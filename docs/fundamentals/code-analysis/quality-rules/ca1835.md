---
title: 'CA1835: akış tabanlı sınıflarda ReadAsync/WriteAsync yöntemlerinin bellek tabanlı aşırı yüklerini tercih etme (kod analizi)'
description: 'Kod Analizi kuralı CA1835 hakkında bilgi edinin: akış tabanlı sınıflarda ReadAsync/WriteAsync yöntemlerinin bellek tabanlı aşırı yüklemelerini tercih etme'
ms.date: 05/11/2020
ms.topic: reference
f1_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
helpviewer_keywords:
- PreferStreamAsyncMemoryOverloads
- CA1835
author: carlossanlop
ms.author: calope
dev_langs:
- CSharp
- VB
ms.openlocfilehash: a3730f911f55af27f75ca41a8a9427a29efd0a18
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/25/2020
ms.locfileid: "96588928"
---
# <a name="ca1835-prefer-the-memory-based-overloads-of-readasyncwriteasync-methods-in-stream-based-classes"></a><span data-ttu-id="5999a-103">CA1835: akış tabanlı sınıflarda ReadAsync/WriteAsync yöntemlerinin bellek tabanlı aşırı yüklerini tercih edin</span><span class="sxs-lookup"><span data-stu-id="5999a-103">CA1835: Prefer the memory-based overloads of ReadAsync/WriteAsync methods in stream-based classes</span></span>

| | <span data-ttu-id="5999a-104">Değer</span><span class="sxs-lookup"><span data-stu-id="5999a-104">Value</span></span> |
|-|-|
|<span data-ttu-id="5999a-105">TypeName</span><span class="sxs-lookup"><span data-stu-id="5999a-105">TypeName</span></span>|<span data-ttu-id="5999a-106">PreferStreamAsyncMemoryOverlodas</span><span class="sxs-lookup"><span data-stu-id="5999a-106">PreferStreamAsyncMemoryOverlodas</span></span>|
| <span data-ttu-id="5999a-107">**Kural Kimliği**</span><span class="sxs-lookup"><span data-stu-id="5999a-107">**Rule ID**</span></span> |<span data-ttu-id="5999a-108">CA1835</span><span class="sxs-lookup"><span data-stu-id="5999a-108">CA1835</span></span>|
| <span data-ttu-id="5999a-109">**Kategori**</span><span class="sxs-lookup"><span data-stu-id="5999a-109">**Category**</span></span> |<span data-ttu-id="5999a-110">Microsoft. Performance</span><span class="sxs-lookup"><span data-stu-id="5999a-110">Microsoft.Performance</span></span>|
| <span data-ttu-id="5999a-111">**Düzeltilme veya kırılmamış**</span><span class="sxs-lookup"><span data-stu-id="5999a-111">**Fix is breaking or non-breaking**</span></span> |<span data-ttu-id="5999a-112">Kırılmamış</span><span class="sxs-lookup"><span data-stu-id="5999a-112">Non-breaking</span></span>|

## <a name="cause"></a><span data-ttu-id="5999a-113">Nedeni</span><span class="sxs-lookup"><span data-stu-id="5999a-113">Cause</span></span>

<span data-ttu-id="5999a-114">Bu kural, ve için bayt dizi tabanlı yöntem aşırı yüklemelerinin `ReadAsync` `WriteAsync` uyandığı yüklerini bulur ve daha verimli olduklarından bunun yerine bellek tabanlı yöntem aşırı yüklemelerini kullanmayı önerir.</span><span class="sxs-lookup"><span data-stu-id="5999a-114">This rule locates awaited invocations of the byte-array-based method overloads for `ReadAsync` and `WriteAsync`, and suggests using the memory-based method overloads instead, because they are more efficient.</span></span>

## <a name="rule-description"></a><span data-ttu-id="5999a-115">Kural açıklaması</span><span class="sxs-lookup"><span data-stu-id="5999a-115">Rule description</span></span>

<span data-ttu-id="5999a-116">Bellek tabanlı yöntem aşırı yüklemeleri, bayt dizisi tabanlı olanlardan daha verimli bir bellek kullanımına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5999a-116">The memory-based method overloads have a more efficient memory usage than the byte array-based ones.</span></span>

<span data-ttu-id="5999a-117">Kural, ' `ReadAsync` `WriteAsync` den devralan herhangi bir sınıfın üzerinde ve çağırmaları üzerinde çalışma yapılır <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="5999a-117">The rule works on `ReadAsync` and `WriteAsync` invocations of any class that inherits from <xref:System.IO.Stream>.</span></span>

<span data-ttu-id="5999a-118">Kural yalnızca metodun anahtar sözcüğünün önünde olduğu durumlarda işe yarar `await` .</span><span class="sxs-lookup"><span data-stu-id="5999a-118">The rule only works when the method is preceded by the `await` keyword.</span></span>

|<span data-ttu-id="5999a-119">Algılanan Yöntem</span><span class="sxs-lookup"><span data-stu-id="5999a-119">Detected method</span></span>|<span data-ttu-id="5999a-120">Önerilen Yöntem</span><span class="sxs-lookup"><span data-stu-id="5999a-120">Suggested method</span></span>|
|-|-|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)>|<span data-ttu-id="5999a-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)>`CancellationToken` `default` C# ' de veya Visual Basic ' de olarak ayarlanır `Nothing` .</span><span class="sxs-lookup"><span data-stu-id="5999a-121"><xref:System.IO.Stream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>|
|<xref:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)>|<span data-ttu-id="5999a-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)>`CancellationToken` `default` C# ' de veya Visual Basic ' de olarak ayarlanır `Nothing` .</span><span class="sxs-lookup"><span data-stu-id="5999a-122"><xref:System.IO.Stream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)> with `CancellationToken` set to `default` in C#, or `Nothing` in Visual Basic.</span></span>|

> [!IMPORTANT]
> <span data-ttu-id="5999a-123">`offset`Ve `count` tamsayı bağımsız değişkenlerini oluşturulan `Memory` veya örneklere geçirdiğinizden emin olun `ReadOnlyMemory` .</span><span class="sxs-lookup"><span data-stu-id="5999a-123">Make sure to pass the `offset` and `count` integer arguments to the created `Memory` or `ReadOnlyMemory` instances.</span></span>

> [!NOTE]
> <span data-ttu-id="5999a-124">Kural CA1835, bellek tabanlı aşırı yüklemelerin kullanılabildiği tüm .NET sürümlerinde kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="5999a-124">Rule CA1835 is available in all .NET versions where the memory-based overloads are available:</span></span>
>
> - <span data-ttu-id="5999a-125">.NET Standard 2,1 ve üzeri.</span><span class="sxs-lookup"><span data-stu-id="5999a-125">.NET Standard 2.1 and above.</span></span>
> - <span data-ttu-id="5999a-126">.NET Core 2,1 ve üzeri.</span><span class="sxs-lookup"><span data-stu-id="5999a-126">.NET Core 2.1 and above.</span></span>

## <a name="how-to-fix-violations"></a><span data-ttu-id="5999a-127">İhlalleri çözme</span><span class="sxs-lookup"><span data-stu-id="5999a-127">How to fix violations</span></span>

<span data-ttu-id="5999a-128">Bunları el ile giderebilir veya yöntem çağrısının yanında görüntülenen ampul üzerine gelerek ve önerilen değişikliği seçerek Visual Studio 'Nun sizin için bunu yapmasına izin verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5999a-128">You can either fix them manually, or you can opt to let Visual Studio do it for you, by hovering over the light bulb that shows up next to the method invocation, and selecting the suggested change.</span></span> <span data-ttu-id="5999a-129">Örnek:</span><span class="sxs-lookup"><span data-stu-id="5999a-129">Example:</span></span>

![CA1835 için kod onarımı-akış tabanlı sınıflarda ReadAsync/WriteAsync yöntemlerinin bellek tabanlı aşırı yüklemelerini tercih edin](media/ca1835-codefix.png)

<span data-ttu-id="5999a-131">Kural, ve yöntemleri için çeşitli ihlaller tespit edebilir `ReadAsync` `WriteAsync` .</span><span class="sxs-lookup"><span data-stu-id="5999a-131">The rule can detect a variety of violations for the `ReadAsync` and `WriteAsync` methods.</span></span> <span data-ttu-id="5999a-132">Kuralın algılayabildiği servis taleplerine örnek olarak şunlar verilebilir:</span><span class="sxs-lookup"><span data-stu-id="5999a-132">Here are examples of the cases that the rule can detect:</span></span>

### <a name="example-1"></a><span data-ttu-id="5999a-133">Örnek 1</span><span class="sxs-lookup"><span data-stu-id="5999a-133">Example 1</span></span>

<span data-ttu-id="5999a-134">`ReadAsync`Bağımsız değişken olmadan ve ile çağırma `CancellationToken` :</span><span class="sxs-lookup"><span data-stu-id="5999a-134">Invocations of `ReadAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer, 0, buffer.Length);
            await s.ReadAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="5999a-135">Onar</span><span class="sxs-lookup"><span data-stu-id="5999a-135">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            byte[] buffer = new byte[s.Length];
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length));
            await s.ReadAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-2"></a><span data-ttu-id="5999a-136">Örnek 2</span><span class="sxs-lookup"><span data-stu-id="5999a-136">Example 2</span></span>

<span data-ttu-id="5999a-137">`WriteAsync`Bağımsız değişken olmadan ve ile çağırma `CancellationToken` :</span><span class="sxs-lookup"><span data-stu-id="5999a-137">Invocations of `WriteAsync`, without and with a `CancellationToken` argument:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod(CancellationToken ct)
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer, 0, buffer.Length);
            await s.WriteAsync(buffer, 0, buffer.Length, ct);
        }
    }
}
```

<span data-ttu-id="5999a-138">Onar</span><span class="sxs-lookup"><span data-stu-id="5999a-138">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length));
            await s.WriteAsync(buffer.AsMemory(0, buffer.Length), ct);
        }
    }
}
```

### <a name="example-3"></a><span data-ttu-id="5999a-139">Örnek 3</span><span class="sxs-lookup"><span data-stu-id="5999a-139">Example 3</span></span>

<span data-ttu-id="5999a-140">İle çağırma `ConfigureAwait` :</span><span class="sxs-lookup"><span data-stu-id="5999a-140">Invocations with `ConfigureAwait`:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1, 0, buffer1.Length).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2, 0, buffer2.Length).ConfigureAwait(true);
        }
    }
}
```

<span data-ttu-id="5999a-141">Onar</span><span class="sxs-lookup"><span data-stu-id="5999a-141">Fix:</span></span>

```cs
using System;
using System.IO;
using System.Threading;

class MyClass
{
    public async void MyMethod()
    {
        using (FileStream s = File.Open("path.txt", FileMode.Open))
        {
            byte[] buffer1 = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
            await s.WriteAsync(buffer1.AsMemory(0, buffer1.Length)).ConfigureAwait(false);

            byte[] buffer2 = new byte[s.Length];
            await s.ReadAsync(buffer2.AsMemory(0, buffer.Length)).ConfigureAwait(true);
        }
    }
}
```

## <a name="non-violations"></a><span data-ttu-id="5999a-142">İhlal olmayan</span><span class="sxs-lookup"><span data-stu-id="5999a-142">Non-violations</span></span>

<span data-ttu-id="5999a-143">Kuralın **tetiklenmeyecek bazı** çağırma örnekleri aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5999a-143">Following are some examples of invocations where the rule will **not** be fired.</span></span>

<span data-ttu-id="5999a-144">Dönüş değeri, `Task` beklenmekte olması yerine bir değişkene kaydedilir:</span><span class="sxs-lookup"><span data-stu-id="5999a-144">The return value is saved in a `Task` variable instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            Task t = s.WriteAsync(buffer, 0, buffer.Length);
        }
    }
}
```

<span data-ttu-id="5999a-145">Dönüş değeri, beklenmek yerine sarmalama yöntemi tarafından döndürülür:</span><span class="sxs-lookup"><span data-stu-id="5999a-145">The return value is returned by the wrapping method instead of being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public Task MyMethod(FileStream s, byte[] buffer)
    {
        return s.WriteAsync(buffer, 0, buffer.Length);
    }
}
```

<span data-ttu-id="5999a-146">Dönüş değeri, beklenen yöntem olan çağırmak için kullanılır `ContinueWith` :</span><span class="sxs-lookup"><span data-stu-id="5999a-146">The return value is used to call `ContinueWith`, which is the method being awaited:</span></span>

```cs
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

class MyClass
{
    public void MyMethod()
    {
        byte[] buffer = { 0xBA, 0x5E, 0xBA, 0x11, 0xF0, 0x07, 0xBA, 0x11 };
        using (FileStream s = new FileStream("path.txt", FileMode.Create))
        {
            await s.WriteAsync(buffer, 0, buffer.Length).ContinueWith(c => { /* ... */ });
        }
    }
}
```

## <a name="when-to-suppress-warnings"></a><span data-ttu-id="5999a-147">Uyarıların ne zaman bastırılamıyor</span><span class="sxs-lookup"><span data-stu-id="5999a-147">When to suppress warnings</span></span>

<span data-ttu-id="5999a-148">Stream tabanlı sınıflarda arabellekleri okurken veya yazarken performansı artırma konusunda endişe ediyorsanız, bu kural ihlalinin görünmemesi daha güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="5999a-148">It's safe to suppress a violation of this rule if you're not concerned about improving performance when reading or writing buffers in stream-based classes.</span></span>

## <a name="see-also"></a><span data-ttu-id="5999a-149">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="5999a-149">See also</span></span>

- [<span data-ttu-id="5999a-150">Performans kuralları</span><span class="sxs-lookup"><span data-stu-id="5999a-150">Performance rules</span></span>](performance-warnings.md)
