---
title: Güvenli ve verimli C# kodu yazma
description: C# dilinde yapılan son geliştirmeler, daha önce güvenli olmayan kodla ilişkili olan doğrulanabilir güvenli kod yazmanızı sağlar.
ms.date: 03/17/2020
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: b739a4ce1f723798cbe50ef9eae673494996751c
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/04/2021
ms.locfileid: "102106624"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="f5102-103">Güvenli ve verimli C# kodu yazma</span><span class="sxs-lookup"><span data-stu-id="f5102-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="f5102-104">C# ' deki yeni özellikler daha iyi performansa sahip doğrulanabilir güvenli kod yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="f5102-105">Bu teknikleri dikkatle uygularsanız, daha az senaryo güvenli olmayan kod gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f5102-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="f5102-106">Bu özellikler, yöntem bağımsız değişkenleri olarak değer türlerine yapılan başvuruların kullanımını kolaylaştırır ve yöntemi döndürür.</span><span class="sxs-lookup"><span data-stu-id="f5102-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="f5102-107">Güvenli bir şekilde bitince, bu teknikler kopyalama değer türlerini en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="f5102-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="f5102-108">Değer türlerini kullanarak, ayırma sayısını ve çöp toplama geçişlerini en aza indirmiş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="f5102-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="f5102-109">Bu makaledeki örnek kodun çoğu C# 7,2 ' de eklenen özellikleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="f5102-110">Bu özellikleri kullanmak için, projenizi C# 7,2 veya sonraki bir sürümünü kullanacak şekilde yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f5102-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="f5102-111">Dil sürümünü ayarlama hakkında daha fazla bilgi için bkz. [dil sürümünü yapılandırma](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="f5102-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="f5102-112">Bu makalede, verimli kaynak yönetimine yönelik teknikler ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="f5102-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="f5102-113">Değer türlerini kullanmanın bir avantajı genellikle yığın ayırmaların önlerinden kaçınmaktır.</span><span class="sxs-lookup"><span data-stu-id="f5102-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="f5102-114">Dezavantajı, değere göre kopyalanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="f5102-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="f5102-115">Bu ticaret, büyük miktarlarda veri üzerinde çalışan algoritmaların iyileştirmesini zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="f5102-115">This trade-off makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="f5102-116">C# 7,2 ' deki yeni dil özellikleri, değer türlerine başvurular kullanarak güvenli verimli kod etkinleştiren mekanizmalar sağlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="f5102-117">Her iki ayırma ve kopyalama işlemini en aza indirmek için bu özellikleri daha seyrek kullanın.</span><span class="sxs-lookup"><span data-stu-id="f5102-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="f5102-118">Bu makalede bu yeni özellikler incelenmektedir.</span><span class="sxs-lookup"><span data-stu-id="f5102-118">This article explores those new features.</span></span>

<span data-ttu-id="f5102-119">Bu makalede aşağıdaki kaynak yönetimi teknikleri ele alınmaktadır:</span><span class="sxs-lookup"><span data-stu-id="f5102-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="f5102-120">Bir [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) türün **sabit** olduğunu bir Express 'e bildirin.</span><span class="sxs-lookup"><span data-stu-id="f5102-120">Declare a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) to express that a type is **immutable**.</span></span> <span data-ttu-id="f5102-121">Bu, derleyicinin parametreleri kullanırken savunma kopyalarının kaydedilmesini sağlar [`in`](language-reference/keywords/in-parameter-modifier.md) .</span><span class="sxs-lookup"><span data-stu-id="f5102-121">That enables the compiler to save defensive copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="f5102-122">Bir tür sabit olamaz, `struct` [`readonly`](language-reference/builtin-types/struct.md#readonly-instance-members) üyenin durumu değiştirmediğini göstermek için üye bildirin.</span><span class="sxs-lookup"><span data-stu-id="f5102-122">If a type can't be immutable, declare `struct` members [`readonly`](language-reference/builtin-types/struct.md#readonly-instance-members) to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="f5102-123">[`ref readonly`](language-reference/keywords/ref.md#reference-return-values)Dönüş değeri `struct` şundan büyük olduğunda <xref:System.IntPtr.Size?displayProperty=nameWithType> ve depolama ömrü değeri döndüren yöntemden büyük olduğunda bir dönüş kullanın.</span><span class="sxs-lookup"><span data-stu-id="f5102-123">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="f5102-124">Bir a 'nın boyutu daha büyükse `readonly struct` <xref:System.IntPtr.Size?displayProperty=nameWithType> , performans nedenleriyle bu parametreyi bir parametre olarak geçirmeniz gerekir `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-124">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="f5102-125">`struct` `in` Değiştirici ile bildirilmemiş `readonly` ya da yöntemi yalnızca yapının üyelerini çağırdığı sürece bir parametre olarak hiçbir şekilde geçirilemez `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f5102-125">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="f5102-126">Bu kılavuzun ihlal olması, performansı olumsuz etkileyebilir ve bu da belirsiz bir davranışa yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="f5102-126">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="f5102-127">Bir [`ref struct`](language-reference/builtin-types/struct.md#ref-struct) `readonly ref struct` <xref:System.Span%601> <xref:System.ReadOnlySpan%601> bayt dizisi olarak bellekle çalışmak için veya gibi bir kullanın.</span><span class="sxs-lookup"><span data-stu-id="f5102-127">Use a [`ref struct`](language-reference/builtin-types/struct.md#ref-struct), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="f5102-128">Bu teknikler, **başvuru** ve **değer** açısından birbiriyle rekabet eden iki hedefi dengelemenize zorlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-128">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="f5102-129">[Başvuru türleri](programming-guide/types/index.md#reference-types) olan değişkenler bellekteki konuma bir başvuru tutar.</span><span class="sxs-lookup"><span data-stu-id="f5102-129">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="f5102-130">[Değer türleri](programming-guide/types/index.md#value-types) olan değişkenler doğrudan değerlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="f5102-130">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="f5102-131">Bu farklılıklar, bellek kaynaklarını yönetmek için önemli olan önemli farklılıkları vurgulamaktadır.</span><span class="sxs-lookup"><span data-stu-id="f5102-131">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="f5102-132">**Değer türleri** genellikle bir yönteme geçirildiğinde veya bir yöntemden döndürüldüğünde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-132">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="f5102-133">Bu davranış, `this` bir değer türünün üyelerini çağırırken değerini kopyalamayı içerir.</span><span class="sxs-lookup"><span data-stu-id="f5102-133">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="f5102-134">Kopyanın maliyeti, türün boyutuyla ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="f5102-134">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="f5102-135">**Başvuru türleri** yönetilen yığında ayrılır.</span><span class="sxs-lookup"><span data-stu-id="f5102-135">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="f5102-136">Her yeni bir nesne için yeni bir ayırma gerekir ve ardından geri kazanılır.</span><span class="sxs-lookup"><span data-stu-id="f5102-136">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="f5102-137">Bu işlemlerin her ikisi de zaman alır.</span><span class="sxs-lookup"><span data-stu-id="f5102-137">Both these operations take time.</span></span> <span data-ttu-id="f5102-138">Başvuru, bir yönteme bir bağımsız değişken olarak geçirildiğinde veya bir yöntemden döndürüldüğünde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-138">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="f5102-139">Bu makalede, bu önerileri açıklamak için 3B nokta yapısının aşağıdaki örnek kavramı kullanılmaktadır:</span><span class="sxs-lookup"><span data-stu-id="f5102-139">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="f5102-140">Farklı örnekler bu kavramın farklı uygulamalarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-140">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="f5102-141">Değişmez değer türleri için salt okunur yapılar bildirme</span><span class="sxs-lookup"><span data-stu-id="f5102-141">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="f5102-142">Değiştirici kullanarak bir bildirmek, `struct` `readonly` derleyicinin, sabit bir tür oluşturmak için olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="f5102-142">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="f5102-143">Derleyici, aşağıdaki kurallarla bu tasarım kararı uygular:</span><span class="sxs-lookup"><span data-stu-id="f5102-143">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="f5102-144">Tüm alan üyeleri olmalıdır `readonly`</span><span class="sxs-lookup"><span data-stu-id="f5102-144">All field members must be `readonly`</span></span>
- <span data-ttu-id="f5102-145">Otomatik uygulanan özellikler dahil olmak üzere tüm özellikler salt okunabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f5102-145">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="f5102-146">Bu iki kural, hiçbir üyenin `readonly struct` Bu yapının durumunu değiştirmemesini sağlamak için yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="f5102-146">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="f5102-147">`struct`Sabittir.</span><span class="sxs-lookup"><span data-stu-id="f5102-147">The `struct` is immutable.</span></span> <span data-ttu-id="f5102-148">`Point3D`Yapı, aşağıdaki örnekte gösterildiği gibi değişmez bir yapı olarak tanımlanabilir:</span><span class="sxs-lookup"><span data-stu-id="f5102-148">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="f5102-149">Tasarım amacınızda sabit değer türü oluşturmak her seferinde bu öneriyi izleyin.</span><span class="sxs-lookup"><span data-stu-id="f5102-149">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="f5102-150">Tüm performans geliştirmeleri, ek bir avantajdır.</span><span class="sxs-lookup"><span data-stu-id="f5102-150">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="f5102-151">`readonly struct`Tasarım amacınızı açıkça ifade eder.</span><span class="sxs-lookup"><span data-stu-id="f5102-151">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="f5102-152">Bir yapı sabit olamaz, salt okunur Üyeler bildirin</span><span class="sxs-lookup"><span data-stu-id="f5102-152">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="f5102-153">C# 8,0 ve üzeri sürümlerde, bir struct türü değişebilir olduğunda, bir yapının olmasına neden olmayan Üyeler bildirmeniz gerekir `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f5102-153">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="f5102-154">3B nokta yapısına ihtiyacı olan, ancak değişikliğe neden olması gereken farklı bir uygulama düşünün.</span><span class="sxs-lookup"><span data-stu-id="f5102-154">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="f5102-155">Aşağıdaki 3B nokta yapısının sürümü, `readonly` değiştiricisini yalnızca yapıyı değiştirolmayan üyelere ekler.</span><span class="sxs-lookup"><span data-stu-id="f5102-155">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="f5102-156">Tasarımınızın bazı üyeler tarafından yapı üzerinde yapılan değişiklikleri desteklemesi gerektiğinde bu örneği izleyin, ancak yine de bazı Üyeler üzerinde ReadOnly 'i zorunlu tutmanın avantajlarının olmasını isteyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f5102-156">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="f5102-157">Yukarıdaki örnekte, `readonly` değiştirici, Özellikler ve özellik erişimcileri uygulayabileceğiniz konumların birçoğu gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f5102-157">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="f5102-158">Otomatik uygulanan özellikler kullanırsanız, derleyici, `readonly` `get` okuma-yazma özellikleri için değiştiriciyi değiştirici ekler.</span><span class="sxs-lookup"><span data-stu-id="f5102-158">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="f5102-159">Derleyici, `readonly` yalnızca bir erişimciyle özellikler için otomatik uygulanan özellik bildirimlerine değiştirici ekler `get` .</span><span class="sxs-lookup"><span data-stu-id="f5102-159">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="f5102-160">`readonly`Bulunmamalıdır durumu olmayan üyelere değiştiricisini eklemek, iki ilgili avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-160">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="f5102-161">İlk olarak, derleyici amacınızı zorluyor.</span><span class="sxs-lookup"><span data-stu-id="f5102-161">First, the compiler enforces your intent.</span></span> <span data-ttu-id="f5102-162">Bu üye yapının durumunu mukutamıyorum.</span><span class="sxs-lookup"><span data-stu-id="f5102-162">That member can't mutate the struct's state.</span></span> <span data-ttu-id="f5102-163">İkincisi, derleyici `in` bir üyeye erişirken parametrelerin savunma kopyalarını oluşturmaz `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f5102-163">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="f5102-164">Derleyici, `struct` bir üye tarafından değiştirilmediğini garanti ettiğinden, bu iyileştirmeyi güvenli hale getirir `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f5102-164">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="f5102-165">`ref readonly return`Mümkün olduğunda büyük yapılar için deyimleri kullanın</span><span class="sxs-lookup"><span data-stu-id="f5102-165">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="f5102-166">Döndürülmekte olan değer döndürülen yönteme yerel olmadığında, değerleri başvuruya göre döndürebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-166">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="f5102-167">Başvuruya göre döndürme, yapıyı değil yalnızca başvurunun kopyalandığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f5102-167">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="f5102-168">Aşağıdaki örnekte, `Origin` `ref` döndürülen değer yerel bir değişken olduğundan, özellik bir return kullanamaz:</span><span class="sxs-lookup"><span data-stu-id="f5102-168">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="f5102-169">Ancak, döndürülen değer statik bir üye olduğu için aşağıdaki özellik tanımı başvuru ile döndürülebilir:</span><span class="sxs-lookup"><span data-stu-id="f5102-169">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="f5102-170">Çağıranların kaynağı değiştirmesini istemezsiniz, bu nedenle değeri şu şekilde döndürmelisiniz `ref readonly` :</span><span class="sxs-lookup"><span data-stu-id="f5102-170">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="f5102-171">Döndürme `ref readonly` , daha büyük yapıları kaydetmenizi ve iç veri üyelerinizin dengeszlik durumunu korumanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-171">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="f5102-172">Çağıran sitede, arayıcılar `Origin` özelliği bir veya değeri olarak kullanma seçeneğini yapar `ref readonly` :</span><span class="sxs-lookup"><span data-stu-id="f5102-172">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="f5102-173">Önceki koddaki ilk atama, sabitin bir kopyasını oluşturur `Origin` ve bu kopyayı atar.</span><span class="sxs-lookup"><span data-stu-id="f5102-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="f5102-174">İkincisi bir başvuru atar.</span><span class="sxs-lookup"><span data-stu-id="f5102-174">The second assigns a reference.</span></span> <span data-ttu-id="f5102-175">`readonly`Değiştiricinin, değişkenin bildiriminin bir parçası olması gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f5102-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="f5102-176">Başvurduğu başvuru değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="f5102-176">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="f5102-177">Bunun için denemeler, derleme zamanı hatasına neden olacak.</span><span class="sxs-lookup"><span data-stu-id="f5102-177">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="f5102-178">`readonly`' İn bildiriminde değiştirici gereklidir `originReference` .</span><span class="sxs-lookup"><span data-stu-id="f5102-178">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="f5102-179">Derleyici, çağıranın başvuruyu değiştiremiyorum.</span><span class="sxs-lookup"><span data-stu-id="f5102-179">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="f5102-180">Değer atama denemeleri doğrudan derleme zamanı hatası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f5102-180">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="f5102-181">Diğer durumlarda derleyici, salt okunur başvuruyu güvenli bir şekilde kullanmadığı takdirde bir savunma kopyası ayırır.</span><span class="sxs-lookup"><span data-stu-id="f5102-181">In other cases, the compiler allocates a defensive copy unless it can safely use the readonly reference.</span></span> <span data-ttu-id="f5102-182">Statik analiz kuralları yapının değiştirilip değiştirilemeyeceğini belirlenir.</span><span class="sxs-lookup"><span data-stu-id="f5102-182">Static analysis rules determine if the struct could be modified.</span></span> <span data-ttu-id="f5102-183">Derleyici, yapı bir öğesi olduğunda `readonly struct` veya üye yapının bir üyesiyse bir savunma kopyası oluşturmaz `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f5102-183">The compiler doesn't create a defensive copy when the struct is a `readonly struct` or the member is a `readonly` member of the struct.</span></span> <span data-ttu-id="f5102-184">Bir bağımsız değişken olarak yapının iletilmesi için savunma kopyalarının gerekli değildir `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-184">Defensive copies aren't needed to pass the struct as an `in` argument.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="f5102-185">`in`Değiştiricisini `readonly struct` şundan büyük parametrelere Uygula`System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="f5102-185">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="f5102-186">`in`Anahtar sözcüğü, `ref` `out` bağımsız değişkenleri başvuruya göre geçirmek için var olan ve anahtar kelimeleri tamamlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-186">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="f5102-187">`in`Anahtar sözcüğü, bağımsız değişkeni başvuruya göre geçirmeyi belirtir, ancak çağrılan yöntem değeri değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="f5102-187">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="f5102-188">Bu ek, tasarım amacınızı ifade etmek için tam bir sözlük sağlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-188">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="f5102-189">Değer türleri, yöntem imzasında Aşağıdaki değiştiricilerin hiçbirini belirtmezseniz, çağrılan bir yönteme geçirildiğinde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-189">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="f5102-190">Bu değiştiricilerin her biri, bir değişkenin başvuruya göre geçtiğini belirtir ve kopyalama önlenir.</span><span class="sxs-lookup"><span data-stu-id="f5102-190">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="f5102-191">Her değiştirici farklı bir amacı ifade eder:</span><span class="sxs-lookup"><span data-stu-id="f5102-191">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="f5102-192">`out`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-192">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="f5102-193">`ref`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f5102-193">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="f5102-194">`in`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="f5102-194">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="f5102-195">`in`Bir bağımsız değişkeni başvuruya göre geçirme değiştiricisini ekleyin ve gereksiz kopyalama olmaması için bağımsız değişkenleri başvuruya göre iletmek üzere tasarım amacınızı bildirin.</span><span class="sxs-lookup"><span data-stu-id="f5102-195">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="f5102-196">Bu bağımsız değişken olarak kullanılan nesneyi değiştirmeyi düşünmüyorsanız.</span><span class="sxs-lookup"><span data-stu-id="f5102-196">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="f5102-197">Bu uygulama genellikle öğesinden daha büyük salt okunur değer türleri için performansı geliştirir <xref:System.IntPtr.Size?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="f5102-197">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f5102-198">Basit türler (,,,,,,, `sbyte` ,, `byte` ,, `short` ve ve `ushort` `int` `uint` `long` `ulong` `char` `float` `double` `decimal` `bool` `enum` türleri) için olası performans kazançları en az düzeydedir.</span><span class="sxs-lookup"><span data-stu-id="f5102-198">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="f5102-199">Aslında, daha küçük türler için başvuruyla geçir kullanılarak performans düşebilir <xref:System.IntPtr.Size?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="f5102-199">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="f5102-200">Aşağıdaki kod, 3B alanda iki işaret arasındaki mesafeyi hesaplayan bir yöntem örneği gösterir.</span><span class="sxs-lookup"><span data-stu-id="f5102-200">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="f5102-201">Bağımsız değişkenler, her biri üç Double içeren iki yapıya sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f5102-201">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="f5102-202">Çift 8 bayttır, bu nedenle her bağımsız değişken 24 bayttır.</span><span class="sxs-lookup"><span data-stu-id="f5102-202">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="f5102-203">`in`Değiştiricisini belirterek, makinenin mimarisine bağlı olarak bu bağımsız değişkenlere 4 baytlık veya 8 baytlık bir başvuru geçirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-203">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="f5102-204">Boyut farkı küçüktür, ancak uygulamanız bu yöntemi birçok farklı değer kullanarak sıkı bir döngüde çağırdığında ekler.</span><span class="sxs-lookup"><span data-stu-id="f5102-204">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="f5102-205">`in`Değiştirici, `out` `ref` diğer yollarla da tamamlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-205">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="f5102-206">Yalnızca, veya varlığının farklı olduğu bir yöntemin aşırı yüklerini oluşturamazsınız `in` `out` `ref` .</span><span class="sxs-lookup"><span data-stu-id="f5102-206">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="f5102-207">Bu yeni kurallar, ve parametreleri için her zaman tanımlanan davranışı genişletir `out` `ref` .</span><span class="sxs-lookup"><span data-stu-id="f5102-207">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="f5102-208">`out`Ve değiştiricileri gibi `ref` , değiştirici uygulandığından değer türleri kutulanmış değildir `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-208">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="f5102-209">`in`Değiştirici parametre alan herhangi bir üyeye uygulanabilir: Yöntemler, temsilciler, Lambdalar, yerel işlevler, Dizin oluşturucular, işleçler.</span><span class="sxs-lookup"><span data-stu-id="f5102-209">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="f5102-210">Parametrelerin başka bir özelliği, `in` bir parametreye bağımsız değişken için değişmez değer veya sabitler kullanmanıza olanak sağlar `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-210">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="f5102-211">Ayrıca, `ref` veya parametresinden farklı olarak `out` , `in` çağırma sitesinde değiştiriciyi uygulamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="f5102-211">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="f5102-212">Aşağıdaki kod, yöntemi çağırmanın iki örneğini göstermektedir `CalculateDistance` .</span><span class="sxs-lookup"><span data-stu-id="f5102-212">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="f5102-213">İlki, başvuruya göre geçirilen iki yerel değişkeni kullanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-213">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="f5102-214">İkincisi, yöntem çağrısının bir parçası olarak oluşturulan geçici bir değişken içerir.</span><span class="sxs-lookup"><span data-stu-id="f5102-214">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="f5102-215">Derleyicinin bir bağımsız değişkenin salt okunurdur yapısını zorladığı çeşitli yollar vardır `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-215">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="f5102-216">İlki, çağrılan yöntem bir parametreye doğrudan atanamaz `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-216">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="f5102-217">`in`Bu değer bir tür olduğunda, parametrenin hiçbir alanına doğrudan atayamaz `struct` .</span><span class="sxs-lookup"><span data-stu-id="f5102-217">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="f5102-218">Ayrıca, `in` veya değiştiricisini kullanarak herhangi bir yönteme bir parametre geçiremezsiniz `ref` `out` .</span><span class="sxs-lookup"><span data-stu-id="f5102-218">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="f5102-219">Bu kurallar, bir parametrenin her alanı için geçerlidir `in` , ancak alan bir `struct` tür ve parametre de bir `struct` tür.</span><span class="sxs-lookup"><span data-stu-id="f5102-219">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="f5102-220">Aslında, tüm üye erişimi düzeylerindeki türler sağlanmış olan bu kurallar birden çok üye erişimi katmanı için geçerlidir `structs` .</span><span class="sxs-lookup"><span data-stu-id="f5102-220">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="f5102-221">Derleyici, `struct` bağımsız değişken olarak geçirilen türleri  `in` ve `struct` üyeleri diğer yöntemlere bağımsız değişkenler olarak kullanıldığında salt okuma değişkenleridir.</span><span class="sxs-lookup"><span data-stu-id="f5102-221">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="f5102-222">Parametrelerin kullanımı, `in` kopya yapmanın olası performans maliyetlerinden kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="f5102-222">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="f5102-223">Herhangi bir yöntem çağrısının semantiğini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="f5102-223">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="f5102-224">Bu nedenle, `in` Çağrı sitesinde değiştiricisini belirtmeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="f5102-224">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="f5102-225">`in`Çağrı sitesinde değiştiricinin atlanması derleyicinin aşağıdaki nedenlerden dolayı bağımsız değişkenin bir kopyasını yapmasına izin verildiğini bildirir:</span><span class="sxs-lookup"><span data-stu-id="f5102-225">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="f5102-226">Bağımsız değişken türünden parametre türüne bir kimlik dönüştürmesi değil, örtük bir dönüştürme var.</span><span class="sxs-lookup"><span data-stu-id="f5102-226">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="f5102-227">Bağımsız değişken bir ifadedir ancak bilinen bir depolama değişkenine sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="f5102-227">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="f5102-228">Varlığı veya yokluğuna göre farklı bir aşırı yükleme var `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-228">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="f5102-229">Bu durumda, değer olarak aşırı yüklemesi daha iyi bir eşleşmedir.</span><span class="sxs-lookup"><span data-stu-id="f5102-229">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="f5102-230">Bu kurallar, var olan kodu salt okuma başvuru bağımsız değişkenlerini kullanacak şekilde güncelleştirdiğinizde yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="f5102-230">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="f5102-231">Çağrılan yöntemin içinde, değer parametrelerine göre kullanan herhangi bir örnek yöntemini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-231">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="f5102-232">Bu örneklerde, parametresinin bir kopyası `in` oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f5102-232">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="f5102-233">Derleyici herhangi bir parametre için geçici bir değişken oluşturabileceğinden `in` , herhangi bir parametre için varsayılan değerleri de belirtebilirsiniz `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-233">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="f5102-234">Aşağıdaki kod, kaynak (nokta 0, 0) ikinci nokta için varsayılan değer olarak belirtir:</span><span class="sxs-lookup"><span data-stu-id="f5102-234">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="f5102-235">Derleyiciye başvuruya göre salt okuma bağımsız değişkenlerini geçirmeye zorlamak için, `in` aşağıdaki kodda gösterildiği gibi, çağrı sitesindeki bağımsız değişkenlerde değiştirici belirtin:</span><span class="sxs-lookup"><span data-stu-id="f5102-235">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="f5102-236">Bu davranış `in` , performans kazançlarının mümkün olduğu büyük kod tabanlarında zaman içindeki parametreleri benimsemeyi kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="f5102-236">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="f5102-237">`in`Önce Yöntem imzalarına değiştiricisini eklersiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-237">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="f5102-238">Daha sonra, `in` `readonly struct` `in` daha fazla konumda parametrelerin savunma kopyalarının oluşturulmasını önlemek için, derleyiciyi çağıran sitelere ve oluşturma türlerine ekleme değiştiricisini ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-238">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="f5102-239">`in`Parametre ataması ayrıca başvuru türleri veya sayısal değerlerle birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f5102-239">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="f5102-240">Ancak, her iki durumda da avantajlar, varsa en az düzeydedir.</span><span class="sxs-lookup"><span data-stu-id="f5102-240">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="f5102-241">Bağımsız değişken olarak değişebilir yapıların önüne kaçının `in`</span><span class="sxs-lookup"><span data-stu-id="f5102-241">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="f5102-242">Yukarıda açıklanan teknikler, başvuruları döndürerek ve değerlere başvuruya göre geçirerek kopyaların nasıl önleneceğini açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="f5102-242">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="f5102-243">Bağımsız değişken türleri tür olarak bildirildiğinde bu teknikler en iyi şekilde çalışır `readonly struct` .</span><span class="sxs-lookup"><span data-stu-id="f5102-243">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="f5102-244">Aksi takdirde, derleyicinin herhangi bir bağımsız değişken için salt okunur hale getirilmesi zorunlu kılmak için birçok durumda **savunma kopyaları** oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f5102-244">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="f5102-245">Bir 3B noktanın kaynaktan uzaklığını hesaplayan aşağıdaki örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f5102-245">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="f5102-246">`Point3D`Yapı ReadOnly bir struct *değil* .</span><span class="sxs-lookup"><span data-stu-id="f5102-246">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="f5102-247">Bu yöntemin gövdesinde altı farklı özellik erişim çağrısı vardır.</span><span class="sxs-lookup"><span data-stu-id="f5102-247">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="f5102-248">İlk inceleme durumunda bu erişimlerin güvenli olduğunu düşündük.</span><span class="sxs-lookup"><span data-stu-id="f5102-248">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="f5102-249">Bütün olarak, `get` erişimci nesnenin durumunu değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="f5102-249">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="f5102-250">Ancak bunu zorlayan bir dil kuralı yoktur.</span><span class="sxs-lookup"><span data-stu-id="f5102-250">But there's no language rule that enforces that.</span></span> <span data-ttu-id="f5102-251">Yalnızca ortak bir kuraldır.</span><span class="sxs-lookup"><span data-stu-id="f5102-251">It's only a common convention.</span></span> <span data-ttu-id="f5102-252">Herhangi bir tür `get` , iç durumu değiştiren bir erişimci uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="f5102-252">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="f5102-253">Bazı dil garantisi olmadan, değiştiriciyle işaretlenmemiş bir üyeyi çağırmadan önce derleyicinin bağımsız değişkenin geçici bir kopyasını oluşturması gerekir `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f5102-253">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="f5102-254">Geçici depolama, yığında oluşturulur, bağımsız değişkenin değerleri geçici depolamaya kopyalanır ve değer bağımsız değişken olarak her üye erişimi için yığına kopyalanır `this` .</span><span class="sxs-lookup"><span data-stu-id="f5102-254">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="f5102-255">Birçok durumda, bu, bağımsız değişken türü bir olmadığında `readonly struct` ve yöntemi işaretlenmeyen üyeleri çağırdığında, bu kopya değere göre geçiş-salt okunur başvuruya göre daha hızlı bir şekilde bir performans sağlar `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f5102-255">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="f5102-256">Yapı durumunu değiştirmeyin tüm yöntemleri olarak işaretlerseniz `readonly` , derleyici yapı durumunun değiştirilmediğini güvenli bir şekilde belirleyebilir ve savunma kopyası gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="f5102-256">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="f5102-257">Bunun yerine, uzaklık hesaplaması değişmez yapıyı kullanıyorsa `ReadonlyPoint3D` geçici nesneler gerekmez:</span><span class="sxs-lookup"><span data-stu-id="f5102-257">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="f5102-258">Bir öğesinin üyelerini çağırdığınızda derleyici daha verimli kod üretir `readonly struct` : `this` başvurunun bir kopyası yerine, her zaman `in` üye metoduna başvuru tarafından geçirilen bir parametre.</span><span class="sxs-lookup"><span data-stu-id="f5102-258">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="f5102-259">Bu iyileştirme, bir `readonly struct` bağımsız değişken olarak kullandığınızda kopyalamayı kaydeder `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-259">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="f5102-260">Null yapılabilir bir değer türünü bağımsız değişken olarak geçirmemelisiniz `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-260">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="f5102-261"><xref:System.Nullable%601>Tür salt okunurdur struct olarak bildirilmemiş.</span><span class="sxs-lookup"><span data-stu-id="f5102-261">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="f5102-262">Bu, derleyicinin parametre bildiriminde değiştirici kullanılarak bir yönteme geçirilen herhangi bir Nullable değer türü bağımsız değişkeni için savunma kopyaları oluşturması gerektiği anlamına gelir `in` .</span><span class="sxs-lookup"><span data-stu-id="f5102-262">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="f5102-263">GitHub 'daki [örnek depolarımızda](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) , [benchmarkdotnet](https://www.nuget.org/packages/BenchmarkDotNet/) kullanarak performans farklarını gösteren bir örnek program görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-263">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="f5102-264">Değere ve başvuruya göre değişmez bir struct geçirilerek başvuruya göre kesilebilir bir yapının geçirilmesini karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="f5102-264">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="f5102-265">Değişmez yapının kullanımı ve başvuruya göre Pass en hızlı.</span><span class="sxs-lookup"><span data-stu-id="f5102-265">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="f5102-266">`ref struct`Tek bir yığın çerçevesinde bloklarla veya bellekle çalışmak için türleri kullanma</span><span class="sxs-lookup"><span data-stu-id="f5102-266">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="f5102-267">İlgili dil özelliği, tek bir yığın çerçevesiyle sınırlandırılmak zorunda olması gereken bir değer türü bildirebilmesidir.</span><span class="sxs-lookup"><span data-stu-id="f5102-267">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="f5102-268">Bu kısıtlama derleyicinin birkaç iyileştirme yapmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="f5102-268">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="f5102-269">Bu özellik için birincil mosyon <xref:System.Span%601> ve ilgili yapılar.</span><span class="sxs-lookup"><span data-stu-id="f5102-269">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="f5102-270">Bu geliştirmelerden, türü kullanan yeni ve güncelleştirilmiş .NET API 'Leri kullanarak performans iyileştirmeleri elde edersiniz <xref:System.Span%601> .</span><span class="sxs-lookup"><span data-stu-id="f5102-270">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="f5102-271">[`stackalloc`](language-reference/operators/stackalloc.md)Birlikte çalışma API 'lerinden bellek kullanılırken veya kullanılarak oluşturulmuş bellekle çalışan benzer gereksinimleriniz olabilir.</span><span class="sxs-lookup"><span data-stu-id="f5102-271">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="f5102-272">`ref struct`Bu gereksinimler için kendi türlerinizi tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-272">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="f5102-273">`readonly ref struct` türüyle</span><span class="sxs-lookup"><span data-stu-id="f5102-273">`readonly ref struct` type</span></span>

<span data-ttu-id="f5102-274">Bir yapının `readonly ref` , ve bildirimlerinin avantajları ve kısıtlamalarını birleştiren şekilde `ref struct` Bildirme `readonly struct` .</span><span class="sxs-lookup"><span data-stu-id="f5102-274">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="f5102-275">Salt okunur yayılma alanı tarafından kullanılan bellek tek bir yığın çerçevesiyle kısıtlıdır ve salt okunur olarak kullanılan bellek değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="f5102-275">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="f5102-276">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="f5102-276">Conclusions</span></span>

<span data-ttu-id="f5102-277">Değer türlerini kullanmak, ayırma işlemlerinin sayısını en aza indirir:</span><span class="sxs-lookup"><span data-stu-id="f5102-277">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="f5102-278">Değer türleri için depolama, yerel değişkenler ve Yöntem bağımsız değişkenleri için ayrılmış yığındır.</span><span class="sxs-lookup"><span data-stu-id="f5102-278">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="f5102-279">Diğer nesnelerin üyesi olan değer türleri için depolama alanı, ayrı bir ayırma olarak değil, bu nesnenin bir parçası olarak ayrılır.</span><span class="sxs-lookup"><span data-stu-id="f5102-279">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="f5102-280">Değer türü dönüş değerleri için depolama, yığın olarak ayrıldı.</span><span class="sxs-lookup"><span data-stu-id="f5102-280">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="f5102-281">Aynı durumlarda başvuru türleri ile karşıtlık:</span><span class="sxs-lookup"><span data-stu-id="f5102-281">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="f5102-282">Başvuru türleri için depolama, yerel değişkenler ve Yöntem bağımsız değişkenleri için ayrılır.</span><span class="sxs-lookup"><span data-stu-id="f5102-282">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="f5102-283">Başvuru yığın üzerinde depolanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-283">The reference is stored on the stack.</span></span>
- <span data-ttu-id="f5102-284">Diğer nesnelerin üyesi olan başvuru türleri için depolama, yığın üzerinde ayrı olarak ayrılır.</span><span class="sxs-lookup"><span data-stu-id="f5102-284">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="f5102-285">İçerilen nesne başvuruyu depolar.</span><span class="sxs-lookup"><span data-stu-id="f5102-285">The containing object stores the reference.</span></span>
- <span data-ttu-id="f5102-286">Başvuru türü dönüş değerleri için depolama, yığın olarak ayrıldı.</span><span class="sxs-lookup"><span data-stu-id="f5102-286">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="f5102-287">Bu depolamanın başvurusu yığında depolanır.</span><span class="sxs-lookup"><span data-stu-id="f5102-287">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="f5102-288">En aza indirme ayırmaları, dengelerle gelir.</span><span class="sxs-lookup"><span data-stu-id="f5102-288">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="f5102-289">Boyutu bir başvurunun boyutundan daha büyükse daha fazla bellek kopyalayabilirsiniz `struct` .</span><span class="sxs-lookup"><span data-stu-id="f5102-289">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="f5102-290">Başvuru genellikle 64 bit veya 32 bittir ve hedef makine CPU 'suna bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f5102-290">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="f5102-291">Bu dengeler genellikle en düşük performans etkisine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f5102-291">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="f5102-292">Ancak, büyük yapılar veya daha büyük koleksiyonlar için performans etkisi artar.</span><span class="sxs-lookup"><span data-stu-id="f5102-292">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="f5102-293">Etki, sıkı Döngülerde ve programlar için etkin yollarda büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="f5102-293">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="f5102-294">C# dilinde yapılan bu geliştirmeler, bellek ayırmalarının en aza indirmek için gerekli performansı elde etmek için önemli bir faktör olan performans açısından kritik algoritmalarda tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f5102-294">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="f5102-295">Bu özellikleri genellikle yazdığınız kodda kullanmacağınızı fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f5102-295">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="f5102-296">Ancak, bu geliştirmeler .NET genelinde benimsenmiştir.</span><span class="sxs-lookup"><span data-stu-id="f5102-296">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="f5102-297">Daha fazla API bu özellikleri kullanırken, uygulamalarınızın performansının iyileştireyi görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="f5102-297">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="f5102-298">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="f5102-298">See also</span></span>

- [<span data-ttu-id="f5102-299">ref anahtar sözcüğü</span><span class="sxs-lookup"><span data-stu-id="f5102-299">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="f5102-300">Ref dönüşler ve ref yerel ayarlar</span><span class="sxs-lookup"><span data-stu-id="f5102-300">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
