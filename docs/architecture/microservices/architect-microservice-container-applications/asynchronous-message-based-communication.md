---
title: Zaman uyumsuz ileti tabanlı iletişim
description: .NET Microservices Mimari Containerized .NET Uygulamaları için | Asynchronous mesaj tabanlı iletişim mikrohizmetler mimarisinde önemli bir kavramdır, çünkü mikro hizmetleri birbirinden bağımsız tutmanın en iyi yoludur ve aynı zamanda sonunda senkronize edilir.
ms.date: 09/20/2018
ms.openlocfilehash: 84eaf70178cce91a86dae8a55badb0b4ddd6a7c1
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "73454239"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="40401-103">Zaman uyumsuz ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="40401-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="40401-104">Asynchronous mesajlaşma ve olay odaklı iletişim, değişiklikleri birden çok mikro hizmet ve ilgili etki alanı modellerinde yayırken çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="40401-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="40401-105">Daha önce tartışma mikroservices ve Bounded Contexts (CS) belirtildiği gibi, modeller (Kullanıcı, Müşteri, Ürün, Hesap, vb) farklı mikrohizmetler veya DC'ler için farklı şeyler anlamına gelebilir.</span><span class="sxs-lookup"><span data-stu-id="40401-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="40401-106">Bu, değişiklikler oluştuğunda, değişiklikleri farklı modeller arasında bağdaştırmak için bir yol gerektiğini anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="40401-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="40401-107">Çözüm, eşzamanlı mesajlaşmaya dayalı nihai tutarlılık ve olay odaklı iletişimdir.</span><span class="sxs-lookup"><span data-stu-id="40401-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="40401-108">İleti kullanırken, işlemler iletileri eşit bir şekilde değiştirerek iletişim kurar.</span><span class="sxs-lookup"><span data-stu-id="40401-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="40401-109">İstemci, bir ileti göndererek bir hizmete bir komut veya istekte bulunur.</span><span class="sxs-lookup"><span data-stu-id="40401-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="40401-110">Hizmetin yanıtlaması gerekiyorsa, istemciye farklı bir ileti gönderir.</span><span class="sxs-lookup"><span data-stu-id="40401-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="40401-111">İleti tabanlı bir iletişim olduğundan, istemci yanıtın hemen alınamayacağını ve hiçbir yanıt verilmeyeceğini varsayar.</span><span class="sxs-lookup"><span data-stu-id="40401-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="40401-112">İleti, üstbilgi (kimlik veya güvenlik bilgileri gibi meta veriler) ve bir gövde tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="40401-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="40401-113">İletiler genellikle AMQP gibi eşzamanlı protokoller aracılığıyla gönderilir.</span><span class="sxs-lookup"><span data-stu-id="40401-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="40401-114">Mikro hizmetler topluluğunda bu tür iletişim için tercih edilen altyapı, SOA'da kullanılan büyük broker ve orkestratörlerden farklı olan hafif bir mesaj aracısIdır.</span><span class="sxs-lookup"><span data-stu-id="40401-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="40401-115">Hafif bir ileti aracısında, altyapı genellikle "aptal"dır ve Yalnızca bir mesaj aracısı olarak hareket eder ve TavşanMQ gibi basit uygulamalar veya Azure Servis Veri Servisi gibi bulutta ölçeklenebilir servis veri neşrısı ile hareket eder.</span><span class="sxs-lookup"><span data-stu-id="40401-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="40401-116">Bu senaryoda, "akıllı" düşünmenin çoğu hala mikro hizmetlerde mesaj üreten ve tüketen uç noktalarda yaşamaktadır.</span><span class="sxs-lookup"><span data-stu-id="40401-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="40401-117">İzlemeye çalışmanız gereken bir diğer kural da, dahili hizmetler arasında yalnızca eşzamanlı mesajlaşma kullanmak ve yalnızca istemci uygulamalarından ön uç hizmetlerine (API Ağ Geçitleri artı birinci düzey) eşzamanlı iletişim kullanmaktır. mikro hizmetler).</span><span class="sxs-lookup"><span data-stu-id="40401-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="40401-118">İki tür eşzamanlı ileti iletişimi vardır: tek alıcılı ileti tabanlı iletişim ve birden çok alıcı ileti tabanlı iletişim.</span><span class="sxs-lookup"><span data-stu-id="40401-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="40401-119">Aşağıdaki bölümlerde onlar hakkında ayrıntılı bilgi verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="40401-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="40401-120">Tek alıcılı ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="40401-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="40401-121">Tek bir alıcıyla ileti tabanlı eşzamanlı iletişim, kanaldan okuyan tüketicilerden tam olarak birine ileti gönderen ve iletinin sadece bir kez işlendiği noktadan noktaya iletişim anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="40401-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="40401-122">Ancak, özel durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="40401-122">However, there are special situations.</span></span> <span data-ttu-id="40401-123">Örneğin, hataları otomatik olarak kurtarmaya çalışan bir bulut sisteminde, aynı ileti birden çok kez gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="40401-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="40401-124">Ağ veya diğer hatalar nedeniyle istemcinin ileti göndermeyi yeniden denemesi gerekir ve sunucunun belirli bir iletiyi yalnızca bir kez işlemek için idempotent olması için bir işlem uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="40401-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="40401-125">Tek alıcılı ileti tabanlı iletişim, şekil 4-18'de gösterildiği gibi, bir mikro hizmetten diğerine asenkron komutlar göndermek için özellikle uygundur.</span><span class="sxs-lookup"><span data-stu-id="40401-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="40401-126">İleti tabanlı iletişim göndermeye başladığınızda (komutlar veya olaylarla), ileti tabanlı iletişimi eşzamanlı HTTP iletişimiyle karıştırmaktan kaçınmalısınız.</span><span class="sxs-lookup"><span data-stu-id="40401-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Eşzamanlı mesaj alan tek bir mikro hizmet](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="40401-128">**Şekil 4-18**.</span><span class="sxs-lookup"><span data-stu-id="40401-128">**Figure 4-18**.</span></span> <span data-ttu-id="40401-129">Eşzamanlı mesaj alan tek bir mikro hizmet</span><span class="sxs-lookup"><span data-stu-id="40401-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="40401-130">Komutlar istemci uygulamalarından geldiğinde, http senkron komutları olarak uygulanabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="40401-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="40401-131">Daha yüksek ölçeklenebilirliğe ihtiyacınız olduğunda veya ileti tabanlı bir iş sürecindeolduğunuzda ileti tabanlı komutlar kullanmalısınız.</span><span class="sxs-lookup"><span data-stu-id="40401-131">You should use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="40401-132">Çoklu alıcılar ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="40401-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="40401-133">Daha esnek bir yaklaşım olarak, gönderenden gelen iletişiminizin ek abone mikro hizmetleri veya harici uygulamalar için kullanılabileceğini bilmek için bir yayımlama/abone verme mekanizması da kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="40401-134">Böylece, gönderme hizmetinde [açık/kapalı ilkeyi](https://en.wikipedia.org/wiki/Open/closed_principle) izlemenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="40401-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="40401-135">Bu şekilde, gönderen hizmetini değiştirmeye gerek kalmadan gelecekte ek aboneler eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="40401-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="40401-136">Yayımla/abone iletişimi kullandığınızda, olayları herhangi bir aboneye yayımlamak için bir olay veri günü arabirimi kullanıyor olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="40401-137">Asynchronous olay odaklı iletişim</span><span class="sxs-lookup"><span data-stu-id="40401-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="40401-138">Eşzamanlı olay odaklı iletişim kullanırken, bir microservice kendi etki alanı içinde bir şey olduğunda bir entegrasyon olayı yayımlar ve başka bir microservice bunun farkında olması gerekir, bir ürün kataloğu microservice bir fiyat değişikliği gibi.</span><span class="sxs-lookup"><span data-stu-id="40401-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="40401-139">Ek mikro hizmetler olaylara abone olur, böylece onları eşzamanlı olarak alabilirler.</span><span class="sxs-lookup"><span data-stu-id="40401-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="40401-140">Bu durumda, alıcılar kendi etki alanı varlıklarını güncelleştirerek daha fazla tümleştirme olayının yayımlanmasını sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="40401-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="40401-141">Bu yayımlama/abone etme sistemi genellikle bir olay veri ceminin inbir uygulaması kullanılarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="40401-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="40401-142">Etkinlik veri veri mesuliyonu, etkinliklere abone olmak veya abone olmak ve olayları yayımlamak için gereken API ile bir soyutlama veya arabirim olarak tasarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="40401-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="40401-143">Olay veri yolunda ayrıca, eşzamanlı iletişimi ve yayımlama/abone etme modelini destekleyen bir mesajlaşma sırası veya servis veri cisi gibi herhangi bir işlem ve mesajlaşma aracısını temel alan bir veya daha fazla uygulama da olabilir.</span><span class="sxs-lookup"><span data-stu-id="40401-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="40401-144">Bir sistem tümleştirme olayları tarafından yönlendirilen nihai tutarlılık kullanıyorsa, bu yaklaşımın son kullanıcıya tamamen açık olması önerilir.</span><span class="sxs-lookup"><span data-stu-id="40401-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made completely clear to the end user.</span></span> <span data-ttu-id="40401-145">Sistem, istemciden gelen SignalR veya yoklama sistemleri gibi tümleştirme olaylarını taklit eden bir yaklaşım kullanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="40401-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="40401-146">Son kullanıcı ve işletme sahibi açıkça sistemde nihai tutarlılık kucaklamak ve birçok durumda iş bu yaklaşım ile herhangi bir sorun olmadığını fark etmek zorunda, sürece açık.</span><span class="sxs-lookup"><span data-stu-id="40401-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="40401-147">Kullanıcılar hemen bazı sonuçlar görmeyi bekleyebilirsiniz ve bu nihai tutarlılık ile olmayabilir, çünkü bu önemlidir.</span><span class="sxs-lookup"><span data-stu-id="40401-147">This is important because users might expect to see some results immediately and this might not happen with eventual consistency.</span></span>

<span data-ttu-id="40401-148">[Dağıtılmış veri yönetimi bölümüiçin Zorluklar ve çözümlerde](distributed-data-management.md) daha önce belirtildiği gibi, birden çok mikro hizmeti kapsayan iş görevlerini uygulamak için tümleştirme olaylarını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="40401-149">Böylece, bu hizmetler arasında nihai tutarlılık olacak.</span><span class="sxs-lookup"><span data-stu-id="40401-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="40401-150">Sonunda tutarlı bir işlem dağıtılmış eylemler koleksiyonundan oluşur.</span><span class="sxs-lookup"><span data-stu-id="40401-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="40401-151">Her eylemde, ilgili microservice bir etki alanı varlığını güncelleştirir ve aynı uçten uca iş görevi içinde bir sonraki eylemi yükselten başka bir tümleştirme olayı yayımlar.</span><span class="sxs-lookup"><span data-stu-id="40401-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="40401-152">Önemli bir nokta, aynı etkinliğe abone olan birden çok mikro hizmetle iletişim kurmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="40401-153">Bunu yapmak için, Şekil 4-19'da gösterildiği gibi, olay odaklı iletişimi temel alan yayımla/abone ol iletisini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="40401-154">Bu yayımlama/abone verme mekanizması mikro hizmet mimarisine özel değildir.</span><span class="sxs-lookup"><span data-stu-id="40401-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="40401-155">DDD'deki [Bağlı Bağlamların](https://martinfowler.com/bliki/BoundedContext.html) iletişim kurma biçimine veya yazma veritabanındaki güncelleştirmeleri [Komut ve Sorgu Sorumluluğu Ayrımı (CQRS)](https://martinfowler.com/bliki/CQRS.html) mimari desenindeki okuma veritabanına yayma şeklinize benzer.</span><span class="sxs-lookup"><span data-stu-id="40401-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="40401-156">Amaç, dağıtılmış sisteminizdeki birden çok veri kaynağı arasında nihai tutarlılık sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="40401-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Eşzamanlı olay odaklı iletişimi gösteren diyagram.](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="40401-158">**Şekil 4-19**.</span><span class="sxs-lookup"><span data-stu-id="40401-158">**Figure 4-19**.</span></span> <span data-ttu-id="40401-159">Asynchronous olay odaklı ileti iletişimi</span><span class="sxs-lookup"><span data-stu-id="40401-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="40401-160">Bir mikro hizmet, etkinlik odaklı iletişimde etkinlikleri bir etkinlik otobüsüne yayınlar ve birçok mikro hizmet, haberdar olmak ve harekete geçmek için bu servise abone olabilir.</span><span class="sxs-lookup"><span data-stu-id="40401-160">In asynchronous event-driven communication one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="40401-161">Uygulamanız, olay odaklı, ileti tabanlı iletişimler için hangi protokolün kullanılacağını belirler.</span><span class="sxs-lookup"><span data-stu-id="40401-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="40401-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) güvenilir sıralı iletişim elde yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="40401-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="40401-163">Bir olay veri yolunda niçin kullandığınızda, [RabbitMQ](https://www.rabbitmq.com/) gibi bir ileti aracısının API'sini veya [Konularla Azure Servis Veri](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)Cebisi gibi bir servis veri yolundan gelen API'yi kullanarak kodiçeren sınıflardaki ilgili bir uygulamaya dayalı bir soyutlama düzeyi (olay veri birimi arabirimi gibi) kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="40401-164">Alternatif olarak, etkinlik veri topunuzu ve yayımlama/abone sisteminizi ifade etmek için NServiceBus, MassTransit veya Brighter gibi üst düzey bir servis veri cebisi kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="40401-165">Üretim sistemleri için mesajlaşma teknolojileri hakkında bir not</span><span class="sxs-lookup"><span data-stu-id="40401-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="40401-166">Soyut etkinlik veri topunuzu uygulamak için kullanılabilen mesajlaşma teknolojileri farklı düzeylerdedir.</span><span class="sxs-lookup"><span data-stu-id="40401-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="40401-167">Örneğin, RabbitMQ (mesajlaşma aracısı taşıma) ve Azure Servis Veri'si gibi ürünler, RabbitMQ ve Azure Hizmet Veri Yolunda'nın üzerinde çalışabilen NServiceBus, MassTransit veya Brighter gibi diğer ürünlerden daha düşük bir düzeyde yer alır.</span><span class="sxs-lookup"><span data-stu-id="40401-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="40401-168">Seçiminiz, uygulama düzeyinde kaç zengin özellik ve uygulamanız için gereken kutudan kullanılabilirliğe bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="40401-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="40401-169">EShopOnContainers örneğinde yapıldığı gibi, geliştirme ortamınız için sadece bir kavram kanıtı olay otobüsü uygulamak için, Bir Docker konteyner üzerinde çalışan RabbitMQ üstüne basit bir uygulama yeterli olabilir.</span><span class="sxs-lookup"><span data-stu-id="40401-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="40401-170">Ancak, aşırı ölçeklenebilirliğe ihtiyaç duyan görev açısından kritik ve üretim sistemleri için Azure Hizmet Veri Tos'u değerlendirmek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="40401-171">Dağıtılmış uygulamaların gelişimini kolaylaştıran üst düzey soyutlamalar ve özellikler için, NServiceBus, MassTransit ve Brighter gibi diğer ticari ve açık kaynaklı hizmet veri merkezlerini değerlendirmenizi öneririz.</span><span class="sxs-lookup"><span data-stu-id="40401-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="40401-172">Tabii ki, RabbitMQ ve Docker gibi alt düzey teknolojilerin üstüne kendi servis otobüsü özellikleri oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="40401-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="40401-173">Ama bu sıhhi tesisat iş özel bir kurumsal uygulama için çok fazla mal olabilir.</span><span class="sxs-lookup"><span data-stu-id="40401-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="40401-174">Etkinlik otobüsüne esnek bir şekilde yayımlama</span><span class="sxs-lookup"><span data-stu-id="40401-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="40401-175">Birden çok mikro hizmet arasında olay odaklı bir mimari uygularken bir sorun, bir şekilde dayalı olay veri yolunda ilgili entegrasyon olay yayımlarken orijinal microservice içinde atomik durum güncellemek için nasıl Hareket.</span><span class="sxs-lookup"><span data-stu-id="40401-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="40401-176">Ek yaklaşımlar da olsa, bunu başarmanın birkaç yolu şunlardır.</span><span class="sxs-lookup"><span data-stu-id="40401-176">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="40401-177">MSMQ gibi işlem (DTC tabanlı) bir sıra kullanma.</span><span class="sxs-lookup"><span data-stu-id="40401-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="40401-178">(Ancak, bu eski bir yaklaşımdır.)</span><span class="sxs-lookup"><span data-stu-id="40401-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="40401-179">[İşlem günlüğü madenciliği kullanma.](https://www.scoop.it/t/sql-server-transaction-log-mining)</span><span class="sxs-lookup"><span data-stu-id="40401-179">Using [transaction log mining](https://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

- <span data-ttu-id="40401-180">Tam [Olay Kaynak](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) deseni kullanma.</span><span class="sxs-lookup"><span data-stu-id="40401-180">Using full [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="40401-181">Giden [Kutusu deseni](https://www.kamilgrzybek.com/design/the-outbox-pattern/)kullanma: olayı oluşturacak ve yayımlayacak bir olay oluşturucu bileşeninin temeli olacak bir ileti sırası olarak işlem veritabanı tablosu.</span><span class="sxs-lookup"><span data-stu-id="40401-181">Using the [Outbox pattern](https://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="40401-182">Eşzamanlı iletişim kullanırken göz önünde bulundurulması gereken ek konular ileti idempotence ve ileti deduplication vardır.</span><span class="sxs-lookup"><span data-stu-id="40401-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="40401-183">Bu konular, daha sonra bu kılavuzda [mikro hizmetler (entegrasyon olayları) arasındaki olay tabanlı iletişimin uygulanması](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) bölümünde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="40401-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="40401-184">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="40401-184">Additional resources</span></span>

- <span data-ttu-id="40401-185">**Olay Odaklı Mesajlaşma** </span><span class="sxs-lookup"><span data-stu-id="40401-185">**Event Driven Messaging** </span></span>\
  <https://soapatterns.org/design_patterns/event_driven_messaging>

- <span data-ttu-id="40401-186">**Yayınla/Abone Ol** </span><span class="sxs-lookup"><span data-stu-id="40401-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="40401-187">**Udi Dahan. Netleştirilmiş CQRS** </span><span class="sxs-lookup"><span data-stu-id="40401-187">**Udi Dahan. Clarified CQRS** </span></span>\
  <http://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="40401-188">**Komut ve Sorgu Sorumluluğu Ayrımı (CQRS)** </span><span class="sxs-lookup"><span data-stu-id="40401-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="40401-189">**Sınırlı Bağlamlar Arasında İletişim** </span><span class="sxs-lookup"><span data-stu-id="40401-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="40401-190">**Nihai tutarlılık** </span><span class="sxs-lookup"><span data-stu-id="40401-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="40401-191">**Jimmy Bogard' ı. Esneklik Doğru Refactoring: Bağlantı Değerlendirme** </span><span class="sxs-lookup"><span data-stu-id="40401-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="40401-192">[Önceki](communication-in-microservice-architecture.md)
> [Sonraki](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="40401-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
