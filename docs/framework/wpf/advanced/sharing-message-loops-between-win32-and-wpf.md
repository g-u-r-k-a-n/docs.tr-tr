---
title: Win32 ve WPF Arasında İleti Döngüleri Paylaşma
titleSuffix: ''
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: e1b96284d69645876d3e383beb03a2cc540d8b7b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/24/2020
ms.locfileid: "76731713"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="3ebd5-102">Win32 ve WPF Arasında İleti Döngüleri Paylaşma</span><span class="sxs-lookup"><span data-stu-id="3ebd5-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="3ebd5-103">Bu konu, birlikte [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]çalışabilirlik için bir ileti döngüsünün nasıl uygulanacağını, <xref:System.Windows.Threading.Dispatcher> ' de var olan ileti döngüsü kullanımını kullanarak ya da birlikte çalışma kodunuzun Win32 tarafında ayrı bir ileti döngüsü oluşturarak açıklar.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the Win32 side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="3ebd5-104">ComponentDispatcher ve Ileti döngüsü</span><span class="sxs-lookup"><span data-stu-id="3ebd5-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="3ebd5-105">Birlikte çalışabilirlik ve klavye olay desteği için normal bir senaryo, <xref:System.Windows.Interop.IKeyboardInputSink>veya <xref:System.Windows.Interop.HwndSource> ya da <xref:System.Windows.Interop.HwndHost>gibi <xref:System.Windows.Interop.IKeyboardInputSink>daha önceden uygulayan sınıflardan alt sınıflara uygular.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="3ebd5-106">Ancak, klavye havuzu desteği, birlikte çalışma sınırlarınız genelinde ileti gönderirken ve alırken sahip olabileceğiniz tüm olası ileti döngüsü gereksinimlerini gidermez.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="3ebd5-107">Bir uygulama iletisi döngüsü mimarisini şekillendirmaya yardımcı olmak için [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], bir ileti döngüsünün izlenecek basit bir protokolü tanımlayan <xref:System.Windows.Interop.ComponentDispatcher> sınıfını sağlar.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="3ebd5-108"><xref:System.Windows.Interop.ComponentDispatcher>, birkaç üye sunan statik bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="3ebd5-109">Her yöntemin kapsamı, çağıran iş parçacığına örtülü olarak bağlanır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="3ebd5-110">Bir ileti döngüsü, bu API 'lerden bazılarını kritik zamanlarda çağırmalıdır (bir sonraki bölümde tanımlandığı gibi).</span><span class="sxs-lookup"><span data-stu-id="3ebd5-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="3ebd5-111"><xref:System.Windows.Interop.ComponentDispatcher>, diğer bileşenlerin (klavye havuzu gibi) dinleyebileceği olayları sağlar.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="3ebd5-112"><xref:System.Windows.Threading.Dispatcher> sınıfı uygun bir sırayla tüm uygun <xref:System.Windows.Interop.ComponentDispatcher> yöntemlerini çağırır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="3ebd5-113">Kendi ileti döngünüzü uyguıyorsanız, kodunuz benzer bir şekilde <xref:System.Windows.Interop.ComponentDispatcher> Yöntemler çağrılmadan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="3ebd5-114"><xref:System.Windows.Interop.ComponentDispatcher> yöntemlerinin bir iş parçacığında çağrılması, yalnızca o iş parçacığında kayıtlı olan olay işleyicilerini çağırır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="3ebd5-115">Ileti döngüleri yazma</span><span class="sxs-lookup"><span data-stu-id="3ebd5-115">Writing Message Loops</span></span>  
 <span data-ttu-id="3ebd5-116">Aşağıda, kendi ileti döngünüzü yazarsanız kullanacağınız <xref:System.Windows.Interop.ComponentDispatcher> üyelerinin bir denetim listesi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="3ebd5-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="3ebd5-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: ileti döngünüz, iş parçacığının kalıcı olduğunu göstermek için bunu çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="3ebd5-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>: ileti döngünüz, iş parçacığının kalıcı olmayan olarak döndürüldüğünü göstermek için bunu çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="3ebd5-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: ileti döngünüz, <xref:System.Windows.Interop.ComponentDispatcher> <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> olayını oluşturması gerektiğini belirtmek için bunu çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="3ebd5-120"><xref:System.Windows.Interop.ComponentDispatcher>, <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> `true`ise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> yükseltmeyecektir, ancak ileti döngüleri, kalıcı durumundayken <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> yanıt veremese bile, <xref:System.Windows.Interop.ComponentDispatcher> çağırmayı tercih edebilir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="3ebd5-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: ileti döngünüz, yeni bir iletinin kullanılabilir olduğunu göstermek için bunu çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="3ebd5-122">Dönüş değeri, <xref:System.Windows.Interop.ComponentDispatcher> olayına yönelik bir dinleyicinin iletiyi işlemediğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="3ebd5-123"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> `true` (işlenmiş) döndürürse, dağıtıcı iletiyle birlikte hiçbir şey yapmaz.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="3ebd5-124">Dönüş değeri `false`ise, Dispatcher 'ın Win32 işlev `TranslateMessage`çağırması beklenir ve ardından `DispatchMessage`çağırır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-124">If the return value is `false`, the dispatcher is expected to call the Win32 function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="3ebd5-125">ComponentDispatcher ve mevcut Ileti Işlemeyi kullanma</span><span class="sxs-lookup"><span data-stu-id="3ebd5-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="3ebd5-126">Aşağıda, devralınan [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ileti döngüsüne güveniyorsanız kullanacağınız <xref:System.Windows.Interop.ComponentDispatcher> üyelerinin bir denetim listesi verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="3ebd5-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: uygulamanın kalıcı olup olmadığını döndürür (örneğin, bir kalıcı ileti döngüsü itilmiş).</span><span class="sxs-lookup"><span data-stu-id="3ebd5-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="3ebd5-128"><xref:System.Windows.Interop.ComponentDispatcher> bu durumu izleyebilir, çünkü sınıfı ileti döngüsünden bir <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> ve <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> çağrıları tutar.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="3ebd5-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> ve <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> olayları, temsilci etkinleştirmeleri için standart kuralları izler.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="3ebd5-130">Temsilciler belirtilmemiş bir düzende çağrılır ve ilki iletiyi işlenmiş olarak işaretlese bile tüm temsilciler çağrılır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="3ebd5-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: boşta işleme (iş parçacığı için başka bir bekleyen ileti yoktur) için uygun ve verimli bir zaman gösterir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="3ebd5-132">iş parçacığı kalıcı ise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="3ebd5-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: ileti göndericisinin işlediği tüm iletiler için oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="3ebd5-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>sırasında işlenmemiş tüm iletiler için oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="3ebd5-135"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> olayı veya <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> olayından sonra, olay verilerinde başvuruya göre geçirilen `handled` parametresi `true`olduğunda bir ileti işlenir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="3ebd5-136">`handled` `true`olduğunda olay işleyicileri iletiyi yoksaymalıdır çünkü bu, önce farklı işleyicinin iletiyi işlediği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="3ebd5-137">Her iki olaya yönelik olay işleyicileri iletiyi değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="3ebd5-138">Dağıtıcı değiştirilmiş iletiyi göndermeli ve özgün değiştirilmemiş iletiyi almalıdır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="3ebd5-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> tüm dinleyicilerine teslim edilir, ancak mimari amaç yalnızca, hedeflenen iletilerin iletiye yanıt olarak kodu çağırması gereken HWND 'yi içeren en üst düzey pencere olur.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="3ebd5-140">HwndSource ComponentDispatcher olaylarını nasıl değerlendirir</span><span class="sxs-lookup"><span data-stu-id="3ebd5-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="3ebd5-141"><xref:System.Windows.Interop.HwndSource> üst düzey bir pencere (üst HWND olmadan) ise, <xref:System.Windows.Interop.ComponentDispatcher>kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="3ebd5-142"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> harekete geçirilir ve ileti <xref:System.Windows.Interop.HwndSource> veya alt pencereler için tasarlanıyorsa, <xref:System.Windows.Interop.HwndSource> <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A><xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> klavye havuz sırasını çağırır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="3ebd5-143"><xref:System.Windows.Interop.HwndSource> en üst düzey bir pencere (üst HWND) değilse, hiçbir işleme uygulanmaz.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="3ebd5-144">Yalnızca üst düzey pencerenin işleme yapması beklenir ve birlikte çalışabilirlik senaryosunun parçası olarak klavye havuzu desteğiyle bir üst düzey pencere olması beklenir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="3ebd5-145">Bir <xref:System.Windows.Interop.HwndSource> üzerinde <xref:System.Windows.Interop.HwndHost.WndProc%2A>, ilk Çağrılmakta olan uygun bir klavye havuzu yöntemi olmadan çağrılırsa, uygulamanız <xref:System.Windows.UIElement.KeyDown>gibi daha üst düzey klavye olaylarını alır.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="3ebd5-146">Ancak, erişim anahtarı desteği gibi istenen klavye giriş modeli özelliklerini atladan klavye havuzu yöntemleri çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="3ebd5-147">Bu durum ileti döngüsünün <xref:System.Windows.Interop.ComponentDispatcher>ilgili iş parçacığını doğru bir şekilde bilgilendirmediği veya üst HWND doğru klavye havuzu yanıtlarını çağırmadığı için meydana gelebilir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="3ebd5-148"><xref:System.Windows.Interop.HwndSource.AddHook%2A> yöntemi kullanılarak bu ileti için kancalar eklediyseniz, klavye havuzuna giden bir ileti HWND 'ye gönderilmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="3ebd5-149">İleti, ileti göndericisi düzeyinde doğrudan işlenmiş ve `DispatchMessage` işlevine gönderilmemiş olabilir.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3ebd5-150">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="3ebd5-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="3ebd5-151">WPF ve Win32 Birlikte Çalışması</span><span class="sxs-lookup"><span data-stu-id="3ebd5-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="3ebd5-152">İş Parçacığı Modeli</span><span class="sxs-lookup"><span data-stu-id="3ebd5-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="3ebd5-153">Girişe Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="3ebd5-153">Input Overview</span></span>](input-overview.md)
