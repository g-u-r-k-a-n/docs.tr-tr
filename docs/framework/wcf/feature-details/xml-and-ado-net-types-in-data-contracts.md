---
title: Veri Sözleşmelerinde XML ve ADO.NET Türleri
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c2ce8461-3c15-4c41-8c81-1cb78f5b59a6
ms.openlocfilehash: d4ac956af0addf9c3b38f3bfb8e8644757dc81c3
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96238320"
---
# <a name="xml-and-adonet-types-in-data-contracts"></a><span data-ttu-id="b4af8-102">Veri Sözleşmelerinde XML ve ADO.NET Türleri</span><span class="sxs-lookup"><span data-stu-id="b4af8-102">XML and ADO.NET Types in Data Contracts</span></span>

<span data-ttu-id="b4af8-103">Windows Communication Foundation (WCF) veri anlaşması modeli, XML 'i doğrudan temsil eden belirli türleri destekler.</span><span class="sxs-lookup"><span data-stu-id="b4af8-103">The Windows Communication Foundation (WCF) data contract model supports certain types that represent XML directly.</span></span> <span data-ttu-id="b4af8-104">Bu türler XML 'e serileştirildiğinde seri hale getirici bu türlerin XML içeriğini başka bir işlem olmadan yazar.</span><span class="sxs-lookup"><span data-stu-id="b4af8-104">When these types are serialized to XML, the serializer writes out the XML contents of these types without any further processing.</span></span> <span data-ttu-id="b4af8-105">Desteklenen türler <xref:System.Xml.XmlElement> , <xref:System.Xml.XmlNode> (türünün kendisi değil değil) dizilerinin ve `XmlNode` uygulayan türler <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-105">Supported types are <xref:System.Xml.XmlElement>, arrays of <xref:System.Xml.XmlNode> (but not the `XmlNode` type itself), as well as types that implement <xref:System.Xml.Serialization.IXmlSerializable>.</span></span> <span data-ttu-id="b4af8-106"><xref:System.Data.DataSet>Ve <xref:System.Data.DataTable> türü ve türü belirtilmiş veri kümeleri, veritabanı programlamasında yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-106">The <xref:System.Data.DataSet> and <xref:System.Data.DataTable> type, as well as typed datasets, are commonly used in database programming.</span></span> <span data-ttu-id="b4af8-107">Bu türler arabirimini uygular `IXmlSerializable` ve bu nedenle veri sözleşmesi modelinde seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-107">These types implement the `IXmlSerializable` interface and are therefore serializable in the data contract model.</span></span> <span data-ttu-id="b4af8-108">Bu türlere ilişkin bazı özel noktalar, konunun sonunda listelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-108">Some special considerations for these types are listed at the end of this topic.</span></span>  
  
## <a name="xml-types"></a><span data-ttu-id="b4af8-109">XML türleri</span><span class="sxs-lookup"><span data-stu-id="b4af8-109">XML Types</span></span>  
  
### <a name="xml-element"></a><span data-ttu-id="b4af8-110">XML öğesi</span><span class="sxs-lookup"><span data-stu-id="b4af8-110">Xml Element</span></span>  

 <span data-ttu-id="b4af8-111">`XmlElement`Türü, XML içerikleri kullanılarak serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-111">The `XmlElement` type is serialized using its XML contents.</span></span> <span data-ttu-id="b4af8-112">Örneğin, aşağıdaki türü kullanma.</span><span class="sxs-lookup"><span data-stu-id="b4af8-112">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#4)]
 [!code-vb[DataContractAttribute#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#4)]  
  
 <span data-ttu-id="b4af8-113">Bu, XML 'e aşağıdaki şekilde serileştirilir:</span><span class="sxs-lookup"><span data-stu-id="b4af8-113">This is serialized to XML as follows:</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
    <myDataMember>  
        <myElement xmlns="" myAttribute="myValue">  
            myContents  
        </myElement>  
    </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="b4af8-114">Sarmalayıcı veri üyesi öğesinin hala mevcut olduğuna dikkat edin `<myDataMember>` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-114">Notice that a wrapper data member element `<myDataMember>` is still present.</span></span> <span data-ttu-id="b4af8-115">Bu öğeyi veri sözleşmesi modelinde kaldırmanın bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-115">There is no way of removing this element in the data contract model.</span></span> <span data-ttu-id="b4af8-116">Bu modeli işleyen serileştiriciler ( <xref:System.Runtime.Serialization.DataContractSerializer> ve), <xref:System.Runtime.Serialization.NetDataContractSerializer> Bu sarmalayıcı öğesine özel öznitelikler yayabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-116">The serializers that handle this model (the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.NetDataContractSerializer>) may emit special attributes into this wrapper element.</span></span> <span data-ttu-id="b4af8-117">Bu öznitelikler, standart XML şema örneği "Nil" özniteliği ( `XmlElement` to to a izin verir `null` ) ve "Type" özniteliği ( `XmlElement` polymorphically kullanılmasına izin veriliyor) içerir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-117">These attributes include the standard XML Schema Instance "nil" attribute (allowing the `XmlElement` to be `null`) and the "type" attribute (allowing `XmlElement` to be used polymorphically).</span></span> <span data-ttu-id="b4af8-118">Ayrıca, aşağıdaki XML öznitelikleri WCF 'ye özgüdür: "ID", "ref", "Type" ve "Assembly".</span><span class="sxs-lookup"><span data-stu-id="b4af8-118">Also, the following XML attributes are specific to WCF: "Id", "Ref", "Type" and "Assembly".</span></span> <span data-ttu-id="b4af8-119">Bu öznitelikler, `XmlElement` nesne grafiği koruma modu etkin veya ile kullanılarak kullanılarak desteklemek için kullanılabilir <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-119">These attributes may be emitted to support using the `XmlElement` with the object graph preservation mode enabled, or with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="b4af8-120">(Nesne grafiği koruma modu hakkında daha fazla bilgi için bkz. [serileştirme ve serisini kaldırma](serialization-and-deserialization.md).)</span><span class="sxs-lookup"><span data-stu-id="b4af8-120">(For more information about the object graph preservation mode, see [Serialization and Deserialization](serialization-and-deserialization.md).)</span></span>  
  
 <span data-ttu-id="b4af8-121">Dizilerine veya koleksiyonlara `XmlElement` izin verilir ve diğer herhangi bir dizi veya koleksiyon olarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-121">Arrays or collections of `XmlElement` are allowed and are handled as any other array or collection.</span></span> <span data-ttu-id="b4af8-122">Diğer bir deyişle, tüm koleksiyon için bir sarmalayıcı öğe ve dizideki her biri için ayrı bir sarmalayıcı öğesi ( `<myDataMember>` Önceki örnekte olduğu gibi) vardır `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-122">That is, there is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each `XmlElement` in the array.</span></span>  
  
 <span data-ttu-id="b4af8-123">Seri durumdan çıkarma sırasında, `XmlElement` gelen XML 'den seri hale getirici tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-123">On deserialization, an `XmlElement` is created by the deserializer from the incoming XML.</span></span> <span data-ttu-id="b4af8-124"><xref:System.Xml.XmlDocument>Seri hale getirici, geçerli bir üst öğe tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-124">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span>  
  
 <span data-ttu-id="b4af8-125">Seri durumdan çıkarılmış XML parçasının `XmlElement` kullandığı tüm önekleri tanımladığından ve üst öğelerden herhangi bir önek tanımına dayanmadığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="b4af8-125">Make sure that the XML fragment that is deserialized to an `XmlElement` defines all prefixes that it uses and does not rely on any prefix definitions from ancestor elements.</span></span> <span data-ttu-id="b4af8-126">Bu, yalnızca, `DataContractSerializer` farklı bir kaynaktan XML 'e erişmek için ' i kullanırken sorun olur `DataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-126">This is a concern only when using the `DataContractSerializer` to access XML from a different (non-`DataContractSerializer`) source.</span></span>  
  
 <span data-ttu-id="b4af8-127">İle kullanıldığında, `DataContractSerializer` `XmlElement` polymorphically atanabilir, ancak yalnızca türünde bir veri üyesi olabilir <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-127">When used with the `DataContractSerializer`, the `XmlElement` may be assigned polymorphically, but only to a data member of type <xref:System.Object>.</span></span> <span data-ttu-id="b4af8-128">Uygulasa da <xref:System.Collections.IEnumerable> , bir `XmlElement` koleksiyon türü olarak kullanılamaz ve bir <xref:System.Collections.IEnumerable> veri üyesine atanamaz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-128">Even though it implements <xref:System.Collections.IEnumerable>, an `XmlElement` cannot be used as a collection type and cannot be assigned to an <xref:System.Collections.IEnumerable> data member.</span></span> <span data-ttu-id="b4af8-129">Tüm polimorfik atamalarında olduğu gibi, `DataContractSerializer` sonuçta elde EDILEN XML 'de veri sözleşme adını yayar; bu durumda, " http://schemas.datacontract.org/2004/07/System.Xml " ad alanında "XmlElement" olur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-129">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "XmlElement" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span>  
  
 <span data-ttu-id="b4af8-130">İle `NetDataContractSerializer` tüm geçerli Polimorfik Atama `XmlElement` ( `Object` veya `IEnumerable` ) desteklenir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-130">With the `NetDataContractSerializer`, any valid polymorphic assignment of `XmlElement` (to `Object` or `IEnumerable`) is supported.</span></span>  
  
 <span data-ttu-id="b4af8-131">Polymorphically atanıp atanmayacağı, öğesinden türetilmiş türler ile serileştiricilerin birini kullanmayı denemeyin `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-131">Do not attempt to use either of the serializers with types derived from `XmlElement`, whether they are assigned polymorphically or not.</span></span>  
  
### <a name="array-of-xmlnode"></a><span data-ttu-id="b4af8-132">XmlNode dizisi</span><span class="sxs-lookup"><span data-stu-id="b4af8-132">Array of XmlNode</span></span>  

 <span data-ttu-id="b4af8-133">Dizilerinin kullanılması <xref:System.Xml.XmlNode> , kullanılmasına çok benzer `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-133">Using arrays of <xref:System.Xml.XmlNode> is very similar to using `XmlElement`.</span></span> <span data-ttu-id="b4af8-134">Dizilerinin kullanılması `XmlNode` , kullanmaktan daha fazla esneklik sağlar `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-134">Using arrays of `XmlNode` gives you more flexibility than using `XmlElement`.</span></span> <span data-ttu-id="b4af8-135">Veri üyesi sarmalama öğesi içinde birden çok öğe yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-135">You can write multiple elements inside the data member wrapping element.</span></span> <span data-ttu-id="b4af8-136">Ayrıca, XML açıklamaları gibi veri üyesi sarmalama öğesi içindeki öğelerden başka içerik de ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-136">You can also inject content other than elements inside of the data member wrapping element, such as XML comments.</span></span> <span data-ttu-id="b4af8-137">Son olarak, öznitelikleri sarmalama verileri üye öğesine yerleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-137">Finally, you can put attributes into the wrapping data member element.</span></span> <span data-ttu-id="b4af8-138">Tüm bunlar `XmlNode` , veya gibi belirli türetilmiş sınıflarla dizisini doldurarak elde edilebilir `XmlNode` <xref:System.Xml.XmlAttribute> `XmlElement` <xref:System.Xml.XmlComment> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-138">All this can be achieved by populating the array of `XmlNode` with specific derived classes of `XmlNode` such as <xref:System.Xml.XmlAttribute>, `XmlElement` or <xref:System.Xml.XmlComment>.</span></span> <span data-ttu-id="b4af8-139">Örneğin, aşağıdaki türü kullanma.</span><span class="sxs-lookup"><span data-stu-id="b4af8-139">For example, using the following type.</span></span>  
  
 [!code-csharp[DataContractAttribute#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#5)]
 [!code-vb[DataContractAttribute#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#5)]  
  
 <span data-ttu-id="b4af8-140">Serileştirilmiş olduğunda, elde edilen XML aşağıdaki koda benzer.</span><span class="sxs-lookup"><span data-stu-id="b4af8-140">When serialized, the resulting XML is similar to the following code.</span></span>  
  
```xml  
<MyDataContract xmlns="http://schemas.contoso.com">  
  <myDataMember myAttribute="myValue">  
     <!--myComment-->  
     <myElement xmlns="" myAttribute="myValue">  
 myContents  
     </myElement>  
     <myElement xmlns="" myAttribute="myValue">  
       myContents  
     </myElement>  
  </myDataMember>  
</MyDataContract>  
```  
  
 <span data-ttu-id="b4af8-141">Veri üyesi sarmalayıcı öğesinin `<myDataMember>` bir öznitelik, açıklama ve iki öğe içerdiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b4af8-141">Note that the data member wrapper element `<myDataMember>` contains an attribute, a comment, and two elements.</span></span> <span data-ttu-id="b4af8-142">Bunlar `XmlNode` seri hale getirilen dört örneklerdir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-142">These are the four `XmlNode` instances that were serialized.</span></span>  
  
 <span data-ttu-id="b4af8-143">`XmlNode`GEÇERSIZ XML ile sonuçlanan bir dizi seri hale getirilemez.</span><span class="sxs-lookup"><span data-stu-id="b4af8-143">An array of `XmlNode` that results in invalid XML cannot be serialized.</span></span> <span data-ttu-id="b4af8-144">Örneğin, ilk diğeri bir olan iki örneğin bir dizisi, `XmlNode` ikinci bir, `XmlElement` GEÇERLI bir <xref:System.Xml.XmlAttribute> XML örneğine karşılık gelmediğinden (özniteliği iliştirmek için bir yer yoktur).</span><span class="sxs-lookup"><span data-stu-id="b4af8-144">For example, an array of two `XmlNode` instances where the first one is an `XmlElement` and the second one is an <xref:System.Xml.XmlAttribute> is invalid, because this sequence does not correspond to any valid XML instance (there is no place to attach the attribute to).</span></span>  
  
 <span data-ttu-id="b4af8-145">Bir dizisinin serisini kaldırma sırasında `XmlNode` düğümler oluşturulur ve gelen XML 'deki bilgilerle doldurulur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-145">On deserialization of an array of `XmlNode`, nodes are created and populated with information from the incoming XML.</span></span> <span data-ttu-id="b4af8-146"><xref:System.Xml.XmlDocument>Seri hale getirici, geçerli bir üst öğe tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-146">A valid parent <xref:System.Xml.XmlDocument> is provided by the deserializer.</span></span> <span data-ttu-id="b4af8-147">Sarmalayıcı veri üyesi öğesindeki tüm öznitelikler de dahil olmak üzere tüm düğümlerin serisi kaldırılır, ancak WCF serileştiricileri (Polimorfik atamayı göstermek için kullanılan öznitelikler gibi) bu öznitelikleri hariç tutulur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-147">All nodes are deserialized, including any attributes on the wrapper data member element, but excluding the attributes placed there by the WCF serializers (such as the attributes used to indicate polymorphic assignment).</span></span> <span data-ttu-id="b4af8-148">XML parçasındaki tüm ad alanı öneklerini tanımlama hakkında desteklenmediği uyarısıyla, serisini kaldırmada olduğu gibi dizilerinin serisini kaldırma için geçerlidir `XmlNode` `XmlElement` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-148">The caveat about defining all namespace prefixes in the XML fragment applies to the deserialization of arrays of `XmlNode` just like it does to deserializing `XmlElement`.</span></span>  
  
 <span data-ttu-id="b4af8-149">Nesne grafiği koruması açık olan serileştiriciler kullanılırken, nesne eşitlik yalnızca `XmlNode` ayrı örneklere değil diziler düzeyinde korunur `XmlNode` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-149">When using the serializers with object graph preservation turned on, object equality is only preserved on the level of `XmlNode` arrays, not individual `XmlNode` instances.</span></span>  
  
 <span data-ttu-id="b4af8-150">`XmlNode`Bir veya daha fazla düğümün ayarlandığı bir diziyi seri hale getirme girişiminde bulunuldu `null` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-150">Do not attempt to serialize an array of `XmlNode` where one or more of the nodes is set to `null`.</span></span> <span data-ttu-id="b4af8-151">Dizi üyesinin tamamına `null` , dizide yer alan herhangi bir kişi için izin verilmez `XmlNode` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-151">It is permitted for the entire array member to be `null`, but not for any individual `XmlNode` contained in the array.</span></span> <span data-ttu-id="b4af8-152">Tüm dizi üyesi null ise sarmalayıcı veri üyesi öğesi, null olduğunu belirten özel bir öznitelik içerir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-152">If the entire array member is null, the wrapper data member element contains a special attribute that indicates that it is null.</span></span> <span data-ttu-id="b4af8-153">Seri durumdan çıkarma sırasında, tüm dizi üyesi de null olur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-153">On deserialization, the entire array member also becomes null.</span></span>  
  
 <span data-ttu-id="b4af8-154">Yalnızca normal dizileri `XmlNode` seri hale getirici tarafından özel olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-154">Only regular arrays of `XmlNode` are treated specially by the serializer.</span></span> <span data-ttu-id="b4af8-155">`XmlNode`Veya ' den türetilen türlerin dizileri olarak belirtilen veri üyelerini içeren diğer koleksiyon türleri olarak belirtilen veri üyeleri `XmlNode` özel olarak değerlendirilmez.</span><span class="sxs-lookup"><span data-stu-id="b4af8-155">Data members declared as other collection types that contain `XmlNode`, or data members declared as arrays of types derived from `XmlNode`, are not treated specially.</span></span> <span data-ttu-id="b4af8-156">Bu nedenle, normal olarak serileştirilmek üzere diğer ölçütlerden birini karşılamadığında seri hale getirilebilir değildir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-156">Thus, they are normally not serializable unless they also meet one of the other criteria for serializing.</span></span>  
  
 <span data-ttu-id="b4af8-157">Dizi dizilerine veya dizilerinin koleksiyonuna `XmlNode` izin verilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-157">Arrays or collections of arrays of `XmlNode` are allowed.</span></span> <span data-ttu-id="b4af8-158">Tüm koleksiyon için bir sarmalayıcı öğe ve `<myDataMember>` `XmlNode` dış dizi ya da koleksiyonda bulunan her bir dizi için ayrı bir sarmalayıcı öğe (önceki örnekte olduğu gibi) vardır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-158">There is a wrapper element for the entire collection, and a separate wrapper element (similar to `<myDataMember>` in the preceding example) for each array of `XmlNode` in the outer array or collection.</span></span>  
  
 <span data-ttu-id="b4af8-159">Ya da türündeki bir veri üyesini <xref:System.Array> `Object` `Array` `IEnumerable` `XmlNode` örnek olarak doldurmak, veri üyesinin örnek olarak değerlendirilmesiyle sonuçlanır `Array` `XmlNode` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-159">Populating a data member of type <xref:System.Array> of `Object` or `Array` of `IEnumerable` with `XmlNode` instances does not result in the data member being treated as an `Array` of `XmlNode` instances.</span></span> <span data-ttu-id="b4af8-160">Her dizi üyesi ayrı olarak serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-160">Each array member is serialized separately.</span></span>  
  
 <span data-ttu-id="b4af8-161">İle kullanıldığında `DataContractSerializer` , dizilerinin dizileri `XmlNode` polymorphically atanabilir, ancak yalnızca türünde bir veri üyesi olabilir `Object` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-161">When used with the `DataContractSerializer`, arrays of `XmlNode` can be assigned polymorphically, but only to a data member of type `Object`.</span></span> <span data-ttu-id="b4af8-162">Uygulayan olsa da `IEnumerable` , bir dizisi `XmlNode` bir koleksiyon türü olarak kullanılamaz ve bir `IEnumerable` veri üyesine atanamaz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-162">Even though it implements `IEnumerable`, an array of `XmlNode` cannot be used as a collection type and be assigned to an `IEnumerable` data member.</span></span> <span data-ttu-id="b4af8-163">Tüm polimorfik atamalarında olduğu gibi, `DataContractSerializer` sonuçta elde EDILEN XML 'de veri sözleşme adını yayar; bu durumda, " http://schemas.datacontract.org/2004/07/System.Xml " ad alanında "ArrayOfXmlNode" olur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-163">As with all polymorphic assignments, the `DataContractSerializer` emits the data contract name in the resulting XML – in this case, it is "ArrayOfXmlNode" in the "http://schemas.datacontract.org/2004/07/System.Xml" namespace.</span></span> <span data-ttu-id="b4af8-164">İle kullanıldığında `NetDataContractSerializer` , bir dizinin geçerli atama `XmlNode` desteklenir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-164">When used with the `NetDataContractSerializer`, any valid assignment of an `XmlNode` array is supported.</span></span>  
  
### <a name="schema-considerations"></a><span data-ttu-id="b4af8-165">Şema konuları</span><span class="sxs-lookup"><span data-stu-id="b4af8-165">Schema Considerations</span></span>  

 <span data-ttu-id="b4af8-166">XML türlerinin şema eşlemesi hakkında daha fazla bilgi için bkz. [veri sözleşmesi şema başvurusu](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="b4af8-166">For details about the schema mapping of XML types, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="b4af8-167">Bu bölüm, önemli noktaların özetini sağlar.</span><span class="sxs-lookup"><span data-stu-id="b4af8-167">This section provides a summary of the important points.</span></span>  
  
 <span data-ttu-id="b4af8-168">Türündeki bir veri üyesi, `XmlElement` aşağıdaki anonim tür kullanılarak tanımlanan bir öğeyle eşlenir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-168">A data member of type `XmlElement` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType>  
   <xsd:sequence>  
      <xsd:any minOccurs="0" processContents="lax" />  
   </xsd:sequence>  
</xsd:complexType>  
```  
  
 <span data-ttu-id="b4af8-169">Dizi türünde bir veri üyesi, `XmlNode` aşağıdaki anonim tür kullanılarak tanımlanan bir öğeyle eşlenir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-169">A data member of type Array of `XmlNode` is mapped to an element defined using the following anonymous type.</span></span>  
  
```xml  
<xsd:complexType mixed="true">  
   <xsd:sequence>  
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax" />  
   </xsd:sequence>  
   <xsd:anyAttribute/>  
</xsd:complexType>  
```  
  
## <a name="types-implementing-the-ixmlserializable-interface"></a><span data-ttu-id="b4af8-170">IXmlSerializable arabirimini uygulayan türler</span><span class="sxs-lookup"><span data-stu-id="b4af8-170">Types Implementing the IXmlSerializable Interface</span></span>  

 <span data-ttu-id="b4af8-171">Arabirimini uygulayan türler `IXmlSerializable` tarafından tamamen desteklenir `DataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-171">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="b4af8-172"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute>Bu türlerin şemasını denetlemek için özniteliği her zaman bu türlere uygulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-172">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>  
  
 <span data-ttu-id="b4af8-173">Şunları uygulayan tür üç değişken vardır `IXmlSerializable` : rastgele içeriği temsil eden türler, tek bir öğeyi temsil eden türler ve eski <xref:System.Data.DataSet> türler.</span><span class="sxs-lookup"><span data-stu-id="b4af8-173">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>  
  
- <span data-ttu-id="b4af8-174">İçerik türleri özniteliği tarafından belirtilen bir şema sağlayıcısı yöntemini kullanır `XmlSchemaProviderAttribute` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-174">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="b4af8-175">Yöntemi döndürmez `null` ve <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> özniteliğinde özelliği varsayılan değerinde bırakılır `false` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-175">The method does not return `null`, and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="b4af8-176">Bu, türlerin en yaygın kullanımdır `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-176">This is the most common usage of `IXmlSerializable` types.</span></span>  
  
- <span data-ttu-id="b4af8-177">Öğe türleri, bir `IXmlSerializable` türün kendi kök öğe adını denetlemesini gerektiğinde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-177">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="b4af8-178">Bir türü öğe türü olarak işaretlemek için, <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> öznitelik üzerinde özelliğini <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> olarak ayarlayın `true` veya şema sağlayıcısı yönteminden null döndürün.</span><span class="sxs-lookup"><span data-stu-id="b4af8-178">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return null from the schema provider method.</span></span> <span data-ttu-id="b4af8-179">Bir şema sağlayıcısı yönteminin olması, öğe türleri için isteğe bağlıdır; içinde Yöntem adı yerine null belirtebilirsiniz `XmlSchemaProviderAttribute` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-179">Having a schema provider method is optional for element types – you may specify null instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="b4af8-180">Ancak, `IsAny` `true` ve bir şema sağlayıcısı yöntemi belirtilmişse, yöntemi null döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-180">However, if `IsAny` is `true` and a schema provider method is specified, the method must return null.</span></span>  
  
- <span data-ttu-id="b4af8-181">Eski <xref:System.Data.DataSet> türler `IXmlSerializable` , özniteliğiyle işaretlenmemiş türlerdir `XmlSchemaProviderAttribute` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-181">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="b4af8-182">Bunun yerine, <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> şema oluşturma yöntemine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-182">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="b4af8-183">Bu model, türü için kullanılır `DataSet` ve türü belirtilmiş veri kümesi .NET Framework önceki sürümlerinde bir sınıf türetiliyor, ancak artık kullanılmıyor ve yalnızca eski nedenlerden dolayı destekleniyor.</span><span class="sxs-lookup"><span data-stu-id="b4af8-183">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="b4af8-184">Bu modele güvenmeyin ve her zaman `XmlSchemaProviderAttribute` `IXmlSerializable` türlerinizi uygulayın.</span><span class="sxs-lookup"><span data-stu-id="b4af8-184">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>  
  
### <a name="ixmlserializable-content-types"></a><span data-ttu-id="b4af8-185">IXmlSerializable Içerik türleri</span><span class="sxs-lookup"><span data-stu-id="b4af8-185">IXmlSerializable Content Types</span></span>  

 <span data-ttu-id="b4af8-186">`IXmlSerializable`' İ uygulayan ve daha önce tanımlanan bir içerik türü olan bir veri üyesini serileştirilirken, serileştirici veri üyesine yönelik sarmalayıcı öğesini yazar ve yöntemine denetimi geçer <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-186">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="b4af8-187"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>Uygulama sarmalayıcı öğesine öznitelik ekleme dahil olmak üzere herhangi BIR XML yazabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-187">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, including adding attributes to the wrapper element.</span></span> <span data-ttu-id="b4af8-188">İşlem tamamlandıktan sonra `WriteXml` seri hale getirici öğeyi kapatır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-188">After `WriteXml` is done, the serializer closes the element.</span></span>  
  
 <span data-ttu-id="b4af8-189">`IXmlSerializable`' İ uygulayan ve daha önce tanımlanan bir içerik türü olan bir veri üyesinin serisi kaldırılırken, seri hale getirici veri üyesine yönelik sarmalayıcı ÖĞESINDE XML okuyucuyu konumlandırır ve metoduna denetimi geçer <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-189">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and pass control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="b4af8-190">Yöntemi, başlangıç ve bitiş etiketleri dahil olmak üzere tüm öğeyi okumalı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-190">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="b4af8-191">`ReadXml`Kodunuzun, öğenin boş olduğu durumu işlediğinizden emin olun.</span><span class="sxs-lookup"><span data-stu-id="b4af8-191">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="b4af8-192">Ayrıca, `ReadXml` uygulamanız belirli bir şekilde adlandırılan sarmalayıcı öğesine dayanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-192">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="b4af8-193">Seri hale getirici tarafından seçilen ad değişiklik gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-193">The name is chosen by the serializer can vary.</span></span>  
  
 <span data-ttu-id="b4af8-194">`IXmlSerializable`Örneğin, türündeki veri üyelerine polymorphically içerik türleri atama izni verilir <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-194">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="b4af8-195">Tür örneklerinin null olması de buna izin verilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-195">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="b4af8-196">Son olarak, `IXmlSerializable` türleri nesne Graph koruması etkin ve ile birlikte kullanmak mümkündür <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-196">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="b4af8-197">Tüm bu özellikler, WCF serileştiricinin belirli öznitelikleri sarmalayıcı öğesine ("Nil" ve "tür" i XML şema örneği ad alanında ve "ID", "ref", "Type" ve "Assembly" adlı WCF 'ye özgü bir ad alanında) iliştirmesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-197">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>  
  
#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="b4af8-198">ReadXml 'i uygularken yoksayılacak öznitelikler</span><span class="sxs-lookup"><span data-stu-id="b4af8-198">Attributes to Ignore when Implementing ReadXml</span></span>  

 <span data-ttu-id="b4af8-199">`ReadXml`Kodu kodunuza geçirmeden önce seri hale GETIRICI XML öğesini inceler, bu özel XML özniteliklerini algılar ve üzerinde davranır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-199">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="b4af8-200">Örneğin, "Nil" ise, `true` null değeri seri durumdan çıkarılmış olur ve `ReadXml` çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-200">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="b4af8-201">Çok biçimlilik algılanırsa, öğesinin içeriği farklı türde gibi seri durumdan çıkarılacak.</span><span class="sxs-lookup"><span data-stu-id="b4af8-201">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="b4af8-202">Polymorphically atanmış türünün uygulamasının uygulamasına `ReadXml` denir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-202">The polymorphically assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="b4af8-203">Herhangi bir durumda, bir `ReadXml` uygulama, seri hale getirici tarafından işlendiği için bu özel öznitelikleri yoksaymalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-203">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>  
  
### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="b4af8-204">IXmlSerializable Içerik türleri için şema konuları</span><span class="sxs-lookup"><span data-stu-id="b4af8-204">Schema Considerations for IXmlSerializable Content Types</span></span>  

 <span data-ttu-id="b4af8-205">Şemayı bir `IXmlSerializable` içerik türü dışa aktarırken, şema sağlayıcısı yöntemi çağırılır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-205">When exporting schema an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="b4af8-206"><xref:System.Xml.Schema.XmlSchemaSet>Şema sağlayıcısı yöntemine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-206">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="b4af8-207">Yöntemi, şema kümesine geçerli bir şema ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-207">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="b4af8-208">Şema kümesi, şema dışa aktarma gerçekleştiği sırada zaten bilinen şemayı içerir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-208">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="b4af8-209">Şema sağlayıcısı yönteminin şema kümesine bir öğe eklemesi gerektiğinde, <xref:System.Xml.Schema.XmlSchema> küme içinde uygun ad alanı ile bir sahip olup olmadığını belirlemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-209">When the schema provider method must add an item to the schema set, it must determine if an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="b4af8-210">Varsa, şema sağlayıcısı yönteminin yeni öğeyi mevcut öğesine eklemesi gerekir `XmlSchema` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-210">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="b4af8-211">Aksi halde, yeni bir örnek oluşturması gerekir `XmlSchema` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-211">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="b4af8-212">Bu, tür dizileri kullanılıyorsa önemlidir `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-212">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="b4af8-213">Örneğin, " `IXmlSerializable` b" ad alanında "A" türü olarak verilen bir tür varsa, şema sağlayıcısı yönteminin adı, şema kümesi "b" için "ArrayOfA" türünü tutmak için şemayı zaten içeriyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-213">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>  
  
 <span data-ttu-id="b4af8-214">Türüne tür eklemenin yanı sıra <xref:System.Xml.Schema.XmlSchemaSet> , içerik türleri için şema sağlayıcısı yöntemi null olmayan bir değer döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-214">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="b4af8-215"><xref:System.Xml.XmlQualifiedName>Verilen tür için kullanılacak şema türünün adını belirten bir döndürebilir `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-215">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="b4af8-216">Bu tam ad ayrıca tür için veri anlaşması adı ve ad alanı olarak da kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-216">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="b4af8-217">Şema sağlayıcısı yöntemi döndürüldüğünde, şema kümesinde varolmayan bir tür döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-217">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="b4af8-218">Ancak, tüm ilişkili türlerin verildiği zaman tarafından ( <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> yöntemi ' de tüm ilgili türler için çağrılır <xref:System.Runtime.Serialization.XsdDataContractExporter> ve <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> özelliğine erişilir), tür şema kümesinde bulunur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-218">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="b4af8-219">`Schemas`Tüm ilgili çağrılar yapılmadan önce özelliğe erişilmesi `Export` bir ile sonuçlanabilir <xref:System.Xml.Schema.XmlSchemaException> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-219">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="b4af8-220">Dışarı aktarma işlemi hakkında daha fazla bilgi için bkz. [sınıflardan şemaları dışarı aktarma](exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b4af8-220">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>  
  
 <span data-ttu-id="b4af8-221">Şema sağlayıcısı yöntemi kullanmak için ' i de döndürebilir <xref:System.Xml.Schema.XmlSchemaType> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-221">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="b4af8-222">Tür anonim olmayabilir veya olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-222">The type may or may not be anonymous.</span></span> <span data-ttu-id="b4af8-223">Anonim ise, tür şeması `IXmlSerializable` `IXmlSerializable` bir veri üyesi olarak her kullanıldığında anonim bir tür olarak verilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-223">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="b4af8-224">`IXmlSerializable`Türün hala bir veri anlaşması adı ve ad alanı vardır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-224">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="b4af8-225">(Bu, ad özelleştirmek için özniteliğin kullanılamaz olması dışında, [veri anlaşması adlarında](data-contract-names.md) açıklandığı şekilde belirlenir <xref:System.Runtime.Serialization.DataContractAttribute> .) Anonim değilse, içindeki türlerden biri olmalıdır `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-225">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="b4af8-226">Bu durum, türünün döndürülmesi ile eşdeğerdir `XmlQualifiedName` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-226">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>  
  
 <span data-ttu-id="b4af8-227">Ayrıca, genel bir öğe bildirimi tür için verilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-227">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="b4af8-228">Türün <xref:System.Xml.Serialization.XmlRootAttribute> kendisine uygulanan özniteliği yoksa, öğesi veri sözleşmesiyle aynı ada ve ad alanına sahiptir ve "boş bırakılabilir" özelliği doğru olur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-228">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is true.</span></span> <span data-ttu-id="b4af8-229">Bunun tek istisnası şema ad alanıdır (" http://www.w3.org/2001/XMLSchema ") – türün veri anlaşması bu ad alanında yer alıyorsa, ilgili genel öğe boş ad alanıdır, çünkü şema ad alanına yeni öğe eklenemez.</span><span class="sxs-lookup"><span data-stu-id="b4af8-229">The only exception to this is the schema namespace ("http://www.w3.org/2001/XMLSchema") – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="b4af8-230">Türe `XmlRootAttribute` uygulanmış özniteliği varsa, genel öğe bildirimi aşağıdaki: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A> <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> ve özellikleri kullanılarak verilir <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-230">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="b4af8-231">`XmlRootAttribute`Uygulanan varsayılanlar, veri sözleşmesinin adıdır, boş bir ad alanıdır ve "boş bırakılabilir" değeri true olur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-231">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being true.</span></span>  
  
 <span data-ttu-id="b4af8-232">Aynı genel öğe bildirimi kuralları eski veri kümesi türleri için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-232">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="b4af8-233">`XmlRootAttribute`Özel kod aracılığıyla eklenen genel öğe bildirimlerinin geçersiz kılınmadığını, `XmlSchemaSet` şema sağlayıcısı yöntemi kullanılarak veya `GetSchema` eski veri kümesi türleri için aracılığıyla geçersiz kılabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b4af8-233">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>  
  
### <a name="ixmlserializable-element-types"></a><span data-ttu-id="b4af8-234">IXmlSerializable öğe türleri</span><span class="sxs-lookup"><span data-stu-id="b4af8-234">IXmlSerializable Element Types</span></span>  

 <span data-ttu-id="b4af8-235">`IXmlSerializable` öğe türlerinde, `IsAny` özelliği olarak ayarlanmış ya da `true` şema sağlayıcısı yöntemi döndürüyor `null` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-235">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>  
  
 <span data-ttu-id="b4af8-236">Öğe türünü serileştirmek ve serisini kaldırma, içerik türünü serileştirmek ve seri durumdan çıkarmak için çok benzerdir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-236">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="b4af8-237">Ancak bazı önemli farklılıklar vardır:</span><span class="sxs-lookup"><span data-stu-id="b4af8-237">However, there are some important differences:</span></span>  
  
- <span data-ttu-id="b4af8-238">`WriteXml`Uygulamanın tam olarak bir öğe yazması bekleniyordu (kuşkusuz birden çok alt öğe içerebilir).</span><span class="sxs-lookup"><span data-stu-id="b4af8-238">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="b4af8-239">Bu tek öğe, birden çok eşdüzey öğe veya karışık içerik dışında öznitelikleri yazmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-239">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="b4af8-240">Öğe boş olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-240">The element may be empty.</span></span>  
  
- <span data-ttu-id="b4af8-241">`ReadXml`Uygulama sarmalayıcı öğesini okumalı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-241">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="b4af8-242">Üreten bir öğeyi okuması beklenmektedir `WriteXml` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-242">It is expected to read the one element that `WriteXml` produces.</span></span>  
  
- <span data-ttu-id="b4af8-243">Öğe türü düzenli olarak serileştirilirken (örneğin, bir veri sözleşmesindeki veri üyesi olarak), seri hale getirici, `WriteXml` içerik türlerinde olduğu gibi çağrılmadan önce bir sarmalayıcı öğesi verir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-243">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="b4af8-244">Ancak, en üst düzeyde bir öğe türü serileştirilirken, seri hale getirici, `WriteXml` veya oluşturucuları içinde serileştirici oluşturulurken bir kök ad ve ad alanı açıkça belirtilmediği takdirde, normalde bir sarmalayıcı öğesi yazar `DataContractSerializer` `NetDataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-244">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace were explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="b4af8-245">Daha fazla bilgi için bkz. [serileştirme ve seri durumundan çıkarma](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="b4af8-245">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>  
  
- <span data-ttu-id="b4af8-246">Yapılandırma zamanında kök adı ve ad alanını belirtmeden en üst düzeyde bir öğe türü serileştirilirken <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> ve <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> temelde hiçbir şey ve <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> çağrı yapmaz `WriteXml` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-246">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially does nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="b4af8-247">Bu modda, serileştirilmekte olan nesne null olamaz ve polymorphically atanamaz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-247">In this mode, the object being serialized cannot be null and cannot be polymorphically assigned.</span></span> <span data-ttu-id="b4af8-248">Ayrıca, nesne grafiği koruması etkinleştirilemez ve kullanılamaz `NetDataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-248">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>  
  
- <span data-ttu-id="b4af8-249">Yapılandırma sırasında kök adı ve ad alanını belirtmeden en üst düzeyde bir öğe türü seri durumdan çıkarılırken, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> `true` herhangi bir öğenin başlangıcını bulabiliyorsanız ' ı döndürür.</span><span class="sxs-lookup"><span data-stu-id="b4af8-249">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="b4af8-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> parametresi, `verifyObjectName` `true` `IsStartObject` nesne gerçekten okunmadan önce ile aynı şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-250"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="b4af8-251">`ReadObject` sonra denetimi yöntemine geçirir `ReadXml` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-251">`ReadObject` then passes control to `ReadXml` method.</span></span>  
  
 <span data-ttu-id="b4af8-252">Öğe türleri için aktarılmış şema, `XmlElement` şema sağlayıcısı yönteminin <xref:System.Xml.Schema.XmlSchemaSet> içerik türleriyle olduğu gibi ek bir şema ekleyebildiğinden, daha önceki bir bölümde açıklanan tür ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-252">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="b4af8-253">`XmlRootAttribute`Özniteliğin öğe türleriyle kullanılmasına izin verilmez ve genel öğe bildirimleri bu türler için hiçbir şekilde yayılmaz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-253">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>  
  
### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="b4af8-254">XmlSerializer 'ın farkları</span><span class="sxs-lookup"><span data-stu-id="b4af8-254">Differences from the XmlSerializer</span></span>  

 <span data-ttu-id="b4af8-255">`IXmlSerializable`Arabirimi ve `XmlSchemaProviderAttribute` ve `XmlRootAttribute` öznitelikleri de tarafından anlaşılamalıdır <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="b4af8-255">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="b4af8-256">Bununla birlikte, bunların veri anlaşması modelinde nasıl ele alınların bazı farklılıkları vardır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-256">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="b4af8-257">Önemli farklılıklar aşağıda özetlenmiştir:</span><span class="sxs-lookup"><span data-stu-id="b4af8-257">The important differences are summarized in the following:</span></span>  
  
- <span data-ttu-id="b4af8-258">Şema sağlayıcısı yönteminin ' de kullanılabilmesi için genel olması gerekir `XmlSerializer` , ancak veri sözleşmesi modelinde kullanılabilmesi için genel olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="b4af8-258">The schema provider method must be public to be usable in the `XmlSerializer`, but does not have to be public to be usable in the data contract model.</span></span>  
  
- <span data-ttu-id="b4af8-259">Şema sağlayıcısı yöntemi `IsAny` , veri anlaşması modelinde doğru olduğunda çağrılır, ancak ile değil `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-259">The schema provider method is called when `IsAny` is true in the data contract model but not with the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="b4af8-260">`XmlRootAttribute`İçerik veya eski veri kümesi türleri için öznitelik mevcut olmadığında, `XmlSerializer` boş ad alanında genel bir öğe bildirimini dışarı aktarır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-260">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="b4af8-261">Veri anlaşması modelinde, kullanılan ad alanı normalde daha önce açıklandığı gibi veri sözleşmesi ad alanıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-261">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>  
  
 <span data-ttu-id="b4af8-262">Serileştirme teknolojileriyle birlikte kullanılan türler oluşturulurken bu farklılıklara dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="b4af8-262">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>  
  
### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="b4af8-263">IXmlSerializable şeması içeri aktarılıyor</span><span class="sxs-lookup"><span data-stu-id="b4af8-263">Importing IXmlSerializable Schema</span></span>  

 <span data-ttu-id="b4af8-264">Türlerden oluşturulan bir şemayı içeri aktarırken `IXmlSerializable` birkaç olasılık vardır:</span><span class="sxs-lookup"><span data-stu-id="b4af8-264">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>  
  
- <span data-ttu-id="b4af8-265">Oluşturulan şema, [veri sözleşmesi şema başvurusunda](data-contract-schema-reference.md)açıklandığı gibi geçerli bir veri anlaşması şeması olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-265">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="b4af8-266">Bu durumda, her zamanki gibi şema içeri aktarılabilir ve normal veri anlaşması türleri oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-266">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>  
  
- <span data-ttu-id="b4af8-267">Oluşturulan şema geçerli bir veri anlaşması şeması olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-267">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="b4af8-268">Örneğin, şema sağlayıcınız yönteminiz, veri anlaşması modelinde desteklenmeyen XML özniteliklerini içeren bir şema oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-268">For example, your schema provider method may generate schema that involves XML attributes which are not supported in the data contract model.</span></span> <span data-ttu-id="b4af8-269">Bu durumda, şemayı türler olarak içeri aktarabilirsiniz `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-269">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="b4af8-270">Bu içeri aktarma modu varsayılan olarak açık değildir ancak örneğin, `/importXmlTypes` [ServiceModel meta veri yardımcı programı aracına (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)komut satırı anahtarı ile birlikte kolayca etkinleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-270">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="b4af8-271">Bu, [sınıfları oluşturmak Için Içeri aktarma şemasında](importing-schema-to-generate-classes.md)ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-271">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="b4af8-272">Doğrudan tür örneklerinizin XML ile birlikte çalışmanız gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b4af8-272">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="b4af8-273">Ayrıca, daha geniş bir şema aralığını destekleyen farklı bir serileştirme teknolojisi kullanmayı da düşünebilirsiniz; bkz. kullanma konusu `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-273">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>  
  
- <span data-ttu-id="b4af8-274">Mevcut `IXmlSerializable` türlerinizi yeni bir oluşturma yerine proxy 'de yeniden kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-274">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="b4af8-275">Bu durumda, tür oluşturmak için şemayı Içeri aktarma konu başlığı altında açıklanan Başvurulmuş türler özelliği, yeniden kullanılacak türü belirtmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-275">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="b4af8-276">Bu, `/reference` yeniden kullanılacak türleri içeren derlemeyi belirten svcutil.exe üzerinde anahtarı kullanmaya karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-276">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>  
  
## <a name="representing-arbitrary-xml-in-data-contracts"></a><span data-ttu-id="b4af8-277">Veri sözleşmelerinde rastgele XML 'yi temsil etme</span><span class="sxs-lookup"><span data-stu-id="b4af8-277">Representing Arbitrary XML in Data Contracts</span></span>  

 <span data-ttu-id="b4af8-278">, `XmlElement` `XmlNode` Ve türleri dizisi, `IXmlSerializable` veri ANLAŞMASı modeline rastgele XML eklemenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-278">The `XmlElement`, Array of `XmlNode` and `IXmlSerializable` types allow you to inject arbitrary XML into the data contract model.</span></span> <span data-ttu-id="b4af8-279">`DataContractSerializer`Ve `NetDataContractSerializer` Bu XML içeriğini, işlemde kesintiye uğramadan KULLANıMDA olan XML yazıcı 'ya iletir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-279">The `DataContractSerializer` and `NetDataContractSerializer` pass this XML content on to the XML writer in use, without interfering in the process.</span></span> <span data-ttu-id="b4af8-280">Ancak, XML yazarları, yazdıkları XML üzerinde belirli kısıtlamaları uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-280">However, the XML writers may enforce certain restrictions on the XML that they write.</span></span> <span data-ttu-id="b4af8-281">Özellikle, bazı önemli örnekler aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="b4af8-281">Specifically, here are some important examples:</span></span>  
  
- <span data-ttu-id="b4af8-282">XML yazarları genellikle \<?xml version=’1.0’ ?> başka bir belge yazmanın ortasında BIR XML belge bildirimine (örneğin,) izin vermez.</span><span class="sxs-lookup"><span data-stu-id="b4af8-282">The XML writers do not typically allow an XML document declaration (for example, \<?xml version=’1.0’ ?>) in the middle of writing another document.</span></span> <span data-ttu-id="b4af8-283">Tam bir XML belgesi alıp veri üyesi olarak seri hale getirilemiyor `Array` `XmlNode` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-283">You cannot take a full XML document and serialize it as an `Array` of `XmlNode` data member.</span></span> <span data-ttu-id="b4af8-284">Bunu yapmak için, belge bildirimini çıkarmanız veya kendi kodlama düzeninizi kullanarak temsil etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-284">To do this, you have to either strip out the document declaration or use your own encoding scheme to represent it.</span></span>  
  
- <span data-ttu-id="b4af8-285">WCF ile sağlanan tüm XML yazarları \<? … ?> , SOAP iletilerinde izin VERILMEDIĞINDEN XML işleme talimatlarını () ve belge türü tanımlarını ( \<! … > ) reddeder.</span><span class="sxs-lookup"><span data-stu-id="b4af8-285">All of the XML writers supplied with WCF reject XML processing instructions (\<? … ?>) and document type definitions (\<! … >), because they are not allowed in SOAP messages.</span></span> <span data-ttu-id="b4af8-286">Yine, bu kısıtlamayı gidermek için kendi kodlama mekanizmanızı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-286">Again, you can use your own encoding mechanism to get around this restriction.</span></span> <span data-ttu-id="b4af8-287">Bunları sonuç XML 'nize dahil etmeniz gerekiyorsa, bunları destekleyen XML yazıcılarını kullanan özel bir kodlayıcı yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-287">If you must include these in your resultant XML, you can write a custom encoder that uses XML writers that support them.</span></span>  
  
- <span data-ttu-id="b4af8-288">Uygulamasını uygularken `WriteXml` , <xref:System.Xml.XmlWriter.WriteRaw%2A> XML yazıcı üzerinde çağırma yöntemini kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="b4af8-288">When implementing `WriteXml`, avoid calling <xref:System.Xml.XmlWriter.WriteRaw%2A> method on the XML writer.</span></span> <span data-ttu-id="b4af8-289">WCF çeşitli XML kodlamaları kullanır (ikili dahil), `WriteRaw` sonucun herhangi bir kodlamada kullanılabilir olması gibi çok zor veya imkansız olur.</span><span class="sxs-lookup"><span data-stu-id="b4af8-289">WCF uses a variety of XML encodings (including binary), it is very difficult or impossible to use `WriteRaw` such that the result is usable in any encoding.</span></span>  
  
- <span data-ttu-id="b4af8-290">`WriteXml`' Yi uygularken, <xref:System.Xml.XmlWriter.WriteEntityRef%2A> <xref:System.Xml.XmlWriter.WriteNmToken%2A> WCF ile sağlanan xml yazıcılarında desteklenmeyen ve yöntemlerini kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="b4af8-290">When implementing `WriteXml`, avoid using the <xref:System.Xml.XmlWriter.WriteEntityRef%2A> and <xref:System.Xml.XmlWriter.WriteNmToken%2A> methods that are unsupported on the XML writers supplied with WCF.</span></span>  
  
## <a name="using-dataset-typed-dataset-and-datatable"></a><span data-ttu-id="b4af8-291">Veri kümesi, türü belirtilmiş veri kümesi ve DataTable kullanma</span><span class="sxs-lookup"><span data-stu-id="b4af8-291">Using DataSet, Typed DataSet and DataTable</span></span>  

 <span data-ttu-id="b4af8-292">Bu türlerin kullanılması, veri anlaşması modelinde tam olarak desteklenmektedir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-292">Using these types is fully supported in the data contract model.</span></span> <span data-ttu-id="b4af8-293">Bu türleri kullanırken aşağıdaki noktaları göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="b4af8-293">When using these types, consider the following points:</span></span>  
  
- <span data-ttu-id="b4af8-294">Bu türlerin şeması (özellikle <xref:System.Data.DataSet> ve türü belirtilmiş türetilmiş sınıfları), bazı WCF olmayan platformlarda birlikte çalışabilir veya bu platformlarla birlikte kullanıldığında zayıf kullanılabilirlik oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-294">The schema for these types (especially <xref:System.Data.DataSet> and its typed derived classes) may not be interoperable with some non-WCF platforms, or may result in poor usability when used with these platforms.</span></span> <span data-ttu-id="b4af8-295">Ayrıca, türü kullanmanın `DataSet` performansı olumsuz etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-295">Additionally, using the `DataSet` type may have performance implications.</span></span> <span data-ttu-id="b4af8-296">Son olarak, uygulamanızı gelecekte uygulamanızı daha kolay hale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-296">Finally, it may make it more difficult for you to version your application in the future.</span></span> <span data-ttu-id="b4af8-297">Sözleşmenizde türler yerine açıkça tanımlanmış veri anlaşması türlerini kullanmayı düşünün `DataSet` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-297">Consider using explicitly defined data contract types instead of `DataSet` types in your contracts.</span></span>  
  
- <span data-ttu-id="b4af8-298">`DataSet`Veya şeması içeri aktarırken `DataTable` , bu türlere başvurmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-298">When importing `DataSet` or `DataTable` schema, it is important to reference these types.</span></span> <span data-ttu-id="b4af8-299">Svcutil.exe komut satırı aracı ile, bu, System.Data.dll bütünleştirilmiş kod adı anahtara geçirilerek gerçekleştirilebilir `/reference` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-299">With the Svcutil.exe command-line tool, this can be accomplished by passing the System.Data.dll assembly name to the `/reference` switch.</span></span> <span data-ttu-id="b4af8-300">Türü belirtilmiş veri kümesi şeması içeri aktarıldıysanız, türü belirtilmiş veri kümesinin türüne başvurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-300">If importing typed dataset schema, you must reference the typed dataset’s type.</span></span> <span data-ttu-id="b4af8-301">Svcutil.exe, yazılan veri kümesinin derlemesinin konumunu `/reference` anahtara geçirin.</span><span class="sxs-lookup"><span data-stu-id="b4af8-301">With Svcutil.exe, pass the location of the typed dataset’s assembly to the `/reference` switch.</span></span> <span data-ttu-id="b4af8-302">Başvuru türleri hakkında daha fazla bilgi için bkz. [sınıfları oluşturmak Için Içeri aktarma şeması](importing-schema-to-generate-classes.md).</span><span class="sxs-lookup"><span data-stu-id="b4af8-302">For more information about referencing types, see the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span>  
  
 <span data-ttu-id="b4af8-303">Veri anlaşması modelinde yazılı veri kümeleri için destek sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="b4af8-303">Support for typed DataSets in the data contract model is limited.</span></span> <span data-ttu-id="b4af8-304">Türü belirtilmiş veri kümeleri serileştirilmiş ve seri durumdan çıkarılmış olabilir ve kendi şemasını dışarı aktarabilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-304">Typed DataSets can be serialized and deserialized and can export their schema.</span></span> <span data-ttu-id="b4af8-305">Ancak, veri anlaşması şeması içeri aktarma işlemi yalnızca var olanları yeniden kullanabilmesi için şemadan yeni tür belirtilmiş veri kümesi türleri oluşturamıyor.</span><span class="sxs-lookup"><span data-stu-id="b4af8-305">However, the Data Contract schema import is unable to generate new typed DataSet types from the schema, as it can only reuse existing ones.</span></span> <span data-ttu-id="b4af8-306">Svcutil.exe anahtarı kullanarak var olan bir türü belirtilmiş veri kümesini işaret edebilirsiniz `/r` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-306">You can point to an existing typed DataSet by using the `/r` switch on Svcutil.exe.</span></span> <span data-ttu-id="b4af8-307">`/r`Türü belirtilmiş bir veri kümesi kullanan bir hizmette anahtar olmadan bir Svcutil.exe kullanmayı denerseniz, otomatik olarak bir alternatif serileştirici (XmlSerializer) seçilir.</span><span class="sxs-lookup"><span data-stu-id="b4af8-307">If you attempt to use a Svcutil.exe without the `/r` switch on a service that uses a typed dataset, an alternative serializer (XmlSerializer) is automatically selected.</span></span> <span data-ttu-id="b4af8-308">DataContractSerializer ' i kullanmanız ve şemadan veri kümeleri oluşturmanız gerekiyorsa, aşağıdaki yordamı kullanabilirsiniz: türü belirtilmiş veri kümesi türlerini oluşturma ( `/d` hizmet üzerinde anahtarla Xsd.exe aracını kullanarak), türleri derleyin ve sonra Svcutil.exe anahtarı kullanarak bunları işaret edin `/r` .</span><span class="sxs-lookup"><span data-stu-id="b4af8-308">If you must use the DataContractSerializer and must generate DataSets from schema, you can use the following procedure: generate the typed DataSet types (by using the Xsd.exe tool with the `/d` switch on the service), compile the types, and then point to them using the `/r` switch on Svcutil.exe.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b4af8-309">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="b4af8-309">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.IXmlSerializable>
- [<span data-ttu-id="b4af8-310">Veri Sözleşmelerini Kullanma</span><span class="sxs-lookup"><span data-stu-id="b4af8-310">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="b4af8-311">Veri Sözleşmesi Seri Hale Getirici Tarafından Desteklenen Türler</span><span class="sxs-lookup"><span data-stu-id="b4af8-311">Types Supported by the Data Contract Serializer</span></span>](types-supported-by-the-data-contract-serializer.md)
