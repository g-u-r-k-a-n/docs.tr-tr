---
title: Görev Tabanlı Zaman Uyumsuz Deseni Uygulama
description: Bu makalede, görev tabanlı zaman uyumsuz düzenin nasıl uygulanacağı açıklanmaktadır. İşlem bağlantılı ve g/ç ile bağlantılı zaman uyumsuz işlemleri uygulamak için bunu kullanabilirsiniz.
ms.date: 06/14/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: fab6bd41-91bd-44ad-86f9-d8319988aa78
ms.openlocfilehash: 1f2f44b6b92f66f95816778c6dc8e893f1291abe
ms.sourcegitcommit: 33deec3e814238fb18a49b2a7e89278e27888291
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/02/2020
ms.locfileid: "84289375"
---
# <a name="implementing-the-task-based-asynchronous-pattern"></a><span data-ttu-id="c27d6-104">Görev Tabanlı Zaman Uyumsuz Deseni Uygulama</span><span class="sxs-lookup"><span data-stu-id="c27d6-104">Implementing the Task-based Asynchronous Pattern</span></span>
<span data-ttu-id="c27d6-105">Görev tabanlı zaman uyumsuz model ' i (dokunarak) üç şekilde uygulayabilirsiniz: C# ve Visual Basic derleyicileri, Visual Studio 'da, el ile veya derleyicinin ve el ile yapılan yöntemlerin bir birleşimi aracılığıyla.</span><span class="sxs-lookup"><span data-stu-id="c27d6-105">You can implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span> <span data-ttu-id="c27d6-106">Aşağıdaki bölümlerde her bir yöntem ayrıntılı olarak ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="c27d6-106">The following sections discuss each method in detail.</span></span> <span data-ttu-id="c27d6-107">İşlem-bağlantılı ve g/ç ile bağlantılı zaman uyumsuz işlemleri uygulamak için dokunma düzenine de yararlanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-107">You can use the TAP pattern to implement both compute-bound and I/O-bound asynchronous operations.</span></span> <span data-ttu-id="c27d6-108">[Iş yükleri](#workloads) bölümü her bir işlem türünü ele alır.</span><span class="sxs-lookup"><span data-stu-id="c27d6-108">The [Workloads](#workloads) section discusses each type of operation.</span></span>

## <a name="generating-tap-methods"></a><span data-ttu-id="c27d6-109">DOKUNMA yöntemlerini oluşturma</span><span class="sxs-lookup"><span data-stu-id="c27d6-109">Generating TAP methods</span></span>

### <a name="using-the-compilers"></a><span data-ttu-id="c27d6-110">Derleyicileri kullanma</span><span class="sxs-lookup"><span data-stu-id="c27d6-110">Using the compilers</span></span>
<span data-ttu-id="c27d6-111">.NET Framework 4,5 ' den başlayarak, `async` anahtar kelimesiyle ( `Async` Visual Basic) nitelendirilen tüm yöntemler zaman uyumsuz bir yöntem olarak değerlendirilir ve C# ve Visual Basic DERLEYICILERI, dokunarak yöntemi zaman uyumsuz olarak uygulamak için gereken dönüştürmeleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-111">Starting with .NET Framework 4.5, any method that is attributed with the `async` keyword (`Async` in Visual Basic) is considered an asynchronous method, and the C# and Visual Basic compilers perform the necessary transformations to implement the method asynchronously by using TAP.</span></span> <span data-ttu-id="c27d6-112">Zaman uyumsuz bir yöntem, ya da <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> bir <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> nesnesi döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-112">An asynchronous method should return either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="c27d6-113">İkincisi için, işlevin gövdesi bir döndürmelidir `TResult` ve derleyici bu sonucun elde edilen görev nesnesi aracılığıyla kullanılabilir hale gelmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="c27d6-113">For the latter, the body of the function should return a `TResult`, and the compiler ensures that this result is made available through the resulting task object.</span></span> <span data-ttu-id="c27d6-114">Benzer şekilde, yöntemin gövdesinde işlenmemiş olan tüm özel durumlar, çıkış görevine göre sıralanır ve sonuçta elde edilen görevin durumunda sonlanmasına neden olur <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-114">Similarly, any exceptions that go unhandled within the body of the method are marshaled to the output task and cause the resulting task to end in the <xref:System.Threading.Tasks.TaskStatus.Faulted?displayProperty=nameWithType> state.</span></span> <span data-ttu-id="c27d6-115">Bu kuralın istisnası, bir <xref:System.OperationCanceledException> (ya da türetilmiş tür) işlenmemiş olduğunda, sonuçta elde edilen görevin durumu sona erdiği durumdur <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-115">The exception to this rule is when an <xref:System.OperationCanceledException> (or derived type) goes unhandled, in which case the resulting task ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled?displayProperty=nameWithType> state.</span></span>

### <a name="generating-tap-methods-manually"></a><span data-ttu-id="c27d6-116">DOKUNMA yöntemlerini el ile oluşturma</span><span class="sxs-lookup"><span data-stu-id="c27d6-116">Generating TAP methods manually</span></span>
<span data-ttu-id="c27d6-117">Uygulama üzerinde daha iyi denetim için dokunma deseninin el ile uygulanmasını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-117">You may implement the TAP pattern manually for better control over implementation.</span></span> <span data-ttu-id="c27d6-118">Derleyici, ad <xref:System.Threading.Tasks?displayProperty=nameWithType> alanı ve ad alanındaki destekleme türlerinden açığa çıkarılan genel yüzey alanını kullanır <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-118">The compiler relies on the public surface area exposed from the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace and supporting types in the <xref:System.Runtime.CompilerServices?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="c27d6-119">DOKUNARAK kendinize uygulamak için bir <xref:System.Threading.Tasks.TaskCompletionSource%601> nesne oluşturur, zaman uyumsuz işlem gerçekleştirir ve tamamlandığında,, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A> <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> veya <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> yöntemini ya da `Try` Bu yöntemlerin birinin sürümünü çağırın.</span><span class="sxs-lookup"><span data-stu-id="c27d6-119">To implement the TAP yourself, you create a <xref:System.Threading.Tasks.TaskCompletionSource%601> object, perform the asynchronous operation, and when it completes, call the <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, or <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> method, or the `Try` version of one of these methods.</span></span> <span data-ttu-id="c27d6-120">DOKUNMA yöntemini el ile uyguladığınızda, gösterilen zaman uyumsuz işlem tamamlandığında ortaya çıkan görevi tamamlamalısınız.</span><span class="sxs-lookup"><span data-stu-id="c27d6-120">When you implement a TAP method manually, you must complete the resulting task when the represented asynchronous operation completes.</span></span> <span data-ttu-id="c27d6-121">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="c27d6-121">For example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#1)]
[!code-vb[Conceptual.TAP_Patterns#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#1)]

### <a name="hybrid-approach"></a><span data-ttu-id="c27d6-122">Karma yaklaşım</span><span class="sxs-lookup"><span data-stu-id="c27d6-122">Hybrid approach</span></span>
 <span data-ttu-id="c27d6-123">DOKUNMA deseninin el ile uygulanmasını, ancak derleyicinin çekirdek mantığını derleyiciye devretmek için yararlı bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-123">You may find it useful to implement the TAP pattern manually but to delegate the core logic for the implementation to the compiler.</span></span> <span data-ttu-id="c27d6-124">Örneğin, bir derleyicinin ürettiği zaman uyumsuz yöntem dışındaki bağımsız değişkenleri doğrulamak istediğinizde karma yaklaşımı kullanmak isteyebilirsiniz, böylece özel durumlar, nesne aracılığıyla gösterilmektense metodun doğrudan çağıranına çıkabilir <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="c27d6-124">For example, you may want to use the hybrid approach when you want to verify arguments outside a compiler-generated asynchronous method so that exceptions can escape to the method’s direct caller rather than being exposed through the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object:</span></span>

 [!code-csharp[Conceptual.TAP_Patterns#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#2)]
 [!code-vb[Conceptual.TAP_Patterns#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#2)]

 <span data-ttu-id="c27d6-125">Bu tür bir temsilcinin yararlı olduğu başka bir durum da hızlı yol iyileştirme uygulıyoruz ve önbelleğe alınmış bir görevi döndürmek isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-125">Another case where such delegation is useful is when you're implementing fast-path optimization and want to return a cached task.</span></span>

## <a name="workloads"></a><span data-ttu-id="c27d6-126">İş yükleri</span><span class="sxs-lookup"><span data-stu-id="c27d6-126">Workloads</span></span>
<span data-ttu-id="c27d6-127">İşlem-bağlantılı ve g/ç ile bağlantılı zaman uyumsuz işlemleri dokunarak yöntemler olarak uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-127">You may implement both compute-bound and I/O-bound asynchronous operations as TAP methods.</span></span> <span data-ttu-id="c27d6-128">Bununla birlikte, bir kitaplıktan ortak yöntemler genel kullanıma sunulduğunda, yalnızca g/ç 'ye bağlanan işlemleri içeren iş yükleri için sağlanması gerekir (hesaplamayı da içerebilir, ancak tamamen hesaplama olmamalıdır).</span><span class="sxs-lookup"><span data-stu-id="c27d6-128">However, when TAP methods are exposed publicly from a library, they should be provided only for workloads that involve I/O-bound operations (they may also involve computation, but should not be purely computational).</span></span> <span data-ttu-id="c27d6-129">Bir yöntem yalnızca işlem bağlantılı ise, yalnızca zaman uyumlu bir uygulama olarak kullanıma sunulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c27d6-129">If a method is purely compute-bound, it should be exposed only as a synchronous implementation.</span></span> <span data-ttu-id="c27d6-130">Bunu kullanan kod daha sonra, işi başka bir iş parçacığına devretmek veya paralellik elde etmek için, bu zaman uyumlu yöntemin bir çağrısını bir göreve sarmayı tercih edebilir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-130">The code that consumes it may then choose whether to wrap an invocation of that synchronous method into a task to offload the work to another thread or to achieve parallelism.</span></span> <span data-ttu-id="c27d6-131">Bir yöntem g/ç bağlantılı ise, yalnızca zaman uyumsuz bir uygulama olarak kullanıma sunulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c27d6-131">And if a method is I/O-bound, it should be exposed only as an asynchronous implementation.</span></span>

### <a name="compute-bound-tasks"></a><span data-ttu-id="c27d6-132">İşlem bağlantılı görevler</span><span class="sxs-lookup"><span data-stu-id="c27d6-132">Compute-bound tasks</span></span>
<span data-ttu-id="c27d6-133"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType>Sınıfı, yoğun şekilde yoğun işlemleri temsil etmek için idealdir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-133">The <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class is ideally suited for representing computationally intensive operations.</span></span> <span data-ttu-id="c27d6-134">Varsayılan olarak, <xref:System.Threading.ThreadPool> verimli yürütme sağlamak için sınıfındaki özel desteğin avantajlarından yararlanır ve ayrıca zaman uyumsuz hesaplamaların ne zaman, nerede ve nasıl yürütüldüğü üzerinde önemli bir denetim sağlar.</span><span class="sxs-lookup"><span data-stu-id="c27d6-134">By default, it takes advantage of special support within the <xref:System.Threading.ThreadPool> class to provide efficient execution, and it also provides significant control over when, where, and how asynchronous computations execute.</span></span>

<span data-ttu-id="c27d6-135">Aşağıdaki yollarla, işlem ile bağlantılı görevler oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="c27d6-135">You can generate compute-bound tasks in the following ways:</span></span>

- <span data-ttu-id="c27d6-136">.NET Framework 4 ' te, <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> zaman uyumsuz olarak yürütülecek bir temsilciyi (genellikle bir <xref:System.Action%601> veya a) kabul eden yöntemini kullanın <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-136">In the .NET Framework 4, use the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method, which accepts a delegate (typically an <xref:System.Action%601> or a <xref:System.Func%601>) to be executed asynchronously.</span></span> <span data-ttu-id="c27d6-137">Bir <xref:System.Action%601> temsilci sağlarsanız, yöntemi <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> Bu temsilcinin zaman uyumsuz yürütmesini temsil eden bir nesne döndürür.</span><span class="sxs-lookup"><span data-stu-id="c27d6-137">If you provide an <xref:System.Action%601> delegate, the method returns a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> object that represents the asynchronous execution of that delegate.</span></span> <span data-ttu-id="c27d6-138">Bir <xref:System.Func%601> temsilci sağlarsanız, yöntemi bir <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> nesnesi döndürür.</span><span class="sxs-lookup"><span data-stu-id="c27d6-138">If you provide a <xref:System.Func%601> delegate, the method returns a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="c27d6-139">Yöntemin aşırı yüklemeleri, <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> bir iptal belirtecini ( <xref:System.Threading.CancellationToken> ), görev oluşturma seçeneklerini ( <xref:System.Threading.Tasks.TaskCreationOptions> ) ve bir görev zamanlayıcısını () kabul eder <xref:System.Threading.Tasks.TaskScheduler> . Bu, hepsi görevin zamanlanması ve yürütülmesi üzerinde ayrıntılı denetim sağlar.</span><span class="sxs-lookup"><span data-stu-id="c27d6-139">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method accept a cancellation token (<xref:System.Threading.CancellationToken>), task creation options (<xref:System.Threading.Tasks.TaskCreationOptions>), and a task scheduler (<xref:System.Threading.Tasks.TaskScheduler>), all of which provide fine-grained control over the scheduling and execution of the task.</span></span> <span data-ttu-id="c27d6-140">Geçerli görev zamanlayıcısını hedefleyen bir fabrika örneği, sınıfının statik özelliği () olarak kullanılabilir <xref:System.Threading.Tasks.Task.Factory%2A> <xref:System.Threading.Tasks.Task> . Örneğin: `Task.Factory.StartNew(…)` .</span><span class="sxs-lookup"><span data-stu-id="c27d6-140">A factory instance that targets the current task scheduler is available as a static property (<xref:System.Threading.Tasks.Task.Factory%2A>) of the <xref:System.Threading.Tasks.Task> class; for example: `Task.Factory.StartNew(…)`.</span></span>

- <span data-ttu-id="c27d6-141">.NET Framework 4,5 ve sonraki sürümlerde (.NET Core ve .NET Standard dahil), <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> için bir kısayol olarak statik yöntemi kullanın <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-141">In the .NET Framework 4.5 and later versions (including .NET Core and .NET Standard), use the static <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method as a shortcut to <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c27d6-142"><xref:System.Threading.Tasks.Task.Run%2A>İş parçacığı havuzunu hedefleyen bir işlem ile bağlantılı görevi kolayca başlatmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-142">You may use <xref:System.Threading.Tasks.Task.Run%2A> to easily launch a compute-bound task that targets the thread pool.</span></span> <span data-ttu-id="c27d6-143">.NET Framework 4,5 ve sonraki sürümlerde, bu, işlem ile sınırlı bir görevi başlatmak için tercih edilen mekanizmadır.</span><span class="sxs-lookup"><span data-stu-id="c27d6-143">In the .NET Framework 4.5 and later versions, this is the preferred mechanism for launching a compute-bound task.</span></span> <span data-ttu-id="c27d6-144">`StartNew`Yalnızca görev üzerinde daha ayrıntılı denetim istediğinizde, doğrudan kullanın.</span><span class="sxs-lookup"><span data-stu-id="c27d6-144">Use `StartNew` directly only when you want more fine-grained control over the task.</span></span>

- <span data-ttu-id="c27d6-145">`Task` `Start` Görevi ayrı olarak oluşturmak ve çizelgelemek istiyorsanız tür veya yöntem oluşturucularını kullanın.</span><span class="sxs-lookup"><span data-stu-id="c27d6-145">Use the constructors of the `Task` type or the `Start` method if you want to generate and schedule the task separately.</span></span> <span data-ttu-id="c27d6-146">Ortak yöntemler yalnızca önceden başlatılmış görevleri döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-146">Public methods must only return tasks that have already been started.</span></span>

- <span data-ttu-id="c27d6-147">Yönteminin aşırı yüklerini kullanın <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-147">Use the overloads of the <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c27d6-148">Bu yöntem, başka bir görev tamamlandığında zamanlanan yeni bir görev oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c27d6-148">This method creates a new task that is scheduled when another task completes.</span></span> <span data-ttu-id="c27d6-149">Bazı <xref:System.Threading.Tasks.Task.ContinueWith%2A> aşırı yüklemeler bir iptal etme belirteci, devamlılık seçeneklerini ve devam görevinin zamanlanması ve yürütülmesi üzerinde daha iyi denetim için bir görev zamanlayıcısını kabul eder.</span><span class="sxs-lookup"><span data-stu-id="c27d6-149">Some of the <xref:System.Threading.Tasks.Task.ContinueWith%2A> overloads accept a cancellation token, continuation options, and a task scheduler for better control over the scheduling and execution of the continuation task.</span></span>

- <span data-ttu-id="c27d6-150"><xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType>Ve yöntemlerini kullanın <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-150">Use the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="c27d6-151">Bu yöntemler, sağlanan bir görev kümesinin tümü veya herhangi biri tamamlandığında zamanlanan yeni bir görev oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c27d6-151">These methods create a new task that is scheduled when all or any of a supplied set of tasks completes.</span></span> <span data-ttu-id="c27d6-152">Bu yöntemler Ayrıca, bu görevlerin planlanmasını ve yürütülmesini denetlemek için aşırı yüklemeler sağlar.</span><span class="sxs-lookup"><span data-stu-id="c27d6-152">These methods also provide overloads to control the scheduling and execution of these tasks.</span></span>

<span data-ttu-id="c27d6-153">İşlem bağlantılı görevlerde, sistem, görevi çalıştırmaya başlamadan önce bir iptal isteği alırsa, zamanlanmış bir görevin yürütülmesini önleyebilir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-153">In compute-bound tasks, the system can prevent the execution of a scheduled task if it receives a cancellation request before it starts running the task.</span></span> <span data-ttu-id="c27d6-154">Bu nedenle, bir iptal belirteci ( <xref:System.Threading.CancellationToken> nesne) sağlarsanız, belirteci izleyen zaman uyumsuz koda bu belirteci geçirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-154">As such, if you provide a cancellation token (<xref:System.Threading.CancellationToken> object), you can pass that token to the asynchronous code that monitors the token.</span></span> <span data-ttu-id="c27d6-155">Ayrıca `StartNew` , ya da `Run` `Task` çalışma zamanının belirteci izleyebilmesi için, veya gibi yukarıda bahsedilen metotlardan birine belirteç sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-155">You can also provide the token to one of the previously mentioned methods such as `StartNew` or `Run` so that the `Task` runtime may also monitor the token.</span></span>

<span data-ttu-id="c27d6-156">Örneğin, bir görüntüyü işleyen zaman uyumsuz bir yöntem düşünün.</span><span class="sxs-lookup"><span data-stu-id="c27d6-156">For example, consider an asynchronous method that renders an image.</span></span> <span data-ttu-id="c27d6-157">Görevin gövdesi, işleme sırasında bir iptal isteği geldiğinde kodun erken çıkabilmesi için iptal belirtecini yoklayabilirler.</span><span class="sxs-lookup"><span data-stu-id="c27d6-157">The body of the task can poll the cancellation token so that the code may exit early if a cancellation request arrives during rendering.</span></span> <span data-ttu-id="c27d6-158">Ayrıca, işleme başlamadan önce iptal isteği alınırsa, işleme işlemini engellemek isteyeceksiniz:</span><span class="sxs-lookup"><span data-stu-id="c27d6-158">In addition, if the cancellation request arrives before rendering starts, you'll want to prevent the rendering operation:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#3)]
[!code-vb[Conceptual.TAP_Patterns#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#3)]

<span data-ttu-id="c27d6-159"><xref:System.Threading.Tasks.TaskStatus.Canceled>Aşağıdaki koşullardan en az biri doğru ise, işlem bağlantılı görevler bir durum ile biter:</span><span class="sxs-lookup"><span data-stu-id="c27d6-159">Compute-bound tasks end in a <xref:System.Threading.Tasks.TaskStatus.Canceled> state if at least one of the following conditions is true:</span></span>

- <span data-ttu-id="c27d6-160">Bir iptal isteği <xref:System.Threading.CancellationToken> , `StartNew` `Run` görev durumuna geçmeden önce oluşturma yöntemine (örneğin, veya) bağımsız değişken olarak belirtilen nesnesine ulaşır <xref:System.Threading.Tasks.TaskStatus.Running> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-160">A cancellation request arrives through the <xref:System.Threading.CancellationToken> object, which is provided as an argument to the creation method (for example, `StartNew` or `Run`) before the task transitions to the <xref:System.Threading.Tasks.TaskStatus.Running> state.</span></span>

- <span data-ttu-id="c27d6-161">Bu <xref:System.OperationCanceledException> tür bir görevin gövdesinde işlenmeyen bir özel durum, bu özel durum <xref:System.Threading.CancellationToken> göreve geçirilmiş ve bu belirteç iptalinin istendiğini gösterdiği bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="c27d6-161">An <xref:System.OperationCanceledException> exception goes unhandled within the body of such a task, that exception contains the same <xref:System.Threading.CancellationToken> that is passed to the task, and that token shows that cancellation is requested.</span></span>

<span data-ttu-id="c27d6-162">Görevin gövdesinde başka bir özel durum yakalanıyorsa, görev <xref:System.Threading.Tasks.TaskStatus.Faulted> durumunda sonlanır ve görevde bekleyen ya da sonuç olarak bir özel durum oluşturulmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="c27d6-162">If another exception goes unhandled within the body of the task, the task ends in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, and any attempts to wait on the task or access its result causes an exception to be thrown.</span></span>

### <a name="io-bound-tasks"></a><span data-ttu-id="c27d6-163">G/ç bağlantılı görevler</span><span class="sxs-lookup"><span data-stu-id="c27d6-163">I/O-bound tasks</span></span>
<span data-ttu-id="c27d6-164">Yürütmenin tamamı için bir iş parçacığı tarafından doğrudan yedeklenmez bir görev oluşturmak için <xref:System.Threading.Tasks.TaskCompletionSource%601> türünü kullanın.</span><span class="sxs-lookup"><span data-stu-id="c27d6-164">To create a task that should not be directly backed by a thread for the entirety of its execution, use the <xref:System.Threading.Tasks.TaskCompletionSource%601> type.</span></span> <span data-ttu-id="c27d6-165">Bu tür <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> , ilişkili bir örnek döndüren bir özelliği gösterir <xref:System.Threading.Tasks.Task%601> .</span><span class="sxs-lookup"><span data-stu-id="c27d6-165">This type exposes a <xref:System.Threading.Tasks.TaskCompletionSource%601.Task%2A> property that returns an associated <xref:System.Threading.Tasks.Task%601> instance.</span></span> <span data-ttu-id="c27d6-166">Bu görevin yaşam döngüsü,,, <xref:System.Threading.Tasks.TaskCompletionSource%601> <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A> <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A> <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A> ve çeşitleri gibi yöntemlerle denetlenir `TrySet` .</span><span class="sxs-lookup"><span data-stu-id="c27d6-166">The life cycle of this task is controlled by <xref:System.Threading.Tasks.TaskCompletionSource%601> methods such as <xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetException%2A>, <xref:System.Threading.Tasks.TaskCompletionSource%601.SetCanceled%2A>, and their `TrySet` variants.</span></span>

<span data-ttu-id="c27d6-167">Belirli bir süre sonra tamamlanacak bir görev oluşturmak istediğinizi varsayalım.</span><span class="sxs-lookup"><span data-stu-id="c27d6-167">Let's say that you want to create a task that will complete after a specified period of time.</span></span> <span data-ttu-id="c27d6-168">Örneğin, Kullanıcı arabirimindeki bir etkinliği geciktirmek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-168">For example, you may want to delay an activity in the user interface.</span></span> <span data-ttu-id="c27d6-169"><xref:System.Threading.Timer?displayProperty=nameWithType>Sınıfı zaten belirli bir süre geçtikten sonra bir temsilciyi zaman uyumsuz olarak çağırma özelliği sağlar ve <xref:System.Threading.Tasks.TaskCompletionSource%601> bunu kullanarak <xref:System.Threading.Tasks.Task%601> süreölçer üzerine bir ön nokta koyabilirsiniz, örneğin:</span><span class="sxs-lookup"><span data-stu-id="c27d6-169">The <xref:System.Threading.Timer?displayProperty=nameWithType> class already provides the ability to asynchronously invoke a delegate after a specified period of time, and by using <xref:System.Threading.Tasks.TaskCompletionSource%601> you can put a <xref:System.Threading.Tasks.Task%601> front on the timer, for example:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#4)]
[!code-vb[Conceptual.TAP_Patterns#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#4)]

<span data-ttu-id="c27d6-170">.NET Framework 4,5 ile başlayarak, <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> yöntemi bu amaçla sağlanır ve örneğin zaman uyumsuz bir yoklama döngüsü uygulamak için başka bir zaman uyumsuz yöntemin içinde kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="c27d6-170">Starting with the .NET Framework 4.5, the <xref:System.Threading.Tasks.Task.Delay%2A?displayProperty=nameWithType> method is provided for this purpose, and you can use it inside another asynchronous method, for example, to implement an asynchronous polling loop:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#5)]
[!code-vb[Conceptual.TAP_Patterns#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#5)]

<span data-ttu-id="c27d6-171"><xref:System.Threading.Tasks.TaskCompletionSource%601>Sınıfta genel olmayan bir karşılık yok.</span><span class="sxs-lookup"><span data-stu-id="c27d6-171">The <xref:System.Threading.Tasks.TaskCompletionSource%601> class doesn't have a non-generic counterpart.</span></span> <span data-ttu-id="c27d6-172">Ancak, <xref:System.Threading.Tasks.Task%601> öğesinden türetilir <xref:System.Threading.Tasks.Task> , bu nedenle, <xref:System.Threading.Tasks.TaskCompletionSource%601> yalnızca bir görevi döndüren g/ç 'ye bağlanan yöntemler için genel nesneyi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-172">However, <xref:System.Threading.Tasks.Task%601> derives from <xref:System.Threading.Tasks.Task>, so you can use the generic <xref:System.Threading.Tasks.TaskCompletionSource%601> object for I/O-bound methods that simply return a task.</span></span> <span data-ttu-id="c27d6-173">Bunu yapmak için, bir kaynağı kukla ile kullanabilirsiniz `TResult` ( <xref:System.Boolean> iyi bir varsayılan seçenektir, ancak bunu bir alta doğru atama Kullanıcı hakkında endişeleriniz varsa <xref:System.Threading.Tasks.Task> <xref:System.Threading.Tasks.Task%601> , `TResult` bunun yerine özel bir tür kullanabilirsiniz).</span><span class="sxs-lookup"><span data-stu-id="c27d6-173">To do this, you can use a source with a dummy `TResult` (<xref:System.Boolean> is a good default choice, but if you're concerned about the user of the <xref:System.Threading.Tasks.Task> downcasting it to a <xref:System.Threading.Tasks.Task%601>, you can use a private `TResult` type instead).</span></span> <span data-ttu-id="c27d6-174">Örneğin, `Delay` önceki örnekteki yöntemi, elde edilen fark () ile birlikte geçerli saati döndürür `Task<DateTimeOffset>` .</span><span class="sxs-lookup"><span data-stu-id="c27d6-174">For example, the `Delay` method in the previous example returns the current time along with the resulting offset (`Task<DateTimeOffset>`).</span></span> <span data-ttu-id="c27d6-175">Böyle bir sonuç değeri gereksiz ise, yöntemi aşağıdaki şekilde kodlanmış olabilir (dönüş türünün değişikliğini ve bağımsız değişkenin değişikliğini <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A> ):</span><span class="sxs-lookup"><span data-stu-id="c27d6-175">If such a result value is unnecessary, the method could instead be coded as follows (note the change of return type and the change of argument to <xref:System.Threading.Tasks.TaskCompletionSource%601.TrySetResult%2A>):</span></span>

[!code-csharp[Conceptual.TAP_Patterns#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#6)]
[!code-vb[Conceptual.TAP_Patterns#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#6)]

### <a name="mixed-compute-bound-and-io-bound-tasks"></a><span data-ttu-id="c27d6-176">Karma işlem ile bağlantılı ve g/ç 'ye sınırlı görevler</span><span class="sxs-lookup"><span data-stu-id="c27d6-176">Mixed compute-bound and I/O-bound tasks</span></span>
<span data-ttu-id="c27d6-177">Zaman uyumsuz yöntemler yalnızca işlem ile bağlantılı veya g/ç bağlantılı işlemlerle sınırlı değildir ancak ikisinin bir karışımını temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-177">Asynchronous methods are not limited to just compute-bound or I/O-bound operations but may represent a mixture of the two.</span></span> <span data-ttu-id="c27d6-178">Aslında, birden çok zaman uyumsuz işlem genellikle daha büyük karışık işlemler halinde birleştirilir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-178">In fact, multiple asynchronous operations are often combined into larger mixed operations.</span></span> <span data-ttu-id="c27d6-179">Örneğin, önceki bir örnekte gösterilen `RenderAsync` yöntemi, bazı giriş `imageData` verilerine göre bir resmi işlemek için yoğun bir hesaplama işlem gerçekleştirdi.</span><span class="sxs-lookup"><span data-stu-id="c27d6-179">For example, the `RenderAsync` method in a previous example performed a computationally intensive operation to render an image based on some input `imageData`.</span></span> <span data-ttu-id="c27d6-180">Bu `imageData` , zaman uyumsuz olarak erişebileceğiniz bir Web hizmetinden gelebilir:</span><span class="sxs-lookup"><span data-stu-id="c27d6-180">This `imageData` could come from a web service that you asynchronously access:</span></span>

[!code-csharp[Conceptual.TAP_Patterns#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap_patterns/cs/patterns1.cs#7)]
[!code-vb[Conceptual.TAP_Patterns#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap_patterns/vb/patterns1.vb#7)]

<span data-ttu-id="c27d6-181">Bu örnek ayrıca, çoklu zaman uyumsuz işlemler aracılığıyla tek bir iptal belirtecinin nasıl iş parçacıklı olabileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="c27d6-181">This example also demonstrates how a single cancellation token may be threaded through multiple asynchronous operations.</span></span> <span data-ttu-id="c27d6-182">Daha fazla bilgi için, [görev tabanlı zaman uyumsuz model](consuming-the-task-based-asynchronous-pattern.md)kullanma konusunun iptal kullanımı bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="c27d6-182">For more information, see the cancellation usage section in [Consuming the Task-based Asynchronous Pattern](consuming-the-task-based-asynchronous-pattern.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="c27d6-183">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="c27d6-183">See also</span></span>

- [<span data-ttu-id="c27d6-184">Görev Tabanlı Zaman Uyumsuz Desen (TAP)</span><span class="sxs-lookup"><span data-stu-id="c27d6-184">Task-based Asynchronous Pattern (TAP)</span></span>](task-based-asynchronous-pattern-tap.md)
- [<span data-ttu-id="c27d6-185">Görev Tabanlı Zaman Uyumsuz Desen Kullanma</span><span class="sxs-lookup"><span data-stu-id="c27d6-185">Consuming the Task-based Asynchronous Pattern</span></span>](consuming-the-task-based-asynchronous-pattern.md)
- [<span data-ttu-id="c27d6-186">Diğer Zaman Uyumsuz Desen ve Türlerle Birlikte Çalışma</span><span class="sxs-lookup"><span data-stu-id="c27d6-186">Interop with Other Asynchronous Patterns and Types</span></span>](interop-with-other-asynchronous-patterns-and-types.md)
