---
title: Kod Sözleşmeleri
description: .NET kodunuzda önkoşulları, Postconditions ve nesne ıntürevlerini belirtmenin bir yolunu sağlayan kod sözleşmelerini keşfet.
ms.date: 09/05/2018
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Code contracts
ms.assetid: 84526045-496f-489d-8517-a258cf76f040
ms.openlocfilehash: 60f794373af75bd3f745c224e0a8c7a84192e4c4
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904149"
---
# <a name="code-contracts"></a><span data-ttu-id="99a38-103">Kod Sözleşmeleri</span><span class="sxs-lookup"><span data-stu-id="99a38-103">Code Contracts</span></span>

<span data-ttu-id="99a38-104">Kod sözleşmeleri, kodunuzda önkoşulları, Postconditions ve nesne ınvaryantları belirtmek için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="99a38-104">Code contracts provide a way to specify preconditions, postconditions, and object invariants in your code.</span></span> <span data-ttu-id="99a38-105">Önkoşullar, bir yöntem veya özellik girilirken karşılanması gereken gereksinimlerdir.</span><span class="sxs-lookup"><span data-stu-id="99a38-105">Preconditions are requirements that must be met when entering a method or property.</span></span> <span data-ttu-id="99a38-106">Postconditions, yöntem veya özellik kodunun çıkış sırasında beklentileri anlatmaktadır.</span><span class="sxs-lookup"><span data-stu-id="99a38-106">Postconditions describe expectations at the time the method or property code exits.</span></span> <span data-ttu-id="99a38-107">Nesne ınvaryantları, iyi durumda olan bir sınıf için beklenen durumu tanımlıyor.</span><span class="sxs-lookup"><span data-stu-id="99a38-107">Object invariants describe the expected state for a class that is in a good state.</span></span>

<span data-ttu-id="99a38-108">Kod sözleşmeleri, kodunuzu işaretlemek için sınıflar, derleme zamanı analizi için bir statik çözümleyici ve bir çalışma zamanı Çözümleyicisi içerir.</span><span class="sxs-lookup"><span data-stu-id="99a38-108">Code contracts include classes for marking your code, a static analyzer for compile-time analysis, and a runtime analyzer.</span></span> <span data-ttu-id="99a38-109">Kod sözleşmeleri sınıfları <xref:System.Diagnostics.Contracts> ad alanında bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="99a38-109">The classes for code contracts can be found in the <xref:System.Diagnostics.Contracts> namespace.</span></span>

<span data-ttu-id="99a38-110">Kod sözleşmelerinin avantajları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="99a38-110">The benefits of code contracts include the following:</span></span>

- <span data-ttu-id="99a38-111">İyileştirilmiş test: kod sözleşmeleri statik sözleşme doğrulaması, çalışma zamanı denetimi ve belge oluşturma sağlar.</span><span class="sxs-lookup"><span data-stu-id="99a38-111">Improved testing: Code contracts provide static contract verification, runtime checking, and documentation generation.</span></span>

- <span data-ttu-id="99a38-112">Otomatik test araçları: önkoşulları karşılamayan anlamlı test bağımsız değişkenlerini filtreleyerek daha anlamlı birim testleri oluşturmak için kod sözleşmelerini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99a38-112">Automatic testing tools: You can use code contracts to generate more meaningful unit tests by filtering out meaningless test arguments that do not satisfy preconditions.</span></span>

- <span data-ttu-id="99a38-113">Statik doğrulama: statik denetleyici, programı çalıştırmadan herhangi bir sözleşme ihlali olup olmadığına karar verebilir.</span><span class="sxs-lookup"><span data-stu-id="99a38-113">Static verification: The static checker can decide whether there are any contract violations without running the program.</span></span> <span data-ttu-id="99a38-114">Null başvuru ve dizi sınırları ve açık sözleşmeler gibi örtük sözleşmeleri denetler.</span><span class="sxs-lookup"><span data-stu-id="99a38-114">It checks for implicit contracts, such as null dereferences and array bounds, and explicit contracts.</span></span>

- <span data-ttu-id="99a38-115">Başvuru belgeleri: belge Oluşturucu, mevcut XML belge dosyalarını sözleşme bilgileriyle genişlettiğini.</span><span class="sxs-lookup"><span data-stu-id="99a38-115">Reference documentation: The documentation generator augments existing XML documentation files with contract information.</span></span> <span data-ttu-id="99a38-116">Ayrıca, üretilen belge sayfalarında sözleşme bölümleri olması için [sanderle](https://github.com/EWSoftware/SHFB) ile kullanılabilen stil sayfaları vardır.</span><span class="sxs-lookup"><span data-stu-id="99a38-116">There are also style sheets that can be used with [Sandcastle](https://github.com/EWSoftware/SHFB) so that the generated documentation pages have contract sections.</span></span>

<span data-ttu-id="99a38-117">Tüm .NET Framework diller, sözleşmelerin avantajlarından hemen faydalanabilir; özel bir Ayrıştırıcı veya derleyici yazmak zorunda değilsiniz.</span><span class="sxs-lookup"><span data-stu-id="99a38-117">All .NET Framework languages can immediately take advantage of contracts; you do not have to write a special parser or compiler.</span></span> <span data-ttu-id="99a38-118">Visual Studio eklentisi, gerçekleştirilecek kod sözleşmesi analizinin düzeyini belirtmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="99a38-118">A Visual Studio add-in lets you specify the level of code contract analysis to be performed.</span></span> <span data-ttu-id="99a38-119">Çözümleyiciler, sözleşmelerin doğru biçimlendirildiğini (tür denetimi ve ad çözümlemesi) ve Microsoft ara dili (MSIL) biçiminde sözleşmelerin derlenmiş bir formunu oluşturabildiğini doğrulayabilirler.</span><span class="sxs-lookup"><span data-stu-id="99a38-119">The analyzers can confirm that the contracts are well-formed (type checking and name resolution) and can produce a compiled form of the contracts in Microsoft intermediate language (MSIL) format.</span></span> <span data-ttu-id="99a38-120">Visual Studio 'da sözleşme yazma, araç tarafından sunulan standart IntelliSense 'den yararlanmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="99a38-120">Authoring contracts in Visual Studio lets you take advantage of the standard IntelliSense provided by the tool.</span></span>

<span data-ttu-id="99a38-121">Anlaşma sınıfındaki yöntemlerin çoğu koşullu olarak derlenir; diğer bir deyişle, derleyici bu yöntemlere yalnızca özel bir sembol tanımladığınızda, CONTRACTS_FULL, yönergesini kullanarak çağrı yayar `#define` .</span><span class="sxs-lookup"><span data-stu-id="99a38-121">Most methods in the contract class are conditionally compiled; that is, the compiler emits calls to these methods only when  you define a special symbol, CONTRACTS_FULL, by using the `#define` directive.</span></span> <span data-ttu-id="99a38-122">CONTRACTS_FULL, yönergeleri kullanmadan kodunuzda sözleşmeleri yazmanızı sağlar `#ifdef` ; farklı yapılar, bazı sözleşmelerle ve bazıları olmadan oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99a38-122">CONTRACTS_FULL lets you write contracts in your code without using `#ifdef` directives; you can produce different builds, some with contracts, and some without.</span></span>

<span data-ttu-id="99a38-123">Kod sözleşmelerini kullanmaya yönelik araçlar ve ayrıntılı yönergeler için bkz. Visual Studio marketi sitesindeki [Kod sözleşmeleri](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) .</span><span class="sxs-lookup"><span data-stu-id="99a38-123">For tools and detailed instructions for using code contracts, see [Code Contracts](https://marketplace.visualstudio.com/items?itemName=RiSEResearchinSoftwareEngineering.CodeContractsforNET) on the Visual Studio marketplace site.</span></span>

## <a name="preconditions"></a><span data-ttu-id="99a38-124">Üstbilgisinde</span><span class="sxs-lookup"><span data-stu-id="99a38-124">Preconditions</span></span>

<span data-ttu-id="99a38-125">Yöntemini kullanarak önkoşulları ifade edebilirsiniz <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="99a38-125">You can express preconditions by using the <xref:System.Diagnostics.Contracts.Contract.Requires%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="99a38-126">Ön koşullar bir yöntem çağrıldığında durumu belirtir.</span><span class="sxs-lookup"><span data-stu-id="99a38-126">Preconditions specify state when a method is invoked.</span></span> <span data-ttu-id="99a38-127">Bunlar genellikle geçerli parametre değerlerini belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="99a38-127">They are generally used to specify valid parameter values.</span></span> <span data-ttu-id="99a38-128">Ön koşullarda bahsedilen tüm Üyeler en azından yöntemin kendisi olarak erişilebilir olmalıdır; Aksi takdirde, önkoşul bir yöntemin tüm çağıranları tarafından anlaşılmayabilir.</span><span class="sxs-lookup"><span data-stu-id="99a38-128">All members that are mentioned in preconditions must be at least as accessible as the method itself; otherwise, the precondition might not be understood by all callers of a method.</span></span> <span data-ttu-id="99a38-129">Koşulun yan etkileri olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="99a38-129">The condition must have no side-effects.</span></span> <span data-ttu-id="99a38-130">Başarısız önkoşulların çalışma zamanı davranışı, çalışma zamanı Çözümleyicisi tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="99a38-130">The run-time behavior of failed preconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="99a38-131">Örneğin, aşağıdaki önkoşul parametrenin `x` null olmayan bir değer olması gerektiğini ifade eder.</span><span class="sxs-lookup"><span data-stu-id="99a38-131">For example, the following precondition expresses that parameter `x` must be non-null.</span></span>

```csharp
Contract.Requires(x != null);
```

<span data-ttu-id="99a38-132">Kodunuzun bir önkoşulun hata durumunda belirli bir özel durum oluşturması gerekiyorsa, genel aşırı yüklemesini <xref:System.Diagnostics.Contracts.Contract.Requires%2A> aşağıdaki gibi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99a38-132">If your code must throw a particular exception on failure of a precondition, you can use the generic overload of <xref:System.Diagnostics.Contracts.Contract.Requires%2A> as follows.</span></span>

```csharp
Contract.Requires<ArgumentNullException>(x != null, "x");
```

### <a name="legacy-requires-statements"></a><span data-ttu-id="99a38-133">Eski deyimleri gerektiriyor</span><span class="sxs-lookup"><span data-stu-id="99a38-133">Legacy Requires Statements</span></span>

<span data-ttu-id="99a38-134">Çoğu kod, kod biçiminde bazı parametre doğrulamasını içerir `if` - `then` - `throw` .</span><span class="sxs-lookup"><span data-stu-id="99a38-134">Most code contains some parameter validation in the form of `if`-`then`-`throw` code.</span></span> <span data-ttu-id="99a38-135">Sözleşme araçları, aşağıdaki durumlarda bu deyimleri ön koşullar olarak tanır:</span><span class="sxs-lookup"><span data-stu-id="99a38-135">The contract tools recognize these statements as preconditions in the following cases:</span></span>

- <span data-ttu-id="99a38-136">Deyimler bir yöntemde diğer deyimlerden önce görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="99a38-136">The statements appear before any other statements in a method.</span></span>

- <span data-ttu-id="99a38-137">Bu tür deyimler kümesinin tamamı,,, <xref:System.Diagnostics.Contracts.Contract> <xref:System.Diagnostics.Contracts.Contract.Requires%2A> <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A> veya yöntemine yapılan çağrı gibi açık bir yöntem çağrısıyla izlenir <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> .</span><span class="sxs-lookup"><span data-stu-id="99a38-137">The entire set of such statements is followed by an explicit <xref:System.Diagnostics.Contracts.Contract> method call, such as a call to the <xref:System.Diagnostics.Contracts.Contract.Requires%2A>, <xref:System.Diagnostics.Contracts.Contract.Ensures%2A>, <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>, or <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> method.</span></span>

<span data-ttu-id="99a38-138">`if` - `then` - `throw` Bu formda deyimler görüntülendiğinde, Araçlar bunları eski deyimler olarak tanır `requires` .</span><span class="sxs-lookup"><span data-stu-id="99a38-138">When `if`-`then`-`throw` statements appear in this form, the tools recognize them as legacy `requires` statements.</span></span> <span data-ttu-id="99a38-139">Sırayı takip eden başka sözleşmeler yoksa `if` - `then` - `throw` , kodu <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> yöntemiyle sonlandırın.</span><span class="sxs-lookup"><span data-stu-id="99a38-139">If no other contracts follow the `if`-`then`-`throw` sequence, end the code with the <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A?displayProperty=nameWithType> method.</span></span>

```csharp
if (x == null) throw new ...
Contract.EndContractBlock(); // All previous "if" checks are preconditions
```

<span data-ttu-id="99a38-140">Önceki testteki koşulun bir geçişli önkoşul olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="99a38-140">Note that the condition in the preceding test is a negated precondition.</span></span> <span data-ttu-id="99a38-141">(Gerçek önkoşul olacaktır `x != null` .) Bir geçişli önkoşul yüksek oranda kısıtlıdır: önceki örnekte gösterildiği gibi yazılmalıdır. Yani, hiçbir yan tümce içermemelidir `else` ve `then` yan tümcesinin gövdesi tek bir `throw` ifade olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="99a38-141">(The actual precondition would be `x != null`.) A negated precondition is highly restricted: It must be written as shown in the previous example; that is, it should contain no `else` clauses, and the body of the `then` clause must be a single `throw` statement.</span></span> <span data-ttu-id="99a38-142">`if`Test, hem önemli hem de görünürlük kurallarına tabidir (bkz. [Kullanım yönergeleri](#usage_guidelines)), ancak `throw` ifade yalnızca önemli kurallara tabidir.</span><span class="sxs-lookup"><span data-stu-id="99a38-142">The `if` test is subject to both purity and visibility rules (see [Usage Guidelines](#usage_guidelines)), but the `throw` expression is subject only to purity rules.</span></span> <span data-ttu-id="99a38-143">Ancak, oluşturulan özel durumun türü, sözleşmenin gerçekleştiği Yöntem olarak görünür olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="99a38-143">However, the type of the exception thrown must be as visible as the method in which the contract occurs.</span></span>

## <a name="postconditions"></a><span data-ttu-id="99a38-144">Sonkoşulları</span><span class="sxs-lookup"><span data-stu-id="99a38-144">Postconditions</span></span>

<span data-ttu-id="99a38-145">Postconditions, bir yöntemin sonlandırıldığında bir yöntemin durumu için sözleşmelerdir.</span><span class="sxs-lookup"><span data-stu-id="99a38-145">Postconditions are contracts for the state of a method when it terminates.</span></span> <span data-ttu-id="99a38-146">Sonkoşul, bir yöntemden çıkmadan hemen önce denetlenir.</span><span class="sxs-lookup"><span data-stu-id="99a38-146">The postcondition is checked just before exiting a method.</span></span> <span data-ttu-id="99a38-147">Başarısız Sonkoşulları çalışma zamanı davranışı, çalışma zamanı Çözümleyicisi tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="99a38-147">The run-time behavior of failed postconditions is determined by the runtime analyzer.</span></span>

<span data-ttu-id="99a38-148">Önkoşullardan farklı olarak, Sonkoşulları daha az görünürlük içeren üyelere başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="99a38-148">Unlike preconditions, postconditions may reference members with less visibility.</span></span> <span data-ttu-id="99a38-149">İstemci özel durum kullanan bir Sonkoşul tarafından ifade edilen bilgilerden bazılarını anlayamayabilir veya kullanamaz, ancak bu, istemcinin yöntemi doğru bir şekilde kullanma yeteneğini etkilemez.</span><span class="sxs-lookup"><span data-stu-id="99a38-149">A client may not be able to understand or make use of some of the information expressed by a postcondition using private state, but this does not affect the client's ability to use the method correctly.</span></span>

### <a name="standard-postconditions"></a><span data-ttu-id="99a38-150">Standart Postconditions</span><span class="sxs-lookup"><span data-stu-id="99a38-150">Standard Postconditions</span></span>

<span data-ttu-id="99a38-151">Yöntemini kullanarak standart Sonkoşulları getirebilirsiniz <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> .</span><span class="sxs-lookup"><span data-stu-id="99a38-151">You can express standard postconditions by using the <xref:System.Diagnostics.Contracts.Contract.Ensures%2A> method.</span></span> <span data-ttu-id="99a38-152">Postconditions `true` , yöntemin normal sonlandırmasından sonra olması gereken bir koşul ifade etmelidir.</span><span class="sxs-lookup"><span data-stu-id="99a38-152">Postconditions express a condition that must be `true` upon normal termination of the method.</span></span>

```csharp
Contract.Ensures(this.F > 0);
```

### <a name="exceptional-postconditions"></a><span data-ttu-id="99a38-153">Olağanüstü Postconditions</span><span class="sxs-lookup"><span data-stu-id="99a38-153">Exceptional Postconditions</span></span>

<span data-ttu-id="99a38-154">Olağanüstü Sonkoşullar, `true` bir yöntem tarafından belirli bir özel durum oluşturulduğunda olması gereken Sonkoşullar olur.</span><span class="sxs-lookup"><span data-stu-id="99a38-154">Exceptional postconditions are postconditions that should be `true` when a particular exception is thrown by a method.</span></span> <span data-ttu-id="99a38-155"><xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType>Aşağıdaki örnekte gösterildiği gibi, yöntemini kullanarak bu Sonkoşulları belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99a38-155">You can specify these postconditions by using the <xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A?displayProperty=nameWithType> method, as the following example shows.</span></span>

```csharp
Contract.EnsuresOnThrow<T>(this.F > 0);
```

<span data-ttu-id="99a38-156">Bağımsız değişkeni, `true` öğesinin bir alt türü olan her bir özel durum oluştuğunda olması gereken durumdur `T` .</span><span class="sxs-lookup"><span data-stu-id="99a38-156">The argument is the condition that must be `true` whenever an exception that is a subtype of `T` is thrown.</span></span>

<span data-ttu-id="99a38-157">Olağanüstü bir Sonkoşul içinde kullanılması zor olan bazı özel durum türleri vardır.</span><span class="sxs-lookup"><span data-stu-id="99a38-157">There are some exception types that are difficult to use in an exceptional postcondition.</span></span> <span data-ttu-id="99a38-158">Örneğin, için türünün kullanılması, <xref:System.Exception> `T` bir yığın taşması veya diğer imkansız-denetim özel durumu olsa bile, oluşturulan özel durum türünden bağımsız olarak koşulu güvence altına almak için yöntemini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="99a38-158">For example, using the type <xref:System.Exception> for `T` requires the method to guarantee the condition regardless of the type of exception that is thrown, even if it is a stack overflow or other impossible-to-control exception.</span></span> <span data-ttu-id="99a38-159">Yalnızca bir üye çağrıldığında, örneğin, bir <xref:System.InvalidTimeZoneException> Yöntem çağrısı için oluşturulduğunda, özel durumlar için, yalnızca bir üye çağrıldığında oluşturulan özel durumlar için olağanüstü Sonkoşulları kullanmanız gerekir <xref:System.TimeZoneInfo> .</span><span class="sxs-lookup"><span data-stu-id="99a38-159">You should use exceptional postconditions only for specific exceptions that might be thrown when a member is called, for example, when an <xref:System.InvalidTimeZoneException> is thrown for a <xref:System.TimeZoneInfo> method call.</span></span>

### <a name="special-postconditions"></a><span data-ttu-id="99a38-160">Özel Postconditions</span><span class="sxs-lookup"><span data-stu-id="99a38-160">Special Postconditions</span></span>

<span data-ttu-id="99a38-161">Aşağıdaki yöntemler yalnızca Postconditions içinde kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="99a38-161">The following methods may be used only within postconditions:</span></span>

- <span data-ttu-id="99a38-162">Yöntemini kullanarak Sonkoşulları içindeki değer dönüş değerlerini ifade eder; `Contract.Result<T>()` burada, `T` yönteminin dönüş türü ile değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="99a38-162">You can refer to method return values in postconditions by using the expression `Contract.Result<T>()`, where `T` is replaced by the return type of the method.</span></span> <span data-ttu-id="99a38-163">Derleyici türü çıkarsanamıyor, açıkça sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="99a38-163">When the compiler is unable to infer the type, you must explicitly provide it.</span></span> <span data-ttu-id="99a38-164">Örneğin, C# derleyicisi herhangi bir bağımsız değişken kullanmayan yöntemler için türleri çıkarmıyor, bu nedenle aşağıdaki Sonkoşul gerektirir: `Contract.Ensures(0 <Contract.Result<int>())` dönüş türü olan Yöntemler, `void` `Contract.Result<T>()` kendi iade koşullarına başvuramaz.</span><span class="sxs-lookup"><span data-stu-id="99a38-164">For example, the C# compiler is unable to infer types for methods that do not take any arguments, so it requires the following postcondition: `Contract.Ensures(0 <Contract.Result<int>())` Methods with a return type of `void` cannot refer to `Contract.Result<T>()` in their postconditions.</span></span>

- <span data-ttu-id="99a38-165">Sonkoşul içindeki bir prestate değeri, bir yöntemin veya özelliğin başlangıcında bir ifadenin değerine başvurur.</span><span class="sxs-lookup"><span data-stu-id="99a38-165">A prestate value in a postcondition refers to the value of an expression at the start of a method or property.</span></span> <span data-ttu-id="99a38-166">Bu, türü olan ifadesini kullanır `Contract.OldValue<T>(e)` `T` `e` .</span><span class="sxs-lookup"><span data-stu-id="99a38-166">It uses the expression `Contract.OldValue<T>(e)`, where `T` is the type of `e`.</span></span> <span data-ttu-id="99a38-167">Derleyici türünü çıkarsdığı zaman genel tür bağımsız değişkenini atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99a38-167">You can omit the generic type argument whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="99a38-168">(Örneğin, C# derleyicisi her zaman bir bağımsız değişken aldığı için türü kullanır.) ' De neler olabileceği `e` ve eski bir ifadenin görünebileceği bağlamlarda çeşitli kısıtlamalar vardır.</span><span class="sxs-lookup"><span data-stu-id="99a38-168">(For example, the C# compiler always infers the type because it takes an argument.) There are several restrictions on what can occur in `e` and the contexts in which an old expression may appear.</span></span> <span data-ttu-id="99a38-169">Eski bir ifade başka bir eski ifade içeremez.</span><span class="sxs-lookup"><span data-stu-id="99a38-169">An old expression cannot contain another old expression.</span></span> <span data-ttu-id="99a38-170">En önemlisi, eski bir ifade yöntemin önkoşul durumunda varolan bir değere başvurmalıdır.</span><span class="sxs-lookup"><span data-stu-id="99a38-170">Most importantly, an old expression must refer to a value that existed in the method's precondition state.</span></span> <span data-ttu-id="99a38-171">Diğer bir deyişle, yöntemin önkoşulunu olduğu sürece değerlendirilebilecek bir ifade olmalıdır `true` .</span><span class="sxs-lookup"><span data-stu-id="99a38-171">In other words, it must be an expression that can be evaluated as long as the method's precondition is `true`.</span></span> <span data-ttu-id="99a38-172">Bu kuralın birkaç örneği aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="99a38-172">Here are several instances of that rule.</span></span>

  - <span data-ttu-id="99a38-173">Değer, yöntemin önkoşul durumunda bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="99a38-173">The value must exist in the method's precondition state.</span></span> <span data-ttu-id="99a38-174">Bir nesne üzerindeki bir alana başvurmak için, önkoşulların nesnenin her zaman null olmadığından emin olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="99a38-174">In order to reference a field on an object, the preconditions must guarantee that the object is always non-null.</span></span>

  - <span data-ttu-id="99a38-175">Eski bir ifadede yöntemin dönüş değerine başvuramaz:</span><span class="sxs-lookup"><span data-stu-id="99a38-175">You cannot refer to the method's return value in an old expression:</span></span>

      ```csharp
      Contract.OldValue(Contract.Result<int>() + x) // ERROR
      ```

  - <span data-ttu-id="99a38-176">`out`Eski bir ifadede parametrelere başvurulamaz.</span><span class="sxs-lookup"><span data-stu-id="99a38-176">You cannot refer to `out` parameters in an old expression.</span></span>

  - <span data-ttu-id="99a38-177">Belirleyici aralığı, yöntemin dönüş değerine bağımlıysa, eski bir ifade bir nicelik sayısının bağlı değişkenine bağlı olamaz:</span><span class="sxs-lookup"><span data-stu-id="99a38-177">An old expression cannot depend on the bound variable of a quantifier if the range of the quantifier depends on the return value of the method:</span></span>

      ```csharp
      Contract.ForAll(0, Contract.Result<int>(), i => Contract.OldValue(xs[i]) > 3); // ERROR
      ```

  - <span data-ttu-id="99a38-178">Bir <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> <xref:System.Diagnostics.Contracts.Contract.Exists%2A> Yöntem çağrısında bir Dizin Oluşturucu veya bağımsız değişken olarak kullanılmadığı sürece, eski bir ifade bir veya çağrısındaki anonim temsilcinin parametresine başvuramaz:</span><span class="sxs-lookup"><span data-stu-id="99a38-178">An old expression cannot refer to the parameter of the anonymous delegate in a <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> call unless it is used as an indexer or argument to a method call:</span></span>

      ```csharp
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(xs[i]) > 3); // OK
      Contract.ForAll(0, xs.Length, i => Contract.OldValue(i) > 3); // ERROR
      ```

  - <span data-ttu-id="99a38-179">Eski ifadenin değeri, veya yöntemine ait bir bağımsız değişken olmadığı müddetçe, anonim temsilcinin gövdesinde anonim temsilcinin herhangi birine bağımlıysa, eski bir ifade bulunamaz <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> <xref:System.Diagnostics.Contracts.Contract.Exists%2A> :</span><span class="sxs-lookup"><span data-stu-id="99a38-179">An old expression cannot occur in the body of an anonymous delegate if the value of the old expression depends on any of the parameters of the anonymous delegate, unless the anonymous delegate is an argument to the <xref:System.Diagnostics.Contracts.Contract.ForAll%2A> or <xref:System.Diagnostics.Contracts.Contract.Exists%2A> method:</span></span>

      ```csharp
      Method(... (T t) => Contract.OldValue(... t ...) ...); // ERROR
      ```

  - <span data-ttu-id="99a38-180">`Out`sözleşmeler metodun gövdesinden önce göründüğünden ve çoğu derleyiciler, Postconditions içindeki parametrelere başvuruya izin vermediğinden, bir sorun oluşur `out` .</span><span class="sxs-lookup"><span data-stu-id="99a38-180">`Out` parameters present a problem because contracts appear before the body of the method, and most compilers do not allow references to `out` parameters in postconditions.</span></span> <span data-ttu-id="99a38-181">Bu sorunu çözmek için, <xref:System.Diagnostics.Contracts.Contract> sınıfı bir <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> parametreye dayalı bir Sonkoşul sağlayan yöntemini sağlar `out` .</span><span class="sxs-lookup"><span data-stu-id="99a38-181">To solve this problem, the <xref:System.Diagnostics.Contracts.Contract> class provides the <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method, which allows a postcondition based on an `out` parameter.</span></span>

      ```csharp
      public void OutParam(out int x)
      {
          Contract.Ensures(Contract.ValueAtReturn(out x) == 3);
          x = 3;
      }
      ```

      <span data-ttu-id="99a38-182">Yönteminde olduğu gibi <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> , derleyici türünü çıkarsdığı zaman genel tür parametresini atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99a38-182">As with the <xref:System.Diagnostics.Contracts.Contract.OldValue%2A> method, you can omit the generic type parameter whenever the compiler is able to infer its type.</span></span> <span data-ttu-id="99a38-183">Sözleşme yeniden yazıcı, yöntem çağrısını parametrenin değeriyle değiştirir `out` .</span><span class="sxs-lookup"><span data-stu-id="99a38-183">The contract rewriter replaces the method call with the value of the `out` parameter.</span></span> <span data-ttu-id="99a38-184"><xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A>Yöntemi yalnızca Postconditions içinde görünebilir.</span><span class="sxs-lookup"><span data-stu-id="99a38-184">The <xref:System.Diagnostics.Contracts.Contract.ValueAtReturn%2A> method may appear only in postconditions.</span></span> <span data-ttu-id="99a38-185">Metodun bağımsız değişkeni bir `out` parametre veya bir yapı parametresinin alanı olmalıdır `out` .</span><span class="sxs-lookup"><span data-stu-id="99a38-185">The argument to the method must be an `out` parameter or a field of a structure `out` parameter.</span></span> <span data-ttu-id="99a38-186">İkincisi, bir yapı oluşturucusunun sonkoşulun içindeki alanlara başvururken da yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="99a38-186">The latter is also useful when referring to fields in the postcondition of a structure constructor.</span></span>

      > [!NOTE]
      > <span data-ttu-id="99a38-187">Şu anda, kod sözleşmesi analiz araçları `out` parametrelerin doğru başlatılıp başlatılmayacağını denetleyip sonkoşulun ne olduğunu göz ardı etmez.</span><span class="sxs-lookup"><span data-stu-id="99a38-187">Currently, the code contract analysis tools do not check whether `out` parameters are initialized properly and disregard their mention in the postcondition.</span></span> <span data-ttu-id="99a38-188">Bu nedenle, önceki örnekte, sözleşmenin sonraki satırı, `x` bir tamsayı atamak yerine değerini kullansaydı, bir derleyici doğru hatayı veremez.</span><span class="sxs-lookup"><span data-stu-id="99a38-188">Therefore, in the previous example, if the line after the contract had used the value of `x` instead of assigning an integer to it, a compiler would not issue the correct error.</span></span> <span data-ttu-id="99a38-189">Bununla birlikte, CONTRACTS_FULL Önişlemci simgesinin tanımlanmadığı bir derlemede (Bu tür asa yayın derlemesi), derleyici bir hata oluşturur.</span><span class="sxs-lookup"><span data-stu-id="99a38-189">However, on a build where the CONTRACTS_FULL preprocessor symbol is not defined (such asa release build), the compiler will issue an error.</span></span>

## <a name="invariants"></a><span data-ttu-id="99a38-190">Invaryantlar</span><span class="sxs-lookup"><span data-stu-id="99a38-190">Invariants</span></span>

<span data-ttu-id="99a38-191">Nesne ınvaryantları, her nesnenin bir istemciye her görünmesinin her bir sınıf örneği için doğru olması gereken koşullardır.</span><span class="sxs-lookup"><span data-stu-id="99a38-191">Object invariants are conditions that should be true for each instance of a class whenever that object is visible to a client.</span></span> <span data-ttu-id="99a38-192">Nesnenin doğru olduğu kabul edildiği koşulları ifade ederler.</span><span class="sxs-lookup"><span data-stu-id="99a38-192">They express the conditions under which the object is considered to be correct.</span></span>

<span data-ttu-id="99a38-193">Sabit Yöntemler, özniteliğiyle işaretlenerek tanımlanır <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> .</span><span class="sxs-lookup"><span data-stu-id="99a38-193">The invariant methods are identified by being marked with the <xref:System.Diagnostics.Contracts.ContractInvariantMethodAttribute> attribute.</span></span> <span data-ttu-id="99a38-194"><xref:System.Diagnostics.Contracts.Contract.Invariant%2A>Aşağıdaki örnekte gösterildiği gibi, sabit metotlar, her biri tek bir sabiti belirten yöntemine yapılan çağrı dizisi haricinde hiçbir kod içermemelidir.</span><span class="sxs-lookup"><span data-stu-id="99a38-194">The invariant methods must contain no code except for a sequence of calls to the <xref:System.Diagnostics.Contracts.Contract.Invariant%2A> method, each of which specifies an individual invariant, as shown in the following example.</span></span>

```csharp
[ContractInvariantMethod]
protected void ObjectInvariant ()
{
    Contract.Invariant(this.y >= 0);
    Contract.Invariant(this.x > this.y);
    ...
}
```

<span data-ttu-id="99a38-195">Invaryantlar CONTRACTS_FULL Önişlemci simgesiyle koşullu olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="99a38-195">Invariants are conditionally defined by the CONTRACTS_FULL preprocessor symbol.</span></span> <span data-ttu-id="99a38-196">Çalışma zamanı denetimi sırasında, ınvaryantlar her genel yöntemin sonunda denetlenir.</span><span class="sxs-lookup"><span data-stu-id="99a38-196">During run-time checking, invariants are checked at the end of each public method.</span></span> <span data-ttu-id="99a38-197">Bir sabit, aynı sınıftaki ortak bir yönteme bahsetiyorsa, normalde bu genel yöntemin sonunda gerçekleşen sabit denetim devre dışıdır.</span><span class="sxs-lookup"><span data-stu-id="99a38-197">If an invariant mentions a public method in the same class, the invariant check that would normally happen at the end of that public method is disabled.</span></span> <span data-ttu-id="99a38-198">Bunun yerine, denetim yalnızca o sınıfa en dıştaki yöntem çağrısının sonunda gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="99a38-198">Instead, the check occurs only at the end of the outermost method call to that class.</span></span> <span data-ttu-id="99a38-199">Bu aynı zamanda, başka bir sınıftaki bir yönteme çağrı nedeniyle sınıf yeniden girilirse de olur.</span><span class="sxs-lookup"><span data-stu-id="99a38-199">This also happens if the class is re-entered because of a call to a method on another class.</span></span> <span data-ttu-id="99a38-200">Invaryantlar, bir nesne Sonlandırıcı ve bir uygulama için denetlenmez <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="99a38-200">Invariants are not checked for an object finalizer and an <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>

<a name="usage_guidelines"></a>

## <a name="usage-guidelines"></a><span data-ttu-id="99a38-201">Kullanım Yönergeleri</span><span class="sxs-lookup"><span data-stu-id="99a38-201">Usage Guidelines</span></span>

### <a name="contract-ordering"></a><span data-ttu-id="99a38-202">Sözleşme sıralaması</span><span class="sxs-lookup"><span data-stu-id="99a38-202">Contract Ordering</span></span>

<span data-ttu-id="99a38-203">Aşağıdaki tabloda, yöntem sözleşmeleri yazarken kullanmanız gereken öğelerin sırası gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="99a38-203">The following table shows the order of elements you should use when you write method contracts.</span></span>

|`If-then-throw statements`|<span data-ttu-id="99a38-204">Geriye dönük olarak uyumlu genel Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="99a38-204">Backward-compatible public preconditions</span></span>|
|-|-|
|<xref:System.Diagnostics.Contracts.Contract.Requires%2A>|<span data-ttu-id="99a38-205">Tüm genel Önkoşullar.</span><span class="sxs-lookup"><span data-stu-id="99a38-205">All public preconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="99a38-206">Tüm genel (normal) Postconditions.</span><span class="sxs-lookup"><span data-stu-id="99a38-206">All public (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="99a38-207">Tüm genel sıradışı Postconditions.</span><span class="sxs-lookup"><span data-stu-id="99a38-207">All public exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.Ensures%2A>|<span data-ttu-id="99a38-208">Tüm özel/iç (normal) Postconditions.</span><span class="sxs-lookup"><span data-stu-id="99a38-208">All private/internal (normal) postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EnsuresOnThrow%2A>|<span data-ttu-id="99a38-209">Tüm özel/iç olağanüstü Postconditions.</span><span class="sxs-lookup"><span data-stu-id="99a38-209">All private/internal exceptional postconditions.</span></span>|
|<xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A>|<span data-ttu-id="99a38-210">`if` - `then` - `throw` Başka sözleşmeler olmadan stil önkoşulları kullanıyorsanız, <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> tüm önceki denetimlerin ön koşullar olduğunu göstermek için öğesine bir çağrısı koyun.</span><span class="sxs-lookup"><span data-stu-id="99a38-210">If using `if`-`then`-`throw` style preconditions without any other contracts, place a call to <xref:System.Diagnostics.Contracts.Contract.EndContractBlock%2A> to indicate that all previous if checks are preconditions.</span></span>|

<a name="purity"></a>

### <a name="purity"></a><span data-ttu-id="99a38-211">Takip</span><span class="sxs-lookup"><span data-stu-id="99a38-211">Purity</span></span>

<span data-ttu-id="99a38-212">Bir sözleşme içinde çağrılan tüm yöntemler saf olmalıdır; diğer bir deyişle, önceden var olan bir durumu güncelleştirmemelidir.</span><span class="sxs-lookup"><span data-stu-id="99a38-212">All methods that are called within a contract must be pure; that is, they must not update any preexisting state.</span></span> <span data-ttu-id="99a38-213">Saf yönteme giriş yapıldıktan sonra oluşturulan nesneleri değiştirmeye izin verilir.</span><span class="sxs-lookup"><span data-stu-id="99a38-213">A pure method is allowed to modify objects that have been created after entry into the pure method.</span></span>

<span data-ttu-id="99a38-214">Kod sözleşmesi araçları şu anda aşağıdaki kod öğelerinin saf olduğunu varsayar:</span><span class="sxs-lookup"><span data-stu-id="99a38-214">Code contract tools currently assume that the following code elements are pure:</span></span>

- <span data-ttu-id="99a38-215">İle işaretlenen Yöntemler <xref:System.Diagnostics.Contracts.PureAttribute> .</span><span class="sxs-lookup"><span data-stu-id="99a38-215">Methods that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span>

- <span data-ttu-id="99a38-216">İle işaretlenen türler <xref:System.Diagnostics.Contracts.PureAttribute> (özniteliği tüm tür yöntemlerine uygulanır).</span><span class="sxs-lookup"><span data-stu-id="99a38-216">Types that are marked with the <xref:System.Diagnostics.Contracts.PureAttribute> (the attribute applies to all the type's methods).</span></span>

- <span data-ttu-id="99a38-217">Özellik Al erişimcileri.</span><span class="sxs-lookup"><span data-stu-id="99a38-217">Property get accessors.</span></span>

- <span data-ttu-id="99a38-218">İşleçler (adları "op" ile başlayan ve bir veya iki parametresi ve void olmayan bir dönüş türü olan statik yöntemler).</span><span class="sxs-lookup"><span data-stu-id="99a38-218">Operators (static methods whose names start with "op", and that have one or two parameters and a non-void return type).</span></span>

- <span data-ttu-id="99a38-219">Tam adı "System. Diagnostics. sözleşmeleri. Sözleşmesi", "System. String", "System. ıO. Path" veya "System. Type" ile başlayan tüm yöntemler.</span><span class="sxs-lookup"><span data-stu-id="99a38-219">Any method whose fully qualified name begins with "System.Diagnostics.Contracts.Contract", "System.String", "System.IO.Path", or "System.Type".</span></span>

- <span data-ttu-id="99a38-220">Temsilci türünün kendisi ile ilişkilendirilebildiği tüm çağrılan temsilciler <xref:System.Diagnostics.Contracts.PureAttribute> .</span><span class="sxs-lookup"><span data-stu-id="99a38-220">Any invoked delegate, provided that the delegate type itself is attributed with the <xref:System.Diagnostics.Contracts.PureAttribute>.</span></span> <span data-ttu-id="99a38-221">Temsilci türleri <xref:System.Predicate%601?displayProperty=nameWithType> ve <xref:System.Comparison%601?displayProperty=nameWithType> saf olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="99a38-221">The delegate types <xref:System.Predicate%601?displayProperty=nameWithType> and <xref:System.Comparison%601?displayProperty=nameWithType> are considered pure.</span></span>

<a name="visibility"></a>

### <a name="visibility"></a><span data-ttu-id="99a38-222">Görünürlük</span><span class="sxs-lookup"><span data-stu-id="99a38-222">Visibility</span></span>

<span data-ttu-id="99a38-223">Bir sözleşmede bahsedilen tüm üyelerin en az göründükleri Yöntem olarak görünür olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="99a38-223">All members mentioned in a contract must be at least as visible as the method in which they appear.</span></span> <span data-ttu-id="99a38-224">Örneğin, bir özel alan, bir genel yöntemin önkoşulunu içinde belirtilemez; istemciler, yöntemi çağırmadan önce böyle bir sözleşmeyi doğrulayamaz.</span><span class="sxs-lookup"><span data-stu-id="99a38-224">For example, a private field cannot be mentioned in a precondition for a public method; clients cannot validate such a contract before they call the method.</span></span> <span data-ttu-id="99a38-225">Ancak, alanı ile işaretlenmişse, <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute> Bu kurallardan muaf tutulur.</span><span class="sxs-lookup"><span data-stu-id="99a38-225">However, if the field is marked with the <xref:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute>, it is exempt from these rules.</span></span>

## <a name="example"></a><span data-ttu-id="99a38-226">Örnek</span><span class="sxs-lookup"><span data-stu-id="99a38-226">Example</span></span>

<span data-ttu-id="99a38-227">Aşağıdaki örnek, kod sözleşmelerinin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="99a38-227">The following example shows the use of code contracts.</span></span>

[!code-csharp[ContractExample#1](../../../samples/snippets/csharp/VS_Snippets_CLR/contractexample/cs/program.cs#1)]
[!code-vb[ContractExample#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/contractexample/vb/program.vb#1)]
