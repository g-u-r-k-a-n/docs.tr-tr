---
title: Akış Hizmetleri ile yinelenen alanlar-WCF geliştiricileri için gRPC
description: GRPC kullanarak veri koleksiyonlarını geçirme yöntemi olarak, yinelenen alanları akış Hizmetleri ile karşılaştırın.
ms.date: 09/02/2019
ms.openlocfilehash: 0e717df57ba2bb52d63a063072d8a45bf0f7e395
ms.sourcegitcommit: f38e527623883b92010cf4760246203073e12898
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/20/2020
ms.locfileid: "77503378"
---
# <a name="grpc-streaming-services-vs-repeated-fields"></a><span data-ttu-id="7eb0c-103">gRPC akış Hizmetleri ile yinelenen alanlar</span><span class="sxs-lookup"><span data-stu-id="7eb0c-103">gRPC streaming services vs. repeated fields</span></span>

<span data-ttu-id="7eb0c-104">gRPC Hizmetleri, veri kümelerini veya nesne listelerini döndürmenin iki yolunu sağlar.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-104">gRPC services provide two ways of returning datasets, or lists of objects.</span></span> <span data-ttu-id="7eb0c-105">Protokol arabellekleri ileti belirtimi, başka bir iletideki ileti türlerini veya ileti dizilerini bildirmek için `repeated` anahtar sözcüğünü kullanır.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-105">The Protocol Buffers message specification uses the `repeated` keyword for declaring lists or arrays of messages within another message.</span></span> <span data-ttu-id="7eb0c-106">GRPC hizmeti belirtimi, uzun süre çalışan kalıcı bir bağlantı bildirmek için `stream` anahtar sözcüğünü kullanır.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-106">The gRPC service specification uses the `stream` keyword to declare a long-running persistent connection.</span></span> <span data-ttu-id="7eb0c-107">Bu bağlantı üzerinde, birden çok ileti gönderilir ve tek tek işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-107">Over that connection, multiple messages are sent, and can be processed, individually.</span></span> 

<span data-ttu-id="7eb0c-108">Ayrıca, bildirimler veya günlük iletileri gibi uzun süre çalışan zamana bağlı veriler için `stream` özelliğini de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-108">You can also use the `stream` feature for long-running temporal data such as notifications or log messages.</span></span> <span data-ttu-id="7eb0c-109">Ancak bu bölüm, tek bir veri kümesi döndürmek için kullanımını göz önünde bulunduracaktır.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-109">But this chapter will consider its use for returning a single dataset.</span></span>

<span data-ttu-id="7eb0c-110">Kullanmanız gereken etkenlere bağlıdır, örneğin:</span><span class="sxs-lookup"><span data-stu-id="7eb0c-110">Which you should use depends on factors such as:</span></span>

- <span data-ttu-id="7eb0c-111">Veri kümesinin genel boyutu.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-111">The overall size of the dataset.</span></span>
- <span data-ttu-id="7eb0c-112">Veri kümesini istemci ya da sunucu ucunda oluşturmak için geçen süre.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-112">The time it took to create the dataset at either the client or server end.</span></span>
- <span data-ttu-id="7eb0c-113">Veri kümesinin tüketicisinin, ilk öğe kullanılabilir duruma geldiğinde hemen üzerinde işlem yapıp başlatamayacağını veya her şeyi yararlı hale yapması için tüm veri kümesine ihtiyacı olup olmadığı.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-113">Whether the consumer of the dataset can start acting on it as soon as the first item is available, or needs the complete dataset to do anything useful.</span></span>

## <a name="when-to-use-repeated-fields"></a><span data-ttu-id="7eb0c-114">`repeated` alanları ne zaman kullanılır?</span><span class="sxs-lookup"><span data-stu-id="7eb0c-114">When to use `repeated` fields</span></span>

<span data-ttu-id="7eb0c-115">Boyut açısından kısıtlanmış olan ve kısa bir süre içinde tek bir şekilde oluşturulabilecek tüm veri kümeleri için — bir saniyenin altında, normal bir prototipleme iletisinde `repeated` alanı kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-115">For any dataset that's constrained in size and that can be generated in its entirety in a short time—say, under one second—you should use a `repeated` field in a regular Protobuf message.</span></span> <span data-ttu-id="7eb0c-116">Örneğin, bir e-ticaret sisteminde, bir sipariş içindeki öğelerin listesini oluşturmak büyük olasılıkla hızlıdır ve liste çok büyük olmaz.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-116">For example, in an e-commerce system, to build a list of items within an order is probably quick and the list won't be very large.</span></span> <span data-ttu-id="7eb0c-117">`repeated` alanla tek bir ileti döndürülmesi `stream` kullanmaktan daha hızlı bir sıralama düzeni ve daha az ağ yükü doğurur.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-117">Returning a single message with a `repeated` field is an order of magnitude faster than using `stream` and incurs less network overhead.</span></span>

<span data-ttu-id="7eb0c-118">İstemciye, işleme başlamadan önce tüm veriler gerekiyorsa ve veri kümesi bellekte oluşturmaya yetecek kadar küçükse, bir `repeated` alanı kullanmayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-118">If the client needs all the data before starting to process it and the dataset is small enough to construct in memory, then consider using a `repeated` field.</span></span> <span data-ttu-id="7eb0c-119">Sunucu üzerindeki bellekte veri kümesinin oluşturulması daha yavaş olsa bile bunu göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-119">Consider it even if the creation of the dataset in memory on the server is slower.</span></span>

## <a name="when-to-use-stream-methods"></a><span data-ttu-id="7eb0c-120">`stream` yöntemlerinin ne zaman kullanılacağı</span><span class="sxs-lookup"><span data-stu-id="7eb0c-120">When to use `stream` methods</span></span>

<span data-ttu-id="7eb0c-121">Veri kümelerinizde bulunan ileti nesneleri çok büyükse, akış isteklerini veya yanıtlarını kullanarak bunları aktarmanız en iyisidir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-121">When the message objects in your datasets are potentially very large, it's best for you transfer them by using streaming requests or responses.</span></span> <span data-ttu-id="7eb0c-122">Bellekte büyük bir nesne oluşturmak, ağa yazmak ve sonra kaynakları boşaltmak daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-122">It's more efficient to construct a large object in memory, write it to the network, and then free up the resources.</span></span> <span data-ttu-id="7eb0c-123">Bu yaklaşım, hizmetinizin ölçeklenebilirliğini geliştirir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-123">This approach will improve the scalability of your service.</span></span>

<span data-ttu-id="7eb0c-124">Benzer şekilde, bunları oluştururken belleğin tükenmesinden kaçınmak için, akış üzerinde kısıtlanmış olmayan boyut veri kümelerini göndermeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-124">Similarly, you should send datasets of unconstrained size over streams to avoid running out of memory while constructing them.</span></span>

<span data-ttu-id="7eb0c-125">Tüketicinin her bir öğeyi ayrı olarak işleyebildiği veri kümeleri için, ilerlemenin kullanıcıya belirtilebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-125">For datasets where the consumer can separately process each item, you should consider using a stream if it means that progress can be indicated to the user.</span></span> <span data-ttu-id="7eb0c-126">Bir akışın kullanılması, bir uygulamanın yanıt hızını iyileştirebilir, ancak uygulamanın genel performansına karşı dengelenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-126">Using a stream can improve the responsiveness of an application, but you should balance it against the overall performance of the application.</span></span>

<span data-ttu-id="7eb0c-127">Akışların yararlı olabilecek başka bir senaryo da birçok hizmet arasında bir iletinin işlendiği yerdir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-127">Another scenario where streams can be useful is where a message is being processed across multiple services.</span></span> <span data-ttu-id="7eb0c-128">Bir zincirdeki her hizmet bir akış döndürürse, Terminal Hizmeti (diğer bir deyişle, zincirdeki son) iletileri döndürmeye başlayabilir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-128">If each service in a chain returns a stream, then the terminal service (that is, the last one in the chain) can start returning messages.</span></span> <span data-ttu-id="7eb0c-129">Bu iletiler işlenebilir ve özgün istek sahibine zincirde geri geçirilebilir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-129">These messages can be processed and passed back along the chain to the original requestor.</span></span> <span data-ttu-id="7eb0c-130">İstek sahibi, bir akış döndürebilir ya da sonuçları tek bir yanıt iletisine toplayabilirler.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-130">The requestor can either return a stream or aggregate the results into a single response message.</span></span> <span data-ttu-id="7eb0c-131">Bu yaklaşım MapReduce gibi desenlerin kendisini geliştirir.</span><span class="sxs-lookup"><span data-stu-id="7eb0c-131">This approach lends itself well to patterns like MapReduce.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="7eb0c-132">[Önceki](migrate-duplex-services.md)
>[İleri](client-libraries.md)</span><span class="sxs-lookup"><span data-stu-id="7eb0c-132">[Previous](migrate-duplex-services.md)
[Next](client-libraries.md)</span></span>
