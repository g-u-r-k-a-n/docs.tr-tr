---
title: Dağıtılmış veri yönetimi için sorunlar ve çözümler
description: Mikro hizmetler dünyasında dağıtılmış veri yönetimi için zorlukların ve çözümlerin neler olduğunu öğrenin.
ms.date: 09/20/2018
ms.openlocfilehash: c30de24591d5a73fd34087f34a69e9c7ed54cd35
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "71834451"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="6ebd2-103">Dağıtılmış veri yönetimi için sorunlar ve çözümler</span><span class="sxs-lookup"><span data-stu-id="6ebd2-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="6ebd2-104">Meydan \#Okuma 1: Her microservice sınırlarını tanımlamak için nasıl</span><span class="sxs-lookup"><span data-stu-id="6ebd2-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="6ebd2-105">Mikro hizmet sınırlarını tanımlamak muhtemelen herkesin karşılaştığı ilk zorluktur.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="6ebd2-106">Her microservice uygulamanızın bir parçası olmalı ve her microservice tüm yararları ve getirdiği zorluklar ile özerk olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="6ebd2-107">Ama bu sınırları nasıl tanımlıyorsun?</span><span class="sxs-lookup"><span data-stu-id="6ebd2-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="6ebd2-108">İlk olarak, uygulamanın mantıksal etki alanı modellerine ve ilgili verilere odaklanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-108">First, you need to focus on the application's logical domain models and related data.</span></span> <span data-ttu-id="6ebd2-109">Aynı uygulama içinde ayrılmış veri adalarını ve farklı bağlamları tanımlamaya çalışın.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-109">Try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="6ebd2-110">Her bağlamın farklı bir iş dili (farklı iş terimleri) olabilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="6ebd2-111">Bağlamlar tanımlanmalı ve bağımsız olarak yönetilmelidir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="6ebd2-112">Bu farklı bağlamlarda kullanılan terimler ve varlıklar benzer görünebilir, ancak belirli bir bağlamda, bir iş kavramının başka bir bağlamda farklı bir amaç için kullanıldığını ve hatta farklı bir ada sahip olabileceğini keşfedebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-112">The terms and entities that are used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="6ebd2-113">Örneğin, bir kullanıcı kimlik veya üyelik bağlamında kullanıcı, CRM bağlamında bir müşteri, sipariş bağlamında alıcı olarak ve benzeri olarak adlandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="6ebd2-114">Her bağlam için farklı bir etki alanına sahip birden çok uygulama bağlamı arasındaki sınırları tanımlama şekliniz, her iş mikro hizmetinin sınırlarını ve ilgili etki alanı modelini ve verilerini tam olarak nasıl tanımlayabileceğinizdir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="6ebd2-115">Her zaman bu mikro hizmetler arasındaki bağlantı en aza indirmek için çalışırsınız.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="6ebd2-116">Bu kılavuz, daha sonra [her microservice için etki alanı modeli sınırlarını tanımlayan](identify-microservice-domain-model-boundaries.md) bölümünde bu tanımlama ve etki alanı modeli tasarımı hakkında daha fazla ayrıntıya gider.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="6ebd2-117">Zorluk \#2: Çeşitli mikro hizmetlerden veri alan sorgular nasıl oluşturulur?</span><span class="sxs-lookup"><span data-stu-id="6ebd2-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="6ebd2-118">İkinci bir zorluk, uzak istemci uygulamalarından mikro hizmetlere geveze iletişimden kaçınırken, çeşitli mikro hizmetlerden veri alan sorguların nasıl uygulanacağıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="6ebd2-119">Bir örnek, sepet, katalog ve kullanıcı kimliği mikro hizmetlerine ait kullanıcı bilgilerini göstermesi gereken bir mobil uygulamadan gelen tek bir ekran olabilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-119">An example could be a single screen from a mobile app that needs to show user information that's owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="6ebd2-120">Başka bir örnek, birden çok mikro hizmetlerde bulunan birçok tablonun yer aldığı karmaşık bir rapor olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="6ebd2-121">Doğru çözüm sorguların karmaşıklığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="6ebd2-122">Ancak her halükarda, sisteminizin iletişiminde verimliliği artırmak istiyorsanız, bilgileri bir araya getirmek için bir yol gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-122">But in any case, you'll need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="6ebd2-123">En popüler çözümler şunlardır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="6ebd2-124">**API Ağ Geçidi.**</span><span class="sxs-lookup"><span data-stu-id="6ebd2-124">**API Gateway.**</span></span> <span data-ttu-id="6ebd2-125">Farklı veritabanlarına sahip birden çok mikro hizmetten basit veri toplama için, önerilen yaklaşım api ağ geçidi olarak adlandırılan bir toplama microservice olduğunu.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="6ebd2-126">Ancak, sisteminizde bir boğma noktası olabilir ve mikro hizmet özerklik ilkesini ihlal edebilir, çünkü bu desen uygulama konusunda dikkatli olmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="6ebd2-127">Bu olasılığı azaltmak için, her biri sistemin dikey bir "dilim" veya iş alanına odaklanan birden çok para cezası kesilmiş API Ağ Geçidi'ne sahip olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical "slice" or business area of the system.</span></span> <span data-ttu-id="6ebd2-128">API Ağ Geçidi deseni daha sonra [API Ağ Geçidi bölümünde](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) daha ayrıntılı olarak açıklanır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-128">The API Gateway pattern is explained in more detail in the [API Gateway section](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md#why-consider-api-gateways-instead-of-direct-client-to-microservice-communication) later.</span></span>

<span data-ttu-id="6ebd2-129">**Sorgu/okuma tabloları ile CQRS.**</span><span class="sxs-lookup"><span data-stu-id="6ebd2-129">**CQRS with query/reads tables.**</span></span> <span data-ttu-id="6ebd2-130">Birden çok mikro hizmetten veri toplama için başka bir çözüm [Materyalize Görünüm deseni.](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="6ebd2-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="6ebd2-131">Bu yaklaşımda, önceden (gerçek sorgular gerçekleşmeden önce normalden arındırılmış verileri hazırlamak), birden çok mikro hizmete ait verileri içeren salt okunur bir tablo oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that's owned by multiple microservices.</span></span> <span data-ttu-id="6ebd2-132">Tablo, istemci uygulamasının gereksinimlerine uygun bir biçime sahiptir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-132">The table has a format suited to the client app's needs.</span></span>

<span data-ttu-id="6ebd2-133">Bir mobil uygulama için ekran gibi bir şey düşünün.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="6ebd2-134">Tek bir veritabanınız varsa, birden çok tablo içeren karmaşık bir birleştirme gerçekleştiren bir SQL sorgusu kullanarak bu ekrana ait verileri bir araya getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="6ebd2-135">Ancak, birden çok veritabanınız varsa ve her veritabanı farklı bir mikro hizmete sahipse, bu veritabanlarını sorgulayamaz ve bir SQL birleştirme oluşturamazsınız.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="6ebd2-136">Karmaşık sorgunuz bir meydan okuma haline gelir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="6ebd2-137">Gereksinimi CQRS yaklaşımını kullanarak giderebilirsiniz—, sadece sorgular için kullanılan farklı bir veritabanında normalden arındırılmış bir tablo oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that's used just for queries.</span></span> <span data-ttu-id="6ebd2-138">Tablo, uygulamanızın ekranının gerektirdiği alanlar ile sorgu tablosundaki sütunlar arasında bire bir ilişki yle karmaşık sorgu için gereken veriler için özel olarak tasarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application's screen and the columns in the query table.</span></span> <span data-ttu-id="6ebd2-139">Ayrıca raporlama amaçlı hizmet verebilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="6ebd2-140">Bu yaklaşım yalnızca özgün sorunu (mikro hizmetler arasında sorgulama ve birleştirme) çözmekle birlikte, aynı zamanda karmaşık bir birleştirmeyle karşılaştırıldığında performansı önemli ölçüde artırır, çünkü uygulamanın sorgu tablosunda ihtiyaç duyduğu verilere zaten sahipsiniz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-140">This approach not only solves the original problem (how to query and join across microservices), but it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="6ebd2-141">Tabii ki, sorgu/okuma tabloları ile Komut ve Sorgu Sorumluluk Ayrımı (CQRS) kullanarak ek geliştirme çalışması anlamına gelir ve nihai tutarlılık kucaklamak gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you'll need to embrace eventual consistency.</span></span> <span data-ttu-id="6ebd2-142">Bununla birlikte, [işbirlikçi senaryolarda](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) performans ve yüksek ölçeklenebilirlik gereksinimleri (veya bakış açısına bağlı olarak rekabetçi senaryolar) birden çok veritabanı ile CQRS uygulamanız gereken yerlerdir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) are where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="6ebd2-143">**Merkezi veritabanlarında "soğuk veri".**</span><span class="sxs-lookup"><span data-stu-id="6ebd2-143">**"Cold data" in central databases.**</span></span> <span data-ttu-id="6ebd2-144">Gerçek zamanlı veri gerektirmeyen karmaşık raporlar ve sorgular için, yaygın bir yaklaşım "sıcak verilerinizi" (mikro hizmetlerden gelen işlem verileri) yalnızca raporlama için kullanılan büyük veritabanlarına "soğuk veri" olarak aktarmaktır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-144">For complex reports and queries that might not require real-time data, a common approach is to export your "hot data" (transactional data from the microservices) as "cold data" into large databases that are used only for reporting.</span></span> <span data-ttu-id="6ebd2-145">Bu merkezi veritabanı sistemi Hadoop, Azure SQL Veri Ambarı'na dayalı bir veri ambarı gibi Büyük Veri tabanlı bir sistem veya yalnızca raporlar için kullanılan tek bir SQL veritabanı (boyut sorun olmayacaksa) olabilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database that's used just for reports (if size won't be an issue).</span></span>

<span data-ttu-id="6ebd2-146">Bu merkezi veritabanının yalnızca gerçek zamanlı veri gereksinimi olmayan sorgular ve raporlar için kullanılacağını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="6ebd2-147">Orijinal güncellemeler ve işlemler, doğruluk kaynağınız olarak, mikro hizmetler verilerinizde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="6ebd2-148">Verileri eşitleme yolunuz, olay odaklı iletişimi (sonraki bölümlerde kapsanmış) veya diğer veritabanı altyapısı alma/dışa aktarma araçlarını kullanarak olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="6ebd2-149">Olay odaklı iletişim kullanıyorsanız, bu tümleştirme işlemi, CQRS sorgu tabloları için daha önce açıklandığı gibi verileri yayma şeklinizle benzer.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="6ebd2-150">Ancak, uygulama tasarımınız karmaşık sorgular için birden çok mikro hizmetten sürekli olarak bilgi toplamayı içeriyorsa, kötü bir tasarımın belirtisi olabilir -bir microservice diğer mikro hizmetlerden mümkün olduğunca izole edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design -a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="6ebd2-151">(Bu, her zaman soğuk veri merkezi veritabanları kullanması gereken raporları/analizleri hariç tutar.) Bu sorun genellikle mikro hizmetleri birleştirmek için bir neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="6ebd2-152">Evrimin özerkliğini ve her bir mikro hizmetin dağıtımını güçlü bağımlılıklar, uyum ve veri toplama ile dengelemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="6ebd2-153">Zorluk \#3: Birden fazla mikro hizmette tutarlılık nasıl elde edir?</span><span class="sxs-lookup"><span data-stu-id="6ebd2-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="6ebd2-154">Daha önce de belirtildiği gibi, her microservice ait veriler bu microservice özel ve sadece kendi microservice API kullanılarak erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="6ebd2-155">Bu nedenle, sunulan bir sorun, birden çok mikro hizmet arasında tutarlılık tutarken uçtan uca iş süreçlerinin nasıl uygulanacağıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="6ebd2-156">Bu sorunu analiz etmek için, [eShopOnContainers başvuru uygulamasından](https://aka.ms/eshoponcontainers)bir örneğe bakalım.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-156">To analyze this problem, let's look at an example from the [eShopOnContainers reference application](https://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="6ebd2-157">Catalog microservice, ürün fiyatı da dahil olmak üzere tüm ürünler hakkında bilgi tutar.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-157">The Catalog microservice maintains information about all the products, including the product price.</span></span> <span data-ttu-id="6ebd2-158">Sepet mikro hizmeti, kullanıcıların alışveriş sepetlerine ekledikleri ürün öğeleriyle ilgili zamansal verileri yönetir ve bu veriler sepete eklendikleri sırada öğelerin fiyatını içerir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-158">The Basket microservice manages temporal data about product items that users are adding to their shopping baskets, which includes the price of the items at the time they were added to the basket.</span></span> <span data-ttu-id="6ebd2-159">Bir ürünün fiyatı katalogda güncellendiğinde, bu fiyat aynı ürünü tutan etkin sepetlerde de güncelleştirilmelidir, ayrıca sistem kullanıcıyı, sepetlerine eklediklerinden beri belirli bir öğenin fiyatının değiştiğini söyleyerek uyarmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-159">When a product's price is updated in the catalog, that price should also be updated in the active baskets that hold that same product, plus the system should probably warn the user saying that a particular item's price has changed since they added it to their basket.</span></span>

<span data-ttu-id="6ebd2-160">Bu uygulamanın varsayımsal yekpare bir sürümünde, ürün tablosundaki fiyat değiştiğinde, katalog alt sistemi sepet tablosundaki geçerli fiyatı güncelleştirmek için bir ACID işlemini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-160">In a hypothetical monolithic version of this application, when the price changes in the products table, the catalog subsystem could simply use an ACID transaction to update the current price in the Basket table.</span></span>

<span data-ttu-id="6ebd2-161">Ancak, mikro hizmetlere dayalı bir uygulamada, Ürün ve Sepet tabloları kendi microservices aittir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-161">However, in a microservices-based application, the Product and Basket tables are owned by their respective microservices.</span></span> <span data-ttu-id="6ebd2-162">Hiçbir microservice, Şekil 4-9'da gösterildiği gibi, doğrudan sorgularda bile başka bir mikro hizmetin sahip olduğu tabloları/depolamayı kendi işlemlerinde içermemelidir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-162">No microservice should ever include tables/storage owned by another microservice in its own transactions, not even in direct queries, as shown in Figure 4-9.</span></span>

![Mikro hizmetler veritabanı verilerinin paylaşılamayabileceğini gösteren diyagram.](./media/distributed-data-management/indepentent-microservice-databases.png)

<span data-ttu-id="6ebd2-164">**Şekil 4-9**.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-164">**Figure 4-9**.</span></span> <span data-ttu-id="6ebd2-165">Bir microservice başka bir microservice bir tabloya doğrudan erişemez</span><span class="sxs-lookup"><span data-stu-id="6ebd2-165">A microservice can't directly access a table in another microservice</span></span>

<span data-ttu-id="6ebd2-166">Sepet tablosu Sepet microservice'e ait olduğundan, Katalog microservice sepet tablosunu doğrudan güncelleştirmemelidir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-166">The Catalog microservice shouldn't update the Basket table directly, because the Basket table is owned by the Basket microservice.</span></span> <span data-ttu-id="6ebd2-167">Sepet mikrohizmetinde bir güncelleştirme yapmak için, Katalog microservice büyük olasılıkla tümleştirme olayları (ileti ve olay tabanlı iletişim) gibi eşzamanlı iletişimi temel alan nihai tutarlılık kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-167">To make an update to the Basket microservice, the Catalog microservice should use eventual consistency probably based on asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="6ebd2-168">Bu nasıl [eShopOnContainers](https://aka.ms/eshoponcontainers) başvuru uygulaması mikro hizmetler arasında tutarlılık bu tür gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-168">This is how the [eShopOnContainers](https://aka.ms/eshoponcontainers) reference application performs this type of consistency across microservices.</span></span>

<span data-ttu-id="6ebd2-169">[CAP teoremi](https://en.wikipedia.org/wiki/CAP_theorem)tarafından belirtildiği gibi, kullanılabilirlik ve ACID güçlü tutarlılık arasında seçim yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-169">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="6ebd2-170">Mikro hizmet tabanlı senaryoların çoğu, güçlü tutarlılık yerine kullanılabilirlik ve yüksek ölçeklenebilirlik ister.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-170">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="6ebd2-171">Görev açısından kritik uygulamalar çalışır durumda ve çalışmaya devam etmeli ve geliştiriciler zayıf veya nihai tutarlılıkla çalışma tekniklerini kullanarak güçlü tutarlılık etrafında çalışabilirler.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-171">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="6ebd2-172">Bu, çoğu mikro hizmet tabanlı mimarinin benimsediğü yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-172">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="6ebd2-173">Ayrıca, ACID tarzı veya iki aşamalı işlemler sadece mikro hizmet ilkelerine aykırı değildir; çoğu NoSQL veritabanları (Azure Cosmos DB, MongoDB, vb.) dağıtılmış veritabanları senaryolarında tipik olan iki aşamalı işleme işlemlerini desteklemez.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-173">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions, typical in distributed databases scenarios.</span></span> <span data-ttu-id="6ebd2-174">Ancak, hizmetler ve veritabanları arasında veri tutarlılığı korumak esastır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-174">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="6ebd2-175">Bu zorluk aynı zamanda, belirli verilerin gereksiz olması gerektiğinde (örneğin, ürünün adının veya açıklamasının Katalog mikrohizmetinde ve Sepet'te olması gerektiğinde) birden çok mikro hizmet arasında değişikliklerin nasıl yayılılacağından da ilgilidir. mikro hizmet.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-175">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product's name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="6ebd2-176">Bu sorun için iyi bir çözüm, olay odaklı iletişim ve yayımlama ve abone sistemi aracılığıyla ifade mikro hizmetler arasında nihai tutarlılık kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-176">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="6ebd2-177">Bu konular daha sonra bu kılavuzda [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) bölümünde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-177">These topics are covered in the section [Asynchronous event-driven communication](asynchronous-message-based-communication.md#asynchronous-event-driven-communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="6ebd2-178">Zorluk \#4: Mikro hizmet sınırları arasında iletişim nasıl tasarlanabilir?</span><span class="sxs-lookup"><span data-stu-id="6ebd2-178">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="6ebd2-179">Mikro hizmet sınırları içinde iletişim kurmak gerçek bir zorluktur.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-179">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="6ebd2-180">Bu bağlamda, iletişim hangi protokolü kullanmanız gerektiğini (HTTP ve REST, AMQP, mesajlaşma vb.) ifade etmez.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-180">In this context, communication doesn't refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="6ebd2-181">Bunun yerine, hangi iletişim stilini kullanmanız gerektiğini ve özellikle mikro hizmetlerinizin nasıl birleştiğinde olması gerektiğini ele alar.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-181">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="6ebd2-182">Bağlantı düzeyine bağlı olarak, hata oluştuğunda, bu hatanın sisteminiz üzerindeki etkisi önemli ölçüde değişir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-182">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="6ebd2-183">Mikro hizmetler tabanlı bir uygulama gibi dağıtılmış bir sistemde, bu kadar çok yapı nın hareket ettirilmesi ve birçok sunucu veya ana bilgisayar arasında dağıtılmış hizmetlerle birlikte bileşenler sonunda başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-183">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="6ebd2-184">Kısmi arıza ve daha büyük kesintiler meydana gelecektir, bu nedenle bu tür dağıtılmış sistemdeki ortak riskleri göz önünde bulundurarak mikro hizmetlerinizi ve aralarındaki iletişimi tasarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-184">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them considering the common risks in this type of distributed system.</span></span>

<span data-ttu-id="6ebd2-185">Popüler bir yaklaşım http (REST) tabanlı mikrohizmetleri, basitlik nedeniyle uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-185">A popular approach is to implement HTTP (REST)-based microservices, due to their simplicity.</span></span> <span data-ttu-id="6ebd2-186">HTTP tabanlı bir yaklaşım son derece kabul edilebilir; buradaki sorun, nasıl kullandığınızla ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-186">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="6ebd2-187">HTTP isteklerini ve yanıtlarını yalnızca istemci uygulamalarından veya API Ağ Geçitlerinden gelen mikro hizmetlerle etkileşim kurmak için kullanıyorsanız, sorun değil.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-187">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that's fine.</span></span> <span data-ttu-id="6ebd2-188">Ancak, mikro hizmetler arasında uzun eşzamanlı HTTP çağrıları zincirleri oluşturursanız, mikro hizmetler yekpare bir uygulamada nesneler gibi kendi sınırları boyunca iletişim kurarsanız, uygulamanız sonunda sorunlarla karşılaşır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-188">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="6ebd2-189">Örneğin, istemci uygulamanızın Sipariş mikro hizmeti gibi tek bir mikro hizmete HTTP API çağrısı yaptığını düşünün.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-189">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="6ebd2-190">Sırayla Sipariş mikrohizmeti, aynı istek/yanıt döngüsü içinde HTTP'yi kullanarak ek mikro hizmetler çağırırsa, bir HTTP çağrıları zinciri oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-190">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you're creating a chain of HTTP calls.</span></span> <span data-ttu-id="6ebd2-191">Başlangıçta mantıklı gelebilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-191">It might sound reasonable initially.</span></span> <span data-ttu-id="6ebd2-192">Ancak, bu yolda giderken göz önünde bulundurulması gereken önemli noktalar vardır:</span><span class="sxs-lookup"><span data-stu-id="6ebd2-192">However, there are important points to consider when going down this path:</span></span>

- <span data-ttu-id="6ebd2-193">Engelleme ve düşük performans.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-193">Blocking and low performance.</span></span> <span data-ttu-id="6ebd2-194">HTTP'nin eşzamanlı doğası nedeniyle, tüm dahili HTTP çağrıları tamamlanana kadar orijinal istek yanıt almaz.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-194">Due to the synchronous nature of HTTP, the original request doesn't get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="6ebd2-195">Bu çağrıların sayısının önemli ölçüde arttığını ve aynı zamanda bir microservice ara HTTP çağrılarından birinin engellendiğini düşünün.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-195">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="6ebd2-196">Sonuç, performansın etkilendiği ve ek HTTP istekleri arttıkça genel ölçeklenebilirliğin katlanarak etkileneceğidir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-196">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

- <span data-ttu-id="6ebd2-197">HTTP ile mikro hizmetleri kaplin.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-197">Coupling microservices with HTTP.</span></span> <span data-ttu-id="6ebd2-198">İş mikro hizmetleri diğer iş mikro hizmetleri ile birleştirilmiş olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-198">Business microservices shouldn't be coupled with other business microservices.</span></span> <span data-ttu-id="6ebd2-199">İdeal olarak, diğer mikro hizmetlerin varlığı hakkında "bilmemelidir".</span><span class="sxs-lookup"><span data-stu-id="6ebd2-199">Ideally, they shouldn't "know" about the existence of other microservices.</span></span> <span data-ttu-id="6ebd2-200">Uygulamanız örnekte olduğu gibi mikro hizmetleri bağlamaya dayanıyorsa, mikrohizmet başına özerklik elde etmek neredeyse imkansız olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-200">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

- <span data-ttu-id="6ebd2-201">Herhangi bir mikro serviste başarısızlık.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-201">Failure in any one microservice.</span></span> <span data-ttu-id="6ebd2-202">HTTP çağrıları yla bağlantılı bir mikro hizmet zinciri uygularsanız, herhangi bir mikro hizmet başarısız olduğunda (ve sonunda başarısız olurlar) tüm mikro hizmetler zinciri başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-202">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="6ebd2-203">Mikro hizmet tabanlı bir sistem, kısmi arızalar sırasında mümkün olduğunca çalışmaya devam edecek şekilde tasarlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-203">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="6ebd2-204">Üstel geri tepme veya devre kesici mekanizmaları ile yeniden denemeler iman etsebile, HTTP çağrı zincirleri ne kadar karmaşıksa, HTTP'ye dayalı bir hata stratejisi uygulamak o kadar karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-204">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is to implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="6ebd2-205">Aslında, dahili mikrohizmetleriniz açıklandığı gibi HTTP istekleri zincirleri oluşturarak iletişim kuruyorsa, işlem içi iletişim mekanizmaları yerine süreçler arasında http'ye dayalı, yekpare bir uygulamanız olduğu söylenebilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-205">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intra-process communication mechanisms.</span></span>

<span data-ttu-id="6ebd2-206">Bu nedenle, mikro hizmet özerkliğini uygulamak ve daha iyi esneklik sağlamak için, mikro hizmetler arasında istek/yanıt iletişimi zincirlerinin kullanımını en aza indirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-206">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="6ebd2-207">Asynchronous ileti ve olay tabanlı iletişim kullanarak veya orijinal HTTP istek/yanıt döngüsünden bağımsız olarak (asynchronous) HTTP yoklamasını kullanarak, yalnızca mikroservisler arası iletişim için eşzamanlı etkileşim kullanmanız önerilir.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-207">It's recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using (asynchronous) HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="6ebd2-208">Asynchronous iletişim kullanımı daha sonra bu kılavuzda ek ayrıntılarla açıklanmıştır bölümlerde [Asynchronous microservice entegrasyonu microservice özerkliğini](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) ve [Asynchronous mesaj tabanlı iletişimi](asynchronous-message-based-communication.md)zorlar.</span><span class="sxs-lookup"><span data-stu-id="6ebd2-208">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice's autonomy](communication-in-microservice-architecture.md#asynchronous-microservice-integration-enforces-microservices-autonomy) and [Asynchronous message-based communication](asynchronous-message-based-communication.md).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="6ebd2-209">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="6ebd2-209">Additional resources</span></span>

- <span data-ttu-id="6ebd2-210">**CAP teoremi** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-210">**CAP theorem** </span></span>\
  <https://en.wikipedia.org/wiki/CAP_theorem>

- <span data-ttu-id="6ebd2-211">**Nihai tutarlılık** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-211">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="6ebd2-212">**Veri Tutarlılığı Astarı** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-212">**Data Consistency Primer** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/dn589800(v=pandp.10)>

- <span data-ttu-id="6ebd2-213">**Martin Fowler' ı. CQRS (Komut ve Sorgu Sorumluluğu Ayrımı)** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-213">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)** </span></span>\
  <https://martinfowler.com/bliki/CQRS.html>

- <span data-ttu-id="6ebd2-214">**Materyalize Görünüm** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-214">**Materialized View** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/materialized-view>

- <span data-ttu-id="6ebd2-215">**Charles Row' u. ACID vs. BASE: Veritabanı İşlem İşleminin DEĞIŞEN pH'ı** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-215">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing** </span></span>\
  <https://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/>

- <span data-ttu-id="6ebd2-216">**Telafi İşlemi** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-216">**Compensating Transaction** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction>

- <span data-ttu-id="6ebd2-217">**Udi Dahan. Hizmet Odaklı Kompozisyon** </span><span class="sxs-lookup"><span data-stu-id="6ebd2-217">**Udi Dahan. Service Oriented Composition** </span></span>\
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

>[!div class="step-by-step"]
><span data-ttu-id="6ebd2-218">[Önceki](logical-versus-physical-architecture.md)
>[Sonraki](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="6ebd2-218">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
