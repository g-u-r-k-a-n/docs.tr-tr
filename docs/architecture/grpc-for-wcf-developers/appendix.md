---
title: WCF geliştiricileri için ek-gRPC
description: Modern mikro hizmet mimarilerinde dağıtılmış işlemlerin ve bunların uygulamalarının tartışılması.
author: markrendle
ms.date: 09/02/2019
ms.openlocfilehash: d181eb07dd50ed338d02edb1908626e6ca3fb56c
ms.sourcegitcommit: 337bdc5a463875daf2cc6883e5a2da97d56f5000
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/24/2019
ms.locfileid: "72846728"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="5f722-103">Ek A-Işlemler</span><span class="sxs-lookup"><span data-stu-id="5f722-103">Appendix A - Transactions</span></span>

<span data-ttu-id="5f722-104">Windows Communication Foundation (WCF) desteklenen dağıtılmış işlemler, birden çok hizmet arasında atomik işlemlerin gerçekleştirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="5f722-104">Windows Communication Foundation (WCF) supported distributed transactions, allowing atomic operations to be performed across multiple services.</span></span> <span data-ttu-id="5f722-105">Bu işlevsellik [Microsoft Dağıtılmış işlem Düzenleyicisi](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85))tabanlıdır.</span><span class="sxs-lookup"><span data-stu-id="5f722-105">This functionality was based on the [Microsoft Distributed Transaction Coordinator](https://docs.microsoft.com/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="5f722-106">Modern mikro hizmetler dikey penceresinde bu tür otomatik dağıtılmış işlem işleme mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="5f722-106">In the modern microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="5f722-107">Birçok farklı teknolojiden, ilişkisel veritabanları, NoSQL veri depoları ve mesajlaşma sistemleri dahil olmak üzere, tek bir ortamda kullanılabilecek işletim sistemleri, programlama dilleri ve çerçeveler dahil olmak üzere çok sayıda farklı teknoloji vardır.</span><span class="sxs-lookup"><span data-stu-id="5f722-107">There are too many different technologies at play, including relational databases, NoSQL data stores, and messaging systems, not to mention the mix of operating systems, programming languages and frameworks that may be used in a single environment.</span></span>

<span data-ttu-id="5f722-108">WCF dağıtılmış işlemi, [iki aşamalı işleme (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)olarak bilinen işlemin bir uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="5f722-108">The WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="5f722-109">Hizmetler genelinde iletileri koordine ederek, her bir hizmette açık işlemler oluşturarak ve başarı veya başarısızlık durumuna bağlı olarak "COMMIT" veya "Rollback" iletileri göndererek, 2PC işlemlerini el ile uygulamak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="5f722-109">It's possible to implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service and sending "commit" or "rollback" messages depending upon success or failure.</span></span> <span data-ttu-id="5f722-110">Ancak, 2PC 'yi yönetmek için kullanılan karmaşıklık, sistem geliştikçe üstel olarak artabilir ve açık işlemler, performansı olumsuz yönde etkileyebilecek veya daha kötü bir hizmet kilitlenmesine neden olabilecek veritabanı kilitlerini tutar.</span><span class="sxs-lookup"><span data-stu-id="5f722-110">However, the complexity that is involved in managing 2PC can increase exponentially as systems evolve, and open transactions hold database locks that can negatively impact performance or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="5f722-111">Mümkünse, dağıtılmış işlemlerden tamamen kaçınmak en iyisidir.</span><span class="sxs-lookup"><span data-stu-id="5f722-111">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="5f722-112">İki veri öğesi atomik güncelleştirmeler gerektirecek şekilde bağlanmışsa, bunları aynı hizmetle işlemeyi ve bu hizmet için tek bir istek veya ileti kullanarak bu atomik değişiklikleri uygulamayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="5f722-112">If two items of data are so linked as to require atomic updates, consider handling them both with the same service, and applying those atomic changes using a single request or message to that service.</span></span>

<span data-ttu-id="5f722-113">Bu mümkün değilse, tek bir alternatif, [Saga deseninin](https://microservices.io/patterns/data/saga.html)kullanılması olabilir.</span><span class="sxs-lookup"><span data-stu-id="5f722-113">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="5f722-114">Bir Saga 'de güncelleştirmeler sırayla işlenir; Her güncelleştirme başarılı olduğu için bir sonraki tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="5f722-114">In a saga, updates are processing sequentially; as each update succeeds the next one is triggered.</span></span> <span data-ttu-id="5f722-115">Bu Tetikleyiciler hizmetten hizmete yayılamaz veya bir Saga Düzenleyicisi veya "Orchestrator" tarafından yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="5f722-115">These triggers can be propagated from service to service, or managed by a saga coordinator or "orchestrator".</span></span> <span data-ttu-id="5f722-116">İşlem sırasında herhangi bir noktada bir güncelleştirme başarısız olursa, güncelleştirmelerini zaten tamamlamış olan hizmetler bunları tersine çevirmek için özel mantık uygular.</span><span class="sxs-lookup"><span data-stu-id="5f722-116">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="5f722-117">Diğer bir seçenek de, [.net mikro hizmetleri e-defterinde](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/)açıklandığı gibi etki alanı odaklı TASARıM (DDD) ve komut/sorgu sorumluluğu ayrımı (CQRS) kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="5f722-117">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/).</span></span> <span data-ttu-id="5f722-118">Özellikle, etki alanı olaylarının veya [olay](https://martinfowler.com/eaaDev/EventSourcing.html) kaynağını kullanmanın kullanılması, güncelleştirmelerin&mdash;düzenli olarak uygulan&mdash;madığından emin olmanıza yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="5f722-118">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently&mdash;if not immediately&mdash;applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="5f722-119">Öncekini</span><span class="sxs-lookup"><span data-stu-id="5f722-119">Previous</span></span>](application-performance-management.md)
