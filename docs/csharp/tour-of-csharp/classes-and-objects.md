---
title: C# sınıflar ve Nesneler - C# Dil turu
description: C#'da yeni misiniz? Sınıflara, nesnelere ve kalıtıma genel bakışı okuyun
ms.date: 02/27/2020
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: c178e11b5667905f75538555c8a309e2fdb4a9ef
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "78159188"
---
# <a name="classes-and-objects"></a><span data-ttu-id="17247-104">Sınıflar ve nesneler</span><span class="sxs-lookup"><span data-stu-id="17247-104">Classes and objects</span></span>

<span data-ttu-id="17247-105">*Sınıflar* C# türlerinin en temelidir.</span><span class="sxs-lookup"><span data-stu-id="17247-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="17247-106">Sınıf, durum (alanlar) ve eylemleri (yöntem ve diğer işlev öğeleri) tek bir birimde birleştiren bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="17247-107">Bir sınıf, *nesneler*olarak da bilinen sınıfın dinamik olarak oluşturulmuş *örnekleri* için bir tanım sağlar.</span><span class="sxs-lookup"><span data-stu-id="17247-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="17247-108">Sınıflar *kalıtım* ve *çok biçimlilik*desteği, *türemiş sınıflar* genişletmek ve *temel sınıfları*uzmanlaşmak mekanizmaları.</span><span class="sxs-lookup"><span data-stu-id="17247-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="17247-109">Sınıf bildirimleri kullanılarak yeni sınıflar oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="17247-109">New classes are created using class declarations.</span></span> <span data-ttu-id="17247-110">Sınıf bildirimi, sınıfın özniteliklerini ve değiştiricilersini, sınıfın adını, taban sınıfı (verilirse) ve sınıf tarafından uygulanan arabirimleri belirten bir üstbilgiyle başlar.</span><span class="sxs-lookup"><span data-stu-id="17247-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="17247-111">Üstbilgi, sınır layıcılar `{` ve `}`.</span><span class="sxs-lookup"><span data-stu-id="17247-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="17247-112">Aşağıdaki kod, aşağıdaki adlı `Point`basit bir sınıfın bildirimini gösterir:</span><span class="sxs-lookup"><span data-stu-id="17247-112">The following code shows a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="17247-113">Sınıf örnekleri, yeni bir `new` örnek için bellek ayıran, örneği başlatması için bir oluşturucu çağırır ve örneğe bir başvuru döndürür işleç kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="17247-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="17247-114">Aşağıdaki ifadeler iki Nokta nesnesi oluşturur ve bu nesnelere iki değişkende başvuru depolar:</span><span class="sxs-lookup"><span data-stu-id="17247-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="17247-115">Nesneye artık erişilemediğinde nesne tarafından işgal edilen bellek otomatik olarak geri alınır.</span><span class="sxs-lookup"><span data-stu-id="17247-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="17247-116">C#'daki nesneleri açıkça ele almak ne gerekli ne de mümkün.</span><span class="sxs-lookup"><span data-stu-id="17247-116">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="17247-117">Üyeler</span><span class="sxs-lookup"><span data-stu-id="17247-117">Members</span></span>

<span data-ttu-id="17247-118">Bir sınıfın üyeleri statik üyeler veya örnek üyelerdir.</span><span class="sxs-lookup"><span data-stu-id="17247-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="17247-119">Statik üyeler sınıflara, örnek üyeler ise nesnelere (sınıf örnekleri) aittir.</span><span class="sxs-lookup"><span data-stu-id="17247-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="17247-120">Aşağıdaki liste, bir sınıfın içerebileceği üye türlerine genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="17247-120">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="17247-121">Sabitler</span><span class="sxs-lookup"><span data-stu-id="17247-121">Constants</span></span>
  - <span data-ttu-id="17247-122">Sınıfla ilişkili sabit değerler</span><span class="sxs-lookup"><span data-stu-id="17247-122">Constant values associated with the class</span></span>
- <span data-ttu-id="17247-123">Alanlar</span><span class="sxs-lookup"><span data-stu-id="17247-123">Fields</span></span>
  - <span data-ttu-id="17247-124">Sınıfın değişkenleri</span><span class="sxs-lookup"><span data-stu-id="17247-124">Variables of the class</span></span>
- <span data-ttu-id="17247-125">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="17247-125">Methods</span></span>
  - <span data-ttu-id="17247-126">Sınıf tarafından gerçekleştirilebilecek hesaplamalar ve eylemler</span><span class="sxs-lookup"><span data-stu-id="17247-126">Computations and actions that can be performed by the class</span></span>
- <span data-ttu-id="17247-127">Özellikler</span><span class="sxs-lookup"><span data-stu-id="17247-127">Properties</span></span>
  - <span data-ttu-id="17247-128">Sınıfın adlandırılmış özelliklerini okuma ve yazma ile ilgili eylemler</span><span class="sxs-lookup"><span data-stu-id="17247-128">Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="17247-129">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="17247-129">Indexers</span></span>
  - <span data-ttu-id="17247-130">Bir dizi gibi sınıfın dizileme örnekleriile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="17247-130">Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="17247-131">Olaylar</span><span class="sxs-lookup"><span data-stu-id="17247-131">Events</span></span>
  - <span data-ttu-id="17247-132">Sınıf tarafından oluşturulabilen bildirimler</span><span class="sxs-lookup"><span data-stu-id="17247-132">Notifications that can be generated by the class</span></span>
- <span data-ttu-id="17247-133">İşleçler</span><span class="sxs-lookup"><span data-stu-id="17247-133">Operators</span></span>
  - <span data-ttu-id="17247-134">Sınıf tarafından desteklenen dönüşümler ve ifade işleçleri</span><span class="sxs-lookup"><span data-stu-id="17247-134">Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="17247-135">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="17247-135">Constructors</span></span>
  - <span data-ttu-id="17247-136">Sınıfın veya sınıfın kendi örneklerini başlatmaiçin gereken eylemler</span><span class="sxs-lookup"><span data-stu-id="17247-136">Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="17247-137">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="17247-137">Finalizers</span></span>
  - <span data-ttu-id="17247-138">Sınıfın örnekleri kalıcı olarak atılmadan önce gerçekleştirecek eylemler</span><span class="sxs-lookup"><span data-stu-id="17247-138">Actions to perform before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="17247-139">Türler</span><span class="sxs-lookup"><span data-stu-id="17247-139">Types</span></span>
  - <span data-ttu-id="17247-140">Sınıf tarafından bildirilen iç içe geçen türler</span><span class="sxs-lookup"><span data-stu-id="17247-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="17247-141">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="17247-141">Accessibility</span></span>

<span data-ttu-id="17247-142">Bir sınıfın her üyesi, üyeye erişebilen program metninin bölgelerini denetleyen ilişkili bir erişilebilirlik vardır.</span><span class="sxs-lookup"><span data-stu-id="17247-142">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="17247-143">Erişilebilirliğin altı olası biçimi vardır.</span><span class="sxs-lookup"><span data-stu-id="17247-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="17247-144">Erişim değiştiriciler aşağıda özetlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="17247-144">The access modifiers are summarized below.</span></span>

- `public`
  - <span data-ttu-id="17247-145">Erişim sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="17247-145">Access isn't limited.</span></span>
- `protected`
  - <span data-ttu-id="17247-146">Erişim bu sınıf veya bu sınıftan türetilen sınıfları ile sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-146">Access is limited to this class or classes derived from this class.</span></span>
- `internal`
  - <span data-ttu-id="17247-147">Erişim geçerli derlemeyle sınırlıdır (.exe, .dll, vb.).</span><span class="sxs-lookup"><span data-stu-id="17247-147">Access is limited to the current assembly (.exe, .dll, and so on.).</span></span>
- `protected internal`
  - <span data-ttu-id="17247-148">Erişim, içeren sınıfla, içeren sınıftan türetilen sınıfla veya aynı derlemedeki sınıfla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-148">Access is limited to the containing class, classes derived from the containing class, or classes within the same assembly.</span></span>
- `private`
  - <span data-ttu-id="17247-149">Erişim bu sınıfla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-149">Access is limited to this class.</span></span>
- `private protected`
  - <span data-ttu-id="17247-150">Erişim, aynı derleme içinde içeren türden türetilen içeren sınıf veya sınıfla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-150">Access is limited to the containing class or classes derived from the containing type within the same assembly.</span></span>

## <a name="type-parameters"></a><span data-ttu-id="17247-151">Tip parametreleri</span><span class="sxs-lookup"><span data-stu-id="17247-151">Type parameters</span></span>

<span data-ttu-id="17247-152">Sınıf tanımı, sınıf adını açı ayraçlarıyla izleyerek bir tür parametresi kümesi belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="17247-153">Tür parametreleri daha sonra sınıf bildirimleri gövdesinde sınıf üyelerini tanımlamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="17247-154">Aşağıdaki örnekte, tip `Pair` parametreleri `TFirst` `TSecond`ve:</span><span class="sxs-lookup"><span data-stu-id="17247-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="17247-155">Tür parametreleri almak için bildirilen bir *sınıf türüne genel sınıf türü*denir.</span><span class="sxs-lookup"><span data-stu-id="17247-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="17247-156">Yapı, arabirim ve temsilci türleri de genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-156">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="17247-157">Genel sınıf kullanıldığında, tür parametrelerinin her biri için tür bağımsız değişkenleri sağlanmalıdır:</span><span class="sxs-lookup"><span data-stu-id="17247-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="17247-158">Yukarıdaki gibi `Pair<int,string>` sağlanan tür bağımsız değişkenleri ile genel bir *tür, yapılı türü*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="17247-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="17247-159">Temel sınıflar</span><span class="sxs-lookup"><span data-stu-id="17247-159">Base classes</span></span>

<span data-ttu-id="17247-160">Bir sınıf bildirimi, bir üst üste ve taban sınıfın adı ile sınıf adı ve türü parametrelerini izleyerek bir taban sınıf belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="17247-161">Taban sınıf belirtimiattüründen türeyen ile `object`aynıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="17247-162">Aşağıdaki örnekte, taban sınıf `Point3D` `Point`ve taban `Point` sınıf: `object`</span><span class="sxs-lookup"><span data-stu-id="17247-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="17247-163">Bir sınıf, taban sınıfının üyelerini devralır.</span><span class="sxs-lookup"><span data-stu-id="17247-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="17247-164">Devralma, bir sınıfın örnek ve statik oluşturucular ve taban sınıfın sonlandırıcıları dışında taban sınıfının tüm üyelerini dolaylı olarak içerdiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="17247-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="17247-165">Türetilen bir sınıf devraldığı üyelere yeni üyeler ekleyebilir, ancak devralınan üye tanımını kaldıramaz.</span><span class="sxs-lookup"><span data-stu-id="17247-165">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="17247-166">Önceki örnekte, `Point3D` ve `x` `y` `Point`alanları devralır ve `Point3D` her örneküç `x` `y`alan `z`içerir, , ve .</span><span class="sxs-lookup"><span data-stu-id="17247-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="17247-167">Örtük dönüştürme, bir sınıf türünden taban sınıf türlerinden herhangi biri için vardır.</span><span class="sxs-lookup"><span data-stu-id="17247-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="17247-168">Sınıf türünden bir değişken, o sınıfın bir örneğine veya türetilmiş herhangi bir sınıfın örneğine başvuruyapabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-168">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="17247-169">Örneğin, önceki sınıf bildirimleri göz önüne `Point` alındığında, tür `Point` bir `Point3D`değişken a veya a başvuruolabilir:</span><span class="sxs-lookup"><span data-stu-id="17247-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="17247-170">Alanlar</span><span class="sxs-lookup"><span data-stu-id="17247-170">Fields</span></span>

<span data-ttu-id="17247-171">*Alan,* bir sınıfla veya bir sınıf örneğiyle ilişkili bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="17247-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="17247-172">Statik değiştirici ile bildirilen bir alan statik bir alan tanımlar.</span><span class="sxs-lookup"><span data-stu-id="17247-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="17247-173">Statik alan tam olarak bir depolama konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="17247-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="17247-174">Bir sınıfın kaç örneği oluşturulursa oluşturulsun, statik alanın yalnızca bir kopyası vardır.</span><span class="sxs-lookup"><span data-stu-id="17247-174">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="17247-175">Statik değiştirici olmadan bildirilen bir alan bir örnek alan tanımlar.</span><span class="sxs-lookup"><span data-stu-id="17247-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="17247-176">Bir sınıfın her örneği, o sınıfın tüm örnek alanlarının ayrı bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="17247-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="17247-177">Aşağıdaki `Color` örnekte, sınıfın her örneğinde , ve `r` `g` `b` örnek alanlarının ayrı bir kopyası vardır, `Black`ancak `White` `Red`, `Green`, `Blue` , ve statik alanların yalnızca bir kopyası vardır:</span><span class="sxs-lookup"><span data-stu-id="17247-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="17247-178">Önceki örnekte gösterildiği gibi, *salt okunur alanlar* `readonly` bir değiştirici ile bildirilebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="17247-179">Bir `readonly` alana atama, yalnızca alanın bildiriminin bir parçası olarak veya aynı sınıftaki bir oluşturucuda oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="17247-180">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="17247-180">Methods</span></span>

<span data-ttu-id="17247-181">*Yöntem,* bir nesne veya sınıf tarafından gerçekleştirilebilecek bir hesaplama veya eylem uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="17247-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="17247-182">*Statik yöntemlere* sınıf aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="17247-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="17247-183">*Örnek yöntemlerine* sınıfın örnekleri aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="17247-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="17247-184">Yöntemler, yönteme aktarılan değerleri veya değişken başvuruları temsil eden *parametrelerin*bir listesine ve yöntem tarafından hesaplanan ve döndürülen değerin türünü belirten bir *dönüş türüne*sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="17247-185">Yöntemin dönüş türü, `void` bir değer döndürmemesidir.</span><span class="sxs-lookup"><span data-stu-id="17247-185">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="17247-186">Türleri gibi, yöntemler de yöntem çağrıldığında tür bağımsız değişkenleri belirtilmesi gereken tür parametreleri kümesi olabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="17247-187">Türlerin aksine, tür bağımsız değişkenleri genellikle bir yöntem çağrısının bağımsız değişkenlerinden çıkarılabilir ve açıkça verilmemesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="17247-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="17247-188">Yöntemin *imzası,* yöntemin beyan edildiği sınıfta benzersiz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="17247-189">Bir yöntemin imzası yöntemin adı, tür parametreleri ve sayısı, değiştiriciler ve parametrelerin türleri oluşur.</span><span class="sxs-lookup"><span data-stu-id="17247-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="17247-190">Bir yöntemin imzası iade türünü içermez.</span><span class="sxs-lookup"><span data-stu-id="17247-190">The signature of a method doesn't include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="17247-191">Parametreler</span><span class="sxs-lookup"><span data-stu-id="17247-191">Parameters</span></span>

<span data-ttu-id="17247-192">Parametreler, değerleri veya değişken başvuruları yöntemlere aktarmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="17247-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="17247-193">Yöntemin parametreleri, yöntem çağrıldığı zaman belirtilen *bağımsız değişkenlerden* gerçek değerlerini alır.</span><span class="sxs-lookup"><span data-stu-id="17247-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="17247-194">Dört tür parametre vardır: değer parametreleri, referans parametreleri, çıkış parametreleri ve parametre dizileri.</span><span class="sxs-lookup"><span data-stu-id="17247-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="17247-195">Giriş bağımsız değişkenlerini geçirmek için bir *değer parametresi* kullanılır.</span><span class="sxs-lookup"><span data-stu-id="17247-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="17247-196">Değer parametresi, parametre için geçirilen bağımsız değişkenden ilk değerini alan yerel bir değişkene karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="17247-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="17247-197">Değer parametresindeki değişiklikler, parametre için geçirilen bağımsız değişkeni etkilemez.</span><span class="sxs-lookup"><span data-stu-id="17247-197">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="17247-198">Değer parametreleri, ilgili bağımsız değişkenlerin atlanabilmesi için varsayılan değer belirterek isteğe bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="17247-199">Bir *başvuru parametresi* başvuru ile bağımsız değişkenleri geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="17247-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="17247-200">Bir başvuru parametresi için geçirilen bağımsız değişken, belirli bir değere sahip bir değişken olmalıdır ve yöntemin yürütülmesi sırasında, başvuru parametresi bağımsız değişkenle aynı depolama konumunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="17247-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="17247-201">Bir başvuru parametresi `ref` değiştirici ile bildirilir.</span><span class="sxs-lookup"><span data-stu-id="17247-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="17247-202">Aşağıdaki örnek, parametrelerin `ref` kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="17247-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="17247-203">Bağımsız değişkenleri başvuruyla geçirmek için bir *çıktı parametresi* kullanılır.</span><span class="sxs-lookup"><span data-stu-id="17247-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="17247-204">Arayan tarafından sağlanan bağımsız değişkene açıkça bir değer atamanızı gerektirmemesi dışında, başvuru parametresine benzer.</span><span class="sxs-lookup"><span data-stu-id="17247-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="17247-205">`out` Bir çıkış parametresi değiştirici ile bildirilir.</span><span class="sxs-lookup"><span data-stu-id="17247-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="17247-206">Aşağıdaki örnek, C# `out` 7'de tanıtılan sözdizimi kullanarak parametrelerin kullanımını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="17247-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="17247-207">*Parametre dizisi,* değişken sayıda bağımsız değişkenin bir yönteme geçirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="17247-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="17247-208">`params` Bir parametre dizisi değiştirici ile bildirilir.</span><span class="sxs-lookup"><span data-stu-id="17247-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="17247-209">Bir yöntemin yalnızca son parametresi bir parametre dizisi olabilir ve parametre dizisinin türü tek boyutlu bir dizi türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="17247-210"><xref:System.Console?displayProperty=nameWithType> Sınıfın Yazma ve Yazma Çizgisi yöntemleri parametre dizi kullanımının iyi örnekleridir.</span><span class="sxs-lookup"><span data-stu-id="17247-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="17247-211">Aşağıdaki gibi beyan edilmiştir.</span><span class="sxs-lookup"><span data-stu-id="17247-211">They're declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="17247-212">Parametre dizisini kullanan bir yöntem de, parametre dizisi tam olarak bir dizi türünün normal parametresi gibi görünür.</span><span class="sxs-lookup"><span data-stu-id="17247-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="17247-213">Ancak, parametre dizilime sahip bir yöntemin çağrılması, parametre dizitüründen tek bir bağımsız değişkeni veya parametre dizisinin öğe türünün herhangi bir değişkenini geçmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="17247-213">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="17247-214">İkinci durumda, bir dizi örneği otomatik olarak oluşturulur ve verilen bağımsız değişkenler ile başharfe.</span><span class="sxs-lookup"><span data-stu-id="17247-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="17247-215">Bu örnek</span><span class="sxs-lookup"><span data-stu-id="17247-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="17247-216">aşağıdakileri yazmaya eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="17247-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="17247-217">Yöntem gövdesi ve yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="17247-217">Method body and local variables</span></span>

<span data-ttu-id="17247-218">Yöntemin gövdesi, yöntem çağrıldığı zaman yürütülecek ifadeleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="17247-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="17247-219">Bir yöntem gövdesi, yöntemin çağrılması için özel değişkenler bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="17247-220">Bu tür değişkenlere *yerel değişkenler*denir.</span><span class="sxs-lookup"><span data-stu-id="17247-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="17247-221">Yerel bir değişken bildirimi bir tür adı, bir değişken adı ve büyük olasılıkla bir başlangıç değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="17247-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="17247-222">Aşağıdaki örnekte, başlangıç `i` değeri sıfır olan yerel bir `j` değişken ve başlangıç değeri olmayan yerel bir değişken beyan edin.</span><span class="sxs-lookup"><span data-stu-id="17247-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="17247-223">C# değeri elde edilmeden önce *kesinlikle atanması* için yerel bir değişken gerektirir.</span><span class="sxs-lookup"><span data-stu-id="17247-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="17247-224">Örneğin, önceki `i` bildirimi bir başlangıç değeri içermediyse, derleyici, programdaki bu noktalarda `i` kesinlikle `i` atanmayacağı için sonraki kullanımlar için bir hata bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-224">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="17247-225">Yöntem, denetimi `return` arayana döndürmek için deyimleri kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="17247-226">Dönen bir `void`yöntemde, `return` ifadeler bir ifade belirtemez.</span><span class="sxs-lookup"><span data-stu-id="17247-226">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="17247-227">Geçersiz olmayan dönen bir yöntemde, `return` ifadeler iade değerini hesaplayan bir ifade içermelidir.</span><span class="sxs-lookup"><span data-stu-id="17247-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="17247-228">Statik ve örnek yöntemleri</span><span class="sxs-lookup"><span data-stu-id="17247-228">Static and instance methods</span></span>

<span data-ttu-id="17247-229">Statik değiştirici ile bildirilen bir *yöntem statik*bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="17247-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="17247-230">Statik bir yöntem belirli bir örnekte çalışmaz ve yalnızca doğrudan statik üyelere erişebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-230">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="17247-231">Statik değiştirici olmadan bildirilen bir *yöntem bir örnek yöntemidir.*</span><span class="sxs-lookup"><span data-stu-id="17247-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="17247-232">Örnek yöntemi belirli bir örneküzerinde çalışır ve hem statik hem de örnek üyelere erişebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="17247-233">Bir örnek yönteminin çağrıldığı örnek açıkça '' `this`olarak erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="17247-234">Statik bir `this` yöntemde başvurmak bir hatadır.</span><span class="sxs-lookup"><span data-stu-id="17247-234">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="17247-235">Aşağıdaki `Entity` sınıfın hem statik hem de örnek üyeleri vardır.</span><span class="sxs-lookup"><span data-stu-id="17247-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="17247-236">Her `Entity` örnek bir seri numarası (ve muhtemelen burada gösterilmeyen bazı diğer bilgiler) içerir.</span><span class="sxs-lookup"><span data-stu-id="17247-236">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="17247-237">Oluşturucu `Entity` (bir örnek yöntemi gibi) bir sonraki kullanılabilir seri numarası ile yeni örneği başharfe olarak laştırır.</span><span class="sxs-lookup"><span data-stu-id="17247-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="17247-238">Oluşturucu bir örnek üye olduğundan, hem `serialNo` örnek alana hem de `nextSerialNo` statik alana erişme izni verilir.</span><span class="sxs-lookup"><span data-stu-id="17247-238">Because the constructor is an instance member, it's permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="17247-239">Ve `GetNextSerialNo` `SetNextSerialNo` statik yöntemler `nextSerialNo` statik alana erişebilir, ancak `serialNo` örnek alanına doğrudan erişmeleri hata olur.</span><span class="sxs-lookup"><span data-stu-id="17247-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="17247-240">Aşağıdaki örnek, Varlık sınıfının kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="17247-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="17247-241">Örnek `SetNextSerialNo` `GetNextSerialNo` yöntem sınıfın `GetSerialNo` örneklerinde çağrılırken, sınıfüzerinde statik yöntemler çağrılır.</span><span class="sxs-lookup"><span data-stu-id="17247-241">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="17247-242">Sanal, geçersiz kılma ve soyut yöntemler</span><span class="sxs-lookup"><span data-stu-id="17247-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="17247-243">Bir örnek yöntem bildirimi `virtual` bir değiştirici içeriyorsa, *yöntemin sanal*bir yöntem olduğu söylenir.</span><span class="sxs-lookup"><span data-stu-id="17247-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="17247-244">Sanal değiştirici olmadığında, yöntemin *sanal olmayan*bir yöntem olduğu söylenir.</span><span class="sxs-lookup"><span data-stu-id="17247-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="17247-245">Sanal bir yöntem çağrıldığında, bu çağırmanın gerçekleştiği örneğin *çalışma zamanı türü,* çağırmak için gerçek yöntem uygulamasını belirler.</span><span class="sxs-lookup"><span data-stu-id="17247-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="17247-246">Sanal olmayan bir yöntem çağırmasında, örneğin *derleme zamanı türü* belirleyici faktördür.</span><span class="sxs-lookup"><span data-stu-id="17247-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="17247-247">Sanal yöntem türetilmiş bir sınıfta *geçersiz* kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="17247-248">Bir örnek yöntem bildirimi bir geçersiz kılma değiştirici içeriyorsa, yöntem aynı imza ile devralınan bir sanal yöntemi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="17247-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="17247-249">Sanal yöntem bildirimi yeni bir yöntem sunarken, geçersiz kılma yöntemi bildirimi, bu yöntemin yeni bir uygulamasını sağlayarak varolan bir devralınan sanal yöntemüzerinde uzmanlaşmıştır.</span><span class="sxs-lookup"><span data-stu-id="17247-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="17247-250">Soyut bir *yöntem,* hiçbir uygulama ile sanal bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="17247-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="17247-251">Soyut bir yöntem soyut değiştirici ile bildirilir ve yalnızca soyut olarak bildirilen bir sınıfta izin verilir.</span><span class="sxs-lookup"><span data-stu-id="17247-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="17247-252">Soyut olmayan her türemiş sınıfta soyut bir yöntem geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="17247-253">Aşağıdaki örnek, bir ifade `Expression`ağacı düğümünü temsil eden soyut bir sınıf `Constant` `VariableReference`ve `Operation`sabitler, değişken başvurular ve aritmetik işlemler için ifade ağacı düğümlerini uygulayan üç türemiş sınıf bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="17247-254">(Bu örnek benzer, ancak ifade ağacı türleri ile karıştırılmamalıdır).</span><span class="sxs-lookup"><span data-stu-id="17247-254">(This example is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="17247-255">Önceki dört sınıf aritmetik ifadeleri modellemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="17247-256">Örneğin, bu sınıfların örneklerini kullanarak, ifade `x + 3` aşağıdaki gibi temsil edilebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="17247-257">Verilen `Evaluate` ifadeyi `Expression` değerlendirmek ve bir `double` değer üretmek için bir örneğin yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="17247-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="17247-258">Yöntem değişken `Dictionary` adları (girişlerin anahtarları olarak) ve değerleri (girişlerin değerleri olarak) içeren bir bağımsız değişken alır.</span><span class="sxs-lookup"><span data-stu-id="17247-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="17247-259">Soyut `Evaluate` bir yöntem olduğundan, türetilen `Expression` soyut olmayan `Evaluate`sınıflar geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="17247-260">Bir `Constant`'uygulama `Evaluate` sadece depolanan sabit döndürür.</span><span class="sxs-lookup"><span data-stu-id="17247-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="17247-261">Bir `VariableReference`'s uygulaması sözlükteki değişken adını arar ve elde edilen değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="17247-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="17247-262">Bir `Operation`'s uygulaması ilk sol ve sağ operands değerlendirir (özyinelemeli `Evaluate` yöntemleri çağırarak) ve daha sonra verilen aritmetik işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="17247-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="17247-263">Aşağıdaki program farklı `Expression` değerler `x * (y + 2)` `x` için ifade değerlendirmek için `y`sınıfları kullanır ve .</span><span class="sxs-lookup"><span data-stu-id="17247-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="17247-264">Yöntem aşırı yükleme</span><span class="sxs-lookup"><span data-stu-id="17247-264">Method overloading</span></span>

<span data-ttu-id="17247-265">Yöntem *aşırı yükleme,* aynı sınıftaki birden çok yöntemin, benzersiz imzaları olduğu sürece aynı ada sahip olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="17247-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="17247-266">Derleyici, aşırı yüklü bir yöntemin çağrılmasını derlediğinizde, çağırmak için belirli bir yöntemi belirlemek için *aşırı yük çözünürlüğünü* kullanır.</span><span class="sxs-lookup"><span data-stu-id="17247-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="17247-267">Aşırı yükleme çözümü, bağımsız değişkenler ile en iyi eşleşen yöntemi bulur veya tek bir en iyi eşleşme bulunamazsa hata bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="17247-268">Aşağıdaki örnekte, aşırı yük çözünürlüğü etkin olarak gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="17247-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="17247-269">Yöntemdeki her çağrı için `UsageExample` yapılan açıklama, hangi yöntemin çağrıldığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="17247-269">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="17247-270">Örnekte gösterildiği gibi, bağımsız değişkenleri tam parametre türlerine ve/veya açıkça tür bağımsız değişkenlerine ekleyerek her zaman belirli bir yöntem seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="17247-271">Diğer işlev üyeleri</span><span class="sxs-lookup"><span data-stu-id="17247-271">Other function members</span></span>

<span data-ttu-id="17247-272">Yürütülebilir kod içeren üyeler, bir sınıfın *işlev üyeleri* olarak topluca bilinir.</span><span class="sxs-lookup"><span data-stu-id="17247-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="17247-273">Önceki bölümde, birincil işlev üyeleri türleri olan yöntemler açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="17247-273">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="17247-274">Bu bölümde C# tarafından desteklenen diğer işlev üyeleri türleri açıklanır: oluşturucular, özellikler, dizin leyiciler, olaylar, işleçler ve sonlandırıcılar.</span><span class="sxs-lookup"><span data-stu-id="17247-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="17247-275">Aşağıdaki örnek, büyüyebilir `MyList<T>`bir nesne listesini uygulayan genel bir sınıf olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="17247-275">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="17247-276">Sınıf, en yaygın işlev türlerinden birkaç örnek içerir.</span><span class="sxs-lookup"><span data-stu-id="17247-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="17247-277">Bu örnek, `MyList` .NET standardı <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>ile aynı olmayan bir sınıf oluşturur.</span><span class="sxs-lookup"><span data-stu-id="17247-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="17247-278">Bu tur için gerekli kavramları göstermek yok, ancak bu sınıf için bir yedek değildir.</span><span class="sxs-lookup"><span data-stu-id="17247-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="17247-279">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="17247-279">Constructors</span></span>

<span data-ttu-id="17247-280">C# hem örnek hem de statik oluşturucuları destekler.</span><span class="sxs-lookup"><span data-stu-id="17247-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="17247-281">*Örnek oluşturucu,* bir sınıfın örneğini başlatması için gereken eylemleri uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="17247-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="17247-282">*Statik oluşturucu,* bir sınıfın kendisini ilk yüklendiğinde başlatması için gereken eylemleri uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="17247-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="17247-283">Bir oluşturucu, iade türü olmayan ve içeren sınıfla aynı ada sahip bir yöntem gibi bildirilir.</span><span class="sxs-lookup"><span data-stu-id="17247-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="17247-284">Bir oluşturucu bildirimi statik bir değiştirici içeriyorsa, statik bir oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="17247-285">Aksi takdirde, bir örnek oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="17247-286">Örnek oluşturucular aşırı yüklenebilir ve isteğe bağlı parametrelere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-286">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="17247-287">Örneğin, `MyList<T>` sınıf tek bir isteğe bağlı `int` parametre ile bir örnek oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-287">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="17247-288">Örnek oluşturucular `new` işleç kullanılarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="17247-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="17247-289">Aşağıdaki ifadeler, isteğe bağlı bağımsız değişkeni `MyList` olan ve olmayan sınıfın oluşturucusu kullanılarak iki `MyList<string>` örnek ayırır.</span><span class="sxs-lookup"><span data-stu-id="17247-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="17247-290">Diğer üyelerin aksine, örnek oluşturucular kalıtsal değildir ve bir sınıfın sınıfta gerçekten beyan edilen bu yapıcılar dışında örnek oluşturucuları yoktur.</span><span class="sxs-lookup"><span data-stu-id="17247-290">Unlike other members, instance constructors aren't inherited, and a class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="17247-291">Bir sınıf için örnek oluşturucu sağlanmışsa, parametreleri olmayan boş bir sınıf otomatik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="17247-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="17247-292">Özellikler</span><span class="sxs-lookup"><span data-stu-id="17247-292">Properties</span></span>

<span data-ttu-id="17247-293">*Özellikler* alanların doğal bir uzantısıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="17247-294">Her ikisi de ilişkili türleri olan üyeler adlandırılmış ve alanlara ve özelliklere erişmek için sözdizimi aynıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="17247-295">Ancak, alanların aksine, özellikler depolama konumlarını ifade etmez.</span><span class="sxs-lookup"><span data-stu-id="17247-295">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="17247-296">Bunun yerine, özelliklerin, değerleri okunduğunda veya yazıldığında yürütülecek deyimleri belirten *erişime sahip olmaları* gerekir.</span><span class="sxs-lookup"><span data-stu-id="17247-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="17247-297">Bir özellik, beyannamenin bir erişime erişimve/veya sınırlayıcılar `{` arasında yazılmış bir set erişimci `}` yle sona ermesi ve yarı kolonla sonlandırmak yerine bir alan gibi bildirilir.</span><span class="sxs-lookup"><span data-stu-id="17247-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="17247-298">Hem erişime sahip hem de ayarlanmış bir erişime sahip bir özellik *okuma yazma özelliğidir,* yalnızca erişime sahip bir özellik yalnızca *okuma özelliğidir*ve yalnızca ayarlanmış bir erişime sahip olan bir özellik *yalnızca yazma özelliğidir.*</span><span class="sxs-lookup"><span data-stu-id="17247-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="17247-299">Get accessor özellik türü bir dönüş değeri ile parametresiz bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="17247-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="17247-300">Bir atamanın hedefi dışında, bir özellik ifadede başvurulduğunda, özelliğin değerini hesaplamak için mülkün erişime giren aracı çağrılır.</span><span class="sxs-lookup"><span data-stu-id="17247-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="17247-301">Kümeli erişimci, değeri adında tek bir parametreye sahip ve dönüş türü olmayan bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="17247-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="17247-302">Bir özellik bir atamanın hedefi olarak veya ++veya --, operand olarak başvurulduğunda, ayarlanan erişimyeni değeri sağlayan bir bağımsız değişkenle çağrılır.</span><span class="sxs-lookup"><span data-stu-id="17247-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="17247-303">Sınıf, `MyList<T>` `Count` `Capacity`sırasıyla salt okunur ve okunan iki özelliği bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="17247-304">Aşağıdaki kod, bu özelliklerin kullanımına bir örnektir:</span><span class="sxs-lookup"><span data-stu-id="17247-304">The following code is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="17247-305">Alanlara ve yöntemlere benzer şekilde, C# hem örnek özelliklerini hem de statik özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="17247-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="17247-306">Statik özellikler statik değiştirici ile bildirilir ve örnek özellikleri onsuz bildirilir.</span><span class="sxs-lookup"><span data-stu-id="17247-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="17247-307">Bir özelliğin erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="17247-308">Bir özellik bildirimi `virtual`, `abstract`, `override` veya değiştirici içeriyorsa, bu özellik erişim (ler) için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="17247-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="17247-309">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="17247-309">Indexers</span></span>

<span data-ttu-id="17247-310">*Dizinleyici,* nesnelerin diziyle aynı şekilde dizilmesini sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="17247-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="17247-311">Bir dizinleyici, üyenin `this` adının sınır dışı edenler `[` ve . `]`</span><span class="sxs-lookup"><span data-stu-id="17247-311">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="17247-312">Parametreler dizinleyicinin erişime atasında mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="17247-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="17247-313">Özelliklere benzer şekilde, dizinleyiciler okuma-yazma, salt okunur ve yalnızca yazma olabilir ve dizinleyicinin erişimi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="17247-314">Sınıf, `MyList<T>` bir parametre alan tek bir `int` okuma-yazma dizinleyicisi bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="17247-315">Dizinleyici, örnekleri değerlerle dizine `MyList<T>` ekmemi `int` mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="17247-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="17247-316">Örnek:</span><span class="sxs-lookup"><span data-stu-id="17247-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="17247-317">Dizinleyiciler aşırı yüklenebilir, bu da bir sınıfın parametrelerinin sayısı veya türleri farklı olduğu sürece birden çok dizinleyici bildirebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="17247-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="17247-318">Olaylar</span><span class="sxs-lookup"><span data-stu-id="17247-318">Events</span></span>

<span data-ttu-id="17247-319">*Olay,* bir sınıfın veya nesnenin bildirim sağlamasını sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="17247-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="17247-320">Bir olay, bildirimin bir olay anahtar sözcüğü içerdiğini ve türünün bir temsilci türü olması dışında bir alan gibi bildirilir.</span><span class="sxs-lookup"><span data-stu-id="17247-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="17247-321">Olay üyesini bildiren bir sınıf içinde, olay bir temsilci türündeki alan gibi olur (olay soyut değilse ve erişime girenleri bildirmezse).</span><span class="sxs-lookup"><span data-stu-id="17247-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="17247-322">Alan, olaya eklenen olay işleyicilerini temsil eden bir temsilciye başvuruda bulunuyor.</span><span class="sxs-lookup"><span data-stu-id="17247-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="17247-323">Olay işleyicileri yoksa, alan `null`.</span><span class="sxs-lookup"><span data-stu-id="17247-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="17247-324">`Changed`Sınıf, `MyList<T>` listeye yeni bir öğenin eklendiğini belirten tek bir olay üyesi ni bildirir.</span><span class="sxs-lookup"><span data-stu-id="17247-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="17247-325">Değiştirilen olay, önce `OnChanged` olayın olup `null` olmadığını denetleyen sanal yöntem tarafından yükseltilir (yani işleyicileri yok).</span><span class="sxs-lookup"><span data-stu-id="17247-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="17247-326">Bir olayı yükseltme kavramı, olay tarafından temsil edilen temsilciyi çağırmakla tam olarak eşdeğerdir, bu nedenle, olayları yükseltmek için özel bir dil yapısı yoktur.</span><span class="sxs-lookup"><span data-stu-id="17247-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="17247-327">İstemciler *olaylara olay işleyicileri*aracılığıyla tepki verir.</span><span class="sxs-lookup"><span data-stu-id="17247-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="17247-328">Olay işleyicileri `+=` işleç kullanılarak eklenir ve `-=` işleci kullanılarak kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="17247-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="17247-329">Aşağıdaki örnek, bir olay işleyicisi `Changed` `MyList<string>`bir .</span><span class="sxs-lookup"><span data-stu-id="17247-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="17247-330">Bir olayın temel depolama denetiminin istendiği gelişmiş senaryolar için, olay `add` bildirimi `remove` açıkça bir özelliğin `set` erişimine benzeyen bir durum bildirimi sağlayabilir ve erişilenler.</span><span class="sxs-lookup"><span data-stu-id="17247-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="17247-331">İşleçler</span><span class="sxs-lookup"><span data-stu-id="17247-331">Operators</span></span>

<span data-ttu-id="17247-332">*İşleç,* belirli bir ifade işlecinin bir sınıfın örneklerine uygulanmasının anlamını tanımlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="17247-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="17247-333">Üç tür işleç tanımlanabilir: unary işleçleri, ikili işleçler ve dönüşüm işleçleri.</span><span class="sxs-lookup"><span data-stu-id="17247-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="17247-334">Tüm operatörler olarak `public` `static`beyan edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="17247-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="17247-335">Sınıf `MyList<T>` iki işleç `operator ==` bildirir `operator !=`ve bu nedenle bu işleçleri örneklere uygulayan ifadelere `MyList` yeni bir anlam verir.</span><span class="sxs-lookup"><span data-stu-id="17247-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="17247-336">Özellikle, işleçler eşitlik `MyList<T>` yöntemlerini kullanarak içerdiği nesnelerin her birini karşılaştırarak olarak iki örnek eşitliği tanımlar.</span><span class="sxs-lookup"><span data-stu-id="17247-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="17247-337">Aşağıdaki örnek, `==` iki `MyList<int>` örneği karşılaştırmak için işleci kullanır.</span><span class="sxs-lookup"><span data-stu-id="17247-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="17247-338">İki `Console.WriteLine` liste `True` aynı sırada aynı değerlere sahip aynı sayıda nesne içerdiğinden ilk çıktılar.</span><span class="sxs-lookup"><span data-stu-id="17247-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="17247-339">Tanımlanmamış `MyList<T>` `operator ==`olsaydı, `Console.WriteLine` ilk çıktı `False` `a` olurdu `b` çünkü `MyList<int>` ve farklı örnekleri başvurur.</span><span class="sxs-lookup"><span data-stu-id="17247-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="17247-340">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="17247-340">Finalizers</span></span>

<span data-ttu-id="17247-341">*Sonlandırıcı,* bir sınıfın örneğini sonuçlandırmak için gereken eylemleri uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="17247-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="17247-342">Sonlandırıcıların parametreleri olamaz, erişilebilirlik değiştiriciler olamaz ve açıkça çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="17247-342">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="17247-343">Bir örneğin sonlandırıcı, çöp toplama sırasında otomatik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="17247-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="17247-344">Çöp toplayıcı, nesneleri ne zaman toplayacaklarına ve sonlandırıcıları çalıştırmaya karar verirken geniş enlem lemesine izin verilir.</span><span class="sxs-lookup"><span data-stu-id="17247-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="17247-345">Özellikle, sonlandırıcı çağrılarının zamanlaması belirleyici değildir ve sonlandırıcılar herhangi bir iş parçacığı üzerinde yürütülebilir.</span><span class="sxs-lookup"><span data-stu-id="17247-345">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="17247-346">Bu ve diğer nedenlerle, sınıflar sonlandırıcıları yalnızca başka çözümler mümkün olmadığında uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="17247-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="17247-347">İfade `using` nesne imha için daha iyi bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="17247-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="17247-348">[Önceki](statements.md)
> [Sonraki](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="17247-348">[Previous](statements.md)
[Next](arrays.md)</span></span>
