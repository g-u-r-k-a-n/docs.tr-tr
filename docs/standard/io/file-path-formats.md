---
title: Windows sistemlerinde dosya yolu biçimleri
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: b3510be5d417b555d2db163636eac5ce0c0779e4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "77628052"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="1fd3c-102">Windows sistemlerinde dosya yolu biçimleri</span><span class="sxs-lookup"><span data-stu-id="1fd3c-102">File path formats on Windows systems</span></span>

<span data-ttu-id="1fd3c-103"><xref:System.IO> Ad alanındaki türlerin çoğunun üyeleri, dosya `path` sistemi kaynağına mutlak veya göreli bir yol belirtmenize olanak tanıyan bir parametre içerir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-103">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="1fd3c-104">Bu yol daha sonra [Windows dosya sistemi API'lerine](/windows/desktop/fileio/file-systems)geçirilir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-104">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="1fd3c-105">Bu konu, Windows sistemlerinde kullanabileceğiniz dosya yollarının biçimlerini tartışır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-105">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="1fd3c-106">Geleneksel DOS yolları</span><span class="sxs-lookup"><span data-stu-id="1fd3c-106">Traditional DOS paths</span></span>

<span data-ttu-id="1fd3c-107">Standart bir DOS yolu üç bileşenden oluşabilir:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-107">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="1fd3c-108">Bir ses veya sürücü harfi ardından`:`birim ayırıcı ( ).</span><span class="sxs-lookup"><span data-stu-id="1fd3c-108">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="1fd3c-109">Dizin adı.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-109">A directory name.</span></span> <span data-ttu-id="1fd3c-110">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) iç içe gelen dizin hiyerarşisi içindeki alt dizinleri ayırır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-110">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="1fd3c-111">İsteğe bağlı dosya adı.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-111">An optional filename.</span></span> <span data-ttu-id="1fd3c-112">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) dosya yolunu ve dosya adını ayırır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-112">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="1fd3c-113">Üç bileşenin tümü de varsa, yol mutlaktır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-113">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="1fd3c-114">Ses veya sürücü harfi belirtilmemişse ve dizin adı [dizin ayırıcı karakteriyle](<xref:System.IO.Path.DirectorySeparatorChar>)başlarsa, yol geçerli sürücünün kökünden göreli olur.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-114">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="1fd3c-115">Aksi takdirde, yol geçerli dizine göredir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-115">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="1fd3c-116">Aşağıdaki tabloda bazı olası dizin ve dosya yolları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-116">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="1fd3c-117">Yol</span><span class="sxs-lookup"><span data-stu-id="1fd3c-117">Path</span></span>  |<span data-ttu-id="1fd3c-118">Açıklama</span><span class="sxs-lookup"><span data-stu-id="1fd3c-118">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="1fd3c-119">C sürücüsünün kökünden mutlak bir dosya yolu:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-119">An absolute file path from the root of drive C:</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="1fd3c-120">Geçerli sürücünün kökünden mutlak bir yol.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-120">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="1fd3c-121">Geçerli dizinin alt dizininde dosyaya göreli bir yol.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-121">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="1fd3c-122">Geçerli dizinin eş olduğu bir dizinde dosyaya göreli bir yol.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-122">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="1fd3c-123">C sürücüsünün kökünden bir dosyaya giden mutlak yol:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-123">An absolute path to a file from the root of drive C:</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="1fd3c-124">C'nin geçerli dizininden göreli bir yol: sürücü.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-124">A relative path from the current directory of the C: drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="1fd3c-125">Son iki yol arasındaki farka dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-125">Note the difference between the last two paths.</span></span> <span data-ttu-id="1fd3c-126">Her ikisi de isteğe bağlı birim belirticisini (C: her iki durumda da) belirtir, ancak ilki belirtilen birimin köküyle başlar, ikincisi ise belirti vermez.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-126">Both specify the optional volume specifier (C: in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="1fd3c-127">Sonuç olarak, ilk sürücü C kök dizininden mutlak bir yoldur:, ikinci sürücü C:.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-127">As result, the first is an absolute path from the root directory of drive C:, whereas the second is a relative path from the current directory of drive C:.</span></span> <span data-ttu-id="1fd3c-128">İlk amaçlanan ikinci formun kullanımı, Windows dosya yollarını içeren hataların ortak bir kaynağıdır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-128">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="1fd3c-129"><xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> Bir dosya yolunun tam olarak nitelikli olup olmadığını (diğer bir şekilde, yol geçerli dizinden bağımsızdır ve geçerli dizin değiştiğinde değişmez) yöntemi çağırarak belirleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-129">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="1fd3c-130">Bu tür bir yolun göreli dizin`.` `..`bölümlerini (ve) içerebileceğini ve çözümlenmiş yolun her zaman aynı konumu işaret ediyorsa tam olarak nitelikli olabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-130">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="1fd3c-131">Aşağıdaki örnekte mutlak ve göreli yollar arasındaki fark gösterin.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-131">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="1fd3c-132">D:\FY2018\ dizininin var olduğunu ve D:\ için geçerli bir dizini ayarlamadığınızı varsayar. örneği çalıştırmadan önce komut isteminden.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-132">It assumes that the directory D:\FY2018\ exists, and that you haven't set any current directory for D:\ from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

[!INCLUDE [localized code comments](../../../includes/code-comments-loc.md)]

## <a name="unc-paths"></a><span data-ttu-id="1fd3c-133">UNC yolları</span><span class="sxs-lookup"><span data-stu-id="1fd3c-133">UNC paths</span></span>

<span data-ttu-id="1fd3c-134">Ağ kaynaklarına erişmek için kullanılan evrensel adlandırma kuralı (UNC) yolları aşağıdaki biçime sahiptir:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-134">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="1fd3c-135">Bir sunucu veya ana bilgisayar adı, hangi tarafından prefaced \\ \\olduğunu .</span><span class="sxs-lookup"><span data-stu-id="1fd3c-135">A server or host name, which is prefaced by \\\\.</span></span> <span data-ttu-id="1fd3c-136">Sunucu adı Bir NetBIOS makine adı veya IP/FQDN adresi olabilir (IPv4 ve v6 desteklenir).</span><span class="sxs-lookup"><span data-stu-id="1fd3c-136">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="1fd3c-137">Ev sahibi adından \\' olarak ayrılan bir paylaşım adı</span><span class="sxs-lookup"><span data-stu-id="1fd3c-137">A share name, which is separated from the host name by \\.</span></span> <span data-ttu-id="1fd3c-138">Birlikte, sunucu ve paylaşım adı hacmini oluşturan.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-138">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="1fd3c-139">Dizin adı.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-139">A directory name.</span></span> <span data-ttu-id="1fd3c-140">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) iç içe gelen dizin hiyerarşisi içindeki alt dizinleri ayırır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-140">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="1fd3c-141">İsteğe bağlı dosya adı.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-141">An optional filename.</span></span> <span data-ttu-id="1fd3c-142">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) dosya yolunu ve dosya adını ayırır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-142">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="1fd3c-143">Unc yollarından bazıları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-143">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="1fd3c-144">Yol</span><span class="sxs-lookup"><span data-stu-id="1fd3c-144">Path</span></span>  |<span data-ttu-id="1fd3c-145">Açıklama</span><span class="sxs-lookup"><span data-stu-id="1fd3c-145">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="1fd3c-146">C kök dizini: sürücü `system07`.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-146">The root directory of the C: drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="1fd3c-147">\\Server2\\Share biriminin \\Test dizinindeki Foo.txt dosyası.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-147">The Foo.txt file in the Test directory of the \\\\Server2\\Share volume.</span></span>|

<span data-ttu-id="1fd3c-148">UNC yolları her zaman tam nitelikli olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-148">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="1fd3c-149">Bunlar göreli dizin segmentleri `..`içerebilir (ve`.` ), ancak bunlar tam nitelikli bir yolun parçası olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-149">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="1fd3c-150">Göreli yolları yalnızca sürücü mektubuna bir UNC yolunu eşleyerek kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-150">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="1fd3c-151">DOS cihaz yolları</span><span class="sxs-lookup"><span data-stu-id="1fd3c-151">DOS device paths</span></span>

<span data-ttu-id="1fd3c-152">Windows işletim sistemi, dosyalar da dahil olmak üzere tüm kaynakları işaret eden birleşik bir nesne modeline sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-152">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="1fd3c-153">Bu nesne yollarına konsol penceresinden erişilebilir ve eski DOS ve UNC yollarının eşlendirilen sembolik bağlantılardan oluşan özel bir klasör aracılığıyla Win32 katmanına maruz kalır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-153">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="1fd3c-154">Bu özel klasöre DOS aygıt yolu sözdizimi aracılığıyla erişilir:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-154">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="1fd3c-155">Sürücüyü sürücü harfiyle tanımlamaya ek olarak, ses GUID'ini kullanarak bir birimi tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-155">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="1fd3c-156">Bu formu alır:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-156">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="1fd3c-157">DOS aygıt yolu sözdizimi,.NET Core 1.1 ve .NET Framework 4.6.2 ile başlayan Windows'da çalışan .NET uygulamalarında desteklenir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-157">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="1fd3c-158">DOS aygıt yolu aşağıdaki bileşenlerden oluşur:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-158">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="1fd3c-159">Yolu DOS aygıt`\\.\` yolu `\\?\`olarak tanımlayan aygıt yolu belirtici (veya),</span><span class="sxs-lookup"><span data-stu-id="1fd3c-159">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="1fd3c-160">.NET `\\?\` Core'un tüm sürümlerinde ve .NET Framework sürümü4.6.2 ile başlayan tüm sürümlerde desteklenir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-160">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="1fd3c-161">"Gerçek" aygıt nesnesine sembolik bir bağlantı (C: bir sürücü adı durumunda veya Volume{b75e2c83-0000-0000-602f00000000} bir ses GUID durumunda).</span><span class="sxs-lookup"><span data-stu-id="1fd3c-161">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="1fd3c-162">DoS aygıt yolunun aygıt yolu belirticiden sonraki ilk bölümü ses düzeyini veya sürücüyü tanımlar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-162">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="1fd3c-163">(Örneğin, `\\?\C:\` ve `\\.\BootPartition\`.)</span><span class="sxs-lookup"><span data-stu-id="1fd3c-163">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="1fd3c-164">Uncs için, şaşırtıcı değil, denir belirli bir `UNC`bağlantı vardır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-164">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="1fd3c-165">Örnek:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-165">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="1fd3c-166">Aygıt UNC'leri için sunucu/paylaşım bölümü hacmi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-166">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="1fd3c-167">Örneğin, `\\?\server1\e:\utilities\\filecomparer\`sunucu/paylaşım bölümünde server1\utilities olduğunu.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-167">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is server1\utilities.</span></span> <span data-ttu-id="1fd3c-168">Bu, göreli dizin <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> segmentleri gibi bir yöntemi ararken önemlidir; hacmi geçmek hiçbir zaman mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-168">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="1fd3c-169">DOS cihaz yolları tanımı gereği tamamen niteliklidir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-169">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="1fd3c-170">Göreli dizin`.` bölümlerine ( ve `..`) izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-170">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="1fd3c-171">Geçerli dizinler hiçbir zaman kullanımlarına girmez.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-171">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="1fd3c-172">Örnek: Aynı dosyaya başvurma yolları</span><span class="sxs-lookup"><span data-stu-id="1fd3c-172">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="1fd3c-173">Aşağıdaki örnek, <xref:System.IO> ad alanında API'leri kullanırken bir dosyaya başvurma yollarından bazılarını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-173">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="1fd3c-174">Örnek, bir <xref:System.IO.FileInfo> nesneyi anında kullanır <xref:System.IO.FileInfo.Name> <xref:System.IO.FileInfo.Length> ve dosya adını ve dosyanın uzunluğunu görüntülemek için nesneyi ve özelliklerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-174">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="1fd3c-175">Yol normalleştirme</span><span class="sxs-lookup"><span data-stu-id="1fd3c-175">Path normalization</span></span>

<span data-ttu-id="1fd3c-176">Windows API'lerine geçirilen yolların hemen hemen hepsi normalleştirildi.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-176">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="1fd3c-177">Normalleştirme sırasında, Windows aşağıdaki adımları gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-177">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="1fd3c-178">Yolu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-178">Identifies the path.</span></span>
- <span data-ttu-id="1fd3c-179">Geçerli dizini kısmen nitelikli (göreli) yollara uygular.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-179">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="1fd3c-180">Canonicalizes bileşen ve dizin ayırıcıları.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-180">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="1fd3c-181">Göreli dizin bileşenlerini (geçerli`.` dizin ve `..` üst dizini için) değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-181">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="1fd3c-182">Belirli karakterleri kırpar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-182">Trims certain characters.</span></span>

<span data-ttu-id="1fd3c-183">Bu normalleştirme örtülü olarak gerçekleşir, ancak <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> [getfullpathname() işlevine](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)bir çağrı yıstıran yöntemi arayarak bunu açıkça yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-183">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="1fd3c-184">Windows [GetFullPathName() işlevini](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) doğrudan P/Invoke kullanarak da arayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-184">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identifying-the-path"></a><span data-ttu-id="1fd3c-185">Yolu tanımlama</span><span class="sxs-lookup"><span data-stu-id="1fd3c-185">Identifying the path</span></span>

<span data-ttu-id="1fd3c-186">Yol normalleştirmedeki ilk adım, yol türünü tanımlamaktır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-186">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="1fd3c-187">Yollar birkaç kategoriden birine girer:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-187">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="1fd3c-188">Bunlar cihaz yollarıdır; diğer bir şey, onlar iki ayırıcı ve bir`\\?` `\\.`soru işareti veya dönem (veya) ile başlar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-188">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="1fd3c-189">Bunlar UNC yolları; diğer bir soru işareti veya dönem olmadan iki ayırıcı ile başlar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-189">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="1fd3c-190">Onlar tam nitelikli DOS yolları vardır; diğer bir şey, bir sürücü harfi, bir birim ayırıcı`C:\`ve bir bileşen ayırıcı ( ) ile başlar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-190">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="1fd3c-191">Eski bir aygıt`CON`belirlerler ( , `LPT1`).</span><span class="sxs-lookup"><span data-stu-id="1fd3c-191">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="1fd3c-192">Bunlar geçerli sürücünün köküne göredir; yani, tek bir bileşen ayırıcı`\`( ) ile başlar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-192">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="1fd3c-193">Bunlar, belirli bir sürücünün geçerli dizine göredir; diğer bir şey, bir sürücü harfi, bir birim ayırıcı`C:`ve hiçbir bileşen ayırıcı ( ) ile başlar.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-193">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="1fd3c-194">Bunlar geçerli dizine göredir; başka bir şey ile başlar`temp\testfile.txt`( ).</span><span class="sxs-lookup"><span data-stu-id="1fd3c-194">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="1fd3c-195">Yol türü, geçerli bir dizinin bir şekilde uygulanıp uygulanmayacağını belirler.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-195">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="1fd3c-196">Ayrıca yolun "kök" ne olduğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-196">It also determines what the "root" of the path is.</span></span>

### <a name="handling-legacy-devices"></a><span data-ttu-id="1fd3c-197">Eski aygıtları işleme</span><span class="sxs-lookup"><span data-stu-id="1fd3c-197">Handling legacy devices</span></span>

<span data-ttu-id="1fd3c-198">`CON`Yol, önceden `COM1` `LPT1`bekletilip `\\.\` döndürülerek bir aygıt yoluna dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-198">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="1fd3c-199">Eski bir aygıt adı ile başlayan bir yol, <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> yöntemtarafından her zaman eski bir aygıt olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-199">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="1fd3c-200">Örneğin, DOS aygıt yolu `CON.TXT` `\\.\CON`için , ve DOS `COM1.TXT\file1.txt` `\\.\COM1`aygıt yolu için .</span><span class="sxs-lookup"><span data-stu-id="1fd3c-200">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="applying-the-current-directory"></a><span data-ttu-id="1fd3c-201">Geçerli dizini uygulama</span><span class="sxs-lookup"><span data-stu-id="1fd3c-201">Applying the current directory</span></span>

<span data-ttu-id="1fd3c-202">Bir yol tam olarak nitelikli değilse, Windows geçerli dizini uygular.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-202">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="1fd3c-203">UNC'ler ve aygıt yolları geçerli dizin uygulanmaz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-203">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="1fd3c-204">Ne ayırıcı C ile tam\\bir sürücü yok: .</span><span class="sxs-lookup"><span data-stu-id="1fd3c-204">Neither does a full drive with separator C:\\.</span></span>

<span data-ttu-id="1fd3c-205">Yol tek bir bileşen ayırıcısıyla başlarsa, geçerli dizinden gelen sürücü uygulanır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-205">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="1fd3c-206">Örneğin, dosya yolu ve `\utilities` geçerli dizin `C:\temp\`ise, normalleştirme üretir. `C:\utilities`</span><span class="sxs-lookup"><span data-stu-id="1fd3c-206">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="1fd3c-207">Yol bir sürücü harfi, birim ayırıcısı ve bileşen ayırıcısı ile başlarsa, belirtilen sürücü için komut kabuğundan son geçerli dizin kümesi uygulanır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-207">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="1fd3c-208">Son geçerli dizini ayarlanmadıysa, sürücü tek başına uygulanır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-208">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="1fd3c-209">Örneğin, dosya `D:sources`yolu , geçerli dizin `C:\Documents\`, ve sürücü D son geçerli `D:\sources\`dizini: `D:\sources\sources`oldu , sonuç .</span><span class="sxs-lookup"><span data-stu-id="1fd3c-209">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="1fd3c-210">Bu "sürücü göreli" yolları program ve komut dosyası mantık hataları ortak bir kaynaktır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-210">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="1fd3c-211">Bir harf ve iki nokta üst üste başlayan bir yolun göreceli olmadığını varsayarsak doğru değildir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-211">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="1fd3c-212">Yol ayırıcıdan başka bir şeyle başlarsa, geçerli sürücü ve geçerli dizin uygulanır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-212">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="1fd3c-213">Örneğin, yol ve `filecompare` geçerli dizin ise, `C:\utilities\`sonuç `C:\utilities\filecompare\`.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-213">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1fd3c-214">Geçerli dizin işlem başına bir ayar olduğundan, çok iş parçacığı uygulamaları (yani, çoğu uygulamalar) göreli yollar tehlikelidir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-214">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="1fd3c-215">Herhangi bir iş parçacığı geçerli dizini herhangi bir zamanda değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-215">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="1fd3c-216">.NET Core 2.1 ile başlayarak, göreli bir yoldan mutlak bir yol ve çözümlemek istediğiniz temel yoldan (geçerli dizin) mutlak bir yol almak için <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> yöntemi arayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-216">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalizing-separators"></a><span data-ttu-id="1fd3c-217">Kanonihale ayırıcılar</span><span class="sxs-lookup"><span data-stu-id="1fd3c-217">Canonicalizing separators</span></span>

<span data-ttu-id="1fd3c-218">Tüm ileri eğik çizgiler (`/`) standart Windows ayırıcı,`\`arka eğik çizgi ( dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-218">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="1fd3c-219">Varsa, ilk iki kesikleri izleyen bir dizi kesik tek bir kesik halinde çökertilir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-219">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluating-relative-components"></a><span data-ttu-id="1fd3c-220">Bağıl bileşenlerin değerlendirilmesi</span><span class="sxs-lookup"><span data-stu-id="1fd3c-220">Evaluating relative components</span></span>

<span data-ttu-id="1fd3c-221">Yol işlenirken, tek veya çift periyotlu (veya)`.` oluşan bileşenler `..`veya segmentler değerlendirilir:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-221">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="1fd3c-222">Geçerli dizine atıfta bulunduğundan, tek bir dönem için geçerli kesim kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-222">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="1fd3c-223">Çift dönem için, çift dönem üst dizine atıfta bulunduğundan, geçerli kesim ve üst kesim kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-223">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="1fd3c-224">Üst dizinler yalnızca yolun kökünü geçmiyorsa kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-224">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="1fd3c-225">Yolun kökü yolun türüne bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-225">The root of the path depends on the type of path.</span></span> <span data-ttu-id="1fd3c-226">DOS yolları`C:\`için sürücü ( ) ( ) UNC'ler için sunucu/paylaşım (`\\Server\Share`),`\\?\` `\\.\`ve aygıt yolları için aygıt yolu önekidir ( veya ).</span><span class="sxs-lookup"><span data-stu-id="1fd3c-226">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trimming-characters"></a><span data-ttu-id="1fd3c-227">Karakterleri kırpma</span><span class="sxs-lookup"><span data-stu-id="1fd3c-227">Trimming characters</span></span>

<span data-ttu-id="1fd3c-228">Ayırıcıların ve daha önce kaldırılan göreli kesimlerin çalıştırmalarıyla birlikte, normalleştirme sırasında bazı ek karakterler kaldırılır:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-228">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="1fd3c-229">Bir kesim tek bir dönemde sona ererse, bu dönem kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-229">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="1fd3c-230">(Bir önceki adımda tek veya çift periyot lu bir kesim normale döndürültürür.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-230">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="1fd3c-231">Üç veya daha fazla dönemden oluşan bir kesim normalleştirilemez ve aslında geçerli bir dosya/dizin adıdır.)</span><span class="sxs-lookup"><span data-stu-id="1fd3c-231">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="1fd3c-232">Yol bir ayırıcıda bitmiyorsa, tüm son daki dönemler ve boşluklar (U+0020) kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-232">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="1fd3c-233">Son kesim yalnızca tek veya çift dönemse, yukarıdaki göreli bileşenler kuralına girer.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-233">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="1fd3c-234">Bu kural, boşluktan sonra bir iz ayırıcı ekleyerek bir dizin adı oluşturabileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-234">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="1fd3c-235">Hiçbir **zaman** bir dizin veya dosya adı ile bir izleme alanı ile oluşturmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-235">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="1fd3c-236">İzleyen boşluklar bir dizine erişmemi zorlaştırabilir veya imkansız hale getirebilir ve uygulamalar genellikle dizinleri veya adları sondaki boşlukları içeren dosyaları işlemeye çalışırken başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-236">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skipping-normalization"></a><span data-ttu-id="1fd3c-237">Normalleştirme atlama</span><span class="sxs-lookup"><span data-stu-id="1fd3c-237">Skipping normalization</span></span>

<span data-ttu-id="1fd3c-238">Normalde, Windows API'sine geçirilen herhangi bir yol (etkili bir şekilde) [GetFullPathName işlevine](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) aktarılır ve normale aktarılır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-238">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="1fd3c-239">Önemli bir özel durum vardır: dönem yerine soru işaretiyle başlayan aygıt yolu.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-239">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="1fd3c-240">Yol tam olarak `\\?\` (kanonik geri tepme nin kullanımına dikkat edin) ile başlamadıkça, normalleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-240">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="1fd3c-241">Neden normalleşmeyi atlamak isteyesin ki?</span><span class="sxs-lookup"><span data-stu-id="1fd3c-241">Why would you want to skip normalization?</span></span> <span data-ttu-id="1fd3c-242">Üç temel nedeni vardır:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-242">There are three major reasons:</span></span>

1. <span data-ttu-id="1fd3c-243">Normalde kullanılamayan ancak yasal olan yollara erişmek için.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-243">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="1fd3c-244">Örneğin, başka bir `hidden.`şekilde erişilen bir dosya veya dizin mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-244">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="1fd3c-245">Zaten normale döndüyseniz normalleştirmeyi atlayarak performansı artırmak için.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-245">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="1fd3c-246">Yalnızca .NET Framework'de, `MAX_PATH` 259 karakterden büyük yollara izin vermek için yol uzunluğunu denetlemeyi atlamak için.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-246">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="1fd3c-247">Çoğu API'ler, bazı istisnalar dışında buna izin verir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-247">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="1fd3c-248">.NET Core uzun yolları örtülü olarak işler `MAX_PATH` ve bir denetim gerçekleştirmez.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-248">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="1fd3c-249">Çek `MAX_PATH` yalnızca .NET Framework için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-249">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="1fd3c-250">Normalleştirme ve maksimum yol denetimleri atlama iki aygıt yolu sözdizimi arasındaki tek fark; aksi takdirde aynıdır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-250">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="1fd3c-251">"Normal" uygulamalarla başa çıkmak için kolayca zor yollar oluşturabileceğinizden, normalleştirmeyi atlayarak dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-251">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="1fd3c-252">`\\?\` [GetFullPathName işlevine](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)açıkça geçerseniz, yollar hala normalize edilir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-252">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="1fd3c-253">[GetFullPathName'e](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) `MAX_PATH` karakterden daha fazla yol `\\?\`iletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-253">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="1fd3c-254">Windows'un işleyebilir maksimum dize boyutuna kadar rasgele uzunluk yolları destekler.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-254">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="1fd3c-255">Büyük/küçük harf ve Windows dosya sistemi</span><span class="sxs-lookup"><span data-stu-id="1fd3c-255">Case and the Windows file system</span></span>

<span data-ttu-id="1fd3c-256">Windows dosya sisteminin Windows olmayan kullanıcılarının ve geliştiricilerin kafa karıştırıcı bulduğu bir özelliği, yol ve dizin adlarının büyük/küçük harf duyarsız olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-256">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="1fd3c-257">Diğer bir arada, dizin ve dosya adları oluşturulduklarında kullanılan dizelerin kasasını yansıtır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-257">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="1fd3c-258">Örneğin, yöntem arama</span><span class="sxs-lookup"><span data-stu-id="1fd3c-258">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="1fd3c-259">TeStDiReCtOrY adında bir dizin oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-259">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="1fd3c-260">Bir dizin veya dosyayı büyük/küçük harf değiştirmek için yeniden adlarsanız, dizin veya dosya adı yeniden adlandırdığınızda kullanılan dizenin büyük/küçük harflerini yansıtır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-260">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="1fd3c-261">Örneğin, aşağıdaki kod test.txt adlı bir dosyayı Test.txt olarak yeniden adlandırır:</span><span class="sxs-lookup"><span data-stu-id="1fd3c-261">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="1fd3c-262">Ancak, dizin ve dosya adı karşılaştırmaları büyük/küçük harf duyarsızdır.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-262">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="1fd3c-263">"test.txt" adlı bir dosyayı ararsanız, .NET dosya sistemi API'leri karşılaştırmada durumu yoksayılsın.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-263">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="1fd3c-264">Test.txt, TEST. TXT, test edin. TXT ve alt ve küçük harflerin diğer kombinasyonları "test.txt" ile eşleşir.</span><span class="sxs-lookup"><span data-stu-id="1fd3c-264">Test.txt, TEST.TXT, test.TXT, and any other combination of upper- and lowercase letters will match "test.txt".</span></span>
