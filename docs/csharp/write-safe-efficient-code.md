---
title: Güvenli ve verimli C# kod yazma
description: C# Dilde en son geliştirmeler, daha önce güvenli olmayan kodla ilişkili olan doğrulanabilir güvenli kod yazmanızı sağlar.
ms.date: 10/23/2018
ms.custom: mvc
ms.openlocfilehash: 89a0bcf28c3c398865082e120ca9c16fe2c00651
ms.sourcegitcommit: 9b2ef64c4fc10a4a10f28a223d60d17d7d249ee8
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/26/2019
ms.locfileid: "72960836"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="d30d3-103">Güvenli ve verimli C# kod yazma</span><span class="sxs-lookup"><span data-stu-id="d30d3-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="d30d3-104">' Deki C# yeni özellikler daha iyi performansa sahip doğrulanabilir güvenli kod yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="d30d3-105">Bu teknikleri dikkatle uygularsanız, daha az senaryo güvenli olmayan kod gerektirir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="d30d3-106">Bu özellikler, yöntem bağımsız değişkenleri olarak değer türlerine yapılan başvuruların kullanımını kolaylaştırır ve yöntemi döndürür.</span><span class="sxs-lookup"><span data-stu-id="d30d3-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="d30d3-107">Güvenli bir şekilde bitince, bu teknikler kopyalama değer türlerini en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="d30d3-108">Değer türlerini kullanarak, ayırma sayısını ve çöp toplama geçişlerini en aza indirmiş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="d30d3-109">Bu makaledeki örnek kodun çoğu 7,2 ' de C# eklenen özellikleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="d30d3-110">Bu özellikleri kullanmak için, projenizi 7,2 veya sonraki bir sürümü kullanacak C# şekilde yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="d30d3-111">Dil sürümünü ayarlama hakkında daha fazla bilgi için bkz. [dil sürümünü yapılandırma](language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="d30d3-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="d30d3-112">Bu makalede, verimli kaynak yönetimine yönelik teknikler ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="d30d3-113">Değer türlerini kullanmanın bir avantajı genellikle yığın ayırmaların önlerinden kaçınmaktır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="d30d3-114">Dezavantajı, değere göre kopyalanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="d30d3-115">Bu zorunluluğunu getirir, büyük miktarlarda veri üzerinde çalışan algoritmaların iyileştirmesini zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-115">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="d30d3-116">C# 7,2 sürümündeki yeni dil özellikleri, değer türlerine başvurular kullanarak güvenli verimli kod etkinleştiren mekanizmalar sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="d30d3-117">Her iki ayırma ve kopyalama işlemini en aza indirmek için bu özellikleri daha seyrek kullanın.</span><span class="sxs-lookup"><span data-stu-id="d30d3-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="d30d3-118">Bu makalede bu yeni özellikler incelenmektedir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-118">This article explores those new features.</span></span>

<span data-ttu-id="d30d3-119">Bu makalede aşağıdaki kaynak yönetimi teknikleri ele alınmaktadır:</span><span class="sxs-lookup"><span data-stu-id="d30d3-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="d30d3-120">Bir türün **sabit** olduğunu ifade etmek için bir [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) bildirin ve [`in`](language-reference/keywords/in-parameter-modifier.md) parametreleri kullanılırken derleyicinin kopyaları kaydetmesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-120">Declare a [`readonly struct`](language-reference/keywords/readonly.md#readonly-struct-example) to express that a type is **immutable** and enables the compiler to save copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="d30d3-121">Bir tür sabit olamaz, üyenin durumu değiştirmediğini göstermek için `struct` üyeleri `readonly` bildirin.</span><span class="sxs-lookup"><span data-stu-id="d30d3-121">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="d30d3-122">Dönüş değeri <xref:System.IntPtr.Size?displayProperty=nameWithType> daha büyük bir `struct` olduğunda ve depolama ömrü değeri döndüren yöntemden daha büyük olduğunda bir [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) dönüşü kullanın.</span><span class="sxs-lookup"><span data-stu-id="d30d3-122">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="d30d3-123">`readonly struct` boyutu <xref:System.IntPtr.Size?displayProperty=nameWithType>daha büyük olduğunda, performans nedenleriyle bunu bir `in` parametresi olarak geçirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-123">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="d30d3-124">`readonly` değiştiricisi ile bildirilemediği veya yöntem yalnızca yapının `readonly` üyelerini çağırdığı sürece bir `struct` `in` parametresi olarak geçirmeyin.</span><span class="sxs-lookup"><span data-stu-id="d30d3-124">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="d30d3-125">Bu kılavuzun ihlal olması, performansı olumsuz etkileyebilir ve bu da belirsiz bir davranışa yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-125">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="d30d3-126">Bellekle bir bayt dizisi olarak çalışmak için [`ref struct`](language-reference/keywords/ref.md#ref-struct-types)veya <xref:System.Span%601> ya da <xref:System.ReadOnlySpan%601> gibi bir `readonly ref struct` kullanın.</span><span class="sxs-lookup"><span data-stu-id="d30d3-126">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="d30d3-127">Bu teknikler, **başvuru** ve **değer**açısından birbiriyle rekabet eden iki hedefi dengelemenize zorlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-127">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="d30d3-128">[Başvuru türleri](programming-guide/types/index.md#reference-types) olan değişkenler bellekteki konuma bir başvuru tutar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-128">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="d30d3-129">[Değer türleri](programming-guide/types/index.md#value-types) olan değişkenler doğrudan değerlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-129">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="d30d3-130">Bu farklılıklar, bellek kaynaklarını yönetmek için önemli olan önemli farklılıkları vurgulamaktadır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-130">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="d30d3-131">**Değer türleri** genellikle bir yönteme geçirildiğinde veya bir yöntemden döndürüldüğünde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-131">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="d30d3-132">Bu davranış, bir değer türünün üyelerini çağırırken `this` değerini kopyalamayı içerir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-132">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="d30d3-133">Kopyanın maliyeti, türün boyutuyla ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-133">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="d30d3-134">**Başvuru türleri** yönetilen yığında ayrılır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-134">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="d30d3-135">Her yeni bir nesne için yeni bir ayırma gerekir ve ardından geri kazanılır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-135">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="d30d3-136">Bu işlemlerin her ikisi de zaman alır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-136">Both these operations take time.</span></span> <span data-ttu-id="d30d3-137">Başvuru, bir yönteme bir bağımsız değişken olarak geçirildiğinde veya bir yöntemden döndürüldüğünde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-137">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="d30d3-138">Bu makalede, bu önerileri açıklamak için 3B nokta yapısının aşağıdaki örnek kavramı kullanılmaktadır:</span><span class="sxs-lookup"><span data-stu-id="d30d3-138">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="d30d3-139">Farklı örnekler bu kavramın farklı uygulamalarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-139">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="d30d3-140">Değişmez değer türleri için salt okunur yapılar bildirme</span><span class="sxs-lookup"><span data-stu-id="d30d3-140">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="d30d3-141">`readonly` değiştiricisini kullanarak bir `struct` bildirmek, derleyiciye sabit bir tür oluşturmak için olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-141">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="d30d3-142">Derleyici, aşağıdaki kurallarla bu tasarım kararı uygular:</span><span class="sxs-lookup"><span data-stu-id="d30d3-142">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="d30d3-143">Tüm alan üyeleri `readonly` olmalıdır</span><span class="sxs-lookup"><span data-stu-id="d30d3-143">All field members must be `readonly`</span></span>
- <span data-ttu-id="d30d3-144">Otomatik uygulanan özellikler dahil olmak üzere tüm özellikler salt okunabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-144">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="d30d3-145">Bu iki kural, bir `readonly struct` üyesinin bu yapının durumunu değiştirmemesini sağlamak için yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-145">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="d30d3-146">`struct` sabittir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-146">The `struct` is immutable.</span></span> <span data-ttu-id="d30d3-147">`Point3D` yapısı, aşağıdaki örnekte gösterildiği gibi sabit bir yapı olarak tanımlanabilir:</span><span class="sxs-lookup"><span data-stu-id="d30d3-147">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="d30d3-148">Tasarım amacınızda sabit değer türü oluşturmak her seferinde bu öneriyi izleyin.</span><span class="sxs-lookup"><span data-stu-id="d30d3-148">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="d30d3-149">Tüm performans geliştirmeleri, ek bir avantajdır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-149">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="d30d3-150">`readonly struct` tasarım amacınızı açıkça ifade eder.</span><span class="sxs-lookup"><span data-stu-id="d30d3-150">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="d30d3-151">Bir yapı sabit olamaz, salt okunur Üyeler bildirin</span><span class="sxs-lookup"><span data-stu-id="d30d3-151">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="d30d3-152">C# 8,0 ve sonraki sürümlerde, bir struct türü değişebilir olduğunda,`readonly`bir şekilde olmasına neden olmayan Üyeler bildirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-152">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="d30d3-153">Örneğin, aşağıda 3B nokta yapısının değişebilir bir çeşitlemesi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="d30d3-153">For example, the following is a mutable variation of the 3D point structure:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    private double _x;
    public double X 
    { 
        readonly get { return _x;}; 
        set { _x = value; }
    }
    
    private double _y;
    public double Y 
    { 
        readonly get { return _y;}; 
        set { _y = value; }
    }

    private double _z;
    public double Z 
    { 
        readonly get { return _z;}; 
        set { _z = value; }
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X, Y, Z }";
}
```

<span data-ttu-id="d30d3-154">Yukarıdaki örnek, `readonly` değiştiricisini uygulayabileceğiniz konumların çoğunu gösterir: Yöntemler, Özellikler ve özellik erişimcileri.</span><span class="sxs-lookup"><span data-stu-id="d30d3-154">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="d30d3-155">Otomatik uygulanan özellikler kullanırsanız, derleyici, okuma-yazma özellikleri için `get` erişimcisine `readonly` değiştiricisini ekler.</span><span class="sxs-lookup"><span data-stu-id="d30d3-155">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="d30d3-156">Derleyici, `readonly` değiştiricisini yalnızca bir `get` erişimcisi olan özellikler için otomatik uygulanan özellik bildirimlerine ekler.</span><span class="sxs-lookup"><span data-stu-id="d30d3-156">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="d30d3-157">`readonly` değiştiricisini bulunmamalıdır olmayan üyelere eklemek, iki ilgili avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-157">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="d30d3-158">İlk olarak, derleyici amacınızı zorluyor.</span><span class="sxs-lookup"><span data-stu-id="d30d3-158">First, the compiler enforces your intent.</span></span> <span data-ttu-id="d30d3-159">Bu üye yapının durumunu veya `readonly`de işaretlenmemiş bir üyeye erişim sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-159">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="d30d3-160">İkincisi, derleyici bir `readonly` üyesine erişirken `in` parametrelerinin savunma kopyalarını oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-160">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="d30d3-161">Derleyici, `struct` bir `readonly` üyesi tarafından değiştirilmediğini garanti ettiğinden, bu iyileştirmesi güvenli hale getirir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-161">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="d30d3-162">Mümkün olduğunda büyük yapılar için `ref readonly return` deyimlerini kullanın</span><span class="sxs-lookup"><span data-stu-id="d30d3-162">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="d30d3-163">Döndürülmekte olan değer döndürülen yönteme yerel olmadığında, değerleri başvuruya göre döndürebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-163">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="d30d3-164">Başvuruya göre döndürme, yapıyı değil yalnızca başvurunun kopyalandığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-164">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="d30d3-165">Aşağıdaki örnekte, döndürülen değer yerel bir değişken olduğundan, `Origin` özelliği bir `ref` dönüşü kullanamaz:</span><span class="sxs-lookup"><span data-stu-id="d30d3-165">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="d30d3-166">Ancak, döndürülen değer statik bir üye olduğu için aşağıdaki özellik tanımı başvuru ile döndürülebilir:</span><span class="sxs-lookup"><span data-stu-id="d30d3-166">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="d30d3-167">Çağıranların kaynağı değiştirmesini istemezsiniz, bu yüzden değeri `readonly ref`döndürmelidir:</span><span class="sxs-lookup"><span data-stu-id="d30d3-167">You don't want callers modifying the origin, so you should return the value by `readonly ref`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="d30d3-168">`ref readonly` döndürmek, daha büyük yapıları kopyalamayı ve iç veri üyelerinizin dengeszlik durumunu korumanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-168">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="d30d3-169">Çağıran sitede, arayanlar `Origin` özelliğini `readonly ref` veya bir değer olarak kullanma seçeneğini yapar:</span><span class="sxs-lookup"><span data-stu-id="d30d3-169">At the call site, callers make the choice to use the `Origin` property as a `readonly ref` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="d30d3-170">Yukarıdaki koddaki ilk atama `Origin` sabitinin bir kopyasını oluşturur ve bu kopyayı atar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-170">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="d30d3-171">İkincisi bir başvuru atar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-171">The second assigns a reference.</span></span> <span data-ttu-id="d30d3-172">`readonly` değiştiricinin, değişkenin bildiriminin bir parçası olması gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="d30d3-172">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="d30d3-173">Başvurduğu başvuru değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-173">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="d30d3-174">Bunun için denemeler, derleme zamanı hatasına neden olacak.</span><span class="sxs-lookup"><span data-stu-id="d30d3-174">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="d30d3-175">`readonly` değiştiricisi `originReference`bildiriminde gereklidir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-175">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="d30d3-176">Derleyici, çağıranın başvuruyu değiştiremiyorum.</span><span class="sxs-lookup"><span data-stu-id="d30d3-176">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="d30d3-177">Değer atama denemeleri doğrudan derleme zamanı hatası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="d30d3-177">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="d30d3-178">Ancak derleyici, herhangi bir üye yönteminin yapının durumunu değiştirmediğini bilmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-178">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="d30d3-179">Nesnenin değiştirilmediğinden emin olmak için, derleyici bir kopya oluşturur ve bu kopyayı kullanarak üye başvuruları çağırır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-179">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="d30d3-180">Tüm değişiklikler, savunma kopyasına göre yapılır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-180">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="d30d3-181">`in` değiştiricisini `System.IntPtr.Size` daha büyük `readonly struct` parametrelere uygulayın</span><span class="sxs-lookup"><span data-stu-id="d30d3-181">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="d30d3-182">`in` anahtar sözcüğü, değişkenleri başvuruya göre geçirmek için mevcut `ref` ve `out` anahtar sözcüklerini tamamlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-182">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="d30d3-183">`in` anahtar sözcüğü, bağımsız değişkeni başvuruya göre geçirmeyi belirtir, ancak çağrılan yöntem değeri değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-183">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="d30d3-184">Bu ek, tasarım amacınızı ifade etmek için tam bir sözlük sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-184">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="d30d3-185">Değer türleri, yöntem imzasında Aşağıdaki değiştiricilerin hiçbirini belirtmezseniz, çağrılan bir yönteme geçirildiğinde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-185">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="d30d3-186">Bu değiştiricilerin her biri, bir değişkenin başvuruya göre geçtiğini belirtir ve kopyalama önlenir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-186">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="d30d3-187">Her değiştirici farklı bir amacı ifade eder:</span><span class="sxs-lookup"><span data-stu-id="d30d3-187">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="d30d3-188">`out`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-188">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="d30d3-189">`ref`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-189">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="d30d3-190">`in`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-190">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="d30d3-191">Bir bağımsız değişkeni başvuruya göre geçirmek için `in` değiştiricisini ekleyin ve gereksiz kopyalama olmaması için bağımsız değişkenleri başvuruya göre iletmek üzere tasarım amacınızı bildirin.</span><span class="sxs-lookup"><span data-stu-id="d30d3-191">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="d30d3-192">Bu bağımsız değişken olarak kullanılan nesneyi değiştirmeyi düşünmüyorsanız.</span><span class="sxs-lookup"><span data-stu-id="d30d3-192">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="d30d3-193">Bu uygulama genellikle <xref:System.IntPtr.Size?displayProperty=nameWithType>daha büyük salt okunur değer türleri için performansı geliştirir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-193">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d30d3-194">Basit türler (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` ve `bool`ve `enum` türleri) için , olası performans kazançları en düşük düzeydedir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-194">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="d30d3-195">Aslında, <xref:System.IntPtr.Size?displayProperty=nameWithType>' den küçük türler için doğrudan başvuru aracılığıyla performans düşebilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-195">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="d30d3-196">Aşağıdaki kod, 3B alanda iki işaret arasındaki mesafeyi hesaplayan bir yöntem örneği gösterir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-196">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="d30d3-197">Bağımsız değişkenler, her biri üç Double içeren iki yapıya sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-197">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="d30d3-198">Çift 8 bayttır, bu nedenle her bağımsız değişken 24 bayttır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-198">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="d30d3-199">`in` değiştiricisini belirterek, makinenin mimarisine bağlı olarak bu bağımsız değişkenlere 4 baytlık veya 8 baytlık bir başvuru geçirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-199">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="d30d3-200">Boyut farkı küçüktür, ancak uygulamanız bu yöntemi birçok farklı değer kullanarak sıkı bir döngüde çağırdığında ekler.</span><span class="sxs-lookup"><span data-stu-id="d30d3-200">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="d30d3-201">`in` değiştirici `out` ve `ref` başka yollarla da tamamlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-201">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="d30d3-202">Yalnızca `in`, `out`veya `ref`varlığı farklı olan bir yöntemin aşırı yüklerini oluşturamazsınız.</span><span class="sxs-lookup"><span data-stu-id="d30d3-202">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="d30d3-203">Bu yeni kurallar, `out` ve `ref` parametreleri için her zaman tanımlanan davranışı genişletir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-203">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="d30d3-204">`out` ve `ref` değiştiricilerine benzer şekilde, `in` değiştiricisi uygulandığından değer türleri paketlenmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-204">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="d30d3-205">`in` değiştiricisi Parametreler alan herhangi bir üyeye uygulanabilir: Yöntemler, temsilciler, Lambdalar, yerel işlevler, Dizin oluşturucular, işleçler.</span><span class="sxs-lookup"><span data-stu-id="d30d3-205">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="d30d3-206">`in` parametrelerinin başka bir özelliği, bir `in` parametresine bağımsız değişken için değişmez değer veya sabitler kullanbiliriz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-206">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="d30d3-207">Ayrıca, bir `ref` veya `out` parametresinden farklı olarak, çağrı sitesinde `in` değiştiricisini uygulamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-207">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="d30d3-208">Aşağıdaki kod, `CalculateDistance` yöntemini çağırmanın iki örneğini göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-208">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="d30d3-209">İlki, başvuruya göre geçirilen iki yerel değişkeni kullanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-209">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="d30d3-210">İkincisi, yöntem çağrısının bir parçası olarak oluşturulan geçici bir değişken içerir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-210">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="d30d3-211">Derleyicinin `in` bağımsız değişkeninin salt okunurdur yapısını zorladığı çeşitli yollar vardır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-211">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="d30d3-212">İlki, çağrılan yöntem bir `in` parametresine doğrudan atanamaz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-212">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="d30d3-213">Bu değer `struct` bir tür olduğunda, `in` parametresinin hiçbir alanına doğrudan atanamaz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-213">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="d30d3-214">Ayrıca, `ref` veya `out` değiştiricisini kullanarak herhangi bir yönteme `in` parametresi geçirilemez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-214">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="d30d3-215">Bu kurallar, `in` parametresinin herhangi bir alanı için geçerlidir, alan bir `struct` türü ve parametresi de bir `struct` türüdür.</span><span class="sxs-lookup"><span data-stu-id="d30d3-215">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="d30d3-216">Aslında, bu kurallar birçok üye erişimi katmanı için geçerlidir, tüm üye erişimi düzeylerindeki türler `structs`.</span><span class="sxs-lookup"><span data-stu-id="d30d3-216">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="d30d3-217">Derleyici, `in` bağımsız değişken olarak geçirilen `struct` türlerini ve `struct` üyelerini diğer yöntemlere bağımsız değişkenler olarak kullanıldığında salt okunurdur.</span><span class="sxs-lookup"><span data-stu-id="d30d3-217">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="d30d3-218">`in` parametrelerinin kullanımı, kopya yapmanın olası performans maliyetlerinden kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-218">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="d30d3-219">Herhangi bir yöntem çağrısının semantiğini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-219">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="d30d3-220">Bu nedenle, çağrı sitesinde `in` değiştiricisini belirtmeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-220">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="d30d3-221">Çağrı sitesindeki `in` değiştiricinin atlanması derleyicinin aşağıdaki nedenlerden dolayı bağımsız değişkenin bir kopyasını yapmasına izin verildiğini bildirir:</span><span class="sxs-lookup"><span data-stu-id="d30d3-221">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="d30d3-222">Bağımsız değişken türünden parametre türüne bir kimlik dönüştürmesi değil, örtük bir dönüştürme var.</span><span class="sxs-lookup"><span data-stu-id="d30d3-222">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="d30d3-223">Bağımsız değişken bir ifadedir ancak bilinen bir depolama değişkenine sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-223">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="d30d3-224">`in`varlığı veya yokluğuna göre farklı bir aşırı yükleme var.</span><span class="sxs-lookup"><span data-stu-id="d30d3-224">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="d30d3-225">Bu durumda, değer olarak aşırı yüklemesi daha iyi bir eşleşmedir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-225">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="d30d3-226">Bu kurallar, var olan kodu salt okuma başvuru bağımsız değişkenlerini kullanacak şekilde güncelleştirdiğinizde yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-226">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="d30d3-227">Çağrılan yöntemin içinde, değer parametrelerine göre kullanan herhangi bir örnek yöntemini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-227">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="d30d3-228">Bu örneklerde `in` parametresinin bir kopyası oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="d30d3-228">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="d30d3-229">Derleyici herhangi bir `in` parametresi için geçici bir değişken oluşturabileceğinden, herhangi bir `in` parametresi için varsayılan değerleri de belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-229">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="d30d3-230">Aşağıdaki kod, kaynak (nokta 0, 0) ikinci nokta için varsayılan değer olarak belirtir:</span><span class="sxs-lookup"><span data-stu-id="d30d3-230">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="d30d3-231">Derleyiciye başvuruya göre salt okuma bağımsız değişkenlerini geçirmeye zorlamak için, aşağıdaki kodda gösterildiği gibi, çağrı sitesindeki bağımsız değişkenlerde `in` değiştiricisini belirtin:</span><span class="sxs-lookup"><span data-stu-id="d30d3-231">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="d30d3-232">Bu davranış, performans kazançlarının mümkün olduğu büyük kod tabanlarında zaman içinde `in` parametrelerinin benimsenmesini kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-232">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="d30d3-233">`in` değiştiricisini öncelikle Yöntem imzalarına eklersiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-233">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="d30d3-234">Ardından, çağrı sitelerine `in` değiştiricisini ekleyebilir ve derleyicinin daha fazla konumda `in` parametrelerinin savunma kopyalarını oluşturmaktan kaçınmasını sağlamak için `readonly struct` türleri oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-234">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="d30d3-235">`in` parametresi ataması, başvuru türleri veya sayısal değerlerle de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-235">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="d30d3-236">Ancak, her iki durumda da avantajlar, varsa en az düzeydedir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-236">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="never-use-mutable-structs-as-in-in-argument"></a><span data-ttu-id="d30d3-237">`in` bağımsız değişkeni olarak hiçbir şekilde kesilebilir yapılar kullanmayın</span><span class="sxs-lookup"><span data-stu-id="d30d3-237">Never use mutable structs as in `in` argument</span></span>

<span data-ttu-id="d30d3-238">Yukarıda açıklanan teknikler, başvuruları döndürerek ve değerlere başvuruya göre geçirerek kopyaların nasıl önleneceğini açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-238">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="d30d3-239">Bu teknikler, bağımsız değişken türleri `readonly struct` türleri olarak bildirildiğinde en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-239">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="d30d3-240">Aksi takdirde, derleyicinin herhangi bir bağımsız değişken için salt okunur hale getirilmesi zorunlu kılmak için birçok durumda **savunma kopyaları** oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-240">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="d30d3-241">Bir 3B noktanın kaynaktan uzaklığını hesaplayan aşağıdaki örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="d30d3-241">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="d30d3-242">`Point3D` yapısı ReadOnly bir struct *değil* .</span><span class="sxs-lookup"><span data-stu-id="d30d3-242">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="d30d3-243">Bu yöntemin gövdesinde altı farklı özellik erişim çağrısı vardır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-243">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="d30d3-244">İlk inceleme durumunda bu erişimlerin güvenli olduğunu düşündük.</span><span class="sxs-lookup"><span data-stu-id="d30d3-244">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="d30d3-245">Tüm `get` erişimci nesnenin durumunu değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-245">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="d30d3-246">Ancak bunu zorlayan bir dil kuralı yoktur.</span><span class="sxs-lookup"><span data-stu-id="d30d3-246">But there's no language rule that enforces that.</span></span> <span data-ttu-id="d30d3-247">Yalnızca ortak bir kuraldır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-247">It's only a common convention.</span></span> <span data-ttu-id="d30d3-248">Herhangi bir tür, iç durumu değiştiren bir `get` erişimcisi uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-248">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="d30d3-249">Bazı dil garantisi olmadan, derleyicinin herhangi bir üyeyi çağırmadan önce bağımsız değişkenin geçici bir kopyasını oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-249">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member.</span></span> <span data-ttu-id="d30d3-250">Geçici depolama, yığında oluşturulur, bağımsız değişkenin değerleri geçici depolamaya kopyalanır ve değer `this` bağımsız değişkeni olarak her üye erişiminde yığına kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-250">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="d30d3-251">Birçok durumda, bu kopyalar, bağımsız değişken türü `readonly struct`olmadığında, bu kopya, değere göre geçiş, salt okunur başvuruya göre daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-251">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct`.</span></span>

<span data-ttu-id="d30d3-252">Bunun yerine, uzaklık hesaplaması değişmez yapıyı kullanıyorsa `ReadonlyPoint3D`geçici nesneler gerekmez:</span><span class="sxs-lookup"><span data-stu-id="d30d3-252">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="d30d3-253">`readonly struct`üyelerini çağırdığınızda derleyici daha verimli kod üretir: alıcının bir kopyası yerine `this` başvurusu, her zaman üye yöntemine başvuru ile geçirilen bir `in` parametresidir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-253">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="d30d3-254">Bu iyileştirme, bir `readonly struct` `in` bağımsız değişkeni olarak kullandığınızda kopyalamayı kaydeder.</span><span class="sxs-lookup"><span data-stu-id="d30d3-254">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="d30d3-255">Null yapılabilir bir değer türünü `in` bağımsız değişken olarak geçirmemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-255">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="d30d3-256"><xref:System.Nullable%601> türü salt okunurdur struct olarak bildirilmemiş.</span><span class="sxs-lookup"><span data-stu-id="d30d3-256">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="d30d3-257">Bu, derleyicinin parametre bildiriminde `in` değiştiricisini kullanarak bir yönteme geçirilen herhangi bir Nullable değer türü bağımsız değişkeni için savunma kopyaları oluşturması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-257">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="d30d3-258">GitHub 'daki [örnek depolarımızda](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) [benchmark.net](https://www.nuget.org/packages/BenchmarkDotNet/) kullanarak performans farklarını gösteren bir örnek program görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-258">You can see an example program that demonstrates the performance differences using [Benchmark.net](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="d30d3-259">Değere ve başvuruya göre değişmez bir struct geçirilerek başvuruya göre kesilebilir bir yapının geçirilmesini karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-259">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="d30d3-260">Değişmez yapının kullanımı ve başvuruya göre Pass en hızlı.</span><span class="sxs-lookup"><span data-stu-id="d30d3-260">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="d30d3-261">Tek bir yığın çerçevesinde bloklarla veya bellekle çalışmak için `ref struct` türlerini kullanın</span><span class="sxs-lookup"><span data-stu-id="d30d3-261">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="d30d3-262">İlgili dil özelliği, tek bir yığın çerçevesiyle sınırlandırılmak zorunda olması gereken bir değer türü bildirebilmesidir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-262">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="d30d3-263">Bu kısıtlama derleyicinin birkaç iyileştirme yapmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-263">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="d30d3-264">Bu özellik için birincil mosyon <xref:System.Span%601> ve ilgili yapılarıdır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-264">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="d30d3-265"><xref:System.Span%601> türünü kullanan yeni ve güncelleştirilmiş .NET API 'Leri kullanarak bu geliştirmelerden performans iyileştirmeleri elde edersiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-265">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="d30d3-266">[`stackalloc`](language-reference/operators/stackalloc.md) kullanılarak oluşturulan ve birlikte çalışma API 'lerinden bellek kullanırken benzer gereksinimlerle çalışıyor olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-266">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="d30d3-267">Bu gereksinimler için kendi `ref struct` türlerinizi tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-267">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="d30d3-268">`readonly ref struct` türü</span><span class="sxs-lookup"><span data-stu-id="d30d3-268">`readonly ref struct` type</span></span>

<span data-ttu-id="d30d3-269">Bir yapının `readonly ref` olarak bildirilmesi, `ref struct` ve `readonly struct` bildirimlerinin avantajlarını ve kısıtlamalarını birleştirir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-269">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="d30d3-270">Salt okunur yayılma alanı tarafından kullanılan bellek tek bir yığın çerçevesiyle kısıtlıdır ve salt okunur olarak kullanılan bellek değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="d30d3-270">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="d30d3-271">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="d30d3-271">Conclusions</span></span>

<span data-ttu-id="d30d3-272">Değer türlerini kullanmak, ayırma işlemlerinin sayısını en aza indirir:</span><span class="sxs-lookup"><span data-stu-id="d30d3-272">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="d30d3-273">Değer türleri için depolama, yerel değişkenler ve Yöntem bağımsız değişkenleri için ayrılmış yığındır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-273">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="d30d3-274">Diğer nesnelerin üyesi olan değer türleri için depolama alanı, ayrı bir ayırma olarak değil, bu nesnenin bir parçası olarak ayrılır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-274">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="d30d3-275">Değer türü dönüş değerleri için depolama, yığın olarak ayrıldı.</span><span class="sxs-lookup"><span data-stu-id="d30d3-275">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="d30d3-276">Aynı durumlarda başvuru türleri ile karşıtlık:</span><span class="sxs-lookup"><span data-stu-id="d30d3-276">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="d30d3-277">Başvuru türleri için depolama, yerel değişkenler ve Yöntem bağımsız değişkenleri için ayrılır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-277">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="d30d3-278">Başvuru yığın üzerinde depolanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-278">The reference is stored on the stack.</span></span>
- <span data-ttu-id="d30d3-279">Diğer nesnelerin üyesi olan başvuru türleri için depolama, yığın üzerinde ayrı olarak ayrılır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-279">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="d30d3-280">İçerilen nesne başvuruyu depolar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-280">The containing object stores the reference.</span></span>
- <span data-ttu-id="d30d3-281">Başvuru türü dönüş değerleri için depolama, yığın olarak ayrıldı.</span><span class="sxs-lookup"><span data-stu-id="d30d3-281">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="d30d3-282">Bu depolamanın başvurusu yığında depolanır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-282">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="d30d3-283">En aza indirme ayırmaları, dengelerle gelir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-283">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="d30d3-284">`struct` boyutu bir başvurunun boyutundan daha büyükse daha fazla bellek kopyalayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-284">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="d30d3-285">Başvuru genellikle 64 bit veya 32 bittir ve hedef makine CPU 'suna bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-285">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="d30d3-286">Bu dengeler genellikle en düşük performans etkisine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-286">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="d30d3-287">Ancak, büyük yapılar veya daha büyük koleksiyonlar için performans etkisi artar.</span><span class="sxs-lookup"><span data-stu-id="d30d3-287">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="d30d3-288">Etki, sıkı Döngülerde ve programlar için etkin yollarda büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-288">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="d30d3-289">Bu C# dilde geliştirmeler, bellek ayırmalarının en aza indirmek için gerekli performansı elde etmek için önemli bir faktör olan performans açısından kritik algoritmalarda tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="d30d3-289">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="d30d3-290">Bu özellikleri genellikle yazdığınız kodda kullanmacağınızı fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-290">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="d30d3-291">Ancak, bu geliştirmeler .NET genelinde benimsenmiştir.</span><span class="sxs-lookup"><span data-stu-id="d30d3-291">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="d30d3-292">Daha fazla API bu özellikleri kullanırken, uygulamalarınızın performansının iyileştireyi görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-292">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="d30d3-293">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="d30d3-293">See also</span></span>

- [<span data-ttu-id="d30d3-294">ref anahtar sözcüğü</span><span class="sxs-lookup"><span data-stu-id="d30d3-294">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="d30d3-295">Ref dönüşler ve ref yerel ayarlar</span><span class="sxs-lookup"><span data-stu-id="d30d3-295">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
