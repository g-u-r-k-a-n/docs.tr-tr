---
description: 'Hakkında daha fazla bilgi edinin: Istemci kullanarak hizmetlere erişme'
title: İstemci Kullanarak Hizmetlere Erişme
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: c8329832-bf66-4064-9034-bf39f153fc2d
ms.openlocfilehash: 112e401f96fb1bf4231fb6bef3e5a57b6f40949e
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793889"
---
# <a name="accessing-services-using-a-client"></a><span data-ttu-id="4bbc1-103">İstemci Kullanarak Hizmetlere Erişme</span><span class="sxs-lookup"><span data-stu-id="4bbc1-103">Accessing Services Using a Client</span></span>

<span data-ttu-id="4bbc1-104">İstemci uygulamaları, hizmetlerle iletişim kurmak için WCF istemcisi veya kanal nesneleri oluşturmalı, yapılandırmalıdır ve kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-104">Client applications must create, configure, and use WCF client or channel objects to communicate with services.</span></span> <span data-ttu-id="4bbc1-105">[WCF Istemci genel bakış](../wcf-client-overview.md) konusu, temel istemci ve kanal nesneleri oluşturma ve bunları kullanma konularında yer alan nesneler ve adımlara genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-105">The [WCF Client Overview](../wcf-client-overview.md) topic provides an overview of the objects and steps involved in creating basic client and channel objects and using them.</span></span>  
  
 <span data-ttu-id="4bbc1-106">Bu konu, senaryonuza bağlı olarak yararlı olabilecek istemci uygulamaları ve istemci ve kanal nesneleri ile ilgili bazı sorunlar hakkında ayrıntılı bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-106">This topic provides in-depth information about some of the issues with client applications and client and channel objects that may be useful depending upon your scenario.</span></span>  
  
## <a name="overview"></a><span data-ttu-id="4bbc1-107">Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="4bbc1-107">Overview</span></span>  

 <span data-ttu-id="4bbc1-108">Bu konuda ile ilgili davranış ve sorunlar açıklanmaktadır:</span><span class="sxs-lookup"><span data-stu-id="4bbc1-108">This topic describes behavior and issues relating to:</span></span>  
  
- <span data-ttu-id="4bbc1-109">Kanal ve oturum yaşam süreleri.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-109">Channel and session lifetimes.</span></span>  
  
- <span data-ttu-id="4bbc1-110">Özel durumları işleme.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-110">Handling exceptions.</span></span>  
  
- <span data-ttu-id="4bbc1-111">Engelleme sorunlarını anlama.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-111">Understanding blocking issues.</span></span>  
  
- <span data-ttu-id="4bbc1-112">Kanalları etkileşimli olarak başlatma.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-112">Initializing channels interactively.</span></span>  
  
### <a name="channel-and-session-lifetimes"></a><span data-ttu-id="4bbc1-113">Kanal ve oturum yaşam süreleri</span><span class="sxs-lookup"><span data-stu-id="4bbc1-113">Channel and Session Lifetimes</span></span>  

 <span data-ttu-id="4bbc1-114">Windows Communication Foundation (WCF) uygulamaları iki kanal, datagram ve oturumsuz kategori içerir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-114">Windows Communication Foundation (WCF) applications includes two categories of channels, datagram and sessionful.</span></span>  
  
 <span data-ttu-id="4bbc1-115">*Veri birimi* kanalı, tüm iletilerin bağıntısız olduğu bir kanaldır.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-115">A *datagram* channel is a channel in which all messages are uncorrelated.</span></span> <span data-ttu-id="4bbc1-116">Bir veri birimi kanalı ile bir giriş veya çıkış işlemi başarısız olursa, sonraki işlem genellikle etkilenmemiştir ve aynı kanal yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-116">With a datagram channel, if an input or output operation fails, the next operation is typically unaffected, and the same channel can be reused.</span></span> <span data-ttu-id="4bbc1-117">Bu nedenle, datagram kanalları genellikle hata vermez.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-117">Because of this, datagram channels typically do not fault.</span></span>  
  
 <span data-ttu-id="4bbc1-118">Ancak *oturumsuz* kanallar, diğer uç noktayla bağlantısı olan kanallardır.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-118">*Sessionful* channels, however, are channels with a connection to the other endpoint.</span></span> <span data-ttu-id="4bbc1-119">Bir taraftaki oturumdaki iletiler, her zaman diğer taraftaki aynı oturumla bağıntılı.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-119">Messages in a session on one side are always correlated with the same session on the other side.</span></span> <span data-ttu-id="4bbc1-120">Ayrıca, bir oturumdaki her iki katılımcı da bu oturumun başarılı olarak kabul edilmesi için, konuşmaları gereksinimlerinin karşılandığını kabul etmelidir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-120">In addition, both participants in a session must agree that the requirements of their conversation were met for that session to be considered successful.</span></span> <span data-ttu-id="4bbc1-121">Kabul etmiyorsanız, oturumsuz kanal hata verebilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-121">If they cannot agree, the sessionful channel may fault.</span></span>  
  
 <span data-ttu-id="4bbc1-122">İlk işlemi çağırarak istemcileri açıkça veya örtük olarak açın.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-122">Open clients explicitly or implicitly by calling the first operation.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4bbc1-123">Hatalı oturumsuz kanalların açıkça algılanmasıyla çalışılması, size bildirimde bulunulduğundan oturum uygulamaya bağlı olarak, genellikle yararlı değildir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-123">Trying to explicitly detect faulted sessionful channels is not typically useful, because when you are notified depends upon the session implementation.</span></span> <span data-ttu-id="4bbc1-124">Örneğin, <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (güvenilir oturum devre dışı bırakılmış), TCP bağlantısının oturumunu yüzey halinde sunırsanız, <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> hizmette veya istemcide olay dinlerken bir ağ arızası durumunda hızlı bir şekilde bildirilmesini sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-124">For example, because the <xref:System.ServiceModel.NetTcpBinding?displayProperty=nameWithType> (with the reliable session disabled) surfaces the session of the TCP connection, if you listen to the <xref:System.ServiceModel.ICommunicationObject.Faulted?displayProperty=nameWithType> event on the service or the client you are likely to be notified quickly in the event of a network failure.</span></span> <span data-ttu-id="4bbc1-125">Ancak, güvenilir oturumlar (etkin olduğu bağlamalar tarafından oluşturulan <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> ), küçük ağ arızalarındaki hizmetleri tahmin etmek için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-125">But reliable sessions (established by bindings in which the <xref:System.ServiceModel.Channels.ReliableSessionBindingElement?displayProperty=nameWithType> is enabled) are designed to insulate services from small network failures.</span></span> <span data-ttu-id="4bbc1-126">Oturum makul bir süre içinde yeniden kurulmuyorsa, güvenilir oturumlar için yapılandırılmış aynı bağlama — daha uzun bir süre boyunca kesilene kadar hata olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-126">If the session can be reestablished within a reasonable period of time, the same binding—configured for reliable sessions—might not fault until the interruption continued for a longer period of time.</span></span>  
  
 <span data-ttu-id="4bbc1-127">Sistem tarafından sunulan bağlamaların (kanalları uygulama katmanında kullanıma sunma) çoğu oturumları varsayılan olarak kullanır, ancak yapmaz <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4bbc1-127">Most of the system-provided bindings (which expose channels to the application layer) use sessions by default, but the <xref:System.ServiceModel.BasicHttpBinding?displayProperty=nameWithType> does not.</span></span> <span data-ttu-id="4bbc1-128">Daha fazla bilgi için bkz. [oturumları kullanma](../using-sessions.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-128">For more information, see [Using Sessions](../using-sessions.md).</span></span>  
  
### <a name="the-proper-use-of-sessions"></a><span data-ttu-id="4bbc1-129">Oturumların uygun kullanımı</span><span class="sxs-lookup"><span data-stu-id="4bbc1-129">The Proper Use of Sessions</span></span>  

 <span data-ttu-id="4bbc1-130">Oturumlar, tüm ileti alışverişi tamamlandı ve her iki taraf da başarılı olarak kabul edildiğinde bilmemiz için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-130">Sessions provide a way to know if the entire message exchange is complete, and if both sides considered it successful.</span></span> <span data-ttu-id="4bbc1-131">Çağıran bir uygulamanın kanalı açması, onu kullanması ve kanalı bir try bloğu içinde kapatması önerilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-131">It is recommended that a calling application open the channel, use it, and close the channel inside one try block.</span></span> <span data-ttu-id="4bbc1-132">Bir oturum kanalı açıksa ve <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> yöntemi bir kez çağrılırsa ve bu çağrı başarıyla döndürülürse, oturum başarılı olmuştur.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-132">If a session channel is open, and the <xref:System.ServiceModel.ICommunicationObject.Close%2A?displayProperty=nameWithType> method is called once, and that call returns successfully, then the session was successful.</span></span> <span data-ttu-id="4bbc1-133">Bu durumda başarılı oldu, tüm teslimin belirtilen bağlamanın karşılandığından ve diğer tarafın çağrılmadan önce kanalda çağırmadığından emin olduğu anlamına gelir <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> <xref:System.ServiceModel.ICommunicationObject.Close%2A> .</span><span class="sxs-lookup"><span data-stu-id="4bbc1-133">Successful in this case means that all delivery guarantees the binding specified were met, and the other side did not call <xref:System.ServiceModel.ICommunicationObject.Abort%2A?displayProperty=nameWithType> on the channel before calling <xref:System.ServiceModel.ICommunicationObject.Close%2A>.</span></span>  
  
 <span data-ttu-id="4bbc1-134">Aşağıdaki bölümde bu istemci yaklaşımına bir örnek verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-134">The following section provides an example of this client approach.</span></span>  
  
### <a name="handling-exceptions"></a><span data-ttu-id="4bbc1-135">Özel Durumları İşleme</span><span class="sxs-lookup"><span data-stu-id="4bbc1-135">Handling Exceptions</span></span>  

 <span data-ttu-id="4bbc1-136">İstemci uygulamalarında özel durumların işlenmesi basittir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-136">Handling exceptions in client applications is straightforward.</span></span> <span data-ttu-id="4bbc1-137">Bir kanal açılırsa, kullanıldığında ve bir try bloğu içinde kapatılırsa, bir özel durum oluşturulmadığı takdirde konuşma başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-137">If a channel is opened, used, and closed inside a try block, then the conversation has succeeded, unless an exception is thrown.</span></span> <span data-ttu-id="4bbc1-138">Genellikle, bir özel durum oluşturulursa, konuşma iptal edilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-138">Typically, if an exception is thrown the conversation is aborted.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4bbc1-139">`using`Deyimin kullanımı ( `Using` Visual Basic) önerilmez.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-139">Use of the `using` statement (`Using` in Visual Basic) is not recommended.</span></span> <span data-ttu-id="4bbc1-140">Bunun nedeni, `using` deyimin sonunun hakkında bilmeniz gerekebilecek diğer özel durumları maskeleyebilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-140">This is because the end of the `using` statement can cause exceptions that can mask other exceptions you may need to know about.</span></span> <span data-ttu-id="4bbc1-141">Daha fazla bilgi için bkz. [Close ve Abort kullanarak WCF istemci kaynaklarını serbest bırakma](../samples/use-close-abort-release-wcf-client-resources.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-141">For more information, see [Use Close and Abort to release WCF client resources](../samples/use-close-abort-release-wcf-client-resources.md).</span></span>  
  
 <span data-ttu-id="4bbc1-142">Aşağıdaki kod örneği, ifadesiyle değil, bir try/catch bloğu kullanarak önerilen istemci modelini gösterir `using` .</span><span class="sxs-lookup"><span data-stu-id="4bbc1-142">The following code example shows the recommended client pattern using a try/catch block and not the `using` statement.</span></span>  
  
 [!code-csharp[FaultContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/faultcontractattribute/cs/client.cs#3)]
 [!code-vb[FaultContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/faultcontractattribute/vb/client.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="4bbc1-143">Özelliğin değerinin denetlenmesi <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> bir yarış durumudur ve bir kanalın yeniden kullanılıp kullanılmayacağını veya kapatılmasını belirlemekte önerilmez.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-143">Checking the value of the <xref:System.ServiceModel.ICommunicationObject.State%2A?displayProperty=nameWithType> property is a race condition and is not recommended to determine whether to reuse or close a channel.</span></span>  
  
 <span data-ttu-id="4bbc1-144">Veri birimi kanalları kapandığında özel durumlar gerçekleşse bile hiçbir zaman hata vermez.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-144">Datagram channels never fault even if exceptions occur when they are closed.</span></span> <span data-ttu-id="4bbc1-145">Ayrıca, güvenli bir konuşma kullanarak kimlik doğrulaması başarısız olan ve çift yönlü olmayan istemciler genellikle bir oluşturur <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4bbc1-145">In addition, non-duplex clients that fail to authenticate using a secure conversation typically throw a <xref:System.ServiceModel.Security.MessageSecurityException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4bbc1-146">Ancak güvenli bir konuşma kullanan çift yönlü istemci kimlik doğrulaması yapamazsa, istemci <xref:System.TimeoutException?displayProperty=nameWithType> bunun yerine bir alır.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-146">However if the duplex client using a secure conversation fails to authenticate, the client receives a <xref:System.TimeoutException?displayProperty=nameWithType> instead.</span></span>  
  
 <span data-ttu-id="4bbc1-147">Uygulama düzeyinde hata bilgileriyle çalışma hakkında daha ayrıntılı bilgi için bkz. [sözleşmeleri ve Hizmetleri kullanarak hataları belirtme ve işleme](../specifying-and-handling-faults-in-contracts-and-services.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-147">For more complete information about working with error information at the application level, see [Specifying and Handling Faults in Contracts and Services](../specifying-and-handling-faults-in-contracts-and-services.md).</span></span> <span data-ttu-id="4bbc1-148">[Beklenen özel durumlar](../samples/expected-exceptions.md) beklenen özel durumları açıklar ve bunların nasıl işleneceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-148">[Expected Exceptions](../samples/expected-exceptions.md) describes expected exceptions and shows how to handle them.</span></span> <span data-ttu-id="4bbc1-149">Kanalları geliştirirken hataların nasıl işleneceği hakkında daha fazla bilgi için bkz. [özel durumları ve hataları işleme](../extending/handling-exceptions-and-faults.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-149">For more information about how to handle errors when developing channels, see [Handling Exceptions and Faults](../extending/handling-exceptions-and-faults.md).</span></span>  
  
### <a name="client-blocking-and-performance"></a><span data-ttu-id="4bbc1-150">İstemci engelleme ve performans</span><span class="sxs-lookup"><span data-stu-id="4bbc1-150">Client Blocking and Performance</span></span>  

 <span data-ttu-id="4bbc1-151">Bir uygulama bir istek-yanıt işlemini zaman uyumlu olarak çağırdığında, istemci, dönüş değeri alınana veya bir özel durum (örneğin bir <xref:System.TimeoutException?displayProperty=nameWithType> ) atılana kadar engeller.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-151">When an application synchronously calls a request-reply operation, the client blocks until a return value is received or an exception (such as a <xref:System.TimeoutException?displayProperty=nameWithType>) is thrown.</span></span> <span data-ttu-id="4bbc1-152">Bu davranış, yerel davranışa benzer.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-152">This behavior is similar to local behavior.</span></span> <span data-ttu-id="4bbc1-153">Bir uygulama bir WCF istemci nesnesi veya kanalında eşzamanlı olarak bir işlem çağırdığında, istemci kanal katmanı verileri ağa yazana veya bir özel durum oluşturuluncaya kadar döndürmez.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-153">When an application synchronously invokes an operation on a WCF client object or channel, the client does not return until the channel layer can write the data to the network or until an exception is thrown.</span></span> <span data-ttu-id="4bbc1-154">Tek yönlü ileti değişimi deseninin (bir işlem olarak ayarlanmış bir işlem olarak işaretleyerek belirtilen <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> `true` ) bazı istemcilerin daha hızlı yanıt verebilmesini sağlarken, bağlamaya ve bu iletilerin zaten gönderilmiş olmasına bağlı olarak tek yönlü işlemler de engelleyebilirler.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-154">And while the one-way message exchange pattern (specified by marking an operation with <xref:System.ServiceModel.OperationContractAttribute.IsOneWay%2A?displayProperty=nameWithType> set to `true`) can make some clients more responsive, one-way operations can also block, depending upon the binding and what messages have already been sent.</span></span> <span data-ttu-id="4bbc1-155">Tek yönlü işlemler yalnızca ileti alışverişi hakkında, daha az ve daha az değildir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-155">One-way operations are only about the message exchange, no more and no less.</span></span> <span data-ttu-id="4bbc1-156">Daha fazla bilgi için bkz. [tek yönlü hizmetler](one-way-services.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-156">For more information, see [One-Way Services](one-way-services.md).</span></span>  
  
 <span data-ttu-id="4bbc1-157">Büyük veri öbekleri ileti değişimi düzeniyle ne fark etmeksizin istemci işlemesini yavaşlatabilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-157">Large data chunks can slow client processing no matter what the message exchange pattern.</span></span> <span data-ttu-id="4bbc1-158">Bu sorunları nasıl işleyeceğinizi anlamak için bkz. [büyük veri ve akış](large-data-and-streaming.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-158">To understand how to handle these issues, see [Large Data and Streaming](large-data-and-streaming.md).</span></span>  
  
 <span data-ttu-id="4bbc1-159">Bir işlem tamamlandığında uygulamanız daha fazla iş yapabilmelidir, WCF istemcinizin uyguladığı hizmet sözleşmesi arabiriminde zaman uyumsuz bir yöntem çifti oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-159">If your application must do more work while an operation completes, you should create an asynchronous method pair on the service contract interface that your WCF client implements.</span></span> <span data-ttu-id="4bbc1-160">Bunu yapmanın en kolay yolu, `/async` [ServiceModel meta veri yardımcı programı aracında (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)anahtarı kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-160">The easiest way to do this is to use the `/async` switch on the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="4bbc1-161">Bir örnek için bkz. [nasıl yapılır: hizmet Işlemlerini zaman uyumsuz olarak çağırma](how-to-call-wcf-service-operations-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-161">For an example, see [How to: Call Service Operations Asynchronously](how-to-call-wcf-service-operations-asynchronously.md).</span></span>  
  
 <span data-ttu-id="4bbc1-162">İstemci performansını artırma hakkında daha fazla bilgi için bkz. [Orta katman Istemci uygulamaları](middle-tier-client-applications.md).</span><span class="sxs-lookup"><span data-stu-id="4bbc1-162">For more information about increasing client performance, see [Middle-Tier Client Applications](middle-tier-client-applications.md).</span></span>  
  
### <a name="enabling-the-user-to-select-credentials-dynamically"></a><span data-ttu-id="4bbc1-163">Kullanıcının kimlik bilgilerini dinamik olarak seçmesini sağlama</span><span class="sxs-lookup"><span data-stu-id="4bbc1-163">Enabling the User to Select Credentials Dynamically</span></span>  

 <span data-ttu-id="4bbc1-164"><xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer>Arabirim, uygulamanın, zaman aşımı zamanlayıcılar başlamadan önce bir kanalın oluşturulduğu kimlik bilgilerini seçmesini sağlayan bir kullanıcı arabirimi görüntülemesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-164">The <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> interface enables applications to display a user interface that enables the user to choose credentials with which a channel is created before the timeout timers start.</span></span>  
  
 <span data-ttu-id="4bbc1-165">Uygulama geliştiricileri, ekleneni <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> iki şekilde kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-165">Application developers can make use of an inserted <xref:System.ServiceModel.Dispatcher.IInteractiveChannelInitializer> in two ways.</span></span> <span data-ttu-id="4bbc1-166">İstemci uygulaması, <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> kanalı açmadan ( *Açık* yaklaşım) veya ilk işlemi ( *örtük* yaklaşım) çağırmadan önce ya da (ya da bir zaman uyumsuz sürüm) çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-166">The client application can call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version) prior to opening the channel (the *explicit* approach) or call the first operation (the *implicit* approach).</span></span>  
  
 <span data-ttu-id="4bbc1-167">Örtük yaklaşım kullanılıyorsa, uygulamanın bir veya uzantısında ilk işlemi çağırması gerekir <xref:System.ServiceModel.ClientBase%601> <xref:System.ServiceModel.IClientChannel> .</span><span class="sxs-lookup"><span data-stu-id="4bbc1-167">If using the implicit approach, the application must call the first operation on a <xref:System.ServiceModel.ClientBase%601> or <xref:System.ServiceModel.IClientChannel> extension.</span></span> <span data-ttu-id="4bbc1-168">İlk işlem dışında bir şey çağırırsa, bir özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-168">If it calls anything other than the first operation, an exception is thrown.</span></span>  
  
 <span data-ttu-id="4bbc1-169">Açık yaklaşımı kullanıyorsanız, uygulamanın sırasıyla aşağıdaki adımları gerçekleştirmesi gerekir:</span><span class="sxs-lookup"><span data-stu-id="4bbc1-169">If using the explicit approach, the application must perform the following steps in order:</span></span>  
  
1. <span data-ttu-id="4bbc1-170">Ya da <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (ya da zaman uyumsuz bir sürüm) çağırın.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-170">Call either <xref:System.ServiceModel.ClientBase%601.DisplayInitializationUI%2A?displayProperty=nameWithType> or <xref:System.ServiceModel.IClientChannel.DisplayInitializationUI%2A?displayProperty=nameWithType> (or an asynchronous version).</span></span>  
  
2. <span data-ttu-id="4bbc1-171">Başlatıcılar döndürüldüğünde, <xref:System.ServiceModel.ICommunicationObject.Open%2A> <xref:System.ServiceModel.IClientChannel> nesne üzerinde veya <xref:System.ServiceModel.IClientChannel> özelliğinden döndürülen nesnede yöntemi çağırın <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4bbc1-171">When the initializers have returned, call either the <xref:System.ServiceModel.ICommunicationObject.Open%2A> method on the <xref:System.ServiceModel.IClientChannel> object or on the <xref:System.ServiceModel.IClientChannel> object returned from the <xref:System.ServiceModel.ClientBase%601.InnerChannel%2A?displayProperty=nameWithType> property.</span></span>  
  
3. <span data-ttu-id="4bbc1-172">Çağrı işlemleri.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-172">Call operations.</span></span>  
  
 <span data-ttu-id="4bbc1-173">Üretim kalitesi uygulamalarının, açık yaklaşımı benimseerek Kullanıcı arabirimi sürecini denetlemekte olması önerilir.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-173">It is recommended that production-quality applications control the user-interface process by adopting the explicit approach.</span></span>  
  
 <span data-ttu-id="4bbc1-174">Örtük yaklaşımı kullanan uygulamalar Kullanıcı arabirimi başlatıcıları çağırır, ancak uygulamanın kullanıcısı bağlamanın zaman aşımı süresi içinde yanıt vermezse, Kullanıcı arabirimi geri döndüğünde bir özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-174">Applications that use the implicit approach invoke the user-interface initializers, but if the user of the application fails to respond within the send timeout period of the binding, an exception is thrown when the user interface returns.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4bbc1-175">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="4bbc1-175">See also</span></span>

- [<span data-ttu-id="4bbc1-176">Çift Yönlü Hizmetler</span><span class="sxs-lookup"><span data-stu-id="4bbc1-176">Duplex Services</span></span>](duplex-services.md)
- [<span data-ttu-id="4bbc1-177">Nasıl yapılır: Tek Yönlü ve İstek-Yanıt Sözleşmeleriyle Hizmetlere Erişme</span><span class="sxs-lookup"><span data-stu-id="4bbc1-177">How to: Access Services with One-Way and Request-Reply Contracts</span></span>](how-to-access-wcf-services-with-one-way-and-request-reply-contracts.md)
- [<span data-ttu-id="4bbc1-178">Nasıl yapılır: Çift Yönlü Sözleşme ile Hizmetlere Erişme</span><span class="sxs-lookup"><span data-stu-id="4bbc1-178">How to: Access Services with a Duplex Contract</span></span>](how-to-access-services-with-a-duplex-contract.md)
- [<span data-ttu-id="4bbc1-179">Nasıl yapılır: WSE 3.0 Hizmetine Erişme</span><span class="sxs-lookup"><span data-stu-id="4bbc1-179">How to: Access a WSE 3.0 Service</span></span>](how-to-access-a-wse-3-0-service-with-a-wcf-client.md)
- [<span data-ttu-id="4bbc1-180">Nasıl yapılır: ChannelFactory Kullanma</span><span class="sxs-lookup"><span data-stu-id="4bbc1-180">How to: Use the ChannelFactory</span></span>](how-to-use-the-channelfactory.md)
- [<span data-ttu-id="4bbc1-181">Nasıl yapılır: Hizmet İşlemlerini Zaman Uyumsuz Olarak Çağırma</span><span class="sxs-lookup"><span data-stu-id="4bbc1-181">How to: Call Service Operations Asynchronously</span></span>](how-to-call-wcf-service-operations-asynchronously.md)
- [<span data-ttu-id="4bbc1-182">Orta Katman İstemci Uygulamaları</span><span class="sxs-lookup"><span data-stu-id="4bbc1-182">Middle-Tier Client Applications</span></span>](middle-tier-client-applications.md)
