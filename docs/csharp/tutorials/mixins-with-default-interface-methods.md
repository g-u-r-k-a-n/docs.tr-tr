---
title: Varsayılan arabirim yöntemlerini kullanarak mixin türleri oluşturma
description: Varsayılan arabirim üyelerini kullanarak uygulayıcılar için isteğe bağlı varsayılan uygulamalara sahip arabirimleri genişletebilirsiniz.
ms.technology: csharp-advanced-concepts
ms.date: 10/04/2019
ms.openlocfilehash: aaf8d34e27c9c56d95560656eb7a7b24b152c053
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240112"
---
# <a name="tutorial-mix-functionality-in-when-creating-classes-using-interfaces-with-default-interface-methods"></a><span data-ttu-id="2a1d5-103">Öğretici: Varsayılan arabirim yöntemleriyle arabirimleri kullanarak sınıf oluştururken işlevselliği karıştırın</span><span class="sxs-lookup"><span data-stu-id="2a1d5-103">Tutorial: Mix functionality in when creating classes using interfaces with default interface methods</span></span>

<span data-ttu-id="2a1d5-104">.NET Core 3.0'daki C# 8.0 ile başlayarak, bir arabirimin üyesini beyan ettiğinizde bir uygulama tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-104">Beginning with C# 8.0 on .NET Core 3.0, you can define an implementation when you declare a member of an interface.</span></span> <span data-ttu-id="2a1d5-105">Bu özellik, arabirimlerde bildirilen özellikler için varsayılan uygulamaları tanımlayabileceğiniz yeni özellikler sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-105">This feature provides new capabilities where you can define default implementations for features declared in interfaces.</span></span> <span data-ttu-id="2a1d5-106">Sınıflar işlevselliği ne zaman geçersiz kılacaklarını, varsayılan işlevselliği ne zaman kullanacaklarını ve ayrı özellikler için destek bildirmeyecekleri zaman ları seçebilirler.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-106">Classes can pick when to override functionality, when to use the default functionality, and when not to declare support for discrete features.</span></span>

<span data-ttu-id="2a1d5-107">Bu öğreticide şunların nasıl yapıldığını öğreneceksiniz:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-107">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> * <span data-ttu-id="2a1d5-108">Ayrık özellikleri açıklayan uygulamalarla arabirimler oluşturun.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-108">Create interfaces with implementations that describe discrete features.</span></span>
> * <span data-ttu-id="2a1d5-109">Varsayılan uygulamaları kullanan sınıflar oluşturun.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-109">Create classes that use the default implementations.</span></span>
> * <span data-ttu-id="2a1d5-110">Varsayılan uygulamaların bazılarını veya tümünün geçersiz kılındığını belirten sınıflar oluşturun.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-110">Create classes that override some or all of the default implementations.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="2a1d5-111">Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="2a1d5-111">Prerequisites</span></span>

<span data-ttu-id="2a1d5-112">C# 8.0 derleyicisi de dahil olmak üzere .NET Core'u çalıştıracak şekilde makinenizi ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-112">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="2a1d5-113">C# 8.0 derleyicisi [Visual Studio 2019 sürümü 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)veya [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) veya daha sonra ile başlayarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-113">The C# 8.0 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019), or the [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download/dotnet-core) or later.</span></span>

## <a name="limitations-of-extension-methods"></a><span data-ttu-id="2a1d5-114">Uzatma yöntemlerinin sınırlamaları</span><span class="sxs-lookup"><span data-stu-id="2a1d5-114">Limitations of extension methods</span></span>

<span data-ttu-id="2a1d5-115">Arabirimin bir parçası olarak görünen davranışı uygulamanın bir yolu, varsayılan davranışı sağlayan [uzantı yöntemlerini](../programming-guide/classes-and-structs/extension-methods.md) tanımlamaktır.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-115">One way you can implement behavior that appears as part of an interface is to define [extension methods](../programming-guide/classes-and-structs/extension-methods.md) that provide the default behavior.</span></span> <span data-ttu-id="2a1d5-116">Arabirimler, bu arabirimi uygulayan herhangi bir sınıf için daha büyük bir yüzey alanı sağlarken en az üye kümesini bildirir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-116">Interfaces declare a minimum set of members while providing a greater surface area for any class that implements that interface.</span></span> <span data-ttu-id="2a1d5-117">Örneğin, herhangi bir <xref:System.Linq.Enumerable> dizinin LINQ sorgusunun kaynağı olmasını sağlayan uzantı yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-117">For example, the extension methods in <xref:System.Linq.Enumerable> provide the implementation for any sequence to be the source of a LINQ query.</span></span>

<span data-ttu-id="2a1d5-118">Uzantı yöntemleri, bildirilen değişken türü kullanılarak derleme zamanında çözülür.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-118">Extension methods are resolved at compile time, using the declared type of the variable.</span></span> <span data-ttu-id="2a1d5-119">Arabirimi uygulayan sınıflar, herhangi bir uzantı yöntemi için daha iyi bir uygulama sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-119">Classes that implement the interface can provide a better implementation for any extension method.</span></span> <span data-ttu-id="2a1d5-120">Derleyicinin bu uygulamayı seçmesi için değişken bildirimleruygulama türüyle eşleşmelidir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-120">Variable declarations must match the implementing type to enable the compiler to choose that implementation.</span></span> <span data-ttu-id="2a1d5-121">Derleme zamanı türü arabirimle eşleştiğinde, yöntem çağrıları uzantı yöntemiyle çözülür.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-121">When the compile-time type matches the interface, method calls resolve to the extension method.</span></span> <span data-ttu-id="2a1d5-122">Uzantı yöntemleriyle ilgili bir diğer endişe, bu yöntemlere uzantı yöntemlerini içeren sınıfın erişilebildiği her yerde erişilebilir olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-122">Another concern with extension methods is that those methods are accessible wherever the class containing the extension methods is accessible.</span></span> <span data-ttu-id="2a1d5-123">Sınıflar, uzantı yöntemlerinde bildirilen özellikleri sağlamaları gerektiğini veya sağlamaması gerektiğini beyan edemez.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-123">Classes cannot declare if they should or should not provide features declared in extension methods.</span></span>

<span data-ttu-id="2a1d5-124">C# 8.0 ile başlayarak varsayılan uygulamaları arabirim yöntemleri olarak bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-124">Starting with C# 8.0, you can declare the default implementations as interface methods.</span></span> <span data-ttu-id="2a1d5-125">Daha sonra, her sınıf varsayılan uygulamayı otomatik olarak kullanır.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-125">Then, every class automatically uses the default implementation.</span></span> <span data-ttu-id="2a1d5-126">Daha iyi bir uygulama sağlayabilir herhangi bir sınıf daha iyi bir algoritma ile arabirim yöntemi tanımı geçersiz kılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-126">Any class that can provide a better implementation can override the interface method definition with a better algorithm.</span></span> <span data-ttu-id="2a1d5-127">Bir anlamda, bu teknik [uzantı yöntemlerini](../programming-guide/classes-and-structs/extension-methods.md)nasıl kullanabileceğinize benzer.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-127">In one sense, this technique sounds similar to how you could use [extension methods](../programming-guide/classes-and-structs/extension-methods.md).</span></span>

<span data-ttu-id="2a1d5-128">Bu makalede, varsayılan arabirim uygulamalarının yeni senaryoları nasıl etkinleştireceğini öğreneceksiniz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-128">In this article, you'll learn how default interface implementations enable new scenarios.</span></span>

## <a name="design-the-application"></a><span data-ttu-id="2a1d5-129">Uygulamayı tasarla</span><span class="sxs-lookup"><span data-stu-id="2a1d5-129">Design the application</span></span>

<span data-ttu-id="2a1d5-130">Bir ev otomasyonu uygulaması düşünün.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-130">Consider a home automation application.</span></span> <span data-ttu-id="2a1d5-131">Muhtemelen ışıklar ve göstergeler için boyunca kullanılabilir birçok farklı türleri var.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-131">You probably have many different types of lights and indicators that could be used throughout the house.</span></span> <span data-ttu-id="2a1d5-132">Her ışık API'leri açıp kapatmak ve geçerli durumu bildirmek için desteklemelidir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-132">Every light must support APIs to turn them on and off, and to report the current state.</span></span> <span data-ttu-id="2a1d5-133">Bazı ışıklar ve göstergeler şu gibi diğer özellikleri destekleyebilir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-133">Some lights and indicators may support other features, such as:</span></span>

- <span data-ttu-id="2a1d5-134">Işığı açın, sonra bir zamanlayıcıdan sonra kapatın.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-134">Turn light on, then turn it off after a timer.</span></span>
- <span data-ttu-id="2a1d5-135">Işığı bir süre için yanıp sön.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-135">Blink the light for a period of time.</span></span>

<span data-ttu-id="2a1d5-136">Bu genişletilmiş özelliklerden bazıları, en az kümeyi destekleyen aygıtlarda taklit edilebilir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-136">Some of these extended capabilities could be emulated in devices that support the minimal set.</span></span> <span data-ttu-id="2a1d5-137">Bu, varsayılan bir uygulama sağlamaanlamına geldiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-137">That indicates providing a default implementation.</span></span> <span data-ttu-id="2a1d5-138">Yerleşik daha fazla özelliklere sahip olan aygıtlar için, aygıt yazılımı yerel yetenekleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-138">For those devices that have more capabilities built in, the device software would use the native capabilities.</span></span> <span data-ttu-id="2a1d5-139">Diğer ışıklar için, arabirimi uygulamayı ve varsayılan uygulamayı kullanmayı seçebilirler.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-139">For other lights, they could choose to implement the interface and use the default implementation.</span></span>

<span data-ttu-id="2a1d5-140">Varsayılan arabirim üyeleri, bu senaryo için uzantı yöntemlerine göre daha iyi bir çözümdür.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-140">Default interface members is a better solution for this scenario than extension methods.</span></span> <span data-ttu-id="2a1d5-141">Sınıf yazarları hangi arabirimleri uygulamak için seçtiklerini denetleyebilir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-141">Class authors can control which interfaces they choose to implement.</span></span> <span data-ttu-id="2a1d5-142">Seçtikleri bu arabirimler yöntem olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-142">Those interfaces they choose are available as methods.</span></span> <span data-ttu-id="2a1d5-143">Buna ek olarak, varsayılan arabirim yöntemleri varsayılan olarak sanal olduğundan, yöntem gönderme her zaman sınıftaki uygulamayı seçer.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-143">In addition, because default interface methods are virtual by default, the method dispatch always chooses the implementation in the class.</span></span>

<span data-ttu-id="2a1d5-144">Bu farklılıkları göstermek için kodu oluşturalım.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-144">Let's create the code to demonstrate these differences.</span></span>

## <a name="create-interfaces"></a><span data-ttu-id="2a1d5-145">Arayüzler oluşturma</span><span class="sxs-lookup"><span data-stu-id="2a1d5-145">Create interfaces</span></span>

<span data-ttu-id="2a1d5-146">Tüm ışıklar için davranışı tanımlayan arabirimi oluşturarak başlayın:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-146">Start by creating the interface that defines the behavior for all lights:</span></span>

[!code-csharp[Declare base interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetILightInterfaceV1)]

<span data-ttu-id="2a1d5-147">Temel bir havai aydınlatma fikstürü, aşağıdaki kodda gösterildiği gibi bu arabirimi uygulayabilir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-147">A basic overhead light fixture might implement this interface as shown in the following code:</span></span>

[!code-csharp[First overhead light](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetOverheadLightV1)]

<span data-ttu-id="2a1d5-148">Bu öğreticide, kod IoT aygıtlarını yönlendirmez, ancak konsola ileti ler yazarak bu etkinlikleri taklit eder.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-148">In this tutorial, the code doesn't drive IoT devices, but emulates those activities by writing messages to the console.</span></span> <span data-ttu-id="2a1d5-149">Evinizi otomatikleştirerek kodu keşfedebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-149">You can explore the code without automating your house.</span></span>

<span data-ttu-id="2a1d5-150">Ardından, bir zaman anından sonra otomatik olarak kapanabilen bir ışık için arabirimi tanımlayalım:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-150">Next, let's define the interface for a light that can automatically turn off after a timeout:</span></span>

[!code-csharp[pure Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/UnusedExampleCode.cs?name=SnippetPureTimerInterface)]

<span data-ttu-id="2a1d5-151">Havai ışığa temel bir uygulama ekleyebilirsiniz, ancak daha iyi bir çözüm `virtual` varsayılan bir uygulama sağlamak için bu arabirim tanımını değiştirmektir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-151">You could add a basic implementation to the overhead light, but a better solution is to modify this interface definition to provide a `virtual` default implementation:</span></span>

[!code-csharp[Timer interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ITimerLight.cs?name=SnippetTimerLightFinal)]

<span data-ttu-id="2a1d5-152">Bu değişikliği ekleyerek, `OverheadLight` sınıf arabirimi için destek beyan ederek zamanlayıcı işlevini uygulayabilir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-152">By adding that change, the `OverheadLight` class can implement the timer function by declaring support for the interface:</span></span>

```csharp
public class OverheadLight : ITimerLight { }
```

<span data-ttu-id="2a1d5-153">Farklı bir ışık türü daha gelişmiş bir protokolü destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-153">A different light type may support a more sophisticated protocol.</span></span> <span data-ttu-id="2a1d5-154">Aşağıdaki kodda gösterildiği `TurnOnFor`gibi, kendi uygulamasını sağlayabilir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-154">It can provide its own implementation for `TurnOnFor`, as shown in the following code:</span></span>

[!code-csharp[Override the timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/HalogenLight.cs?name=SnippetHalogenLight)]

<span data-ttu-id="2a1d5-155">Sanal sınıf yöntemlerinin geçersiz kılınması `TurnOnFor` `HalogenLight` yerine, sınıftaki `override` bildirim anahtar sözcüğü kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-155">Unlike overriding virtual class methods, the declaration of `TurnOnFor` in the `HalogenLight` class does not use the `override` keyword.</span></span>

## <a name="mix-and-match-capabilities"></a><span data-ttu-id="2a1d5-156">Karıştırma ve eşleştirme özellikleri</span><span class="sxs-lookup"><span data-stu-id="2a1d5-156">Mix and match capabilities</span></span>

<span data-ttu-id="2a1d5-157">Daha gelişmiş özellikler tanıttıkça varsayılan arabirim yöntemlerinin avantajları daha da netleşir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-157">The advantages of default interface methods become clearer as you introduce more advanced capabilities.</span></span> <span data-ttu-id="2a1d5-158">Arabirimleri kullanmak, yetenekleri karıştırmanızı ve eşleştirmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-158">Using interfaces enables you to mix and match capabilities.</span></span> <span data-ttu-id="2a1d5-159">Ayrıca, her sınıf yazarının varsayılan uygulama ile özel bir uygulama arasında seçim yapma olanağı sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-159">It also enables each class author to choose between the default implementation and a custom implementation.</span></span> <span data-ttu-id="2a1d5-160">Yanıp sönen bir ışık için varsayılan uygulama içeren bir arabirim ekleyelim:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-160">Let's add an interface with a default implementation for a blinking light:</span></span>

[!code-csharp[Define the blinking light interface](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/IBlinkingLight.cs?name=SnippetBlinkingLight)]

<span data-ttu-id="2a1d5-161">Varsayılan uygulama herhangi bir ışığın yanıp sönmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-161">The default implementation enables any light to blink.</span></span> <span data-ttu-id="2a1d5-162">Genel akış ışığı varsayılan uygulamayı kullanarak hem zamanlayıcı hem de yanıp sönme özellikleri ekleyebilir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-162">The overhead light can add both timer and blink capabilities using the default implementation:</span></span>

[!code-csharp[Use the default blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/OverheadLight.cs?name=SnippetOverheadLight)]

<span data-ttu-id="2a1d5-163">Yeni bir ışık `LEDLight` türü, hem zamanlayıcı işlevini hem de doğrudan yanıp sönme işlevini destekler.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-163">A new light type, the `LEDLight` supports both the timer function and the blink function directly.</span></span> <span data-ttu-id="2a1d5-164">Bu ışık stili hem `ITimerLight` `IBlinkingLight` arabirimleri hem de `Blink` arabirimleri uygular ve yöntemi geçersiz kılar:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-164">This light style implements both the `ITimerLight` and `IBlinkingLight` interfaces, and overrides the `Blink` method:</span></span>

[!code-csharp[Override the blink function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/LEDLight.cs?name=SnippetLEDLight)]

<span data-ttu-id="2a1d5-165">A, `ExtraFancyLight` yanıp sönen ve zamanlayıcı işlevlerini doğrudan destekleyebilir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-165">An `ExtraFancyLight` might support both blink and timer functions directly:</span></span>

[!code-csharp[Override the blink and timer function](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ExtraFancyLight.cs?name=SnippetExtraFancyLight)]

<span data-ttu-id="2a1d5-166">Daha `HalogenLight` önce oluşturduğunuz yanıp sönme desteklemez.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-166">The `HalogenLight` you created earlier doesn't support blinking.</span></span> <span data-ttu-id="2a1d5-167">Bu nedenle, desteklenen `IBlinkingLight` arabirimler listesine eklemeyin.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-167">So, don't add the `IBlinkingLight` to the list of its supported interfaces.</span></span>

## <a name="detect-the-light-types-using-pattern-matching"></a><span data-ttu-id="2a1d5-168">Desen eşleştirmesini kullanarak ışık türlerini algılama</span><span class="sxs-lookup"><span data-stu-id="2a1d5-168">Detect the light types using pattern matching</span></span>

<span data-ttu-id="2a1d5-169">Sonra, biraz test kodu yazalım.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-169">Next, let's write some test code.</span></span> <span data-ttu-id="2a1d5-170">Hangi arabirimleri desteklediğini inceleyerek Bir ışığın yeteneklerini belirlemek için C#'ın [desen eşleştirme](../pattern-matching.md) özelliğinden yararlanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-170">You can make use of C#'s [pattern matching](../pattern-matching.md) feature to determine a light's capabilities by examining which interfaces it supports.</span></span>  <span data-ttu-id="2a1d5-171">Aşağıdaki yöntem, her ışığın desteklenen özelliklerini uygular:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-171">The following method exercises the supported capabilities of each light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetTestLightFunctions)]

<span data-ttu-id="2a1d5-172">Yönteminizdeki `Main` aşağıdaki kod, sırayla her ışık türünü oluşturur ve bu ışığı sınar:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-172">The following code in your `Main` method creates each light type in sequence and tests that light:</span></span>

[!code-csharp[Test a light's capabilities](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/Program.cs?name=SnippetMainMethod)]

## <a name="how-the-compiler-determines-best-implementation"></a><span data-ttu-id="2a1d5-173">Derleyici en iyi uygulamayı nasıl belirler?</span><span class="sxs-lookup"><span data-stu-id="2a1d5-173">How the compiler determines best implementation</span></span>

<span data-ttu-id="2a1d5-174">Bu senaryo, herhangi bir uygulama olmadan bir temel arabirim gösterir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-174">This scenario shows a base interface without any implementations.</span></span> <span data-ttu-id="2a1d5-175">`ILight` Arabirime bir yöntem eklemek yeni karmaşıklıklar sunar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-175">Adding a method into the `ILight` interface introduces new complexities.</span></span> <span data-ttu-id="2a1d5-176">Varsayılan arabirim yöntemlerini yöneten dil kuralları, birden çok türetilmiş arabirim uygulayan somut sınıflar üzerindeki etkiyi en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-176">The language rules governing default interface methods minimize the effect on the concrete classes that implement multiple derived interfaces.</span></span> <span data-ttu-id="2a1d5-177">Orijinal arabirimi, kullanımını nasıl değiştirdiğini göstermek için yeni bir yöntemle geliştirelim.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-177">Let's enhance the original interface with a new method to show how that changes its use.</span></span> <span data-ttu-id="2a1d5-178">Her gösterge ışığı, güç durumunu numaralandırılmış bir değer olarak bildirebilir:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-178">Every indicator light can report its power status as an enumerated value:</span></span>

[!code-csharp[Enumeration for power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetPowerStatus)]

<span data-ttu-id="2a1d5-179">Varsayılan uygulama AC güç varsayar:</span><span class="sxs-lookup"><span data-stu-id="2a1d5-179">The default implementation assumes AC power:</span></span>

[!code-csharp[Report a default power status](~/samples/snippets/csharp/tutorials/mixins-with-interfaces/ILight.cs?name=SnippetILightInterface)]

<span data-ttu-id="2a1d5-180">Bu `ExtraFancyLight` değişiklikler, `ILight` arabirim ve türetilmiş arabirimler için destek beyan `ITimerLight` `IBlinkingLight`etse de, temiz bir şekilde derlenir ve .</span><span class="sxs-lookup"><span data-stu-id="2a1d5-180">These changes compile cleanly, even though the `ExtraFancyLight` declares support for the `ILight` interface and both derived interfaces, `ITimerLight` and `IBlinkingLight`.</span></span> <span data-ttu-id="2a1d5-181">`ILight` Arabirimde bildirilen yalnızca bir "en yakın" uygulama vardır.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-181">There's only one "closest" implementation declared in the `ILight` interface.</span></span> <span data-ttu-id="2a1d5-182">Geçersiz kılma bildiren herhangi bir sınıf "en yakın" uygulama olur.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-182">Any class that declared an override would become the one "closest" implementation.</span></span> <span data-ttu-id="2a1d5-183">Önceki sınıflarda, diğer türemiş arabirimlerin üyelerini geçersiz kıldıran örnekler gördünüz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-183">You saw examples in the preceding classes that overrode the members of other derived interfaces.</span></span>

<span data-ttu-id="2a1d5-184">Birden çok türetilmiş arabirimde aynı yöntemi geçersiz kılmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-184">Avoid overriding the same method in multiple derived interfaces.</span></span> <span data-ttu-id="2a1d5-185">Bunu yapmak, bir sınıf her iki türemiş arabirimi de uyguladığında belirsiz bir yöntem çağrısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-185">Doing so creates an ambiguous method call whenever a class implements both derived interfaces.</span></span> <span data-ttu-id="2a1d5-186">Derleyici tek bir daha iyi yöntem seçemez, bu nedenle hata sorunu yayınlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-186">The compiler can't pick a single better method so it issues an error.</span></span> <span data-ttu-id="2a1d5-187">Örneğin, hem bir `IBlinkingLight` `ITimerLight` geçersiz kılma uygulanan `PowerStatus`ve `OverheadLight` uygulanan, daha belirli bir geçersiz kılma sağlamak gerekir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-187">For example, if both the `IBlinkingLight` and `ITimerLight` implemented an override of `PowerStatus`, the `OverheadLight` would need to provide a more specific override.</span></span> <span data-ttu-id="2a1d5-188">Aksi takdirde, derleyici iki türetilmiş arabirimdeki uygulamalar arasında seçim yapamaz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-188">Otherwise, the compiler can't pick between the implementations in the two derived interfaces.</span></span> <span data-ttu-id="2a1d5-189">Genellikle arabirim tanımlarını küçük tutarak ve tek bir özelliğe odaklanarak bu durumu önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-189">You can usually avoid this situation by keeping interface definitions small and focused on one feature.</span></span> <span data-ttu-id="2a1d5-190">Bu senaryoda, bir ışığın her yeteneği kendi arabirimidir; birden çok arabirim yalnızca sınıflar tarafından devralınır.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-190">In this scenario, each capability of a light is its own interface; multiple interfaces are only inherited by classes.</span></span>

<span data-ttu-id="2a1d5-191">Bu örnek, sınıflara karıştırılabilecek ayrı özellikler tanımlayabileceğiniz bir senaryo gösterir.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-191">This sample shows one scenario where you can define discrete features that can be mixed into classes.</span></span> <span data-ttu-id="2a1d5-192">Desteklenen işlevleri, bir sınıf destekleyen arabirimler bildirerek herhangi bir desteklenen işlevselliği bildirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-192">You declare any set of supported functionality by declaring which interfaces a class supports.</span></span> <span data-ttu-id="2a1d5-193">Sanal varsayılan arabirim yöntemlerinin kullanımı, sınıfların arabirim yöntemlerinin herhangi biri veya tümü için farklı bir uygulama kullanmasını veya tanımlamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-193">The use of virtual default interface methods enables classes to use or define a different implementation for any or all the interface methods.</span></span> <span data-ttu-id="2a1d5-194">Bu dil yeteneği, oluşturmakta olduğunuz gerçek dünya sistemlerini modellemek için yeni yollar sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-194">This language capability provides new ways to model the real-world systems you're building.</span></span> <span data-ttu-id="2a1d5-195">Varsayılan arabirim yöntemleri, bu özelliklerin sanal uygulamalarını kullanarak farklı özellikleri karıştırıp eşleştirebilecek ilgili sınıfları ifade etmek için daha net bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a1d5-195">Default interface methods provide a clearer way to express related classes that may mix and match different features using virtual implementations of those capabilities.</span></span>
