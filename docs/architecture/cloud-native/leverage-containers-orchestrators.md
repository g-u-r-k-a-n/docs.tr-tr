---
title: Kapsayıcılardan ve düzenleyicilerden yararlanma
description: Azure'da Docker Konteynerleri ve Kubernetes Orkestratörlerinden Yararlanma
ms.date: 06/30/2019
ms.openlocfilehash: 44b2fff8c9c88717d83e41a421b9817e2cc68135
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989044"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="74496-103">Kapsayıcılardan ve düzenleyicilerden yararlanma</span><span class="sxs-lookup"><span data-stu-id="74496-103">Leveraging containers and orchestrators</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="74496-104">Konteynerler ve orkestratörler, yekpare dağıtım yaklaşımlarında yaygın olan sorunları çözmek için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="74496-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="74496-105">Yekpare dağıtımlarla ilgili zorluklar</span><span class="sxs-lookup"><span data-stu-id="74496-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="74496-106">Geleneksel olarak, çoğu uygulama tek bir birim olarak dağıtılmıştır.</span><span class="sxs-lookup"><span data-stu-id="74496-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="74496-107">Bu tür uygulamalar monolit olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="74496-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="74496-108">Uygulamaları birden fazla modül veya derlemeden oluşsalar bile tek birim olarak dağıtmanın bu genel yaklaşımı, Şekil 3-1'de gösterildiği gibi yekpare mimari olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="74496-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![Yekpare mimari.](./media/monolithic-architecture.png)

<span data-ttu-id="74496-110">**Şekil 3-1**.</span><span class="sxs-lookup"><span data-stu-id="74496-110">**Figure 3-1**.</span></span> <span data-ttu-id="74496-111">Yekpare mimari.</span><span class="sxs-lookup"><span data-stu-id="74496-111">Monolithic architecture.</span></span>

<span data-ttu-id="74496-112">Basitlik avantajına sahip olmalarına rağmen, yekpare mimariler bir takım zorluklarla karşı karşıyadır:</span><span class="sxs-lookup"><span data-stu-id="74496-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployments"></a><span data-ttu-id="74496-113">Dağıtımlar</span><span class="sxs-lookup"><span data-stu-id="74496-113">Deployments</span></span>

<span data-ttu-id="74496-114">Yekpare uygulamalara dağıtım genellikle, yalnızca küçük bir modül değiştirilse bile, tüm uygulamanın yeniden başlatılmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="74496-114">Deploying to monolithic applications typically requires restarting the entire application, even if only one small module is being replaced.</span></span> <span data-ttu-id="74496-115">Uygulamayı barındıran makine sayısına bağlı olarak, bu dağıtımlar sırasında kapalı kalma süresine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-115">Depending on the number of machines hosting the application, this can result in downtime during deployments.</span></span>

### <a name="hosting"></a><span data-ttu-id="74496-116">Barındırma</span><span class="sxs-lookup"><span data-stu-id="74496-116">Hosting</span></span>

<span data-ttu-id="74496-117">Monolitik uygulamalar tamamen tek bir makine örneğinde barındırılır.</span><span class="sxs-lookup"><span data-stu-id="74496-117">Monolithic applications are hosted entirely on a single machine instance.</span></span> <span data-ttu-id="74496-118">Bu, dağıtılmış bir uygulamadaki herhangi bir modülün ihtiyaç duyduğundan daha yüksek özellikli donanım gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="74496-118">This may require higher-capability hardware than any module in a distributed application would need.</span></span> <span data-ttu-id="74496-119">Ayrıca, uygulamanın herhangi bir bölümü darboğaza dönüşürse, ölçeklendirmek için uygulamanın tamamının ek makine düğümlerine dağıtılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="74496-119">Also, if any part of the app becomes a bottleneck, the entire application must be deployed to additional machine nodes in order to scale out.</span></span>

### <a name="environment"></a><span data-ttu-id="74496-120">Ortam</span><span class="sxs-lookup"><span data-stu-id="74496-120">Environment</span></span>

<span data-ttu-id="74496-121">Monolitik uygulamalar genellikle varolan bir barındırma ortamına (işletim sistemi, yüklü çerçeveler, vb.) dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="74496-121">Monolithic applications are typically deployed into an existing hosting environment (operating system, installed frameworks, etc.).</span></span> <span data-ttu-id="74496-122">Bu ortam, uygulamanın geliştirildiği veya test edildiği ortamla eşleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="74496-122">This environment may not match the environment in which the application was developed or tested.</span></span> <span data-ttu-id="74496-123">Uygulamanın ortamındaki tutarsızlıklar, yekpare dağıtımlar için sık karşılaşılan bir sorun kaynağıdır.</span><span class="sxs-lookup"><span data-stu-id="74496-123">Inconsistencies in the application's environment are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="74496-124">Kaplin</span><span class="sxs-lookup"><span data-stu-id="74496-124">Coupling</span></span>

<span data-ttu-id="74496-125">Monolitik uygulamaların, uygulamanın farklı bölümleri ile uygulama ile çevresi arasında büyük bir bağlantı yada ması olasıdır.</span><span class="sxs-lookup"><span data-stu-id="74496-125">Monolithic applications are likely to have a great deal of coupling between different parts of the application, and between the application and its environment.</span></span> <span data-ttu-id="74496-126">Bu, belirli bir hizmeti veya endişeyi daha sonra, ölçeklenebilirliğini artırmak veya alternatif bir uygulamada takas etmek için hesaba katmayı zorlaştırabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-126">This can make it difficult to factor out a particular service or concern later, in order to increase its scalability or swap in an alternative implementation.</span></span> <span data-ttu-id="74496-127">Bu bağlantı aynı zamanda sistem değişiklikleri için çok daha büyük potansiyel etkilere yol açar, daha büyük uygulamalarda kapsamlı test gerektiren.</span><span class="sxs-lookup"><span data-stu-id="74496-127">This coupling also leads to much larger potential impacts for changes to the system, requiring extensive testing in larger applications.</span></span>

### <a name="technology-choice"></a><span data-ttu-id="74496-128">Teknoloji seçimi</span><span class="sxs-lookup"><span data-stu-id="74496-128">Technology choice</span></span>

<span data-ttu-id="74496-129">Monolitik uygulamalar bir birim olarak oluşturulur ve dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="74496-129">Monolithic applications are built and deployed as a unit.</span></span> <span data-ttu-id="74496-130">Bu basitlik ve tekdüzelik sunuyor ama yenilik için bir engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-130">This offers simplicity and uniformity but can be a barrier to innovation.</span></span> <span data-ttu-id="74496-131">Sistemdeki yeni bir özellik veya modül daha modern bir platform veya çerçeveye daha uygun olsa da, tutarlılık ve dağıtım kolaylığı açısından uygulamanın mevcut yaklaşımı kullanılarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-131">Although a new feature or module in the system might be better-suited to a more modern platform or framework, it's likely to be built using the application's current approach for the sake of consistency as well as ease of development and deployment.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="74496-132">Konteynerlerin ve orkestratörlerin faydaları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="74496-132">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="74496-133">Docker en popüler konteyner yönetimi ve görüntüleme platformudur ve Linux ve Windows'daki konteynerlerle hızlı bir şekilde çalışmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-133">Docker is the most popular container management and imaging platform and allows you to quickly work with containers on Linux and Windows.</span></span> <span data-ttu-id="74496-134">Kapsayıcılar, herhangi bir sistemde aynı şekilde çalışan ayrı ancak tekrarlanabilir uygulama ortamları sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-134">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="74496-135">Bu, bulut ayarı uygulamalarda uygulamaları ve uygulama bileşenlerini geliştirmek ve barındırmak için onları mükemmel hale getirir.</span><span class="sxs-lookup"><span data-stu-id="74496-135">This makes them perfect for developing and hosting applications and app components in cloud-native applications.</span></span> <span data-ttu-id="74496-136">Kapsayıcılar birbirinden izole edilir, bu nedenle aynı ana bilgisayar donanımındaki iki kapsayıcı, çakışmalara neden olan bağımlılıklar olmadan yazılımın ve hatta işletim sisteminin farklı sürümlerine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-136">Containers are isolated from one another, so two containers on the same host hardware can have different versions of software and even operating system installed, without the dependencies causing conflicts.</span></span>

<span data-ttu-id="74496-137">Dahası, kapsayıcılar kaynak denetimine denetlenebilir basit dosyalar tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="74496-137">What's more, containers are defined by simple files that can be checked into source control.</span></span> <span data-ttu-id="74496-138">Tam sunucuların aksine, güncellemeleri uygulamak veya ek hizmetler yüklemek için sık sık manuel çalışma gerektiren sanal makineler bile, konteyner altyapısı kolayca sürüm kontrollü olabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-138">Unlike full servers, even virtual machines, which frequently require manual work to apply updates or install additional services, container infrastructure can easily be version-controlled.</span></span> <span data-ttu-id="74496-139">Böylece, kapsayıcılarda çalışacak şekilde oluşturulmuş uygulamalar geliştirilebilir, sınanabilir ve otomatik araçlar kullanılarak bir yapı boru hattının parçası olarak dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-139">Thus, apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="74496-140">Konteynerler değişmez.</span><span class="sxs-lookup"><span data-stu-id="74496-140">Containers are immutable.</span></span> <span data-ttu-id="74496-141">Bir kapsayıcıtanımına sahip olduğunuzda, bu kapsayıcıyı yeniden oluşturabilirsiniz ve bu kapsayıcı tam olarak aynı şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="74496-141">Once you have the definition of a container, you can recreate that container and it will run exactly the same way.</span></span> <span data-ttu-id="74496-142">Bu değişmezlik, bileşen tabanlı tasarıma kendini verir.</span><span class="sxs-lookup"><span data-stu-id="74496-142">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="74496-143">Bir uygulamanın bazı bölümleri diğerleri kadar sık değişmiyorsa, en sık değişen bölümleri dağıtabilecekken neden uygulamanın tamamını yeniden dağıtın?</span><span class="sxs-lookup"><span data-stu-id="74496-143">If some parts of an application don't change as often as others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="74496-144">Bir uygulamanın farklı özellikleri ve çapraz kesme endişeleri ayrı birimlere ayrılabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-144">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="74496-145">Şekil 3-2, yekpare bir uygulamanın belirli özellikleri veya işlevleri atayarak kapsayıcılardan ve mikro hizmetlerden nasıl yararlanabileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="74496-145">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="74496-146">Uygulamanın kendisinde kalan işlevsellik de kapsayıcı olmuştur.</span><span class="sxs-lookup"><span data-stu-id="74496-146">The remaining functionality in the app itself has also been containerized.</span></span>

<span data-ttu-id="74496-147">![Arka uçta mikro hizmetleri kullanmak için yekpare bir uygulamayı kırmak. ](./media/breaking-up-monolith-with-backend-microservices.png)
 **Şekil 3-2**.</span><span class="sxs-lookup"><span data-stu-id="74496-147">![Breaking up a monolithic app to use microservices in the back end.](./media/breaking-up-monolith-with-backend-microservices.png)
**Figure 3-2**.</span></span> <span data-ttu-id="74496-148">Arka uçta mikro hizmetleri kullanmak için yekpare bir uygulamayı kırmak.</span><span class="sxs-lookup"><span data-stu-id="74496-148">Breaking up a monolithic app to use microservices in the back end.</span></span>

<span data-ttu-id="74496-149">Ayrı kapsayıcılar kullanılarak oluşturulmuş bulut tabanlı uygulamalar, bir uygulamayı gerektiği kadar veya az dağıtabilme özelliğinden yararlanır.</span><span class="sxs-lookup"><span data-stu-id="74496-149">Cloud-native apps built using separate containers benefit from the ability to deploy as much or as little of an application as needed.</span></span> <span data-ttu-id="74496-150">Tek tek hizmetler, her hizmete uygun kaynaklara sahip düğümler üzerinde barındırılabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-150">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="74496-151">Her hizmetin çalıştığı ortam değişmezdir, dev, test ve üretim arasında paylaşılabilir ve kolayca sürülebilir.</span><span class="sxs-lookup"><span data-stu-id="74496-151">The environment each service runs in is immutable, can be shared between dev, test, and production, and can easily be versioned.</span></span> <span data-ttu-id="74496-152">Uygulamanın farklı alanları arasında bağlantı açıkça aramalar veya iletiler arasında hizmetler arasında değil, monolit içinde zaman bağımlılıkları derlemek olarak oluşur.</span><span class="sxs-lookup"><span data-stu-id="74496-152">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="74496-153">Ve genel uygulamanın herhangi bir bölümü, uygulamanın geri kalanında değişiklik gerektirmeden bu özellik veya özellik için en mantıklı teknolojiyi seçebilir.</span><span class="sxs-lookup"><span data-stu-id="74496-153">And any given part of the overall app can choose the technology that makes the most sense for that feature or capability without requiring changes to the rest of the app.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="74496-154">Ölçeklemenin faydaları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="74496-154">What are the scaling benefits?</span></span>

<span data-ttu-id="74496-155">Konteynerler üzerine inşa edilen hizmetler, Kubernetes gibi düzenleme araçlarının sağladığı ölçekleme avantajlarından yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-155">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="74496-156">Tasarım kapları sadece kendilerini biliyorum.</span><span class="sxs-lookup"><span data-stu-id="74496-156">By design containers only know about themselves.</span></span> <span data-ttu-id="74496-157">Birlikte çalışması gereken birden çok kapsayıcıya sahip olmaya başladığınızda, bunları daha yüksek bir düzeyde düzenlemeye değebilir.</span><span class="sxs-lookup"><span data-stu-id="74496-157">Once you start to have multiple containers that need to work together, it can be worthwhile to organize them at a higher level.</span></span> <span data-ttu-id="74496-158">Çok sayıda kapsayıcıyı ve ağ yapılandırması gibi paylaşılan bağımlılıklarını organize etmek, orkestrasyon araçlarının günü kurtarmak için geldiği yerdir!</span><span class="sxs-lookup"><span data-stu-id="74496-158">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="74496-159">Kubernetes, konteyner uygulamalarının dağıtımını, ölçeklemesini ve yönetimini otomatikleştirmek için tasarlanmış bir konteyner düzenleme platformudur.</span><span class="sxs-lookup"><span data-stu-id="74496-159">Kubernetes is a container orchestration platform designed to automate deployment, scaling, and management of containerized applications.</span></span> <span data-ttu-id="74496-160">Kapsayıcı gruplarının üzerine bir soyutlama katmanı oluşturur ve bunları *bölmeler*halinde düzenler.</span><span class="sxs-lookup"><span data-stu-id="74496-160">It creates an abstraction layer on top of groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="74496-161">Bölmeler *düğüm*olarak adlandırılan işçi makinelerinde çalışır.</span><span class="sxs-lookup"><span data-stu-id="74496-161">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="74496-162">Tüm organize grup *küme*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="74496-162">The whole organized group is referred to as a *cluster*.</span></span> <span data-ttu-id="74496-163">Şekil 3-3 bir Kubernetes kümesinin farklı bileşenlerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="74496-163">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="74496-164">![Kubernetes küme bileşenleri. ](./media/kubernetes-cluster-components.png)
 **Şekil 3-3**.</span><span class="sxs-lookup"><span data-stu-id="74496-164">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="74496-165">Kubernetes küme bileşenleri.</span><span class="sxs-lookup"><span data-stu-id="74496-165">Kubernetes cluster components.</span></span>

<span data-ttu-id="74496-166">Kubernetes, talebi karşılamak için kümeleri ölçekleme için yerleşik destek lemiştir.</span><span class="sxs-lookup"><span data-stu-id="74496-166">Kubernetes has built-in support for scaling clusters to meet demand.</span></span> <span data-ttu-id="74496-167">Kapsayıcı mikro hizmetlerle birlikte, bulut yerel uygulamalara ihtiyaç duyulduğunda ve nerede ihtiyaç duyulduğunda ek kaynaklarla talepteki ani artışlara hızlı ve verimli bir şekilde yanıt verebilme olanağı sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-167">Combined with containerized micro-services, this provides cloud-native applications with the ability to quickly and efficiently respond to spikes in demand with additional resources when and where they're needed.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="74496-168">Bildirimsel karşı zorunluluk</span><span class="sxs-lookup"><span data-stu-id="74496-168">Declarative versus imperative</span></span>

<span data-ttu-id="74496-169">Kubernetes hem bildirimsel hem de zorunlu nesne yapılandırmadestekler.</span><span class="sxs-lookup"><span data-stu-id="74496-169">Kubernetes supports both declarative and imperative object configuration.</span></span> <span data-ttu-id="74496-170">Zorunlu yaklaşım, Kubernetes'e her adımda ne yapması gerektiğini söyleyen çeşitli komutlar çalıştırmayı içerir.</span><span class="sxs-lookup"><span data-stu-id="74496-170">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="74496-171">Bu görüntüyü *çalıştırın.*</span><span class="sxs-lookup"><span data-stu-id="74496-171">*Run* this image.</span></span> <span data-ttu-id="74496-172">Bu bölmeyi *silin.*</span><span class="sxs-lookup"><span data-stu-id="74496-172">*Delete* this pod.</span></span> <span data-ttu-id="74496-173">Bu bağlantı noktasını *ortaya çıkar.*</span><span class="sxs-lookup"><span data-stu-id="74496-173">*Expose* this port.</span></span> <span data-ttu-id="74496-174">Bildirimsel yaklaşımla, *ne yapmanız* yerine *ne istediğinizi* açıklayan bir yapılandırma dosyası kullanırsınız ve Kubernetes istenen bitiş durumuna ulaşmak için ne yapmanız gerektiğini bulur.</span><span class="sxs-lookup"><span data-stu-id="74496-174">With the declarative approach, you use a configuration file that describes *what you want* instead of *what to do* and Kubernetes figures out what to do to achieve the desired end state.</span></span> <span data-ttu-id="74496-175">Kümenizi zorunlu komutları kullanarak zaten yapılandırıldıysanız, 'yi kullanarak bir `kubectl get svc SERVICENAME -o yaml > service.yaml`bildirim bildirimi dışa aktarabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-175">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="74496-176">Bu, bunun gibi bir manifesto dosyası üretecektir:</span><span class="sxs-lookup"><span data-stu-id="74496-176">This will produce a manifest file like this one:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="74496-177">Bildirimsel yapılandırmayı kullanırken, yapılandırma dosyalarınızın bulunduğu klasöre karşı `kubectl diff -f FOLDERNAME` kullanarak bunları işlemeden önce yapılacak değişiklikleri önizleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-177">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="74496-178">Değişiklikleri uygulamak istediğinizden emin olduktan sonra `kubectl apply -f FOLDERNAME`çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="74496-178">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="74496-179">Bir `-R` klasör hiyerarşisi özyinelemeli olarak işlemek için ekleyin.</span><span class="sxs-lookup"><span data-stu-id="74496-179">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="74496-180">Hizmetlere ek olarak, *dağıtımlar*gibi diğer Kubernetes özellikleri için bildirimsel yapılandırma kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-180">In addition to services, you can use declarative configuration for other Kubernetes features, such as *deployments*.</span></span> <span data-ttu-id="74496-181">Bildirimsel dağıtımlar, küme kaynaklarını güncelleştirmek için dağıtım denetleyicileri tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="74496-181">Declarative deployments are used by deployment controllers to update cluster resources.</span></span> <span data-ttu-id="74496-182">Dağıtımlar yeni değişiklikleri kullanıma çıkarmak, daha fazla yükü desteklemek için ölçeklendirmek veya önceki bir düzeltmeye geri dönmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="74496-182">Deployments are used to roll out new changes, scale up to support more load, or roll back to a previous revision.</span></span> <span data-ttu-id="74496-183">Bir küme kararsızsa, bildirimsel dağıtımlar kümeyi otomatik olarak istenilen duruma geri getirmek için bir mekanizma sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-183">If a cluster is unstable, declarative deployments provide a mechanism for automatically bringing the cluster back to a desired state.</span></span>

<span data-ttu-id="74496-184">Bildirimsel yapılandırmanın kullanılması, altyapının uygulama koduyla birlikte iade edilebilen ve sürümlendirilebilen kod olarak temsil edilmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="74496-184">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="74496-185">Bu, kaynak denetimi değişikliklerine bağlı bir yapı ve dağıtım ardışık hattını kullanarak sürekli dağıtım için gelişmiş değişim denetimi ve daha iyi destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-185">This provides improved change control and better support for continuous deployment using a build and deploy pipeline tied to source control changes.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="74496-186">Konteynerler ve orkestrasyonlar için hangi senaryolar idealdir?</span><span class="sxs-lookup"><span data-stu-id="74496-186">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="74496-187">Aşağıdaki senaryolar kapsayıcılar ve orkestratörler kullanmak için idealdir.</span><span class="sxs-lookup"><span data-stu-id="74496-187">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="74496-188">Yüksek çalışma süresi ve ölçeklenebilirlik gerektiren uygulamalar</span><span class="sxs-lookup"><span data-stu-id="74496-188">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="74496-189">Yüksek çalışma süresi ve ölçeklenebilirlik gereksinimleri olan bireysel uygulamalar, mikro hizmetler, kapsayıcılar ve orkestratörler kullanarak bulut yerel mimariler için ideal adaylardır.</span><span class="sxs-lookup"><span data-stu-id="74496-189">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="74496-190">Bu uygulamalar, sürümlü ortamlar kullanılarak kaplarda geliştirilebilir, üretime geçmeden önce kapsamlı bir şekilde test edilebilir ve sıfır kesintiyle üretime dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-190">These applications can be developed in containers using versioned environments, can be extensively tested before going to production, and can be deployed to production with zero downtime.</span></span> <span data-ttu-id="74496-191">Kubernetes kümelerinin kullanımı, bu tür uygulamaların isteğe bağlı olarak ölçeklendirilebilmesini ve düğüm hatalarından otomatik olarak kurtarabilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-191">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="74496-192">Çok sayıda uygulama</span><span class="sxs-lookup"><span data-stu-id="74496-192">Large numbers of applications</span></span>

<span data-ttu-id="74496-193">Çok sayıda uygulamayı dağıtan ve daha sonra muhafaza etmesi gereken kuruluşlar kapsayıcılardan ve orkestratörlerden yararlanır.</span><span class="sxs-lookup"><span data-stu-id="74496-193">Organizations that deploy and must subsequently maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="74496-194">Kapsayıcı ortamlar ve Kubernetes kümeleri kurma ön çaba öncelikle sabit bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="74496-194">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="74496-195">Tek tek uygulamaları dağıtma, sürdürme ve güncelleştirmenin, bakımı gereken uygulama sayısına göre değişen bir maliyeti vardır.</span><span class="sxs-lookup"><span data-stu-id="74496-195">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications that must be maintained.</span></span> <span data-ttu-id="74496-196">Belirli bir oldukça az sayıda uygulamanın ötesinde, özel uygulamaları elle korumanın karmaşıklığı, kapsayıcılar ve orkestratörler kullanarak bir çözümü uygulama maliyetini aşıyor.</span><span class="sxs-lookup"><span data-stu-id="74496-196">Beyond a certain fairly small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="74496-197">Konteynerleri ve orkestratörleri kullanmaktan ne zaman kaçınmalısınız?</span><span class="sxs-lookup"><span data-stu-id="74496-197">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="74496-198">On iki faktörlü uygulama ilkelerine uygun olarak uygulamanızı oluşturmak istemiyor sanız veya yapamıyorsanız, konteynerlerden ve orkestratörlerden kaçınmanız daha iyi olacaktır.</span><span class="sxs-lookup"><span data-stu-id="74496-198">If you're unwilling or unable to build your application following Twelve-Factor App principles, you'll probably be better off avoiding containers and orchestrators.</span></span> <span data-ttu-id="74496-199">Bu gibi durumlarda, vm tabanlı bir barındırma platformu veya muhtemelen bazı işlevsellik parçalarını ayrı kapsayıcılara ve hatta sunucusuz işlevlere dönüştürebileceğiniz bir karma sistemle ilerlemek en iyisi olabilir.</span><span class="sxs-lookup"><span data-stu-id="74496-199">In these cases, it may be best to move forward with a VM-based hosting platform, or possibly some hybrid system in which you can spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="74496-200">Geliştirme kaynakları</span><span class="sxs-lookup"><span data-stu-id="74496-200">Development resources</span></span>

<span data-ttu-id="74496-201">Bu bölümde, bir sonraki uygulamanız için kapsayıcılar ve orkestratörler kullanmaya başlamanıza yardımcı olabilecek geliştirme kaynaklarının kısa bir listesi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="74496-201">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="74496-202">Bulut-yerel mikrohizmetler mimari uygulamanızı nasıl tasarladığınıza ilişkin rehberlik arıyorsanız, bu kitabın arkadaşı [.NET Microservices: Architecture for Containerized .NET Applications](https://aka.ms/microservicesebook)'ı okuyun.</span><span class="sxs-lookup"><span data-stu-id="74496-202">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://aka.ms/microservicesebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="74496-203">Yerel Kubernetes Geliştirme</span><span class="sxs-lookup"><span data-stu-id="74496-203">Local Kubernetes Development</span></span>

<span data-ttu-id="74496-204">Kubernetes dağıtımları üretim ortamlarında büyük değer sağlar, ancak bunları yerel olarak da çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-204">Kubernetes deployments provide great value in production environments, but you can also run them locally.</span></span> <span data-ttu-id="74496-205">Çoğu zaman bağımsız olarak tek tek uygulamalar veya mikro hizmetler üzerinde çalışabilmek iyi olsa da, bazen üretime dağıtıldığında çalışacağı gibi tüm sistemi yerel olarak çalıştırabilmek iyidir.</span><span class="sxs-lookup"><span data-stu-id="74496-205">Although much of the time it's good to be able to work on individual apps or microservices independently, sometimes it's good to be able to run the whole system locally just as it will run when deployed to production.</span></span> <span data-ttu-id="74496-206">Bunu başarmanın birkaç yolu vardır, bunlardan ikisi Minikube ve Docker Desktop'dır.</span><span class="sxs-lookup"><span data-stu-id="74496-206">There are several ways to achieve this, two of which are Minikube and Docker Desktop.</span></span> <span data-ttu-id="74496-207">Visual Studio ayrıca Docker gelişimi için takım sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-207">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="74496-208">Minikube</span><span class="sxs-lookup"><span data-stu-id="74496-208">Minikube</span></span>

<span data-ttu-id="74496-209">Minikube nedir?</span><span class="sxs-lookup"><span data-stu-id="74496-209">What is Minikube?</span></span> <span data-ttu-id="74496-210">Minikube projesi "Minikube macOS, Linux ve Windows'da yerel bir Kubernetes kümesini uyguluyor" diyor.</span><span class="sxs-lookup"><span data-stu-id="74496-210">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="74496-211">Birincil hedefleri "yerel Kubernetes uygulama geliştirme için en iyi araç olmak ve uygun tüm Kubernetes özelliklerini desteklemektir."</span><span class="sxs-lookup"><span data-stu-id="74496-211">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="74496-212">Minikube'yi yüklemek Docker'dan ayrıdır, ancak Minikube Docker Desktop'ın desteklediğinden farklı hipervizörleri destekler.</span><span class="sxs-lookup"><span data-stu-id="74496-212">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="74496-213">Aşağıdaki Kubernetes özellikleri şu anda Minikube tarafından desteklenir:</span><span class="sxs-lookup"><span data-stu-id="74496-213">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="74496-214">DNS</span><span class="sxs-lookup"><span data-stu-id="74496-214">DNS</span></span>
- <span data-ttu-id="74496-215">Düğüm Bağlantı Noktaları</span><span class="sxs-lookup"><span data-stu-id="74496-215">NodePorts</span></span>
- <span data-ttu-id="74496-216">ConfigMaps ve sırları</span><span class="sxs-lookup"><span data-stu-id="74496-216">ConfigMaps and secrets</span></span>
- <span data-ttu-id="74496-217">Panolar</span><span class="sxs-lookup"><span data-stu-id="74496-217">Dashboards</span></span>
- <span data-ttu-id="74496-218">Konteyner çalışma süreleri: Docker, rkt, CRI-O ve konteyner</span><span class="sxs-lookup"><span data-stu-id="74496-218">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="74496-219">Kapsayıcı Ağ Arabirimini Etkinleştirme (CNI)</span><span class="sxs-lookup"><span data-stu-id="74496-219">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="74496-220">Giriş</span><span class="sxs-lookup"><span data-stu-id="74496-220">Ingress</span></span>

<span data-ttu-id="74496-221">Minikube'yi yükledikten sonra, görüntüyü indiren `minikube start` komutu çalıştırarak hızlı bir şekilde kullanmaya başlayabilir ve yerel Kubernetes kümesini başlatabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-221">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="74496-222">Küme başlatıldıktan sonra, standart Kubernetes `kubectl` komutlarını kullanarak onunla etkileşime girebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-222">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="74496-223">Docker Masaüstü</span><span class="sxs-lookup"><span data-stu-id="74496-223">Docker Desktop</span></span>

<span data-ttu-id="74496-224">Ayrıca Windows'da Doğrudan Docker Desktop'dan Kubernetes ile de çalışabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-224">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="74496-225">Windows Kapsayıcıları kullanıyorsanız tek seçeneğiniz budur ve Windows olmayan kapsayıcılar için de mükemmel bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="74496-225">This is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="74496-226">Standart Docker Desktop yapılandırma uygulaması, Docker Desktop'tan çalışan Kubernetes'i yapılandırmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="74496-226">The standard Docker Desktop configuration app is used to configure Kubernetes running from Docker Desktop.</span></span>

![Docker Masaüstünde Kubernetes'i Yapılandırma](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="74496-228">**Şekil 3-4**.</span><span class="sxs-lookup"><span data-stu-id="74496-228">**Figure 3-4**.</span></span> <span data-ttu-id="74496-229">Docker Desktop'da Kubernetes'i yapılandırma.</span><span class="sxs-lookup"><span data-stu-id="74496-229">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="74496-230">Docker Desktop zaten yerel olarak kapsayıcı uygulamaları yapılandırmak ve çalıştırmak için en popüler araçtır.</span><span class="sxs-lookup"><span data-stu-id="74496-230">Docker Desktop is already the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="74496-231">Docker Desktop ile çalışırken, üretime dağıtacağınız Docker kapsayıcı görüntülerinin aynısını yerel olarak geliştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-231">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="74496-232">Docker Desktop, konteyner uygulamaları yerel olarak "oluşturmak, test etmek ve sevk etmek" için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="74496-232">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="74496-233">Görüntüler Azure Konteyner Kayıt Defteri veya Docker Hub gibi bir resim kayıt defterine gönderildikten sonra, Azure Kubernetes Service (AKS) gibi hizmetler üretimde uygulamayı yönetir.</span><span class="sxs-lookup"><span data-stu-id="74496-233">Once the images have been shipped to an image registry like Azure Container Registry or Docker Hub, then services like Azure Kubernetes Service (AKS) manage the application in production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="74496-234">Görsel Stüdyo Docker Takım</span><span class="sxs-lookup"><span data-stu-id="74496-234">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="74496-235">Visual Studio web uygulamaları için Docker geliştirme destekler.</span><span class="sxs-lookup"><span data-stu-id="74496-235">Visual Studio supports Docker development for web applications.</span></span> <span data-ttu-id="74496-236">Yeni bir ASP.NET Core uygulaması oluşturduğunuzda, şekil 3-5'te gösterildiği gibi, proje oluşturma sürecinin bir parçası olarak docker desteği ile yapılandırma seçeneği verilir.</span><span class="sxs-lookup"><span data-stu-id="74496-236">When you create a new ASP.NET Core application, you're given the option to configure it with Docker support as part of the project creation process, as shown in Figure 3-5.</span></span>

![Visual Studio Docker Desteği etkinleştirin](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="74496-238">**Şekil 3-5**.</span><span class="sxs-lookup"><span data-stu-id="74496-238">**Figure 3-5**.</span></span> <span data-ttu-id="74496-239">Visual Studio Docker Desteği etkinleştirin</span><span class="sxs-lookup"><span data-stu-id="74496-239">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="74496-240">Bu seçenek seçildiğinde, proje, uygulamayı `Dockerfile` docker kapsayıcısında oluşturmak ve barındırmak için kullanılabilecek kökünde bir ile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="74496-240">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="74496-241">Örnek Dockerfile Şekil 3-6'da gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="74496-241">An example Dockerfile is shown in Figure 3-6.</span></span>

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0-stretch AS build
WORKDIR /src
COPY ["WebApplication3/WebApplication3.csproj", "WebApplication3/"]
RUN dotnet restore "WebApplication3/WebApplication3.csproj"
COPY . .
WORKDIR "/src/WebApplication3"
RUN dotnet build "WebApplication3.csproj" -c Release -o /app

FROM build AS publish
RUN dotnet publish "WebApplication3.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication3.dll"]
```

<span data-ttu-id="74496-242">**Şekil 3-6**.</span><span class="sxs-lookup"><span data-stu-id="74496-242">**Figure 3-6**.</span></span> <span data-ttu-id="74496-243">Visual Studio Dockerfile oluşturulan</span><span class="sxs-lookup"><span data-stu-id="74496-243">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="74496-244">Uygulama çalıştığında varsayılan davranış Docker'ı da kullanacak şekilde yapılandırılır.</span><span class="sxs-lookup"><span data-stu-id="74496-244">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="74496-245">Şekil 3-7, Docker desteği ile oluşturulan yeni bir ASP.NET Core projesinden elde edilen farklı çalışma seçeneklerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="74496-245">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker Çalışma Seçenekleri](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="74496-247">**Şekil 3-7**.</span><span class="sxs-lookup"><span data-stu-id="74496-247">**Figure 3-7**.</span></span> <span data-ttu-id="74496-248">Visual Studio Docker Çalışma Seçenekleri</span><span class="sxs-lookup"><span data-stu-id="74496-248">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="74496-249">[Azure Geliştirme Alanları,](https://docs.microsoft.com/azure/dev-spaces/) yerel geliştirmeye ek olarak, birden çok geliştiricinin Azure'da kendi Kubernetes yapılandırmalarıyla çalışması için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="74496-249">In addition to local development, [Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="74496-250">Şekil 3-7'de de görebileceğiniz gibi, uygulamayı Azure Geliştirme Spaces'te de çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-250">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="74496-251">ASP.NET Core uygulamanıza Docker desteğini oluştururken eklemezseniz, her zaman daha sonra ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-251">If you don't add Docker support to your ASP.NET Core application when you create it, you can always add it later.</span></span> <span data-ttu-id="74496-252">Visual Studio Solution Explorer'dan projeye sağ tıklayın ve Şekil 3-8'de gösterildiği gibi**Docker Desteği** **Ekle'yi** > seçin.</span><span class="sxs-lookup"><span data-stu-id="74496-252">From the Visual Studio Solution Explorer, right click on the project and select **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio Docker Desteği Ekle](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="74496-254">**Şekil 3-8**.</span><span class="sxs-lookup"><span data-stu-id="74496-254">**Figure 3-8**.</span></span> <span data-ttu-id="74496-255">Visual Studio Docker Desteği Ekle</span><span class="sxs-lookup"><span data-stu-id="74496-255">Visual Studio Add Docker Support</span></span>

<span data-ttu-id="74496-256">Docker desteğine ek olarak, Şekil 3-8'de de gösterilen Konteyner Orkestrasyon Desteği'ni de ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74496-256">In addition to Docker support, you can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="74496-257">Varsayılan olarak, orkestratör Kubernetes ve Helm kullanır.</span><span class="sxs-lookup"><span data-stu-id="74496-257">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="74496-258">Orkestratörü seçtikten sonra, proje `azds.yaml` köküne bir dosya eklenir `charts` ve uygulamayı yapılandırmak ve Kubernetes'e dağıtmak için kullanılan Miğfer grafiklerini içeren bir klasör eklenir.</span><span class="sxs-lookup"><span data-stu-id="74496-258">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="74496-259">Şekil 3-9 yeni bir projede ortaya çıkan dosyaları gösterir.</span><span class="sxs-lookup"><span data-stu-id="74496-259">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio Ekle Orkestratör Desteği](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="74496-261">**Şekil 3-9**.</span><span class="sxs-lookup"><span data-stu-id="74496-261">**Figure 3-9**.</span></span> <span data-ttu-id="74496-262">Visual Studio Ekle Orkestratör Desteği</span><span class="sxs-lookup"><span data-stu-id="74496-262">Visual Studio Add Orchestrator Support</span></span>

## <a name="references"></a><span data-ttu-id="74496-263">Başvurular</span><span class="sxs-lookup"><span data-stu-id="74496-263">References</span></span>

- [<span data-ttu-id="74496-264">Kubernetes nedir?</span><span class="sxs-lookup"><span data-stu-id="74496-264">What is Kubernetes?</span></span>](https://blog.newrelic.com/engineering/what-is-kubernetes/)
- [<span data-ttu-id="74496-265">Minikube ile Kubernetes kurulumu</span><span class="sxs-lookup"><span data-stu-id="74496-265">Installing Kubernetes with Minikube</span></span>](https://kubernetes.io/docs/setup/learning-environment/minikube/)
- [<span data-ttu-id="74496-266">MiniKube vs Docker Masaüstü</span><span class="sxs-lookup"><span data-stu-id="74496-266">MiniKube vs Docker Desktop</span></span>](https://medium.com/containers-101/local-kubernetes-for-windows-minikube-vs-docker-desktop-25a1c6d3b766)
- [<span data-ttu-id="74496-267">Docker için Görsel Stüdyo Araçları</span><span class="sxs-lookup"><span data-stu-id="74496-267">Visual Studio Tools for Docker</span></span>](https://docs.microsoft.com/dotnet/standard/containerized-lifecycle-architecture/design-develop-containerized-apps/visual-studio-tools-for-docker)

>[!div class="step-by-step"]
><span data-ttu-id="74496-268">[Önceki](scale-applications.md)
>[Sonraki](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="74496-268">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
