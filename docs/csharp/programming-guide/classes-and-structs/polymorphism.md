---
title: Çok biçimlilik-C# Programlama Kılavuzu
description: Temel ve türetilmiş sınıflar arasındaki ilişkiyi açıklayan C# gibi nesne odaklı programlama dillerinde önemli bir kavram olan çok biçimlilik hakkında bilgi edinin.
ms.date: 02/08/2020
helpviewer_keywords:
- C# language, polymorphism
- polymorphism [C#]
ms.assetid: 086af969-29a5-4ce8-a993-0b7d53839dab
ms.openlocfilehash: 2a1ca4c498c5885c7d34475405ac83c4cccecd6f
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/21/2020
ms.locfileid: "86864130"
---
# <a name="polymorphism-c-programming-guide"></a><span data-ttu-id="97ab7-103">Çok Biçimlilik (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="97ab7-103">Polymorphism (C# Programming Guide)</span></span>

<span data-ttu-id="97ab7-104">Çok biçimlilik, kapsülleme ve devralma sonrasında nesne odaklı programlama için genellikle üçüncü olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-104">Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</span></span> <span data-ttu-id="97ab7-105">Çok biçimlilik, "çoktan şekillendirilmiş" anlamına gelen ve iki ayrı yönü bulunan bir Yunan kelimedir:</span><span class="sxs-lookup"><span data-stu-id="97ab7-105">Polymorphism is a Greek word that means "many-shaped" and it has two distinct aspects:</span></span>
  
- <span data-ttu-id="97ab7-106">Çalışma zamanında, türetilmiş bir sınıfın nesneleri Yöntem parametreleri ve koleksiyonlar ya da diziler gibi yerlerde bir temel sınıfın nesneleri olarak kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-106">At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays.</span></span> <span data-ttu-id="97ab7-107">Bu çok biçimlilik gerçekleştiğinde, nesnenin bildirildiği tür artık çalışma zamanı türüyle aynı değildir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-107">When this polymorphism occurs, the object's declared type is no longer identical to its run-time type.</span></span>
- <span data-ttu-id="97ab7-108">Temel sınıflar [sanal](../../language-reference/keywords/virtual.md) *yöntemleri*tanımlayabilir ve uygulayabilir ve türetilmiş sınıflar bunları [geçersiz kılabilir](../../language-reference/keywords/override.md) , bu da kendi tanım ve uygulamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="97ab7-108">Base classes may define and implement [virtual](../../language-reference/keywords/virtual.md) *methods*, and derived classes can [override](../../language-reference/keywords/override.md) them, which means they provide their own definition and implementation.</span></span> <span data-ttu-id="97ab7-109">Çalışma zamanında, istemci kodu yöntemi çağırdığında, CLR nesnenin çalışma zamanı türünü arar ve sanal yöntemin geçersiz kılmasını çağırır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-109">At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method.</span></span> <span data-ttu-id="97ab7-110">Kaynak kodunuzda bir temel sınıfta bir yöntemi çağırabilir ve türetilmiş sınıfın yönteminin yürütülmesine neden olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="97ab7-110">In your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.</span></span>

<span data-ttu-id="97ab7-111">Sanal yöntemler, ilişkili nesneler gruplarıyla tek bir şekilde çalışmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="97ab7-111">Virtual methods enable you to work with groups of related objects in a uniform way.</span></span> <span data-ttu-id="97ab7-112">Örneğin, bir kullanıcının çizim yüzeyinde çeşitli şekil türlerini oluşturmalarına olanak tanıyan bir çizim uygulamanız olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="97ab7-112">For example, suppose you have a drawing application that enables a user to create various kinds of shapes on a drawing surface.</span></span> <span data-ttu-id="97ab7-113">Kullanıcı tarafından oluşturulacak belirli şekil türlerini derleme sırasında bilemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="97ab7-113">You do not know at compile time which specific types of shapes the user will create.</span></span> <span data-ttu-id="97ab7-114">Bununla birlikte, uygulamanın oluşturulan çeşitli şekil türlerini izlemesi gerekir ve Kullanıcı fare eylemlerine yanıt olarak onları güncelleştirmek zorunda olur.</span><span class="sxs-lookup"><span data-stu-id="97ab7-114">However, the application has to keep track of all the various types of shapes that are created, and it has to update them in response to user mouse actions.</span></span> <span data-ttu-id="97ab7-115">Bu sorunu çözmek için iki temel adımda çok biçimlilik kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="97ab7-115">You can use polymorphism to solve this problem in two basic steps:</span></span>

1. <span data-ttu-id="97ab7-116">Her belirli şekil sınıfının ortak bir temel sınıftan türetildiği bir sınıf hiyerarşisi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="97ab7-116">Create a class hierarchy in which each specific shape class derives from a common base class.</span></span>
1. <span data-ttu-id="97ab7-117">Temel sınıf yöntemine tek bir çağrı aracılığıyla herhangi bir türetilmiş sınıfta uygun yöntemi çağırmak için bir sanal yöntem kullanın.</span><span class="sxs-lookup"><span data-stu-id="97ab7-117">Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.</span></span>

<span data-ttu-id="97ab7-118">İlk olarak, adlı bir temel sınıf `Shape` ve, ve gibi türetilmiş sınıflar `Rectangle` oluşturun `Circle` `Triangle` .</span><span class="sxs-lookup"><span data-stu-id="97ab7-118">First, create a base class called `Shape`, and derived classes such as `Rectangle`, `Circle`, and `Triangle`.</span></span> <span data-ttu-id="97ab7-119">`Shape`Sınıfa bir sanal yöntem verin `Draw` ve sınıfın temsil ettiği belirli şekli çizmek için her türetilmiş sınıfta bunu geçersiz kılın.</span><span class="sxs-lookup"><span data-stu-id="97ab7-119">Give the `Shape` class a virtual method called `Draw`, and override it in each derived class to draw the particular shape that the class represents.</span></span> <span data-ttu-id="97ab7-120">Bir `List<Shape>` nesne oluşturun ve bir `Circle` , `Triangle` , ve ekleyin `Rectangle` .</span><span class="sxs-lookup"><span data-stu-id="97ab7-120">Create a `List<Shape>` object and add a `Circle`, `Triangle`, and `Rectangle` to it.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#PolymorphismOverview)]

<span data-ttu-id="97ab7-121">Çizim yüzeyini güncelleştirmek için, listeyi yinelemek ve listedeki her bir nesnede yöntemi çağırmak için bir [foreach](../../language-reference/keywords/foreach-in.md) döngüsü kullanın `Draw` `Shape` .</span><span class="sxs-lookup"><span data-stu-id="97ab7-121">To update the drawing surface, use a [foreach](../../language-reference/keywords/foreach-in.md) loop to iterate through the list and call the `Draw` method on each `Shape` object in the list.</span></span> <span data-ttu-id="97ab7-122">Listedeki her nesnenin tanımlanmış bir türü olsa da `Shape` , çağrılacak çalışma zamanı türü (türetilmiş her sınıfta yöntemin geçersiz kılınan sürümü).</span><span class="sxs-lookup"><span data-stu-id="97ab7-122">Even though each object in the list has a declared type of `Shape`, it's the run-time type (the overridden version of the method in each derived class) that will be invoked.</span></span>

[!code-csharp[Polymorphism overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UsePolymorphism)]

<span data-ttu-id="97ab7-123">C# dilinde, Kullanıcı tanımlı türler dahil olmak üzere tüm türler öğesinden devraldığı için her tür polimorfik olur <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="97ab7-123">In C#, every type is polymorphic because all types, including user-defined types, inherit from <xref:System.Object>.</span></span>  

## <a name="polymorphism-overview"></a><span data-ttu-id="97ab7-124">Çok biçimlilik genel bakış</span><span class="sxs-lookup"><span data-stu-id="97ab7-124">Polymorphism overview</span></span>

### <a name="virtual-members"></a><span data-ttu-id="97ab7-125">Sanal üyeler</span><span class="sxs-lookup"><span data-stu-id="97ab7-125">Virtual members</span></span>

<span data-ttu-id="97ab7-126">Türetilmiş bir sınıf temel sınıftan devraldığında, temel sınıfın tüm yöntemlerini, alanlarını, özelliklerini ve olaylarını alır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-126">When a derived class inherits from a base class, it gains all the methods, fields, properties, and events of the base class.</span></span> <span data-ttu-id="97ab7-127">Türetilmiş sınıfın Tasarımcısı, Sanal yöntemlerin davranışı için farklı seçeneklere sahip olabilir:</span><span class="sxs-lookup"><span data-stu-id="97ab7-127">The designer of the derived class can different choices for the behavior of virtual methods:</span></span>

- <span data-ttu-id="97ab7-128">Türetilmiş sınıf, yeni davranışı tanımlayarak temel sınıftaki sanal üyeleri geçersiz kılabilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-128">The derived class may override virtual members in the base class, defining new behavior.</span></span>
- <span data-ttu-id="97ab7-129">Türetilmiş sınıf, var olan davranışı koruyarak ve daha fazla türetilmiş sınıfların yöntemi geçersiz kılmasını etkinleştirerek, en yakın temel sınıf yöntemini geçersiz kılmadan devralınır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-129">The derived class inherit the closest base class method without overriding it, preserving the existing behavior but enabling further derived classes to override the method.</span></span>
- <span data-ttu-id="97ab7-130">Türetilmiş sınıf, temel sınıf uygulamalarını gizleyen bu üyelerin sanal olmayan yeni uygulamasını tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-130">The derived class may define new non-virtual implementation of those members that hide the base class implementations.</span></span>

<span data-ttu-id="97ab7-131">Türetilmiş bir sınıf, yalnızca temel sınıf üyesi [sanal](../../language-reference/keywords/virtual.md) veya [soyut](../../language-reference/keywords/abstract.md)olarak bildirilirse bir temel sınıf üyesini geçersiz kılabilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-131">A derived class can override a base class member only if the base class member is declared as [virtual](../../language-reference/keywords/virtual.md) or [abstract](../../language-reference/keywords/abstract.md).</span></span> <span data-ttu-id="97ab7-132">Türetilmiş üye, metodun sanal çağrıya katılmayı amaçladığı kesin olarak belirtmek için [override](../../language-reference/keywords/override.md) anahtar sözcüğünü kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-132">The derived member must use the [override](../../language-reference/keywords/override.md) keyword to explicitly indicate that the method is intended to participate in virtual invocation.</span></span> <span data-ttu-id="97ab7-133">Aşağıdaki kod bir örnek sağlar:</span><span class="sxs-lookup"><span data-stu-id="97ab7-133">The following code provides an example:</span></span>

[!code-csharp[Virtual overview](~/samples/snippets/csharp/objectoriented/Inheritance.cs#VirtualMethods)]

<span data-ttu-id="97ab7-134">Alanlar sanal olamaz; yalnızca Yöntemler, özellikler, olaylar ve Dizin oluşturucular sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-134">Fields cannot be virtual; only methods, properties, events, and indexers can be virtual.</span></span> <span data-ttu-id="97ab7-135">Türetilmiş bir sınıf sanal üyeyi geçersiz kıldığında, bu üye, bu sınıfın bir örneği temel sınıfın bir örneği olarak erişildiği zaman bile çağırılır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-135">When a derived class overrides a virtual member, that member is called even when an instance of that class is being accessed as an instance of the base class.</span></span> <span data-ttu-id="97ab7-136">Aşağıdaki kod bir örnek sağlar:</span><span class="sxs-lookup"><span data-stu-id="97ab7-136">The following code provides an example:</span></span>

[!code-csharp[Virtual overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#SnippetTestVirtualMethods)]

<span data-ttu-id="97ab7-137">Sanal yöntemler ve özellikler, türetilmiş sınıfların bir yöntemin temel sınıf uygulamasını kullanmaya gerek kalmadan bir temel sınıfı genişletmesine imkan tanır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-137">Virtual methods and properties enable derived classes to extend a base class without needing to use the base class implementation of a method.</span></span> <span data-ttu-id="97ab7-138">Daha fazla bilgi için bkz. [geçersiz kılma ve yeni anahtar sözcüklerle sürüm oluşturma](./versioning-with-the-override-and-new-keywords.md).</span><span class="sxs-lookup"><span data-stu-id="97ab7-138">For more information, see [Versioning with the Override and New Keywords](./versioning-with-the-override-and-new-keywords.md).</span></span> <span data-ttu-id="97ab7-139">Bir arabirim, bir yöntemi veya uygulamasının türetilmiş sınıflara ayrılmakta olduğu yöntemler kümesini tanımlamak için başka bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="97ab7-139">An interface provides another way to define a method or set of methods whose implementation is left to derived classes.</span></span> <span data-ttu-id="97ab7-140">Daha fazla bilgi için bkz. [arabirimler](../interfaces/index.md).</span><span class="sxs-lookup"><span data-stu-id="97ab7-140">For more information, see [Interfaces](../interfaces/index.md).</span></span>

### <a name="hide-base-class-members-with-new-members"></a><span data-ttu-id="97ab7-141">Temel sınıf üyelerini yeni üyelerle gizle</span><span class="sxs-lookup"><span data-stu-id="97ab7-141">Hide base class members with new members</span></span>

<span data-ttu-id="97ab7-142">Türetilmiş sınıfınızın bir temel sınıftaki üye ile aynı ada sahip bir üyeye sahip olmasını istiyorsanız, temel sınıf üyesini gizlemek için [New](../../language-reference/keywords/new-modifier.md) anahtar sözcüğünü kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="97ab7-142">If you want your derived class to have a member with the same name as a member in a base class, you can use the [new](../../language-reference/keywords/new-modifier.md) keyword to hide the base class member.</span></span> <span data-ttu-id="97ab7-143">`new`Anahtar sözcüğü, değiştirilmekte olan bir sınıf üyesinin dönüş türünden önce konur.</span><span class="sxs-lookup"><span data-stu-id="97ab7-143">The `new` keyword is put before the return type of a class member that is being replaced.</span></span> <span data-ttu-id="97ab7-144">Aşağıdaki kod bir örnek sağlar:</span><span class="sxs-lookup"><span data-stu-id="97ab7-144">The following code provides an example:</span></span>

[!code-csharp[New method overview example](~/samples/snippets/csharp/objectoriented/Inheritance.cs#NewMethods)]

<span data-ttu-id="97ab7-145">Gizli temel sınıf üyelerine türetilmiş sınıfın örneğini bir temel sınıfın örneğine aktararak istemci kodundan erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-145">Hidden base class members may be accessed from client code by casting the instance of the derived class to an instance of the base class.</span></span> <span data-ttu-id="97ab7-146">Örnek:</span><span class="sxs-lookup"><span data-stu-id="97ab7-146">For example:</span></span>

[!code-csharp[New method overview usage](~/samples/snippets/csharp/objectoriented/Inheritance.cs#UseNewMethods)]

### <a name="prevent-derived-classes-from-overriding-virtual-members"></a><span data-ttu-id="97ab7-147">Türetilmiş sınıfların sanal üyeleri geçersiz kılmasını engelle</span><span class="sxs-lookup"><span data-stu-id="97ab7-147">Prevent derived classes from overriding virtual members</span></span>  

<span data-ttu-id="97ab7-148">Sanal üyeler, sanal üye ile ilk olarak tarafından tanımlanan sınıf arasında kaç sınıf bildirildiği dikkate almaksızın sanal olarak kalır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-148">Virtual members remain virtual, regardless of how many classes have been declared between the virtual member and the class that originally declared it.</span></span> <span data-ttu-id="97ab7-149">Sınıfı `A` bir sanal üye bildiriyorsa ve sınıfından türetilmiş sınıf ve sınıfından türetiliyor, sınıf `B` `A` `C` `B` `C` sanal üyeyi devralır ve sınıfın `B` Bu üye için bir geçersiz kılma olarak bildirilip bildirilmediğine bakılmaksızın onu geçersiz kılabilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-149">If class `A` declares a virtual member, and class `B` derives from `A`, and class `C` derives from `B`, class `C` inherits the virtual member, and may override it, regardless of whether class `B` declared an override for that member.</span></span> <span data-ttu-id="97ab7-150">Aşağıdaki kod bir örnek sağlar:</span><span class="sxs-lookup"><span data-stu-id="97ab7-150">The following code provides an example:</span></span>

[!code-csharp[Basic hierarchy](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#FirstHierarchy)]

<span data-ttu-id="97ab7-151">Türetilmiş bir sınıf, bir geçersiz kılma [korumalı](../../language-reference/keywords/sealed.md)olarak bildirerek sanal devralmayı durdurabilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-151">A derived class can stop virtual inheritance by declaring an override as [sealed](../../language-reference/keywords/sealed.md).</span></span> <span data-ttu-id="97ab7-152">Devralma durdurulduğunda, `sealed` `override` sınıf üye bildiriminde anahtar sözcükten önce anahtar sözcüğü koyulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-152">Stopping inheritance requires putting the `sealed` keyword before the `override` keyword in the class member declaration.</span></span> <span data-ttu-id="97ab7-153">Aşağıdaki kod bir örnek sağlar:</span><span class="sxs-lookup"><span data-stu-id="97ab7-153">The following code provides an example:</span></span>

[!code-csharp[A sealed overridden member](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#SealedOverride)]

<span data-ttu-id="97ab7-154">Önceki örnekte, yöntemi `DoWork` öğesinden türetilmiş hiçbir sınıf için artık sanal değildir `C` .</span><span class="sxs-lookup"><span data-stu-id="97ab7-154">In the previous example, the method `DoWork` is no longer virtual to any class derived from `C`.</span></span> <span data-ttu-id="97ab7-155">Türlerine `C` veya türüne saçılması durumunda bile, örnekleri için hala sanal olur `B` `A` .</span><span class="sxs-lookup"><span data-stu-id="97ab7-155">It's still virtual for instances of `C`, even if they're cast to type `B` or type `A`.</span></span> <span data-ttu-id="97ab7-156">Aşağıdaki örnekte gösterildiği gibi, korumalı Yöntemler, anahtar sözcüğü kullanılarak türetilmiş sınıflar tarafından değiştirilebilir `new` :</span><span class="sxs-lookup"><span data-stu-id="97ab7-156">Sealed methods can be replaced by derived classes by using the `new` keyword, as the following example shows:</span></span>

[!code-csharp[New method declaration](~/samples/snippets/csharp/objectoriented/Hierarchy.cs#NewDeclaration)]

<span data-ttu-id="97ab7-157">Bu durumda, `DoWork` `D` türünde bir değişken kullanılarak çağrılırsa `D` , yeni `DoWork` çağırılır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-157">In this case, if `DoWork` is called on `D` using a variable of type `D`, the new `DoWork` is called.</span></span> <span data-ttu-id="97ab7-158">Bir `C` `B` örneğine erişmek için, veya türünde bir değişken `A` kullanılırsa `D` , öğesine yapılan bir çağrı, `DoWork` sanal devralma kurallarını izleyerek bu çağrıları sınıfının uygulamasına yönlendirme `DoWork` `C` işlemini kullanır.</span><span class="sxs-lookup"><span data-stu-id="97ab7-158">If a variable of type `C`, `B`, or `A` is used to access an instance of `D`, a call to `DoWork` will follow the rules of virtual inheritance, routing those calls to the implementation of `DoWork` on class `C`.</span></span>

### <a name="access-base-class-virtual-members-from-derived-classes"></a><span data-ttu-id="97ab7-159">Türetilmiş sınıflardan temel sınıf sanal üyelerine erişin</span><span class="sxs-lookup"><span data-stu-id="97ab7-159">Access base class virtual members from derived classes</span></span>

<span data-ttu-id="97ab7-160">Bir yöntemi veya özelliği değiştirilmiş veya geçersiz kılan türetilmiş bir sınıf, anahtar sözcüğünü kullanarak temel sınıftaki yönteme veya özelliğe erişmeye devam edebilir `base` .</span><span class="sxs-lookup"><span data-stu-id="97ab7-160">A derived class that has replaced or overridden a method or property can still access the method or property on the base class using the `base` keyword.</span></span> <span data-ttu-id="97ab7-161">Aşağıdaki kod bir örnek sağlar:</span><span class="sxs-lookup"><span data-stu-id="97ab7-161">The following code provides an example:</span></span>

```csharp
public class Base
{
    public virtual void DoWork() {/*...*/ }
}
public class Derived : Base
{
    public override void DoWork()
    {
        //Perform Derived's work here
        //...
        // Call DoWork on base class
        base.DoWork();
    }
}
```

<span data-ttu-id="97ab7-162">Daha fazla bilgi için bkz. [Base](../../language-reference/keywords/base.md).</span><span class="sxs-lookup"><span data-stu-id="97ab7-162">For more information, see [base](../../language-reference/keywords/base.md).</span></span>

> [!NOTE]
> <span data-ttu-id="97ab7-163">Sanal üyelerin `base` kendi uygulamalarında bu üyenin temel sınıf uygulamasını çağırmak için kullanılması önerilir.</span><span class="sxs-lookup"><span data-stu-id="97ab7-163">It is recommended that virtual members use `base` to call the base class implementation of that member in their own implementation.</span></span> <span data-ttu-id="97ab7-164">Temel sınıf davranışının oluşmasına izin vermek, türetilmiş sınıfın türetilmiş sınıfa özgü davranış uygulamaya odaklanmalarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="97ab7-164">Letting the base class behavior occur enables the derived class to concentrate on implementing behavior specific to the derived class.</span></span> <span data-ttu-id="97ab7-165">Temel sınıf uygulama çağrılıp, davranışını temel sınıfın davranışıyla uyumlu hale getirmek için türetilmiş sınıfa kadar olur.</span><span class="sxs-lookup"><span data-stu-id="97ab7-165">If the base class implementation is not called, it is up to the derived class to make their behavior compatible with the behavior of the base class.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="97ab7-166">Bu bölümde</span><span class="sxs-lookup"><span data-stu-id="97ab7-166">In this section</span></span>

- [<span data-ttu-id="97ab7-167">Geçersiz Kılma ve Yeni Anahtar Sözcüklerle Sürüm Oluşturma</span><span class="sxs-lookup"><span data-stu-id="97ab7-167">Versioning with the Override and New Keywords</span></span>](./versioning-with-the-override-and-new-keywords.md)
- [<span data-ttu-id="97ab7-168">Geçersiz Kılmanın ve Yeni Anahtar Sözcüklerin Ne Zaman Kullanılacağını Bilme</span><span class="sxs-lookup"><span data-stu-id="97ab7-168">Knowing When to Use Override and New Keywords</span></span>](./knowing-when-to-use-override-and-new-keywords.md)
- [<span data-ttu-id="97ab7-169">ToString yöntemini geçersiz kılma</span><span class="sxs-lookup"><span data-stu-id="97ab7-169">How to override the ToString method</span></span>](./how-to-override-the-tostring-method.md)

## <a name="see-also"></a><span data-ttu-id="97ab7-170">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="97ab7-170">See also</span></span>

- [<span data-ttu-id="97ab7-171">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="97ab7-171">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="97ab7-172">Devralma</span><span class="sxs-lookup"><span data-stu-id="97ab7-172">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="97ab7-173">Soyut ve Korumalı Sınıflar ve Sınıf Üyeleri</span><span class="sxs-lookup"><span data-stu-id="97ab7-173">Abstract and Sealed Classes and Class Members</span></span>](./abstract-and-sealed-classes-and-class-members.md)
- [<span data-ttu-id="97ab7-174">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="97ab7-174">Methods</span></span>](./methods.md)
- [<span data-ttu-id="97ab7-175">Ekinlikler</span><span class="sxs-lookup"><span data-stu-id="97ab7-175">Events</span></span>](../events/index.md)
- [<span data-ttu-id="97ab7-176">Özellikler</span><span class="sxs-lookup"><span data-stu-id="97ab7-176">Properties</span></span>](./properties.md)
- [<span data-ttu-id="97ab7-177">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="97ab7-177">Indexers</span></span>](../indexers/index.md)
- [<span data-ttu-id="97ab7-178">Türler</span><span class="sxs-lookup"><span data-stu-id="97ab7-178">Types</span></span>](../types/index.md)
