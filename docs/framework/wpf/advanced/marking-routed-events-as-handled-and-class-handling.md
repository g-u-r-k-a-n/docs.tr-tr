---
title: Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400171"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
Yönlendirilen bir olayın işleyicileri olay verileri içinde işlenen olayı işaretleyebilir. Olayı işlemek rotayı etkili bir şekilde kısaltır. Sınıf işleme, yönlendirilen olaylar tarafından desteklenen bir programlama kavramıdır. Bir sınıf işleyicisi, sınıfın herhangi bir örneğinde herhangi bir örnek işleyiciönce çağrılan bir işleyici ile bir sınıf düzeyinde belirli bir yönlendirilmiş olay işlemek için fırsat vardır.  

<a name="prerequisites"></a>
## <a name="prerequisites"></a>Önkoşullar  
 Bu [konu, Yönlendirilen Olaylara Genel Bakış'ta](routed-events-overview.md)tanıtılan kavramlar üzerinde ayrıntılı bilgi vermektedir.  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a>Olaylar İşlenirken Ne Zaman İşaretlenir?  
 Yönlendirilen bir olay <xref:System.Windows.RoutedEventArgs.Handled%2A> için `true` olay verilerinde özelliğin değerini ayarladığınızda, buna "işlenen olayı işaretleme" adı verilir. Yönlendirilen olayları bir uygulama yazarı olarak veya varolan yönlendirilmiş olaylara yanıt veren veya yeni yönlendirilmiş olayları uygulayan bir denetim yazarı olarak, işlenmiş olarak işaretlemeniz gerektiğinde mutlak bir kural yoktur. Çoğunlukla, yönlendirilen etkinliğin olay verilerinde taşınan "ele alma" kavramı, kendi uygulamanızın API'lerde [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] maruz kalan çeşitli yönlendirilmiş olaylara verdiği yanıtlar ve özel yönlendirilmiş olaylar için sınırlı bir protokol olarak kullanılmalıdır. "İşlenen" sorunu değerlendirmenin başka bir yolu da, kodunuz yönlendirilmiş olaya önemli ve nispeten tam bir şekilde yanıt verdiyse, genellikle işlenen yönlendirilmiş bir olayı işaretlemeniz gerektiğidir. Genellikle, tek bir yönlendirilmiş olay oluşumu için ayrı işleyici uygulamaları gerektiren birden fazla önemli yanıt olmamalıdır. Daha fazla yanıt gerekiyorsa, gerekli kod, yönlendirme için yönlendirilen olay sistemini kullanmak yerine tek bir işleyici içinde zincirlenmiş uygulama mantığı aracılığıyla uygulanmalıdır. "Önemli" olan kavram da özneldir ve uygulamanıza veya kodunuza bağlıdır. Genel kılavuz olarak, bazı "önemli yanıt" örnekleri şunlardır: odak ayarlama, genel durumu değiştirme, görsel gösterimi etkileyen özellikleri ayarlama ve diğer yeni olayları yükseltmek. Önemsiz yanıtlara örnek olarak şunlar verilebilir: özel durumu (görsel etkisi olmadan veya programlı gösterim olmadan) değiştirmek, olayların günlüğe kaydedilmesi veya bir olayın bağımsız değişkenlerine bakma ve buna yanıt vermemeyi seçme.  
  
 Yönlendirilmiş olay sistemi davranışı, olay verilerinin zaten işlendiği yönlendirilmiş bir olaya yanıt olarak [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] eklenen işleyiciler <xref:System.Windows.UIElement.AddHandler%2A> veya ortak imza çağrıldığı için, yönlendirilmiş bir olayın işlenmiş durumunu kullanmak için bu "önemli yanıt" modelini güçlendirir. Olay rotasında önceki katılımcılar tarafından işlenen yönlendirilmiş olayları işlemek için `handledEventsToo` parametre sürümü ()<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>ile bir işleyici ekleme ekstra çaba geçmesi gerekir.  
  
 Bazı durumlarda, denetimler kendilerini işlenir gibi belirli yönlendirilmiş olayları işaretler. İşlenmiş bir yönlendirilmiş olay, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] denetim yazarlarının, denetimin yönlendirilen olaya yanıt olarak eylemlerinin denetim uygulamasının bir parçası olarak önemli veya eksiksiz olduğu ve olayın başka işleme gerek olmadığı yönündeki kararını temsil eder. Genellikle bu, bir olay için bir sınıf işleyicisi ekleyerek veya bir taban sınıf üzerinde var olan sınıf işleyicisanallarından birini geçersiz kılarak yapılır. Gerekirse bu olay işleme etrafında çalışmaya devam edebilirsiniz; Daha sonra bu konunun ilerleyen saatlerinde [Denetimler tarafından Olay Bastırma Etrafında Çalışma](#WorkingAroundEventSuppressionByControls) konusuna bakın.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>"Önizleme" (Tünelleme) Olaylar vs Bubbling Olaylar ve Olay Taşıma  
 Önizleme yönlendirilmiş olaylar, öğe ağacı nın içinden geçen bir tünel izleme yolunu izleyen olaylardır. Adlandırma kuralında ifade edilen "Önizleme", önizleme (tünel) yönlendirilen olayları önizlemenin (tünel) yönlendirilen olayların eşdeğer köpüren yönlendirilmiş olaydan önce yükseltildiği giriş olayları için genel ilkenin göstergesidir. Ayrıca, bir tünel ve köpüren çifti olan giriş yönlendirilmiş olaylar ayrı bir işleme mantığı var. Tünelleme/önizleme yönlendirilmiş olay bir olay dinleyicisi tarafından işlenir olarak işaretlenirse, köpüren yönlendirilmiş olay, köpüren yönlendirilmiş olayın dinleyicileri onu almadan önce bile işaretlenir. Tünel ve köpüren yönlendirilen olaylar teknik olarak ayrı olaylardır, ancak bu davranışı etkinleştirmek için olay verilerinin aynı örneğini kasıtlı olarak paylaşırlar.  
  
 Tünel leme ve yönlendirilen olayları köpürten olaylar arasındaki bağlantı, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] belirli bir sınıfın kendi bildirilen yönlendirilmiş olaylarını nasıl yükselttiğinin iç uygulamasıyla gerçekleştirilir ve bu, eşleştirilmiş giriş yönlendirilmiş olaylar için de geçerlidir. Ancak bu sınıf düzeyinde uygulama yoksa, bir tünel yönlendirilmiş olay ile adlandırma düzenini paylaşan köpüren yönlendirilmiş olay arasında bir bağlantı yoktur: böyle bir uygulama olmadan tamamen ayrı iki yönlendirilmiş olay olur ve sırayla yükseltilir veya olay verilerini paylaşır.  
  
 Özel bir sınıfta tünel/kabarcık giriş yönlendirilmiş olay çiftleri nasıl uygulanacağı hakkında daha fazla bilgi için [bkz.](how-to-create-a-custom-routed-event.md)  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a>Sınıf İşleyicileri ve Örnek İşleyiciler  
 Yönlendirilen olaylar, etkinliğe iki farklı dinleyici türünü göz önünde bulundur: sınıf dinleyicileri ve örnek dinleyiciler. Sınıf dinleyicileri vardır, çünkü <xref:System.Windows.EventManager> türler statik<xref:System.Windows.EventManager.RegisterClassHandler%2A>oluşturucularında belirli bir API'yi çağırmış veya bir öğe taban sınıfından sınıf işleyicisi sanal yöntemi geçersiz kalmıştır. Örnek dinleyiciler, bu yönlendirilen olay için bir veya daha fazla işleyicinin bir <xref:System.Windows.UIElement.AddHandler%2A>çağrı yla eklendiği belirli sınıf örnekleri/öğeleridir. [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Varolan yönlendirilmiş olaylar, ortak dil çalışma zamanı (CLR) olay sarıcının bir parçası <xref:System.Windows.UIElement.AddHandler%2A> olarak çağrılar yapar ve olayın uygulamalarını ekler{} ve kaldırır,{} bu da olay işleyicilerini bir öznitelik sözdizimi aracılığıyla bağlama nın basit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mekanizmasının nasıl etkinleştirildiğidir. Bu nedenle [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] bile basit kullanım sonuçta <xref:System.Windows.UIElement.AddHandler%2A> bir çağrı eşittir.  
  
 Görsel ağaç içindeki öğeler kayıtlı işleyici uygulamaları için denetlenir. İşleyiciler, yönlendirilen olay için yönlendirme stratejisinin türünde doğal olan sırada, rota boyunca çağrılır. Örneğin, köpüren yönlendirilmiş olaylar ilk olarak yönlendirilen olayı yükselten aynı öğeye bağlı işleyicileri çağırır. Daha sonra yönlendirilen olay "kabarcıklar" sonraki üst öğeye ve benzeri uygulama kök öğesi erişilene kadar.  
  
 Köpüren bir rotadaki kök öğeperspektifinden, sınıf işleme veya yönlendirilen olayın kaynağına daha yakın herhangi bir öğe, olay bağımsız değişkenlerini işlenen olarak işaretleyen işleyicileri çağırırsa, kök öğelerdeki işleyiciler çağrılmaz ve olay rotası bu kök öğeye ulaşmadan önce etkili bir şekilde kısaltılır. Ancak, bir sınıf işleyicisi veya örnek işleyicisi yönlendirilen olayı işlenmiş olarak işaretlemiş olsa bile, işleyiciler yine de çağrılması gereken özel bir koşullu kullanılarak eklenebileceğinden, rota tamamen durdurulamaz. Bu, [olaylar işlenirken bile yükseltilen Örnek İşleyiciler Ekleme'de](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)açıklanır , daha sonra bu konu.  
  
 Olay rotasından daha derin bir düzeyde, bir sınıfın belirli bir örneğinde etkili olabilecek birden çok sınıf işleyicileri de vardır. Bunun nedeni, yönlendirilen olaylar için sınıf işleme modelinin, her bir yönlendirilmiş olay için her sınıf işleyicisini kaydetmesi için sınıf hiyerarşisindeki tüm olası sınıfların olmasını sağlamasıdır. Her sınıf işleyicisi bir iç depoya eklenir ve bir uygulama için olay rotası oluşturulduğunda, sınıf işleyicilerinin tümü olay rotasına eklenir. Sınıf işleyicileri, en çok türetilmiş sınıf işleyicisi ilk çağrılacak şekilde rotaya eklenir ve sonraki her ardışık taban sınıftan sınıf işleyicileri çağrılır. Genel olarak, sınıf işleyicileri, zaten işlenmiş olarak işaretlenmiş yönlendirilmiş olaylara da yanıt verecek şekilde kaydedilmez. Bu nedenle, bu sınıf işleme mekanizması iki seçenekbirini sağlar:  
  
- Türemiş sınıflar, alınan işlem olayını işaretlemeyen bir işleyici ekleyerek taban sınıftan devralınan sınıf işlemeyi tamamlayabilir, çünkü taban sınıf işleyicisi türemiş sınıf işleyicisinden sonra çağrılacaktır.  
  
- Türemiş sınıflar, işlenen yönlendirilmiş olayı işaretleyen bir sınıf işleyicisi ekleyerek taban sınıftan sınıf işlemeyerini alabilir. Görsel görünüm, durum mantığı, giriş işleme ve komut işleme gibi alanlarda amaçlanan temel denetim tasarımını değiştirebileceğinden, bu yaklaşıma karşı dikkatli olmalısınız.  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Yönlendirilen Olayların Kontrol Taban Sınıfları tarafından Sınıf Yönetimi  
 Bir olay rotasında verilen her öğe düğümünde, sınıf dinleyicileri öğedeki herhangi bir örnek dinleyiciden önce yönlendirilen olaya yanıt verme fırsatına sahiptir. Bu nedenle, sınıf işleyicileri bazen belirli bir denetim sınıfı uygulaması nın daha fazla yaymak istemediği yönlendirilmiş olayları bastırmak veya sınıfın bir özelliği olan bu yönlendirilmiş olayın özel kullanımını sağlamak için kullanılır. Örneğin, bir sınıf, belirli bir sınıfın bağlamında bazı kullanıcı giriş koşulunun ne anlama geldiğini hakkında daha fazla ayrıntı içeren kendi sınıfa özgü olayı yükseltebilir. Sınıf uygulaması daha sonra daha genel yönlendirilmiş olayı işlenmiş olarak işaretleyebilir. Sınıf işleyicileri genellikle paylaşılan olay verilerinin zaten işlendiği yönlendirilmiş olaylar için çağrılmadıkları şekilde eklenir, ancak <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> atipik durumlarda, yönlendirilen olaylar işleildiğinde bile sınıf işleyicilerini çağırmak üzere kaydeden bir imza da vardır.  
  
### <a name="class-handler-virtuals"></a>Sınıf Işleyici Sanalları  
 Bazı öğeler, özellikle temel öğeler, <xref:System.Windows.UIElement>boş "On*Event" ve\*"OnPreview Event" gibi ortak yönlendirilmiş olaylar listesine karşılık gelen sanal yöntemleri ortaya çıkarır. Bu sanal yöntemler, bu yönlendirilen olay için bir sınıf işleyicisi uygulamak için geçersiz kılınabilir. Temel öğe sınıfları, daha önce açıklandığı gibi kullanarak <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> bu tür yönlendirilen her olay için bu sanal yöntemleri sınıf işleyicisi olarak kaydeder. On\*Event sanal yöntemleri, her tür için statik oluşturucularda özel başlatma gerektirmeden, ilgili yönlendirilen olaylar için sınıf işlemeyi uygulamayı çok daha kolaylaştırır. Örneğin, <xref:System.Windows.UIElement.OnDragEnter%2A> sanal yöntemi geçersiz kılarak, <xref:System.Windows.UIElement> türetilen herhangi bir <xref:System.Windows.UIElement.DragEnter> sınıftaolay için sınıf işleme ekleyebilirsiniz. Geçersiz kılma içinde, yönlendirilen olayı işleyebilir, diğer olayları yükseltebilir, örneklerdeki öğe özelliklerini veya bu eylemlerin herhangi bir birleşimini değiştirebilecek sınıfa özgü mantık başlatabilirsiniz. İşlenen olayı işaretleseniz bile genellikle bu tür geçersiz kılmalarda temel uygulamayı çağırmalısınız. Sanal yöntem taban sınıfta olduğundan, temel uygulamayı çağırmanın güçlü bir şekilde önerilir. Her sanal dan temel uygulamaları çağıran standart korumalı sanal desen aslında değiştirir ve bir sınıf hiyerarşisi tüm sınıflar için sınıf işleyicileri, yönlendirilmiş olay sınıfı işleme yerli benzer bir mekanizma en türetilmiş sınıfın işleyicisi ile başlayan ve taban sınıf işleyicisi devam eden, herhangi bir örnek çağırdı. Yalnızca sınıfınızın taban sınıf işleme mantığını değiştirmek için kasıtlı bir gereksinimi varsa temel uygulama çağrısını atlamalısınız. Geçersiz kılma kodunuzdan önce veya sonra temel uygulamayı arayıp aramadığınız, uygulamanızın niteliğine bağlıdır.  
  
#### <a name="input-event-class-handling"></a>Giriş Olay Sınıf Taşıma  
 Sınıf işleyicisanal yöntemlerinin tümü, yalnızca paylaşılan olay verilerinin zaten işlenmemiş olduğu durumlarda çağrılacak şekilde kaydedilir. Ayrıca, benzersiz giriş olayları için, tünel ve köpüren sürümleri genellikle sırayla yükseltilir ve olay verilerini paylaşır. Bu, biri tünel sürümü ve diğer köpüren sürümü olan giriş olayları sınıf işleyicileri belirli bir çift için, hemen ele olay işaretlemek istemeyebilirsiniz gerektirir. İşlenen olayı işaretlemek için tünel sınıfı işleme sanal yöntemini uygularsanız, bu köpüren sınıf işleyicisinin çağrılmasını önler (tünel leme veya köpürme olayı için normal olarak kayıtlı örnek işleyicileri önleme çağrılmaktadır).  
  
 Bir düğüm üzerinde sınıf işleme tamamlandıktan sonra, örnek dinleyiciler kabul edilir.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Olaylar İşaretlendiğinde Bile Yükseltilen Örnek İşleyiciler Ekleme  
 Yöntem, <xref:System.Windows.UIElement.AddHandler%2A> bir olay rotadaki işleme öğesine ulaştığında olay sistemi tarafından çağrılacak işleyiciler eklemenize olanak tanıyan belirli bir aşırı yük sağlar, ancak başka bir işleyici olay verilerini bu olayı işlenmiş olarak işaretlemek için zaten ayarlamış olsa bile. Bu genellikle yapılmaz. Genellikle, işleyiciler, birden çok son sonuç istense bile, bir öğenin bir öğede nerede işlendiğine bakılmaksızın, uygulama kodunun bir olaydan etkilenebilecek tüm alanlarını ayarlamak için yazılabilir. Ayrıca, genellikle bu olaya yanıt vermesi gereken tek bir öğe vardır ve uygun uygulama mantığı zaten gerçekleşmişti. Ancak `handledEventsToo` aşırı yük, bir öğe ağacındaki veya denetim birleştirme deki diğer bazı öğelerin zaten işlenmiş bir olayı işaretlediği istisnai durumlar için kullanılabilir, ancak öğe ağacındaki diğer öğeler (rotaya bağlı olarak) hala kendi işleyicilerinin çağrılmasını ister.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>İşlenmemiş Olarak İşlenme Olayları Ne Zaman İşaretlenir?  
 Genellikle, işlenen işaretli olaylar, üzerinde<xref:System.Windows.RoutedEventArgs.Handled%2A> `false` `handledEventsToo`hareket eden işleyiciler tarafından bile işlenmemiş (geri ayarlanmış) işaretlenmemelidir. Ancak, bazı giriş olayları, üst düzey olay ağaçta bir konumda ve başka bir konumda düşük düzey olay görüldüğünde çakışabilir üst düzey ve alt düzey olay gösterimleri vardır. Örneğin, bir alt öğenin üst öğe gibi <xref:System.Windows.UIElement.TextInput> <xref:System.Windows.UIElement.KeyDown>düşük düzeyli bir olayı dinlerken üst düzey bir önemli olayı dinlediği durumu göz önünde bulundurun. Üst öğe alt düzey olayı işlerse, üst düzey olay, olayı işlemek için sezgisel olarak ilk fırsatolması gereken alt öğede bile bastırılabilir.  
  
 Bu gibi durumlarda, alt düzey olay için hem üst öğelere hem de alt öğelere işleyiciler eklemek gerekebilir. Alt öğe işleyicisi uygulaması, alt düzey olayı işlenmiş olarak işaretleyebilir, ancak üst öğe işleyicisi uygulaması, ağacın diğer öğeleri (yanı sıra üst düzey olay) yanıt verme fırsatı olabilir, böylece yeniden işlenmemiş ayarlar. Bu durum oldukça nadir olmalıdır.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Kontrol Birleştirme Için Giriş Olaylarını Kasıtlı Olarak Bastırma  
 Yönlendirilen olayların sınıf işlemesinin kullanıldığı ana senaryo, giriş olayları ve birleştirilmiş denetimler içindir. Bileşik denetim, tanım gereği birden çok pratik denetim veya denetim taban sınıflarından oluşur. Denetimin yazarı genellikle, tüm denetimi tekil olay kaynağı olarak bildirmek için alt bileşenlerin her birinin yükseltebileceği olası giriş olaylarının tümünün biraraya getirmesini ister. Bazı durumlarda denetim yazarı olayları bileşenlerden tamamen bastırmak veya daha fazla bilgi taşıyan veya daha belirli bir davranışı ima eden bileşen tanımlı bir olayın yerine geçebilecek. Herhangi bir bileşen yazar tarafından hemen görülebilen [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> kanonik örnek, bir fare olayını nasıl işlediğive sonunda tüm <xref:System.Windows.Controls.Primitives.ButtonBase.Click> düğmelerin sahip olduğu sezgisel olaya nasıl çözüm verdiğidir: bir olay.  
  
 Temel <xref:System.Windows.Controls.Button> sınıf<xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Control> ( ) hangi sırayla türetilmiştir <xref:System.Windows.FrameworkElement> <xref:System.Windows.UIElement>ve , ve çok kontrol girişi işleme için gerekli <xref:System.Windows.UIElement> olay altyapısı düzeyinde kullanılabilir. Özellikle, <xref:System.Windows.UIElement> fare <xref:System.Windows.Input.Mouse> imlecini kendi sınırları içinde işleyen genel olayları işler ve <xref:System.Windows.UIElement.MouseLeftButtonDown>en yaygın düğme eylemleri için farklı olaylar sağlar. <xref:System.Windows.UIElement>ayrıca, önceden <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> kaydedilmiş sınıf işleyicisi <xref:System.Windows.UIElement.MouseLeftButtonDown>olarak <xref:System.Windows.Controls.Primitives.ButtonBase> boş bir sanal sağlar ve geçersiz kılar. Benzer şekilde, <xref:System.Windows.Controls.Primitives.ButtonBase> sınıf işleyicileri kullanır. <xref:System.Windows.UIElement.MouseLeftButtonUp> Olay verilerinden geçirilen geçersiz kılmalarda, uygulamalar bu <xref:System.Windows.RoutedEventArgs> örneği ayarlayarak <xref:System.Windows.RoutedEventArgs.Handled%2A> `true`işlenirken işaretler ve aynı olay verileri, diğer sınıf işleyicilerine ve ayrıca örnek işleyicilerine veya olay ayarlayıcılarına giden rotanın geri kalanı boyunca devam eden şeydir. Ayrıca, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> geçersiz kılma sonraki <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı yükseltecektir. Çoğu dinleyici için sonuç, <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> olayların "kaybolması" ve bunun <xref:System.Windows.Controls.Primitives.ButtonBase.Click>yerine, bu olayın düğmenin bir kısmı veya tamamen başka bir öğeden değil, gerçek bir düğmeden kaynaklandığı bilindiği için daha fazla anlam ifade eden bir olay la değiştirilecektir.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a>Denetimler tarafından Olay Bastırma Etrafında Çalışma  
 Bazen tek tek denetimler içindeki bu olay bastırma davranışı, uygulamanız için olay işleme mantığının daha genel amaçlarına engel olabilir. Örneğin, uygulamanızın uygulama kök öğesinde <xref:System.Windows.UIElement.MouseLeftButtonDown> bulunan bir işleyicisi nedense, bir düğmeye tıklayan farenin kök düzeyinde çağrıda bulunmayacağını veya <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> işleyicileri çağırmayacağını fark elabilirsiniz. Olayın kendisi aslında kabarcık yaptı (yine, olay yolları gerçekten sona ermedi, ancak yönlendirilen olay sistemi işleyici çağırma davranışını değiştirmektedir. Yönlendirilen olay düğmeye ulaştığında, <xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı daha <xref:System.Windows.UIElement.MouseLeftButtonDown> anlamlı bir şekilde değiştirmek istediği için sınıf işleme işlem işlem yerini işaretledi. Bu nedenle, <xref:System.Windows.UIElement.MouseLeftButtonDown> rotanın daha yukarısı herhangi bir standart işleyici çağrılmaz. İşleyicilerinizin bu durumda çağrılmasını sağlamak için kullanabileceğiniz iki teknik vardır.  
  
 İlk teknik, işleyiciyi imzasını `handledEventsToo` kullanarak kasten <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>eklemektir. Bu yaklaşımın bir sınırlama bir olay işleyicisi eklemek için bu teknik yalnızca kod değil, biçimlendirme mümkün olmasıdır. Olay işleyicisi adını olay özniteliği değeri üzerinden belirtmenin basit sözdizimi bu davranışı [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] etkinleştirmez.  
  
 İkinci teknik yalnızca, yönlendirilen olayın tünel ve köpüren sürümlerinin eşleştiği giriş olayları için çalışır. Bu yönlendirilen olaylar için, önizleme/tünel eşdeğeri yönlendirilmiş olaya işleyiciler ekleyebilirsiniz. Bu yönlendirilen olay kökten başlayarak rotadan tünel açacaktır, böylece düğme sınıfı işleme kodu, uygulamanın öğe ağacındaki bazı ata öğesi düzeyinde Önizleme işleyicisini taktığınızı varsayarak onu engellemez. Bu yaklaşımı kullanırsanız, işlenen herhangi bir Önizleme olayını işaretleme konusunda dikkatli olun. Kök öğede <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> ele alınması ile verilen örnekiçin, olay <xref:System.Windows.RoutedEventArgs.Handled%2A> işleyici uygulamasında olduğu gibi işaretlediyseniz, aslında <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı bastırırsınız. Bu genellikle arzu edilen bir davranış değildir.  
  
## <a name="see-also"></a>Ayrıca bkz.

- <xref:System.Windows.EventManager>
- [Önizleme Olayları](preview-events.md)
- [Özel Yönlendirilmiş Olay Oluşturma](how-to-create-a-custom-routed-event.md)
- [Gönderilmiş Olaylara Genel Bakış](routed-events-overview.md)
