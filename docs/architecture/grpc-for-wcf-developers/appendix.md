---
title: WCF geliştiricileri için ek-gRPC
description: Modern mikro hizmet mimarilerinde dağıtılmış işlemlerin ve bunların uygulamalarının tartışılması.
ms.date: 09/02/2019
ms.openlocfilehash: f60899463a13e9f740f6ae63150d18eab3069124
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91165864"
---
# <a name="appendix-a---transactions"></a><span data-ttu-id="27bcf-103">Ek A-Işlemler</span><span class="sxs-lookup"><span data-stu-id="27bcf-103">Appendix A - Transactions</span></span>

<span data-ttu-id="27bcf-104">Windows Communication Foundation (WCF) dağıtılmış işlemleri destekler ve birden çok hizmet arasında Atomik işlemler gerçekleştirmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="27bcf-104">Windows Communication Foundation (WCF) supports distributed transactions, allowing you to perform atomic operations across multiple services.</span></span> <span data-ttu-id="27bcf-105">Bu işlevsellik, [Microsoft Dağıtılmış işlem Düzenleyicisi](/previous-versions/windows/desktop/ms684146(v=vs.85))tabanlıdır.</span><span class="sxs-lookup"><span data-stu-id="27bcf-105">This functionality is based on the [Microsoft Distributed Transaction Coordinator](/previous-versions/windows/desktop/ms684146(v=vs.85)).</span></span>

<span data-ttu-id="27bcf-106">Daha yeni mikro hizmetler yataysa, bu tür otomatik dağıtılmış işlem işleme mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-106">In the newer microservices landscape, this type of automated distributed transaction processing isn't possible.</span></span> <span data-ttu-id="27bcf-107">İlişkisel veritabanları, NoSQL veri depoları ve mesajlaşma sistemleri dahil olmak üzere çok sayıda farklı teknoloji vardır.</span><span class="sxs-lookup"><span data-stu-id="27bcf-107">There are too many different technologies involved, including relational databases, NoSQL data stores, and messaging systems.</span></span> <span data-ttu-id="27bcf-108">Tek bir ortamda kullanımda olan işletim sistemleri, programlama dilleri ve çerçevelerin bir karışımı de olabilir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-108">There might also be a mix of operating systems, programming languages, and frameworks in use in a single environment.</span></span>

<span data-ttu-id="27bcf-109">WCF dağıtılmış işlem, [iki aşamalı işleme (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol)olarak bilinen işlemin bir uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="27bcf-109">WCF distributed transaction is an implementation of what is known as a [two-phase commit (2PC)](https://en.wikipedia.org/wiki/Two-phase_commit_protocol).</span></span> <span data-ttu-id="27bcf-110">Hizmetler genelinde iletileri koordine ederek, her bir hizmette açık işlemler oluşturarak ve başarılı veya başarısız olmasına bağlı olarak işleme veya geri alma iletileri göndererek, 2PC işlemlerini el ile uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="27bcf-110">You can implement 2PC transactions manually by coordinating messages across services, creating open transactions within each service, and sending commit or rollback messages, depending upon success or failure.</span></span> <span data-ttu-id="27bcf-111">Ancak, 2PC 'yi yönetme bölümünde yer alan karmaşıklık, sistemler geliştikçe üstel olarak artabilir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-111">However, the complexity involved in managing 2PC can increase exponentially as systems evolve.</span></span> <span data-ttu-id="27bcf-112">Açık işlemler, performansı olumsuz etkileyebilecek veya daha kötü bir hizmet kilitlenmesine neden olabilecek veritabanı kilitlerini tutar.</span><span class="sxs-lookup"><span data-stu-id="27bcf-112">Open transactions hold database locks that can negatively affect performance, or, worse, cause cross-service deadlocks.</span></span>

<span data-ttu-id="27bcf-113">Mümkünse, dağıtılmış işlemlerden tamamen kaçınmak en iyisidir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-113">If possible, it's best to avoid distributed transactions altogether.</span></span> <span data-ttu-id="27bcf-114">İki veri öğesi atomik güncelleştirmeler gerektirecek şekilde bağlanmışsa, bunları aynı hizmetle işlemeyi göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="27bcf-114">If two items of data are so linked as to require atomic updates, consider handling them both with the same service.</span></span> <span data-ttu-id="27bcf-115">Bu atomik değişiklikleri, bu hizmete tek bir istek veya ileti kullanarak uygulayın.</span><span class="sxs-lookup"><span data-stu-id="27bcf-115">Apply those atomic changes by using a single request or message to that service.</span></span>

<span data-ttu-id="27bcf-116">Bu mümkün değilse, tek bir alternatif, [Saga deseninin](https://microservices.io/patterns/data/saga.html)kullanılması olabilir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-116">If that isn't possible, then one alternative is to use the [Saga pattern](https://microservices.io/patterns/data/saga.html).</span></span> <span data-ttu-id="27bcf-117">Bir Saga 'de güncelleştirmeler sırayla işlenir; Her güncelleştirme başarılı olduğu için, bir sonraki tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-117">In a saga, updates are processed sequentially; as each update succeeds, the next one is triggered.</span></span> <span data-ttu-id="27bcf-118">Bu Tetikleyiciler hizmetten hizmete yayılamaz veya bir Saga Düzenleyicisi veya Orchestrator tarafından yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-118">These triggers can be propagated from service to service, or managed by a saga coordinator or orchestrator.</span></span> <span data-ttu-id="27bcf-119">İşlem sırasında herhangi bir noktada bir güncelleştirme başarısız olursa, güncelleştirmelerini zaten tamamlamış olan hizmetler bunları tersine çevirmek için özel mantık uygular.</span><span class="sxs-lookup"><span data-stu-id="27bcf-119">If an update fails at any point during the process, the services that have already completed their updates apply specific logic to reverse them.</span></span>

<span data-ttu-id="27bcf-120">Diğer bir seçenek de, [.net mikro hizmetleri e-defterinde](../microservices/microservice-ddd-cqrs-patterns/index.md)açıklandığı gibi etki alanı odaklı TASARıM (DDD) ve komut/sorgu sorumluluğu ayrımı (CQRS) kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="27bcf-120">Another option is to use Domain Driven Design (DDD) and Command/Query Responsibility Segregation (CQRS), as described in the [.NET Microservices e-book](../microservices/microservice-ddd-cqrs-patterns/index.md).</span></span> <span data-ttu-id="27bcf-121">Özellikle, etki alanı olaylarının veya [olay](https://martinfowler.com/eaaDev/EventSourcing.html) kaynağını kullanmanın kullanılması, güncelleştirmelerin sürekli olarak uygulanmadığından emin olmanıza yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="27bcf-121">In particular, using domain events or [event sourcing](https://martinfowler.com/eaaDev/EventSourcing.html) can help to ensure that updates are consistently, if not immediately, applied.</span></span>

>[!div class="step-by-step"]
>[<span data-ttu-id="27bcf-122">Önceki</span><span class="sxs-lookup"><span data-stu-id="27bcf-122">Previous</span></span>](application-performance-management.md)
