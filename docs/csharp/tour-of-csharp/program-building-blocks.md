---
title: C# programlarının yapı taşları "
description: C# üyeleri, ifadeler ve deyimler hakkında bilgi edinin. Türler yazdığınız üyeleri içerir. Bu Üyeler deyimlerden ve ifadelerden oluşturulur.
ms.date: 08/06/2020
ms.openlocfilehash: 142fe7b5a3424a8925638bfb4e4437392347f4c6
ms.sourcegitcommit: 0100be20fcf23f61dab672deced70059ed71bb2e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/17/2020
ms.locfileid: "88268146"
---
# <a name="program-building-blocks"></a><span data-ttu-id="d9aea-105">Program yapı taşları</span><span class="sxs-lookup"><span data-stu-id="d9aea-105">Program building blocks</span></span>

<span data-ttu-id="d9aea-106">Önceki makalede açıklanan türler, bu derleme blokları kullanılarak oluşturulmuştur: [***Üyeler***](../programming-guide/classes-and-structs/members.md), [ ***ifadeler***ve ***deyimler***](../programming-guide/statements-expressions-operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="d9aea-106">The types described in the previous article are built using these building blocks: [***members***](../programming-guide/classes-and-structs/members.md), [***expressions***, and ***statements***](../programming-guide/statements-expressions-operators/index.md).</span></span>

## <a name="members"></a><span data-ttu-id="d9aea-107">Üyeler</span><span class="sxs-lookup"><span data-stu-id="d9aea-107">Members</span></span>

<span data-ttu-id="d9aea-108">A üyeleri `class` ***statik Üyeler*** veya ***örnek üyeleridir***.</span><span class="sxs-lookup"><span data-stu-id="d9aea-108">The members of a `class` are either ***static members*** or ***instance members***.</span></span> <span data-ttu-id="d9aea-109">Statik Üyeler sınıflara aittir ve örnek üyeleri nesnelere aittir (sınıf örnekleri).</span><span class="sxs-lookup"><span data-stu-id="d9aea-109">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="d9aea-110">Aşağıdaki liste, bir sınıfın içerebileceği üye türlerine genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-110">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="d9aea-111">**Sabitler**: sınıfla ilişkili sabit değerler</span><span class="sxs-lookup"><span data-stu-id="d9aea-111">**Constants**: Constant values associated with the class</span></span>
- <span data-ttu-id="d9aea-112">**Alanlar**: sınıfıyla ilişkili değişkenler</span><span class="sxs-lookup"><span data-stu-id="d9aea-112">**Fields**:  Variables that are associated of the class</span></span>
- <span data-ttu-id="d9aea-113">**Yöntemler**: sınıfı tarafından gerçekleştirilebilecek eylemler</span><span class="sxs-lookup"><span data-stu-id="d9aea-113">**Methods**:  Actions that can be performed by the class</span></span>
- <span data-ttu-id="d9aea-114">**Özellikler**: sınıfının adlandırılmış özelliklerini okuma ve yazma ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="d9aea-114">**Properties**: Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="d9aea-115">**Dizin oluşturucular**: bir dizi gibi sınıfın dizin oluşturma örnekleri ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="d9aea-115">**Indexers**: Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="d9aea-116">**Olaylar**: sınıfı tarafından oluşturulabilecek bildirimler</span><span class="sxs-lookup"><span data-stu-id="d9aea-116">**Events**: Notifications that can be generated by the class</span></span>
- <span data-ttu-id="d9aea-117">**İşleçler**: sınıf tarafından desteklenen dönüşümler ve ifade işleçleri</span><span class="sxs-lookup"><span data-stu-id="d9aea-117">**Operators**: Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="d9aea-118">**Oluşturucular**: sınıf veya sınıf örneklerinin başlatılması için gereken eylemler</span><span class="sxs-lookup"><span data-stu-id="d9aea-118">**Constructors**: Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="d9aea-119">**Sonlandırıcılar**: sınıf örneklerinin kalıcı olarak atılmadan önce gerçekleştirilen eylemler</span><span class="sxs-lookup"><span data-stu-id="d9aea-119">**Finalizers**: Actions performed before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="d9aea-120">**Türler**: sınıf tarafından belirtilen iç içe türler</span><span class="sxs-lookup"><span data-stu-id="d9aea-120">**Types**: Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="d9aea-121">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="d9aea-121">Accessibility</span></span>

<span data-ttu-id="d9aea-122">Bir sınıfın her üyesinin ilişkili bir erişilebilirliği vardır ve bu, üyeye erişebilen program metni bölgelerini denetler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-122">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="d9aea-123">Olası altı erişilebilirlik biçimi vardır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-123">There are six possible forms of accessibility.</span></span> <span data-ttu-id="d9aea-124">Erişim değiştiriciler aşağıda özetlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-124">The access modifiers are summarized below.</span></span>

- <span data-ttu-id="d9aea-125">`public`: Erişim sınırlı değil.</span><span class="sxs-lookup"><span data-stu-id="d9aea-125">`public`: Access isn't limited.</span></span>
- <span data-ttu-id="d9aea-126">`private`: Erişim bu sınıfla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-126">`private`: Access is limited to this class.</span></span>
- <span data-ttu-id="d9aea-127">`protected`: Erişim bu sınıftan türetilmiş bu sınıf veya sınıflarla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-127">`protected`: Access is limited to this class or classes derived from this class.</span></span>
- <span data-ttu-id="d9aea-128">`internal`: Erişim geçerli derleme (veya) ile sınırlıdır `.exe` `.dll` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-128">`internal`: Access is limited to the current assembly (`.exe` or `.dll`).</span></span>
- <span data-ttu-id="d9aea-129">`protected internal`: Erişim bu sınıfla, bu sınıftan türetilmiş sınıflarla veya aynı derleme içindeki sınıflardan sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-129">`protected internal`: Access is limited to this class, classes derived from this class, or classes within the same assembly.</span></span>
- <span data-ttu-id="d9aea-130">`private protected`: Erişim bu sınıf veya aynı derleme içindeki bu türden türetilmiş sınıflarla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-130">`private protected`: Access is limited to this class or classes derived from this type within the same assembly.</span></span>

## <a name="fields"></a><span data-ttu-id="d9aea-131">Alanlar</span><span class="sxs-lookup"><span data-stu-id="d9aea-131">Fields</span></span>

<span data-ttu-id="d9aea-132">*Alan* , bir sınıf ile veya bir sınıf örneğiyle ilişkili bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-132">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="d9aea-133">Statik değiştiriciyle belirtilen bir alan statik bir alan tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-133">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="d9aea-134">Statik alan tam olarak bir depolama konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-134">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="d9aea-135">Bir sınıfın kaç örneğinin oluşturulduğuna bakılmaksızın, bir statik alanın yalnızca bir kopyası vardır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-135">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="d9aea-136">Statik değiştirici olmadan belirtilen bir alan bir örnek alanını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-136">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="d9aea-137">Bir sınıfın her örneği, bu sınıfın tüm örnek alanlarının ayrı bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-137">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="d9aea-138">Aşağıdaki örnekte, sınıfının her örneği `Color` ,, ve örnek alanlarının ayrı bir kopyasına sahiptir `r` `g` `b` , ancak,,, `Black` `White` `Red` `Green` ve `Blue` statik alanlarının yalnızca bir kopyası vardır:</span><span class="sxs-lookup"><span data-stu-id="d9aea-138">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ColorClassDefinition":::

<span data-ttu-id="d9aea-139">Önceki örnekte gösterildiği gibi, *salt okuma alanları* bir değiştirici ile bildirilebilecek `readonly` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-139">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="d9aea-140">Salt okunurdur bir alana atama, yalnızca alanın bildiriminin bir parçası olarak veya aynı sınıftaki bir Oluşturucu halinde gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-140">Assignment to a read-only field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="d9aea-141">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="d9aea-141">Methods</span></span>

<span data-ttu-id="d9aea-142">Bir *Yöntem* , bir nesne veya sınıf tarafından gerçekleştirilebilecek bir hesaplama veya eylem uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-142">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="d9aea-143">*Statik yöntemlere* sınıfı aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-143">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="d9aea-144">*Örnek yöntemlerine* , sınıfının örnekleri aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-144">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="d9aea-145">Metotlarda, metoda geçirilen değerleri veya değişken başvurularını temsil eden bir *parametre*listesi bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-145">Methods may have a list of *parameters*, which represent values or variable references passed to the method.</span></span> <span data-ttu-id="d9aea-146">Yöntemler, hesaplanan ve yöntemi tarafından döndürülen değerin türünü belirten bir *dönüş türüne*sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-146">Methods have a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="d9aea-147">Bir yöntemin dönüş türü `void` bir değer döndürmezse.</span><span class="sxs-lookup"><span data-stu-id="d9aea-147">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="d9aea-148">Türler gibi yöntemler de bir tür parametreleri kümesine sahip olabilir, bu da yöntem çağrıldığında tür bağımsız değişkenlerinin belirtilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-148">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="d9aea-149">Türlerin aksine, tür bağımsız değişkenleri genellikle yöntem çağrısının bağımsız değişkenlerinden çıkarsanamıyor ve açıkça verilmemelidir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-149">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="d9aea-150">Yöntemin *imzası* , yöntemin bildirildiği sınıfta benzersiz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-150">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="d9aea-151">Bir yöntemin imzası yöntemin adından, tür parametrelerinin sayısına ve parametrelerinin sayısına, değiştiricilerine ve türlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-151">The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="d9aea-152">Bir yöntemin imzası, dönüş türünü içermez.</span><span class="sxs-lookup"><span data-stu-id="d9aea-152">The signature of a method doesn't include the return type.</span></span>

<span data-ttu-id="d9aea-153">Bir yöntem gövdesi tek bir ifadesiyse, aşağıdaki örnekte gösterildiği gibi, yöntem bir Compact ifadesi biçimi kullanılarak tanımlanabilir:</span><span class="sxs-lookup"><span data-stu-id="d9aea-153">When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:</span></span>

```csharp
public override ToString() => "This is an object";
```

### <a name="parameters"></a><span data-ttu-id="d9aea-154">Parametreler</span><span class="sxs-lookup"><span data-stu-id="d9aea-154">Parameters</span></span>

<span data-ttu-id="d9aea-155">Parametreler, değerlere veya değişken başvurularını yöntemlere geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-155">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="d9aea-156">Bir yöntemin parametreleri, yöntemi çağrıldığında belirtilen *bağımsız değişkenlerden* gerçek değerlerini alır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-156">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="d9aea-157">Dört tür parametre vardır: değer parametreleri, başvuru parametreleri, çıkış parametreleri ve parametre dizileri.</span><span class="sxs-lookup"><span data-stu-id="d9aea-157">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="d9aea-158">Giriş bağımsız değişkenlerini geçirmek için bir *değer parametresi* kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-158">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="d9aea-159">Değer parametresi, parametresi için geçirilen bağımsız değişkenden ilk değerini alan yerel bir değişkene karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-159">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="d9aea-160">Değer parametresindeki değişiklikler, parametresi için geçirilen bağımsız değişkeni etkilemez.</span><span class="sxs-lookup"><span data-stu-id="d9aea-160">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="d9aea-161">Değer parametreleri, ilgili bağımsız değişkenlerin atlanabilmesi için varsayılan bir değer belirtilerek isteğe bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-161">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="d9aea-162">*Başvuru parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-162">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="d9aea-163">Başvuru parametresi için geçirilen bağımsız değişken, kesin bir değere sahip bir değişken olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-163">The argument passed for a reference parameter must be a variable with a definite value.</span></span> <span data-ttu-id="d9aea-164">Yöntemin yürütülmesi sırasında başvuru parametresi, bağımsız değişken değişkeniyle aynı depolama konumunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d9aea-164">During execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="d9aea-165">Bir başvuru parametresi değiştiriciyle birlikte bildirilmiştir `ref` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-165">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="d9aea-166">Aşağıdaki örnek parametrelerin kullanımını gösterir `ref` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-166">The following example shows the use of `ref` parameters.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RefExample":::

<span data-ttu-id="d9aea-167">Bir *output parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-167">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="d9aea-168">Bir başvuru parametresine benzer, ancak çağıran tarafından belirtilen bağımsız değişkene açıkça bir değer atamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="d9aea-168">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="d9aea-169">Bir çıkış parametresi değiştiriciyle birlikte bildirilmiştir `out` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-169">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="d9aea-170">Aşağıdaki örnek, `out` C# 7 ' de tanıtılan sözdizimi kullanılarak parametrelerin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-170">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="OutExample":::

<span data-ttu-id="d9aea-171">Bir *parametre dizisi* , bir metoda değişken sayıda bağımsız değişken geçirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-171">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="d9aea-172">Bir parametre dizisi değiştiriciyle birlikte bildirilmiştir `params` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-172">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="d9aea-173">Bir yöntemin yalnızca son parametresi bir parametre dizisi olabilir ve bir parametre dizisinin türü tek boyutlu bir dizi türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-173">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="d9aea-174">`Write`Sınıfının ve `WriteLine` yöntemleri, <xref:System.Console?displayProperty=nameWithType> parametre dizisi kullanımının iyi örnekleridir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-174">The `Write` and `WriteLine` methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="d9aea-175">Bunlar aşağıdaki şekilde bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-175">They're declared as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ConsoleExtract":::

<span data-ttu-id="d9aea-176">Bir parametre dizisi kullanan bir yöntem içinde, parametre dizisi tam olarak bir dizi türünün normal parametresine benzer şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-176">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="d9aea-177">Ancak, bir parametre dizisi olan bir yöntem çağrısında, parametre dizisi türünün tek bir bağımsız değişkenini veya parametre dizisinin öğe türünün herhangi bir sayıda bağımsız değişkenini geçirmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="d9aea-177">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="d9aea-178">İkinci durumda, bir dizi örneği otomatik olarak oluşturulur ve verilen bağımsız değişkenlerle başlatılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-178">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="d9aea-179">Bu örnek</span><span class="sxs-lookup"><span data-stu-id="d9aea-179">This example</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseParamsArgs":::

<span data-ttu-id="d9aea-180">, aşağıdaki yazma ile eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-180">is equivalent to writing the following.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CompilerParams":::

### <a name="method-body-and-local-variables"></a><span data-ttu-id="d9aea-181">Yöntem gövdesi ve yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="d9aea-181">Method body and local variables</span></span>

<span data-ttu-id="d9aea-182">Yöntemin gövdesi, yöntemi çağrıldığında yürütülecek deyimleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-182">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="d9aea-183">Yöntem gövdesi, yöntemi çağrısına özgü değişkenleri bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-183">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="d9aea-184">Bu tür değişkenlere *yerel değişkenler*denir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-184">Such variables are called *local variables*.</span></span> <span data-ttu-id="d9aea-185">Yerel bir değişken bildirimi bir tür adı, değişken adı ve muhtemelen bir başlangıç değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-185">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="d9aea-186">Aşağıdaki örnek, başlangıç değeri sıfır olan yerel bir değişken `i` ve ilk değeri olmayan bir yerel değişken bildirir `j` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-186">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="SquaresClass":::

<span data-ttu-id="d9aea-187">C# değeri alınabilmesi için önce bir yerel değişkenin *kesinlikle atanmasını* gerektirir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-187">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="d9aea-188">Örneğin, önceki bildirimi `i` bir başlangıç değeri içermiyorsa, `i` `i` programda bu noktalarda kesin olarak atanmadığı için derleyici daha sonraki kullanımları için bir hata bildirir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-188">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the later usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="d9aea-189">Bir yöntem `return` , çağrı yapana denetim döndürmek için deyimlerini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-189">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="d9aea-190">Döndürülen bir yöntemde `void` `return` deyimler bir ifade belirtemez.</span><span class="sxs-lookup"><span data-stu-id="d9aea-190">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="d9aea-191">Void olmayan bir yöntemde `return` deyim dönüş değerini hesaplayan bir ifade içermelidir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-191">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="d9aea-192">Statik ve örnek yöntemleri</span><span class="sxs-lookup"><span data-stu-id="d9aea-192">Static and instance methods</span></span>

<span data-ttu-id="d9aea-193">Değiştirici ile belirtilen bir yöntem `static` *statik bir yöntemdir*.</span><span class="sxs-lookup"><span data-stu-id="d9aea-193">A method declared with a `static` modifier is a *static method*.</span></span> <span data-ttu-id="d9aea-194">Statik bir yöntem, belirli bir örnek üzerinde çalışmaz ve yalnızca statik üyelere doğrudan erişebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-194">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="d9aea-195">Değiştirici olmadan bildirildiği bir yöntem `static` bir *örnek yöntemidir*.</span><span class="sxs-lookup"><span data-stu-id="d9aea-195">A method declared without a `static` modifier is an *instance method*.</span></span> <span data-ttu-id="d9aea-196">Örnek yöntemi, belirli bir örnek üzerinde çalışır ve hem statik hem de örnek üyelerine erişebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-196">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="d9aea-197">Örnek yönteminin çağrıldığı örnek, olarak açıkça erişilebilir `this` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-197">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="d9aea-198">Statik bir yöntemde başvurmak için bir hatadır `this` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-198">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="d9aea-199">Aşağıdaki `Entity` sınıfta hem statik hem de örnek üyeleri vardır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-199">The following `Entity` class has both static and instance members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="EntityClass":::

<span data-ttu-id="d9aea-200">Her `Entity` örnek bir seri numarası içerir (ve burada görünmeyen bazı diğer bilgileri kabul edilir).</span><span class="sxs-lookup"><span data-stu-id="d9aea-200">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="d9aea-201">`Entity`Oluşturucu (bir örnek yöntemi gibi) yeni örneği bir sonraki kullanılabilir seri numarasıyla başlatır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-201">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="d9aea-202">Oluşturucu bir örnek üyesi olduğundan, hem `_serialNo` örnek alanına hem de statik alana erişme izni vardır `s_nextSerialNo` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-202">Because the constructor is an instance member, it's permitted to access both the `_serialNo` instance field and the `s_nextSerialNo` static field.</span></span>

<span data-ttu-id="d9aea-203">`GetNextSerialNo`Ve `SetNextSerialNo` statik yöntemler `s_nextSerialNo` statik alana erişebilir, ancak örnek alanına doğrudan erişmesi için bir hata olabilir `_serialNo` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-203">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `s_nextSerialNo` static field, but it would be an error for them to directly access the `_serialNo` instance field.</span></span>

<span data-ttu-id="d9aea-204">Aşağıdaki örnek sınıfının kullanımını gösterir `Entity` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-204">The following example shows the use of the `Entity` class.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingEntity":::

<span data-ttu-id="d9aea-205">`SetNextSerialNo`Ve `GetNextSerialNo` statik yöntemler sınıfında çağrılır, ancak `GetSerialNo` örnek yöntemi sınıfının örneklerinde çağrılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-205">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="d9aea-206">Sanal, geçersiz kılma ve soyut yöntemler</span><span class="sxs-lookup"><span data-stu-id="d9aea-206">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="d9aea-207">Bir örnek yöntemi bildirimi bir değiştirici içerdiğinde `virtual` , yöntemi bir *sanal yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-207">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="d9aea-208">Bir sanal değiştirici yoksa, yöntem *sanal olmayan bir yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-208">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="d9aea-209">Bir sanal yöntem çağrıldığında, çağrının gerçekleştiği örneğin *çalışma zamanı türü* , çağrılacak gerçek Yöntem uygulamasını belirler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-209">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="d9aea-210">Sanal olmayan bir yöntem çağrısında, örneğin *derleme zamanı türü* belirleme faktörü olur.</span><span class="sxs-lookup"><span data-stu-id="d9aea-210">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="d9aea-211">Bir sanal yöntem, türetilmiş bir sınıfta *geçersiz kılınabilir* .</span><span class="sxs-lookup"><span data-stu-id="d9aea-211">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="d9aea-212">Bir örnek yöntemi bildirimi bir geçersiz kılma değiştiricisi içerdiğinde, yöntemi aynı imzaya sahip devralınmış bir sanal yöntemi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-212">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="d9aea-213">Aa sanal yöntem bildirimi yeni bir yöntem sunar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-213">Aa virtual method declaration introduces a new method.</span></span> <span data-ttu-id="d9aea-214">Bir geçersiz kılma yöntemi bildirimi, bu yöntemin yeni bir uygulamasını sağlayarak, var olan bir devralınmış sanal yöntemi uzmanlık eder.</span><span class="sxs-lookup"><span data-stu-id="d9aea-214">An override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="d9aea-215">*Soyut bir yöntem* , uygulama içermeyen bir sanal yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-215">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="d9aea-216">Soyut bir yöntem `abstract` değiştiriciyle tanımlanmış ve yalnızca bir soyut sınıfta izin verilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-216">An abstract method is declared with the `abstract` modifier and is permitted only in an abstract class.</span></span> <span data-ttu-id="d9aea-217">Soyut olmayan her türetilmiş sınıfta bir soyut yöntem geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-217">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="d9aea-218">Aşağıdaki örnek, `Expression` bir ifade ağaç düğümünü temsil eden bir soyut sınıfı ve `Constant` `VariableReference` `Operation` sabitler, değişken başvuruları ve aritmetik işlemler için ifade ağacı düğümleri uygulayan üç türetilmiş sınıfı,, ve ' ı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-218">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="d9aea-219">(Bu örnek, ifade ağacı türleriyle ilgili değildir ancak ile benzerdir).</span><span class="sxs-lookup"><span data-stu-id="d9aea-219">(This example is similar to, but not related to the expression tree types).</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="WorkingWithExpressions":::

<span data-ttu-id="d9aea-220">Önceki dört sınıf aritmetik ifadeleri modellemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-220">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="d9aea-221">Örneğin, bu sınıfların örneklerini kullanarak, ifadesi `x + 3` aşağıdaki gibi gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-221">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UseExpressions":::

<span data-ttu-id="d9aea-222">`Evaluate`Bir örneğin yöntemi, `Expression` verilen ifadeyi değerlendirmek ve bir değer üretmek için çağrılır `double` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-222">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="d9aea-223">Yöntemi, `Dictionary` değişken adlarını (girdilerin anahtarları olarak) ve değerlerini (girişlerin değerleri olarak) içeren bir bağımsız değişken alır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-223">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="d9aea-224">`Evaluate`Soyut bir yöntem olduğundan, öğesinden türetilen soyut olmayan sınıflar `Expression` geçersiz kılınmalıdır `Evaluate` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-224">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="d9aea-225">' `Constant` Nin uygulanması, `Evaluate` yalnızca saklı sabiti döndürür.</span><span class="sxs-lookup"><span data-stu-id="d9aea-225">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="d9aea-226">A `VariableReference` uygulamasının, sözlükte değişken adını arar ve elde edilen değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="d9aea-226">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="d9aea-227">Bir `Operation` uygulama ilk olarak sol ve sağ işlenenleri değerlendirir (yöntemlerini özyinelemeli olarak çağırarak `Evaluate` ) ve ardından verilen aritmetik işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-227">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="d9aea-228">Aşağıdaki program, `Expression` `x * (y + 2)` ve farklı değerleri için ifadeyi değerlendirmek için sınıflarını kullanır `x` `y` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-228">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="UsingExpressions":::

### <a name="method-overloading"></a><span data-ttu-id="d9aea-229">Yöntem aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="d9aea-229">Method overloading</span></span>

<span data-ttu-id="d9aea-230">Yöntem *aşırı yüklemesi* , aynı sınıftaki birden çok metodun benzersiz imzalara sahip oldukları sürece aynı ada sahip olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-230">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="d9aea-231">Aşırı yüklenmiş bir yöntemin çağrılması derlenirken, derleyici çağrılacak özel yöntemi belirlemekte *aşırı yükleme çözümü* kullanır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-231">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="d9aea-232">Aşırı yükleme çözümlemesi, bağımsız değişkenlerle en iyi eşleşen bir yöntemi bulur.</span><span class="sxs-lookup"><span data-stu-id="d9aea-232">Overload resolution finds the one method that best matches the arguments.</span></span> <span data-ttu-id="d9aea-233">Tek bir en iyi eşleşme bulunamazsa bir hata bildirilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-233">If no single best match can be found, an error is reported.</span></span> <span data-ttu-id="d9aea-234">Aşağıdaki örnekte, etkin olan aşırı yükleme çözümü gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-234">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="d9aea-235">Yöntemi içindeki her çağrının yorumu `UsageExample` hangi yöntemin çağrılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-235">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="Overloading":::

<span data-ttu-id="d9aea-236">Örnekte gösterildiği gibi belirli bir yöntem her zaman bağımsız değişkenleri tam parametre türlerine ve tür bağımsız değişkenlerine açıkça atayarak seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-236">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="d9aea-237">Diğer işlev üyeleri</span><span class="sxs-lookup"><span data-stu-id="d9aea-237">Other function members</span></span>

<span data-ttu-id="d9aea-238">Yürütülebilir kod içeren Üyeler topluca bir sınıfın *işlev üyeleri* olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-238">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="d9aea-239">Yukarıdaki bölümde, işlev üyelerinin birincil türleri olan yöntemler açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-239">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="d9aea-240">Bu bölümde C# tarafından desteklenen diğer işlev üyesi türleri açıklanmaktadır: oluşturucular, özellikler, Dizin oluşturucular, olaylar, işleçler ve sonlandırıcılar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-240">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="d9aea-241">Aşağıdaki örnek `MyList<T>` , bir nesne growable listesini uygulayan adlı bir genel sınıfı gösterir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-241">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="d9aea-242">Sınıfı, en yaygın işlev üyesi türlerine birkaç örnek içerir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-242">The class contains several examples of the most common kinds of function members.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListExample":::

### <a name="constructors"></a><span data-ttu-id="d9aea-243">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="d9aea-243">Constructors</span></span>

<span data-ttu-id="d9aea-244">C# hem örnek hem de statik oluşturucuları destekler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-244">C# supports both instance and static constructors.</span></span> <span data-ttu-id="d9aea-245">*Örnek Oluşturucu* , bir sınıfın örneğini başlatmak için gereken eylemleri uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-245">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="d9aea-246">*Statik Oluşturucu* , ilk yüklendiği zaman bir sınıfın kendisini başlatmak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-246">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="d9aea-247">Bir Oluşturucu, dönüş türü olmayan bir yöntem ve kapsayan sınıfla aynı adı ile birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-247">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="d9aea-248">Bir Oluşturucu bildiriminde bir değiştirici varsa `static` , bir statik oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-248">If a constructor declaration includes a `static` modifier, it declares a static constructor.</span></span> <span data-ttu-id="d9aea-249">Aksi takdirde, bir örnek Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-249">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="d9aea-250">Örnek oluşturucular aşırı yüklenebilir ve isteğe bağlı parametrelere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-250">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="d9aea-251">Örneğin, `MyList<T>` sınıfı tek bir isteğe bağlı parametre ile bir örnek Oluşturucu bildirir `int` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-251">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="d9aea-252">Örnek oluşturucular işleci kullanılarak çağrılır `new` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-252">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="d9aea-253">Aşağıdaki deyimler, `MyList<string>` `MyList` ve isteğe bağlı bağımsız değişken olmadan sınıfının oluşturucusunu kullanarak iki örnek ayırır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-253">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="CreateLists":::

<span data-ttu-id="d9aea-254">Diğer üyelerin aksine, örnek oluşturucular devralınmaz.</span><span class="sxs-lookup"><span data-stu-id="d9aea-254">Unlike other members, instance constructors aren't inherited.</span></span> <span data-ttu-id="d9aea-255">Bir sınıf, sınıfta gerçekten tanımlanmış olan oluşturuculardan başka örnek oluşturuculara sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-255">A class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="d9aea-256">Bir sınıf için örnek Oluşturucu sağlanmazsa, parametresi olmayan boş bir değer otomatik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-256">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="d9aea-257">Özellikler</span><span class="sxs-lookup"><span data-stu-id="d9aea-257">Properties</span></span>

<span data-ttu-id="d9aea-258">*Özellikler* , alanlar için doğal bir uzantıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-258">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="d9aea-259">Her ikisi de ilişkili türlerin bulunduğu isimlerdir ve alanlara ve özelliklere erişim için sözdizimi aynıdır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-259">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="d9aea-260">Ancak, alanların aksine, Özellikler depolama konumlarını göstermiyor.</span><span class="sxs-lookup"><span data-stu-id="d9aea-260">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="d9aea-261">Bunun yerine, özellikler, değerleri okunmak veya yazıldığında yürütülen deyimleri belirten *erişimcileri* vardır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-261">Instead, properties have *accessors* that specify the statements executed when their values are read or written.</span></span>

<span data-ttu-id="d9aea-262">Bir özellik, bildirim bir get erişimcisi ile sona erene veya sınırlayıcılar arasında yazılmış bir set erişimcisi ya da bir `{` noktalı virgülle bitmesi dışında, bir alan gibi tanımlanır `}` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-262">A property is declared like a field, except that the declaration ends with a get accessor or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="d9aea-263">Hem get erişimcisine hem de bir set erişimcisine sahip olan bir özellik *okuma-yazma özelliğidir*, yalnızca bir get erişimcisine sahip olan bir özellik *salt okunurdur*ve yalnızca bir set erişimcisi olan bir özellik yalnızca bir salt *yazılır özelliktir*.</span><span class="sxs-lookup"><span data-stu-id="d9aea-263">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="d9aea-264">Get erişimcisi, özellik türünün dönüş değeri olan parametresiz bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-264">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="d9aea-265">Bir set erişimcisi, value adlı tek parametreli ve dönüş türü olmayan bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-265">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="d9aea-266">Get erişimcisi özelliğin değerini hesaplar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-266">The get accessor computes the value of the property.</span></span> <span data-ttu-id="d9aea-267">Set erişimcisi, özelliği için yeni bir değer sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-267">The set accessor provides a new value for the property.</span></span> <span data-ttu-id="d9aea-268">Özellik bir atamanın hedefi ya da veya işleneni, `++` `--` set erişimcisi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-268">When the property is the target of an assignment, or the operand of `++` or `--`, the set accessor is invoked.</span></span> <span data-ttu-id="d9aea-269">Özelliğin başvurduğu diğer durumlarda, get erişimcisi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-269">In other cases where the property is referenced, the get accessor is invoked.</span></span>

 <span data-ttu-id="d9aea-270">Bir atamaya bir atama hedefi olarak veya + + veya--, işleneni olarak başvurulduğunda, yeni değer sağlayan bir bağımsız değişkenle çağrılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-270">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="d9aea-271">`MyList<T>`Sınıfı iki özellik bildirir `Count` ve `Capacity` sırasıyla salt okunurdur ve okuma-yazma olur.</span><span class="sxs-lookup"><span data-stu-id="d9aea-271">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="d9aea-272">Aşağıdaki kod, bu özelliklerin kullanım örneğidir:</span><span class="sxs-lookup"><span data-stu-id="d9aea-272">The following code is an example of use of these properties:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="AccessProperties":::

<span data-ttu-id="d9aea-273">Alanlar ve yöntemlere benzer şekilde C# hem örnek özelliklerini hem de statik özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-273">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="d9aea-274">Statik özellikler statik değiştirici ile tanımlanır ve örnek özellikleri bu olmadan tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-274">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="d9aea-275">Bir özelliğin erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-275">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="d9aea-276">Bir özellik bildirimi `virtual` ,, `abstract` veya değiştiricisini içerdiğinde, `override` özelliğin erişimcilerle geçerli olur.</span><span class="sxs-lookup"><span data-stu-id="d9aea-276">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="d9aea-277">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="d9aea-277">Indexers</span></span>

<span data-ttu-id="d9aea-278">*Dizin Oluşturucu* , nesnelerin diziyle aynı şekilde dizinlenmesini sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-278">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="d9aea-279">Bir Dizin Oluşturucu, üyenin adının `this` ardından sınırlayıcılar ve arasında yazılmış bir parametre listesi gelmesi dışında bir özellik gibi bildirilmiştir `[` `]` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-279">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="d9aea-280">Parametreler, dizin oluşturucunun erişimcisinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-280">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="d9aea-281">Özelliklere benzer şekilde, Dizin oluşturucular okunabilir-yazılır, salt okunurdur ve salt yazılır olabilir ve bir dizin oluşturucunun erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-281">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="d9aea-282">`MyList<T>`Sınıfı, bir parametresi alan tek bir okuma-yazma Dizin Oluşturucu bildirir `int` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-282">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="d9aea-283">Dizin Oluşturucu, örneklerin değerleriyle dizin oluşturmanızı mümkün kılar `MyList<T>` `int` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-283">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="d9aea-284">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="d9aea-284">For example:</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAccess":::

<span data-ttu-id="d9aea-285">Dizin oluşturucular aşırı yüklenebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-285">Indexers can be overloaded.</span></span> <span data-ttu-id="d9aea-286">Bir sınıf, parametrelerinin sayısı veya türleri farklı olduğu sürece birden çok Dizin Oluşturucu bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-286">A class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="d9aea-287">Ekinlikler</span><span class="sxs-lookup"><span data-stu-id="d9aea-287">Events</span></span>

<span data-ttu-id="d9aea-288">Bir *olay* , bir sınıf veya nesnenin bildirimler sağlamasını sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-288">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="d9aea-289">Bildirimin bir `event` anahtar sözcük içermesi ve türün bir temsilci türü olması dışında bir olay, bir alan gibi bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-289">An event is declared like a field except that the declaration includes an `event` keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="d9aea-290">Olay üyesini bildiren bir sınıf içinde, olay bir temsilci türünün alanı gibi davranır (olay soyut değildir ve erişimcileri bildirmez).</span><span class="sxs-lookup"><span data-stu-id="d9aea-290">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="d9aea-291">Bu alan, olaya eklenmiş olan olay işleyicilerini temsil eden bir temsilciye bir başvuru depolar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-291">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="d9aea-292">Hiçbir olay işleyicisi yoksa, alanı olur `null` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-292">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="d9aea-293">`MyList<T>`Sınıfı, adlı tek bir olay üyesini bildirir `Changed` ve bu, listeye yeni bir öğe eklendiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-293">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="d9aea-294">Değiştirilen olay `OnChanged` sanal yöntemi tarafından tetiklenir ve bu, önce olayın `null` (hiçbir işleyicinin mevcut olmadığı anlamına gelir) olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-294">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="d9aea-295">Bir olayı oluşturma kavramı, olay tarafından temsil edilen temsilciyi çağırmaya tam olarak eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-295">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event.</span></span> <span data-ttu-id="d9aea-296">Olayları yükseltmek için özel dil yapıları yoktur.</span><span class="sxs-lookup"><span data-stu-id="d9aea-296">There are no special language constructs for raising events.</span></span>

<span data-ttu-id="d9aea-297">İstemciler *olay işleyicileri*aracılığıyla olaylara tepki verir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-297">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="d9aea-298">Olay işleyicileri işleci kullanılarak eklenir `+=` ve işleci kullanılarak kaldırılır `-=` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-298">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="d9aea-299">Aşağıdaki örnek, olayına bir olay işleyicisi ekler `Changed` `MyList<string>` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-299">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="RespondToEvents":::

<span data-ttu-id="d9aea-300">Bir olayın temeldeki depolamanın denetiminin istendiği Gelişmiş senaryolarda, bir olay bildirimi açıkça sağlayabilir `add` ve `remove` Bu da `set` bir özelliğin erişimcisine benzer.</span><span class="sxs-lookup"><span data-stu-id="d9aea-300">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="d9aea-301">İşleçler</span><span class="sxs-lookup"><span data-stu-id="d9aea-301">Operators</span></span>

<span data-ttu-id="d9aea-302">*İşleci* , bir sınıfın örneklerine belirli bir ifade işlecini uygulamanın anlamını tanımlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-302">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="d9aea-303">Üç tür işleç tanımlanabilir: Birli İşleçler, ikili işleçler ve dönüştürme işleçleri.</span><span class="sxs-lookup"><span data-stu-id="d9aea-303">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="d9aea-304">Tüm işleçler ve olarak bildirilmelidir `public` `static` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-304">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="d9aea-305">`MyList<T>`Sınıfı iki işleç bildirir `operator ==` ve `operator !=` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-305">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`.</span></span> <span data-ttu-id="d9aea-306">Bu geçersiz kılınan operatörler, bu işleçleri örneklere uygulayan deyimlere yeni anlam verir `MyList` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-306">These overridden operators give new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="d9aea-307">Özellikle, işleçler, `MyList<T>` içerilen nesnelerin her birini yöntemlerini kullanarak karşılaştıran iki örneğin eşitliğini tanımlar `Equals` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-307">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their `Equals` methods.</span></span> <span data-ttu-id="d9aea-308">Aşağıdaki örnek, `==` iki örneği karşılaştırmak için işlecini kullanır `MyList<int>` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-308">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

:::code language="csharp" source="./snippets/shared/ClassesObjects.cs" ID="ListAddition":::

<span data-ttu-id="d9aea-309">Bu `Console.WriteLine` `True` iki liste aynı sırada aynı değerleri taşıyan aynı sayıda nesne içerdiğinden ilk çıktılar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-309">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="d9aea-310">`MyList<T>`Tanımlı değil `operator ==` , ilki `Console.WriteLine` çıktıyı içeriyor `False` `a` ve `b` farklı örneklere başvuracaktır `MyList<int>` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-310">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="d9aea-311">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="d9aea-311">Finalizers</span></span>

<span data-ttu-id="d9aea-312">*Sonlandırıcı* , bir sınıfın örneğini tamamlamak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-312">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="d9aea-313">Genellikle, yönetilmeyen kaynakları serbest bırakmak için sonlandırıcının olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-313">Typically, a finalizer is needed to release unmanaged resources.</span></span> <span data-ttu-id="d9aea-314">Sonlandırıcılar parametrelere sahip olamaz, erişilebilirlik değiştiricilerine sahip olamaz ve açıkça çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="d9aea-314">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="d9aea-315">Örnek için Sonlandırıcı çöp toplama sırasında otomatik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-315">The finalizer for an instance is invoked automatically during garbage collection.</span></span> <span data-ttu-id="d9aea-316">Daha fazla ayrıntı için [sonlandırıcılar](../programming-guide/classes-and-structs/destructors.md)hakkındaki makaleye bakın.</span><span class="sxs-lookup"><span data-stu-id="d9aea-316">For more details, see the article on [finalizers](../programming-guide/classes-and-structs/destructors.md).</span></span>

<span data-ttu-id="d9aea-317">Çöp toplayıcısına, nesnelerin toplanması ve Sonlandırıcıların ne zaman toplanacağına karar verirken geniş bir enlem vardır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-317">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="d9aea-318">Özellikle, Sonlandırıcı çağırma zamanlaması belirleyici değildir ve herhangi bir iş parçacığında sonlandırıcılar çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-318">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="d9aea-319">Bu ve diğer nedenlerden dolayı sınıfların yalnızca başka hiçbir çözüm uygulanabilir olmadığında sonlandırıcılar uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-319">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="d9aea-320">`using`İfade, nesne yok etme için daha iyi bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-320">The `using` statement provides a better approach to object destruction.</span></span>

## <a name="expressions"></a><span data-ttu-id="d9aea-321">İfadeler</span><span class="sxs-lookup"><span data-stu-id="d9aea-321">Expressions</span></span>

<span data-ttu-id="d9aea-322">*İfadeler* , *işlenenler* ve *işleçlerden*oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="d9aea-322">*Expressions* are constructed from *operands* and *operators*.</span></span> <span data-ttu-id="d9aea-323">Bir ifadenin işleçleri, işlenenlerin hangi işlemleri uygulanacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-323">The operators of an expression indicate which operations to apply to the operands.</span></span> <span data-ttu-id="d9aea-324">İşleç örnekleri,, `+` , `-` `*` ve içerir `/` `new` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-324">Examples of operators include `+`, `-`, `*`, `/`, and `new`.</span></span> <span data-ttu-id="d9aea-325">İşlenenlerin örnekleri, sabit değerleri, alanları, yerel değişkenleri ve ifadeleri içerir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-325">Examples of operands include literals, fields, local variables, and expressions.</span></span>

<span data-ttu-id="d9aea-326">Bir ifade birden çok işleç içerdiğinde işleçlerin *önceliği*, her bir işlecin değerlendirilme sırasını denetler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-326">When an expression contains multiple operators, the *precedence* of the operators controls the order in which the individual operators are evaluated.</span></span> <span data-ttu-id="d9aea-327">Örneğin, `x + y * z` `x + (y * z)` `*` işleç işleçten daha yüksek önceliğe sahip olduğu için ifade değerlendirilir `+` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-327">For example, the expression `x + y * z` is evaluated as `x + (y * z)` because the `*` operator has higher precedence than the `+` operator.</span></span>

<span data-ttu-id="d9aea-328">Aynı önceliğe sahip iki işleç arasında bir işlenen gerçekleştiğinde, işleçlerin *ilişkilendirilebilirliği* , işlemlerin gerçekleştirileceği sırayı denetler:</span><span class="sxs-lookup"><span data-stu-id="d9aea-328">When an operand occurs between two operators with the same precedence, the *associativity* of the operators controls the order in which the operations are performed:</span></span>

* <span data-ttu-id="d9aea-329">Atama ve null birleşim işleçleri hariç olmak üzere tüm ikili işleçler *sola ilişkilendirilebilir*, yani işlemler soldan sağa yapılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-329">Except for the assignment and null-coalescing operators, all binary operators are *left-associative*, meaning that operations are performed from left to right.</span></span> <span data-ttu-id="d9aea-330">Örneğin, `x + y + z` olarak değerlendirilir `(x + y) + z` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-330">For example, `x + y + z` is evaluated as `(x + y) + z`.</span></span>
* <span data-ttu-id="d9aea-331">Atama işleçleri, null birleşim `??` ve `??=` İşleçler ve koşullu operatör `?:` *doğru ilişkilendirilebilir*, yani işlemler sağdan sola yapılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-331">The assignment operators, the null-coalescing `??` and `??=` operators, and the conditional operator `?:` are *right-associative*, meaning that operations are performed from right to left.</span></span> <span data-ttu-id="d9aea-332">Örneğin, `x = y = z` olarak değerlendirilir `x = (y = z)` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-332">For example, `x = y = z` is evaluated as `x = (y = z)`.</span></span>

<span data-ttu-id="d9aea-333">Öncelik ve ilişkilendirilebilirlik, parantezler kullanılarak denetlenebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-333">Precedence and associativity can be controlled using parentheses.</span></span> <span data-ttu-id="d9aea-334">Örneğin, ilk olarak ile `x + y * z` çarpar `y` `z` ve sonra sonucunu ekler `x` , ancak ilk olarak `(x + y) * z` sonucu ekler `x` ve `y` sonra sonucunu ile çarpar `z` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-334">For example, `x + y * z` first multiplies `y` by `z` and then adds the result to `x`, but `(x + y) * z` first adds `x` and `y` and then multiplies the result by `z`.</span></span>

<span data-ttu-id="d9aea-335">Çoğu işleç [*aşırı*](../language-reference/operators/operator-overloading.md)yüklenebilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-335">Most operators can be [*overloaded*](../language-reference/operators/operator-overloading.md).</span></span> <span data-ttu-id="d9aea-336">İşleç aşırı yüklemesi, Kullanıcı tanımlı operatör uygulamalarının bir veya her ikisinin de Kullanıcı tanımlı sınıf veya yapı türünde olduğu işlemler için belirtilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-336">Operator overloading permits user-defined operator implementations to be specified for operations where one or both of the operands are of a user-defined class or struct type.</span></span>

<span data-ttu-id="d9aea-337">C# [Aritmetik](../language-reference/operators/arithmetic-operators.md), [mantıksal](../language-reference/operators/boolean-logical-operators.md), [bit düzeyinde ve vardiya](../language-reference/operators/bitwise-and-shift-operators.md) işlemleri, [eşitlik](../language-reference/operators/equality-operators.md) ve [sıra](../language-reference/operators/comparison-operators.md) karşılaştırmaları gerçekleştirmeye yönelik bir dizi işleç sağlar.</span><span class="sxs-lookup"><span data-stu-id="d9aea-337">C# provides a number of operators to perform [arithmetic](../language-reference/operators/arithmetic-operators.md), [logical](../language-reference/operators/boolean-logical-operators.md), [bitwise and shift](../language-reference/operators/bitwise-and-shift-operators.md) operations and [equality](../language-reference/operators/equality-operators.md) and [order](../language-reference/operators/comparison-operators.md) comparisons.</span></span>

<span data-ttu-id="d9aea-338">Öncelik düzeyine göre sıralanan C# işleçlerinin tüm listesi için bkz. [c# işleçleri](../language-reference/operators/index.md).</span><span class="sxs-lookup"><span data-stu-id="d9aea-338">For the complete list of C# operators ordered by precedence level, see [C# operators](../language-reference/operators/index.md).</span></span>

## <a name="statements"></a><span data-ttu-id="d9aea-339">Deyimler</span><span class="sxs-lookup"><span data-stu-id="d9aea-339">Statements</span></span>

<span data-ttu-id="d9aea-340">Bir programın eylemleri *deyimler*kullanılarak ifade edilir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-340">The actions of a program are expressed using *statements*.</span></span> <span data-ttu-id="d9aea-341">C#, gömülü deyimler açısından tanımlanmış bir dizi farklı sayıda ifadeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-341">C# supports several different kinds of statements, a number of which are defined in terms of embedded statements.</span></span>

- <span data-ttu-id="d9aea-342">Bir *blok* , tek bir ifadeye izin verilen bağlamlarda birden çok deyimin yazılmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-342">A *block* permits multiple statements to be written in contexts where a single statement is allowed.</span></span> <span data-ttu-id="d9aea-343">Bir blok, sınırlayıcılar ve arasında yazılmış deyimler listesinden oluşur `{` `}` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-343">A block consists of a list of statements written between the delimiters `{` and `}`.</span></span>
- <span data-ttu-id="d9aea-344">*Bildirim deyimleri* yerel değişkenleri ve sabitleri bildirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-344">*Declaration statements* are used to declare local variables and constants.</span></span>
- <span data-ttu-id="d9aea-345">*İfade deyimleri* , ifadeleri değerlendirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-345">*Expression statements* are used to evaluate expressions.</span></span> <span data-ttu-id="d9aea-346">Deyim olarak kullanılabilecek ifadeler, yöntem etkinleştirmeleri, işleci kullanılarak nesne ayırmaları `new` , ve `=` bileşik atama işleçleri kullanan atamalar, artırma ve azaltma işlemlerini ve `++` `--` işleçlerini ve `await` ifadelerini içerir.</span><span class="sxs-lookup"><span data-stu-id="d9aea-346">Expressions that can be used as statements include method invocations, object allocations using the `new` operator, assignments using `=` and the compound assignment operators, increment and decrement operations using the `++` and `--` operators and `await` expressions.</span></span>
- <span data-ttu-id="d9aea-347">*Seçim deyimleri* , bazı deyimlerin değerine göre yürütme için bir dizi olası deyimden birini seçmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-347">*Selection statements* are used to select one of a number of possible statements for execution based on the value of some expression.</span></span> <span data-ttu-id="d9aea-348">Bu grup `if` ve deyimlerini içerir `switch` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-348">This group contains the `if` and `switch` statements.</span></span>
- <span data-ttu-id="d9aea-349">*Yineleme deyimleri* , art arda gömülü bir deyimi yürütmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-349">*Iteration statements* are used to execute repeatedly an embedded statement.</span></span> <span data-ttu-id="d9aea-350">Bu grup,, `while` , `do` `for` ve deyimlerini içerir `foreach` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-350">This group contains the `while`, `do`, `for`, and `foreach` statements.</span></span>
- <span data-ttu-id="d9aea-351">*Sıçrama deyimleri* , denetimi aktarmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-351">*Jump statements* are used to transfer control.</span></span> <span data-ttu-id="d9aea-352">Bu grup,,,, `break` `continue` `goto` `throw` `return` ve deyimlerini içerir `yield` .</span><span class="sxs-lookup"><span data-stu-id="d9aea-352">This group contains the `break`, `continue`, `goto`, `throw`, `return`, and `yield` statements.</span></span>
- <span data-ttu-id="d9aea-353">`try`... `catch` Bildirisi, bir bloğun yürütülmesi sırasında oluşan özel durumları yakalamak için kullanılır ve `try` ... `finally` deyimleri her zaman yürütülen ve özel bir durumun gerçekleşmediği sonlandırma kodunu belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-353">The `try`...`catch` statement is used to catch exceptions that occur during execution of a block, and the `try`...`finally` statement is used to specify finalization code that is always executed, whether an exception occurred or not.</span></span>
- <span data-ttu-id="d9aea-354">`checked`Ve `unchecked` deyimleri, tam sayı türü aritmetik işlemler ve dönüştürmeler için taşma denetimi bağlamını denetlemek üzere kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-354">The `checked` and `unchecked` statements are used to control the overflow-checking context for integral-type arithmetic operations and conversions.</span></span>
- <span data-ttu-id="d9aea-355">Bu `lock` ifade, belirli bir nesne için karşılıklı dışlama kilidini almak, bir ifadeyi yürütmek ve sonra kilidi serbest bırakmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-355">The `lock` statement is used to obtain the mutual-exclusion lock for a given object, execute a statement, and then release the lock.</span></span>
- <span data-ttu-id="d9aea-356">`using`İfade, kaynak almak, bir ifadeyi yürütmek ve ardından bu kaynağı atmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d9aea-356">The `using` statement is used to obtain a resource, execute a statement, and then dispose of that resource.</span></span>

<span data-ttu-id="d9aea-357">Aşağıdakiler, kullanılabilecek deyimlerin türlerini listeler:</span><span class="sxs-lookup"><span data-stu-id="d9aea-357">The following lists the kinds of statements that can be used:</span></span>

* <span data-ttu-id="d9aea-358">Yerel değişken bildirimi.</span><span class="sxs-lookup"><span data-stu-id="d9aea-358">Local variable declaration.</span></span>
* <span data-ttu-id="d9aea-359">Yerel sabit bildirimi.</span><span class="sxs-lookup"><span data-stu-id="d9aea-359">Local constant declaration.</span></span>
* <span data-ttu-id="d9aea-360">İfade deyimi.</span><span class="sxs-lookup"><span data-stu-id="d9aea-360">Expression statement.</span></span>
* <span data-ttu-id="d9aea-361">`if` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-361">`if` statement.</span></span>
* <span data-ttu-id="d9aea-362">`switch` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-362">`switch` statement.</span></span>
* <span data-ttu-id="d9aea-363">`while` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-363">`while` statement.</span></span>
* <span data-ttu-id="d9aea-364">`do` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-364">`do` statement.</span></span>
* <span data-ttu-id="d9aea-365">`for` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-365">`for` statement.</span></span>
* <span data-ttu-id="d9aea-366">`foreach` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-366">`foreach` statement.</span></span>
* <span data-ttu-id="d9aea-367">`break` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-367">`break` statement.</span></span>
* <span data-ttu-id="d9aea-368">`continue` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-368">`continue` statement.</span></span>
* <span data-ttu-id="d9aea-369">`goto` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-369">`goto` statement.</span></span>
* <span data-ttu-id="d9aea-370">`return` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-370">`return` statement.</span></span>
* <span data-ttu-id="d9aea-371">`yield` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-371">`yield` statement.</span></span>
* <span data-ttu-id="d9aea-372">`throw` deyimler ve `try` deyimler.</span><span class="sxs-lookup"><span data-stu-id="d9aea-372">`throw` statements and `try` statements.</span></span>
* <span data-ttu-id="d9aea-373">`checked` ve `unchecked` deyimleri.</span><span class="sxs-lookup"><span data-stu-id="d9aea-373">`checked` and `unchecked` statements.</span></span>
* <span data-ttu-id="d9aea-374">`lock` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-374">`lock` statement.</span></span>
* <span data-ttu-id="d9aea-375">`using` Ekstre.</span><span class="sxs-lookup"><span data-stu-id="d9aea-375">`using` statement.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="d9aea-376">[Önceki](types.md) 
> [Sonraki](features.md)</span><span class="sxs-lookup"><span data-stu-id="d9aea-376">[Previous](types.md)
[Next](features.md)</span></span>
