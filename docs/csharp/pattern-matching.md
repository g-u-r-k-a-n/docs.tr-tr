---
title: Model eşleştirme-C# Kılavuzu
description: "C 'de desenler eşleştirme ifadeleri hakkında bilgi edinin #"
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 2dd1401e3ef22a02f327e44ff884182ee3e22278
ms.sourcegitcommit: b1f4756120deaecb8b554477bb040620f69a4209
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/03/2020
ms.locfileid: "89415000"
---
# <a name="pattern-matching"></a><span data-ttu-id="f98a0-103">Desen Eşleştirme</span><span class="sxs-lookup"><span data-stu-id="f98a0-103">Pattern Matching</span></span>

<span data-ttu-id="f98a0-104">Desenler bir değerin belirli bir *şekle*sahip olduğunu ve eşleşen şekline sahip olduğu zaman değerden bilgi *ayıklayabilirler* .</span><span class="sxs-lookup"><span data-stu-id="f98a0-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="f98a0-105">Model eşleştirme, günümüzde zaten kullandığınız algoritmalar için daha kısa sözdizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="f98a0-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="f98a0-106">Mevcut söz dizimini kullanarak model eşleştirme algoritmaları zaten oluşturmuş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="f98a0-107">`if` `switch` Değerleri test eden bir yazın.</span><span class="sxs-lookup"><span data-stu-id="f98a0-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="f98a0-108">Daha sonra, bu deyimler eşleşiyorsa, bu değerden bilgi ayıklar ve bunları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="f98a0-109">Yeni sözdizimi öğeleri, zaten bildiğiniz deyimlere yönelik uzantılardır: `is` ve `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="f98a0-110">Bu yeni uzantılar bir değeri test eden ve bu bilgileri ayıklayarak birleştirir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="f98a0-111">Bu makalede, nasıl okunabilir, kısa kod etkinleştirmesinin nasıl yapıldığını gösteren yeni sözdizimine bakacağız.</span><span class="sxs-lookup"><span data-stu-id="f98a0-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="f98a0-112">Desen eşleştirme, verilerin ve kodun ayrıldığı ve verilerin ve bunları işleyen yöntemlerin sıkı bir şekilde birbirine bağlı olduğu nesne odaklı tasarımlardan farklı olarak, verilerin ve kodun ayrıldığı deyimler sunar.</span><span class="sxs-lookup"><span data-stu-id="f98a0-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="f98a0-113">Bu yeni deyimleri göstermek için, model eşleştirme deyimlerini kullanarak geometrik şekilleri temsil eden yapılarla çalışmaalım.</span><span class="sxs-lookup"><span data-stu-id="f98a0-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="f98a0-114">Nesnenin çalışma zamanı türüne göre nesne davranışını özelleştirmek için sınıf hiyerarşileri oluşturma ve [sanal yöntemleri oluşturma ve geçersiz kılınan Yöntemler](methods.md#inherited) hakkında bilgi sahibisiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="f98a0-115">Bu teknikler, bir sınıf hiyerarşisinde yapılandırılmamış veriler için mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="f98a0-116">Veriler ve Yöntemler ayrı olduğunda, diğer araçlara ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="f98a0-117">Yeni *model eşleştirme* yapıları, verileri incelemek ve bu verilerin herhangi bir koşuluna göre denetim akışını işlemek için temizleyici sözdizimini etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="f98a0-118">Zaten `if` `switch` bir değişkenin değerini test eden deyimleri yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="f98a0-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="f98a0-119">`is`Bir değişkenin türünü test eden deyimler yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="f98a0-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="f98a0-120">*Model eşleştirme* , bu deyimlere yeni yetenekler ekler.</span><span class="sxs-lookup"><span data-stu-id="f98a0-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="f98a0-121">Bu makalede, farklı geometrik şekillerin alanını hesaplayan bir yöntem oluşturacaksınız.</span><span class="sxs-lookup"><span data-stu-id="f98a0-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="f98a0-122">Ancak, nesne yönelimli teknikler için bir daha olmadan ve farklı şekiller için bir sınıf hiyerarşisi oluşturmadan bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="f98a0-123">Bunun yerine *model eşleştirmeyi* kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="f98a0-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="f98a0-124">Bu örneğe giderek, bu kodun bir nesne hiyerarşisi olarak nasıl yapılandırıldığı ile karşıtlığı vardır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="f98a0-125">Sorgu ve işleme gereken veriler bir sınıf hiyerarşisi olmadığında, desen eşleştirme zarif tasarımları mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="f98a0-126">Bir soyut şekil tanımıyla başlamak ve farklı özel şekil sınıfları eklemek yerine, yalnızca geometrik şekillerin her biri için yalnızca basit veri tanımlarıyla başlayalım.</span><span class="sxs-lookup"><span data-stu-id="f98a0-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="f98a0-127">Bu yapılardan, bazı şekillerin alanını hesaplayan bir yöntem yazalım.</span><span class="sxs-lookup"><span data-stu-id="f98a0-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="f98a0-128">`is`Tür deseninin ifadesi</span><span class="sxs-lookup"><span data-stu-id="f98a0-128">The `is` type pattern expression</span></span>

<span data-ttu-id="f98a0-129">C# 7,0 ' den önce, her türü bir dizi `if` ve deyimde test etmeniz gerekir `is` :</span><span class="sxs-lookup"><span data-stu-id="f98a0-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="f98a0-130">Yukarıdaki kod, *tür deseninin*klasik bir ifadesidir: türünü tespit etmek ve bu türe göre farklı bir eylem almak için bir değişkeni test etiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="f98a0-131">Bu kod `is` , test başarılı olursa bir değişken atamak için ifade uzantıları kullanılarak daha basit hale gelir:</span><span class="sxs-lookup"><span data-stu-id="f98a0-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="f98a0-132">Bu güncelleştirilmiş sürümde, `is` ifadenin her ikisi de değişkeni sınar ve uygun türdeki yeni bir değişkene atar.</span><span class="sxs-lookup"><span data-stu-id="f98a0-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="f98a0-133">Ayrıca, bu sürümün bir olan türünü de içerdiğine dikkat edin `Rectangle` `struct` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="f98a0-134">Yeni `is` ifade, değer türleri ve başvuru türleri ile birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="f98a0-135">Bir eşleştirme ifadesinin sonuçlarının yanlış kullanılmasını önlemenize yardımcı olacak şekilde, model eşleştirme ifadelerine yönelik dil kuralları.</span><span class="sxs-lookup"><span data-stu-id="f98a0-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="f98a0-136">Yukarıdaki örnekte,, `s` `c` ve değişkenleri `r` yalnızca kapsamdadır ve ilgili model eşleşme ifadeleri sonuçlara sahip olduğunda kesinlikle atanır `true` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="f98a0-137">Başka bir konumda herhangi bir değişken kullanmayı denerseniz, kodunuz derleyici hataları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f98a0-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="f98a0-138">Bu kuralların her ikisini de kapsam ile başlayarak ayrıntılı bir şekilde incelim.</span><span class="sxs-lookup"><span data-stu-id="f98a0-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="f98a0-139">Değişken `c` yalnızca `else` ilk deyimin dalında kapsamdadır `if` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="f98a0-140">Değişkeni `s` yönteminde kapsam içinde `ComputeAreaModernIs` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="f98a0-141">Çünkü bir deyimin her dalı `if` değişkenler için ayrı bir kapsam oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f98a0-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="f98a0-142">Ancak, `if` deyimin kendisi değildir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="f98a0-143">Bu, bildiriminde belirtilen değişkenlerin `if` `if` deyimlerle aynı kapsamda (Bu durumda yöntem) olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case).</span></span> <span data-ttu-id="f98a0-144">Bu davranış, model eşleştirmeye özgü değildir, ancak değişken kapsamları ve deyimleri için tanımlanan davranıştır `if` `else` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-144">This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="f98a0-145">Değişkenler `c` ve `s` ilgili deyimler true olduğunda, kesin olarak `if` atanan doğru mekanizmaya göre atanır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-145">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="f98a0-146">Bu konudaki örneklerde, bir model eşleştirme `is` ifadesinin `true` deyimin dalındaki Match değişkenini kesinlikle atayan önerilen yapı kullanılır `if` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-146">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="f98a0-147">Mantığa göre ters çevirebilirsiniz `if (!(shape is Square s))` ve değişken `s` yalnızca dalda kesinlikle atanır `false` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-147">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="f98a0-148">Bu geçerli bir C# olsa da, mantığın izlenmesi daha kafa karıştırıcı olduğundan önerilmez.</span><span class="sxs-lookup"><span data-stu-id="f98a0-148">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="f98a0-149">Bu kurallar, bu düzenin karşılanmadığı zaman bir model eşleştirme ifadesinin sonucuna yanlışlıkla erişmeniz çok düşüktür.</span><span class="sxs-lookup"><span data-stu-id="f98a0-149">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="f98a0-150">Model eşleştirme `switch` deyimlerini kullanma</span><span class="sxs-lookup"><span data-stu-id="f98a0-150">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="f98a0-151">Aynı zamanda, diğer şekil türlerini desteklemeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-151">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="f98a0-152">Test ettiğiniz koşulların sayısı arttıkça, `is` model eşleştirme ifadelerinin kullanımı için bir tamsayı gelebileceğinizi göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-152">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="f98a0-153">Denetlemek istediğiniz her türde deyim gerektirmesinin yanı sıra `if` , `is` giriş tek bir türle eşleşiyorsa, ifadeler test ile sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-153">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="f98a0-154">Bu durumda, `switch` düzenin eşleşen ifadelerin daha iyi bir seçenek haline geldiğini göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-154">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="f98a0-155">Geleneksel `switch` deyim bir desenli ifade idi: sabit örüntü destekleniyor.</span><span class="sxs-lookup"><span data-stu-id="f98a0-155">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="f98a0-156">Bir değişkeni bir ifadede kullanılan herhangi bir sabitle karşılaştırabilirsiniz `case` :</span><span class="sxs-lookup"><span data-stu-id="f98a0-156">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="f98a0-157">Deyimin desteklediği tek desenler sabit bir `switch` modeldir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-157">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="f98a0-158">Sayısal türlerle ve türle daha fazla sınırlandırıldı `string` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-158">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="f98a0-159">Bu kısıtlamalar kaldırılmıştır ve artık `switch` tür modelini kullanarak bir ifade yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f98a0-159">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="f98a0-160">Model eşleştirme `switch` deyimleri, geleneksel C stili ifadesini kullanan geliştiriciler için tanıdık sözdizimini kullanır `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-160">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="f98a0-161">Her biri `case` değerlendirilir ve giriş değişkeniyle eşleşen koşulun altındaki kod yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f98a0-161">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="f98a0-162">Kod yürütme, bir Case ifadesinden sonrakine "düşmüyor". `case` deyimin sözdizimi her `case` bir uçta `break` , veya ile gerektirir `return` `goto` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-162">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="f98a0-163">`goto`Başka bir etikete atlanacak deyimler yalnızca sabit model için geçerlidir (klasik switch deyimi).</span><span class="sxs-lookup"><span data-stu-id="f98a0-163">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="f98a0-164">Bildirisini düzenleyen önemli yeni kurallar vardır `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-164">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="f98a0-165">İfadedeki değişkenin türüyle ilgili kısıtlamalar `switch` kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-165">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="f98a0-166">Bu örnekte olduğu gibi herhangi bir tür `object` kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-166">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="f98a0-167">Case ifadeleri artık sabit değerlerle sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-167">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="f98a0-168">Bu sınırlamanın kaldırılması, yeniden sıralama `switch` bölümlerinin bir programın davranışını değiştirebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-168">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="f98a0-169">Sabit değerlerle sınırlı olduğunda, `case` ifadenin değeriyle birden fazla etiket eşleşmeyebilir `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-169">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="f98a0-170">Her `switch` bölümün bir sonraki bölüme dönmesi gereken kuralla birlikte birleştirin ve `switch` bölümler, davranışları etkilemeden herhangi bir sırada yeniden düzenlenebilir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-170">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="f98a0-171">Artık, daha Genelleştirilmiş `switch` ifadelerle, her bölümün sırası önemli.</span><span class="sxs-lookup"><span data-stu-id="f98a0-171">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="f98a0-172">`switch`İfadeler metin sırasına göre değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-172">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="f98a0-173">Yürütme `switch` , deyimle eşleşen ilk etikete aktarır `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-173">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="f98a0-174">`default`Durum yalnızca başka bir Case etiketi eşleşmezse yürütülür.</span><span class="sxs-lookup"><span data-stu-id="f98a0-174">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="f98a0-175">Bu `default` durum, metin sırası ne olursa olsun son olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-175">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="f98a0-176">`default`Böyle bir durum yoksa ve diğer `case` deyimlerden hiçbiri eşleşmezse, yürütme deyimden sonraki deyimde devam eder `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-176">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="f98a0-177">`case`Etiket kodunun hiçbiri yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f98a0-177">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="f98a0-178">`when``case`deyimlerdeki yan tümceler</span><span class="sxs-lookup"><span data-stu-id="f98a0-178">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="f98a0-179">Etikette yan tümcesini kullanarak 0 alanı olan bu şekiller için özel durumlar yapabilirsiniz `when` `case` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-179">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="f98a0-180">Yüz uzunluğu 0 olan bir kare veya yarıçapı 0 olan bir daire 0 alanına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-180">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="f98a0-181">Bu koşulu `when` , etiket üzerinde bir yan tümce kullanarak belirtirsiniz `case` :</span><span class="sxs-lookup"><span data-stu-id="f98a0-181">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="f98a0-182">Bu değişiklik, yeni sözdizimi hakkında bazı önemli noktaları gösterir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-182">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="f98a0-183">İlk olarak, `case` bir bölüme birden çok etiket uygulanabilir `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-183">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="f98a0-184">Bu etiketlerin herhangi biri olduğunda, ekstre bloğu yürütülür `true` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-184">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="f98a0-185">Bu örnekte, `switch` ifade bir daire ya da 0 alanı olan bir kare ise, yöntem 0 sabitini döndürür.</span><span class="sxs-lookup"><span data-stu-id="f98a0-185">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="f98a0-186">Bu örnek `case` , ilk blok için iki etiket içinde iki farklı değişken tanıtır `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-186">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="f98a0-187">Bu `switch` bloktaki deyimlerin değişkenlerini `c` (daire için) veya `s` (kare için) kullandığına dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="f98a0-187">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="f98a0-188">Bu değişkenlerden hiçbiri kesinlikle bu bloğa atanmamıştır `switch` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-188">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="f98a0-189">Bu durumlardan biri eşleşiyorsa, değişkenlerden açıkça biri atanır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-189">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="f98a0-190">Ancak, çalışma zamanında eşleşeceğinden, derleme zamanında *hangisinin* atandığını söylemek olanaksızdır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-190">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="f98a0-191">Bu nedenle, aynı blok için birden çok etiket kullandığınızda çoğu zaman `case` deyimde yeni bir değişken sunmaz `case` ya da değişkeni yalnızca `when` yan tümcesinde kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="f98a0-191">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="f98a0-192">Bu şekilleri 0 alanla eklediyseniz, daha fazla şekil türü ekleyelim: dikdörtgen ve üçgen:</span><span class="sxs-lookup"><span data-stu-id="f98a0-192">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="f98a0-193">Bu değişiklik kümesi `case` , Yeni şekillerin her biri için bozuk Case ve Labels ve blokların etiketlerini ekler.</span><span class="sxs-lookup"><span data-stu-id="f98a0-193">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="f98a0-194">Son olarak, `null` bağımsız değişkenin olmamasını sağlamak için büyük/küçük harf ekleyebilirsiniz `null` :</span><span class="sxs-lookup"><span data-stu-id="f98a0-194">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="f98a0-195">Düzendeki `null` Constant `null` bir tür içermediğinden, ancak herhangi bir başvuru türüne veya null yapılabilir değer türüne dönüştürülebildiğinden, model için özel davranış ilginç değildir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-195">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="f98a0-196">`null`, Bir türü herhangi bir türe dönüştürmek yerine, `null` değişkenin derleme zamanı türünden bağımsız olarak bir değerin herhangi bir tür düzeniyle eşleşmeyeceğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="f98a0-196">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="f98a0-197">Bu davranış, yeni `switch` tabanlı tür deseninin deyimle tutarlı olmasını sağlar `is` : `is` deyimler, `false` denetlenen değer olduğunda her zaman döndürülür `null` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-197">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="f98a0-198">Ayrıca daha basittir: türü denetledikten sonra, ek null bir denetim gerekmez.</span><span class="sxs-lookup"><span data-stu-id="f98a0-198">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="f98a0-199">Yukarıdaki örneklerin herhangi bir durum bloklarında hiçbir null denetim olmadığını ve tür örüntüsünün eşleşmesi null olmayan bir değer garantisi olduğundan, bu durum gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-199">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="f98a0-200">`var``case`deyimlerdeki bildirimler</span><span class="sxs-lookup"><span data-stu-id="f98a0-200">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="f98a0-201">`var`Eşleşme ifadelerinden biri olarak giriş, model eşleşmesi için yeni kurallar sağlar.</span><span class="sxs-lookup"><span data-stu-id="f98a0-201">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="f98a0-202">İlk kural `var` bildirimin normal tür çıkarımı kurallarını takip ediyor: tür, anahtar ifadesinin statik türü olarak algılanır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-202">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="f98a0-203">Bu kuraldan, türü her zaman eşleşir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-203">From that rule, the type always matches.</span></span>

<span data-ttu-id="f98a0-204">İkinci kural, bir `var` bildirimin diğer tür deseninin içerdiği null denetimini içermediği bir bildirimde bulunur.</span><span class="sxs-lookup"><span data-stu-id="f98a0-204">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="f98a0-205">Bu, değişkenin null olabileceği ve bu durumda null bir denetim olması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-205">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="f98a0-206">Bu iki kural, `var` bir ifadedeki bir bildirimin bir `case` ifadeyle aynı koşullara uyan birçok örnekte olduğu anlamına gelir `default` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-206">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="f98a0-207">Durum için varsayılan olmayan bir durum tercih edildiği için `default` , `default` Bu durum hiçbir şekilde yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="f98a0-207">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="f98a0-208">Derleyici, bir `default` Servis talebinin yazıldığı ancak hiçbir zaman yürütülebileceği durumlarda uyarı göstermez.</span><span class="sxs-lookup"><span data-stu-id="f98a0-208">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="f98a0-209">Bu, `switch` tüm olası durumların listelendiği geçerli ifade davranışıyla tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-209">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="f98a0-210">Üçüncü kural, bir `var` Servis talebinin yararlı olabileceğini kullanır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-210">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="f98a0-211">Girişin bir dize olduğu ve bilinen komut değerlerini aradığınız bir model eşleşmesi yaptığınızı düşünün.</span><span class="sxs-lookup"><span data-stu-id="f98a0-211">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="f98a0-212">Şöyle bir işlem yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f98a0-212">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="f98a0-213">`var`Durum `null` , boş dize veya yalnızca boşluk içeren herhangi bir dize ile eşleşir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-213">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="f98a0-214">Önceki kodun, `?.` yanlışlıkla bir oluşturmadığından emin olmak için işlecini kullandığına dikkat edin <xref:System.NullReferenceException> .</span><span class="sxs-lookup"><span data-stu-id="f98a0-214">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="f98a0-215">`default`Durum, bu komut ayrıştırıcısı tarafından anlaşılmayan diğer dize değerlerini işler.</span><span class="sxs-lookup"><span data-stu-id="f98a0-215">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="f98a0-216">Bu, `var` bir ifadeden farklı bir Case ifadesini düşünmek isteyebileceğiniz bir örnektir `default` .</span><span class="sxs-lookup"><span data-stu-id="f98a0-216">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="f98a0-217">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="f98a0-217">Conclusions</span></span>

<span data-ttu-id="f98a0-218">*Model eşleştirme yapıları* , bir devralma hiyerarşisi tarafından ilgili olmayan farklı değişkenler ve türler arasında denetim akışını kolayca yönetmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="f98a0-218">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="f98a0-219">Ayrıca, değişkende test ettiğiniz herhangi bir koşulu kullanmak için mantığı da denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-219">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="f98a0-220">Daha fazla dağıtılmış uygulama oluştururken daha sık ihtiyacınız olacak desenler ve deyimler sayesinde, verilerin ve bu verileri işleyen yöntemlerin ayrı olduğu durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="f98a0-220">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="f98a0-221">Bu örnekte kullanılan şekil yapıların hiçbir yöntem içermediğini, yalnızca salt okunurdur özellikleri olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-221">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="f98a0-222">Model eşleştirme, herhangi bir veri türü ile birlikte çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="f98a0-222">Pattern Matching works with any data type.</span></span> <span data-ttu-id="f98a0-223">Nesneyi inceleyecek ve bu koşullara göre denetim akışı kararları veren ifadeler yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="f98a0-223">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="f98a0-224">Bu örnekteki kodu, bir soyut `Shape` ve belirli türetilmiş şekillerin her biri, alanı hesaplamak için kendi sanal yöntem uygulamalarına sahip olan bir sınıf hiyerarşisi oluşturmaktan izlenecek tasarımla karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="f98a0-224">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="f98a0-225">Genellikle, verilerle çalışırken ve veri depolama sorunlarını davranış kaygılarından ayırmak istediğinizde, model eşleştirme ifadelerinin çok faydalı bir araç olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-225">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="f98a0-226">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="f98a0-226">See also</span></span>

- [<span data-ttu-id="f98a0-227">Öğretici: veri türlerini genişletmek için model eşleştirme özelliklerini kullanma</span><span class="sxs-lookup"><span data-stu-id="f98a0-227">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
