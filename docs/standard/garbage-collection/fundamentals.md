---
title: Çöp toplamanın temelleri
description: Çöp toplayıcısının nasıl çalıştığını ve en iyi performans için nasıl yapılandırılabileceğini öğrenin.
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: ea8aef03d2f5837f35ecb31209e57853c0c8257b
ms.sourcegitcommit: 17ee6605e01ef32506f8fdc686954244ba6911de
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/22/2019
ms.locfileid: "74330425"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="33dd1-103">Çöp toplamanın temelleri</span><span class="sxs-lookup"><span data-stu-id="33dd1-103">Fundamentals of garbage collection</span></span>

<span data-ttu-id="33dd1-104">Ortak dil çalışma zamanında (CLR) Çöp toplayıcı (GC) otomatik bellek yöneticisi olarak görev yapar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-104">In the common language runtime (CLR), the garbage collector (GC) serves as an automatic memory manager.</span></span> <span data-ttu-id="33dd1-105">Aşağıdaki avantajları sağlar:</span><span class="sxs-lookup"><span data-stu-id="33dd1-105">It provides the following benefits:</span></span>

- <span data-ttu-id="33dd1-106">, El ile bellek boşaltmaya gerek kalmadan uygulamanızı geliştirmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-106">Enables you to develop your application without having to manually free memory.</span></span>

- <span data-ttu-id="33dd1-107">Yönetilen yığında nesneleri verimli bir şekilde ayırır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-107">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="33dd1-108">Artık kullanılmayan nesneleri geri kazanır, hafızasını temizler ve belleğin gelecekteki ayırmalarda kullanılabilmesini önler.</span><span class="sxs-lookup"><span data-stu-id="33dd1-108">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="33dd1-109">Yönetilen nesneler, ile başlamak için otomatik olarak temiz içerik alır, bu nedenle oluşturucuların her veri alanını başlatması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="33dd1-109">Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</span></span>

- <span data-ttu-id="33dd1-110">Bir nesnenin başka bir nesnenin içeriğini kullanabilmesi için bellek güvenliği sağlar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-110">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

<span data-ttu-id="33dd1-111">Bu makalede çöp toplamanın temel kavramları açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-111">This article describes the core concepts of garbage collection.</span></span>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="33dd1-112">Belleğin temelleri</span><span class="sxs-lookup"><span data-stu-id="33dd1-112">Fundamentals of memory</span></span>

<span data-ttu-id="33dd1-113">Aşağıdaki listede, önemli CLR belleği kavramları özetlenmektedir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-113">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="33dd1-114">Her işlemin kendi kendine ayrı bir sanal adres alanı vardır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-114">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="33dd1-115">Aynı bilgisayardaki tüm süreçler, varsa aynı fiziksel belleği ve sayfa dosyasını paylaşır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-115">All processes on the same computer share the same physical memory and the page file, if there is one.</span></span>

- <span data-ttu-id="33dd1-116">Varsayılan olarak, 32 bit bilgisayarlarda, her işlemin 2 GB 'lık bir Kullanıcı modu sanal adres alanı vardır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-116">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="33dd1-117">Bir uygulama geliştiricisi olarak yalnızca sanal adres alanı ile çalışır ve fiziksel belleği doğrudan hiçbir şekilde işlemeyin.</span><span class="sxs-lookup"><span data-stu-id="33dd1-117">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="33dd1-118">Çöp toplayıcı, yönetilen yığında sizin için sanal belleği ayırır ve serbest bırakır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-118">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="33dd1-119">Yerel kod yazıyorsanız, sanal adres alanı ile çalışmak için Windows işlevlerini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="33dd1-119">If you are writing native code, you use Windows functions to work with the virtual address space.</span></span> <span data-ttu-id="33dd1-120">Bu işlevler, yerel yığınlardaki sanal belleği ayırır ve boşaltır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-120">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="33dd1-121">Sanal bellek üç durumda olabilir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-121">Virtual memory can be in three states:</span></span>

  - <span data-ttu-id="33dd1-122">Süz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-122">Free.</span></span> <span data-ttu-id="33dd1-123">Bellek bloğunun kendisine başvuru yoktur ve ayırma için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-123">The block of memory has no references to it and is available for allocation.</span></span>

  - <span data-ttu-id="33dd1-124">Ayrılamadı.</span><span class="sxs-lookup"><span data-stu-id="33dd1-124">Reserved.</span></span> <span data-ttu-id="33dd1-125">Bellek bloğu kullanım için kullanılabilir ve diğer herhangi bir ayırma isteği için kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-125">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="33dd1-126">Ancak, bu bellek bloğunda verileri kaydedilene kadar depoleyemez.</span><span class="sxs-lookup"><span data-stu-id="33dd1-126">However, you cannot store data to this memory block until it is committed.</span></span>

  - <span data-ttu-id="33dd1-127">Yazıldı.</span><span class="sxs-lookup"><span data-stu-id="33dd1-127">Committed.</span></span> <span data-ttu-id="33dd1-128">Bellek bloğu fiziksel depolamaya atanır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-128">The block of memory is assigned to physical storage.</span></span>

- <span data-ttu-id="33dd1-129">Sanal adres alanı parçalanabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-129">Virtual address space can get fragmented.</span></span> <span data-ttu-id="33dd1-130">Bu, adres alanında delik olarak da bilinen boş blokların olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-130">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="33dd1-131">Sanal bellek ayırma istendiğinde, sanal bellek yöneticisinin, bu ayırma isteğini karşılamak için yeterince büyük olan tek bir ücretsiz blok bulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-131">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="33dd1-132">2 GB boş alan olsa bile, tüm bu boş alan tek bir adres bloğunda yer almadığı takdirde 2 GB gerektiren ayırma başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-132">Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="33dd1-133">Ayırmak için yeterli sanal adres alanı yoksa ve yürütülecek fiziksel alan yoksa bellek tükeniyor.</span><span class="sxs-lookup"><span data-stu-id="33dd1-133">You can run out of memory if there isn't enough virtual address space to reserve or physical space to commit.</span></span>

  <span data-ttu-id="33dd1-134">Fiziksel bellek baskısı (yani fiziksel bellek talebi) düşük olsa bile sayfa dosyası kullanılır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-134">The page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="33dd1-135">Fiziksel bellek baskısı ilk kez yüksek olduğunda, işletim sistemi, verileri depolamak için fiziksel bellekte yer almalıdır ve fiziksel bellekteki bazı verileri sayfa dosyasına yedekler.</span><span class="sxs-lookup"><span data-stu-id="33dd1-135">The first time physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="33dd1-136">Bu veriler, gerekli olana kadar sayfalanmadığı için fiziksel bellek basıncının düşük olduğu durumlarda sayfalama ile karşılaşmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="33dd1-136">That data is not paged until it's needed, so it's possible to encounter paging in situations where the physical memory pressure is low.</span></span>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="33dd1-137">Çöp toplama koşulları</span><span class="sxs-lookup"><span data-stu-id="33dd1-137">Conditions for a garbage collection</span></span>

<span data-ttu-id="33dd1-138">Çöp toplama, aşağıdaki koşullardan biri doğru olduğunda gerçekleşir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-138">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="33dd1-139">Sistemde fiziksel bellek yetersiz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-139">The system has low physical memory.</span></span> <span data-ttu-id="33dd1-140">Bu, ana bilgisayar tarafından belirtilen işletim sistemi ya da düşük bellekten düşük bellek bildirimi tarafından algılanır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-140">This is detected by either the low memory notification from the OS or low memory as indicated by the host.</span></span>

- <span data-ttu-id="33dd1-141">Yönetilen yığında ayrılmış nesneler tarafından kullanılan bellek, kabul edilebilir bir eşik geçirir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-141">The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="33dd1-142">İşlem çalışırken bu eşik sürekli olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-142">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="33dd1-143"><xref:System.GC.Collect%2A?displayProperty=nameWithType> yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-143">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="33dd1-144">Neredeyse tüm durumlarda, çöp toplayıcı sürekli çalıştığından bu yöntemi çağırmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="33dd1-144">In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="33dd1-145">Bu yöntem öncelikle benzersiz durumlar ve test için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-145">This method is primarily used for unique situations and testing.</span></span>

## <a name="the-managed-heap"></a><span data-ttu-id="33dd1-146">Yönetilen yığın</span><span class="sxs-lookup"><span data-stu-id="33dd1-146">The managed heap</span></span>

<span data-ttu-id="33dd1-147">Çöp toplayıcı CLR tarafından başlatıldıktan sonra, nesneleri depolamak ve yönetmek için bir bellek segmenti ayırır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-147">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="33dd1-148">Bu bellek, işletim sistemindeki yerel bir yığının aksine yönetilen yığın olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-148">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="33dd1-149">Yönetilen her işlem için yönetilen bir yığın vardır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-149">There is a managed heap for each managed process.</span></span> <span data-ttu-id="33dd1-150">İşlemdeki tüm iş parçacıkları aynı yığında nesneler için bellek ayırır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-150">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="33dd1-151">Bellek ayırmak için çöp toplayıcı Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) işlevini çağırır ve yönetilen uygulamalar için bir seferde bir bellek kesimini ayırır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-151">To reserve memory, the garbage collector calls the Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="33dd1-152">Çöp toplayıcı, gerektiğinde kesimleri de ayırır ve Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) işlevini çağırarak kesimleri işletim sistemine (herhangi bir nesne temizlenmeden sonra) yeniden yayınlar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-152">The garbage collector also reserves segments, as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="33dd1-153">Çöp toplayıcı tarafından ayrılan parçaların boyutu uygulamaya özgüdür ve düzenli güncelleştirmeler de dahil olmak üzere herhangi bir zamanda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-153">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="33dd1-154">Uygulamanız, belirli bir kesim boyutuna ilişkin varsayımları asla belirtmemelidir veya buna bağlı olarak, kesim ayırmaları için kullanılabilir bellek miktarını yapılandırmayı denemelidir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-154">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="33dd1-155">Yığın üzerinde daha az nesne ayrılmışsa, çöp toplayıcının yapması gereken daha az iş vardır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-155">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="33dd1-156">Nesneleri ayırdığınızda, yalnızca 15 bayta ihtiyacınız olduğunda 32 baytlık bir dizi tahsis etme gibi gereksinimlerinizi aşan yuvarlanmış değerler kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="33dd1-156">When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="33dd1-157">Çöp toplama tetiklendiğinde çöp toplayıcı, ölü nesneler tarafından kullanılan belleği geri kazanır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-157">When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</span></span> <span data-ttu-id="33dd1-158">Geri kazanma işlemi, canlı nesneleri bir araya gelecek şekilde sıkıştırır ve atılacak alan kaldırıldıktan sonra yığın daha küçük hale getirir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-158">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="33dd1-159">Bu, birlikte ayrılan nesnelerin, konumlarını korumak için yönetilen yığında birlikte kalmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-159">This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</span></span>

<span data-ttu-id="33dd1-160">Çöp koleksiyonlarının sürekliliği (sıklığı ve süresi), ayırma hacminin ve yönetilen yığında kalan bellek miktarının sonucudur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-160">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="33dd1-161">Yığın iki sayfa@@ 'nin birikmesi olarak düşünülebilir: [büyük nesne yığını](large-object-heap.md) ve küçük nesne yığını.</span><span class="sxs-lookup"><span data-stu-id="33dd1-161">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span>

<span data-ttu-id="33dd1-162">[Büyük nesne yığını](large-object-heap.md) 85.000 bayt ve daha büyük olan çok büyük nesneler içerir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-162">The [large object heap](large-object-heap.md) contains very large objects that are 85,000 bytes and larger.</span></span> <span data-ttu-id="33dd1-163">Büyük nesne yığınındaki nesneler genellikle dizilerdir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-163">The objects on the large object heap are usually arrays.</span></span> <span data-ttu-id="33dd1-164">Örnek nesnesinin son derece büyük olması nadir bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-164">It is rare for an instance object to be extremely large.</span></span>

> [!TIP]
> <span data-ttu-id="33dd1-165">Nesnelerin [eşik boyutunu](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) büyük nesne yığınında gidilecek şekilde yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-165">You can [configure the threshold size](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold) for objects to go on the large object heap.</span></span>

## <a name="generations"></a><span data-ttu-id="33dd1-166">İse</span><span class="sxs-lookup"><span data-stu-id="33dd1-166">Generations</span></span>

<span data-ttu-id="33dd1-167">Yığın, uzun süreli ve kısa süreli nesneleri işleyebilmesi için nesiller halinde düzenlenir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-167">The heap is organized into generations so it can handle long-lived and short-lived objects.</span></span> <span data-ttu-id="33dd1-168">Çöp toplama öncelikli olarak genellikle yığının yalnızca küçük bir kısmını kaplayan kısa süreli nesneler geri kazanma ile gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-168">Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</span></span> <span data-ttu-id="33dd1-169">Yığında üç Neste nesne vardır:</span><span class="sxs-lookup"><span data-stu-id="33dd1-169">There are three generations of objects on the heap:</span></span>

- <span data-ttu-id="33dd1-170">**Nesil 0**.</span><span class="sxs-lookup"><span data-stu-id="33dd1-170">**Generation 0**.</span></span> <span data-ttu-id="33dd1-171">Bu, kardeşinizin nesli ve kısa süreli nesneler içerir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-171">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="33dd1-172">Kısa süreli bir nesne örneği, geçici bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-172">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="33dd1-173">Çöp toplama bu nesde en sık oluşur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-173">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="33dd1-174">Yeni ayrılmış nesneler yeni nesil nesneler oluşturur ve örtülü olarak 0. nesil koleksiyonlardır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-174">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections.</span></span> <span data-ttu-id="33dd1-175">Ancak, büyük nesnelerse, kuşak 2 koleksiyonundaki büyük nesne yığınına gider.</span><span class="sxs-lookup"><span data-stu-id="33dd1-175">However, if they are large objects, they go on the large object heap in a generation 2 collection.</span></span>

  <span data-ttu-id="33dd1-176">Çoğu nesne, oluşturma 0 ' da çöp toplama için geri kazanılır ve bir sonraki nesle devam etmez.</span><span class="sxs-lookup"><span data-stu-id="33dd1-176">Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</span></span>

- <span data-ttu-id="33dd1-177">**1. nesil**.</span><span class="sxs-lookup"><span data-stu-id="33dd1-177">**Generation 1**.</span></span> <span data-ttu-id="33dd1-178">Bu nesil, kısa süreli nesneler içerir ve kısa süreli nesneler ve uzun süreli nesneler arasında bir arabellek işlevi görür.</span><span class="sxs-lookup"><span data-stu-id="33dd1-178">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

- <span data-ttu-id="33dd1-179">**2. nesil**.</span><span class="sxs-lookup"><span data-stu-id="33dd1-179">**Generation 2**.</span></span> <span data-ttu-id="33dd1-180">Bu nesil uzun süreli nesneler içerir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-180">This generation contains long-lived objects.</span></span> <span data-ttu-id="33dd1-181">Uzun süreli bir nesne örneği, işlem süresince canlı olan statik verileri içeren bir sunucu uygulamasındaki nesnedir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-181">An example of a long-lived object is an object in a server application that contains static data that's live for the duration of the process.</span></span>

<span data-ttu-id="33dd1-182">Atık koleksiyonlar belirli nesiller üzerinde koşullar garanti olarak oluşur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-182">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="33dd1-183">Oluşturma toplanması, bu kuşak ve tüm küçük nesiller içindeki nesnelerin toplanması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-183">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="33dd1-184">2\. nesil atık toplama, tüm nesiller içindeki tüm nesneleri geri kazanır (yani, yönetilen yığındaki tüm nesneler) olduğu için tam çöp toplama olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-184">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="33dd1-185">Acil ihtiyaç ve promosyonlar</span><span class="sxs-lookup"><span data-stu-id="33dd1-185">Survival and promotions</span></span>

<span data-ttu-id="33dd1-186">Atık toplamada geri kazanımayan nesneler, acil sanal öğeler olarak bilinir ve bir sonraki oluşturmaya yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-186">Objects that are not reclaimed in a garbage collection are known as survivors and are promoted to the next generation.</span></span> <span data-ttu-id="33dd1-187">Nesil 0 atık toplamayı sürdüren nesneler 1. nesil olarak yükseltilir; 1. nesil atık toplamayı sürdüren nesneler 2. nesil olarak yükseltilir; ve 2. nesil bir atık toplamayı sürdüren nesneler 2. kuşak olarak kalır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-187">Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="33dd1-188">Çöp toplayıcı, bir kuşakma hızının yüksek olduğunu algıladığında, bu kuşak için ayırmaların eşiğini arttırır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-188">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation.</span></span> <span data-ttu-id="33dd1-189">Sonraki koleksiyon, geri kazanılan bellek miktarını önemli ölçüde alır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-189">The next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="33dd1-190">CLR sürekli olarak iki öncelik dengeler: bir uygulamanın çalışma kümesinin çöp toplamayı geciktirerek çok büyük bir şekilde geçmesine izin vermez ve çöp toplamanın çok sık çalışmasına izin vermez.</span><span class="sxs-lookup"><span data-stu-id="33dd1-190">The CLR continually balances two priorities: not letting an application's working set get too large by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="33dd1-191">Kısa ömürlü Nesler ve segmentler</span><span class="sxs-lookup"><span data-stu-id="33dd1-191">Ephemeral generations and segments</span></span>

<span data-ttu-id="33dd1-192">Nesil 0 ve 1 ' deki nesneler kısa süreli olduğundan, bu nesiller, kısa ömürlü nesiller olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-192">Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</span></span>

<span data-ttu-id="33dd1-193">Kısa ömürlü nesiller, kısa ömürlü segment olarak bilinen bellek segmentinde ayrılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-193">Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</span></span> <span data-ttu-id="33dd1-194">Çöp toplayıcı tarafından alınan her yeni segment, yeni kısa ömürlü segment olur ve 0. nesil atık toplamayı izleyen nesneleri içerir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-194">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="33dd1-195">Eski kısa ömürlü segment, yeni nesil 2 segmentine dönüşür.</span><span class="sxs-lookup"><span data-stu-id="33dd1-195">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="33dd1-196">Kısa ömürlü segmentin boyutu sistemin 32-bit mi yoksa 64 bit mi olduğunu ve çalıştırdığı çöp toplayıcı türünde olmasına bağlı olarak değişir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-196">The size of the ephemeral segment varies depending on whether a system is 32-bit or 64-bit, and on the type of garbage collector it is running.</span></span> <span data-ttu-id="33dd1-197">Varsayılan değerler aşağıdaki tabloda gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-197">Default values are shown in the following table.</span></span>

||<span data-ttu-id="33dd1-198">32 bit:</span><span class="sxs-lookup"><span data-stu-id="33dd1-198">32-bit</span></span>|<span data-ttu-id="33dd1-199">64 bit</span><span class="sxs-lookup"><span data-stu-id="33dd1-199">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="33dd1-200">İş istasyonu GC</span><span class="sxs-lookup"><span data-stu-id="33dd1-200">Workstation GC</span></span>|<span data-ttu-id="33dd1-201">16 MB</span><span class="sxs-lookup"><span data-stu-id="33dd1-201">16 MB</span></span>|<span data-ttu-id="33dd1-202">256 MB</span><span class="sxs-lookup"><span data-stu-id="33dd1-202">256 MB</span></span>|
|<span data-ttu-id="33dd1-203">Sunucu GC</span><span class="sxs-lookup"><span data-stu-id="33dd1-203">Server GC</span></span>|<span data-ttu-id="33dd1-204">64 MB</span><span class="sxs-lookup"><span data-stu-id="33dd1-204">64 MB</span></span>|<span data-ttu-id="33dd1-205">4 GB</span><span class="sxs-lookup"><span data-stu-id="33dd1-205">4 GB</span></span>|
|<span data-ttu-id="33dd1-206">> 4 mantıksal CPU içeren sunucu GC</span><span class="sxs-lookup"><span data-stu-id="33dd1-206">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="33dd1-207">32 MB</span><span class="sxs-lookup"><span data-stu-id="33dd1-207">32 MB</span></span>|<span data-ttu-id="33dd1-208">2 GB</span><span class="sxs-lookup"><span data-stu-id="33dd1-208">2 GB</span></span>|
|<span data-ttu-id="33dd1-209">> 8 mantıksal CPU 'Lar ile sunucu GC</span><span class="sxs-lookup"><span data-stu-id="33dd1-209">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="33dd1-210">16 MB</span><span class="sxs-lookup"><span data-stu-id="33dd1-210">16 MB</span></span>|<span data-ttu-id="33dd1-211">1 GB</span><span class="sxs-lookup"><span data-stu-id="33dd1-211">1 GB</span></span>|

<span data-ttu-id="33dd1-212">Kısa ömürlü segment 2. nesil nesneleri içerebilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-212">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="33dd1-213">2\. nesil nesneler birden çok segment kullanabilir (işleminiz için gereken ve belleğin izin verdiği kadar).</span><span class="sxs-lookup"><span data-stu-id="33dd1-213">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="33dd1-214">Kısa ömürlü atık toplamanın serbest bırakılan bellek miktarı, kısa ömürlü segmentin boyutuyla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-214">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="33dd1-215">Serbest bırakılan bellek miktarı, ölü nesneler tarafından kullanılan alanla orantılıdır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-215">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="33dd1-216">Çöp toplama sırasında ne olur?</span><span class="sxs-lookup"><span data-stu-id="33dd1-216">What happens during a garbage collection</span></span>

<span data-ttu-id="33dd1-217">Bir çöp toplama işlemi aşağıdaki aşamaları içerir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-217">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="33dd1-218">Tüm canlı nesnelerin listesini bulan ve oluşturan bir işaretleme aşaması.</span><span class="sxs-lookup"><span data-stu-id="33dd1-218">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="33dd1-219">Düzenlenecek nesneler için başvuruları güncelleştiren bir değiştirme aşaması.</span><span class="sxs-lookup"><span data-stu-id="33dd1-219">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="33dd1-220">Yok sayılma nesnelerinin kapladığı alanı geri kazanır ve kalan nesneleri sıkıştırarak bir düzenleme aşaması.</span><span class="sxs-lookup"><span data-stu-id="33dd1-220">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="33dd1-221">Sıkıştırma aşaması, bir atık toplamayı, segmentin eski ucuna doğru bir şekilde taşımış nesneleri hareket ettirir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-221">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="33dd1-222">2\. nesil koleksiyonlar birden çok parçayı kaplayabildiğinden, 2. nesil olarak yükseltilen nesneler eski bir kesime taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-222">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="33dd1-223">2\. nesil ve 2. nesil ve 2. nesil daha fazla VNet, 1. kuşak olarak yükseltildikleri için farklı bir kesime taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-223">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="33dd1-224">Genellikle büyük nesne yığını (LOH) sıkıştırmaz, çünkü büyük nesneleri kopyalamak bir performans cezası uygular.</span><span class="sxs-lookup"><span data-stu-id="33dd1-224">Ordinarily, the large object heap (LOH) is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="33dd1-225">Ancak, .NET Core 'da ve .NET Framework 4.5.1 ve üzeri sürümlerde, büyük nesne yığınını isteğe bağlı olarak sıkıştırmak için <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> özelliğini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-225">However, in .NET Core and in .NET Framework 4.5.1 and later, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span> <span data-ttu-id="33dd1-226">Ayrıca, bir sabit sınır belirtildiğinde, LOH otomatik olarak sıkıştırılır:</span><span class="sxs-lookup"><span data-stu-id="33dd1-226">In addition, the LOH is automatically compacted when a hard limit is set by specifying either:</span></span>

  - <span data-ttu-id="33dd1-227">kapsayıcıda bir bellek sınırı veya</span><span class="sxs-lookup"><span data-stu-id="33dd1-227">a memory limit on a container, or</span></span>
  - <span data-ttu-id="33dd1-228">[gcheaphardlimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) veya [Gcheaphardlimit yüzdesi](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) çalışma zamanı yapılandırma seçenekleri</span><span class="sxs-lookup"><span data-stu-id="33dd1-228">the [GCHeapHardLimit](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit) or [GCHeapHardLimitPercent](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent) run-time configuration options</span></span>

<span data-ttu-id="33dd1-229">Çöp toplayıcı, nesnelerin canlı olup olmadığını anlamak için aşağıdaki bilgileri kullanır:</span><span class="sxs-lookup"><span data-stu-id="33dd1-229">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="33dd1-230">**Yığın kökleri**.</span><span class="sxs-lookup"><span data-stu-id="33dd1-230">**Stack roots**.</span></span> <span data-ttu-id="33dd1-231">Tam zamanında (JıT) derleyici ve yığın denetçisi tarafından sunulan yığın değişkenleri.</span><span class="sxs-lookup"><span data-stu-id="33dd1-231">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="33dd1-232">JıT iyileştirmeleri, yığın değişkenlerinin çöp toplayıcısına bildirildiği kod bölgelerini uzatabilir veya kısaltabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-232">JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="33dd1-233">**Çöp toplama tutamaçları**.</span><span class="sxs-lookup"><span data-stu-id="33dd1-233">**Garbage collection handles**.</span></span> <span data-ttu-id="33dd1-234">Yönetilen nesneleri işaret eden ve Kullanıcı kodu veya ortak dil çalışma zamanı tarafından ayrılabilen işler.</span><span class="sxs-lookup"><span data-stu-id="33dd1-234">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="33dd1-235">**Statik veriler**.</span><span class="sxs-lookup"><span data-stu-id="33dd1-235">**Static data**.</span></span> <span data-ttu-id="33dd1-236">Uygulama etki alanlarında diğer nesnelere başvurıbir statik nesneler.</span><span class="sxs-lookup"><span data-stu-id="33dd1-236">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="33dd1-237">Her uygulama etki alanı, kendi statik nesnelerini izler.</span><span class="sxs-lookup"><span data-stu-id="33dd1-237">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="33dd1-238">Çöp toplama başlamadan önce, çöp toplamayı tetikleyen iş parçacığı hariç tüm yönetilen iş parçacıkları askıya alınır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-238">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="33dd1-239">Aşağıdaki çizimde, çöp toplamayı tetikleyen ve diğer iş parçacıklarının askıya alınmasına neden olan bir iş parçacığı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-239">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

![Bir iş parçacığı bir çöp toplama işlemi tetiklerse](./media/gc-triggered.png)

## <a name="manipulate-unmanaged-resources"></a><span data-ttu-id="33dd1-241">Yönetilmeyen kaynakları değiştirme</span><span class="sxs-lookup"><span data-stu-id="33dd1-241">Manipulate unmanaged resources</span></span>

<span data-ttu-id="33dd1-242">Yönetilen nesneler, kendi yerel dosya tutamaçlarını kullanarak yönetilmeyen nesnelere başvuru yaptığından, atık toplayıcı yalnızca yönetilen yığında belleği izlediği için yönetilmeyen nesneleri açık bir şekilde serbest yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-242">If managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector only tracks memory on the managed heap.</span></span>

<span data-ttu-id="33dd1-243">Yönetilen nesne kullanıcıları, nesne tarafından kullanılan yerel kaynakları atılamayabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-243">Users of the managed object may not dispose the native resources used by the object.</span></span> <span data-ttu-id="33dd1-244">Temizleme işlemini gerçekleştirmek için, yönetilen nesneyi sonlandırılabilir hale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-244">To perform the cleanup, you can make the managed object finalizable.</span></span> <span data-ttu-id="33dd1-245">Sonlandırma, nesne artık kullanımda olmadığında yürütülen Temizleme eylemlerinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-245">Finalization consists of cleanup actions that execute when the object is no longer in use.</span></span> <span data-ttu-id="33dd1-246">Yönetilen nesne söz konusu olduğunda, sonlandırıcı yönteminde belirtilen temizleme eylemlerini gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-246">When the managed object dies, it performs cleanup actions that are specified in its finalizer method.</span></span>

<span data-ttu-id="33dd1-247">Sonlandırılabilir bir nesnenin etkin olmadığı tespit edildiğinde, temizleme eylemlerinin yürütülmesi için Sonlandırıcı bir sıraya konur, ancak nesnenin kendisi bir sonraki oluşturmaya yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-247">When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</span></span> <span data-ttu-id="33dd1-248">Bu nedenle, nesnenin geri kazanılıp kazanılmadığını öğrenmek için bu kuşada gerçekleşen sonraki atık toplamaya (bir sonraki atık toplama olması gerekmez) kadar beklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-248">Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</span></span>

<span data-ttu-id="33dd1-249">Sonlandırma hakkında daha fazla bilgi için bkz. <xref:System.Object.Finalize?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="33dd1-249">For more information about finalization, see <xref:System.Object.Finalize?displayProperty=nameWithType>.</span></span>

## <a name="workstation-and-server-garbage-collection"></a><span data-ttu-id="33dd1-250">İş istasyonu ve sunucu atık toplama</span><span class="sxs-lookup"><span data-stu-id="33dd1-250">Workstation and server garbage collection</span></span>

<span data-ttu-id="33dd1-251">Çöp toplayıcı kendi kendini ayarlamadır ve çok çeşitli senaryolarda çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-251">The garbage collector is self-tuning and can work in a wide variety of scenarios.</span></span> <span data-ttu-id="33dd1-252">Bir [yapılandırma dosyası ayarını](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection) , iş yükünün özelliklerine göre çöp toplamanın türünü ayarlamak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-252">You can use a [configuration file setting](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection) to set the type of garbage collection based on the characteristics of the workload.</span></span> <span data-ttu-id="33dd1-253">CLR aşağıdaki çöp toplama türlerini sağlar:</span><span class="sxs-lookup"><span data-stu-id="33dd1-253">The CLR provides the following types of garbage collection:</span></span>

- <span data-ttu-id="33dd1-254">İş istasyonu çöp toplama (GC), istemci uygulamaları için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-254">Workstation garbage collection (GC) is designed for client apps.</span></span> <span data-ttu-id="33dd1-255">Tek başına uygulamalar için varsayılan GC Flavor 'dir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-255">It is the default GC flavor for standalone apps.</span></span> <span data-ttu-id="33dd1-256">Barındırılan uygulamalarda, örneğin, ASP.NET tarafından barındırılan uygulamalar için, ana bilgisayar varsayılan GC özelliğini belirler.</span><span class="sxs-lookup"><span data-stu-id="33dd1-256">For hosted apps, for example, those hosted by ASP.NET, the host determines the default GC flavor.</span></span>

  <span data-ttu-id="33dd1-257">İş istasyonu atık toplama işlemi eşzamanlı olabilir veya eşzamanlı olmayan bir şekilde olabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-257">Workstation garbage collection can be concurrent or non-concurrent.</span></span> <span data-ttu-id="33dd1-258">Eşzamanlı atık toplama, yönetilen iş parçacıklarının bir çöp toplama sırasında işlemlere devam etmesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-258">Concurrent garbage collection enables managed threads to continue operations during a garbage collection.</span></span> <span data-ttu-id="33dd1-259">[Arka plan atık toplama](#background-workstation-garbage-collection) , .NET Framework 4 ve sonraki sürümlerde [eşzamanlı çöp toplama](#concurrent-garbage-collection) yerini alır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-259">[Background garbage collection](#background-workstation-garbage-collection) replaces [concurrent garbage collection](#concurrent-garbage-collection) in .NET Framework 4 and later versions.</span></span>

- <span data-ttu-id="33dd1-260">Yüksek aktarım hızı ve ölçeklenebilirlik gerektiren sunucu uygulamalarına yönelik olan sunucu çöp toplama.</span><span class="sxs-lookup"><span data-stu-id="33dd1-260">Server garbage collection, which is intended for server applications that need high throughput and scalability.</span></span>

  - <span data-ttu-id="33dd1-261">.NET Core 'da, sunucu çöp toplama, eş zamanlı olmayan veya arka plan olabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-261">In .NET Core, server garbage collection can be non-concurrent or background.</span></span>

  - <span data-ttu-id="33dd1-262">.NET Framework 4,5 ve sonraki sürümlerinde, sunucu çöp toplama, eş zamanlı olmayan veya arka plan olabilir (arka plan atık toplama, eşzamanlı atık toplamayı değiştirir).</span><span class="sxs-lookup"><span data-stu-id="33dd1-262">In .NET Framework 4.5 and later versions, server garbage collection can be non-concurrent or background (background garbage collection replaces concurrent garbage collection).</span></span> <span data-ttu-id="33dd1-263">.NET Framework 4 ve önceki sürümlerde, sunucu çöp toplama işlemi eşzamanlı değildir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-263">In .NET Framework 4 and previous versions, server garbage collection is non-concurrent.</span></span>

<span data-ttu-id="33dd1-264">Aşağıdaki çizimde, bir sunucusunda çöp toplamayı gerçekleştiren adanmış iş parçacıkları gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-264">The following illustration shows the dedicated threads that perform the garbage collection on a server:</span></span>

![Sunucu atık toplama Iş parçacıkları](./media/gc-server.png)

### <a name="compare-workstation-and-server-garbage-collection"></a><span data-ttu-id="33dd1-266">İş istasyonu ve sunucu çöp toplamayı karşılaştırın</span><span class="sxs-lookup"><span data-stu-id="33dd1-266">Compare workstation and server garbage collection</span></span>

<span data-ttu-id="33dd1-267">İş istasyonu çöp toplama işlemi için iş parçacığı ve performans değerlendirmeleri aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-267">The following are threading and performance considerations for workstation garbage collection:</span></span>

- <span data-ttu-id="33dd1-268">Koleksiyon, çöp toplamayı tetikleyen ve aynı önceliğe kalan Kullanıcı iş parçacığında oluşur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-268">The collection occurs on the user thread that triggered the garbage collection and remains at the same priority.</span></span> <span data-ttu-id="33dd1-269">Kullanıcı iş parçacıkları genellikle normal öncelikte çalıştığı için çöp toplayıcı (normal bir öncelikli iş parçacığı üzerinde çalışır), CPU süresi için diğer iş parçacıklarıyla rekabet etmelidir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-269">Because user threads typically run at normal priority, the garbage collector (which runs on a normal priority thread) must compete with other threads for CPU time.</span></span> <span data-ttu-id="33dd1-270">(Yerel kod çalıştıran iş parçacıkları sunucu veya iş istasyonu çöp toplamadan askıya alınmaz.)</span><span class="sxs-lookup"><span data-stu-id="33dd1-270">(Threads that run native code are not suspended on either server or workstation garbage collection.)</span></span>

- <span data-ttu-id="33dd1-271">İş istasyonu çöp toplama her zaman, [yapılandırma ayarından](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver)bağımsız olarak yalnızca bir işlemciye sahip olan bir bilgisayarda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-271">Workstation garbage collection is always used on a computer that has only one processor, regardless of the [configuration setting](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver).</span></span>

<span data-ttu-id="33dd1-272">Aşağıda sunucu çöp toplama için iş parçacığı ve performans konuları verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-272">The following are threading and performance considerations for server garbage collection:</span></span>

- <span data-ttu-id="33dd1-273">Koleksiyon `THREAD_PRIORITY_HIGHEST` öncelik düzeyinde çalışan birden fazla adanmış iş parçacığında oluşur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-273">The collection occurs on multiple dedicated threads that are running at `THREAD_PRIORITY_HIGHEST` priority level.</span></span>

- <span data-ttu-id="33dd1-274">Her CPU için bir yığın ve bir ayrılmış iş parçacığı her CPU için sağlanır ve sayfa@@ 'ler aynı anda toplanır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-274">A heap and a dedicated thread to perform garbage collection are provided for each CPU, and the heaps are collected at the same time.</span></span> <span data-ttu-id="33dd1-275">Her yığın küçük bir nesne yığını ve büyük bir nesne yığını içerir ve tüm yığınlara Kullanıcı kodu tarafından erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-275">Each heap contains a small object heap and a large object heap, and all heaps can be accessed by user code.</span></span> <span data-ttu-id="33dd1-276">Farklı yığınlardaki nesneler birbirlerine başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-276">Objects on different heaps can refer to each other.</span></span>

- <span data-ttu-id="33dd1-277">Birden çok çöp toplama iş parçacığı birlikte çalıştığından, sunucu çöp toplama, aynı boyuttaki yığında iş istasyonu atık toplamadan daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-277">Because multiple garbage collection threads work together, server garbage collection is faster than workstation garbage collection on the same size heap.</span></span>

- <span data-ttu-id="33dd1-278">Sunucu çöp toplama genellikle daha büyük boyut segmentlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-278">Server garbage collection often has larger size segments.</span></span> <span data-ttu-id="33dd1-279">Ancak, bu yalnızca bir Genelleştirme 'dir: kesim boyutu uygulamaya özeldir ve değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-279">However, this is only a generalization: segment size is implementation-specific and is subject to change.</span></span> <span data-ttu-id="33dd1-280">Uygulamanızı ayarlamaya yönelik çöp toplayıcı tarafından ayrılan parçaların boyutu hakkında varsayımlar yapmayın.</span><span class="sxs-lookup"><span data-stu-id="33dd1-280">Don't make assumptions about the size of segments allocated by the garbage collector when tuning your app.</span></span>

- <span data-ttu-id="33dd1-281">Sunucu atık toplama, kaynak kullanımı yoğun olabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-281">Server garbage collection can be resource-intensive.</span></span> <span data-ttu-id="33dd1-282">Örneğin, 4 işlemcili bir bilgisayarda çalışan sunucu GC 'yi kullanan 12 işlem olduğunu düşünün.</span><span class="sxs-lookup"><span data-stu-id="33dd1-282">For example, imagine that there are 12 processes that use server GC running on a computer that has 4 processors.</span></span> <span data-ttu-id="33dd1-283">Tüm süreçler aynı anda çöp toplama işlemi gerçekleşiyorsa, aynı işlemcide zamanlanan 12 iş parçacığı olduğu için birbirleriyle karışacaktır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-283">If all the processes happen to collect garbage at the same time, they would interfere with each other, as there would be 12 threads scheduled on the same processor.</span></span> <span data-ttu-id="33dd1-284">Süreçler etkinse, hepsi sunucu GC 'yi kullanmak iyi bir fikir değildir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-284">If the processes are active, it's not a good idea to have them all use server GC.</span></span>

<span data-ttu-id="33dd1-285">Bir uygulamanın yüzlerce örneğini çalıştırıyorsanız, eşzamanlı atık toplama devre dışı bırakılmış iş istasyonu çöp toplamayı kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="33dd1-285">If you're running hundreds of instances of an application, consider using workstation garbage collection with concurrent garbage collection disabled.</span></span> <span data-ttu-id="33dd1-286">Bu, performansı iyileştirebilen daha az bağlam geçişe neden olur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-286">This will result in less context switching, which can improve performance.</span></span>

## <a name="background-workstation-garbage-collection"></a><span data-ttu-id="33dd1-287">Arka plan iş istasyonu çöp toplama</span><span class="sxs-lookup"><span data-stu-id="33dd1-287">Background workstation garbage collection</span></span>

<span data-ttu-id="33dd1-288">Arka plan iş istasyonu çöp toplama bölümünde, 2. nesil toplama işlemi devam ederken kısa ömürlü nesiller (0 ve 1) gerektiği şekilde toplanır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-288">In background workstation garbage collection, ephemeral generations (0 and 1) are collected as needed while the collection of generation 2 is in progress.</span></span> <span data-ttu-id="33dd1-289">Arka plan iş istasyonu çöp toplama işlemi adanmış bir iş parçacığında gerçekleştirilir ve yalnızca 2. nesil koleksiyonlar için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-289">Background workstation garbage collection is performed on a dedicated thread and applies only to generation 2 collections.</span></span>

<span data-ttu-id="33dd1-290">Arka plan atık toplama varsayılan olarak etkindir ve .NET Framework uygulamalar veya .NET Core uygulamalarında [System. GC. eş zamanlı](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent) ayarı [gcConcurrent](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) yapılandırma ayarıyla etkinleştirilebilir veya devre dışı bırakılabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-290">Background garbage collection is enabled by default and can be enabled or disabled with the [gcConcurrent](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) configuration setting in .NET Framework apps or the [System.GC.Concurrent](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent) setting in .NET Core apps.</span></span>

> [!NOTE]
> <span data-ttu-id="33dd1-291">Arka plan atık toplama, [eşzamanlı atık toplamayı](#concurrent-garbage-collection) değiştirir ve .NET Framework 4 ve sonraki sürümlerde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-291">Background garbage collection replaces [concurrent garbage collection](#concurrent-garbage-collection) and is available in .NET Framework 4 and later versions.</span></span> <span data-ttu-id="33dd1-292">.NET Framework 4 ' te yalnızca iş istasyonu çöp toplama için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-292">In .NET Framework 4, it's supported only for workstation garbage collection.</span></span> <span data-ttu-id="33dd1-293">.NET Framework 4,5 ' den başlayarak, arka plan atık toplama, hem iş istasyonu hem de sunucu çöp toplama için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-293">Starting with .NET Framework 4.5, background garbage collection is available for both workstation and server garbage collection.</span></span>

<span data-ttu-id="33dd1-294">Arka plan atık toplama sırasında kısa ömürlü oluşumlara yönelik bir koleksiyon, ön plan atık toplama olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-294">A collection on ephemeral generations during background garbage collection is known as foreground garbage collection.</span></span> <span data-ttu-id="33dd1-295">Ön plan atık koleksiyonları gerçekleştiğinde, tüm yönetilen iş parçacıkları askıya alınır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-295">When foreground garbage collections occur, all managed threads are suspended.</span></span>

<span data-ttu-id="33dd1-296">Arka plan atık toplama işlemi devam ederken ve nesil 0 ' da yeterli nesne ayırdığınızda CLR, 1. nesil bir ön plan atık toplama işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-296">When background garbage collection is in progress and you've allocated enough objects in generation 0, the CLR performs a generation 0 or generation 1 foreground garbage collection.</span></span> <span data-ttu-id="33dd1-297">Adanmış arka plan atık toplama iş parçacığı, ön plan atık toplama için bir istek olup olmadığını anlamak için sık kullanılan güvenli noktaları denetler.</span><span class="sxs-lookup"><span data-stu-id="33dd1-297">The dedicated background garbage collection thread checks at frequent safe points to determine whether there is a request for foreground garbage collection.</span></span> <span data-ttu-id="33dd1-298">Varsa, ön plan atık toplama işleminin gerçekleşmesi için arka plan koleksiyonu kendisini askıya alır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-298">If there is, the background collection suspends itself so that foreground garbage collection can occur.</span></span> <span data-ttu-id="33dd1-299">Ön plan atık toplama işlemi tamamlandıktan sonra, adanmış arka plan atık toplama iş parçacığı ve Kullanıcı iş parçacıkları sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="33dd1-299">After the foreground garbage collection is completed, the dedicated background garbage collection thread and user threads resume.</span></span>

<span data-ttu-id="33dd1-300">Arka plan atık toplama sırasında kısa ömürlü çöp koleksiyonları gerçekleşebildiğinden arka plan atık toplama, eşzamanlı atık toplama tarafından uygulanan ayırma kısıtlamalarını ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-300">Background garbage collection removes allocation restrictions imposed by concurrent garbage collection, because ephemeral garbage collections can occur during background garbage collection.</span></span> <span data-ttu-id="33dd1-301">Arka plan atık toplama, kısa ömürlü neslerdeki ölü nesneleri kaldırabilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-301">Background garbage collection can remove dead objects in ephemeral generations.</span></span> <span data-ttu-id="33dd1-302">Ayrıca, 1. nesil atık toplama işlemi sırasında gerekirse yığını genişletebilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-302">It can also expand the heap if needed during a generation 1 garbage collection.</span></span>

<span data-ttu-id="33dd1-303">Aşağıdaki çizimde, bir iş istasyonunda ayrı bir adanmış iş parçacığında gerçekleştirilen arka plan atık toplama işlemi gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-303">The following illustration shows background garbage collection performed on a separate dedicated thread on a workstation:</span></span>

![Arka plan iş istasyonu çöp toplama](./media/fundamentals/background-workstation-garbage-collection.png)

### <a name="background-server-garbage-collection"></a><span data-ttu-id="33dd1-305">Arka plan sunucusu çöp toplama</span><span class="sxs-lookup"><span data-stu-id="33dd1-305">Background server garbage collection</span></span>

<span data-ttu-id="33dd1-306">.NET Framework 4,5 ile başlayarak, arka plan sunucusu çöp toplama sunucu çöp toplama için varsayılan moddur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-306">Starting with .NET Framework 4.5, background server garbage collection is the default mode for server garbage collection.</span></span>

<span data-ttu-id="33dd1-307">Arka plan sunucusu çöp toplama, önceki bölümde açıklanan arka plan iş istasyonu çöp toplamasına benzer şekilde çalışır, ancak bazı farklılıklar vardır:</span><span class="sxs-lookup"><span data-stu-id="33dd1-307">Background server garbage collection functions similarly to background workstation garbage collection, described in the previous section, but there are a few differences:</span></span>

- <span data-ttu-id="33dd1-308">Arka plan iş istasyonu çöp toplama, bir adanmış arka plan atık toplama iş parçacığı kullanır, ancak arka plan sunucusu çöp toplama birden çok iş</span><span class="sxs-lookup"><span data-stu-id="33dd1-308">Background workstation garbage collection uses one dedicated background garbage collection thread, whereas background server garbage collection uses multiple threads.</span></span> <span data-ttu-id="33dd1-309">Genellikle, her mantıksal işlemci için adanmış bir iş parçacığı vardır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-309">Typically, there's a dedicated thread for each logical processor.</span></span>

- <span data-ttu-id="33dd1-310">İş istasyonu arka plan atık toplama iş parçacığından farklı olarak, bu iş parçacıkları zaman aşımına uğrar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-310">Unlike the workstation background garbage collection thread, these threads do not time out.</span></span>

<span data-ttu-id="33dd1-311">Aşağıdaki çizimde, bir sunucudaki ayrı bir adanmış iş parçacığında gerçekleştirilen arka plan atık toplama işlemi gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-311">The following illustration shows background garbage collection performed on a separate dedicated thread on a server:</span></span>

![Arka plan sunucusu çöp toplama](./media/fundamentals/background-server-garbage-collection.png)

## <a name="concurrent-garbage-collection"></a><span data-ttu-id="33dd1-313">Eşzamanlı atık toplama</span><span class="sxs-lookup"><span data-stu-id="33dd1-313">Concurrent garbage collection</span></span>

> [!TIP]
> <span data-ttu-id="33dd1-314">Bu bölüm için geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="33dd1-314">This section applies to:</span></span>
>
> - <span data-ttu-id="33dd1-315">İş istasyonu atık toplama için .NET Framework 3,5 ve öncesi</span><span class="sxs-lookup"><span data-stu-id="33dd1-315">.NET Framework 3.5 and earlier for workstation garbage collection</span></span>
> - <span data-ttu-id="33dd1-316">Sunucu atık toplama için .NET Framework 4 ve öncesi</span><span class="sxs-lookup"><span data-stu-id="33dd1-316">.NET Framework 4 and earlier for server garbage collection</span></span>
>
> <span data-ttu-id="33dd1-317">Eş zamanlı atık, sonraki sürümlerde [arka plan atık toplama](#background-workstation-garbage-collection) ile değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-317">Concurrent garbage is replaced by [background garbage collection](#background-workstation-garbage-collection) in later versions.</span></span>

<span data-ttu-id="33dd1-318">İş istasyonu veya sunucu çöp toplama bölümünde, iş parçacıklarının, koleksiyon süresince büyük bir süre için çöp toplamayı gerçekleştiren adanmış bir iş parçacığıyla eşzamanlı olarak çalışmasını sağlayan [eşzamanlı atık toplamayı etkinleştirebilirsiniz](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md).</span><span class="sxs-lookup"><span data-stu-id="33dd1-318">In workstation or server garbage collection, you can [enable concurrent garbage collection](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md), which enables threads to run concurrently with a dedicated thread that performs the garbage collection for most of the duration of the collection.</span></span> <span data-ttu-id="33dd1-319">Bu seçenek, kuşak 2 ' de yalnızca çöp koleksiyonlarını etkiler; nesil 0 ve 1 her zaman eşzamanlı değildir çünkü çok hızlı tamamlanır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-319">This option affects only garbage collections in generation 2; generations 0 and 1 are always non-concurrent because they finish very fast.</span></span>

<span data-ttu-id="33dd1-320">Eşzamanlı atık toplama, bir koleksiyon için duraklamaları en aza indirerek etkileşimli uygulamaların daha fazla yanıt vermesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="33dd1-320">Concurrent garbage collection enables interactive applications to be more responsive by minimizing pauses for a collection.</span></span> <span data-ttu-id="33dd1-321">Yönetilen iş parçacıkları, eşzamanlı atık toplama iş parçacığı çalışırken çoğu zaman çalışmaya devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-321">Managed threads can continue to run most of the time while the concurrent garbage collection thread is running.</span></span> <span data-ttu-id="33dd1-322">Çöp toplama işlemi gerçekleşirken bu, daha kısa duraklamalar oluşur.</span><span class="sxs-lookup"><span data-stu-id="33dd1-322">This results in shorter pauses while a garbage collection is occurring.</span></span>

<span data-ttu-id="33dd1-323">Eş zamanlı çöp toplama, adanmış bir iş parçacığında gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-323">Concurrent garbage collection is performed on a dedicated thread.</span></span> <span data-ttu-id="33dd1-324">Varsayılan olarak, CLR, eşzamanlı atık toplama özellikli iş istasyonu çöp toplamayı çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="33dd1-324">By default, the CLR runs workstation garbage collection with concurrent garbage collection enabled.</span></span> <span data-ttu-id="33dd1-325">Bu, tek işlemci ve çok işlemcili bilgisayarlar için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-325">This is true for single-processor and multi-processor computers.</span></span>

<span data-ttu-id="33dd1-326">Aşağıdaki çizimde ayrı bir adanmış iş parçacığında gerçekleştirilen eşzamanlı çöp toplama gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33dd1-326">The following illustration shows concurrent garbage collection performed on a separate dedicated thread.</span></span>

![Eşzamanlı atık toplama Iş parçacıkları](./media/gc-concurrent.png)

## <a name="see-also"></a><span data-ttu-id="33dd1-328">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="33dd1-328">See also</span></span>

- [<span data-ttu-id="33dd1-329">GC için yapılandırma seçenekleri</span><span class="sxs-lookup"><span data-stu-id="33dd1-329">Configuration options for GC</span></span>](../../core/run-time-config/garbage-collector.md)
- [<span data-ttu-id="33dd1-330">Çöp toplama</span><span class="sxs-lookup"><span data-stu-id="33dd1-330">Garbage collection</span></span>](index.md)
