---
title: Güvenli ve verimli C# kodu yazın
description: C# dilinde yapılan son geliştirmeler, daha önce güvenli olmayan kodla ilişkili performansın doğrulanabilir güvenli kodu yazmanızı sağlar.
ms.date: 10/23/2018
ms.technology: csharp-advanced-concepts
ms.custom: mvc
ms.openlocfilehash: 365320fef5a2f9cd123086c1baed9a786ede9f05
ms.sourcegitcommit: 59e36e65ac81cdd094a5a84617625b2a0ff3506e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/27/2020
ms.locfileid: "80345088"
---
# <a name="write-safe-and-efficient-c-code"></a><span data-ttu-id="99bce-103">Güvenli ve verimli C# kodu yazın</span><span class="sxs-lookup"><span data-stu-id="99bce-103">Write safe and efficient C# code</span></span>

<span data-ttu-id="99bce-104">C#'daki yeni özellikler, daha iyi performansla doğrulanabilir güvenli kod yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-104">New features in C# enable you to write verifiable safe code with better performance.</span></span> <span data-ttu-id="99bce-105">Bu teknikleri dikkatle uygularsanız, daha az senaryo güvenli olmayan kod gerektirir.</span><span class="sxs-lookup"><span data-stu-id="99bce-105">If you carefully apply these techniques, fewer scenarios require unsafe code.</span></span> <span data-ttu-id="99bce-106">Bu özellikler, yöntem bağımsız değişkenleri ve yöntem döndürür olarak değer türlerine başvuruları kullanmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="99bce-106">These features make it easier to use references to value types as method arguments and method returns.</span></span> <span data-ttu-id="99bce-107">Güvenli bir şekilde yapıldığında, bu teknikler kopyalama değer türlerini en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="99bce-107">When done safely, these techniques minimize copying value types.</span></span> <span data-ttu-id="99bce-108">Değer türlerini kullanarak, ayırma ve çöp toplama geçişlerinin sayısını en aza indirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-108">By using value types, you can minimize the number of allocations and garbage collection passes.</span></span>

<span data-ttu-id="99bce-109">Bu makaledeki örnek kodun çoğu C# 7.2'ye eklenen özellikleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-109">Much of the sample code in this article uses features added in C# 7.2.</span></span> <span data-ttu-id="99bce-110">Bu özellikleri kullanmak için projenizi C# 7.2 veya daha sonra kullanacak şekilde yapılandırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="99bce-110">To use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="99bce-111">Dil sürümünü ayarlama hakkında daha fazla bilgi için [bkz.](language-reference/configure-language-version.md)</span><span class="sxs-lookup"><span data-stu-id="99bce-111">For more information on setting the language version, see [configure the language version](language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="99bce-112">Bu makalede, verimli kaynak yönetimi teknikleri üzerinde duruluyor.</span><span class="sxs-lookup"><span data-stu-id="99bce-112">This article focuses on techniques for efficient resource management.</span></span> <span data-ttu-id="99bce-113">Değer türlerini kullanmanın bir avantajı da genellikle yığın ayırmalarından kaçınmalarıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-113">One advantage to using value types is that they often avoid heap allocations.</span></span> <span data-ttu-id="99bce-114">Dezavantajı, değere göre kopyalanmış olmalarıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-114">The disadvantage is that they're copied by value.</span></span> <span data-ttu-id="99bce-115">Bu takas, büyük miktarda veri üzerinde çalışan algoritmaları optimize etmeyi zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="99bce-115">This trade-off makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="99bce-116">C# 7.2'deki yeni dil özellikleri, değer türlerine yapılan atıfları kullanarak güvenli verimli kod sağlayan mekanizmalar sağlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-116">New language features in C# 7.2 provide mechanisms that enable safe efficient code using references to value types.</span></span> <span data-ttu-id="99bce-117">Hem ayırmaları hem de kopyalama işlemlerini en aza indirmek için bu özellikleri akıllıca kullanın.</span><span class="sxs-lookup"><span data-stu-id="99bce-117">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="99bce-118">Bu makalede, bu yeni özellikler inceletir.</span><span class="sxs-lookup"><span data-stu-id="99bce-118">This article explores those new features.</span></span>

<span data-ttu-id="99bce-119">Bu makalede, aşağıdaki kaynak yönetimi teknikleri üzerinde duruluyor:</span><span class="sxs-lookup"><span data-stu-id="99bce-119">This article focuses on the following resource management techniques:</span></span>

- <span data-ttu-id="99bce-120">Bir [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) türün **değişmez**olduğunu ifade etmek için a bildirin.</span><span class="sxs-lookup"><span data-stu-id="99bce-120">Declare a [`readonly struct`](language-reference/builtin-types/struct.md#readonly-struct) to express that a type is **immutable**.</span></span> <span data-ttu-id="99bce-121">Bu, derleyicinin parametreleri kullanırken [`in`](language-reference/keywords/in-parameter-modifier.md) savunma kopyalarını kaydetmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-121">That enables the compiler to save defensive copies when using [`in`](language-reference/keywords/in-parameter-modifier.md) parameters.</span></span>
- <span data-ttu-id="99bce-122">Bir tür değişmez değilse, üyenin `struct` durumu `readonly` değiştirmediğini belirtmek için üye bildirin.</span><span class="sxs-lookup"><span data-stu-id="99bce-122">If a type can't be immutable, declare `struct` members `readonly` to indicate that the member doesn't modify state.</span></span>
- <span data-ttu-id="99bce-123">İade [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) değeri daha `struct` <xref:System.IntPtr.Size?displayProperty=nameWithType> büyükse ve depolama ömrü değeri döndüren yöntemden daha büyükse bir iade kullanın.</span><span class="sxs-lookup"><span data-stu-id="99bce-123">Use a [`ref readonly`](language-reference/keywords/ref.md#reference-return-values) return when the return value is a `struct` larger than <xref:System.IntPtr.Size?displayProperty=nameWithType> and the storage lifetime is greater than the method returning the value.</span></span>
- <span data-ttu-id="99bce-124">A `readonly struct` boyutu daha <xref:System.IntPtr.Size?displayProperty=nameWithType>büyükse, performans nedenleriyle `in` bir parametre olarak geçirmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-124">When the size of a `readonly struct` is bigger than <xref:System.IntPtr.Size?displayProperty=nameWithType>, you should pass it as an `in` parameter for performance reasons.</span></span>
- <span data-ttu-id="99bce-125">Değiştirici `struct` ile `in` beyan edilmedikçe veya yöntem yalnızca `readonly` yapı nın üyelerini çağırmadığı sürece asla bir parametre olarak geçmeyin. `readonly`</span><span class="sxs-lookup"><span data-stu-id="99bce-125">Never pass a `struct` as an `in` parameter unless it's declared with the `readonly` modifier or the method calls only `readonly` members of the struct.</span></span> <span data-ttu-id="99bce-126">Bu kılavuzun ihlal için de performansı olumsuz etkileyebilir ve belirsiz bir davranışa yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-126">Violating this guidance may negatively affect performance and could lead to an obscure behavior.</span></span>
- <span data-ttu-id="99bce-127">Bir [`ref struct`](language-reference/keywords/ref.md#ref-struct-types)byte `readonly ref struct` dizisi <xref:System.Span%601> olarak <xref:System.ReadOnlySpan%601> bellekle çalışmak için bir veya benzeri bir şey kullanın.</span><span class="sxs-lookup"><span data-stu-id="99bce-127">Use a [`ref struct`](language-reference/keywords/ref.md#ref-struct-types), or a `readonly ref struct` such as <xref:System.Span%601> or <xref:System.ReadOnlySpan%601> to work with memory as a sequence of bytes.</span></span>

<span data-ttu-id="99bce-128">Bu teknikler **referanslar** ve **değerler**açısından iki rakip hedefleri dengelemek için zorlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-128">These techniques force you to balance two competing goals with regard to **references** and **values**.</span></span> <span data-ttu-id="99bce-129">[Başvuru türleri](programming-guide/types/index.md#reference-types) olan değişkenler bellekteki konuma bir başvuru tutar.</span><span class="sxs-lookup"><span data-stu-id="99bce-129">Variables that are [reference types](programming-guide/types/index.md#reference-types) hold a reference to the location in memory.</span></span> <span data-ttu-id="99bce-130">[Değer türleri](programming-guide/types/index.md#value-types) olan değişkenler doğrudan değerlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="99bce-130">Variables that are [value types](programming-guide/types/index.md#value-types) directly contain their value.</span></span> <span data-ttu-id="99bce-131">Bu farklılıklar, bellek kaynaklarını yönetmek için önemli olan temel farklılıkları vurgular.</span><span class="sxs-lookup"><span data-stu-id="99bce-131">These differences highlight the key differences that are important for managing memory resources.</span></span> <span data-ttu-id="99bce-132">**Değer türleri** genellikle bir yönteme geçirildiğinde veya bir yöntemden döndürüldüğünde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-132">**Value types** are typically copied when passed to a method or returned from a method.</span></span> <span data-ttu-id="99bce-133">Bu davranış, bir değer `this` türünün üyelerini ararken değerini kopyalamayı içerir.</span><span class="sxs-lookup"><span data-stu-id="99bce-133">This behavior includes copying the value of `this` when calling members of a value type.</span></span> <span data-ttu-id="99bce-134">Kopyanın maliyeti, türün boyutuyla ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="99bce-134">The cost of the copy is related to the size of the type.</span></span> <span data-ttu-id="99bce-135">**Başvuru türleri** yönetilen yığına ayrılır.</span><span class="sxs-lookup"><span data-stu-id="99bce-135">**Reference types** are allocated on the managed heap.</span></span> <span data-ttu-id="99bce-136">Her yeni nesne yeni bir ayırma gerektirir ve daha sonra geri alınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-136">Each new object requires a new allocation, and subsequently must be reclaimed.</span></span> <span data-ttu-id="99bce-137">Bu iki işlem de zaman alır.</span><span class="sxs-lookup"><span data-stu-id="99bce-137">Both these operations take time.</span></span> <span data-ttu-id="99bce-138">Başvuru türü bir bağımsız değişken olarak bir yönteme geçirildiğinde veya bir yöntemden döndürüldüğünde başvuru kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-138">The reference is copied when a reference type is passed as an argument to a method or returned from a method.</span></span>

<span data-ttu-id="99bce-139">Bu makalede, bu önerileri açıklamak için 3B noktası yapısının aşağıdaki örnek kavramını kullanır:</span><span class="sxs-lookup"><span data-stu-id="99bce-139">This article uses the following example concept of the 3D-point structure to explain these recommendations:</span></span>

```csharp
public struct Point3D
{
    public double X;
    public double Y;
    public double Z;
}
```

<span data-ttu-id="99bce-140">Farklı örnekler bu kavramın farklı uygulamalarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-140">Different examples use different implementations of this concept.</span></span>

## <a name="declare-readonly-structs-for-immutable-value-types"></a><span data-ttu-id="99bce-141">Değişmez değer türleri için yalnızca okunan structs'u bildirin</span><span class="sxs-lookup"><span data-stu-id="99bce-141">Declare readonly structs for immutable value types</span></span>

<span data-ttu-id="99bce-142">`struct` Değiştiricinin `readonly` kullanılmasını bildirmek derleyiciye amacınızın değişmez bir tür oluşturmak olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="99bce-142">Declaring a `struct` using the `readonly` modifier informs the compiler that your intent is to create an immutable type.</span></span> <span data-ttu-id="99bce-143">Derleyici bu tasarım kararını aşağıdaki kurallarla zorlar:</span><span class="sxs-lookup"><span data-stu-id="99bce-143">The compiler enforces that design decision with the following rules:</span></span>

- <span data-ttu-id="99bce-144">Tüm saha üyeleri,`readonly`</span><span class="sxs-lookup"><span data-stu-id="99bce-144">All field members must be `readonly`</span></span>
- <span data-ttu-id="99bce-145">Otomatik olarak uygulanan özellikler de dahil olmak üzere tüm özellikler salt okunur olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-145">All properties must be read-only, including auto-implemented properties.</span></span>

<span data-ttu-id="99bce-146">Bu iki kural, hiçbir `readonly struct` üyenin o yapının durumunu dengelenmediğinden emin olmak için yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="99bce-146">These two rules are sufficient to ensure that no member of a `readonly struct` modifies the state of that struct.</span></span> <span data-ttu-id="99bce-147">Değişmez. `struct`</span><span class="sxs-lookup"><span data-stu-id="99bce-147">The `struct` is immutable.</span></span> <span data-ttu-id="99bce-148">Yapı, `Point3D` aşağıdaki örnekte gösterildiği gibi değişmez bir yapı olarak tanımlanabilir:</span><span class="sxs-lookup"><span data-stu-id="99bce-148">The `Point3D` structure could be defined as an immutable struct as shown in the following example:</span></span>

```csharp
readonly public struct ReadonlyPoint3D
{
    public ReadonlyPoint3D(double x, double y, double z)
    {
        this.X = x;
        this.Y = y;
        this.Z = z;
    }

    public double X { get; }
    public double Y { get; }
    public double Z { get; }
}
```

<span data-ttu-id="99bce-149">Tasarım amacınız değişmez bir değer türü oluşturmak olduğunda bu öneriyi uygulayın.</span><span class="sxs-lookup"><span data-stu-id="99bce-149">Follow this recommendation whenever your design intent is to create an immutable value type.</span></span> <span data-ttu-id="99bce-150">Performans iyileştirmeleri ek bir avantajdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-150">Any performance improvements are an added benefit.</span></span> <span data-ttu-id="99bce-151">Tasarım `readonly struct` amacınızı açıkça ifade eder.</span><span class="sxs-lookup"><span data-stu-id="99bce-151">The `readonly struct` clearly expresses your design intent.</span></span>

## <a name="declare-readonly-members-when-a-struct-cant-be-immutable"></a><span data-ttu-id="99bce-152">Bir yapı değişmez olamaz zaman salt okunur üyeleri bildirin</span><span class="sxs-lookup"><span data-stu-id="99bce-152">Declare readonly members when a struct can't be immutable</span></span>

<span data-ttu-id="99bce-153">C# 8.0 ve daha sonra, bir yapı türü mutasyona neden olmayan üyeleri beyan `readonly`etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="99bce-153">In C# 8.0 and later, when a struct type is mutable, you should declare members that don't cause mutation to be `readonly`.</span></span> <span data-ttu-id="99bce-154">3B nokta yapısı gerektiren, ancak susturulabilirliği desteklemesi gereken farklı bir uygulama düşünün.</span><span class="sxs-lookup"><span data-stu-id="99bce-154">Consider a different application that needs a 3D point structure, but must support mutability.</span></span> <span data-ttu-id="99bce-155">3B nokta yapısının aşağıdaki sürümü, değiştiriciyi `readonly` yalnızca yapıyı değiştirmeyen üyelere ekler.</span><span class="sxs-lookup"><span data-stu-id="99bce-155">The following version of the 3D point structure adds the `readonly` modifier only to those members that don't modify the structure.</span></span> <span data-ttu-id="99bce-156">Tasarımınızın bazı üyeler tarafından yapıda yapılan değişiklikleri desteklemesi gerektiğinde, ancak yine de yalnızca bazı üyelere okunan zorlamanın avantajlarını istediğinizde bu örneği izleyin:</span><span class="sxs-lookup"><span data-stu-id="99bce-156">Follow this example when your design must support modifications to the struct by some members, but you still want the benefits of enforcing readonly on some members:</span></span>

```csharp
public struct Point3D
{
    public Point3D(double x, double y, double z)
    {
        _x = x;
        _y = y;
        _z = z;
    }

    private double _x;
    public double X
    {
        readonly get => _x;
        set => _x = value;
    }

    private double _y;
    public double Y
    {
        readonly get => _y;
        set => _y = value;
    }

    private double _z;
    public double Z
    {
        readonly get => _z;
        set => _z = value;
    }

    public readonly double Distance => Math.Sqrt(X * X + Y * Y + Z * Z);

    public readonly override string ToString() => $"{X}, {Y}, {Z}";
}
```

<span data-ttu-id="99bce-157">Önceki örnek, `readonly` değiştiriciyi uygulayabileceğiniz birçok konumu gösterir: yöntemler, özellikler ve özellik erişimcileri.</span><span class="sxs-lookup"><span data-stu-id="99bce-157">The preceding sample shows many of the locations where you can apply the `readonly` modifier: methods, properties, and property accessors.</span></span> <span data-ttu-id="99bce-158">Otomatik olarak uygulanan özellikleri kullanıyorsanız, derleyici `readonly` okuma yazma `get` özellikleri için değiştiriciyi erişime ekler.</span><span class="sxs-lookup"><span data-stu-id="99bce-158">If you use auto-implemented properties, the compiler adds the `readonly` modifier to the `get` accessor for read-write properties.</span></span> <span data-ttu-id="99bce-159">Derleyici, yalnızca `readonly` `get` bir erişime sahip özellikler için otomatik olarak uygulanan özellik bildirimlerine değiştirici ekler.</span><span class="sxs-lookup"><span data-stu-id="99bce-159">The compiler adds the `readonly` modifier to the auto-implemented property declarations for properties with only a `get` accessor.</span></span>

<span data-ttu-id="99bce-160">`readonly` Durumu mutasyona uğratmaz üyelere değiştirici nin eklenmesi, ilgili iki avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-160">Adding the `readonly` modifier to members that don't mutate state provides two related benefits.</span></span> <span data-ttu-id="99bce-161">İlk olarak, derleyici niyetinizi zorlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-161">First, the compiler enforces your intent.</span></span> <span data-ttu-id="99bce-162">Bu üye yapının durumunu mutasyona uğratamaz ve aynı zamanda işaretlenmemiş `readonly`bir üyeye erişemez.</span><span class="sxs-lookup"><span data-stu-id="99bce-162">That member can't mutate the struct's state, nor can it access a member that isn't also marked `readonly`.</span></span> <span data-ttu-id="99bce-163">İkinci olarak, derleyici bir `in` `readonly` üyeye erişirken parametrelerin savunma kopyalarını oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="99bce-163">Second, the compiler won't create defensive copies of `in` parameters when accessing a `readonly` member.</span></span> <span data-ttu-id="99bce-164">Derleyici, bir üye tarafından değiştirilmediğini garanti `struct` ettiği için bu `readonly` optimizasyonu güvenli bir şekilde yapabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-164">The compiler can make this optimization safely because it guarantees that the `struct` is not modified by a `readonly` member.</span></span>

## <a name="use-ref-readonly-return-statements-for-large-structures-when-possible"></a><span data-ttu-id="99bce-165">Mümkün `ref readonly return` olduğunda büyük yapılar için ifadeleri kullanma</span><span class="sxs-lookup"><span data-stu-id="99bce-165">Use `ref readonly return` statements for large structures when possible</span></span>

<span data-ttu-id="99bce-166">Döndürülen değer dönen yönteme yerel olmadığında değerleri referans olarak döndürebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-166">You can return values by reference when the value being returned isn't local to the returning method.</span></span> <span data-ttu-id="99bce-167">Başvuruyla döndürülme, yapının değil, yalnızca başvurunun kopyalanması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="99bce-167">Returning by reference means that only the reference is copied, not the structure.</span></span> <span data-ttu-id="99bce-168">Aşağıdaki örnekte, `Origin` döndürülen değer yerel `ref` bir değişken olduğundan özellik geri dönüş kullanamaz:</span><span class="sxs-lookup"><span data-stu-id="99bce-168">In the following example, the `Origin` property can't use a `ref` return because the value being returned is a local variable:</span></span>

```csharp
public Point3D Origin => new Point3D(0,0,0);
```

<span data-ttu-id="99bce-169">Ancak, döndürülen değer statik bir üye olduğundan, aşağıdaki özellik tanımı başvuru yla döndürülebilir:</span><span class="sxs-lookup"><span data-stu-id="99bce-169">However, the following property definition can be returned by reference because the returned value is a static member:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    // Dangerous! returning a mutable reference to internal storage
    public ref Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="99bce-170">Arayanların kaynağı değiştirmesini istemiyorsanız, değeri aşağıdakilere göre `ref readonly`döndürmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="99bce-170">You don't want callers modifying the origin, so you should return the value by `ref readonly`:</span></span>

```csharp
public struct Point3D
{
    private static Point3D origin = new Point3D(0,0,0);

    public static ref readonly Point3D Origin => ref origin;

    // other members removed for space
}
```

<span data-ttu-id="99bce-171">İade, `ref readonly` daha büyük yapıların kopyalanmasını kaydetmenize ve dahili veri üyelerinizin değişmezliğini korumanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-171">Returning `ref readonly` enables you to save copying larger structures and preserve the immutability of your internal data members.</span></span>

<span data-ttu-id="99bce-172">Arama sitesinde, arayanlar `Origin` özelliği bir `ref readonly` değer olarak veya bir değer olarak kullanmayı tercih eder:</span><span class="sxs-lookup"><span data-stu-id="99bce-172">At the call site, callers make the choice to use the `Origin` property as a `ref readonly` or as a value:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="99bce-173">Önceki koddaki ilk atama, sabitin `Origin` bir kopyasını yapar ve bu kopyayı atar.</span><span class="sxs-lookup"><span data-stu-id="99bce-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="99bce-174">İkinci bir referans atar.</span><span class="sxs-lookup"><span data-stu-id="99bce-174">The second assigns a reference.</span></span> <span data-ttu-id="99bce-175">Değiştiricinin `readonly` değişkenin bildiriminin bir parçası olması gerektiğine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="99bce-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="99bce-176">Başvuruda bulunduğu başvuru değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="99bce-176">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="99bce-177">Bunu yapmaya çalışır derleme zamanı hatasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-177">Attempts to do so result in a compile-time error.</span></span>

<span data-ttu-id="99bce-178">Değiştirici `readonly` nin beyanı üzerine `originReference`gereklidir.</span><span class="sxs-lookup"><span data-stu-id="99bce-178">The `readonly` modifier is required on the declaration of `originReference`.</span></span>

<span data-ttu-id="99bce-179">Derleyici, arayanın başvuruyu değiştiremeyebileceğini zorlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-179">The compiler enforces that the caller can't modify the reference.</span></span> <span data-ttu-id="99bce-180">Değeri doğrudan derleme zamanı hatası oluşturmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="99bce-180">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="99bce-181">Ancak derleyici, herhangi bir üye yönteminin yapının durumunu modicimi olduğunu bilemiyor.</span><span class="sxs-lookup"><span data-stu-id="99bce-181">However, the compiler can't know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="99bce-182">Nesnenin değiştirilmediğinden emin olmak için derleyici bir kopya oluşturur ve bu kopyayı kullanarak üye başvurularını arar.</span><span class="sxs-lookup"><span data-stu-id="99bce-182">To ensure that the object isn't modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="99bce-183">Herhangi bir değişiklik bu savunma kopya vardır.</span><span class="sxs-lookup"><span data-stu-id="99bce-183">Any modifications are to that defensive copy.</span></span>

## <a name="apply-the-in-modifier-to-readonly-struct-parameters-larger-than-systemintptrsize"></a><span data-ttu-id="99bce-184">`in` Değiştiriciyi daha `readonly struct` büyük parametrelere uygulayın`System.IntPtr.Size`</span><span class="sxs-lookup"><span data-stu-id="99bce-184">Apply the `in` modifier to `readonly struct` parameters larger than `System.IntPtr.Size`</span></span>

<span data-ttu-id="99bce-185">`in` Anahtar kelime, varolan `ref` `out` ve anahtar kelimeleri referansa göre bağımsız değişkenler geçirmek için tamamlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-185">The `in` keyword complements the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="99bce-186">`in` Anahtar kelime, bağımsız değişkeni başvuruyla geçeni belirtir, ancak çağrılan yöntem değeri değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="99bce-186">The `in` keyword specifies passing the argument by reference, but the called method doesn't modify the value.</span></span>

<span data-ttu-id="99bce-187">Bu ek, tasarım amacınızı ifade etmek için tam bir kelime dağarcığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-187">This addition provides a full vocabulary to express your design intent.</span></span>
<span data-ttu-id="99bce-188">Yöntem imzasında aşağıdaki değiştiricilerden hiçbirini belirtmediğinizde, değer türleri çağrılan yönteme geçildiğinde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-188">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="99bce-189">Bu değiştiricilerin her biri, kopyadan kaçınarak bir değişkenin başvuru yla geçirildiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="99bce-189">Each of these modifiers specifies that a variable is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="99bce-190">Her değiştirici farklı bir amacı ifade eder:</span><span class="sxs-lookup"><span data-stu-id="99bce-190">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="99bce-191">`out`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-191">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="99bce-192">`ref`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-192">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="99bce-193">`in`: Bu yöntem, bu parametre olarak kullanılan bağımsız değişkenin değerini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="99bce-193">`in`: This method doesn't modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="99bce-194">Bir `in` bağımsız değişkeni başvuruyla geçirmek için değiştiriciekleyin ve gereksiz kopyalamayı önlemek için tasarım amacınızı bağımsız değişkenleri referans olarak geçirmek üzere bildirin.</span><span class="sxs-lookup"><span data-stu-id="99bce-194">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="99bce-195">Bu bağımsız değişken olarak kullanılan nesneyi değiştirmek niyetinde değilsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-195">You don't intend to modify the object used as that argument.</span></span>

<span data-ttu-id="99bce-196">Bu uygulama genellikle <xref:System.IntPtr.Size?displayProperty=nameWithType>yalnızca daha büyük olan salt değer türleri için performansı artırır.</span><span class="sxs-lookup"><span data-stu-id="99bce-196">This practice often improves performance for readonly value types that are larger than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span> <span data-ttu-id="99bce-197">Basit türleri`sbyte`için `byte` `short`(, `int` `uint`, `long` `ushort` `ulong`, `char` `float`, `double` `decimal` , `bool`, `enum` , , , ve türleri), herhangi bir potansiyel performans kazançları en azdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-197">For simple types (`sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `char`, `float`, `double`, `decimal` and `bool`, and `enum` types), any potential performance gains are minimal.</span></span> <span data-ttu-id="99bce-198">Aslında, performans <xref:System.IntPtr.Size?displayProperty=nameWithType>daha küçük türleri için pass-by-reference kullanarak bozulabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-198">In fact, performance may degrade by using pass-by-reference for types smaller than <xref:System.IntPtr.Size?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="99bce-199">Aşağıdaki kod, 3B alanda iki nokta arasındaki mesafeyi hesaplayan bir yöntem örneği gösterir.</span><span class="sxs-lookup"><span data-stu-id="99bce-199">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="99bce-200">Bağımsız değişkenler, her biri üç çift içeren iki yapıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-200">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="99bce-201">Bir çift 8 bayt, bu yüzden her argüman 24 bayt olduğunu.</span><span class="sxs-lookup"><span data-stu-id="99bce-201">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="99bce-202">`in` Değiştirici belirterek, makinenin mimarisine bağlı olarak bu bağımsız değişkenlere 4 bayt veya 8 baytlık bir başvuru geçersiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-202">By specifying the `in` modifier, you pass a 4 byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="99bce-203">Boyut farkı küçüktür, ancak uygulamanız bu yöntemi birçok farklı değer kullanarak sıkı bir döngü içinde aradığında birikir.</span><span class="sxs-lookup"><span data-stu-id="99bce-203">The difference in size is small, but it adds up when your application calls this method in a tight loop using many different values.</span></span>

<span data-ttu-id="99bce-204">`in` Değiştirici tamamlar `out` ve `ref` diğer şekillerde de.</span><span class="sxs-lookup"><span data-stu-id="99bce-204">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="99bce-205">Yalnızca `in`, `out`veya `ref`.</span><span class="sxs-lookup"><span data-stu-id="99bce-205">You can't create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="99bce-206">Bu yeni kurallar, her zaman tanımlanmış `out` olan `ref` davranışı ve parametreleri genişletir.</span><span class="sxs-lookup"><span data-stu-id="99bce-206">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span> <span data-ttu-id="99bce-207">`out` Değiştiriciler `ref` ve değiştiriciler gibi, `in` değiştirici uygulandığından değer türleri kutulu değil.</span><span class="sxs-lookup"><span data-stu-id="99bce-207">Like the `out` and `ref` modifiers, value types aren't boxed because the `in` modifier is applied.</span></span>

<span data-ttu-id="99bce-208">Değiştirici `in` parametreleri alan herhangi bir üyeye uygulanabilir: yöntemler, temsilciler, lambdas, yerel fonksiyonlar, dizinleyiciler, işleçler.</span><span class="sxs-lookup"><span data-stu-id="99bce-208">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="99bce-209">Parametrelerin `in` bir diğer özelliği de, bağımsız değişken için bir `in` parametre için gerçek değerleri veya sabitleri kullanabilmektir.</span><span class="sxs-lookup"><span data-stu-id="99bce-209">Another feature of `in` parameters is that you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="99bce-210">Ayrıca, bir `ref` `out` veya parametrenin aksine, `in` değiştiriciyi çağrı yerinde uygulamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="99bce-210">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="99bce-211">Aşağıdaki kod, `CalculateDistance` yöntemi arama iki örnek gösterir.</span><span class="sxs-lookup"><span data-stu-id="99bce-211">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="99bce-212">İlk başvuru ile geçirilen iki yerel değişken kullanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-212">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="99bce-213">İkinci yöntem çağrısının bir parçası olarak oluşturulan geçici bir değişken içerir.</span><span class="sxs-lookup"><span data-stu-id="99bce-213">The second includes a temporary variable created as part of the method call.</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="99bce-214">Derleyicinin bir `in` bağımsız değişkenin salt okunur doğasını zorladığı çeşitli yollar vardır.</span><span class="sxs-lookup"><span data-stu-id="99bce-214">There are several ways in which the compiler enforces the read-only nature of an `in` argument.</span></span>  <span data-ttu-id="99bce-215">Her şeyden önce, çağrılan yöntem doğrudan bir `in` parametre atamaz.</span><span class="sxs-lookup"><span data-stu-id="99bce-215">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="99bce-216">Bu değer bir `in` `struct` tür olduğunda doğrudan bir parametrenin herhangi bir alanına atamaz.</span><span class="sxs-lookup"><span data-stu-id="99bce-216">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="99bce-217">Buna ek olarak, bir `in` parametreyi `ref` veya `out` değiştiriyi kullanarak herhangi bir yönteme geçiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-217">In addition, you can't pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="99bce-218">Bu kurallar, alan bir `in` `struct` tür ve parametre de bir tür olması `struct` koşuluyla, bir parametrenin herhangi bir alan için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="99bce-218">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="99bce-219">Aslında, bu kurallar üye erişim in her düzeyde türleri sağlanan üye `structs`erişim birden çok katman için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="99bce-219">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span>
<span data-ttu-id="99bce-220">Derleyici, bağımsız `struct` değişken olarak `in` geçirilen `struct` türleri zorlar ve diğer yöntemlere bağımsız değişken olarak kullanıldığında üyeleri salt okunur değişkenlerdir.</span><span class="sxs-lookup"><span data-stu-id="99bce-220">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="99bce-221">Parametrelerin `in` kullanımı kopya yapma olası performans maliyetlerini önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-221">The use of `in` parameters can avoid the potential performance costs of making copies.</span></span> <span data-ttu-id="99bce-222">Herhangi bir yöntem çağrısının anlambilimini değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="99bce-222">It doesn't change the semantics of any method call.</span></span> <span data-ttu-id="99bce-223">Bu nedenle, arama yerinde `in` değiştirici belirtmeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="99bce-223">Therefore, you don't need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="99bce-224">Çağrı yerindeki `in` değiştiricinin atlanması derleyiciye, aşağıdaki nedenlerle bağımsız değişkenin bir kopyasını yapmasına izin verildiğini bildirir:</span><span class="sxs-lookup"><span data-stu-id="99bce-224">Omitting the `in` modifier at the call site informs the compiler that it's allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="99bce-225">Bağımsız değişken türünden parametre türüne bir kimlik dönüştürmesi yok.</span><span class="sxs-lookup"><span data-stu-id="99bce-225">There exists an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="99bce-226">Bağımsız değişken bir ifadedir, ancak bilinen bir depolama değişkeni yoktur.</span><span class="sxs-lookup"><span data-stu-id="99bce-226">The argument is an expression but doesn't have a known storage variable.</span></span>
- <span data-ttu-id="99bce-227">Varlığına veya yokluğuna göre farklılık gösteren `in`aşırı yük vardır.</span><span class="sxs-lookup"><span data-stu-id="99bce-227">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="99bce-228">Bu durumda, değer aşırı daha iyi bir maç.</span><span class="sxs-lookup"><span data-stu-id="99bce-228">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="99bce-229">Bu kurallar, salt okunur başvuru bağımsız değişkenlerini kullanmak üzere varolan kodu güncelleştirirken yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-229">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="99bce-230">Çağrılan yöntemin içinde, değer parametrelerine göre kullanan herhangi bir örnek yöntemi çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-230">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="99bce-231">Bu gibi durumlarda, parametrenin `in` bir kopyası oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="99bce-231">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="99bce-232">Derleyici herhangi `in` bir parametre için geçici bir değişken oluşturabileceğinden, `in` herhangi bir parametre için varsayılan değerleri de belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-232">Because the compiler may create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="99bce-233">Aşağıdaki kod, ikinci noktanın varsayılan değeri olarak kaynağı (0,0 noktası) belirtir:</span><span class="sxs-lookup"><span data-stu-id="99bce-233">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="99bce-234">Derleyiciyi başvuru yla salt okunur bağımsız değişkenleri `in` geçirmeye zorlamak için, aşağıdaki kodda gösterildiği gibi çağrı yerindeki bağımsız değişkenlerde değiştirici belirtin:</span><span class="sxs-lookup"><span data-stu-id="99bce-234">To force the compiler to pass read-only arguments by reference, specify the `in` modifier on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="99bce-235">Bu davranış, performans kazançlarının mümkün olduğu büyük kod tabanlarında parametrelerin zaman içinde benimsenmesi `in` kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="99bce-235">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="99bce-236">Önce yöntem `in` imzalarına değiştirici ekleyin.</span><span class="sxs-lookup"><span data-stu-id="99bce-236">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="99bce-237">Daha sonra, çağrı `in` sitelerinde değiştirici ekleyebilir `readonly struct` ve derleyicinin daha fazla konumda `in` parametrelerin savunma kopyalarını oluşturmamasını sağlamak için türler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-237">Then, you can add the `in` modifier at call sites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="99bce-238">`in` Parametre ataması, başvuru türleri veya sayısal değerlerle de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-238">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="99bce-239">Ancak, her iki durumda da yararları, varsa, en azdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-239">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="avoid-mutable-structs-as-an-in-argument"></a><span data-ttu-id="99bce-240">`in` Bağımsız değişken olarak değişken structs kaçının</span><span class="sxs-lookup"><span data-stu-id="99bce-240">Avoid mutable structs as an `in` argument</span></span>

<span data-ttu-id="99bce-241">Yukarıda açıklanan teknikler, referansları döndürerek ve değerleri referansla geçirerek kopyalardan nasıl kaçınılanın açıklar.</span><span class="sxs-lookup"><span data-stu-id="99bce-241">The techniques described above explain how to avoid copies by returning references and passing values by reference.</span></span> <span data-ttu-id="99bce-242">Bu teknikler, bağımsız değişken türleri `readonly struct` tür olarak bildirilirken en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="99bce-242">These techniques work best when the argument types are declared as `readonly struct` types.</span></span> <span data-ttu-id="99bce-243">Aksi takdirde, derleyici, herhangi bir bağımsız değişkenin yalnızca okuma sını uygulamak için birçok durumda **savunma kopyaları** oluşturmalıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-243">Otherwise, the compiler must create **defensive copies** in many situations to enforce the readonly-ness of any arguments.</span></span> <span data-ttu-id="99bce-244">Bir 3B noktanın kaynaktan uzaklığı hesaplayan aşağıdaki örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="99bce-244">Consider the following example that calculates the distance of a 3D point from the origin:</span></span>

[!code-csharp[InArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#InArgument "Specifying an in argument")]

<span data-ttu-id="99bce-245">Yapı `Point3D` sadece okunan bir yapı *değildir.*</span><span class="sxs-lookup"><span data-stu-id="99bce-245">The `Point3D` structure is *not* a readonly struct.</span></span> <span data-ttu-id="99bce-246">Bu yöntemin gövdesinde altı farklı özellik erişim çağrıları vardır.</span><span class="sxs-lookup"><span data-stu-id="99bce-246">There are six different property access calls in the body of this method.</span></span> <span data-ttu-id="99bce-247">İlk muayenede, bu erişimlerin güvenli olduğunu düşünmüş olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-247">On first examination, you may have thought these accesses were safe.</span></span> <span data-ttu-id="99bce-248">Sonuçta, bir `get` erişimci nesnenin durumunu değiştirmemelidir.</span><span class="sxs-lookup"><span data-stu-id="99bce-248">After all, a `get` accessor shouldn't modify the state of the object.</span></span> <span data-ttu-id="99bce-249">Ama bunu zorunlu kılacak bir dil kuralı yok.</span><span class="sxs-lookup"><span data-stu-id="99bce-249">But there's no language rule that enforces that.</span></span> <span data-ttu-id="99bce-250">Bu sadece sıradan bir toplantı.</span><span class="sxs-lookup"><span data-stu-id="99bce-250">It's only a common convention.</span></span> <span data-ttu-id="99bce-251">Herhangi bir tür `get` iç durumu değiştiren bir erişimci uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-251">Any type could implement a `get` accessor that modified the internal state.</span></span> <span data-ttu-id="99bce-252">Bazı dil garantisi olmadan, derleyici `readonly` değiştirici ile işaretlenmemiş herhangi bir üye çağırmadan önce bağımsız değişkenin geçici bir kopyasını oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="99bce-252">Without some language guarantee, the compiler must create a temporary copy of the argument before calling any member not marked with the `readonly` modifier.</span></span> <span data-ttu-id="99bce-253">Yığında geçici depolama oluşturulur, bağımsız değişkenin değerleri geçici depolama alanına kopyalanır ve değer `this` bağımsız değişken olarak her üye erişim için yığına kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-253">The temporary storage is created on the stack, the values of the argument are copied to the temporary storage, and the value is copied to the stack for each member access as the `this` argument.</span></span> <span data-ttu-id="99bce-254">Çoğu durumda, bu kopyalar, bağımsız değişken türü bir `readonly struct` olmadığında ve yöntem işaretlenmemiş `readonly`üyeleri aradığında, geçiş değeri nin yalnızca okunan başvurudan daha hızlı olduğu performansa yeterince zarar verir.</span><span class="sxs-lookup"><span data-stu-id="99bce-254">In many situations, these copies harm performance enough that pass-by-value is faster than pass-by-readonly-reference when the argument type isn't a `readonly struct` and the method calls members that aren't marked `readonly`.</span></span> <span data-ttu-id="99bce-255">Yapı durumunu değiştirmeyen tüm yöntemleri `readonly`işaretlerseniz, derleyici yapı durumunun değiştirilmediğini ve savunma kopyasının gerekli olmadığını güvenli bir şekilde belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-255">If you mark all methods that don't modify the struct state as `readonly`, the compiler can safely determine that the struct state isn't modified, and a defensive copy is not needed.</span></span>

<span data-ttu-id="99bce-256">Bunun yerine, mesafe hesaplaması değişmez yapıyı `ReadonlyPoint3D`kullanıyorsa, geçici nesnelergerekmez:</span><span class="sxs-lookup"><span data-stu-id="99bce-256">Instead, if the distance calculation uses the immutable struct, `ReadonlyPoint3D`, temporary objects aren't needed:</span></span>

[!code-csharp[readonlyInArgument](../../samples/snippets/csharp/safe-efficient-code/ref-readonly-struct/Program.cs#ReadOnlyInArgument "Specifying a readonly in argument")]

<span data-ttu-id="99bce-257">Derleyici, üye `readonly struct`yi çağırdığınızda daha verimli `this` kod oluşturur : Başvuru, alıcının bir `in` kopyası yerine, her zaman üye yöntemine atıfta bulunularak geçirilen bir parametredir.</span><span class="sxs-lookup"><span data-stu-id="99bce-257">The compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="99bce-258">Bu optimizasyon, bir `readonly struct` `in` bağımsız değişken olarak kullandığınızda kopyalama kaydeder.</span><span class="sxs-lookup"><span data-stu-id="99bce-258">This optimization saves copying when you use a `readonly struct` as an `in` argument.</span></span>

<span data-ttu-id="99bce-259">`in` Bağımsız değişken olarak geçersiz bir değer türünü geçmemelisin.</span><span class="sxs-lookup"><span data-stu-id="99bce-259">You shouldn't pass a nullable value type as an `in` argument.</span></span> <span data-ttu-id="99bce-260">Tür, <xref:System.Nullable%601> salt okunur yapı olarak bildirilmemiştir.</span><span class="sxs-lookup"><span data-stu-id="99bce-260">The <xref:System.Nullable%601> type isn't declared as a read-only struct.</span></span> <span data-ttu-id="99bce-261">Bu, derleyicinin parametre bildirimindeki `in` değiştiriciyi kullanarak bir yönteme geçirilen herhangi bir geçersiz değer türü bağımsız değişkeni için savunma kopyaları oluşturması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="99bce-261">That means the compiler must generate defensive copies for any nullable value type argument passed to a method using the `in` modifier on the parameter declaration.</span></span>

<span data-ttu-id="99bce-262">GitHub'daki [örnek depomuzda](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) [BenchmarkDotNet'i](https://www.nuget.org/packages/BenchmarkDotNet/) kullanarak performans farklarını gösteren bir örnek program görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-262">You can see an example program that demonstrates the performance differences using [BenchmarkDotNet](https://www.nuget.org/packages/BenchmarkDotNet/) in our [samples repository](https://github.com/dotnet/samples/tree/master/csharp/safe-efficient-code/benchmark) on GitHub.</span></span> <span data-ttu-id="99bce-263">Değişmez bir yapıyı değere ve referansa göre ve değere göre sabit bir yapıyla karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="99bce-263">It compares passing a mutable struct by value and by reference with passing an immutable struct by value and by reference.</span></span> <span data-ttu-id="99bce-264">Değişmez yapının kullanımı ve referans la geçiş en hızlısi.</span><span class="sxs-lookup"><span data-stu-id="99bce-264">The use of the immutable struct and pass by reference is fastest.</span></span>

## <a name="use-ref-struct-types-to-work-with-blocks-or-memory-on-a-single-stack-frame"></a><span data-ttu-id="99bce-265">Tek `ref struct` bir yığın çerçeveüzerinde bloklarla veya bellekle çalışmak için türleri kullanma</span><span class="sxs-lookup"><span data-stu-id="99bce-265">Use `ref struct` types to work with blocks or memory on a single stack frame</span></span>

<span data-ttu-id="99bce-266">İlişkili dil özelliği, tek bir yığın çerçevesiyle sınırlandırılması gereken bir değer türünü bildirme yeteneğidir.</span><span class="sxs-lookup"><span data-stu-id="99bce-266">A related language feature is the ability to declare a value type that must be constrained to a single stack frame.</span></span> <span data-ttu-id="99bce-267">Bu kısıtlama derleyicinin birkaç optimizasyon yapmalarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="99bce-267">This restriction enables the compiler to make several optimizations.</span></span> <span data-ttu-id="99bce-268">Bu özelliğin temel <xref:System.Span%601> motivasyonu ve ilgili yapılardır.</span><span class="sxs-lookup"><span data-stu-id="99bce-268">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="99bce-269">Bu <xref:System.Span%601> geliştirmelerden, türünden yararlanan yeni ve güncelleştirilmiş .NET API'lerini kullanarak performans iyileştirmeleri elde eedeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-269">You'll achieve performance improvements from these enhancements by using new and updated .NET APIs that make use of the <xref:System.Span%601> type.</span></span>

<span data-ttu-id="99bce-270">Interop API'lerinden bellek [`stackalloc`](language-reference/operators/stackalloc.md) kullanırken veya kullanırken oluşturulan bellekle çalışan benzer gereksinimlere sahip olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-270">You may have similar requirements working with memory created using [`stackalloc`](language-reference/operators/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="99bce-271">Bu ihtiyaçlar `ref struct` için kendi türlerinizi tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-271">You can define your own `ref struct` types for those needs.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="99bce-272">`readonly ref struct`Türü</span><span class="sxs-lookup"><span data-stu-id="99bce-272">`readonly ref struct` type</span></span>

<span data-ttu-id="99bce-273">Bir yapıyı bir `readonly ref` yapı olarak bildirmek, `ref struct` beyannamelerin yararlarını ve `readonly struct` kısıtlamalarını birleştirir.</span><span class="sxs-lookup"><span data-stu-id="99bce-273">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` declarations.</span></span> <span data-ttu-id="99bce-274">Yalnızca okuma açıklığı tarafından kullanılan bellek tek bir yığın çerçevesiyle sınırlıdır ve yalnızca okunan yayılma alanı tarafından kullanılan bellek değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="99bce-274">The memory used by the readonly span is restricted to a single stack frame, and the memory used by the readonly span can't be modified.</span></span>

## <a name="conclusions"></a><span data-ttu-id="99bce-275">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="99bce-275">Conclusions</span></span>

<span data-ttu-id="99bce-276">Değer türlerinin kullanılması ayırma işlemleri sayısını en aza indirir:</span><span class="sxs-lookup"><span data-stu-id="99bce-276">Using value types minimizes the number of allocation operations:</span></span>

- <span data-ttu-id="99bce-277">Değer türleri için depolama yerel değişkenler ve yöntem bağımsız değişkenleri için ayrılmış yığın.</span><span class="sxs-lookup"><span data-stu-id="99bce-277">Storage for value types is stack allocated for local variables and method arguments.</span></span>
- <span data-ttu-id="99bce-278">Diğer nesnelerin üyesi olan değer türleri için depolama ayrı bir ayırma olarak değil, bu nesnenin bir parçası olarak ayrılır.</span><span class="sxs-lookup"><span data-stu-id="99bce-278">Storage for value types that are members of other objects is allocated as part of that object, not as a separate allocation.</span></span>
- <span data-ttu-id="99bce-279">Değer türü iade değerleri için depolama yığın ayrılır.</span><span class="sxs-lookup"><span data-stu-id="99bce-279">Storage for value type return values is stack allocated.</span></span>

<span data-ttu-id="99bce-280">Bu aynı durumlarda başvuru türleri ile kontrast:</span><span class="sxs-lookup"><span data-stu-id="99bce-280">Contrast that with reference types in those same situations:</span></span>

- <span data-ttu-id="99bce-281">Başvuru türleri için depolama, yerel değişkenler ve yöntem bağımsız değişkenleri için ayrılan yığındır.</span><span class="sxs-lookup"><span data-stu-id="99bce-281">Storage for reference types are heap allocated for local variables and method arguments.</span></span> <span data-ttu-id="99bce-282">Başvuru yığınında depolanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-282">The reference is stored on the stack.</span></span>
- <span data-ttu-id="99bce-283">Diğer nesnelerin üyesi olan başvuru türleri için depolama ayrı ayrı yığın aayrılır.</span><span class="sxs-lookup"><span data-stu-id="99bce-283">Storage for reference types that are members of other objects are separately allocated on the heap.</span></span> <span data-ttu-id="99bce-284">İçeren nesne başvuruyu depolar.</span><span class="sxs-lookup"><span data-stu-id="99bce-284">The containing object stores the reference.</span></span>
- <span data-ttu-id="99bce-285">Referans türü iade değerleri için depolama yığın ayrılır.</span><span class="sxs-lookup"><span data-stu-id="99bce-285">Storage for reference type return values is heap allocated.</span></span> <span data-ttu-id="99bce-286">Bu depolama başvurusu yığında depolanır.</span><span class="sxs-lookup"><span data-stu-id="99bce-286">The reference to that storage is stored on the stack.</span></span>

<span data-ttu-id="99bce-287">Tahsisatları en aza indirmek, dengelemelerle birlikte gelir.</span><span class="sxs-lookup"><span data-stu-id="99bce-287">Minimizing allocations comes with tradeoffs.</span></span> <span data-ttu-id="99bce-288">Boyutu başvurunun boyutundan daha `struct` büyük olduğunda daha fazla bellek kopyalarsınız.</span><span class="sxs-lookup"><span data-stu-id="99bce-288">You copy more memory when the size of the `struct` is larger than the size of a reference.</span></span> <span data-ttu-id="99bce-289">Bir başvuru genellikle 64 bit veya 32 bittir ve hedef makine CPU'ya bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="99bce-289">A reference is typically 64 bits or 32 bits, and depends on the target machine CPU.</span></span>

<span data-ttu-id="99bce-290">Bu tradeoffs genellikle en az performans etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="99bce-290">These tradeoffs generally have minimal performance impact.</span></span> <span data-ttu-id="99bce-291">Ancak, büyük strüktlar veya daha büyük koleksiyonlar için performans etkisi artar.</span><span class="sxs-lookup"><span data-stu-id="99bce-291">However, for large structs or larger collections, the performance impact increases.</span></span> <span data-ttu-id="99bce-292">Etkisi sıkı döngüler ve programlar için sıcak yollar büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="99bce-292">The impact can be large in tight loops and hot paths for programs.</span></span>

<span data-ttu-id="99bce-293">C# dilindeki bu geliştirmeler, bellek ayırmalarını en aza indirmenin gerekli performansı elde etmede önemli bir faktör olduğu performans açısından kritik algoritmalar için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="99bce-293">These enhancements to the C# language are designed for performance critical algorithms where minimizing memory allocations is a major factor in achieving the necessary performance.</span></span> <span data-ttu-id="99bce-294">Yazdığınız kodda bu özellikleri sık sık kullanmadığınızı görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="99bce-294">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="99bce-295">Ancak, bu geliştirmeler .NET boyunca benimsenmiştir.</span><span class="sxs-lookup"><span data-stu-id="99bce-295">However, these enhancements have been adopted throughout .NET.</span></span> <span data-ttu-id="99bce-296">Giderek daha fazla API bu özellikleri kullandıkça, uygulamalarınızın performansının iyileştiğini görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="99bce-296">As more and more APIs make use of these features, you'll see the performance of your applications improve.</span></span>

## <a name="see-also"></a><span data-ttu-id="99bce-297">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="99bce-297">See also</span></span>

- [<span data-ttu-id="99bce-298">ref anahtar kelime</span><span class="sxs-lookup"><span data-stu-id="99bce-298">ref keyword</span></span>](language-reference/keywords/ref.md)
- [<span data-ttu-id="99bce-299">Ref dönüşler ve ref yerel ayarlar</span><span class="sxs-lookup"><span data-stu-id="99bce-299">Ref returns and ref locals</span></span>](programming-guide/classes-and-structs/ref-returns.md)
