---
title: Uzantı yöntemleri-C# Programlama Kılavuzu
description: C# ' deki genişletme yöntemleri, yeni türetilmiş bir tür oluşturmadan, yeniden derlemeden ya da özgün türü değiştirmeden mevcut türlere Yöntemler eklemenizi sağlar.
ms.date: 03/19/2020
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
ms.openlocfilehash: 116087ac1aab57f2869b05f436801c7861c56eca
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063711"
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="4e3e6-103">Uzantı Metotları (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="4e3e6-103">Extension Methods (C# Programming Guide)</span></span>

<span data-ttu-id="4e3e6-104">Uzantı yöntemleri, yeni türetilmiş bir tür oluşturmadan, yeniden derlemeden ya da özgün türü değiştirmeden yöntemler "eklemenizi" sağlar.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-104">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="4e3e6-105">Uzantı yöntemleri statik yöntemlerdir, ancak genişletilmiş türdeki örnek yöntemler gibi olarak adlandırılırlar.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-105">Extension methods are static methods, but they're called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="4e3e6-106">C#, F # ve Visual Basic yazılmış istemci kodu için, genişletme yöntemi ve bir tür içinde tanımlanan yöntemleri çağırma arasında görünür bir fark yoktur.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-106">For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.</span></span>

<span data-ttu-id="4e3e6-107">En yaygın genişletme yöntemleri, var olan ve türlerine sorgu işlevselliği ekleyen LINQ standart sorgu işleçleridir <xref:System.Collections.IEnumerable?displayProperty=nameWithType> <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-107">The most common extension methods are the LINQ standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="4e3e6-108">Standart sorgu işleçlerini kullanmak için, önce bunları bir `using System.Linq` yönergeyle kapsama taşıyın.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-108">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="4e3e6-109">Ardından, uygulayan herhangi bir tür,,, vb <xref:System.Collections.Generic.IEnumerable%601> . gibi örnek yöntemlere sahip olacak şekilde görünür <xref:System.Linq.Enumerable.GroupBy%2A> <xref:System.Linq.Enumerable.OrderBy%2A> <xref:System.Linq.Enumerable.Average%2A> .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-109">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="4e3e6-110">Ya da gibi bir türün örneğinden sonra "nokta" yazdığınızda, bu ek yöntemleri IntelliSense deyimin tamamlanmasına bakabilirsiniz <xref:System.Collections.Generic.IEnumerable%601> <xref:System.Collections.Generic.List%601> <xref:System.Array> .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-110">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>

### <a name="orderby-example"></a><span data-ttu-id="4e3e6-111">OrderBy örneği</span><span class="sxs-lookup"><span data-stu-id="4e3e6-111">OrderBy Example</span></span>

<span data-ttu-id="4e3e6-112">Aşağıdaki örnek, bir tamsayı dizisinde standart sorgu işleci yönteminin nasıl çağrılacağını gösterir `OrderBy` .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-112">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="4e3e6-113">Parantez içindeki ifade bir lambda ifadesidir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-113">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="4e3e6-114">Birçok standart sorgu işleci Lambda ifadelerini parametre olarak alır, ancak bu uzantı yöntemleri için bir gereklilik değildir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-114">Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods.</span></span> <span data-ttu-id="4e3e6-115">Daha fazla bilgi için bkz. [lambda ifadeleri](../../language-reference/operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="4e3e6-115">For more information, see [Lambda Expressions](../../language-reference/operators/lambda-expressions.md).</span></span>

[!code-csharp[csProgGuideExtensionMethods#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#3)]

<span data-ttu-id="4e3e6-116">Uzantı yöntemleri statik yöntemler olarak adlandırılır ancak örnek yöntemi söz dizimi kullanılarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-116">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="4e3e6-117">İlk parametresi, yöntemin hangi tür üzerinde çalıştığını belirtir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-117">Their first parameter specifies which type the method operates on.</span></span> <span data-ttu-id="4e3e6-118">Parametresi öncesinde [Bu](../../language-reference/keywords/this.md) değiştirici gelir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-118">The parameter is preceded by the [this](../../language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="4e3e6-119">Uzantı yöntemleri yalnızca bir yönergeyle ad alanını kaynak kodunuza açıkça aktardığınızda kapsam içinde bulunur `using` .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-119">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>

<span data-ttu-id="4e3e6-120">Aşağıdaki örnek, sınıfı için tanımlanmış bir uzantı yöntemini gösterir <xref:System.String?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-120">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="4e3e6-121">İç içe olmayan, genel olmayan bir statik sınıf içinde tanımlanmıştır:</span><span class="sxs-lookup"><span data-stu-id="4e3e6-121">It's defined inside a non-nested, non-generic static class:</span></span>

[!code-csharp[csProgGuideExtensionMethods#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#4)]

<span data-ttu-id="4e3e6-122">`WordCount`Genişletme yöntemi bu `using` yönergeyle kapsama getirilebilir:</span><span class="sxs-lookup"><span data-stu-id="4e3e6-122">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>

```csharp
using ExtensionMethods;
```

<span data-ttu-id="4e3e6-123">Ve bu sözdizimi kullanılarak bir uygulamadan çağrılabilir:</span><span class="sxs-lookup"><span data-stu-id="4e3e6-123">And it can be called from an application by using this syntax:</span></span>

```csharp
string s = "Hello Extension Methods";
int i = s.WordCount();
```

<span data-ttu-id="4e3e6-124">Kodunuzda, örnek yöntemi sözdizimi ile genişletme yöntemi çağırılır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-124">You invoke the extension method in your code with instance method syntax.</span></span> <span data-ttu-id="4e3e6-125">Derleyici tarafından oluşturulan ara dil (IL), kodunuzu statik yöntemdeki bir çağrıya dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-125">The intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="4e3e6-126">Kapsülleme ilkesi gerçekten ihlal edilmez.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-126">The principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="4e3e6-127">Genişletme yöntemleri genişledikleri türdeki özel değişkenlere erişemez.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-127">Extension methods cannot access private variables in the type they are extending.</span></span>

<span data-ttu-id="4e3e6-128">Daha fazla bilgi için bkz. [özel bir genişletme yöntemi uygulama ve çağırma](./how-to-implement-and-call-a-custom-extension-method.md).</span><span class="sxs-lookup"><span data-stu-id="4e3e6-128">For more information, see [How to implement and call a custom  extension method](./how-to-implement-and-call-a-custom-extension-method.md).</span></span>

<span data-ttu-id="4e3e6-129">Genel olarak, büyük olasılıkla kendi uygulamanızı uygulamaktan çok daha sık genişletme yöntemleri çağrılıyor.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-129">In general, you'll probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="4e3e6-130">Genişletme yöntemleri örnek yöntem sözdizimi tarafından çağrıldığından istemci kodundan kullanmak için herhangi bir özel bilgi gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-130">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="4e3e6-131">Belirli bir tür için uzantı yöntemlerini etkinleştirmek için, `using` yöntemlerin tanımlandığı ad alanı için bir yönerge eklemeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-131">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="4e3e6-132">Örneğin, standart sorgu işleçlerini kullanmak için bu `using` yönergeyi kodunuza ekleyin:</span><span class="sxs-lookup"><span data-stu-id="4e3e6-132">For example, to use the standard query operators, add this `using` directive to your code:</span></span>

```csharp
using System.Linq;
```

<span data-ttu-id="4e3e6-133">(System.Core.dll için de bir başvuru eklemeniz gerekebilir.) Standart sorgu işleçlerinin artık, çoğu tür için kullanılabilen ek yöntemler olarak IntelliSense 'de göründüğünü fark edeceksiniz <xref:System.Collections.Generic.IEnumerable%601> .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-133">(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>

## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="4e3e6-134">Derleme Zamanında Uzantı Yöntemleri Bağlama</span><span class="sxs-lookup"><span data-stu-id="4e3e6-134">Binding Extension Methods at Compile Time</span></span>

<span data-ttu-id="4e3e6-135">Bir sınıfı veya arabirimi genişletmek için genişletme yöntemini kullanabilir, ancak bunları geçersiz kılamazsınız.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-135">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="4e3e6-136">Arabirim veya sınıf yöntemiyle aynı ada ve imzaya sahip genişletme yöntemi asla çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-136">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="4e3e6-137">Derleme sırasında genişletme yöntemleri, her zaman türün kendisinde tanımlı örnek yöntemlerden daha düşük önceliğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-137">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="4e3e6-138">Diğer bir deyişle, bir türün adlı bir yöntemi varsa `Process(int i)` ve aynı imzaya sahip bir uzantı yönteminiz varsa, derleyici her zaman örnek yöntemine bağlanır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-138">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="4e3e6-139">Derleyici bir yöntem çağırmayla karşılaştığında, türün örnek yöntemleri önce bir eşleşme arar.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-139">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="4e3e6-140">Eşleşme bulunmazsa, tür için tanımlanan uzantı yöntemleri aranır ve ilk bulunan uzantı yöntemine bağlanılır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-140">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="4e3e6-141">Aşağıdaki örnek, derleyicinin hangi genişletme yöntemine veya örnek yöntemine bağlanılacağını nasıl belirlediğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-141">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>

## <a name="example"></a><span data-ttu-id="4e3e6-142">Örnek</span><span class="sxs-lookup"><span data-stu-id="4e3e6-142">Example</span></span>

<span data-ttu-id="4e3e6-143">Aşağıdaki örnek, C# derleyicisinin bir yöntem çağrısını türde bir örnek yöntemine mi yoksa bir genişletme yöntemine mi bağlayacağını belirlemede izlediği kuralları gösterir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-143">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="4e3e6-144">Statik sınıf, `Extensions` uygulayan her tür için tanımlanmış genişletme yöntemleri içerir `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-144">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="4e3e6-145">Sınıfları `A` , `B` ve `C` All arabirimini uygular.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-145">Classes `A`, `B`, and `C` all implement the interface.</span></span>

<span data-ttu-id="4e3e6-146">`MethodB`Ad ve imza, sınıflar tarafından zaten uygulanmış yöntemlerle tam olarak eşleştiğinden, genişletme yöntemi hiçbir şekilde çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-146">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>

<span data-ttu-id="4e3e6-147">Derleyici eşleşen imzaya sahip bir örnek yöntemi bulamadığında, varsa eşleşen bir uzantı yöntemine bağlanır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-147">When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>

[!code-csharp[csProgGuideExtensionMethods#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideExtensionMethods/cs/extensionmethods.cs#5)]

## <a name="common-usage-patterns"></a><span data-ttu-id="4e3e6-148">Ortak kullanım desenleri</span><span class="sxs-lookup"><span data-stu-id="4e3e6-148">Common Usage Patterns</span></span>

### <a name="collection-functionality"></a><span data-ttu-id="4e3e6-149">Koleksiyon Işlevselliği</span><span class="sxs-lookup"><span data-stu-id="4e3e6-149">Collection Functionality</span></span>

<span data-ttu-id="4e3e6-150">Geçmişte, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> belirli bir tür için arabirimi uygulayan ve bu türdeki koleksiyonlar üzerinde işlem yapan işlevselliği içeren "koleksiyon sınıfları" oluşturmak yaygın bir şekilde oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-150">In the past, it was common to create "Collection Classes" that implemented the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> interface for a given type and contained functionality that acted on collections of that type.</span></span> <span data-ttu-id="4e3e6-151">Bu tür koleksiyon nesnesini oluştururken bir sorun olmadığından, üzerinde bir uzantı kullanılarak aynı işlevsellik elde edilebilir <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-151">While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4e3e6-152">Uzantılar, işlevin <xref:System.Array?displayProperty=nameWithType> <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> Bu tür üzerinde uygulayan bir veya gibi herhangi bir koleksiyondan çağrılmasına izin vermenin avantajlarından yararlanır <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-152">Extensions have the advantage of allowing the functionality to be called from any collection such as an <xref:System.Array?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601?displayProperty=nameWithType> that implements <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> on that type.</span></span> <span data-ttu-id="4e3e6-153">Bu [makalede daha önce](#orderby-example), bir Int32 dizisi kullanılarak buna bir örnek bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-153">An example of this using an Array of Int32 can be found [earlier in this article](#orderby-example).</span></span>

### <a name="layer-specific-functionality"></a><span data-ttu-id="4e3e6-154">Katmana özgü Işlevsellik</span><span class="sxs-lookup"><span data-stu-id="4e3e6-154">Layer-Specific Functionality</span></span>

<span data-ttu-id="4e3e6-155">Çoklu kare mimarisi veya diğer katmanlı uygulama tasarımı kullanırken, bir dizi etki alanı varlığı veya uygulama sınırları genelinde iletişim kurmak için kullanılabilecek nesneleri Veri Aktarımı.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-155">When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries.</span></span> <span data-ttu-id="4e3e6-156">Bu nesneler genellikle hiçbir işlevsellik içermez veya yalnızca uygulamanın tüm katmanları için geçerli olan minimum işlevleri içerir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-156">These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application.</span></span> <span data-ttu-id="4e3e6-157">Uzantı yöntemleri, nesneleri gerekli olmayan yöntemlerle yüklemeden veya diğer katmanlarda istemeden, her uygulama katmanına özgü işlevselliği eklemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-157">Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.</span></span>

```csharp
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

### <a name="extending-predefined-types"></a><span data-ttu-id="4e3e6-158">Önceden tanımlanmış türleri genişletme</span><span class="sxs-lookup"><span data-stu-id="4e3e6-158">Extending Predefined Types</span></span>

<span data-ttu-id="4e3e6-159">Yeniden kullanılabilir işlevlerin oluşturulması gerektiğinde yeni nesneler oluşturmak yerine, genellikle .NET veya CLR türü gibi var olan bir türü genişletebiliriz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-159">Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type.</span></span> <span data-ttu-id="4e3e6-160">Örnek olarak, genişletme yöntemlerini kullanmıyorsanız, `Engine` `Query` kodumuza ait birden çok konumdan çağrılabilen bir SQL Server sorgu yürütme işini yapmak için bir veya sınıfı oluşturarız.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-160">As an example, if we don't use extension methods, we might create an `Engine` or `Query` class to do the work of executing a query on a SQL Server that may be called from multiple places in our code.</span></span> <span data-ttu-id="4e3e6-161">Ancak, <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> bir SQL Server bağlantısı olan her yerden bu sorguyu gerçekleştirmek için uzantı yöntemlerini kullanarak sınıfı genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-161">However we can instead extend the <xref:System.Data.SqlClient.SqlConnection?displayProperty=nameWithType> class using extension methods to perform that query from anywhere we have a connection to a SQL Server.</span></span> <span data-ttu-id="4e3e6-162">Diğer örnekler, sınıfa ortak işlevsellik eklemek <xref:System.String?displayProperty=nameWithType> , ve nesnelerinin veri işleme yeteneklerini ve <xref:System.IO.File?displayProperty=nameWithType> <xref:System.IO.Stream?displayProperty=nameWithType> <xref:System.Exception?displayProperty=nameWithType> belirli hata işleme işlevselliği için nesneleri genişletmek olabilir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-162">Other examples might be to add common functionality to the <xref:System.String?displayProperty=nameWithType> class, extend the data processing capabilities of the <xref:System.IO.File?displayProperty=nameWithType> and <xref:System.IO.Stream?displayProperty=nameWithType> objects, and <xref:System.Exception?displayProperty=nameWithType> objects for specific error handling functionality.</span></span> <span data-ttu-id="4e3e6-163">Bu tür kullanım örnekleri yalnızca hayal ve iyi bir fikir ile sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-163">These types of use-cases are limited only by your imagination and good sense.</span></span>

<span data-ttu-id="4e3e6-164">Önceden tanımlanmış türleri genişletme, değerler ile `struct` metotlara geçirdikleri için türlerle zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-164">Extending predefined types can be difficult with `struct` types because they're passed by value to methods.</span></span> <span data-ttu-id="4e3e6-165">Diğer bir deyişle, yapı üzerinde yapılan tüm değişiklikler yapının bir kopyasına yapılır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-165">That means any changes to the struct are made to a copy of the struct.</span></span> <span data-ttu-id="4e3e6-166">Uzantı yöntemi çıktıktan sonra bu değişiklikler görünür değildir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-166">Those changes aren't visible once the extension method exits.</span></span> <span data-ttu-id="4e3e6-167">C# 7,2 ile başlayarak, `ref` bir genişletme yönteminin ilk bağımsız değişkenine değiştirici ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-167">Beginning with C# 7.2, you can add the `ref` modifier to the first argument of an extension method.</span></span> <span data-ttu-id="4e3e6-168">Değiştirici eklemek, `ref` ilk bağımsız değişkenin başvuruya göre geçirildiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-168">Adding the `ref` modifier means the first argument is passed by reference.</span></span> <span data-ttu-id="4e3e6-169">Bu, genişletilmekte olan yapının durumunu değiştiren uzantı yöntemleri yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-169">This enables you to write extension methods that change the state of the struct being extended.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="4e3e6-170">Genel Yönergeler</span><span class="sxs-lookup"><span data-stu-id="4e3e6-170">General Guidelines</span></span>

<span data-ttu-id="4e3e6-171">Bir nesnenin kodunu değiştirerek veya makul ve mümkün olduğunda yeni bir tür türeterek işlevsellik eklemek tercih edilir ancak, uzantı yöntemleri .NET ekosistemi boyunca yeniden kullanılabilir işlevsellik oluşturmak için önemli bir seçenek haline gelir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-171">While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem.</span></span> <span data-ttu-id="4e3e6-172">Özgün kaynak denetiminiz altında olmadığında, türetilmiş bir nesne uygunsuz veya imkansız olduğunda ya da işlevselliğin uygun kapsamın ötesinde sunulmaması durumunda, uzantı yöntemleri mükemmel bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-172">For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.</span></span>

<span data-ttu-id="4e3e6-173">Türetilmiş türler hakkında daha fazla bilgi için bkz. [Devralma](./inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="4e3e6-173">For more information on derived types, see [Inheritance](./inheritance.md).</span></span>

<span data-ttu-id="4e3e6-174">Kaynak kodunu denetiminde olmayan bir türü genişletmek için bir genişletme yöntemi kullanırken, türün uygulamasındaki bir değişikliğin genişletme yönteminizin kesilmesine neden olacağı riski çalıştırırsınız.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-174">When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>

<span data-ttu-id="4e3e6-175">Belirli bir tür için uzantı yöntemleri uygularsanız, aşağıdaki noktaları hatırlayın:</span><span class="sxs-lookup"><span data-stu-id="4e3e6-175">If you do implement extension methods for a given type, remember the following points:</span></span>

- <span data-ttu-id="4e3e6-176">Türden tanımlı yöntemle aynı imzaya sahip değilse genişletme yöntemi asla çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-176">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>
- <span data-ttu-id="4e3e6-177">Uzantı yöntemleri ad alanı seviyesinde kapsama alınır.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-177">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="4e3e6-178">Örneğin, adlı tek bir ad alanında uzantı yöntemlerini içeren birden fazla statik sınıfınız varsa `Extensions` , bunların hepsi yönergeyle kapsam haline getirilir `using Extensions;` .</span><span class="sxs-lookup"><span data-stu-id="4e3e6-178">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they'll all be brought into scope by the `using Extensions;` directive.</span></span>

<span data-ttu-id="4e3e6-179">Uygulanan bir sınıf kitaplığı için derleme sürüm numarasının artıyor olmasını önlemek için uzantı yöntemleri kullanmamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-179">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="4e3e6-180">Kaynak koda sahip olduğunuz bir kitaplığa önemli işlevsellik eklemek istiyorsanız, derleme sürümü oluşturma için .NET yönergelerini izleyin.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-180">If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.</span></span> <span data-ttu-id="4e3e6-181">Daha fazla bilgi için bkz. [derleme sürümü oluşturma](../../../standard/assembly/versioning.md).</span><span class="sxs-lookup"><span data-stu-id="4e3e6-181">For more information, see [Assembly Versioning](../../../standard/assembly/versioning.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="4e3e6-182">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="4e3e6-182">See also</span></span>

- [<span data-ttu-id="4e3e6-183">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="4e3e6-183">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="4e3e6-184">Paralel programlama örnekleri (bunlar birçok örnek genişletme yöntemi içerir)</span><span class="sxs-lookup"><span data-stu-id="4e3e6-184">Parallel Programming Samples (these include many example extension methods)</span></span>](/samples/browse/?products=dotnet-core%2Cdotnet-standard&term=parallel)
- [<span data-ttu-id="4e3e6-185">Lambda Ifadeleri</span><span class="sxs-lookup"><span data-stu-id="4e3e6-185">Lambda Expressions</span></span>](../../language-reference/operators/lambda-expressions.md)
- [<span data-ttu-id="4e3e6-186">Standart Sorgu İşleçlerine Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="4e3e6-186">Standard Query Operators Overview</span></span>](../concepts/linq/standard-query-operators-overview.md)
- [<span data-ttu-id="4e3e6-187">Örnek parametreleri ve bunların etkileri için dönüştürme kuralları</span><span class="sxs-lookup"><span data-stu-id="4e3e6-187">Conversion rules for Instance parameters and their impact</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/conversion-rules-for-instance-parameters-and-their-impact)
- [<span data-ttu-id="4e3e6-188">Diller arasında uzantı yöntemleri birlikte çalışabilirliği</span><span class="sxs-lookup"><span data-stu-id="4e3e6-188">Extension methods Interoperability between languages</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-interoperability-between-languages)
- [<span data-ttu-id="4e3e6-189">Uzantı yöntemleri ve curried temsilciler</span><span class="sxs-lookup"><span data-stu-id="4e3e6-189">Extension methods and Curried Delegates</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-methods-and-curried-delegates)
- [<span data-ttu-id="4e3e6-190">Uzantı yöntemi bağlama ve hata raporlama</span><span class="sxs-lookup"><span data-stu-id="4e3e6-190">Extension method Binding and Error reporting</span></span>](https://docs.microsoft.com/archive/blogs/sreekarc/extension-method-binding-and-error-reporting)
