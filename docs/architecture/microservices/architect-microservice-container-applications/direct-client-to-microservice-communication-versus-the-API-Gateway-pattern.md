---
title: API ağ geçidi deseni, doğrudan istemciden mikrohizmete iletişime karşı
description: API ağ geçidi deseninin ve doğrudan istemciden mikrohizmete iletişimin farklılıklarını ve kullanımlarını anlayın.
ms.date: 01/07/2019
ms.openlocfilehash: 47e9a383c1fcb6c9fec38cb376b60a4ab839077d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401727"
---
# <a name="the-api-gateway-pattern-versus-the-direct-client-to-microservice-communication"></a><span data-ttu-id="458db-103">Doğrudan istemciden mikrohizmete iletişime karşı API ağ geçidi deseni</span><span class="sxs-lookup"><span data-stu-id="458db-103">The API gateway pattern versus the Direct client-to-microservice communication</span></span>

<span data-ttu-id="458db-104">Microservices mimarisinde, her microservice bir dizi (genellikle) ince taneli uç noktaları ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="458db-104">In a microservices architecture, each microservice exposes a set of (typically) fine-grained endpoints.</span></span> <span data-ttu-id="458db-105">Bu durum, bu bölümde açıklandığı gibi, istemci-mikrohizmet iletişimetkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="458db-105">This fact can impact the client-to-microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="458db-106">Doğrudan istemciden mikrohizmete iletişim</span><span class="sxs-lookup"><span data-stu-id="458db-106">Direct client-to-microservice communication</span></span>

<span data-ttu-id="458db-107">Olası bir yaklaşım, doğrudan istemciden mikrohizmete iletişim mimarisi kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="458db-107">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="458db-108">Bu yaklaşımda, bir istemci uygulaması Şekil 4-12'de gösterildiği gibi, bazı mikro hizmetlere doğrudan istekte bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-108">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![İstemciden mikrohizmete iletişim mimarisini gösteren diyagram.](./media/direct-client-to-microservice-communication.png)

<span data-ttu-id="458db-110">**Şekil 4-12**.</span><span class="sxs-lookup"><span data-stu-id="458db-110">**Figure 4-12**.</span></span> <span data-ttu-id="458db-111">Doğrudan istemciden mikrohizmete iletişim mimarisini kullanma</span><span class="sxs-lookup"><span data-stu-id="458db-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="458db-112">Bu yaklaşımda, her microservice'in ortak bir bitiş noktası vardır, bazen her microservice için farklı bir TCP bağlantı noktasına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="458db-112">In this approach, each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="458db-113">Belirli bir hizmetin URL'si, Azure'da aşağıdaki URL olabilir:</span><span class="sxs-lookup"><span data-stu-id="458db-113">An example of a URL for a particular service could be the following URL in Azure:</span></span>

`http://eshoponcontainers.westus.cloudapp.azure.com:88/`

<span data-ttu-id="458db-114">Bir kümeyi temel alan bir üretim ortamında, bu URL kümede kullanılan yük dengeleyicisine eşlenir ve bu da istekleri mikro hizmetlere dağıtır.</span><span class="sxs-lookup"><span data-stu-id="458db-114">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="458db-115">Üretim ortamlarında, mikro hizmetleriniz ve Internet arasında [Azure Uygulama Ağ Geçidi](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) gibi bir Uygulama Teslim Denetleyicisi (ADC) olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-115">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="458db-116">Bu, yalnızca yük dengeleme sataşma gerçekleştirmenin yanı sıra SSL sonlandırma sunarak hizmetlerinizi güvence altına alan saydam bir katman görevi görür.</span><span class="sxs-lookup"><span data-stu-id="458db-116">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="458db-117">Bu, CPU yoğun SSL sonlandırma ve diğer yönlendirme görevlerini Azure Uygulama Ağ Geçidi'ne boşaltarak ev sahiplerinizin yükünü artırır.</span><span class="sxs-lookup"><span data-stu-id="458db-117">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="458db-118">Her durumda, bir yük dengeleyici ve ADC bakış mantıksal uygulama mimarisi açısından saydamdır.</span><span class="sxs-lookup"><span data-stu-id="458db-118">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="458db-119">Doğrudan istemciden mikrohizmete iletişim mimarisi, özellikle istemci uygulaması ASP.NET bir MVC uygulaması gibi sunucu tarafında ki bir web uygulamasıysa, küçük bir mikrohizmet tabanlı uygulama için yeterince iyi olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-119">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="458db-120">Ancak, büyük ve karmaşık mikrohizmet tabanlı uygulamalar oluşturduğunuzda (örneğin, düzinelerce mikro hizmet türünü işlerken) ve özellikle istemci uygulamalar uzak mobil uygulamalar veya SPA web uygulamaları olduğunda, bu yaklaşım birkaç sorunla karşı karşıya kalır.</span><span class="sxs-lookup"><span data-stu-id="458db-120">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="458db-121">Mikro hizmetlere dayalı büyük bir uygulama geliştirirken aşağıdaki soruları göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="458db-121">Consider the following questions when developing a large application based on microservices:</span></span>

- <span data-ttu-id="458db-122">*İstemci uygulamaları arka uçtaki istek sayısını nasıl en aza indirebilir ve geveze iletişimi birden çok mikro hizmete indirgeyebilir?*</span><span class="sxs-lookup"><span data-stu-id="458db-122">*How can client apps minimize the number of requests to the back end and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="458db-123">Tek bir UI ekranı oluşturmak için birden çok mikro hizmetle etkileşim kurmak, Internet'te gidiş-dönüş seyahat sayısını artırır.</span><span class="sxs-lookup"><span data-stu-id="458db-123">Interacting with multiple microservices to build a single UI screen increases the number of round trips across the Internet.</span></span> <span data-ttu-id="458db-124">Bu, UI tarafında gecikme ve karmaşıklığı artırır.</span><span class="sxs-lookup"><span data-stu-id="458db-124">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="458db-125">İdeal olarak, yanıtlar sunucu tarafında verimli bir şekilde toplanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="458db-125">Ideally, responses should be efficiently aggregated in the server side.</span></span> <span data-ttu-id="458db-126">Birden çok veri parçası paralel olarak geri geldiğinden ve bazı UI'ler hazır olur olmaz verileri gösterebildiği için bu gecikme süresini azaltır.</span><span class="sxs-lookup"><span data-stu-id="458db-126">This reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it's ready.</span></span>

- <span data-ttu-id="458db-127">*Yetkilendirme, veri dönüşümleri ve dinamik istek gönderme gibi çapraz kesme yle nasıl başa çıkabilirsiniz?*</span><span class="sxs-lookup"><span data-stu-id="458db-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="458db-128">Her mikro hizmette güvenlik ve yetkilendirme gibi güvenlik ve çapraz kesme kaygılarının uygulanması önemli geliştirme çabası gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="458db-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="458db-129">Olası bir yaklaşım, bu hizmetlerin Docker ana bilgisayar veya dahili küme içinde dışarıdan doğrudan erişimi kısıtlamak ve api ağ geçidi gibi merkezi bir yerde bu çapraz kesme endişelerini uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="458db-129">A possible approach is to have those services within the Docker host or internal cluster to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

- <span data-ttu-id="458db-130">*İstemci uygulamaları, Internet dostu olmayan protokoller kullanan hizmetlerle nasıl iletişim kurabilir?*</span><span class="sxs-lookup"><span data-stu-id="458db-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="458db-131">Sunucu tarafında kullanılan protokoller (AMQP veya ikili protokoller gibi) genellikle istemci uygulamalarında desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="458db-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="458db-132">Bu nedenle, istekler HTTP/HTTPS gibi protokoller aracılığıyla gerçekleştirilmeli ve daha sonra diğer protokollere çevrilmelidir.</span><span class="sxs-lookup"><span data-stu-id="458db-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="458db-133">*Ortadaki adam* yaklaşımı bu durumda yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-133">A *man-in-the-middle* approach can help in this situation.</span></span>

- <span data-ttu-id="458db-134">*Özellikle mobil uygulamalar için yapılmış bir cepheyi nasıl şekillendirebilirsiniz?*</span><span class="sxs-lookup"><span data-stu-id="458db-134">*How can you shape a facade especially made for mobile apps?*</span></span>

<span data-ttu-id="458db-135">Birden çok mikro hizmetin API'si farklı istemci uygulamalarının gereksinimleri için iyi tasarlanamayabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="458db-136">Örneğin, bir mobil uygulamanın gereksinimleri bir web uygulamasının gereksinimlerinden farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="458db-137">Mobil uygulamalar için, veri yanıtları daha verimli olması için daha da optimize etmek gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="458db-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="458db-138">Bunu, birden çok mikro hizmetten veri toplayarak ve tek bir veri kümesini döndürerek ve bazen mobil uygulamanın ihtiyaç daşmayan yanıtındaki verileri ortadan kaldırarak yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that isn't needed by the mobile app.</span></span> <span data-ttu-id="458db-139">Ve, tabii ki, bu verileri sıkıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="458db-140">Yine, mobil uygulama ve mikro hizmetler arasında bir cephe veya API bu senaryo için uygun olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-140">Again, a facade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="why-consider-api-gateways-instead-of-direct-client-to-microservice-communication"></a><span data-ttu-id="458db-141">Neden doğrudan istemciden mikrohizmete iletişim yerine API Ağ Geçitleri'ni göz önünde bulundurun?</span><span class="sxs-lookup"><span data-stu-id="458db-141">Why consider API Gateways instead of direct client-to-microservice communication</span></span>

<span data-ttu-id="458db-142">Bir microservices mimarisinde, istemci uygulamalarının genellikle birden fazla microservice işlevselliğini tüketmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="458db-142">In a microservices architecture, the client apps usually need to consume functionality from more than one microservice.</span></span> <span data-ttu-id="458db-143">Bu tüketim doğrudan gerçekleştirilirse, istemcinin mikrohizmet uç noktalarına birden çok çağrı yı işlemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="458db-143">If that consumption is performed directly, the client needs to handle multiple calls to microservice endpoints.</span></span> <span data-ttu-id="458db-144">Uygulama geliştiğinde ve yeni mikro hizmetler sunulduğunda veya mevcut mikro hizmetler güncellendiğinde ne olur?</span><span class="sxs-lookup"><span data-stu-id="458db-144">What happens when the application evolves and new microservices are introduced or existing microservices are updated?</span></span> <span data-ttu-id="458db-145">Uygulamanızda çok sayıda mikro hizmet varsa, istemci uygulamalarından bu kadar çok uç nokta yı işlemek bir kabus olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-145">If your application has many microservices, handling so many endpoints from the client apps can be a nightmare.</span></span> <span data-ttu-id="458db-146">İstemci uygulaması bu dahili uç noktalarla birleştiğinden, gelecekte mikro hizmetlerin gelişmesi istemci uygulamaları üzerinde yüksek etkiye neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-146">Since the client app would be coupled to those internal endpoints, evolving the microservices in the future can cause high impact for the client apps.</span></span>

<span data-ttu-id="458db-147">Bu nedenle, bir ara düzey veya indirection katmanı (Ağ Geçidi) olması mikro hizmet tabanlı uygulamalar için çok uygun olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-147">Therefore, having an intermediate level or tier of indirection (Gateway) can be very convenient for microservice-based applications.</span></span> <span data-ttu-id="458db-148">API Ağ Geçitleriniz yoksa, istemci uygulamalarının istekleri doğrudan mikro hizmetlere göndermesi gerekir ve bu da aşağıdaki sorunlar gibi sorunlara yol açar:</span><span class="sxs-lookup"><span data-stu-id="458db-148">If you don't have API Gateways, the client apps must send requests directly to the microservices and that raises problems, such as the following issues:</span></span>

- <span data-ttu-id="458db-149">**Kaplin**: API Ağ Geçidi deseni olmadan, istemci uygulamaları dahili mikro hizmetlerle birleştiğinde.</span><span class="sxs-lookup"><span data-stu-id="458db-149">**Coupling**: Without the API Gateway pattern, the client apps are coupled to the internal microservices.</span></span> <span data-ttu-id="458db-150">İstemci uygulamaları, uygulamanın birden fazla alanının mikro hizmetlerde nasıl ayrıştırDığını bilmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="458db-150">The client apps need to know how the multiple areas of the application are decomposed in microservices.</span></span> <span data-ttu-id="458db-151">Dahili mikro hizmetleri geliştirip yeniden düzenleme yaparken, bu eylemler, istemci uygulamalarından gelen dahili mikro hizmetlere doğrudan başvuru nedeniyle istemci uygulamalarında kırılmalara neden oldukları için bakımı oldukça kötü etkiler.</span><span class="sxs-lookup"><span data-stu-id="458db-151">When evolving and refactoring the internal microservices, those actions impact maintenance pretty badly because they cause breaking changes to the client apps due to the direct reference to the internal microservices from the client apps.</span></span> <span data-ttu-id="458db-152">İstemci uygulamalarının sık sık güncellenmesi gerekir, bu da çözümün daha da gelişmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="458db-152">Client apps need to be updated frequently, making the solution harder to evolve.</span></span>

- <span data-ttu-id="458db-153">**Çok fazla gidiş-dönüş seyahat**: İstemci uygulamasındaki tek bir sayfa/ekran birden çok hizmete birden fazla çağrı gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="458db-153">**Too many round trips**: A single page/screen in the client app might require several calls to multiple services.</span></span> <span data-ttu-id="458db-154">Bu, istemci ve sunucu arasında birden çok ağ turu turuna neden olabilir ve önemli bir gecikme sonu ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="458db-154">That can result in multiple network round trips between the client and the server, adding significant latency.</span></span> <span data-ttu-id="458db-155">Ara düzeyde işlenen toplama, istemci uygulamasının performansını ve kullanıcı deneyimini artırabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-155">Aggregation handled in an intermediate level could improve the performance and user experience for the client app.</span></span>

- <span data-ttu-id="458db-156">**Güvenlik sorunları**: Ağ geçidi olmadan, tüm mikro hizmetler "dış dünyaya" maruz kalmalıdır ve bu da saldırı yüzeyini istemci uygulamaları tarafından doğrudan kullanılmayan dahili mikro hizmetleri gizlemenize göre daha büyük hale getirmelidir.</span><span class="sxs-lookup"><span data-stu-id="458db-156">**Security issues**: Without a gateway, all the microservices must be exposed to the "external world", making the attack surface larger than if you hide internal microservices that aren't directly used by the client apps.</span></span> <span data-ttu-id="458db-157">Saldırı yüzeyi ne kadar küçükse, uygulamanız o kadar güvenli olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-157">The smaller the attack surface is, the more secure your application can be.</span></span>

- <span data-ttu-id="458db-158">**Çapraz kesme endişeleri**: Kamuya açık her mikro hizmet, yetkilendirme, SSL, vb. gibi endişeleri ele almalıdır. Birçok durumda, bu endişeler tek bir katmanda ele alınabilir, böylece dahili mikro hizmetler basitleştirilir.</span><span class="sxs-lookup"><span data-stu-id="458db-158">**Cross-cutting concerns**: Each publicly published microservice must handle concerns such as authorization, SSL, etc. In many situations, those concerns could be handled in a single tier so the internal microservices are simplified.</span></span>

## <a name="what-is-the-api-gateway-pattern"></a><span data-ttu-id="458db-159">API Ağ Geçidi deseni nedir?</span><span class="sxs-lookup"><span data-stu-id="458db-159">What is the API Gateway pattern?</span></span>

<span data-ttu-id="458db-160">Birden çok istemci uygulamasıyla büyük veya karmaşık mikrohizmet tabanlı uygulamalar tasarlayıp oluşturduğunuzda, dikkate alınması gereken iyi bir yaklaşım [api ağ geçidi](https://microservices.io/patterns/apigateway.html)olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-160">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="458db-161">Bu, belirli mikro hizmet grupları için tek giriş noktası sağlayan bir hizmettir.</span><span class="sxs-lookup"><span data-stu-id="458db-161">This is a service that provides a single-entry point for certain groups of microservices.</span></span> <span data-ttu-id="458db-162">Nesne yönelimli tasarımdaki [Cephe desenine](https://en.wikipedia.org/wiki/Facade_pattern) benzer, ama bu durumda, dağıtılmış bir sistemin parçası.</span><span class="sxs-lookup"><span data-stu-id="458db-162">It's similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object-oriented design, but in this case, it's part of a distributed system.</span></span> <span data-ttu-id="458db-163">API Ağ Geçidi deseni bazen "ön uç için arka uç"[(BFF)](https://samnewman.io/patterns/architectural/bff/)olarak da bilinir, çünkü istemci uygulamasının gereksinimlerini düşünürken bunu oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="458db-163">The API Gateway pattern is also sometimes known as the "backend for frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="458db-164">Bu nedenle, API ağ geçidi istemci uygulamaları ve mikro hizmetler arasında yer alıyor.</span><span class="sxs-lookup"><span data-stu-id="458db-164">Therefore, the API gateway sits between the client apps and the microservices.</span></span> <span data-ttu-id="458db-165">İstemlerden hizmetlere istekleri yönlendirme, ters proxy olarak görür.</span><span class="sxs-lookup"><span data-stu-id="458db-165">It acts as a reverse proxy, routing requests from clients to services.</span></span> <span data-ttu-id="458db-166">Ayrıca kimlik doğrulama, SSL sonlandırma ve önbellek gibi ek çapraz kesme özellikleri de sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-166">It can also provide additional cross-cutting features such as authentication, SSL termination, and cache.</span></span>

<span data-ttu-id="458db-167">Şekil 4-13, özel bir API Ağ Geçidi'nin yalnızca birkaç mikro hizmetle basitleştirilmiş mikrohizmet tabanlı bir mimariye nasıl sığabileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="458db-167">Figure 4-13 shows how a custom API Gateway can fit into a simplified microservice-based architecture with just a few microservices.</span></span>

![Özel hizmet olarak uygulanan bir API Ağ Geçidi'ni gösteren diyagram.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/custom-service-api-gateway.png)

<span data-ttu-id="458db-169">**Şekil 4-13**.</span><span class="sxs-lookup"><span data-stu-id="458db-169">**Figure 4-13**.</span></span> <span data-ttu-id="458db-170">Özel hizmet olarak uygulanan bir API Ağ Geçidi kullanma</span><span class="sxs-lookup"><span data-stu-id="458db-170">Using an API Gateway implemented as a custom service</span></span>

<span data-ttu-id="458db-171">Uygulamalar, istekleri tek tek mikro hizmetlere iletmek üzere yapılandırılan tek bir uç nokta olan API Ağ Geçidi'ne bağlanır.</span><span class="sxs-lookup"><span data-stu-id="458db-171">Apps connect to a single endpoint, the API Gateway, that's configured to forward requests to individual microservices.</span></span> <span data-ttu-id="458db-172">Bu örnekte, API Ağ Geçidi, kapsayıcı olarak çalışan özel bir ASP.NET Core WebHost hizmeti olarak uygulanır.</span><span class="sxs-lookup"><span data-stu-id="458db-172">In this example, the API Gateway would be implemented as a custom ASP.NET Core WebHost service running as a container.</span></span>

<span data-ttu-id="458db-173">Bu diyagramda birden çok ve farklı istemci uygulamasına bakan tek bir özel API Ağ Geçidi hizmeti kullandığınızı vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="458db-173">It's important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="458db-174">API Ağ Geçidi hizmetiniz istemci uygulamalarından gelen birçok farklı gereksinime bağlı olarak büyüyeceği ve gelişeceği için bu durum önemli bir risk olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-174">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="458db-175">Sonunda, bu farklı ihtiyaçları nedeniyle şişirilmiş olacak ve etkili bir monolitik uygulama veya monolitik hizmet oldukça benzer olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-175">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="458db-176">Bu nedenle, API Ağ Geçidi'ni örneğin istemci uygulama form faktörü türü başına bir olmak üzere birden çok hizmete veya birden çok küçük API Ağ Geçidine bölmenize çok yöneliktır.</span><span class="sxs-lookup"><span data-stu-id="458db-176">That's why it's very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per client app form-factor type, for instance.</span></span>

<span data-ttu-id="458db-177">API Ağ Geçidi deseni uygularken dikkatli olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="458db-177">You need to be careful when implementing the API Gateway pattern.</span></span> <span data-ttu-id="458db-178">Genellikle uygulamanızın tüm dahili microservices toplama tek bir API Ağ Geçidi olması iyi bir fikir değildir.</span><span class="sxs-lookup"><span data-stu-id="458db-178">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="458db-179">Eğer varsa, yekpare bir toplayıcı veya orkestratör olarak hareket eder ve tüm microservices birikerek microservice özerkliğini ihlal eder.</span><span class="sxs-lookup"><span data-stu-id="458db-179">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span>

<span data-ttu-id="458db-180">Bu nedenle, API Ağ Geçitleri iş sınırlarına ve istemci uygulamalarına göre ayrı tutulmalıdır ve tüm dahili mikro hizmetler için tek bir toplayıcı olarak hareket etmemelidir.</span><span class="sxs-lookup"><span data-stu-id="458db-180">Therefore, the API Gateways should be segregated based on business boundaries and the client apps and not act as a single aggregator for all the internal microservices.</span></span>

<span data-ttu-id="458db-181">API Ağ Geçidi katmanını birden çok API Ağ Geçidi'ne bölerken, uygulamanızda birden çok istemci uygulaması varsa, birden çok API Ağ Geçidi türünü tanımlarken birincil pivot olabilir, böylece her istemci uygulamasının gereksinimleri için farklı bir cepheye sahip olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-181">When splitting the API Gateway tier into multiple API Gateways, if your application has multiple client apps, that can be a primary pivot when identifying the multiple API Gateways types, so that you can have a different facade for the needs of each client app.</span></span> <span data-ttu-id="458db-182">Bu durum, her API Ağ Geçidi'nin her istemci uygulama türü için özel leştirilmiş farklı bir API sağlayabileceği ve hatta aşağıdaki resimde gösterildiği gibi birden çok dahili mikro hizmeti çağıran belirli bağdaştırıcı kodu uygulayarak istemci form faktörüne göre uyarlanmış farklı bir API sağlayabileceği "Frontend için Backend" ([BFF)](https://samnewman.io/patterns/architectural/bff/)adlı bir desendir:</span><span class="sxs-lookup"><span data-stu-id="458db-182">This case is a pattern named "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) where each API Gateway can provide a different API tailored for each client app type, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices, as shown in the following image:</span></span>

![Birden çok özel API Ağ Geçidi ni gösteren diyagram.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/multiple-custom-api-gateways.png)

<span data-ttu-id="458db-184">**Şekil 4-13.1**.</span><span class="sxs-lookup"><span data-stu-id="458db-184">**Figure 4-13.1**.</span></span> <span data-ttu-id="458db-185">Birden çok özel API Ağ Geçidi kullanma</span><span class="sxs-lookup"><span data-stu-id="458db-185">Using multiple custom API Gateways</span></span>

<span data-ttu-id="458db-186">Şekil 4-13.1, istemci türüne göre ayrılmış API Ağ geçitlerini gösterir; biri mobil istemciler ve diğeri de web istemcileri için.</span><span class="sxs-lookup"><span data-stu-id="458db-186">Figure 4-13.1 shows API Gateways that are segregated by client type; one for mobile clients and one for web clients.</span></span> <span data-ttu-id="458db-187">Geleneksel bir web uygulaması, web API Ağ Geçidi'ni kullanan bir MVC microservice'e bağlanır.</span><span class="sxs-lookup"><span data-stu-id="458db-187">A traditional web app connects to an MVC microservice that uses the web API Gateway.</span></span> <span data-ttu-id="458db-188">Örnekte, birden çok ince taneli API Ağ Geçidi içeren basitleştirilmiş bir mimari gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="458db-188">The example depicts a simplified architecture with multiple fine-grained API Gateways.</span></span> <span data-ttu-id="458db-189">Bu durumda, her API Ağ Geçidi için tanımlanan sınırlar tamamen "Frontend için Backend"[(BFF)](https://samnewman.io/patterns/architectural/bff/)desenine dayanır, bu nedenle yalnızca istemci uygulaması başına gereken API'ye dayanır.</span><span class="sxs-lookup"><span data-stu-id="458db-189">In this case, the boundaries identified for each API Gateway are based purely on the "Backend for Frontend" ([BFF](https://samnewman.io/patterns/architectural/bff/)) pattern, hence based just on the API needed per client app.</span></span> <span data-ttu-id="458db-190">Ancak daha büyük uygulamalarda da daha ileri gitmeli ve ikinci bir tasarım pivotolarak iş sınırlarına dayalı ek API Ağ Geçitleri oluşturmalısınız.</span><span class="sxs-lookup"><span data-stu-id="458db-190">But in larger applications you should also go further and create additional API Gateways based on business boundaries as a second design pivot.</span></span>

## <a name="main-features-in-the-api-gateway-pattern"></a><span data-ttu-id="458db-191">API Ağ Geçidi modelindeki ana özellikler</span><span class="sxs-lookup"><span data-stu-id="458db-191">Main features in the API Gateway pattern</span></span>

<span data-ttu-id="458db-192">BIR API Ağ Geçidi birden çok özellik sunabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-192">An API Gateway can offer multiple features.</span></span> <span data-ttu-id="458db-193">Ürüne bağlı olarak daha zengin veya daha basit özellikler sunabilir, ancak herhangi bir API Ağ Geçidi için en önemli ve temel özellikler aşağıdaki tasarım desenleridir:</span><span class="sxs-lookup"><span data-stu-id="458db-193">Depending on the product it might offer richer or simpler features, however, the most important and foundational features for any API Gateway are the following design patterns:</span></span>

<span data-ttu-id="458db-194">**Proxy veya ağ geçidi yönlendirmesi ters.**</span><span class="sxs-lookup"><span data-stu-id="458db-194">**Reverse proxy or gateway routing.**</span></span> <span data-ttu-id="458db-195">API Ağ Geçidi, istekleri (katman 7 yönlendirme, genellikle HTTP istekleri) dahili mikro hizmetlerin uç noktalarına yönlendirmek veya yönlendirmek için ters proxy sunar.</span><span class="sxs-lookup"><span data-stu-id="458db-195">The API Gateway offers a reverse proxy to redirect or route requests (layer 7 routing, usually HTTP requests) to the endpoints of the internal microservices.</span></span> <span data-ttu-id="458db-196">Ağ geçidi, istemci uygulamaları için tek bir bitiş noktası veya URL sağlar ve ardından istekleri dahili olarak bir grup dahili mikro hizmetle eşler.</span><span class="sxs-lookup"><span data-stu-id="458db-196">The gateway provides a single endpoint or URL for the client apps and then internally maps the requests to a group of internal microservices.</span></span> <span data-ttu-id="458db-197">Bu yönlendirme özelliği, istemci uygulamalarını mikro hizmetlerden ayırmaya yardımcı olur, ancak api ağ geçidini yekpare API ile istemci uygulamaları arasında oturtarak yekpare bir API'yi modernize ederken de oldukça kullanışlıdır, ardından yeni mikro hizmetler olarak yeni API'ler ekleyebilirsiniz gelecekte birçok mikro hizmetlere bölünene kadar eski yekpare API'yi kullanmaya devam edin.</span><span class="sxs-lookup"><span data-stu-id="458db-197">This routing feature helps to decouple the client apps from the microservices but it's also pretty convenient when modernizing a monolithic API by sitting the API Gateway in between the monolithic API and the client apps, then you can add new APIs as new microservices while still using the legacy monolithic API until it's split into many microservices in the future.</span></span> <span data-ttu-id="458db-198">API Ağ Geçidi sayesinde, kullanılan API'lerin dahili mikro hizmetler veya yekpare API olarak uygulanıp uygulanmadığını ve daha da önemlisi, API Ağ Geçidi yönlendirmesi sayesinde monolitik API'yi mikro hizmetlere dönüştürürken ve yeniden düzenlemede istemci uygulamaları fark etmez. , istemci uygulamaları herhangi bir URI değişikliğinden etkilenmez.</span><span class="sxs-lookup"><span data-stu-id="458db-198">Because of the API Gateway, the client apps won't notice if the APIs being used are implemented as internal microservices or a monolithic API and more importantly, when evolving and refactoring the monolithic API into microservices, thanks to the API Gateway routing, client apps won't be impacted with any URI change.</span></span>

<span data-ttu-id="458db-199">Daha fazla bilgi için [ağ geçidi yönlendirme deseni'ne](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing)bakın.</span><span class="sxs-lookup"><span data-stu-id="458db-199">For more information, see [Gateway routing pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-routing).</span></span>

<span data-ttu-id="458db-200">**Toplama istekleri.**</span><span class="sxs-lookup"><span data-stu-id="458db-200">**Requests aggregation.**</span></span> <span data-ttu-id="458db-201">Ağ geçidi deseninin bir parçası olarak, birden çok dahili mikro hizmeti hedefleyen birden çok istemci isteğini (genellikle HTTP istekleri) tek bir istemci isteğine toplayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-201">As part of the gateway pattern you can aggregate multiple client requests (usually HTTP requests) targeting multiple internal microservices into a single client request.</span></span> <span data-ttu-id="458db-202">Bu desen, özellikle bir istemci sayfasının/ekranının çeşitli mikro hizmetlerden gelen bilgilere ihtiyacı olduğunda kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="458db-202">This pattern is especially convenient when a client page/screen needs information from several microservices.</span></span> <span data-ttu-id="458db-203">Bu yaklaşımla, istemci uygulaması API Ağ Geçidi'ne tek bir istek gönderir ve bu istekler dahili mikro hizmetlere gönderilir ve ardından sonuçları toplar ve her şeyi istemci uygulamasına geri gönderir.</span><span class="sxs-lookup"><span data-stu-id="458db-203">With this approach, the client app sends a single request to the API Gateway that dispatches several requests to the internal microservices and then aggregates the results and sends everything back to the client app.</span></span> <span data-ttu-id="458db-204">Bu tasarım deseninin temel yararı ve amacı, mobil uygulamalar veya SPA uygulamalarından gelen istekler gibi mikro hizmetlerin yaşadığı veri merkezinin dışında, özellikle uzak uygulamalar için önemli olan istemci uygulamaları ve arka uç API'si arasındaki gevezeliği azaltmaktır. istemci uzak tarayıcılarda Javascript geliyor.</span><span class="sxs-lookup"><span data-stu-id="458db-204">The main benefit and goal of this design pattern is to reduce chattiness between the client apps and the backend API, which is especially important for remote apps out of the datacenter where the microservices live, like mobile apps or requests coming from SPA apps that come from Javascript in client remote browsers.</span></span> <span data-ttu-id="458db-205">Sunucu ortamında istekleri gerçekleştiren normal web uygulamaları için (ASP.NET Core MVC web uygulaması gibi), gecikme gecikmesi uzak istemci uygulamalarına göre çok daha küçük olduğu için bu desen o kadar önemli değildir.</span><span class="sxs-lookup"><span data-stu-id="458db-205">For regular web apps performing the requests in the server environment (like an ASP.NET Core MVC web app), this pattern is not so important as the latency is very much smaller than for remote client apps.</span></span>

<span data-ttu-id="458db-206">Kullandığınız API Ağ Geçidi ürününe bağlı olarak, bu toplama yı gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="458db-206">Depending on the API Gateway product you use, it might be able to perform this aggregation.</span></span> <span data-ttu-id="458db-207">Ancak, çoğu durumda API Ağ Geçidi kapsamında toplama mikrohizmetleri oluşturmak daha esnektir, bu nedenle kümelenmeyi kodda tanımlarsınız (c# kodu):</span><span class="sxs-lookup"><span data-stu-id="458db-207">However, in many cases it's more flexible to create aggregation microservices under the scope of the API Gateway, so you define the aggregation in code (that is, C# code):</span></span>

<span data-ttu-id="458db-208">Daha fazla bilgi için [ağ geçidi toplama deseni'ne](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation)bakın.</span><span class="sxs-lookup"><span data-stu-id="458db-208">For more information, see [Gateway aggregation pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-aggregation).</span></span>

<span data-ttu-id="458db-209">**Çapraz kesme endişeleri veya ağ geçidi boşaltma.**</span><span class="sxs-lookup"><span data-stu-id="458db-209">**Cross-cutting concerns or gateway offloading.**</span></span> <span data-ttu-id="458db-210">Her API Ağ Geçidi ürünü tarafından sunulan özelliklere bağlı olarak, işlevselliği tek tek mikro hizmetlerden ağ geçidine boşaltarak, çapraz kesme endişelerini tek bir katmanda birleştirerek her bir mikro hizmetin uygulanmasını kolaylaştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-210">Depending on the features offered by each API Gateway product, you can offload functionality from individual microservices to the gateway, which simplifies the implementation of each microservice by consolidating cross-cutting concerns into one tier.</span></span> <span data-ttu-id="458db-211">Bu, özellikle aşağıdaki işlevler gibi her dahili mikro hizmette düzgün bir şekilde uygulanması karmaşık olabilecek özel leştirilmiş özellikler için uygundur:</span><span class="sxs-lookup"><span data-stu-id="458db-211">This is especially convenient for specialized features that can be complex to implement properly in every internal microservice, such as the following functionality:</span></span>

- <span data-ttu-id="458db-212">Kimlik doğrulama ve yetkilendirme</span><span class="sxs-lookup"><span data-stu-id="458db-212">Authentication and authorization</span></span>
- <span data-ttu-id="458db-213">Hizmet bulma tümleştirmesi</span><span class="sxs-lookup"><span data-stu-id="458db-213">Service discovery integration</span></span>
- <span data-ttu-id="458db-214">Yanıtları Önbelleğe Alma</span><span class="sxs-lookup"><span data-stu-id="458db-214">Response caching</span></span>
- <span data-ttu-id="458db-215">Yeniden deneme politikaları, devre kesici ve QoS</span><span class="sxs-lookup"><span data-stu-id="458db-215">Retry policies, circuit breaker, and QoS</span></span>
- <span data-ttu-id="458db-216">Hız sınırlama ve azaltma</span><span class="sxs-lookup"><span data-stu-id="458db-216">Rate limiting and throttling</span></span>
- <span data-ttu-id="458db-217">Yük dengeleme</span><span class="sxs-lookup"><span data-stu-id="458db-217">Load balancing</span></span>
- <span data-ttu-id="458db-218">Günlük, izleme, korelasyon</span><span class="sxs-lookup"><span data-stu-id="458db-218">Logging, tracing, correlation</span></span>
- <span data-ttu-id="458db-219">Üstbilgi, sorgu dizeleri ve talepleri dönüştürme</span><span class="sxs-lookup"><span data-stu-id="458db-219">Headers, query strings, and claims transformation</span></span>
- <span data-ttu-id="458db-220">IP beyaz liste</span><span class="sxs-lookup"><span data-stu-id="458db-220">IP whitelisting</span></span>

<span data-ttu-id="458db-221">Daha fazla bilgi için [bkz.](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading)</span><span class="sxs-lookup"><span data-stu-id="458db-221">For more information, see [Gateway offloading pattern](https://docs.microsoft.com/azure/architecture/patterns/gateway-offloading).</span></span>

## <a name="using-products-with-api-gateway-features"></a><span data-ttu-id="458db-222">API Ağ Geçidi özelliklerine sahip ürünleri kullanma</span><span class="sxs-lookup"><span data-stu-id="458db-222">Using products with API Gateway features</span></span>

<span data-ttu-id="458db-223">Her uygulamaya bağlı olarak API Ağ Geçitleri ürünleri tarafından sunulan çok daha fazla çapraz kesme endişeleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-223">There can be many more cross-cutting concerns offered by the API Gateways products depending on each implementation.</span></span> <span data-ttu-id="458db-224">Burada keşfedeceğiz:</span><span class="sxs-lookup"><span data-stu-id="458db-224">We'll explore here:</span></span>

- [<span data-ttu-id="458db-225">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="458db-225">Azure API Management</span></span>](https://azure.microsoft.com/services/api-management/)
- [<span data-ttu-id="458db-226">Ocelot</span><span class="sxs-lookup"><span data-stu-id="458db-226">Ocelot</span></span>](https://github.com/ThreeMammals/Ocelot)

### <a name="azure-api-management"></a><span data-ttu-id="458db-227">Azure API Management</span><span class="sxs-lookup"><span data-stu-id="458db-227">Azure API Management</span></span>

<span data-ttu-id="458db-228">[Azure API Yönetimi](https://azure.microsoft.com/services/api-management/) (Şekil 4-14'te gösterildiği gibi) yalnızca API Ağ Geçidi ihtiyaçlarınızı çözmekle kalmıyor, aynı zamanda API'lerinizden öngörüler toplama gibi özellikler de sağlar.</span><span class="sxs-lookup"><span data-stu-id="458db-228">[Azure API Management](https://azure.microsoft.com/services/api-management/) (as shown in Figure 4-14) not only solves your API Gateway needs but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="458db-229">Bir API yönetimi çözümü kullanıyorsanız, API Ağ Geçidi yalnızca tam API yönetimi çözümü içinde bir bileşendir.</span><span class="sxs-lookup"><span data-stu-id="458db-229">If you're using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![API ağ geçidiniz olarak Azure API Yönetimi'nin nasıl kullanılacağını gösteren diyagram.](./media/direct-client-to-microservice-communication-versus-the-API-Gateway-pattern/api-gateway-azure-api-management.png)

<span data-ttu-id="458db-231">**Şekil 4-14**.</span><span class="sxs-lookup"><span data-stu-id="458db-231">**Figure 4-14**.</span></span> <span data-ttu-id="458db-232">API Ağ Geçidiniz için Azure API Yönetimini kullanma</span><span class="sxs-lookup"><span data-stu-id="458db-232">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="458db-233">Azure API Yönetimi hem API Ağ Geçidi nizi hem de günlük, güvenlik, ölçüm, vb. gibi Yönetim gereksinimlerinizi çözer. Bu durumda, Azure API Yönetimi gibi bir ürünü kullanırken, bu tür API Ağ geçitleri "daha ince" olduğundan, tek bir API Ağ Geçidi'ne sahip olabileceğiniz gerçeği o kadar da riskli değildir, yani yekpare bir bileşene dönüşebilecek özel C# kodu uygulamazsınız.</span><span class="sxs-lookup"><span data-stu-id="458db-233">Azure API Management solves both your API Gateway and Management needs like logging, security, metering, etc. In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span>

<span data-ttu-id="458db-234">API Ağ Geçidi ürünleri genellikle giriş iletişimi için ters proxy gibi davranır, burada api'leri dahili mikro hizmetlerden filtreleyebilir ve bu tek katmanda yayınlanan API'lere yetkilendirme uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-234">The API Gateway products usually act like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="458db-235">API Yönetim sisteminden edinilebilen bilgiler, API'lerinizin nasıl kullanıldığını ve nasıl performans gösterdiğini anlamanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="458db-235">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="458db-236">Bunu, yakın gerçek zamanlı analiz raporlarını görüntülemenize ve işletmenizi etkileyebilecek eğilimleri belirleyerek yaparlar.</span><span class="sxs-lookup"><span data-stu-id="458db-236">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="458db-237">Ayrıca, daha fazla çevrimiçi ve çevrimdışı çözümleme için istek ve yanıt etkinliği yle ilgili günlüklere sahip olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-237">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="458db-238">Azure API Yönetimi ile API'lerinizi bir anahtar, bir belirteç ve IP filtreleme kullanarak güvenebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-238">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="458db-239">Bu özellikler, esnek ve ince taneli kotaları ve oran sınırlarını zorlamanıza, ilkeleri kullanarak API'lerinizin şeklini ve davranışını değiştirmenize ve yanıt önbelleğe alma yla performansı artırmanıza izin verir.</span><span class="sxs-lookup"><span data-stu-id="458db-239">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="458db-240">Bu kılavuzda ve başvuru örneği uygulamasında (eShopOnContainers), azure API Yönetimi gibi PaaS ürünlerini kullanmadan düz kaplara odaklanmak için mimari daha basit ve özel yapım kapsayıcı mimarisiyle sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="458db-240">In this guide and the reference sample application (eShopOnContainers), the architecture is limited to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="458db-241">Ancak Microsoft Azure'da dağıtılan büyük mikro hizmet tabanlı uygulamalar için, üretimdeki API Ağ geçitlerinizin temeli olarak Azure API Yönetimini değerlendirmenizi öneririz.</span><span class="sxs-lookup"><span data-stu-id="458db-241">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to evaluate Azure API Management as the base for your API Gateways in production.</span></span>

### <a name="ocelot"></a><span data-ttu-id="458db-242">Ocelot</span><span class="sxs-lookup"><span data-stu-id="458db-242">Ocelot</span></span>

<span data-ttu-id="458db-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) hafif bir API Ağ Geçidi, basit yaklaşımlar için önerilir.</span><span class="sxs-lookup"><span data-stu-id="458db-243">[Ocelot](https://github.com/ThreeMammals/Ocelot) is a lightweight API Gateway, recommended for simpler approaches.</span></span> <span data-ttu-id="458db-244">Ocelot, özellikle kendi sistemine birleşik giriş noktaları gerektiren mikro hizmetler mimarisi için yapılmış bir Açık Kaynak .NET Core tabanlı API Ağ Geçididir.</span><span class="sxs-lookup"><span data-stu-id="458db-244">Ocelot is an Open Source .NET Core based API Gateway especially made for microservices architecture that need unified points of entry into their system.</span></span> <span data-ttu-id="458db-245">Hafif, hızlı, ölçeklenebilir ve diğer birçok özellik arasında yönlendirme ve kimlik doğrulama sağlar.</span><span class="sxs-lookup"><span data-stu-id="458db-245">It's lightweight, fast, scalable and provides routing and authentication among many other features.</span></span>

<span data-ttu-id="458db-246">[eShopOnContainers başvuru uygulaması](https://github.com/dotnet-architecture/eShopOnContainers) için Ocelot'u seçmenizin temel nedeni, Ocelot'un Docker Host, Kubernetes gibi mikro hizmetleri/kapsayıcılarınızı dağıttığınız aynı uygulama dağıtım ortamına dağıtabileceğiniz bir .NET Core hafif API Ağ Geçidi olmasıdır. Ve .NET Core'a dayandığı için, Linux veya Windows'da dağıtım alabildiğiniz çapraz platformdur.</span><span class="sxs-lookup"><span data-stu-id="458db-246">The main reason to choose Ocelot for the [eShopOnContainers reference application](https://github.com/dotnet-architecture/eShopOnContainers) is because Ocelot is a .NET Core lightweight API Gateway that you can deploy into the same application deployment environment where you're deploying your microservices/containers, such as a Docker Host, Kubernetes, etc. And since it's based on .NET Core, it's cross-platform allowing you to deploy on Linux or Windows.</span></span>

<span data-ttu-id="458db-247">Kapsayıcılarda çalışan özel API Ağ geçitlerini gösteren önceki diyagramlar, Ocelot'u bir kapsayıcıda ve mikro hizmet tabanlı uygulamada nasıl çalıştırabileceğinizdir.</span><span class="sxs-lookup"><span data-stu-id="458db-247">The previous diagrams showing custom API Gateways running in containers are precisely how you can also run Ocelot in a container and microservice-based application.</span></span>

<span data-ttu-id="458db-248">Buna ek olarak, apigee, Kong, MuleSoft, WSO2 ve linkerd ve Istio gibi diğer ürünler servis örgü denetleyici özellikleri için API Ağ Geçitleri özellikleri sunan piyasada birçok ürün vardır.</span><span class="sxs-lookup"><span data-stu-id="458db-248">In addition, there are many other products in the market offering API Gateways features, such as Apigee, Kong, MuleSoft, WSO2, and other products like Linkerd and Istio for service mesh ingress controller features.</span></span>

<span data-ttu-id="458db-249">İlk mimari ve desenler açıklama bölümlerinden sonra, sonraki bölümlerde [Ocelot](https://github.com/ThreeMammals/Ocelot)ile API Ağ Geçitleri nasıl uygulanacağını açıklar.</span><span class="sxs-lookup"><span data-stu-id="458db-249">After the initial architecture and patterns explanation sections, the next sections explain how to implement API Gateways with [Ocelot](https://github.com/ThreeMammals/Ocelot).</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="458db-250">API Ağ Geçidi deseni sakıncaları</span><span class="sxs-lookup"><span data-stu-id="458db-250">Drawbacks of the API Gateway pattern</span></span>

- <span data-ttu-id="458db-251">En önemli dezavantajı, bir API Ağ Geçidi uyguladığınız zaman, bu katmanı dahili mikro hizmetlerle birarada tutabiliyor olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="458db-251">The most important drawback is that when you implement an API Gateway, you're coupling that tier with the internal microservices.</span></span> <span data-ttu-id="458db-252">Bu gibi kaplin uygulamanız için ciddi zorluklara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-252">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="458db-253">Azure Servis Veri Servisi ekibinin mimarı Clemens Vaster, goto 2016'daki "[Mesajlaşma ve MikroHizmetler](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" oturumunda bu olası zorluğu "yeni ESB" olarak tanımlıyor.</span><span class="sxs-lookup"><span data-stu-id="458db-253">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as "the new ESB" in the "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

- <span data-ttu-id="458db-254">Mikro hizmetler API Ağ Geçidi kullanmak, olası tek bir hata noktası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="458db-254">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

- <span data-ttu-id="458db-255">Bir API Ağ Geçidi, ek ağ çağrısı nedeniyle daha fazla yanıt süresi başlatabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-255">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="458db-256">Ancak, bu ekstra arama genellikle doğrudan dahili mikro hizmetleri arayan çok geveze bir istemci arabirimine sahip daha az etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="458db-256">However, this extra call usually has less impact than having a client interface that's too chatty directly calling the internal microservices.</span></span>

- <span data-ttu-id="458db-257">Düzgün ölçeklendirilemezse, API Ağ Geçidi bir darboğaza dönüşebilir.</span><span class="sxs-lookup"><span data-stu-id="458db-257">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

- <span data-ttu-id="458db-258">Bir API Ağ Geçidi, özel mantık ve veri toplama içeriyorsa ek geliştirme maliyeti ve gelecekteki bakım gerektirir.</span><span class="sxs-lookup"><span data-stu-id="458db-258">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="458db-259">Geliştiriciler, her mikro hizmetin uç noktalarını ortaya çıkarmak için API Ağ Geçidi'ni güncelleştirmelidir.</span><span class="sxs-lookup"><span data-stu-id="458db-259">Developers must update the API Gateway in order to expose each microservice's endpoints.</span></span> <span data-ttu-id="458db-260">Ayrıca, dahili mikro hizmetlerdeki uygulama değişiklikleri API Ağ Geçidi düzeyinde kod değişikliklerine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-260">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="458db-261">Ancak, API Ağ Geçidi yalnızca güvenlik, günlüğe kaydetme ve sürüm uygulaması (Azure API Yönetimi'ni kullanırken olduğu gibi) uyguluyorsa, bu ek geliştirme maliyeti geçerli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-261">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

- <span data-ttu-id="458db-262">API Ağ Geçidi tek bir ekip tarafından geliştirilirse, bir geliştirme darboğaz olabilir.</span><span class="sxs-lookup"><span data-stu-id="458db-262">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="458db-263">Bu, daha iyi bir yaklaşımın farklı istemci gereksinimlerine yanıt veren birkaç para cezası kesilen API Ağ Geçidine sahip olmasının başka bir nedenidir.</span><span class="sxs-lookup"><span data-stu-id="458db-263">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="458db-264">Ayrıca, API Ağ Geçidi'ni dahili olarak, dahili mikro hizmetler üzerinde çalışan farklı ekiplerin sahip olduğu birden çok alana veya katmana ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="458db-264">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="458db-265">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="458db-265">Additional resources</span></span>

- <span data-ttu-id="458db-266">**Chris Richardson' ı. Desen: API Ağ Geçidi / Ön Uç için Arka Uç** </span><span class="sxs-lookup"><span data-stu-id="458db-266">**Chris Richardson. Pattern: API Gateway / Backend for Front-End** </span></span>\
  <https://microservices.io/patterns/apigateway.html>

- <span data-ttu-id="458db-267">**API Ağ Geçidi deseni** </span><span class="sxs-lookup"><span data-stu-id="458db-267">**API Gateway pattern** </span></span>\
  <https://docs.microsoft.com/azure/architecture/microservices/gateway>

- <span data-ttu-id="458db-268">**Toplama ve kompozisyon deseni** </span><span class="sxs-lookup"><span data-stu-id="458db-268">**Aggregation and composition pattern** </span></span>\
  <https://microservices.io/patterns/data/api-composition.html>

- <span data-ttu-id="458db-269">**Azure API Yönetimi** </span><span class="sxs-lookup"><span data-stu-id="458db-269">**Azure API Management** </span></span>\
  <https://azure.microsoft.com/services/api-management/>

- <span data-ttu-id="458db-270">**Udi Dahan. Hizmet Odaklı Kompozisyon** </span><span class="sxs-lookup"><span data-stu-id="458db-270">**Udi Dahan. Service Oriented Composition** </span></span>\
  <http://udidahan.com/2014/07/30/service-oriented-composition-with-video/>

- <span data-ttu-id="458db-271">**Clemens Vasters' ı. GOTO 2016'da Mesajlaşma ve MikroHizmetler (video)** </span><span class="sxs-lookup"><span data-stu-id="458db-271">**Clemens Vasters. Messaging and Microservices at GOTO 2016 (video)** </span></span>\
  <https://www.youtube.com/watch?v=rXi5CLjIQ9k>

- <span data-ttu-id="458db-272">**Özetle API Ağ Geçidi** (Core API Ağ Geçidi Öğretici Serisi ASP.net) </span><span class="sxs-lookup"><span data-stu-id="458db-272">**API Gateway in a Nutshell** (ASP.net Core API Gateway Tutorial Series) </span></span>\
  <https://www.pogsdotnet.com/2018/08/api-gateway-in-nutshell.html>

>[!div class="step-by-step"]
><span data-ttu-id="458db-273">[Önceki](identify-microservice-domain-model-boundaries.md)
>[Sonraki](communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="458db-273">[Previous](identify-microservice-domain-model-boundaries.md)
[Next](communication-in-microservice-architecture.md)</span></span>
