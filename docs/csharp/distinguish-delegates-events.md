---
title: Temsilcileri ve Olayları Ayırt Etme
description: Temsilciler ve olaylar arasındaki farkı ve .NET Core'un bu özelliklerinin her birini ne zaman kullanacağınızı öğrenin.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: 4179330fe5e88da5d5034a150a057f63e31b178b
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588254"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="b7a82-103">Temsilcileri ve Olayları Ayırt Etme</span><span class="sxs-lookup"><span data-stu-id="b7a82-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="b7a82-104">Önceki</span><span class="sxs-lookup"><span data-stu-id="b7a82-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="b7a82-105">.NET Core platformuna yeni gelen geliştiriciler, bir tasarıma `delegates` dayalı ve temelli bir tasarım arasında karar verirken genellikle mücadele ederler. `events`</span><span class="sxs-lookup"><span data-stu-id="b7a82-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="b7a82-106">Bu zor bir kavramdır, çünkü iki dil özelliği çok benzerdir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="b7a82-107">Etkinlikler, temsilciler için dil desteği kullanılarak bile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b7a82-107">Events are even built using the language support for delegates.</span></span>

<span data-ttu-id="b7a82-108">Her ikisi de geç bağlama senaryosu sunar: bileşenin yalnızca çalışma zamanında bilinen bir yöntemi çağırarak iletişim kurduğu senaryoları etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="b7a82-109">Her ikisi de tek ve birden çok abone yöntemini destekler.</span><span class="sxs-lookup"><span data-stu-id="b7a82-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="b7a82-110">Bunu tek döküm ve çok noktaya yayın desteği olarak adlandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7a82-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="b7a82-111">Her ikisi de işleyicileri eklemek ve kaldırmak için benzer sözdizimini destekler.</span><span class="sxs-lookup"><span data-stu-id="b7a82-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="b7a82-112">Son olarak, bir olay yükselterek ve bir temsilci arama tam olarak aynı yöntem sözdizimi arayın kullanın.</span><span class="sxs-lookup"><span data-stu-id="b7a82-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="b7a82-113">Hatta her ikisi `Invoke()` de `?.` işleç ile kullanmak için aynı yöntem sözdizimini destekler.</span><span class="sxs-lookup"><span data-stu-id="b7a82-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="b7a82-114">Tüm bu benzerlikler ile, hangi kullanmak için ne zaman belirlemekte sorun olması kolaydır.</span><span class="sxs-lookup"><span data-stu-id="b7a82-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="b7a82-115">Olayları Dinlemek İsteğe Bağlıdır</span><span class="sxs-lookup"><span data-stu-id="b7a82-115">Listening to Events is Optional</span></span>

<span data-ttu-id="b7a82-116">Hangi dil özelliğinin kullanılacağını belirlemede en önemli husus, bağlı bir abonenin olup olmaması gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="b7a82-117">Kodunuz abone tarafından sağlanan kodu aramanız gerekiyorsa, temsilcilere dayalı bir tasarım kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="b7a82-118">Kodunuz tüm çalışmasını herhangi bir abone çağırmadan tamamlayabiliyorsa, olaylara dayalı bir tasarım kullanmalısınız.</span><span class="sxs-lookup"><span data-stu-id="b7a82-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span>

<span data-ttu-id="b7a82-119">Bu bölümde oluşturulmuş örnekleri göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="b7a82-119">Consider the examples built during this section.</span></span> <span data-ttu-id="b7a82-120">Öğeleri düzgün bir `List.Sort()` şekilde sıralamak için, kullanarak oluşturduğun koda bir karşılayıcı işlevi verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="b7a82-121">Hangi öğelerin döndürüleceğini belirlemek için LINQ sorguları temsilcilerle birlikte sağlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b7a82-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="b7a82-122">Her ikisi de delegelerle oluşturulmuş bir tasarım kullandı.</span><span class="sxs-lookup"><span data-stu-id="b7a82-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="b7a82-123">Olayı `Progress` göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="b7a82-123">Consider the `Progress` event.</span></span> <span data-ttu-id="b7a82-124">Bir görevde ilerleme yi tirenleri bildirir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-124">It reports progress on a task.</span></span>
<span data-ttu-id="b7a82-125">Herhangi bir dinleyici olup olmadığı görev devam ediyor.</span><span class="sxs-lookup"><span data-stu-id="b7a82-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="b7a82-126">Başka `FileSearcher` bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="b7a82-127">Yine de arama ve hiçbir olay aboneleri ekli bile, aranan tüm dosyaları bulmak.</span><span class="sxs-lookup"><span data-stu-id="b7a82-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="b7a82-128">Olayları dinleyen abone ler olmasa bile UX denetimleri hala doğru çalışır.</span><span class="sxs-lookup"><span data-stu-id="b7a82-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="b7a82-129">Her ikisi de olaylara dayalı tasarımlar kullanır.</span><span class="sxs-lookup"><span data-stu-id="b7a82-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="b7a82-130">İade Değerleri Temsilciler Gerektirir</span><span class="sxs-lookup"><span data-stu-id="b7a82-130">Return Values Require Delegates</span></span>

<span data-ttu-id="b7a82-131">Başka bir husus, temsilci yönteminiz için isteyeceğiniz yöntem prototipidir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="b7a82-132">Gördüğünüz gibi, olaylar için kullanılan temsilcilerin hepsinin geçersiz bir dönüş türü vardır.</span><span class="sxs-lookup"><span data-stu-id="b7a82-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="b7a82-133">Ayrıca, olay bağımsız değişken nesnesinin özelliklerini değiştirerek bilgileri olay kaynaklarına geri aktaran olay işleyicileri oluşturmak için deyimler olduğunu da gördünüz.</span><span class="sxs-lookup"><span data-stu-id="b7a82-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="b7a82-134">Bu deyimler işe yarasa da, bir yöntemden değer döndürmek kadar doğal değildir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="b7a82-135">Bu iki buluşçistin her ikisinin de genellikle mevcut olabileceğine dikkat edin: Temsilci yönteminiz bir değer döndürürse, algoritmayı bir şekilde etkileme olasılığı yüksektir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="events-have-private-invocation"></a><span data-ttu-id="b7a82-136">Etkinlikler Özel Çağrı var</span><span class="sxs-lookup"><span data-stu-id="b7a82-136">Events Have Private Invocation</span></span>

<span data-ttu-id="b7a82-137">Bir olayın bulunduğu sınıf dışındaki sınıflar yalnızca olay dinleyicileri ekleyebilir ve kaldırabilir; yalnızca olayı içeren sınıf olayı çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-137">Classes other than the one in which an event is contained can only add and remove event listeners; only the class containing the event can invoke the event.</span></span> <span data-ttu-id="b7a82-138">Olaylar genellikle ortak sınıf üyeleridir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-138">Events are typically public class members.</span></span>
<span data-ttu-id="b7a82-139">Buna karşılık, temsilciler genellikle parametre olarak geçirilir ve hiç depolanırsa özel sınıf üyesi olarak depolanır.</span><span class="sxs-lookup"><span data-stu-id="b7a82-139">By comparison, delegates are often passed as parameters and stored as private class members, if they are stored at all.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="b7a82-140">Etkinlik Dinleyicilerinin Genellikle Daha Uzun Ömürleri Var</span><span class="sxs-lookup"><span data-stu-id="b7a82-140">Event Listeners Often Have Longer Lifetimes</span></span>

<span data-ttu-id="b7a82-141">Bu biraz daha zayıf bir gerekçedir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-141">This is a slightly weaker justification.</span></span> <span data-ttu-id="b7a82-142">Ancak, olay kaynağı uzun bir süre boyunca olayları yükseltecek zaman olay tabanlı tasarımlar daha doğal olduğunu görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7a82-142">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="b7a82-143">Birçok sistemde UX denetimleri için bunun örneklerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7a82-143">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="b7a82-144">Bir etkinliğe abone olduktan sonra, etkinlik kaynağı programın ömrü boyunca olayları yükseltebilir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-144">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="b7a82-145">(Artık ihtiyacınız olmadığında etkinliklerden aboneliğinizi kaldırabilirsiniz.)</span><span class="sxs-lookup"><span data-stu-id="b7a82-145">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="b7a82-146">Bir temsilcinin bir yönteme bağımsız değişken olarak kullanıldığı ve bu yöntem döndürüldikten sonra temsilcinin kullanılmadığı birçok temsilci tabanlı tasarımla karşılamayın.</span><span class="sxs-lookup"><span data-stu-id="b7a82-146">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="b7a82-147">Dikkatle Değerlendirin</span><span class="sxs-lookup"><span data-stu-id="b7a82-147">Evaluate Carefully</span></span>

<span data-ttu-id="b7a82-148">Yukarıdaki hususlar sert ve hızlı kurallar değildir.</span><span class="sxs-lookup"><span data-stu-id="b7a82-148">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="b7a82-149">Bunun yerine, belirli kullanımınız için hangi seçeneğin en iyi olduğuna karar vermenize yardımcı olabilecek bir kılavuztemsil ederler.</span><span class="sxs-lookup"><span data-stu-id="b7a82-149">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="b7a82-150">Benzer oldukları için, hatta her ikisini de prototip ve çalışmak için daha doğal olacağını düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b7a82-150">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="b7a82-151">Her ikisi de geç bağlama senaryoları iyi ele.</span><span class="sxs-lookup"><span data-stu-id="b7a82-151">They both handle late binding scenarios well.</span></span> <span data-ttu-id="b7a82-152">Tasarımınızı en iyi şekilde ileten tasarımıkullanın.</span><span class="sxs-lookup"><span data-stu-id="b7a82-152">Use the one that communicates your design the best.</span></span>
