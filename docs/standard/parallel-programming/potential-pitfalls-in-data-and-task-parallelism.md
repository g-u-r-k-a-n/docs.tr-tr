---
title: Veri ve Görev Paralelliğinde Olası Tuzaklar
description: Paralellik, sıralı kodda karşılaşılmayan karmaşıklık eklediğinden, veri ve görev paralelliği hakkında potansiyel bir bilgi edinin.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallel programming, pitfalls
ms.assetid: 1e357177-e699-4b8f-9e49-56d3513ed128
ms.openlocfilehash: 05d934b80e60a8630db5b70e16a07c014598487a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84599769"
---
# <a name="potential-pitfalls-in-data-and-task-parallelism"></a><span data-ttu-id="4c318-103">Veri ve Görev Paralelliğinde Olası Tuzaklar</span><span class="sxs-lookup"><span data-stu-id="4c318-103">Potential Pitfalls in Data and Task Parallelism</span></span>
<span data-ttu-id="4c318-104">Birçok durumda, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> normal sıralı döngüler üzerinde önemli performans iyileştirmeleri sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-104">In many cases, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> can provide significant performance improvements over ordinary sequential loops.</span></span> <span data-ttu-id="4c318-105">Ancak, döngüyü paralelleştirme işi, ardışık kodda yaygın olmayan veya hiç karşılaşılmayan sorunlara yol açabilecek karmaşıklığa neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-105">However, the work of parallelizing the loop introduces complexity that can lead to problems that, in sequential code, are not as common or are not encountered at all.</span></span> <span data-ttu-id="4c318-106">Bu konuda, paralel döngüler yazarken kaçınılacak bazı yöntemler listelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="4c318-106">This topic lists some practices to avoid when you write parallel loops.</span></span>  
  
## <a name="do-not-assume-that-parallel-is-always-faster"></a><span data-ttu-id="4c318-107">Parallel öğesinin her zaman daha hızlı olduğunu varsaymayın</span><span class="sxs-lookup"><span data-stu-id="4c318-107">Do Not Assume That Parallel Is Always Faster</span></span>  
 <span data-ttu-id="4c318-108">Bazı durumlarda, paralel bir döngü sıralı eşinden daha yavaş çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-108">In certain cases a parallel loop might run slower than its sequential equivalent.</span></span> <span data-ttu-id="4c318-109">Thumb 'in temel kuralı, birkaç yineleme ve Hızlı Kullanıcı temsilcileri olan paralel döngülerin çok daha hızlı bir şekilde hızlandırlanmasının düşüktür.</span><span class="sxs-lookup"><span data-stu-id="4c318-109">The basic rule of thumb is that parallel loops that have few iterations and fast user delegates are unlikely to speedup much.</span></span> <span data-ttu-id="4c318-110">Ancak, birçok etken performansa dahil edildiğinden, gerçek sonuçları her zaman ölçmenizi öneririz.</span><span class="sxs-lookup"><span data-stu-id="4c318-110">However, because many factors are involved in performance, we recommend that you always measure actual results.</span></span>  
  
## <a name="avoid-writing-to-shared-memory-locations"></a><span data-ttu-id="4c318-111">Paylaşılan bellek konumlarına yazmayı önleyin</span><span class="sxs-lookup"><span data-stu-id="4c318-111">Avoid Writing to Shared Memory Locations</span></span>  
 <span data-ttu-id="4c318-112">Ardışık kodda, statik değişkenlerle veya sınıf alanlarından okumak veya yazmak yaygın olmayan bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="4c318-112">In sequential code, it is not uncommon to read from or write to static variables or class fields.</span></span> <span data-ttu-id="4c318-113">Ancak, birden çok iş parçacığı bu tür değişkenlere eşzamanlı olarak eriştiği zaman, yarış koşullarında büyük bir olasılık vardır.</span><span class="sxs-lookup"><span data-stu-id="4c318-113">However, whenever multiple threads are accessing such variables concurrently, there is a big potential for race conditions.</span></span> <span data-ttu-id="4c318-114">Erişimi değişkene eşitlemek için kilitleri da kullanabilirsiniz, ancak eşitleme maliyeti performansı zarar verebilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-114">Even though you can use locks to synchronize access to the variable, the cost of synchronization can hurt performance.</span></span> <span data-ttu-id="4c318-115">Bu nedenle, en az bir paralel döngüde mümkün olduğunca, paylaşılan duruma erişimi önlemenize veya en azından sınırlamanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="4c318-115">Therefore, we recommend that you avoid, or at least limit, access to shared state in a parallel loop as much as possible.</span></span> <span data-ttu-id="4c318-116">Bunu yapmanın en iyi yolu, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> döngü yürütme sırasında iş parçacığı yerel durumunu depolamak için bir değişken kullanan ve öğesinin aşırı yüklerini kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="4c318-116">The best way to do this is to use the overloads of <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> that use a <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> variable to store thread-local state during loop execution.</span></span> <span data-ttu-id="4c318-117">Daha fazla bilgi için bkz. [nasıl yapılır: Iş parçacığı yerel değişkenleriyle paralel. for döngüsü yazma](how-to-write-a-parallel-for-loop-with-thread-local-variables.md) ve [nasıl yapılır: Bölüm Yerel Değişkenleriyle bir Parallel. foreach döngüsü yazma](how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="4c318-117">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="avoid-over-parallelization"></a><span data-ttu-id="4c318-118">Fazla paralelleştirme kullanmaktan kaçının</span><span class="sxs-lookup"><span data-stu-id="4c318-118">Avoid Over-Parallelization</span></span>  
 <span data-ttu-id="4c318-119">Paralel döngüleri kullanarak, kaynak koleksiyonun bölümlenmesi ve çalışan iş parçacıklarını eşitlemek için ek ücret maliyetlerine tabi olursunuz.</span><span class="sxs-lookup"><span data-stu-id="4c318-119">By using parallel loops, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads.</span></span> <span data-ttu-id="4c318-120">Paralelleştirme avantajları, bilgisayardaki işlemci sayısıyla daha fazla sınırlandırılır.</span><span class="sxs-lookup"><span data-stu-id="4c318-120">The benefits of parallelization are further limited by the number of processors on the computer.</span></span> <span data-ttu-id="4c318-121">Yalnızca bir işlemcide birden çok işlem ile sınırlı iş parçacığı çalıştırılarak kazanılabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-121">There is no speedup to be gained by running multiple compute-bound threads on just one processor.</span></span> <span data-ttu-id="4c318-122">Bu nedenle, paralel hale getirmek bir döngüye atmamaya dikkat etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="4c318-122">Therefore, you must be careful not to over-parallelize a loop.</span></span>  
  
 <span data-ttu-id="4c318-123">Fazla paralelleştirme gerçekleşebileceği en yaygın senaryo iç içe döngüdedir.</span><span class="sxs-lookup"><span data-stu-id="4c318-123">The most common scenario in which over-parallelization can occur is in nested loops.</span></span> <span data-ttu-id="4c318-124">Çoğu durumda, aşağıdaki koşullardan biri veya daha fazlası geçerli değilse yalnızca dış döngüyü paralel hale getirmek en iyi seçenektir:</span><span class="sxs-lookup"><span data-stu-id="4c318-124">In most cases, it is best to parallelize only the outer loop unless one or more of the following conditions apply:</span></span>  
  
- <span data-ttu-id="4c318-125">İç döngünün çok uzun olduğu bilinmektedir.</span><span class="sxs-lookup"><span data-stu-id="4c318-125">The inner loop is known to be very long.</span></span>  
  
- <span data-ttu-id="4c318-126">Her sırada pahalı bir hesaplama gerçekleştirçalışıyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="4c318-126">You are performing an expensive computation on each order.</span></span> <span data-ttu-id="4c318-127">(Örnekte gösterilen işlem pahalı değildir.)</span><span class="sxs-lookup"><span data-stu-id="4c318-127">(The operation shown in the example is not expensive.)</span></span>  
  
- <span data-ttu-id="4c318-128">Hedef sistemde, üzerinde sorgu paralelleştirerek üretilecek iş parçacığı sayısını işlemek için yeterli işlemci olduğu bilinmektedir `cust.Orders` .</span><span class="sxs-lookup"><span data-stu-id="4c318-128">The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on `cust.Orders`.</span></span>  
  
 <span data-ttu-id="4c318-129">Her durumda, en uygun sorgu şeklinin belirlenmesi için en iyi yol test ve ölçüdür.</span><span class="sxs-lookup"><span data-stu-id="4c318-129">In all cases, the best way to determine the optimum query shape is to test and measure.</span></span>  
  
## <a name="avoid-calls-to-non-thread-safe-methods"></a><span data-ttu-id="4c318-130">Iş parçacığı olmayan güvenli yöntemlere yapılan çağrılardan kaçının</span><span class="sxs-lookup"><span data-stu-id="4c318-130">Avoid Calls to Non-Thread-Safe Methods</span></span>  
 <span data-ttu-id="4c318-131">İş parçacığı açısından güvenli olmayan örnek yöntemlerine paralel bir döngüden yazmak, programınızda algılanamayan veya algılanamayan veri bozulmasına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-131">Writing to non-thread-safe instance methods from a parallel loop can lead to data corruption which may or may not go undetected in your program.</span></span> <span data-ttu-id="4c318-132">Ayrıca özel durumlara da yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-132">It can also lead to exceptions.</span></span> <span data-ttu-id="4c318-133">Aşağıdaki örnekte, birden çok iş parçacığı <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType> yöntemi aynı anda çağırmaya çalışıyor ve bu sınıf tarafından desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="4c318-133">In the following example, multiple threads would be attempting to call the <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType> method simultaneously, which is not supported by the class.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#04)]
 [!code-vb[TPL_Pitfalls#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#04)]  
  
## <a name="limit-calls-to-thread-safe-methods"></a><span data-ttu-id="4c318-134">Iş parçacığı güvenli yöntemleriyle yapılan çağrıları sınırlayın</span><span class="sxs-lookup"><span data-stu-id="4c318-134">Limit Calls to Thread-Safe Methods</span></span>  
 <span data-ttu-id="4c318-135">.NET Framework çoğu statik yöntem iş parçacığı açısından güvenlidir ve aynı anda birden çok iş parçacığından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-135">Most static methods in the .NET Framework are thread-safe and can be called from multiple threads concurrently.</span></span> <span data-ttu-id="4c318-136">Ancak, bu durumlarda bile ilgili eşitleme, sorgudaki önemli yavaşlama oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-136">However, even in these cases, the synchronization involved can lead to significant slowdown in the query.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4c318-137">Sorgularınıza bazı çağrılar ekleyerek bunu kendiniz test edebilirsiniz <xref:System.Console.WriteLine%2A> .</span><span class="sxs-lookup"><span data-stu-id="4c318-137">You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries.</span></span> <span data-ttu-id="4c318-138">Bu yöntem, Gösterim amacıyla belge örneklerinde kullanılmasına karşın, gerekli olmadığı takdirde bunu paralel Döngülerde kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="4c318-138">Although this method is used in the documentation examples for demonstration purposes, do not use it in parallel loops unless necessary.</span></span>  
  
## <a name="be-aware-of-thread-affinity-issues"></a><span data-ttu-id="4c318-139">Iş parçacığı benzeşim sorunlarından haberdar olun</span><span class="sxs-lookup"><span data-stu-id="4c318-139">Be Aware of Thread Affinity Issues</span></span>  
 <span data-ttu-id="4c318-140">Tek iş parçacıklı Apartment (STA) bileşenleri, Windows Forms ve Windows Presentation Foundation (WPF) için COM birlikte çalışabilirlik gibi bazı teknolojiler, kodun belirli bir iş parçacığında çalıştırılmasını gerektiren iş parçacığı benzeşim kısıtlamalarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="4c318-140">Some technologies, for example, COM interoperability for Single-Threaded Apartment (STA) components, Windows Forms, and Windows Presentation Foundation (WPF), impose thread affinity restrictions that require code to run on a specific thread.</span></span> <span data-ttu-id="4c318-141">Örneğin, hem Windows Forms hem de WPF 'de, bir denetime yalnızca oluşturulduğu iş parçacığında erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-141">For example, in both Windows Forms and WPF, a control can only be accessed on the thread on which it was created.</span></span> <span data-ttu-id="4c318-142">Bu, örneğin, iş parçacığı Zamanlayıcı 'yı yalnızca kullanıcı arabirimi iş parçacığında çalışacak şekilde yapılandırmadığınız takdirde bir liste denetimini paralel bir döngüden güncelleştiremeyeceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4c318-142">This means, for example, that you cannot update a list control from a parallel loop unless you configure the thread scheduler to schedule work only on the UI thread.</span></span> <span data-ttu-id="4c318-143">Daha fazla bilgi için bkz. [bir eşitleme bağlamı belirtme](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span><span class="sxs-lookup"><span data-stu-id="4c318-143">For more information, see [Specifying a synchronization context](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span></span>  
  
## <a name="use-caution-when-waiting-in-delegates-that-are-called-by-parallelinvoke"></a><span data-ttu-id="4c318-144">Parallel. Invoke tarafından çağrılan Temsilcilerde beklerken dikkatli olun</span><span class="sxs-lookup"><span data-stu-id="4c318-144">Use Caution When Waiting in Delegates That Are Called by Parallel.Invoke</span></span>  
 <span data-ttu-id="4c318-145">Bazı durumlarda, görev paralel kitaplığı bir görevi satır içine alacak ve bu, yürütülmekte olan iş parçacığında görev üzerinde çalıştığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4c318-145">In certain circumstances, the Task Parallel Library will inline a task, which means it runs on the task on the currently executing thread.</span></span> <span data-ttu-id="4c318-146">(Daha fazla bilgi için bkz. [Task zamanlayıcılar](xref:System.Threading.Tasks.TaskScheduler).) Bu performans iyileştirmesi belirli durumlarda kilitlenmeye neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-146">(For more information, see [Task Schedulers](xref:System.Threading.Tasks.TaskScheduler).) This performance optimization can lead to deadlock in certain cases.</span></span> <span data-ttu-id="4c318-147">Örneğin, iki görev aynı temsilci kodunu çalıştırabilir, bu da bir olay meydana geldiğinde bildirir ve ardından diğer görevin sinyal gelmesini bekler.</span><span class="sxs-lookup"><span data-stu-id="4c318-147">For example, two tasks might run the same delegate code, which signals when an event occurs, and then waits for the other task to signal.</span></span> <span data-ttu-id="4c318-148">İkinci görev ilk olarak aynı iş parçacığında satır içine alınır ve ilki bekleme durumuna geçtiğinde ikinci görev hiçbir şekilde olayını işaret edemeyecektir.</span><span class="sxs-lookup"><span data-stu-id="4c318-148">If the second task is inlined on the same thread as the first, and the first goes into a Wait state, the second task will never be able to signal its event.</span></span> <span data-ttu-id="4c318-149">Böyle bir oluşumu önlemek için, bekleme işleminde bir zaman aşımı belirtebilir veya bir görevin diğerini engelleyemez emin olmak için açık iş parçacığı oluşturucuları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4c318-149">To avoid such an occurrence, you can specify a timeout on the Wait operation, or use explicit thread constructors to help ensure that one task cannot block the other.</span></span>  
  
## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a><span data-ttu-id="4c318-150">ForEach, for ve ForAll yinelemelerinin her zaman paralel olarak yürütüleceğini varsayın</span><span class="sxs-lookup"><span data-stu-id="4c318-150">Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel</span></span>  
 <span data-ttu-id="4c318-151">Bir veya döngüsünde tek tek yinelemelerin <xref:System.Threading.Tasks.Parallel.For%2A> <xref:System.Threading.Tasks.Parallel.ForEach%2A> paralel olarak yürütülmesi gerektiğini göz önünde bulundurmanız önemlidir <xref:System.Linq.ParallelEnumerable.ForAll%2A> .</span><span class="sxs-lookup"><span data-stu-id="4c318-151">It is important to keep in mind that individual iterations in a <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> or <xref:System.Linq.ParallelEnumerable.ForAll%2A> loop may but do not have to execute in parallel.</span></span> <span data-ttu-id="4c318-152">Bu nedenle, tekrarların paralel olarak yürütülmesi veya yinelemeler üzerinde herhangi bir sıraya göre yürütülmesi açısından doğruluğu için herhangi bir kod yazmadan kaçınmalısınız.</span><span class="sxs-lookup"><span data-stu-id="4c318-152">Therefore, you should avoid writing any code that depends for correctness on parallel execution of iterations or on the execution of iterations in any particular order.</span></span> <span data-ttu-id="4c318-153">Örneğin, bu kodun kilitlenmesi olasıdır:</span><span class="sxs-lookup"><span data-stu-id="4c318-153">For example, this code is likely to deadlock:</span></span>  
  
 [!code-csharp[TPL_Pitfalls#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#01)]
 [!code-vb[TPL_Pitfalls#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#01)]  
  
 <span data-ttu-id="4c318-154">Bu örnekte, bir yineleme bir olay ayarlıyor ve diğer tüm yinelemeler olayda bekler.</span><span class="sxs-lookup"><span data-stu-id="4c318-154">In this example, one iteration sets an event, and all other iterations wait on the event.</span></span> <span data-ttu-id="4c318-155">Olay ayarı yinelemesi tamamlanana kadar bekleyen yinelemeden hiçbiri tamamlanamaz.</span><span class="sxs-lookup"><span data-stu-id="4c318-155">None of the waiting iterations can complete until the event-setting iteration has completed.</span></span> <span data-ttu-id="4c318-156">Ancak, bekleyen yinelemeler, olay ayarı yinelemesi yürütme şansı vermeden önce paralel döngüyü yürütmek için kullanılan tüm iş parçacıklarını engelliyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-156">However, it is possible that the waiting iterations block all threads that are used to execute the parallel loop, before the event-setting iteration has had a chance to execute.</span></span> <span data-ttu-id="4c318-157">Bu, bir kilitlenme ile sonuçlanır: olay ayarı yinelemesi hiçbir şekilde yürütülmez ve bekleyen yinelemeler hiçbir şekilde çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="4c318-157">This results in a deadlock – the event-setting iteration will never execute, and the waiting iterations will never wake up.</span></span>  
  
 <span data-ttu-id="4c318-158">Özellikle, bir paralel döngünün bir yinelemesi, ilerleme yapmak için döngünün başka bir yinelemesinin asla beklemelidir.</span><span class="sxs-lookup"><span data-stu-id="4c318-158">In particular, one iteration of a parallel loop should never wait on another iteration of the loop to make progress.</span></span> <span data-ttu-id="4c318-159">Paralel döngü, yinelemeleri sırayla zamanlamaya karar verirse, ters sırada bir kilitlenme meydana gelir.</span><span class="sxs-lookup"><span data-stu-id="4c318-159">If the parallel loop decides to schedule the iterations sequentially but in the opposite order, a deadlock will occur.</span></span>  
  
## <a name="avoid-executing-parallel-loops-on-the-ui-thread"></a><span data-ttu-id="4c318-160">UI Iş parçacığında paralel döngüler yürütmeden kaçının</span><span class="sxs-lookup"><span data-stu-id="4c318-160">Avoid Executing Parallel Loops on the UI Thread</span></span>  
 <span data-ttu-id="4c318-161">Uygulamanızın Kullanıcı arabirimi (UI) yanıt vermesini sağlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="4c318-161">It is important to keep your application's user interface (UI) responsive.</span></span> <span data-ttu-id="4c318-162">Bir işlem paralelleştirme sağlamak için yeterli iş içeriyorsa, büyük olasılıkla bu işlemi UI iş parçacığında çalıştırmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="4c318-162">If an operation contains enough work to warrant parallelization, then it likely should not be run that operation on the UI thread.</span></span>  <span data-ttu-id="4c318-163">Bunun yerine, bir arka plan iş parçacığında çalıştırılacak işlemin boşaltması gerekir.</span><span class="sxs-lookup"><span data-stu-id="4c318-163">Instead, it should offload that operation to be run on a background thread.</span></span> <span data-ttu-id="4c318-164">Örneğin, bir UI denetiminde işlenmesi gereken bazı verileri hesaplamak için bir paralel döngü kullanmak istiyorsanız, döngüyü doğrudan bir UI olay işleyicide değil, bir görev örneği içinde yürütmeyi düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="4c318-164">For example, if you want to use a parallel loop to compute some data that should then be rendered into a UI control, you should consider executing the loop within a task instance rather than directly in a UI event handler.</span></span>  <span data-ttu-id="4c318-165">Yalnızca çekirdek Hesaplama tamamlandığında, UI güncelleştirmesini UI iş parçacığına geri sıralayamaz.</span><span class="sxs-lookup"><span data-stu-id="4c318-165">Only when the core computation has completed should you then marshal the UI update back to the UI thread.</span></span>  
  
 <span data-ttu-id="4c318-166">UI iş parçacığında paralel döngüler çalıştırırsanız, Kullanıcı arabirimi denetimlerini döngünün içinden güncelleştirmemeye özen gösterin.</span><span class="sxs-lookup"><span data-stu-id="4c318-166">If you do run parallel loops on the UI thread, be careful to avoid updating UI controls from within the loop.</span></span> <span data-ttu-id="4c318-167">UI denetimlerinin Kullanıcı arabirimi iş parçacığında yürütülen paralel bir döngüden güncelleştirilmesi girişimi, Kullanıcı arabirimi güncelleştirmesinin nasıl çağrıldığına bağlı olarak durum bozulması, özel durumlar, Gecikmeli güncelleştirmeler ve hatta kilitlenmeler oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-167">Attempting to update UI controls from within a parallel loop that is executing on the UI thread can lead to state corruption, exceptions, delayed updates, and even deadlocks, depending on how the UI update is invoked.</span></span> <span data-ttu-id="4c318-168">Aşağıdaki örnekte, paralel döngü tüm yinelemeler tamamlanana kadar yürütüldüğü Kullanıcı arabirimi iş parçacığını engeller.</span><span class="sxs-lookup"><span data-stu-id="4c318-168">In the following example, the parallel loop blocks the UI thread on which it’s executing until all iterations are complete.</span></span> <span data-ttu-id="4c318-169">Ancak, döngü yinelemesi bir arka plan iş parçacığında çalışıyorsa (gibi <xref:System.Threading.Tasks.Parallel.For%2A> ), Invoke çağrısı, Kullanıcı arabirimi iş parçacığına ve bu iletinin işlenmesini bekleyen bloklara bir ileti gönderilmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="4c318-169">However, if an iteration of the loop is running on a background thread (as <xref:System.Threading.Tasks.Parallel.For%2A> may do), the call to Invoke causes a message to be submitted to the UI thread and blocks waiting for that message to be processed.</span></span> <span data-ttu-id="4c318-170">Kullanıcı arabirimi iş parçacığı çalıştıran bir şekilde çalıştığından, <xref:System.Threading.Tasks.Parallel.For%2A> ileti hiçbir şekilde işlenmez ve UI iş parçacığı kilitlenmeleri.</span><span class="sxs-lookup"><span data-stu-id="4c318-170">Since the UI thread is blocked running the <xref:System.Threading.Tasks.Parallel.For%2A>, the message can never be processed, and the UI thread deadlocks.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#02)]
 [!code-vb[TPL_Pitfalls#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#02)]  
  
 <span data-ttu-id="4c318-171">Aşağıdaki örnek, bir görev örneği içinde döngüyü çalıştırarak kilitlenmenin nasıl önleneceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="4c318-171">The following example shows how to avoid the deadlock, by running the loop inside a task instance.</span></span> <span data-ttu-id="4c318-172">UI iş parçacığı döngü tarafından engellenmemiştir ve ileti işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="4c318-172">The UI thread is not blocked by the loop, and the message can be processed.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#03)]
 [!code-vb[TPL_Pitfalls#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#03)]  
  
## <a name="see-also"></a><span data-ttu-id="4c318-173">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="4c318-173">See also</span></span>

- [<span data-ttu-id="4c318-174">Paralel programlama</span><span class="sxs-lookup"><span data-stu-id="4c318-174">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="4c318-175">PLINQ'te Olası Tuzaklar</span><span class="sxs-lookup"><span data-stu-id="4c318-175">Potential Pitfalls with PLINQ</span></span>](potential-pitfalls-with-plinq.md)
- [<span data-ttu-id="4c318-176">Paralel programlama için desenler: .NET Framework 4 ile paralel desenleri anlama ve uygulama</span><span class="sxs-lookup"><span data-stu-id="4c318-176">Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4</span></span>](https://www.microsoft.com/download/details.aspx?id=19222)
