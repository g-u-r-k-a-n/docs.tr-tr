---
title: Zaman uyumsuz dosya erişimi (C#)
description: Zaman uyumsuz özelliğini C# ' deki dosyalara erişmek için nasıl kullanacağınızı öğrenin. Geri çağırmaları kullanmadan veya kodlarınızı Yöntemler arasında bölmeden zaman uyumsuz yöntemlere çağrı yapabilirsiniz.
ms.date: 08/19/2020
ms.assetid: bb018fea-5313-4c80-ab3f-7c24b2145bd9
ms.openlocfilehash: 9a8db6004e8fff2cb39f0c350b403b56ea619e54
ms.sourcegitcommit: 9c45035b781caebc63ec8ecf912dc83fb6723b1f
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/25/2020
ms.locfileid: "88812048"
---
# <a name="asynchronous-file-access-c"></a><span data-ttu-id="fe813-104">Zaman uyumsuz dosya erişimi (C#)</span><span class="sxs-lookup"><span data-stu-id="fe813-104">Asynchronous file access (C#)</span></span>

<span data-ttu-id="fe813-105">Dosyalara erişmek için zaman uyumsuz özelliği kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe813-105">You can use the async feature to access files.</span></span> <span data-ttu-id="fe813-106">Async özelliğini kullanarak, geri çağırmaları kullanmadan veya kodunuzu birden çok yöntemde veya Lambda ifadelerinde bölmeden zaman uyumsuz yöntemlere çağrı yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe813-106">By using the async feature, you can call into asynchronous methods without using callbacks or splitting your code across multiple methods or lambda expressions.</span></span> <span data-ttu-id="fe813-107">Zaman uyumlu kodu zaman uyumsuz yapmak için, zaman uyumlu bir yöntem yerine zaman uyumsuz bir yöntem çağırır ve koda birkaç anahtar sözcük eklemeniz yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="fe813-107">To make synchronous code asynchronous, you just call an asynchronous method instead of a synchronous method and add a few keywords to the code.</span></span>

<span data-ttu-id="fe813-108">Dosya erişim çağrılarına zaman uyumsuzluğu eklemek için aşağıdaki nedenleri göz önünde bulundurmanız gerekebilir:</span><span class="sxs-lookup"><span data-stu-id="fe813-108">You might consider the following reasons for adding asynchrony to file access calls:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="fe813-109">İşlemi başlatan kullanıcı arabirimi iş parçacığı başka bir iş gerçekleştirebildiğinden, asynchrony UI uygulamalarını daha hızlı hale getirir.</span><span class="sxs-lookup"><span data-stu-id="fe813-109">Asynchrony makes UI applications more responsive because the UI thread that launches the operation can perform other work.</span></span> <span data-ttu-id="fe813-110">UI iş parçacığının uzun zaman alan kodu yürütmesi gerekiyorsa (örneğin, 50 milisaniyeden fazla), g/ç tamamlanana kadar UI dondurabilir ve Kullanıcı arabirimi iş parçacığı klavye ve fare girişini ve diğer olayları yeniden işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="fe813-110">If the UI thread must execute code that takes a long time (for example, more than 50 milliseconds), the UI may freeze until the I/O is complete and the UI thread can again process keyboard and mouse input and other events.</span></span>
> - <span data-ttu-id="fe813-111">Asynchrony, iş parçacıkları gereksinimini azaltarak ASP.NET ve diğer sunucu tabanlı uygulamaların ölçeklenebilirliğini geliştirir.</span><span class="sxs-lookup"><span data-stu-id="fe813-111">Asynchrony improves the scalability of ASP.NET and other server-based applications by reducing the need for threads.</span></span> <span data-ttu-id="fe813-112">Uygulama yanıt başına adanmış bir iş parçacığı kullanıyorsa ve bin istek aynı anda işleneiyorsa, bin iş parçacığı gerekir.</span><span class="sxs-lookup"><span data-stu-id="fe813-112">If the application uses a dedicated thread per response and a thousand requests are being handled simultaneously, a thousand threads are needed.</span></span> <span data-ttu-id="fe813-113">Zaman uyumsuz işlemlerin genellikle bekleme sırasında bir iş parçacığı kullanması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="fe813-113">Asynchronous operations often don't need to use a thread during the wait.</span></span> <span data-ttu-id="fe813-114">Mevcut g/ç Tamamlama iş parçacığını kısa bir süre içinde kullanırlar.</span><span class="sxs-lookup"><span data-stu-id="fe813-114">They use the existing I/O completion thread briefly at the end.</span></span>
> - <span data-ttu-id="fe813-115">Bir dosya erişim işleminin gecikmesi geçerli koşullar altında çok düşük olabilir, ancak gecikme gelecekte büyük ölçüde artabilir.</span><span class="sxs-lookup"><span data-stu-id="fe813-115">The latency of a file access operation might be very low under current conditions, but the latency may greatly increase in the future.</span></span> <span data-ttu-id="fe813-116">Örneğin, bir dosya dünya genelinde bir sunucuya taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="fe813-116">For example, a file may be moved to a server that's across the world.</span></span>
> - <span data-ttu-id="fe813-117">Zaman uyumsuz özelliği kullanmanın ek yükü küçüktür.</span><span class="sxs-lookup"><span data-stu-id="fe813-117">The added overhead of using the Async feature is small.</span></span>
> - <span data-ttu-id="fe813-118">Zaman uyumsuz görevler, paralel olarak kolayca çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="fe813-118">Asynchronous tasks can easily be run in parallel.</span></span>

## <a name="use-appropriate-classes"></a><span data-ttu-id="fe813-119">Uygun sınıfları kullan</span><span class="sxs-lookup"><span data-stu-id="fe813-119">Use appropriate classes</span></span>

<span data-ttu-id="fe813-120">Bu konudaki basit örnekler <xref:System.IO.File.WriteAllTextAsync%2A?displayProperty=nameWithType> ve gösterir <xref:System.IO.File.ReadAllTextAsync%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="fe813-120">The simple examples in this topic demonstrate <xref:System.IO.File.WriteAllTextAsync%2A?displayProperty=nameWithType> and <xref:System.IO.File.ReadAllTextAsync%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="fe813-121">Dosya g/ç işlemleri üzerinde sınırlı denetim için, <xref:System.IO.FileStream> işletim sistemi düzeyinde zaman uyumsuz g/ç 'nin oluşmasına neden olan bir seçeneğe sahip sınıfını kullanın.</span><span class="sxs-lookup"><span data-stu-id="fe813-121">For finite control over the file I/O operations, use the <xref:System.IO.FileStream> class, which has an option that causes asynchronous I/O to occur at the operating system level.</span></span> <span data-ttu-id="fe813-122">Bu seçeneği kullanarak, birçok durumda bir iş parçacığı havuzu iş parçacığını engellemeyi önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe813-122">By using this option, you can avoid blocking a thread pool thread in many cases.</span></span> <span data-ttu-id="fe813-123">Bu seçeneği etkinleştirmek için, `useAsync=true` `options=FileOptions.Asynchronous` Oluşturucu çağrısında veya bağımsız değişkenini belirtirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe813-123">To enable this option, you specify the `useAsync=true` or `options=FileOptions.Asynchronous` argument in the constructor call.</span></span>

<span data-ttu-id="fe813-124">Bu seçeneği, <xref:System.IO.StreamReader> ve <xref:System.IO.StreamWriter> doğrudan bir dosya yolu belirterek açarsanız kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe813-124">You can't use this option with <xref:System.IO.StreamReader> and <xref:System.IO.StreamWriter> if you open them directly by specifying a file path.</span></span> <span data-ttu-id="fe813-125">Ancak, bu seçeneği, <xref:System.IO.Stream> sınıfının açık olduğunu bir şekilde sağlarsanız kullanabilirsiniz <xref:System.IO.FileStream> .</span><span class="sxs-lookup"><span data-stu-id="fe813-125">However, you can use this option if you provide them a <xref:System.IO.Stream> that the <xref:System.IO.FileStream> class opened.</span></span> <span data-ttu-id="fe813-126">Zaman uyumsuz çağrılar, kullanıcı ARABIRIMI iş parçacığı bekleme sırasında engellenmediği için, bir iş parçacığı havuzu iş parçacığı engellense bile UI uygulamalarında daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="fe813-126">Asynchronous calls are faster in UI apps even if a thread pool thread is blocked, because the UI thread isn't blocked during the wait.</span></span>

## <a name="write-text"></a><span data-ttu-id="fe813-127">Yazma metni</span><span class="sxs-lookup"><span data-stu-id="fe813-127">Write text</span></span>

<span data-ttu-id="fe813-128">Aşağıdaki örnekler bir dosyaya metin yazar.</span><span class="sxs-lookup"><span data-stu-id="fe813-128">The following examples write text to a file.</span></span> <span data-ttu-id="fe813-129">Her await ifadesinde, yöntemi hemen çıkar.</span><span class="sxs-lookup"><span data-stu-id="fe813-129">At each await statement, the method immediately exits.</span></span> <span data-ttu-id="fe813-130">G/ç dosyası tamamlandığında, yöntemi await ifadesini izleyen deyimde devam eder.</span><span class="sxs-lookup"><span data-stu-id="fe813-130">When the file I/O is complete, the method resumes at the statement that follows the await statement.</span></span> <span data-ttu-id="fe813-131">Zaman uyumsuz değiştirici, await ifadesini kullanan yöntemlerin tanımıdır.</span><span class="sxs-lookup"><span data-stu-id="fe813-131">The async modifier is in the definition of methods that use the await statement.</span></span>

### <a name="simple-example"></a><span data-ttu-id="fe813-132">Basit örnek</span><span class="sxs-lookup"><span data-stu-id="fe813-132">Simple example</span></span>

:::code language="csharp" source="snippets/file-access/Program.cs" id="SimpleWrite":::

### <a name="finite-control-example"></a><span data-ttu-id="fe813-133">Sınırlı denetim örneği</span><span class="sxs-lookup"><span data-stu-id="fe813-133">Finite control example</span></span>

:::code language="csharp" source="snippets/file-access/Program.cs" id="WriteText":::

<span data-ttu-id="fe813-134">Özgün örnek, `await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);` aşağıdaki iki deyimin bir örneği olan ifadesine sahiptir:</span><span class="sxs-lookup"><span data-stu-id="fe813-134">The original example has the statement `await sourceStream.WriteAsync(encodedText, 0, encodedText.Length);`, which is a contraction of the following two statements:</span></span>

```csharp
Task theTask = sourceStream.WriteAsync(encodedText, 0, encodedText.Length);
await theTask;
```

<span data-ttu-id="fe813-135">İlk ifade bir görev döndürür ve dosya işlemenin başlatılmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="fe813-135">The first statement returns a task and causes file processing to start.</span></span> <span data-ttu-id="fe813-136">Await ile ikinci ifade, yönteminin hemen çıkmasına ve farklı bir görev döndürmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="fe813-136">The second statement with the await causes the method to immediately exit and return a different task.</span></span> <span data-ttu-id="fe813-137">Dosya işleme daha sonra tamamlandığında, yürütme, await ' ı izleyen ifadeye geri döner.</span><span class="sxs-lookup"><span data-stu-id="fe813-137">When the file processing later completes, execution returns to the statement that follows the await.</span></span>

## <a name="read-text"></a><span data-ttu-id="fe813-138">Metin oku</span><span class="sxs-lookup"><span data-stu-id="fe813-138">Read text</span></span>

<span data-ttu-id="fe813-139">Aşağıdaki örneklerde bir dosyadaki metin okunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fe813-139">The following examples read text from a file.</span></span>

### <a name="simple-example"></a><span data-ttu-id="fe813-140">Basit örnek</span><span class="sxs-lookup"><span data-stu-id="fe813-140">Simple example</span></span>

:::code language="csharp" source="snippets/file-access/Program.cs" id="SimpleRead":::

### <a name="finite-control-example"></a><span data-ttu-id="fe813-141">Sınırlı denetim örneği</span><span class="sxs-lookup"><span data-stu-id="fe813-141">Finite control example</span></span>

<span data-ttu-id="fe813-142">Metin, arabelleğe alınmış ve bu durumda bir öğesine yerleştirildi <xref:System.Text.StringBuilder> .</span><span class="sxs-lookup"><span data-stu-id="fe813-142">The text is buffered and, in this case, placed into a <xref:System.Text.StringBuilder>.</span></span> <span data-ttu-id="fe813-143">Önceki örnekte aksine, await 'ın değerlendirmesi bir değer oluşturur.</span><span class="sxs-lookup"><span data-stu-id="fe813-143">Unlike in the previous example, the evaluation of the await produces a value.</span></span> <span data-ttu-id="fe813-144"><xref:System.IO.Stream.ReadAsync%2A>Yöntemi bir> döndürür <xref:System.Threading.Tasks.Task> \<<xref:System.Int32> , bu nedenle await değerlendirmesi `Int32` işlem tamamlandıktan sonra bir değer oluşturur `numRead` .</span><span class="sxs-lookup"><span data-stu-id="fe813-144">The <xref:System.IO.Stream.ReadAsync%2A> method returns a <xref:System.Threading.Tasks.Task>\<<xref:System.Int32>>, so the evaluation of the await produces an `Int32` value `numRead` after the operation completes.</span></span> <span data-ttu-id="fe813-145">Daha fazla bilgi için bkz. [Async Return Types (C#)](async-return-types.md).</span><span class="sxs-lookup"><span data-stu-id="fe813-145">For more information, see [Async Return Types (C#)](async-return-types.md).</span></span>

:::code language="csharp" source="snippets/file-access/Program.cs" id="ReadText":::

## <a name="parallel-asynchronous-io"></a><span data-ttu-id="fe813-146">Paralel zaman uyumsuz g/ç</span><span class="sxs-lookup"><span data-stu-id="fe813-146">Parallel asynchronous I/O</span></span>

<span data-ttu-id="fe813-147">Aşağıdaki örneklerde, 10 metin dosyası yazarak paralel işleme gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="fe813-147">The following examples demonstrate parallel processing by writing 10 text files.</span></span>

### <a name="simple-example"></a><span data-ttu-id="fe813-148">Basit örnek</span><span class="sxs-lookup"><span data-stu-id="fe813-148">Simple example</span></span>

:::code language="csharp" source="snippets/file-access/Program.cs" id="SimpleParallelWrite":::

### <a name="finite-control-example"></a><span data-ttu-id="fe813-149">Sınırlı denetim örneği</span><span class="sxs-lookup"><span data-stu-id="fe813-149">Finite control example</span></span>

<span data-ttu-id="fe813-150">Her dosya için, <xref:System.IO.Stream.WriteAsync%2A> yöntemi bir görev listesine eklenen bir görevi döndürür.</span><span class="sxs-lookup"><span data-stu-id="fe813-150">For each file, the <xref:System.IO.Stream.WriteAsync%2A> method returns a task that is then added to a list of tasks.</span></span> <span data-ttu-id="fe813-151">`await Task.WhenAll(tasks);`Deyimden çıkılıyor ve tüm görevler için dosya işleme tamamlandığında yöntemi içinde devam eder.</span><span class="sxs-lookup"><span data-stu-id="fe813-151">The `await Task.WhenAll(tasks);` statement exits the method and resumes within the method when file processing is complete for all of the tasks.</span></span>

<span data-ttu-id="fe813-152">Örnek, <xref:System.IO.FileStream> `finally` görevler tamamlandıktan sonra bir bloktaki tüm örnekleri kapatır.</span><span class="sxs-lookup"><span data-stu-id="fe813-152">The example closes all <xref:System.IO.FileStream> instances in a `finally` block after the tasks are complete.</span></span> <span data-ttu-id="fe813-153">Her biri `FileStream` bir bildiriminde oluşturulduysa, `using` görev tamamlanmadan önce ' `FileStream` nin atımı bırakılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="fe813-153">If each `FileStream` was instead created in a `using` statement, the `FileStream` might be disposed of before the task was complete.</span></span>

<span data-ttu-id="fe813-154">Herhangi bir performans artışı, zaman uyumsuz işlemden değil, paralel işlemden neredeyse tamamen yapılır.</span><span class="sxs-lookup"><span data-stu-id="fe813-154">Any performance boost is almost entirely from the parallel processing and not the asynchronous processing.</span></span> <span data-ttu-id="fe813-155">Zaman uyumsuzluğu 'nin avantajları birden çok iş parçacığını bağlamaktır ve Kullanıcı arabirimi iş parçacığını bağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="fe813-155">The advantages of asynchrony are that it doesn't tie up multiple threads, and that it doesn't tie up the user interface thread.</span></span>

:::code language="csharp" source="snippets/file-access/Program.cs" id="ParallelWriteText":::

<span data-ttu-id="fe813-156"><xref:System.IO.Stream.WriteAsync%2A>Ve yöntemlerini kullanırken, <xref:System.IO.Stream.ReadAsync%2A> <xref:System.Threading.CancellationToken> işlem orta-akış işlemini iptal etmek için kullanabileceğiniz bir belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe813-156">When using the <xref:System.IO.Stream.WriteAsync%2A> and <xref:System.IO.Stream.ReadAsync%2A> methods, you can specify a <xref:System.Threading.CancellationToken>, which you can use to cancel the operation mid-stream.</span></span> <span data-ttu-id="fe813-157">Daha fazla bilgi için bkz. [yönetilen iş parçacıklarında iptal](../../../../standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="fe813-157">For more information, see [Cancellation in managed threads](../../../../standard/threading/cancellation-in-managed-threads.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="fe813-158">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="fe813-158">See also</span></span>

- [<span data-ttu-id="fe813-159">Async ve await ile zaman uyumsuz programlama (C#)</span><span class="sxs-lookup"><span data-stu-id="fe813-159">Asynchronous programming with async and await (C#)</span></span>](index.md)
- [<span data-ttu-id="fe813-160">Zaman uyumsuz dönüş türleri (C#)</span><span class="sxs-lookup"><span data-stu-id="fe813-160">Async return types (C#)</span></span>](async-return-types.md)
