---
title: Demetleri ve diğer türleri ayrıştırma
description: Tuples ve diğer türleri yapısızlaştırılmasını öğrenin.
ms.technology: csharp-fundamentals
ms.date: 07/18/2016
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: 23d193faf9702628698fe558f6667aeb130e8916
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "73100663"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="64124-103">Demetleri ve diğer türleri ayrıştırma</span><span class="sxs-lookup"><span data-stu-id="64124-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="64124-104">Tuple, yöntem çağrısından birden çok değer almak için hafif bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="64124-104">A tuple provides a lightweight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="64124-105">Ama bir kez tuple almak, onun bireysel unsurları işlemek zorunda.</span><span class="sxs-lookup"><span data-stu-id="64124-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="64124-106">Bunu bir öğe-by-eleman bazında yapmak, aşağıdaki örnekte gösterdiği gibi hantal.</span><span class="sxs-lookup"><span data-stu-id="64124-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="64124-107">Yöntem `QueryCityData` 3-tuple döndürür ve öğelerinin her biri ayrı bir işlemde bir değişkene atanır.</span><span class="sxs-lookup"><span data-stu-id="64124-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="64124-108">Bir nesneden birden çok alan ve özellik değeri almak da aynı derecede hantal olabilir: bir alan veya özellik değerini bir değişkene üye bazında atamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="64124-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="64124-109">C# 7.0 ile başlayarak, bir tuple'dan birden çok öğe alabilir veya tek bir *deconstruct* işleminde bir nesneden birden çok alan, özellik ve hesaplanan değerleri alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="64124-110">Bir tuple'ı yapısızleştirdiğinizde, öğelerini tek tek değişkenlere atarsınız.</span><span class="sxs-lookup"><span data-stu-id="64124-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="64124-111">Bir nesneyi yapısızleştirdiğinizde, seçili değerleri tek tek değişkenlere atarsınız.</span><span class="sxs-lookup"><span data-stu-id="64124-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="64124-112">Bir tuple deconstructing</span><span class="sxs-lookup"><span data-stu-id="64124-112">Deconstructing a tuple</span></span>

<span data-ttu-id="64124-113">C#, tek bir işlemde bir tuple'daki tüm öğeleri çözmenize olanak tanıyan yerleşik destek özelliğine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="64124-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="64124-114">Bir tuple'ı dekonstrükte etmek için kullanılan genel sözdizimi, bir tanesini tanımlamak için sözdizimine benzer: her öğenin bir atama deyiminin sol tarafında parantez içinde atanacak olan değişkenleri içine alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="64124-115">Örneğin, aşağıdaki deyim dört ayrı değişkene 4-tuple öğeleriatar:</span><span class="sxs-lookup"><span data-stu-id="64124-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="64124-116">Bir tuple'ı yapısızlandırmanın üç yolu vardır:</span><span class="sxs-lookup"><span data-stu-id="64124-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="64124-117">Parantez içindeki her alanın türünü açıkça bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="64124-118">Aşağıdaki örnek, `QueryCityData` yöntem tarafından döndürülen 3-tuple yapısızlaştırılması için bu yaklaşımı kullanır.</span><span class="sxs-lookup"><span data-stu-id="64124-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="64124-119">C# her `var` değişkenin türünü çıkarsın diye anahtar sözcüğü kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="64124-120">Anahtar kelimeyi `var` parantezlerin dışına yerlikir.</span><span class="sxs-lookup"><span data-stu-id="64124-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="64124-121">Aşağıdaki örnek, yöntemle döndürülen 3-tuple'ı dekonstrükte ederken tür çıkarımını `QueryCityData` kullanır.</span><span class="sxs-lookup"><span data-stu-id="64124-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="64124-122">Anahtar kelimeyi `var` parantez içindeki değişken bildirimlerinden herhangi biriyle veya tümüyle tek tek kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="64124-123">Bu hantal ve tavsiye edilmez.</span><span class="sxs-lookup"><span data-stu-id="64124-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="64124-124">Son olarak, tuple'ı zaten bildirilmiş değişkenlere dönüştürebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="64124-125">Tuple'daki her alan aynı türe sahip olsa bile parantez dışında belirli bir tür belirtemeyeceğiniz unutmayın.</span><span class="sxs-lookup"><span data-stu-id="64124-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="64124-126">Bu, CS8136 derleyici hatası oluşturur, "Dekonstrüksiyon 'var (...)' formu 'var' için belirli bir tür eserinizinverir."</span><span class="sxs-lookup"><span data-stu-id="64124-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="64124-127">Tuple'ın her öğesini bir değişkene atamanız gerektiğini de unutmayın.</span><span class="sxs-lookup"><span data-stu-id="64124-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="64124-128">Herhangi bir öğeyi atlarsanız, derleyici CS8132 hatası oluşturur, "'x' öğelerinin bir tuple'ını 'y' değişkenlerine dönüştüremez."</span><span class="sxs-lookup"><span data-stu-id="64124-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="64124-129">Dekonstrüksiyonun sol tarafındaki varolan değişkenlere bildirimleri ve atamaları karıştıramayacağınızı unutmayın.</span><span class="sxs-lookup"><span data-stu-id="64124-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="64124-130">Derleyici CS8184 hatası oluşturur, "bir yapısızlaştırma sol tarafta ki bildirimleri ve ifadeleri karıştıramaz."</span><span class="sxs-lookup"><span data-stu-id="64124-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="64124-131">üyeleri yeni beyan ve varolan değişkenleri içerdiğinde.</span><span class="sxs-lookup"><span data-stu-id="64124-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="64124-132">Tuple elemanlarının atılarak yapısızlaştırılması</span><span class="sxs-lookup"><span data-stu-id="64124-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="64124-133">Genellikle bir tuple deconstructing, yalnızca bazı öğelerin değerleri ilgileniyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="64124-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="64124-134">C# 7.0 ile başlayarak, yalnızca yazma değişkenleri olan ve değerlerini yoksaymayı seçtiğiniz c#'ın *atılması*desteğinden yararlanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="64124-135">Bir atama, bir atamadaki alt\_karakter (" ") tarafından belirlenir.</span><span class="sxs-lookup"><span data-stu-id="64124-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="64124-136">İstediğiniz kadar değer atabilirsiniz; hepsi tek bir atlayıp, `_`.</span><span class="sxs-lookup"><span data-stu-id="64124-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="64124-137">Aşağıdaki örnek, tuples'in atılarak kullanımını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="64124-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="64124-138">Bu `QueryCityDataForYears` yöntem, bir şehrin adı, alanı, bir yıl, o yıl için şehir nüfusu, ikinci yıl ve ikinci yıl için şehrin nüfusu ile 6-tuple döndürür.</span><span class="sxs-lookup"><span data-stu-id="64124-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="64124-139">Örnek, bu iki yıl arasındaki nüfus değişimini göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="64124-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="64124-140">Tuple'dan elde edilen verilerden şehir alanıyla ilgilenmiyoruz ve şehir adını ve iki tarihi tasarım zamanında biliyoruz.</span><span class="sxs-lookup"><span data-stu-id="64124-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="64124-141">Sonuç olarak, yalnızca tuple'da depolanan iki popülasyon değeriyle ilgileniyoruz ve kalan değerlerini atılarak işleyebiliriz.</span><span class="sxs-lookup"><span data-stu-id="64124-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

## <a name="deconstructing-user-defined-types"></a><span data-ttu-id="64124-142">Kullanıcı tanımlı türleri deconstructing</span><span class="sxs-lookup"><span data-stu-id="64124-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="64124-143">C#, tuple olmayan türleri yapılandırmak için yerleşik destek sunmaz.</span><span class="sxs-lookup"><span data-stu-id="64124-143">C# does not offer built-in support for deconstructing non-tuple types.</span></span> <span data-ttu-id="64124-144">Ancak, bir sınıfın, bir yapının veya arabirimin yazarı olarak, bir veya daha fazla `Deconstruct` yöntem uygulayarak tür örneklerinin deconstructed izin verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="64124-145">Yöntem geçersiz döndürür ve oluşturulacak her değer yöntem imzasında bir [çıkış](language-reference/keywords/out-parameter-modifier.md) parametresi ile gösterilir.</span><span class="sxs-lookup"><span data-stu-id="64124-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="64124-146">Örneğin, bir `Person` `Deconstruct` sınıfın aşağıdaki yöntemi ilk, orta ve soyadı döndürür:</span><span class="sxs-lookup"><span data-stu-id="64124-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="64124-147">Daha sonra aşağıdaki gibi bir `Person` atama `p` ile adlı sınıfın bir örneğini deconstruct olabilir:</span><span class="sxs-lookup"><span data-stu-id="64124-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="64124-148">Aşağıdaki örnek, bir `Deconstruct` `Person` nesnenin çeşitli özelliklerini döndürmek için yöntemi aşırı yükler.</span><span class="sxs-lookup"><span data-stu-id="64124-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="64124-149">Bireysel aşırı yükler geri dönüş:</span><span class="sxs-lookup"><span data-stu-id="64124-149">Individual overloads return:</span></span>

- <span data-ttu-id="64124-150">Adı ve soyadı.</span><span class="sxs-lookup"><span data-stu-id="64124-150">A first and last name.</span></span>
- <span data-ttu-id="64124-151">Bir ilk, son ve göbek adı.</span><span class="sxs-lookup"><span data-stu-id="64124-151">A first, last, and middle name.</span></span>
- <span data-ttu-id="64124-152">Ad, soyad, şehir adı ve eyalet adı.</span><span class="sxs-lookup"><span data-stu-id="64124-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="64124-153">`Deconstruct` Yöntemi, genellikle bir nesneden çıkarılan veri gruplarını yansıtmak için aşırı yüklenebildiğinizden, ayırt edici ve açık olan imzalarla yöntemleri tanımlamaya `Deconstruct` dikkat etmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-153">Because you can overload the `Deconstruct` method to reflect groups of data that are commonly extracted from an object, you should be careful to define `Deconstruct` methods with signatures that are distinctive and unambiguous.</span></span> <span data-ttu-id="64124-154">Aynı `Deconstruct` sayıda `out` parametreye veya aynı sayıda ve `out` farklı bir sırada parametre türüne sahip birden çok yöntem karışıklığa neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="64124-154">Multiple `Deconstruct` methods that have the same number of `out` parameters or the same number and type of `out` parameters in a different order can cause confusion.</span></span>

<span data-ttu-id="64124-155">Aşağıdaki örnekte aşırı yüklenen `Deconstruct` yöntem, olası bir karışıklık kaynağını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="64124-155">The overloaded `Deconstruct` method in the following example illustrates one possible source of confusion.</span></span> <span data-ttu-id="64124-156">İlk aşırı yükleme, bir `Person` nesnenin adını, soyadını ve yaşını bu sırada döndürür.</span><span class="sxs-lookup"><span data-stu-id="64124-156">The first overload returns the first name, middle name, last name, and age of a `Person` object, in that order.</span></span> <span data-ttu-id="64124-157">İkinci aşırı yükleme ad bilgilerini yalnızca yıllık gelirle birlikte döndürür, ancak ilk, orta ve soyadı farklı bir sıradadır.</span><span class="sxs-lookup"><span data-stu-id="64124-157">The second overload returns name information only along with annual income, but the first, middle, and last name are in a different order.</span></span> <span data-ttu-id="64124-158">Bu, bir `Person` örneğin yapısını çözerken bağımsız değişkenlerin sırasını karıştırmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="64124-158">This makes it easy to confuse the order of arguments when deconstructing a `Person` instance.</span></span>

[!code-csharp[Deconstruct-ambiguity](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-ambiguous.cs)]

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="64124-159">Kullanıcı tanımlı bir türü atar ile yapılandırma</span><span class="sxs-lookup"><span data-stu-id="64124-159">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="64124-160">[Tuples](#deconstructing-tuple-elements-with-discards)ile yaptığınız gibi, bir `Deconstruct` yöntem tarafından döndürülen seçili öğeleri yok saymak için atar kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-160">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="64124-161">Her atfetmek " "\_adlı bir değişkenle tanımlanır ve tek bir yapısızlaştırma işlemi birden çok atamı içerebilir.</span><span class="sxs-lookup"><span data-stu-id="64124-161">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="64124-162">Aşağıdaki örnek, bir `Person` nesneyi dört dize (ad ve soyad, şehir ve devlet) olarak belirtir, ancak soyadını ve durumu atar.</span><span class="sxs-lookup"><span data-stu-id="64124-162">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="64124-163">Uzantı yöntemiyle kullanıcı tanımlı bir tür deconstructing</span><span class="sxs-lookup"><span data-stu-id="64124-163">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="64124-164">Bir sınıf, yapı veya arabirim yazmadıysanız, ilgilendiğiniz değerleri döndürmek için bir veya daha `Deconstruct` fazla [uzantı yöntemi](programming-guide/classes-and-structs/extension-methods.md) uygulayarak bu tür nesneleri yapısızhale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="64124-164">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="64124-165">Aşağıdaki örnek, `Deconstruct` <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> sınıf için iki uzantı yöntemi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="64124-165">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="64124-166">İlk, özelliğin türü, statik veya örnek olsun, salt okunur olup olmadığı ve dizine eklenip dizilmediği de dahil olmak üzere özellikleri gösteren bir değer kümesi döndürür.</span><span class="sxs-lookup"><span data-stu-id="64124-166">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="64124-167">İkincisi, özelliğin erişilebilirliğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="64124-167">The second indicates the property's accessibility.</span></span> <span data-ttu-id="64124-168">Get ve Set erişime sahip olan ların erişilebilirliği farklı olabileceğinden, Boolean değerleri özelliğin ayrı get ve set erişime sahip olup olmadığını ve varsa aynı erişilebilirliğe sahip olup olmadıklarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="64124-168">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="64124-169">Yalnızca bir erişimci varsa veya hem get hem de set erişime `access` sahipse, değişken özelliğin bir bütün olarak erişilebilirliğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="64124-169">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="64124-170">Aksi takdirde, get ve set erişimci erişilebilirliği `getAccess` ve `setAccess` değişkenler tarafından gösterilir.</span><span class="sxs-lookup"><span data-stu-id="64124-170">Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="64124-171">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="64124-171">See also</span></span>

- [<span data-ttu-id="64124-172">Atılanlar</span><span class="sxs-lookup"><span data-stu-id="64124-172">Discards</span></span>](discards.md)
- [<span data-ttu-id="64124-173">Dizilerini</span><span class="sxs-lookup"><span data-stu-id="64124-173">Tuples</span></span>](tuples.md)
