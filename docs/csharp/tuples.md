---
title: Demet türleri-C# Kılavuzu
description: "C 'de adlandırılmamış ve adlandırılmış demet türleri hakkında bilgi edinin #"
ms.date: 05/15/2018
ms.technology: csharp-fundamentals
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 0fb6f043857a9932b7a86f773cce812e0fd49dcb
ms.sourcegitcommit: 0edbeb66d71b8df10fcb374cfca4d731b58ccdb2
ms.contentlocale: tr-TR
ms.lasthandoff: 07/07/2020
ms.locfileid: "86051863"
---
# <a name="c-tuple-types"></a><span data-ttu-id="fcb53-103">C# demet türleri</span><span class="sxs-lookup"><span data-stu-id="fcb53-103">C# tuple types</span></span>

<span data-ttu-id="fcb53-104">C# tanımlama grupları, hafif bir sözdizimi kullanarak tanımladığınız türlerdir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="fcb53-105">Daha basit bir sözdizimi, sayıya göre dönüştürme kuralları (kardinalite olarak adlandırılır) ve öğe türleri ve kopyalar, eşitlik testleri ve atamalar için tutarlı kurallar vardır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="fcb53-106">Zorunluluğunu getirir olarak, tanımlama grupları devralma ile ilişkili nesne odaklı bazı deyimleri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="fcb53-107">[C# 7,0 'deki](whats-new/csharp-7.md#tuples) yenilikler makalesinde yer alan tanımlama bilgileri bölümüne genel bakış alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="fcb53-108">Bu makalede, C# 7,0 ve sonraki sürümlerinde tanımlama gruplarını ve bunları kullanmanın farklı yollarını ve tanımlama grupları ile çalışmaya yönelik ilk Kılavuzu düzenleyen dil kurallarını öğreneceksiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="fcb53-109">Yeni tanımlama grubu özellikleri türleri gerektirir <xref:System.ValueTuple> .</span><span class="sxs-lookup"><span data-stu-id="fcb53-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="fcb53-110">NuGet paketini [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) türleri içermeyen platformlarda kullanabilmek için eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="fcb53-111">Bu, çerçeveye teslim edilen türleri kullanan diğer dil özelliklerine benzerdir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="fcb53-112">Örnek olarak `async` `await` `INotifyCompletion` , arabirime ve LINQ uygulamasına bağlı olarak verilebilir `IEnumerable<T>` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="fcb53-113">Bununla birlikte, .NET daha fazla platforma bağımlı olduğu için teslim mekanizması değişiyor.</span><span class="sxs-lookup"><span data-stu-id="fcb53-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="fcb53-114">.NET Framework, dil derleyicisi ile aynı temposunda her zaman yollanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="fcb53-115">Yeni dil özellikleri yeni türlere dayandığınızda, bu türler dil Özellikleri sevk edildiğinde NuGet paketleri olarak kullanılabilir olacaktır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="fcb53-116">Bu yeni türler .NET Standard API 'sine eklendikçe ve Framework 'ün bir parçası olarak teslim edildiğinde, NuGet paket gereksinimi kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="fcb53-117">Yeni demet desteği ekleme nedenlerinden başlayalım.</span><span class="sxs-lookup"><span data-stu-id="fcb53-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="fcb53-118">Yöntemler tek bir nesne döndürür.</span><span class="sxs-lookup"><span data-stu-id="fcb53-118">Methods return a single object.</span></span> <span data-ttu-id="fcb53-119">Tanımlama grupları bu tek nesnede birden çok değeri daha kolay paketlemenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="fcb53-120">.NET Framework zaten genel sınıflar içeriyor `Tuple` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="fcb53-121">Ancak, bu sınıfların iki önemli sınırlaması vardı.</span><span class="sxs-lookup"><span data-stu-id="fcb53-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="fcb53-122">Bunlardan biri için, `Tuple` Özellikleri, vb. olarak adlandırılır `Item1` `Item2` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="fcb53-123">Bu adlar hiçbir anlam bilgisi içermez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-123">Those names carry no semantic information.</span></span> <span data-ttu-id="fcb53-124">Bu türlerin kullanılması, `Tuple` özelliklerin her birinin anlamını karşılayarak iletişim kurmasına imkan vermez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="fcb53-125">Yeni dil özellikleri, bir tanımlama grubu içindeki öğeler için anlamsal anlamlı adlar bildirme ve kullanma imkanı sağlar.</span><span class="sxs-lookup"><span data-stu-id="fcb53-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="fcb53-126">`Tuple`Sınıflar, başvuru türleri olduklarından daha fazla performans sorunlarına neden olur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="fcb53-127">Türlerden birini kullanmak `Tuple` nesneleri ayırmayı gösterir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="fcb53-128">Etkin yollarda birçok küçük nesne ayırmak uygulamanızın performansı üzerinde ölçülebilir bir etkiye sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="fcb53-129">Bu nedenle, tanımlama grupları için dil desteği yeni `ValueTuple` yapıları kullanır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="fcb53-130">Bu eksiklikleri önlemek için, `class` `struct` birden çok öğe taşımak üzere bir veya oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="fcb53-131">Ne yazık ki, sizin için daha fazla çalışma ve tasarım amacınızı gizler.</span><span class="sxs-lookup"><span data-stu-id="fcb53-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="fcb53-132">`struct`Ya da `class` hem veri hem de davranışla bir tür tanımladığınız anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="fcb53-133">Birçok kez yalnızca birden çok değeri tek bir nesnede depolamak istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="fcb53-134">Dil özellikleri ve `ValueTuple` genel yapılar, bu demet türlerine herhangi bir davranış (Yöntem) ekleyemeyeceği kuralını zorlar.</span><span class="sxs-lookup"><span data-stu-id="fcb53-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="fcb53-135">Tüm `ValueTuple` türler *değişebilir yapılarda*oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="fcb53-136">Her üye alanı bir ortak alandır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-136">Each member field is a public field.</span></span> <span data-ttu-id="fcb53-137">Böylece çok hafif hale gelir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-137">That makes them very lightweight.</span></span> <span data-ttu-id="fcb53-138">Bununla birlikte, bu, her ne kadar önemli olduğu durumlarda başlıkların kullanılması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="fcb53-139">Tanımlama grupları, ve türlerine göre daha basit ve daha esnek veri kapsayıcılarıdır `class` `struct` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="fcb53-140">Bu farklılıkları keşfedelim.</span><span class="sxs-lookup"><span data-stu-id="fcb53-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="fcb53-141">Adlandırılmış ve adlandırılmamış diziler</span><span class="sxs-lookup"><span data-stu-id="fcb53-141">Named and unnamed tuples</span></span>

<span data-ttu-id="fcb53-142">Yapının,,, vb `ValueTuple` . adlı alanları `Item1` `Item2` `Item3` var olan türlerde tanımlanan özelliklere benzer şekilde `Tuple` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="fcb53-143">Bu adlar, *adlandırılmamış tanımlama grupları*için kullanabileceğiniz tek adlardır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="fcb53-144">Bir tanımlama grubu için alternatif alan adı sağlamadığınızda, adlandırılmamış bir tanımlama grubu oluşturdunuz:</span><span class="sxs-lookup"><span data-stu-id="fcb53-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="fcb53-145">Önceki örnekteki tanımlama grubu, değişmez sabitler kullanılarak başlatılmış ve C# 7,1 ' de *demet alan adı tahminleri* kullanılarak oluşturulan öğe adlarına sahip olmayacaktır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="fcb53-146">Ancak, bir tanımlama grubu başlattığınızda, her bir alana daha iyi adlar veren yeni dil özellikleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="fcb53-147">Bunun yapılması adlandırılmış bir *tanımlama grubu*oluşturur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="fcb53-148">Adlandırılmış tanımlama gruplarının hala,,, vb. adlı öğeleri vardır `Item1` `Item2` `Item3` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-148">Named tuples still have elements named `Item1`, `Item2`, `Item3`, and so on.</span></span>
<span data-ttu-id="fcb53-149">Ancak, adlandırmış olduğunuz öğelerin herhangi biri için eş anlamlıları da vardır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="fcb53-150">Her öğe için ad belirterek adlandırılmış bir tanımlama grubu oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="fcb53-151">Bir yol, kayıt kümesi başlatmasının parçası olarak adları belirtmektir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="fcb53-152">Adlandırılmış tanımlama gruplarını etkin bir şekilde kullanabilmeniz için bu eş anlamlılar derleyici ve dil tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="fcb53-153">Ides ve düzenleyiciler, Roslyn API 'Lerini kullanarak bu anlam adlarını okuyabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="fcb53-154">Adlandırılmış bir tanımlama grubunun öğelerine aynı derlemenin herhangi bir yerindeki anlam adlarıyla başvurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="fcb53-155">Derleyici, `Item*` derlenmiş çıktıyı oluştururken eşdeğerleriyle tanımladığınız adların yerini alır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="fcb53-156">Derlenen Microsoft ara dili (MSIL), bu öğeleri verdiğiniz adları içermez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="fcb53-157">C# 7,1 ' den başlayarak, kayıt düzeni için alan adları, kayıt düzeni başlatmak için kullanılan değişkenlerden bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="fcb53-158">Tanımlama gruplarına alan adları sağlamak, **[demet yansıtma başlatıcıları](#tuple-projection-initializers)** olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-158">Providing field names to tuples is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="fcb53-159">Aşağıdaki kod `accumulation` öğeleriyle `count` (bir tamsayı) ve `sum` (bir Double) adlı bir tanımlama grubu oluşturur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="fcb53-160">Derleyici, ortak Yöntemler veya özelliklerden döndürülen tanımlama grupları için oluşturduğunuz adları iletmelidir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="fcb53-161">Bu durumlarda, derleyici yöntemine bir öznitelik ekler <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> .</span><span class="sxs-lookup"><span data-stu-id="fcb53-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="fcb53-162">Bu öznitelik <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> , kayıt grubundaki her öğeye verilen adları içeren bir List özelliği içerir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="fcb53-163">Visual Studio gibi geliştirme araçları da bu meta verileri okur ve meta veri alanı adlarını kullanarak IntelliSense ve diğer özellikleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="fcb53-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="fcb53-164">`ValueTuple`Adlandırılmış tanımlama gruplarını birbirlerine atamaya yönelik kuralları anlamak için yeni tanımlama bilgileri ve türün temel temellerini anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="fcb53-165">Demet projeksiyon başlatıcıları</span><span class="sxs-lookup"><span data-stu-id="fcb53-165">Tuple projection initializers</span></span>

<span data-ttu-id="fcb53-166">Genel olarak, demet yansıtma başlatıcıları, bir demet başlatma bildiriminin sağ tarafındaki değişken veya alan adlarını kullanarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="fcb53-167">Açık bir ad verilirse, bu, yansıtılan herhangi bir adın önüne geçer.</span><span class="sxs-lookup"><span data-stu-id="fcb53-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="fcb53-168">Örneğin, aşağıdaki başlatıcıda öğeler `explicitFieldOne` ve değil, ve `explicitFieldTwo` `localVariableOne` `localVariableTwo` :</span><span class="sxs-lookup"><span data-stu-id="fcb53-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="fcb53-169">Açık bir adın sağlanmadığı herhangi bir alan için, geçerli bir örtük ad yansıtıldır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="fcb53-170">Açıkça veya örtük olarak anlamsal adlar sağlama gereksinimi yoktur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="fcb53-171">Aşağıdaki başlatıcıda `Item1` değeri olan `42` ve değeri `stringContent` "her şeye yanıt" olan alan adlarına sahiptir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="fcb53-172">Aday alan adlarının demet alanı üzerinde yansıtılmamaları gereken iki koşul vardır:</span><span class="sxs-lookup"><span data-stu-id="fcb53-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="fcb53-173">Aday adı, ayrılmış bir tanımlama grubu adı olduğunda.</span><span class="sxs-lookup"><span data-stu-id="fcb53-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="fcb53-174">Örnekler, `Item3` , `ToString` veya içerir `Rest` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-174">Examples include `Item3`, `ToString`, or `Rest`.</span></span>
1. <span data-ttu-id="fcb53-175">Aday adı, başka bir demet alan adının bir yinelemesi olduğunda açık veya kapalı olur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-175">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="fcb53-176">Bu koşullar belirsizlik kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="fcb53-176">These conditions avoid ambiguity.</span></span> <span data-ttu-id="fcb53-177">Bu adlar, bir tanımlama grubu içindeki bir alanın alan adları olarak kullanıldıklarında belirsizliğe neden olur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-177">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="fcb53-178">Bu koşullardan hiçbiri derleme zamanı hatalarına neden olur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-178">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="fcb53-179">Bunun yerine, yansıtılan adlara sahip öğeler kendileri için öngörülen semantik adlara sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-179">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="fcb53-180">Aşağıdaki örneklerde bu koşullar gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-180">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="fcb53-181">Bu durumlar derleyici hatalarına neden olmaz çünkü bu, kayıt düzeni alan adı projeksiyonlarını belirleyemediği zaman C# 7,0 ile yazılmış kod için bir değişiklik olacaktır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-181">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="fcb53-182">Eşitlik ve tanımlama grupları</span><span class="sxs-lookup"><span data-stu-id="fcb53-182">Equality and tuples</span></span>

<span data-ttu-id="fcb53-183">C# 7,3 ' den başlayarak demet türleri `==` ve işleçlerini destekler `!=` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-183">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="fcb53-184">Bu işleçler, sol bağımsız değişkenin her bir üyesini sırasıyla doğru bağımsız değişkenin her bir üyesiyle karşılaştırarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-184">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="fcb53-185">Bu karşılaştırmalar kısa devre.</span><span class="sxs-lookup"><span data-stu-id="fcb53-185">These comparisons short-circuit.</span></span> <span data-ttu-id="fcb53-186">Bir çift eşit olmadığı anda üyelerin değerlendirilmesi durdurulur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-186">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="fcb53-187">Aşağıdaki kod örnekleri kullanılır `==` , ancak tüm karşılaştırma kuralları için geçerlidir `!=` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-187">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="fcb53-188">Aşağıdaki kod örneği iki tamsayı çifti için bir eşitlik karşılaştırması gösterir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-188">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="fcb53-189">Demet eşitlik testlerini daha uygun hale getirmek için çeşitli kurallar vardır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-189">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="fcb53-190">Tanımlama grubu eşitliği, aşağıdaki kodda gösterildiği gibi, tanımlama gruplarının biri null yapılabilir bir tanımlama grubu ise [yükseltilmemiş dönüştürmeleri](~/_csharplang/spec/conversions.md#lifted-conversion-operators) gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-190">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="fcb53-191">Tanımlama grubu eşitliği, her iki başlığın de her bir üyesinde örtük dönüştürmeler de gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-191">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="fcb53-192">Bunlar, yükseltilmemiş dönüştürmeleri, genişleyen dönüşümler veya diğer örtük dönüştürmeler içerir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-192">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="fcb53-193">Aşağıdaki örneklerde, tamsayı 2 kayıt düzeninin, tamsayıdan Long 'a örtük dönüştürme nedeniyle uzun 2 tanımlama grubu ile karşılaştırılabilmesinin gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-193">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="fcb53-194">Demet üyelerinin adları, eşitlik için testlere katılmaz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-194">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="fcb53-195">Ancak, işlenenden biri açık adlara sahip bir demet sabit değeri ise, bu adlar diğer işlenenin adlarıyla eşleşmezse, derleyici uyarı CS8383 oluşturur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-195">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="fcb53-196">Her iki işlenenin de demet sabit değerleri olduğu durumlarda, aşağıdaki örnekte gösterildiği gibi uyarı sağ işlenende olur:</span><span class="sxs-lookup"><span data-stu-id="fcb53-196">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="fcb53-197">Son olarak, tanımlama grupları iç içe diziler içerebilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-197">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="fcb53-198">Tanımlama grubu eşitliği, aşağıdaki örnekte gösterildiği gibi, iç içe geçmiş diziler aracılığıyla her bir işlenenin "şeklini" karşılaştırır:</span><span class="sxs-lookup"><span data-stu-id="fcb53-198">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="fcb53-199">Farklı şekilleri olduğunda, eşitlik (veya eşitsizlik) için iki tanımlama grubunu karşılaştırmak üzere derleme zamanı hatası.</span><span class="sxs-lookup"><span data-stu-id="fcb53-199">It's a compile-time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="fcb53-200">Derleyici, iç içe geçmiş tanımlama gruplarının kendisini karşılaştırmak için denenmez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-200">The compiler won't attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="fcb53-201">Atama ve tanımlama grupları</span><span class="sxs-lookup"><span data-stu-id="fcb53-201">Assignment and tuples</span></span>

<span data-ttu-id="fcb53-202">Dil, her bir sağ taraftaki öğenin örtük olarak karşılık gelen sol taraftaki öğesine dönüştürülebileceği, aynı sayıda öğeye sahip demet türleri arasında atamayı destekler.</span><span class="sxs-lookup"><span data-stu-id="fcb53-202">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="fcb53-203">Diğer dönüşümler atamalar için kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-203">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="fcb53-204">Farklı şekillerde bir tanımlama grubu atamak için bir derleme zamanı hatası vardır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-204">It's a compile-time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="fcb53-205">Derleyici, iç içe geçmiş tanımlama gruplarının atamasını atamak için denenmez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-205">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="fcb53-206">Demet türleri arasında izin verilen atama türlerine bakalım.</span><span class="sxs-lookup"><span data-stu-id="fcb53-206">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="fcb53-207">Aşağıdaki örneklerde kullanılan değişkenleri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="fcb53-207">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="fcb53-208">İlk iki değişken, `unnamed` ve `anonymous` öğeleri için belirtilen semantik adlara sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-208">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="fcb53-209">Alan adları `Item1` ve ' dir `Item2` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-209">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="fcb53-210">Son iki değişken `named` ve `differentName` öğeler için belirtilen semantik adlara sahip.</span><span class="sxs-lookup"><span data-stu-id="fcb53-210">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="fcb53-211">Bu iki başlık, öğeler için farklı adlara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-211">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="fcb53-212">Bu başlıkların dördü, aynı sayıda öğeye sahiptir (' kardinalite ' olarak adlandırılır) ve bu öğelerin türleri aynıdır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-212">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="fcb53-213">Bu nedenle, bu atamaların hepsi çalışır:</span><span class="sxs-lookup"><span data-stu-id="fcb53-213">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="fcb53-214">Başlıkların adlarının atanmadığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="fcb53-214">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="fcb53-215">Öğelerin değerleri, kayıt düzeni içindeki öğelerin sırasını izleyerek atanır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-215">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="fcb53-216">Farklı türlerin veya öğe sayılarının başlıkları atanamaz:</span><span class="sxs-lookup"><span data-stu-id="fcb53-216">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="fcb53-217">Yöntem dönüş değerleri olarak tanımlama grubu</span><span class="sxs-lookup"><span data-stu-id="fcb53-217">Tuples as method return values</span></span>

<span data-ttu-id="fcb53-218">Tanımlama grupları için en yaygın kullanımdan biri yöntem dönüş değeri olarak belirlenir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-218">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="fcb53-219">Bir örnek adım adım inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="fcb53-219">Let's walk through one example.</span></span> <span data-ttu-id="fcb53-220">Bir dizi sayı için standart sapmayı hesaplayan bu yöntemi göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="fcb53-220">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="fcb53-221">Bu örnekler düzeltilmeyen örnek standart sapmayı hesaplar.</span><span class="sxs-lookup"><span data-stu-id="fcb53-221">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="fcb53-222">Düzeltilen örnek standart sapma formülü, iç kare farklarının toplamını, genişletme yöntemi olduğu gibi N yerine, her ne kadar (N-1) olacak şekilde böler `Average` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-222">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span>

<span data-ttu-id="fcb53-223">Yukarıdaki kod, standart sapma için textbook formülünü izler.</span><span class="sxs-lookup"><span data-stu-id="fcb53-223">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="fcb53-224">Doğru yanıtı üretir ancak bu, verimsiz bir uygulama.</span><span class="sxs-lookup"><span data-stu-id="fcb53-224">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="fcb53-225">Bu yöntem, diziyi iki kez numaralandırır: ortalamayı üretmek için bir kez ve ortalamanın farkının ortalamasının ortalamasını üretmek için bir kez.</span><span class="sxs-lookup"><span data-stu-id="fcb53-225">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="fcb53-226">(LINQ sorgularının geç değerlendirildiğini unutmayın. bu nedenle, ortalama farklar ve bu farkların ortalaması yalnızca bir numaralandırma yapar.)</span><span class="sxs-lookup"><span data-stu-id="fcb53-226">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="fcb53-227">Dizinin yalnızca bir listesini kullanarak standart sapmayı hesaplayan alternatif bir formül vardır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-227">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="fcb53-228">Bu hesaplama, diziyi numaralandırdığından iki değer üretir: dizideki tüm öğelerin toplamı ve her bir değerin kare toplamı:</span><span class="sxs-lookup"><span data-stu-id="fcb53-228">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="fcb53-229">Bu sürüm, diziyi tam olarak bir kez numaralandırır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-229">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="fcb53-230">Ancak yeniden kullanılabilir kod değildir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-230">But it's not reusable code.</span></span> <span data-ttu-id="fcb53-231">Çalışmaya devam ederseniz, birçok farklı istatistiksel hesaplamaların dizideki öğelerin sayısını, sıranın toplamını ve dizi karelerinin toplamını kullanmasını göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-231">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="fcb53-232">Bu yöntemi yeniden düzenleme ve bu değerlerin üçünü de üreten bir yardımcı program yöntemi yazma.</span><span class="sxs-lookup"><span data-stu-id="fcb53-232">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="fcb53-233">Üç değer de bir tanımlama grubu olarak döndürülebilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-233">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="fcb53-234">Bu yöntemi, numaralandırma sırasında hesaplanan üç değerin bir kayıt düzeninde depolanması için güncelleştirelim.</span><span class="sxs-lookup"><span data-stu-id="fcb53-234">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="fcb53-235">Bu sürümü oluşturur:</span><span class="sxs-lookup"><span data-stu-id="fcb53-235">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="fcb53-236">Visual Studio 'nun yeniden düzenleme desteği, çekirdek istatistik işlevlerinin özel bir yönteme ayıklanabilmesini kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-236">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="fcb53-237">Bu,, `private static` ve ' nin üç değeri ile demet türünü döndüren bir yöntem sunar `Sum` `SumOfSquares` `Count` :</span><span class="sxs-lookup"><span data-stu-id="fcb53-237">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]

<span data-ttu-id="fcb53-238">Dil, el ile birkaç hızlı düzenleme yapmak istiyorsanız kullanabileceğiniz birkaç seçenek sağlar.</span><span class="sxs-lookup"><span data-stu-id="fcb53-238">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="fcb53-239">İlk olarak, `var` bildirimi kullanarak yöntem çağrısından kayıt düzeni sonucunu başlatabilirsiniz `ComputeSumAndSumOfSquares` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-239">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="fcb53-240">Ayrıca, yöntemi içinde üç ayrı değişken oluşturabilirsiniz `ComputeSumAndSumOfSquares` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-240">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="fcb53-241">Son sürüm aşağıdaki kodda gösterilmiştir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-241">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="fcb53-242">Bu son sürüm, bu üç değere veya bunların herhangi bir alt kümesine ihtiyacı olan herhangi bir yöntem için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-242">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="fcb53-243">Dil, bu demet döndürme yöntemlerinde öğelerin adlarını yönetmenin diğer seçeneklerini destekler.</span><span class="sxs-lookup"><span data-stu-id="fcb53-243">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="fcb53-244">Dönüş değeri bildiriminden alan adlarını kaldırabilir ve adlandırılmamış bir tanımlama grubu döndürebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="fcb53-244">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="fcb53-245">Bu kayıt düzeninin alanları, ve olarak `Item1` adlandırılır `Item2` `Item3` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-245">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="fcb53-246">Metotlardan döndürülen başlıkların öğelerine anlam isimleri sağlamanız önerilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-246">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="fcb53-247">LINQ sorguları yazarken, tanımlama gruplarının yararlı olabilecek başka bir IOM.</span><span class="sxs-lookup"><span data-stu-id="fcb53-247">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="fcb53-248">Son öngörülen sonuç, seçilen nesnelerin özelliklerinin tümünü değil, genellikle bazılarını içerir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-248">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="fcb53-249">Genellikle sorgunun sonuçlarını anonim bir tür bir nesne dizisine proje olarak projecekti.</span><span class="sxs-lookup"><span data-stu-id="fcb53-249">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="fcb53-250">Bu çok sayıda kısıtlama sunuyordu, öncelikle anonim türler bir yöntem için dönüş türünde kolaylıkla adlandırılamadığından.</span><span class="sxs-lookup"><span data-stu-id="fcb53-250">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="fcb53-251">`object` `dynamic` Sonuç türü olarak veya olarak kullanmanın alternatifleri, önemli performans maliyetleriyle birlikte geldi.</span><span class="sxs-lookup"><span data-stu-id="fcb53-251">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="fcb53-252">Bir demet türü dizisinin döndürülmesi kolaydır ve öğelerin adları ve türleri derleme zamanında ve IDE araçları aracılığıyla kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-252">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="fcb53-253">Örneğin, bir ToDo uygulaması düşünün.</span><span class="sxs-lookup"><span data-stu-id="fcb53-253">For example, consider a ToDo application.</span></span> <span data-ttu-id="fcb53-254">Yapılacaklar listesindeki tek bir girişi göstermek için aşağıdakine benzer bir sınıf tanımlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="fcb53-254">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="fcb53-255">Mobil uygulamalarınız, yalnızca başlığı görüntüleyen geçerli ToDo öğelerinin Compact formunu destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-255">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="fcb53-256">Bu LINQ sorgusu, yalnızca KIMLIĞI ve başlığı içeren bir projeksiyon oluşturacak.</span><span class="sxs-lookup"><span data-stu-id="fcb53-256">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="fcb53-257">Bir tanımlama grubu sırası döndüren bir yöntem tasarımın iyi olduğunu ifade eder:</span><span class="sxs-lookup"><span data-stu-id="fcb53-257">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="fcb53-258">C# 7,1 ' de demet projeksiyonları, anonim türlerde özellik adlandırmasına benzer şekilde, öğeleri kullanarak adlandırılmış tanımlama grupları oluşturmanıza imkan tanır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-258">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="fcb53-259">Yukarıdaki kodda, `select` sorgu projeksiyonun öğesi ve öğeleri içeren bir tanımlama grubu oluşturur `ID` `Title` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-259">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="fcb53-260">Adlandırılmış tanımlama grubu, imzanın bir parçası olabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-260">The named tuple can be part of the signature.</span></span> <span data-ttu-id="fcb53-261">Derleyicinin ve IDE araçlarının, sonucu doğru şekilde kullandığınızı, statik denetim sağlamasına imkan tanır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-261">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="fcb53-262">Adlandırılmış tanımlama grubu statik tür bilgilerini de taşır, bu nedenle, sonuçlarla çalışmak için yansıma veya dinamik bağlama gibi pahalı çalışma süresi özelliklerinin kullanılmasına gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-262">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="fcb53-263">Ayrıştırma</span><span class="sxs-lookup"><span data-stu-id="fcb53-263">Deconstruction</span></span>

<span data-ttu-id="fcb53-264">Bir yöntem tarafından döndürülen kayıt *grubunu kaldırarak bir* kayıt grubundaki tüm öğelerin paketini kaldırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-264">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="fcb53-265">Başlıkların çıkarılması için üç farklı yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-265">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="fcb53-266">İlk olarak, her bir alanın türünü parantez içindeki her bir öğe için ayrı değişkenler oluşturmak üzere açıkça bildirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="fcb53-266">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="fcb53-267">Ayrıca, parantez dışında bir anahtar sözcüğü kullanarak, bir kayıt grubundaki her bir alan için örtük olarak belirlenmiş değişkenler de bildirebilirsiniz `var` :</span><span class="sxs-lookup"><span data-stu-id="fcb53-267">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="fcb53-268">`var`Parantez içinde herhangi bir veya tüm değişken bildirimlerinin anahtar sözcüğünü kullanmak da geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-268">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span>

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="fcb53-269">Kayıt grubundaki her alan aynı türde olsa bile, parantez dışında belirli bir tür kullanamazsınız.</span><span class="sxs-lookup"><span data-stu-id="fcb53-269">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="fcb53-270">Mevcut bildirimlerle de tanımlama gruplarını kaldırabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="fcb53-270">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
> <span data-ttu-id="fcb53-271">Parantez içindeki bildirimlerle mevcut bildirimleri karıştıramazsınız.</span><span class="sxs-lookup"><span data-stu-id="fcb53-271">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="fcb53-272">Örneğin, aşağıdakilere izin verilmez: `(var x, y) = MyMethod();` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-272">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="fcb53-273">*X* , parantez içinde bildirildiği ve *y* daha önce başka bir yerde BILDIRILDIĞI için bu hata CS8184 oluşturur.</span><span class="sxs-lookup"><span data-stu-id="fcb53-273">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="fcb53-274">Kullanıcı tanımlı türleri kaldırma</span><span class="sxs-lookup"><span data-stu-id="fcb53-274">Deconstructing user-defined types</span></span>

<span data-ttu-id="fcb53-275">Herhangi bir demet türü, yukarıda gösterilen şekilde kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-275">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="fcb53-276">Kullanıcı tanımlı herhangi bir tür (sınıflar, yapılar veya hatta arabirimler) üzerinde oluşturmayı etkinleştirmek de kolaydır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-276">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="fcb53-277">Tür yazarı, `Deconstruct` türü oluşturan veri öğelerini temsil eden herhangi bir sayıda [ `out` değişkene](language-reference/keywords/out-parameter-modifier.md) değer atayan bir veya daha fazla yöntem tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-277">The type author can define one or more `Deconstruct` methods that assign values to any number of [`out` variables](language-reference/keywords/out-parameter-modifier.md) representing the data elements that make up the type.</span></span> <span data-ttu-id="fcb53-278">Örneğin, aşağıdaki tür bir `Person` `Deconstruct` kişi nesnesini ilk adı ve soyadı temsil eden öğelere oluşturan bir yöntemi tanımlar:</span><span class="sxs-lookup"><span data-stu-id="fcb53-278">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="fcb53-279">Deyapý yöntemi, `Person` ve özelliklerini temsil eden bir ile iki dizeden atamayı sağlar `FirstName` `LastName` :</span><span class="sxs-lookup"><span data-stu-id="fcb53-279">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="fcb53-280">Yazmayan türler için bile, oluşturmayı etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-280">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="fcb53-281">`Deconstruct`Yöntemi, bir nesnenin erişilebilir veri üyelerini paketten uygulayan bir genişletme yöntemi olabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-281">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="fcb53-282">Aşağıdaki örnekte, `Student` türünden türetilmiş bir tür ve,,, `Person` `Student` ve öğelerini temsil eden üç değişkene bir oluşturan uzantı yöntemi gösterilmektedir `FirstName` `LastName` `GPA` :</span><span class="sxs-lookup"><span data-stu-id="fcb53-282">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="fcb53-283">Bir `Student` nesne artık iki adet erişilebilir `Deconstruct` yönteme sahiptir: türler için belirtilen genişletme yöntemi `Student` ve `Person` türün üyesi.</span><span class="sxs-lookup"><span data-stu-id="fcb53-283">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="fcb53-284">Her ikisi de kapsamdadır ve bir, `Student` iki değişkene veya üçüne parçalanmalarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="fcb53-284">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="fcb53-285">Üç değişkene bir öğrenci atarsanız, ilk ad, soyadı ve GPA döndürülür.</span><span class="sxs-lookup"><span data-stu-id="fcb53-285">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="fcb53-286">İki değişkene bir öğrenci atarsanız, yalnızca ad ve soyadı döndürülür.</span><span class="sxs-lookup"><span data-stu-id="fcb53-286">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="fcb53-287">`Deconstruct`Bir sınıfta veya sınıf hiyerarşisinde birden çok yöntem tanımlamanız dikkatli olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-287">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="fcb53-288">`Deconstruct`Aynı sayıda parametreye sahip birden çok yöntem, `out` belirsizlikleri hızlı bir şekilde neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-288">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="fcb53-289">Çağıranlar, istenen yöntemi kolayca çağıramayabilir `Deconstruct` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-289">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="fcb53-290">Bu örnekte, `Deconstruct` için yönteminin `Person` iki çıkış parametresi olduğundan ve `Deconstruct` için yönteminin üç olması nedeniyle belirsiz bir çağrı için en az şans vardır `Student` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-290">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="fcb53-291">Yinelenenleri kaldırma işleçleri, test eşitliğine katılmaz.</span><span class="sxs-lookup"><span data-stu-id="fcb53-291">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="fcb53-292">Aşağıdaki örnek, CS0019 derleyici hatası oluşturur:</span><span class="sxs-lookup"><span data-stu-id="fcb53-292">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="fcb53-293">`Deconstruct`Yöntemi, `Person` nesneyi `p` iki dize içeren bir kayıt türüne dönüştürebilir, ancak eşitlik testleri bağlamında geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-293">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="tuples-as-out-parameters"></a><span data-ttu-id="fcb53-294">Out parametreleri olarak tanımlama grubu</span><span class="sxs-lookup"><span data-stu-id="fcb53-294">Tuples as out parameters</span></span>

<span data-ttu-id="fcb53-295">Tanımlama grupları, [ `out` parametre](language-reference/keywords/out-parameter-modifier.md) olarak *kullanılabilir.*</span><span class="sxs-lookup"><span data-stu-id="fcb53-295">Tuples can be used as [`out` parameters](language-reference/keywords/out-parameter-modifier.md) *themselves*.</span></span> <span data-ttu-id="fcb53-296">Daha önce [ayrıştırma](#deconstruction) bölümünde bahsedilen belirsizlik ile karıştırılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-296">Not to be confused with any ambiguity previously mentioned in the [Deconstruction](#deconstruction) section.</span></span> <span data-ttu-id="fcb53-297">Bir yöntem çağrısında, yalnızca demet 'in şeklini açıklamanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="fcb53-297">In a method call, you need only describe the tuple's shape:</span></span>

[!code-csharp[TuplesAsOutParameters](~/samples/snippets/csharp/tuples/program.cs#01_TupleAsOutVariable "Tuples as out parameters")]

<span data-ttu-id="fcb53-298">Alternatif olarak, [_adlandırılmamış_](#named-and-unnamed-tuples) bir tanımlama grubu kullanabilir ve alanlarına şu şekilde başvurabilirsiniz `Item1` `Item2` :</span><span class="sxs-lookup"><span data-stu-id="fcb53-298">Alternatively, you could use an [_unnamed_](#named-and-unnamed-tuples) tuple and refer to its fields as `Item1` and `Item2`:</span></span>

```csharp
dict.TryGetValue(2, out (int, string) pair);
// ...
Console.WriteLine($"{pair.Item1}: {pair.Item2}");
```

## <a name="conclusion"></a><span data-ttu-id="fcb53-299">Sonuç</span><span class="sxs-lookup"><span data-stu-id="fcb53-299">Conclusion</span></span>

<span data-ttu-id="fcb53-300">Adlandırılmış tanımlama grupları için yeni dil ve kitaplık desteği, birden çok öğeyi depolayan ancak sınıflar ve yapılar için davranış tanımlamadığınız veri yapılarını kullanan tasarımlarla çalışmayı çok daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="fcb53-300">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="fcb53-301">Bu türler için tanımlama gruplarını kullanmak kolaydır.</span><span class="sxs-lookup"><span data-stu-id="fcb53-301">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="fcb53-302">Daha ayrıntılı veya sözdizimini kullanarak tür yazmak zorunda kalmadan statik tür denetimi avantajlarından yararlanın `class` `struct` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-302">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="fcb53-303">Bu sayede bile, veya olan yardımcı program yöntemleri için en yararlı seçenektir `private` `internal` .</span><span class="sxs-lookup"><span data-stu-id="fcb53-303">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="fcb53-304">`class`Ya da `struct` genel yöntemleriniz birden çok öğeye sahip bir değer döndürzaman, ya da tür Kullanıcı tanımlı türler oluşturun.</span><span class="sxs-lookup"><span data-stu-id="fcb53-304">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
