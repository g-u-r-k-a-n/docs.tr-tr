---
title: Profil Oluşturmaya Genel Bakış
ms.date: 03/30/2017
helpviewer_keywords:
- managed code, profiling API support
- unmanaged code, combining with managed code in profiling
- notification threads [.NET Framework profiling]
- unmanaged code, profiling
- profiling API [.NET Framework], and COM
- profiling API [.NET Framework], unmanaged code profiling
- profilers, writing
- profiling API [.NET Framework], call stacks
- code profilers, writing
- profiling API [.NET Framework], security considerations
- profiling API [.NET Framework], managed code support
- common language runtime, profiling
- profiling API [.NET Framework], notification threads
- call stacks [.NET Framework profiling]
- profiling API [.NET Framework], stack depth
- common language runtime, writing a profiler
- profiling API [.NET Framework], information retrieval interfaces
- shadow stacks [.NET Framework profiling]
- COM, using in the profiling API
- stack snapshots [.NET Framework profiling]
- profiling API [.NET Framework], supported features
- profiling API [.NET Framework], overview
- security, profiling API considerations
- stack depth [.NET Framework profiling]
ms.assetid: 864c2344-71dc-46f9-96b2-ed59fb6427a8
ms.openlocfilehash: 3836b562d969726a6587d702d3edf45abb147d10
ms.sourcegitcommit: 961ec21c22d2f1d55c9cc8a7edf2ade1d1fd92e3
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/02/2020
ms.locfileid: "80588499"
---
# <a name="profiling-overview"></a><span data-ttu-id="5ffb4-102">Profil Oluşturmaya Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="5ffb4-102">Profiling Overview</span></span>

<span data-ttu-id="5ffb4-103">Profil oluşturucu, başka bir uygulamanın yürütülmesini izleyen bir araçtır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-103">A profiler is a tool that monitors the execution of another application.</span></span> <span data-ttu-id="5ffb4-104">Ortak bir dil çalışma zamanı (CLR) profil oluşturucusu profil oluşturma API'sini kullanarak CLR'den ileti alan ve CLR'ye ileti gönderen işlevlerden oluşan dinamik bir bağlantı kitaplığıdır (DLL).</span><span class="sxs-lookup"><span data-stu-id="5ffb4-104">A common language runtime (CLR) profiler is a dynamic link library (DLL) that consists of functions that receive messages from, and send messages to, the CLR by using the profiling API.</span></span> <span data-ttu-id="5ffb4-105">Profil oluşturucu DLL, clr tarafından çalışma zamanında yüklenir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-105">The profiler DLL is loaded by the CLR at run time.</span></span>

<span data-ttu-id="5ffb4-106">Geleneksel profil oluşturma araçları, uygulamanın yürütülmesini ölçmeye odaklanır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-106">Traditional profiling tools focus on measuring the execution of the application.</span></span> <span data-ttu-id="5ffb4-107">Diğer bir deyişle, her işlevde harcanan zamanı veya uygulamanın bellek kullanımını zaman içinde ölçerler.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-107">That is, they measure the time that is spent in each function or the memory usage of the application over time.</span></span> <span data-ttu-id="5ffb4-108">Profil oluşturma API' si, kod kapsama yardımcı programları ve hatta gelişmiş hata ayıklama yardımcıları gibi daha geniş bir tanı araçları sınıfını hedefler.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-108">The profiling API targets a broader class of diagnostic tools such as code-coverage utilities and even advanced debugging aids.</span></span> <span data-ttu-id="5ffb4-109">Bu kullanımların hepsi doğada tanısaldır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-109">These uses are all diagnostic in nature.</span></span> <span data-ttu-id="5ffb4-110">Profil oluşturma API'si yalnızca bir uygulamanın yürütülmesini de ölçer.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-110">The profiling API not only measures but also monitors the execution of an application.</span></span> <span data-ttu-id="5ffb4-111">Bu nedenle, profil oluşturma API'si hiçbir zaman uygulamanın kendisi tarafından kullanılmamalıdır ve uygulamanın yürütülmesi profil oluşturucuya bağlı olmamalıdır (veya bundan etkilenmemelidir).</span><span class="sxs-lookup"><span data-stu-id="5ffb4-111">For this reason, the profiling API should never be used by the application itself, and the application’s execution should not depend on (or be affected by) the profiler.</span></span>

<span data-ttu-id="5ffb4-112">CLR uygulamasının profilini çıkarmak, geleneksel olarak derlenen makine kodunu profillemekten daha fazla destek gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-112">Profiling a CLR application requires more support than profiling conventionally compiled machine code.</span></span> <span data-ttu-id="5ffb4-113">Bunun nedeni, CLR'nin uygulama etki alanları, çöp toplama, yönetilen özel durum işleme, kodun tam zamanında (JIT) derlemesi (Microsoft ara dilini veya MSIL kodu yerel makine koduna dönüştürme) ve benzeri özellikler gibi kavramları tanıtmasıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-113">This is because the CLR introduces concepts such as application domains, garbage collection, managed exception handling, just-in-time (JIT) compilation of code (converting Microsoft intermediate language, or MSIL, code into native machine code), and similar features.</span></span> <span data-ttu-id="5ffb4-114">Geleneksel profil oluşturma mekanizmaları bu özellikleri tanımlayamaz veya bu özellikler hakkında yararlı bilgiler sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-114">Conventional profiling mechanisms cannot identify or provide useful information about these features.</span></span> <span data-ttu-id="5ffb4-115">Profil oluşturma API'si, CLR'nin ve profilli uygulamanın performansı üzerinde en az etkiye sahip, bu eksik bilgileri verimli bir şekilde sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-115">The profiling API provides this missing information efficiently, with minimal effect on the performance of the CLR and the profiled application.</span></span>

<span data-ttu-id="5ffb4-116">Çalışma zamanında JIT derleme profil oluşturma için iyi fırsatlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-116">JIT compilation at run time provides good opportunities for profiling.</span></span> <span data-ttu-id="5ffb4-117">Profil oluşturma API'si, bir profil oluşturucunun JIT derlenmeden önce bir yordam için bellek teki MSIL kod akışını değiştirmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-117">The profiling API enables a profiler to change the in-memory MSIL code stream for a routine before it is JIT-compiled.</span></span> <span data-ttu-id="5ffb4-118">Bu şekilde, profil oluşturucu daha derin bir araştırma gerektiren belirli yordamlara dinamik olarak enstrümantasyon kodu ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-118">In this manner, the profiler can dynamically add instrumentation code to particular routines that need deeper investigation.</span></span> <span data-ttu-id="5ffb4-119">Bu yaklaşım geleneksel senaryolarda mümkün olsa da, profil oluşturma API'sini kullanarak CLR için uygulanması çok daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-119">Although this approach is possible in conventional scenarios, it is much easier to implement for the CLR by using the profiling API.</span></span>

## <a name="the-profiling-api"></a><span data-ttu-id="5ffb4-120">Profil Oluşturma API'si</span><span class="sxs-lookup"><span data-stu-id="5ffb4-120">The Profiling API</span></span>

<span data-ttu-id="5ffb4-121">Genellikle, profil oluşturma API yönetilen bir uygulamanın yürütülmesini izleyen bir program dır bir *kod profil oluşturucu*yazmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-121">Typically, the profiling API is used to write a *code profiler*, which is a program that monitors the execution of a managed application.</span></span>

<span data-ttu-id="5ffb4-122">Profil oluşturma API profili olan uygulama ile aynı işleme yüklenir bir profil dll tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-122">The profiling API is used by a profiler DLL, which is loaded into the same process as the application that is being profiled.</span></span> <span data-ttu-id="5ffb4-123">Profil oluşturucu DLL bir geri arama arabirimi uygular[(ICorProfilerCallback.NET](icorprofilercallback-interface.md) Framework sürüm 1.0 ve 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) sürüm 2.0 ve sonrası).</span><span class="sxs-lookup"><span data-stu-id="5ffb4-123">The profiler DLL implements a callback interface ([ICorProfilerCallback](icorprofilercallback-interface.md) in the .NET Framework version 1.0 and 1.1, [ICorProfilerCallback2](icorprofilercallback2-interface.md) in version 2.0 and later).</span></span> <span data-ttu-id="5ffb4-124">CLR, profil işlemindeki olayların profiloluşturucuya bildirilmesi için bu arabirimdeki yöntemleri çağırır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-124">The CLR calls the methods in that interface to notify the profiler of events in the profiled process.</span></span> <span data-ttu-id="5ffb4-125">Profil oluşturucu, profilli uygulamanın durumu hakkında bilgi edinmek için [ICorProfilerInfo](icorprofilerinfo-interface.md) ve [ICorProfilerInfo2](icorprofilerinfo2-interface.md) arayüzlerinde kullanılan yöntemleri kullanarak çalışma süresine geri çağrıyapabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-125">The profiler can call back into the runtime by using the methods in the [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md) interfaces to obtain information about the state of the profiled application.</span></span>

> [!NOTE]
> <span data-ttu-id="5ffb4-126">Yalnızca profil oluşturucu çözümünün veri toplama bölümü profilli uygulamayla aynı işlemde çalışıyor olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-126">Only the data-gathering part of the profiler solution should be running in the same process as the profiled application.</span></span> <span data-ttu-id="5ffb4-127">Tüm kullanıcı arabirimi ve veri analizi ayrı bir işlemle yapılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-127">All user interface and data analysis should be performed in a separate process.</span></span>

<span data-ttu-id="5ffb4-128">Aşağıdaki resimde profil oluşturucu DLL'nin profil yapılan uygulama ve CLR ile nasıl etkileşimde bulunduğu gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-128">The following illustration shows how the profiler DLL interacts with the application that is being profiled and the CLR.</span></span>

![Profil oluşturma mimarisini gösteren ekran görüntüsü.](./media/profiling-overview/profiling-architecture.png)

### <a name="the-notification-interfaces"></a><span data-ttu-id="5ffb4-130">Bildirim Arayüzleri</span><span class="sxs-lookup"><span data-stu-id="5ffb4-130">The Notification Interfaces</span></span>

<span data-ttu-id="5ffb4-131">[ICorProfilerCallback](icorprofilercallback-interface.md) ve [ICorProfilerCallback2](icorprofilercallback2-interface.md) bildirim arabirimleri olarak kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-131">[ICorProfilerCallback](icorprofilercallback-interface.md) and [ICorProfilerCallback2](icorprofilercallback2-interface.md) can be considered notification interfaces.</span></span> <span data-ttu-id="5ffb4-132">Bu arabirimler [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md)ve [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md)gibi yöntemlerden oluşur.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-132">These interfaces consist of methods such as [ClassLoadStarted](icorprofilercallback-classloadstarted-method.md), [ClassLoadFinished](icorprofilercallback-classloadfinished-method.md), and [JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md).</span></span> <span data-ttu-id="5ffb4-133">CLR bir sınıfı her yüklese veya boşaltsa, bir işlev derlesin ve `ICorProfilerCallback` saire, profiloluşturcunun veya `ICorProfilerCallback2` arabirimindeki ilgili yöntemi çağırır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-133">Each time the CLR loads or unloads a class, compiles a function, and so on, it calls the corresponding method in the profiler's `ICorProfilerCallback` or `ICorProfilerCallback2` interface.</span></span>

<span data-ttu-id="5ffb4-134">Örneğin, bir profil oluşturucu kod performansını iki bildirim işlevi yle ölçebilir: [FunctionEnter2](functionenter2-function.md) ve [FunctionLeave2](functionleave2-function.md).</span><span class="sxs-lookup"><span data-stu-id="5ffb4-134">For example, a profiler could measure code performance through two notification functions: [FunctionEnter2](functionenter2-function.md) and [FunctionLeave2](functionleave2-function.md).</span></span> <span data-ttu-id="5ffb4-135">Her bildirimi yalnızca zaman damgaları, sonuçları birikir ve uygulamanın yürütülmesi sırasında hangi işlevlerin en çok CPU veya duvar saati süresini tükettiğini gösteren bir liste çıkarır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-135">It just time-stamps each notification, accumulates results, and outputs a list that indicates which functions consumed the most CPU or wall-clock time during the execution of the application.</span></span>

### <a name="the-information-retrieval-interfaces"></a><span data-ttu-id="5ffb4-136">Bilgi Alma Arayüzleri</span><span class="sxs-lookup"><span data-stu-id="5ffb4-136">The Information Retrieval Interfaces</span></span>

<span data-ttu-id="5ffb4-137">Profil leme ile ilgili diğer ana arayüzler [ICorProfilerInfo](icorprofilerinfo-interface.md) ve [ICorProfilerInfo2'dir.](icorprofilerinfo2-interface.md)</span><span class="sxs-lookup"><span data-stu-id="5ffb4-137">The other main interfaces involved in profiling are [ICorProfilerInfo](icorprofilerinfo-interface.md) and [ICorProfilerInfo2](icorprofilerinfo2-interface.md).</span></span> <span data-ttu-id="5ffb4-138">Profil oluşturucu, çözümlemesi için daha fazla bilgi elde etmek için bu arabirimleri gerektiği gibi çağırır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-138">The profiler calls these interfaces as required to obtain more information to help its analysis.</span></span> <span data-ttu-id="5ffb4-139">Örneğin, CLR [FunctionEnter2](functionenter2-function.md) işlevini aradığında, bir işlev tanımlayıcısı sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-139">For example, whenever the CLR calls the [FunctionEnter2](functionenter2-function.md) function, it supplies a function identifier.</span></span> <span data-ttu-id="5ffb4-140">Profil oluşturucu, işlevin üst sınıfını, adını ve benzeri bilgileri keşfetmek için [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) yöntemini arayarak bu işlev hakkında daha fazla bilgi edinebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-140">The profiler can get more information about that function by calling the [ICorProfilerInfo2::GetFunctionInfo2](icorprofilerinfo2-getfunctioninfo2-method.md) method to discover the function's parent class, its name, and so on.</span></span>

## <a name="supported-features"></a><span data-ttu-id="5ffb4-141">Desteklenen Özellikler</span><span class="sxs-lookup"><span data-stu-id="5ffb4-141">Supported Features</span></span>

<span data-ttu-id="5ffb4-142">Profil oluşturma API'si, ortak dil çalışma zamanında gerçekleşen çeşitli olaylar ve eylemler hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-142">The profiling API provides information about a variety of events and actions that occur in the common language runtime.</span></span> <span data-ttu-id="5ffb4-143">Bu bilgileri, süreçlerin iç işleyişini izlemek ve .NET Framework uygulamanızın performansını analiz etmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-143">You can use this information to monitor the inner workings of processes and to analyze the performance of your .NET Framework application.</span></span>

<span data-ttu-id="5ffb4-144">Profil oluşturma API' si, CLR' de meydana gelen aşağıdaki eylemler ve olaylar hakkında bilgi alır:</span><span class="sxs-lookup"><span data-stu-id="5ffb4-144">The profiling API retrieves information about the following actions and events that occur in the CLR:</span></span>

- <span data-ttu-id="5ffb4-145">CLR başlatma ve kapatma olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-145">CLR startup and shutdown events.</span></span>

- <span data-ttu-id="5ffb4-146">Uygulama etki alanı oluşturma ve kapatma olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-146">Application domain creation and shutdown events.</span></span>

- <span data-ttu-id="5ffb4-147">Montaj yükleme ve boşaltma olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-147">Assembly loading and unloading events.</span></span>

- <span data-ttu-id="5ffb4-148">Modül yükleme ve boşaltma olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-148">Module loading and unloading events.</span></span>

- <span data-ttu-id="5ffb4-149">COM vtable oluşturma ve imha olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-149">COM vtable creation and destruction events.</span></span>

- <span data-ttu-id="5ffb4-150">Tam zamanında (JIT) derleme ve kod pitching olaylar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-150">Just-in-time (JIT) compilation and code-pitching events.</span></span>

- <span data-ttu-id="5ffb4-151">Sınıf yükleme ve boşaltma olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-151">Class loading and unloading events.</span></span>

- <span data-ttu-id="5ffb4-152">İş parçacığı oluşturma ve imha olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-152">Thread creation and destruction events.</span></span>

- <span data-ttu-id="5ffb4-153">İşlev giriş ve çıkış olayları.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-153">Function entry and exit events.</span></span>

- <span data-ttu-id="5ffb4-154">Özel durum.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-154">Exceptions.</span></span>

- <span data-ttu-id="5ffb4-155">Yönetilen ve yönetilmeyen kod yürütme arasındaki geçişler.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-155">Transitions between managed and unmanaged code execution.</span></span>

- <span data-ttu-id="5ffb4-156">Farklı çalışma zamanı bağlamları arasında geçişler.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-156">Transitions between different runtime contexts.</span></span>

- <span data-ttu-id="5ffb4-157">Çalışma zamanı askıya almalar hakkında bilgi.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-157">Information about runtime suspensions.</span></span>

- <span data-ttu-id="5ffb4-158">Çalışma zamanı bellek yığını ve çöp toplama etkinliği hakkında bilgi.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-158">Information about the runtime memory heap and garbage collection activity.</span></span>

<span data-ttu-id="5ffb4-159">Profil oluşturma API'si, COM uyumlu herhangi bir dilden çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-159">The profiling API can be called from any (non-managed) COM-compatible language.</span></span>

<span data-ttu-id="5ffb4-160">API, CPU ve bellek tüketimi açısından etkilidir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-160">The API is efficient with regard to CPU and memory consumption.</span></span> <span data-ttu-id="5ffb4-161">Profil oluşturma, yanıltıcı sonuçlara neden olacak kadar önemli olan profilli uygulamada değişiklikler içermez.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-161">Profiling does not involve changes to the profiled application that are significant enough to cause misleading results.</span></span>

<span data-ttu-id="5ffb4-162">Profil oluşturma API'si hem örnekleme hem de örnekleme yapmayan profilciler için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-162">The profiling API is useful to both sampling and non-sampling profilers.</span></span> <span data-ttu-id="5ffb4-163">Örnekleme *profiloluşturucusu* profili normal saat işaretlerinde inceler, örneğin, 5 milisaniye arayla.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-163">A *sampling profiler* inspects the profile at regular clock ticks, say, at 5 milliseconds apart.</span></span> <span data-ttu-id="5ffb4-164">Örnekleme olmayan bir *profil oluşturucu,* olaya neden olan iş parçacığıyla eşzamanlı olarak bir olay hakkında bilgilendirilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-164">A *non-sampling profiler* is informed of an event synchronously with the thread that causes the event.</span></span>

### <a name="unsupported-functionality"></a><span data-ttu-id="5ffb4-165">Desteklenmeyen İşlev</span><span class="sxs-lookup"><span data-stu-id="5ffb4-165">Unsupported Functionality</span></span>

<span data-ttu-id="5ffb4-166">Profil oluşturma API'si aşağıdaki işlevselliği desteklemez:</span><span class="sxs-lookup"><span data-stu-id="5ffb4-166">The profiling API does not support the following functionality:</span></span>

- <span data-ttu-id="5ffb4-167">Geleneksel Win32 yöntemleri kullanılarak profillenilmesi gereken yönetilmeyen kod.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-167">Unmanaged code, which must be profiled using conventional Win32 methods.</span></span> <span data-ttu-id="5ffb4-168">Ancak, CLR profil oluşturucu, yönetilen ve yönetilmeyen kod arasındaki sınırları belirlemek için geçiş olayları içerir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-168">However, the CLR profiler includes transition events to determine the boundaries between managed and unmanaged code.</span></span>

- <span data-ttu-id="5ffb4-169">Kendi kodlarını boy odaklı programlama gibi amaçlarla değiştiren kendi kendini değiştiren uygulamalar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-169">Self-modifying applications that modify their own code for purposes such as aspect-oriented programming.</span></span>

- <span data-ttu-id="5ffb4-170">Profil oluşturma API'si bu bilgileri sağlamadığından, sınır denetimi.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-170">Bounds checking, because the profiling API does not provide this information.</span></span> <span data-ttu-id="5ffb4-171">CLR, yönetilen tüm kodların sınır denetimi için içsel destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-171">The CLR provides intrinsic support for bounds checking of all managed code.</span></span>

- <span data-ttu-id="5ffb4-172">Aşağıdaki nedenlerle desteklenmeyen uzaktan profil oluşturma:</span><span class="sxs-lookup"><span data-stu-id="5ffb4-172">Remote profiling, which is not supported for the following reasons:</span></span>

  - <span data-ttu-id="5ffb4-173">Uzaktan profil oluşturma yürütme süresini uzalar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-173">Remote profiling extends execution time.</span></span> <span data-ttu-id="5ffb4-174">Profil oluşturma arabirimlerini kullandığınızda, profil oluşturma sonuçlarının gereksiz yere etkilenmemesi için yürütme süresini en aza indirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-174">When you use the profiling interfaces, you must minimize execution time so that profiling results will not be unduly affected.</span></span> <span data-ttu-id="5ffb4-175">Yürütme performansı izlenirken bu özellikle doğrudur.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-175">This is especially true when execution performance is being monitored.</span></span> <span data-ttu-id="5ffb4-176">Ancak, profil oluşturma arabirimleri bellek kullanımını izlemek veya yığın çerçeveleri, nesneler ve benzeri hakkında çalışma zamanı bilgileri elde etmek için kullanıldığında uzaktan profil oluşturma bir sınırlama değildir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-176">However, remote profiling is not a limitation when the profiling interfaces are used to monitor memory usage or to obtain run-time information about stack frames, objects, and so on.</span></span>

  - <span data-ttu-id="5ffb4-177">CLR kod profillayıcısı, profilli uygulamanın çalıştırıldığı yerel bilgisayarda çalışma süresiyle birlikte bir veya daha fazla geri arama arabirimi kaydetmelidir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-177">The CLR code profiler must register one or more callback interfaces with the runtime on the local computer on which the profiled application is running.</span></span> <span data-ttu-id="5ffb4-178">Bu, uzak kod profiloluşturabilme yeteneğini sınırlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-178">This limits the ability to create a remote code profiler.</span></span>

## <a name="notification-threads"></a><span data-ttu-id="5ffb4-179">Bildirim Konuları</span><span class="sxs-lookup"><span data-stu-id="5ffb4-179">Notification Threads</span></span>

<span data-ttu-id="5ffb4-180">Çoğu durumda, bir olay oluşturan iş parçacığı da bildirimleri yürütür.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-180">In most cases, the thread that generates an event also executes notifications.</span></span> <span data-ttu-id="5ffb4-181">Bu tür bildirimlerin (örneğin, [FunctionEnter](functionenter-function.md) ve [FunctionLeave)](functionleave-function.md) `ThreadID`açık bir şekilde sağlanmasıgerekmez.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-181">Such notifications (for example, [FunctionEnter](functionenter-function.md) and [FunctionLeave](functionleave-function.md)) do not need to supply the explicit `ThreadID`.</span></span> <span data-ttu-id="5ffb4-182">Ayrıca, profil oluşturucu, etkilenen iş parçacığına dayalı `ThreadID` olarak çözümleme bloklarını küresel depolamada dizine ekinyapmak yerine çözüm leme bloklarını depolamak ve güncelleştirmek için iş parçacığı yerel depolamasını kullanmaya karar verebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-182">Also, the profiler might decide to use thread-local storage to store and update its analysis blocks instead of indexing the analysis blocks in global storage, based on the `ThreadID` of the affected thread.</span></span>

<span data-ttu-id="5ffb4-183">Bu geri aramaların seri hale getirilemediğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-183">Note that these callbacks are not serialized.</span></span> <span data-ttu-id="5ffb4-184">Kullanıcılar, iş parçacığı namına veri yapıları oluşturarak ve birden çok iş parçacığından paralel erişimi önlemek için gerektiğinde profil oluşturucu kodunu kilitleyerek kodlarını korumalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-184">Users must protect their code by creating thread-safe data structures and by locking the profiler code where necessary to prevent parallel access from multiple threads.</span></span> <span data-ttu-id="5ffb4-185">Bu nedenle, bazı durumlarda alışılmadık bir geri arama dizisi alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-185">Therefore, in certain cases you can receive an unusual sequence of callbacks.</span></span> <span data-ttu-id="5ffb4-186">Örneğin, yönetilen bir uygulamanın aynı kodu çalıştıran iki iş parçacığı yumurtladığını varsayalım.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-186">For example, assume that a managed application is spawning two threads that are executing identical code.</span></span> <span data-ttu-id="5ffb4-187">Bu durumda, [iCorProfilerCallback almak mümkündür::JITCompilationBir](icorprofilercallback-jitcompilationstarted-method.md) iş parçacığı bazı işlev `FunctionEnter` ve ICorProfilerCallback almadan önce diğer iş parçacığı bir geri arama için olay [başladı::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) geri arama.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-187">In this case, it is possible to receive a [ICorProfilerCallback::JITCompilationStarted](icorprofilercallback-jitcompilationstarted-method.md) event for some function from one thread and a `FunctionEnter` callback from the other thread before receiving the [ICorProfilerCallback::JITCompilationFinished](icorprofilercallback-jitcompilationfinished-method.md) callback.</span></span> <span data-ttu-id="5ffb4-188">Bu durumda, kullanıcı henüz `FunctionEnter` tam olarak tam zamanında (JIT) derlenmiş olmayan bir işlev için bir geri arama alır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-188">In this case, the user will receive a `FunctionEnter` callback for a function that may not have been fully just-in-time (JIT) compiled yet.</span></span>

## <a name="security"></a><span data-ttu-id="5ffb4-189">Güvenlik</span><span class="sxs-lookup"><span data-stu-id="5ffb4-189">Security</span></span>

<span data-ttu-id="5ffb4-190">Profil oluşturucu DLL, ortak dil çalışma zamanı yürütme altyapısının bir parçası olarak çalışan yönetilmeyen bir DLL'dir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-190">A profiler DLL is an unmanaged DLL that runs as part of the common language runtime execution engine.</span></span> <span data-ttu-id="5ffb4-191">Sonuç olarak, profil oluşturucu DLL'deki kod yönetilen kod erişim güvenliği kısıtlamalarına tabi değildir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-191">As a result, the code in the profiler DLL is not subject to the restrictions of managed code access security.</span></span> <span data-ttu-id="5ffb4-192">Profil oluşturucu DLL üzerindeki tek sınırlamalar, işletim sistemi tarafından profilli uygulamayı çalıştıran kullanıcıya uygulanan sınırlamalardır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-192">The only limitations on the profiler DLL are those imposed by the operating system on the user who is running the profiled application.</span></span>

<span data-ttu-id="5ffb4-193">Profiler yazarları güvenlikle ilgili sorunları önlemek için uygun önlemleri almalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-193">Profiler authors should take appropriate precautions to avoid security-related issues.</span></span> <span data-ttu-id="5ffb4-194">Örneğin, yükleme sırasında, kötü amaçlı bir kullanıcının değiştirememesi için bir profil oluşturucu DLL'nin bir erişim denetim listesine (ACL) eklenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-194">For example, during installation, a profiler DLL should be added to an access control list (ACL) so that a malicious user cannot modify it.</span></span>

## <a name="combining-managed-and-unmanaged-code-in-a-code-profiler"></a><span data-ttu-id="5ffb4-195">Yönetilen ve Yönetilmeyen Kodu Kod Profilleyicisinde Birleştirme</span><span class="sxs-lookup"><span data-stu-id="5ffb4-195">Combining Managed and Unmanaged Code in a Code Profiler</span></span>

<span data-ttu-id="5ffb4-196">Yanlış yazılmış bir profil oluşturucu, kendisine dairesel başvurular alabildiği gibi öngörülemeyen davranışlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-196">An incorrectly written profiler can cause circular references to itself, resulting in unpredictable behavior.</span></span>

<span data-ttu-id="5ffb4-197">CLR profil oluşturma API'sinin gözden geçirilmesi, COM interop veya dolaylı aramalar aracılığıyla birbirini çağıran yönetilen ve yönetilmeyen bileşenler içeren bir profil oluşturabileceğiniz izlenimini oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-197">A review of the CLR profiling API may create the impression that you can write a profiler that contains managed and unmanaged components that call each other through COM interop or indirect calls.</span></span>

<span data-ttu-id="5ffb4-198">Bu, tasarım açısından mümkün olsa da, profil oluşturma API'si yönetilen bileşenleri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-198">Although this is possible from a design perspective, the profiling API does not support managed components.</span></span> <span data-ttu-id="5ffb4-199">Bir CLR profiloluşturucu tamamen yönetilmemiş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-199">A CLR profiler must be completely unmanaged.</span></span> <span data-ttu-id="5ffb4-200">Yönetilen ve yönetilmeyen kodu clr profiloluşturcayında birleştirme girişimleri erişim ihlallerine, program hatasına veya kilitlenmelere neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-200">Attempts to combine managed and unmanaged code in a CLR profiler may cause access violations, program failure, or deadlocks.</span></span> <span data-ttu-id="5ffb4-201">Profil oluşturucunun yönetilen bileşenleri olayları yönetilmeyen bileşenlerine geri döndürecek ve bu da yönetilen bileşenleri yeniden çağırarak dairesel başvurulara yol açacaktır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-201">The managed components of the profiler will fire events back to their unmanaged components, which would subsequently call the managed components again, resulting in circular references.</span></span>

<span data-ttu-id="5ffb4-202">Bir CLR profiloluşturucunun yönetilen kodu güvenli bir şekilde arayabildiği tek konum, bir yöntemin Microsoft ara dili (MSIL) gövdesindedir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-202">The only location where a CLR profiler can call managed code safely is in the Microsoft intermediate language (MSIL) body of a method.</span></span> <span data-ttu-id="5ffb4-203">MSIL gövdesini değiştirmek için önerilen [uygulama, ICorProfilerCallback4](icorprofilercallback4-interface.md) arabirimindeki JIT yeniden derleme yöntemlerini kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-203">The recommended practice for modifying the MSIL body is to use the  JIT recompilation methods in the [ICorProfilerCallback4](icorprofilercallback4-interface.md) interface.</span></span>

<span data-ttu-id="5ffb4-204">MSIL'i değiştirmek için eski enstrümantasyon yöntemlerini kullanmak da mümkündür.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-204">It is also possible to use the older instrumentation methods to modify MSIL.</span></span> <span data-ttu-id="5ffb4-205">Bir işlevin tam zamanında (JIT) derlemesi tamamlanmadan önce, profil oluşturucu bir yöntemin MSIL gövdesine yönetilen çağrıları ekleyebilir ve ardından JIT-derleme yapabilir [(Bkz. ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) yöntemi).</span><span class="sxs-lookup"><span data-stu-id="5ffb4-205">Before the just-in-time (JIT) compilation of a function is completed, the profiler can insert managed calls in the MSIL body of a method and then JIT-compile it (see the [ICorProfilerInfo::GetILFunctionBody](icorprofilerinfo-getilfunctionbody-method.md) method).</span></span> <span data-ttu-id="5ffb4-206">Bu teknik, yönetilen kodun seçici araçları için veya JIT hakkında istatistik ve performans verileri toplamak için başarıyla kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-206">This technique can successfully be used for selective instrumentation of managed code, or to gather statistics and performance data about the JIT.</span></span>

<span data-ttu-id="5ffb4-207">Alternatif olarak, bir kod profilleyicisi, yönetilmeyen koda çağıran her yönetilen işlevin MSIL gövdesine yerel kancalar ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-207">Alternatively, a code profiler can insert native hooks in the MSIL body of every managed function that calls into unmanaged code.</span></span> <span data-ttu-id="5ffb4-208">Bu teknik enstrümantasyon ve kapsama için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-208">This technique can be used for instrumentation and coverage.</span></span> <span data-ttu-id="5ffb4-209">Örneğin, bir kod profilleyicisi, bloğun yürütüldünlü olduğundan emin olmak için her MSIL bloğundan sonra enstrümantasyon kancaları ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-209">For example, a code profiler could insert instrumentation hooks after every MSIL block to ensure that the block has been executed.</span></span> <span data-ttu-id="5ffb4-210">Bir yöntemin MSIL gövdesinin modifikasyonu çok hassas bir işlemdir ve dikkate alınması gereken birçok faktör vardır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-210">The modification of the MSIL body of a method is a very delicate operation, and there are many factors that should be taken into consideration.</span></span>

## <a name="profiling-unmanaged-code"></a><span data-ttu-id="5ffb4-211">Yönetilmeyen Kodu Profil Oluşturma</span><span class="sxs-lookup"><span data-stu-id="5ffb4-211">Profiling Unmanaged Code</span></span>

<span data-ttu-id="5ffb4-212">Ortak dil çalışma zamanı (CLR) profil oluşturma API, yönetilmeyen kodu profil oluşturma için en az destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-212">The common language runtime (CLR) profiling API provides minimal support for profiling unmanaged code.</span></span> <span data-ttu-id="5ffb4-213">Aşağıdaki işlevsellik sağlanır:</span><span class="sxs-lookup"><span data-stu-id="5ffb4-213">The following functionality is provided:</span></span>

- <span data-ttu-id="5ffb4-214">Yığın zincirlerinin numaralandırması.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-214">Enumeration of stack chains.</span></span> <span data-ttu-id="5ffb4-215">Bu özellik, yönetilen kod ve yönetilmeyen kod arasındaki sınırı belirlemek için bir kod profiloluşturucu sağlar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-215">This feature enables a code profiler to determine the boundary between managed code and unmanaged code.</span></span>

- <span data-ttu-id="5ffb4-216">Yığın zincirinin yönetilen koda mı yoksa yerel koda mı karşılık olduğunu belirleme.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-216">Determination whether a stack chain corresponds to managed code or native code.</span></span>

<span data-ttu-id="5ffb4-217">.NET Framework sürümleri 1.0 ve 1.1'de, bu yöntemler CLR hata ayıklama API'sinin işlem içi alt kümesi aracılığıyla kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-217">In the .NET Framework versions 1.0 and 1.1, these methods are available through the in-process subset of the CLR debugging API.</span></span> <span data-ttu-id="5ffb4-218">Bunlar CorDebug.idl dosyasında tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-218">They are defined in the CorDebug.idl file.</span></span>

<span data-ttu-id="5ffb4-219">.NET Framework 2.0 ve sonraki durumlarda, bu işlevsellik için [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) yöntemini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-219">In the .NET Framework 2.0 and later, you can use the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method for this functionality.</span></span>

## <a name="using-com"></a><span data-ttu-id="5ffb4-220">COM'u kullanma</span><span class="sxs-lookup"><span data-stu-id="5ffb4-220">Using COM</span></span>

<span data-ttu-id="5ffb4-221">Profil oluşturma arabirimleri COM arabirimleri olarak tanımlansa da, ortak dil çalışma süresi (CLR) aslında bu arabirimleri kullanmak için COM'u başlatmaz.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-221">Although the profiling interfaces are defined as COM interfaces, the common language runtime (CLR) does not actually initialize COM to use these interfaces.</span></span> <span data-ttu-id="5ffb4-222">Bunun nedeni, yönetilen uygulama nın istenen iş parçacığı modelini belirtme şansı elde etmeden önce [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) işlevini kullanarak iş parçacığı modelini ayarlamak zorunda kalmamaktır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-222">The reason is to avoid having to set the threading model by using the [CoInitialize](/windows/desktop/api/objbase/nf-objbase-coinitialize) function before the managed application has had a chance to specify its desired threading model.</span></span> <span data-ttu-id="5ffb4-223">Benzer şekilde, profil oluşturucunun `CoInitialize`kendisi aramamalıdır, çünkü profillegösterilen uygulamayla uyumsuz bir iş parçacığı modeli seçebilir ve uygulamanın başarısız olmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-223">Similarly, the profiler itself should not call `CoInitialize`, because it may pick a threading model that is incompatible with the application being profiled and may cause the application to fail.</span></span>

## <a name="call-stacks"></a><span data-ttu-id="5ffb4-224">Çağrı Yığınları</span><span class="sxs-lookup"><span data-stu-id="5ffb4-224">Call Stacks</span></span>

<span data-ttu-id="5ffb4-225">Profil oluşturma API'si çağrı yığınları elde etmek için iki yol sağlar: çağrı yığınlarının seyrek bir şekilde toplanmasını sağlayan bir yığın anlık görüntü yöntemi ve her anda çağrı yığınını izleyen bir gölge yığını yöntemi.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-225">The profiling API provides two ways to obtain call stacks: a stack snapshot method, which enables sparse gathering of call stacks, and a shadow stack method, which tracks the call stack at every instant.</span></span>

### <a name="stack-snapshot"></a><span data-ttu-id="5ffb4-226">Anlık Görüntü Yığını</span><span class="sxs-lookup"><span data-stu-id="5ffb4-226">Stack Snapshot</span></span>

<span data-ttu-id="5ffb4-227">Yığın anlık görüntüsü, bir iş parçacığı yığınının bir anda zaman içinde izlenmesidir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-227">A stack snapshot is a trace of the stack of a thread at an instant in time.</span></span> <span data-ttu-id="5ffb4-228">Profil oluşturma API yığını üzerinde yönetilen işlevlerin izlenmesini destekler, ancak profillenmemiş işlevlerin izlenmesini profiloluşturcunun kendi yığın yürütücüse bırakır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-228">The profiling API supports the tracing of managed functions on the stack, but it leaves the tracing of unmanaged functions to the profiler's own stack walker.</span></span>

<span data-ttu-id="5ffb4-229">Yönetilen yığınları yürümek için profiloluşturucu program hakkında daha fazla bilgi için, bu dokümantasyon kümesinde [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) yöntemi ve [Profiler Stack Yürüyüş .NET Framework 2.0: Temelleri ve Ötesi](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="5ffb4-229">For more information about how to program the profiler to walk managed stacks, see the [ICorProfilerInfo2::DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) method in this documentation set, and [Profiler Stack Walking in the .NET Framework 2.0: Basics and Beyond](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).</span></span>

### <a name="shadow-stack"></a><span data-ttu-id="5ffb4-230">Gölge Yığını</span><span class="sxs-lookup"><span data-stu-id="5ffb4-230">Shadow Stack</span></span>

<span data-ttu-id="5ffb4-231">Anlık görüntü yöntemini çok sık kullanmak hızlı bir performans sorunu oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-231">Using the snapshot method too frequently can quickly create a performance issue.</span></span> <span data-ttu-id="5ffb4-232">Yığın izlerini sık sık almak istiyorsanız, profilciniz bunun yerine [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md)ve [ICorProfilerCallback2](icorprofilercallback2-interface.md) özel durum geri aramaları kullanarak bir gölge yığını oluşturmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-232">If you want to take stack traces frequently, your profiler should instead build a shadow stack by using the [FunctionEnter2](functionenter2-function.md), [FunctionLeave2](functionleave2-function.md), [FunctionTailcall2](functiontailcall2-function.md), and [ICorProfilerCallback2](icorprofilercallback2-interface.md) exception callbacks.</span></span> <span data-ttu-id="5ffb4-233">Gölge yığını her zaman geçerlidir ve yığın anlık görüntüsü gerektiğinde hızla depolama alanına kopyalanabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-233">The shadow stack is always current and can quickly be copied to storage whenever a stack snapshot is needed.</span></span>

<span data-ttu-id="5ffb4-234">Gölge yığını işlev bağımsız değişkenleri, döndürme değerleri ve genel anlık bilgiler edinebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-234">A shadow stack may obtain function arguments, return values, and information about generic instantiations.</span></span> <span data-ttu-id="5ffb4-235">Bu bilgiler yalnızca gölge yığını aracılığıyla kullanılabilir ve denetim bir işleve verildiğinde elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-235">This information is available only through the shadow stack and may be obtained when control is handed to a function.</span></span> <span data-ttu-id="5ffb4-236">Ancak, bu bilgiler daha sonra işlevin çalıştırılması sırasında kullanılamayabilir.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-236">However, this information may not be available later during the run of the function.</span></span>

## <a name="callbacks-and-stack-depth"></a><span data-ttu-id="5ffb4-237">Geri Aramalar ve Yığın Derinliği</span><span class="sxs-lookup"><span data-stu-id="5ffb4-237">Callbacks and Stack Depth</span></span>

<span data-ttu-id="5ffb4-238">Profiler geri aramaları çok yığın kısıtlı durumlarda verilebilir ve profilci geri aramasında yığın taşma hemen bir işlem çıkışına yol açar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-238">Profiler callbacks may be issued in very stack-constrained circumstances, and a stack overflow in a profiler callback will lead to an immediate process exit.</span></span> <span data-ttu-id="5ffb4-239">Bir profil oluşturucu, geri aramalara yanıt olarak mümkün olduğunca az yığın kullandığınızdan emin olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-239">A profiler should make sure to use as little stack as possible in response to callbacks.</span></span> <span data-ttu-id="5ffb4-240">Profil oluşturucu, yığın taşmasına karşı sağlam olan işlemlere karşı kullanılmak üzere tasarlanmıştırsa, profilcinin kendisi de yığın taşmasını tetiklemekten kaçınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-240">If the profiler is intended for use against processes that are robust against stack overflow, the profiler itself should also avoid triggering stack overflow.</span></span>

## <a name="related-topics"></a><span data-ttu-id="5ffb4-241">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="5ffb4-241">Related Topics</span></span>

|<span data-ttu-id="5ffb4-242">Başlık</span><span class="sxs-lookup"><span data-stu-id="5ffb4-242">Title</span></span>|<span data-ttu-id="5ffb4-243">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5ffb4-243">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="5ffb4-244">Profil Oluşturma Ortamını Ayarlama</span><span class="sxs-lookup"><span data-stu-id="5ffb4-244">Setting Up a Profiling Environment</span></span>](setting-up-a-profiling-environment.md)|<span data-ttu-id="5ffb4-245">Profil oluşturucunun nasıl başharfe atılabildiğini, olay bildirimlerini nasıl ayarladığını ve bir Windows Hizmetinin profilini nasıl oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup oluşturup</span><span class="sxs-lookup"><span data-stu-id="5ffb4-245">Explains how to initialize a profiler, set event notifications, and profile a Windows Service.</span></span>|
|[<span data-ttu-id="5ffb4-246">Profil Oluşturma Arabirimleri</span><span class="sxs-lookup"><span data-stu-id="5ffb4-246">Profiling Interfaces</span></span>](profiling-interfaces.md)|<span data-ttu-id="5ffb4-247">Profil oluşturma API'sinin kullandığı yönetilmeyen arabirimleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-247">Describes the unmanaged interfaces that the profiling API uses.</span></span>|
|[<span data-ttu-id="5ffb4-248">Profil Oluşturma Genel Statik İşlevleri</span><span class="sxs-lookup"><span data-stu-id="5ffb4-248">Profiling Global Static Functions</span></span>](profiling-global-static-functions.md)|<span data-ttu-id="5ffb4-249">Profil oluşturma API'sinin kullandığı yönetilmeyen genel statik işlevleri açıklar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-249">Describes the unmanaged global static functions that the profiling API uses.</span></span>|
|[<span data-ttu-id="5ffb4-250">Profil Oluşturma Sabit Listeleri</span><span class="sxs-lookup"><span data-stu-id="5ffb4-250">Profiling Enumerations</span></span>](profiling-enumerations.md)|<span data-ttu-id="5ffb4-251">Profil oluşturma API'sinin kullandığı yönetilmeyen sayısallaştırmaları açıklar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-251">Describes the unmanaged enumerations that the profiling API uses.</span></span>|
|[<span data-ttu-id="5ffb4-252">Profil Oluşturma Yapıları</span><span class="sxs-lookup"><span data-stu-id="5ffb4-252">Profiling Structures</span></span>](profiling-structures.md)|<span data-ttu-id="5ffb4-253">Profil oluşturma API'sinin kullandığı yönetilmeyen yapıları açıklar.</span><span class="sxs-lookup"><span data-stu-id="5ffb4-253">Describes the unmanaged structures that the profiling API uses.</span></span>|
