---
title: Büyük Veriler ve Akış Yapma
ms.date: 03/30/2017
ms.assetid: ab2851f5-966b-4549-80ab-c94c5c0502d2
ms.openlocfilehash: 91e53f66fb0f2f94a315c318eb0b203d78427bae
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79184673"
---
# <a name="large-data-and-streaming"></a><span data-ttu-id="25e69-102">Büyük Veriler ve Akış Yapma</span><span class="sxs-lookup"><span data-stu-id="25e69-102">Large Data and Streaming</span></span>

<span data-ttu-id="25e69-103">Windows Communication Foundation (WCF) XML tabanlı bir iletişim altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-103">Windows Communication Foundation (WCF) is an XML-based communications infrastructure.</span></span> <span data-ttu-id="25e69-104">XML verileri genellikle [XML 1.0 belirtiminde](https://www.w3.org/TR/REC-xml/)tanımlanan standart metin biçiminde kodlandığı için, bağlı sistem geliştiricileri ve mimarlar genellikle ağ üzerinden gönderilen iletilerin tel ayak izi (veya boyutu) ile ilgilidir ve XML'nin metin tabanlı kodlaması ikili verilerin verimli aktarımı için özel zorluklar oluşturur.</span><span class="sxs-lookup"><span data-stu-id="25e69-104">Because XML data is commonly encoded in the standard text format defined in the [XML 1.0 specification](https://www.w3.org/TR/REC-xml/), connected systems developers and architects are typically concerned about the wire footprint (or size) of messages sent across the network, and the text-based encoding of XML poses special challenges for the efficient transfer of binary data.</span></span>  
  
## <a name="basic-considerations"></a><span data-ttu-id="25e69-105">Temel Hususlar</span><span class="sxs-lookup"><span data-stu-id="25e69-105">Basic Considerations</span></span>  
 <span data-ttu-id="25e69-106">WCF için aşağıdaki bilgiler hakkında arka plan bilgileri sağlamak için, bu bölümde, genellikle bağlı sistem altyapıları için geçerli olan kodlamalar, ikili veriler ve akış la ilgili bazı genel endişeler ve hususlar vurgulanır.</span><span class="sxs-lookup"><span data-stu-id="25e69-106">To provide background information about the following information for WCF, this section highlights some general concerns and considerations for encodings, binary data, and streaming that generally apply to connected systems infrastructures.</span></span>  
  
### <a name="encoding-data-text-vs-binary"></a><span data-ttu-id="25e69-107">Kodlama Verileri: Metin vs İkili</span><span class="sxs-lookup"><span data-stu-id="25e69-107">Encoding Data: Text vs. Binary</span></span>  
 <span data-ttu-id="25e69-108">Yaygın olarak ifade edilen geliştirici endişeleri, xml'in başlangıç etiketleri ve bitiş etiketlerinin yinelenen doğası nedeniyle ikili biçimlerle karşılaştırıldığında önemli ek yükü olduğu, sayısal değerlerin kodlanmasının önemli ölçüde daha büyük olduğu algısını içerir metin değerleri yle ifade edildikleri ve ikili verilerin metin biçimine katıştırılması için özel olarak kodlanmaları gerektiğinden verimli bir şekilde ifade edilemeyeceği için.</span><span class="sxs-lookup"><span data-stu-id="25e69-108">Commonly expressed developer concerns include the perception that XML has significant overhead when compared to binary formats due to the repetitive nature of start tags and end tags, that the encoding of numerical values is considered to be significantly larger because they are expressed in text values, and that binary data cannot be expressed efficiently because it must be specially encoded for embedding into a text format.</span></span>  
  
 <span data-ttu-id="25e69-109">Bu ve benzer kaygıların çoğu geçerli olmakla birlikte, XML Web hizmetleri ortamındaXML metin kodlanmış iletiler ile eski bir uzak yordam çağrısı (RPC) ortamındaki ikili kodlanmış iletiler arasındaki gerçek fark genellikle çok daha az ilk dikkate önerebilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-109">While many of these and similar concerns are valid, the actual difference between XML-text encoded messages in an XML Web services environment and binary-encoded messages in a legacy remote procedure call (RPC) environment is often much less significant than the initial consideration might suggest.</span></span>  
  
 <span data-ttu-id="25e69-110">XML-metin kodlanmış iletiler saydam ve "insan tarafından okunabilir" olsa da, ikili iletiler genellikle karşılaştırma da oldukça belirsizdir ve araçlar olmadan çözülmesi zordur.</span><span class="sxs-lookup"><span data-stu-id="25e69-110">While XML-text encoded messages are transparent and "human readable", binary messages are often fairly obscure in comparison and difficult to decode without tools.</span></span> <span data-ttu-id="25e69-111">Okunabilirlikteki bu fark, ikili iletilerin genellikle yükte satır altı meta verileri taşıdığını göz ardı etmeye yol açar ve bu da xml metin iletilerinde olduğu gibi genel ek yük ekler.</span><span class="sxs-lookup"><span data-stu-id="25e69-111">This difference in legibility leads one to overlook that binary messages also often carry inline metadata in the payload, which adds overhead just as with XML text messages.</span></span> <span data-ttu-id="25e69-112">Bu, gevşek bağlantı ve dinamik çağırma özellikleri sağlamayı amaçlayan ikili biçimler için özellikle geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-112">This is specifically true for binary formats that aim to provide loose-coupling and dynamic invocation capabilities.</span></span>  
  
 <span data-ttu-id="25e69-113">Ancak, ikili biçimler genellikle aşağıdaki veri kayıtları için veri düzenini bildiren bir "üstbilgi" içinde bu tür açıklayıcı meta veri bilgilerini taşır.</span><span class="sxs-lookup"><span data-stu-id="25e69-113">However, binary formats commonly carry such descriptive metadata information in a "header," which also declares the data layout for the following data records.</span></span> <span data-ttu-id="25e69-114">Taşıma daha sonra bu ortak meta veri bloğu bildirimini en az ek yük ile izler.</span><span class="sxs-lookup"><span data-stu-id="25e69-114">The payload then follows this common metadata block declaration with minimal further overhead.</span></span> <span data-ttu-id="25e69-115">Bunun aksine, XML her veri öğesini bir öğeye veya öznitelike içine, böylece çevreleyen meta verilerin her serileştirilmiş yük nesnesi için tekrar tekrar dahil edilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-115">In contrast, XML encloses each data item in an element or attribute so that the enclosing metadata is repetitively included for each serialized payload object.</span></span> <span data-ttu-id="25e69-116">Sonuç olarak, bazı açıklayıcı meta veriler her ikisi için de ifade edilmesi gerektiğinden, tek bir serileştirilmiş yük nesnesinin boyutu, metinle ikili gösterimlerle karşılaştırıldığında benzerdir, ancak ikili biçim her ek ile paylaşılan meta veri açıklamasından yararlanır daha düşük genel ek yük nedeniyle aktarılan yük nesnesi.</span><span class="sxs-lookup"><span data-stu-id="25e69-116">As a result, the size of a single serialized payload object is similar when comparing text to binary representations as some descriptive metadata must be expressed for both, but the binary format benefits from the shared metadata description with each additional payload object that is transferred due to the lower overall overhead.</span></span>  
  
 <span data-ttu-id="25e69-117">Yine de, sayılar gibi belirli veri türleri için, düz metin gösterimi birkaç bayt daha küçük olabileceğinden, düz metin gösterimi yerine 128 bit ondalık yazı gibi sabit boyutlu, ikili sayısal gösterimler kullanmanın bir dezavantajı olabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-117">Still, for certain data types, such as numbers, there might be a disadvantage to using fixed-size, binary numerical representations, such as a 128-bit decimal type instead of plain text, as the plain text representation might be several bytes smaller.</span></span> <span data-ttu-id="25e69-118">Metin verilerinin genellikle daha esnek XML metin kodlama seçeneklerinden boyut avantajları olabilir, ancak bazı ikili biçimler .NET İkili XML Biçimi için geçerli olmayan 16 bit ve hatta 32 bit Unicode varsayılan olarak varsayılan olabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-118">Text data also might have size benefits from the typically more flexible XML text encoding choices, while some binary formats might default to 16-bit or even 32-bit Unicode, which does not apply to the .NET Binary XML Format.</span></span>  
  
 <span data-ttu-id="25e69-119">Sonuç olarak, metin veya ikili arasında karar vermek, ikili iletilerin her zaman XML-metin iletilerinden daha küçük olduğunu varsaymak kadar kolay değildir.</span><span class="sxs-lookup"><span data-stu-id="25e69-119">As a result, deciding between text or binary is not quite as easy as assuming that binary messages are always smaller than XML-text messages.</span></span>  
  
 <span data-ttu-id="25e69-120">XML metin mesajlarının açık bir avantajı, standartlara dayalı olmaları ve en geniş birlikte çalışabilirlik seçenekleri ve platform desteği seçenekleri sunabildikleridir.</span><span class="sxs-lookup"><span data-stu-id="25e69-120">A clear advantage of XML-text messages is that they are standards-based and offer the broadest choice of interoperability options and platform support.</span></span> <span data-ttu-id="25e69-121">Daha fazla bilgi için bu konunun ilerleyen bölümlerindeki "Kodlamalar" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="25e69-121">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="binary-content"></a><span data-ttu-id="25e69-122">İkili İçerik</span><span class="sxs-lookup"><span data-stu-id="25e69-122">Binary Content</span></span>  
 <span data-ttu-id="25e69-123">İkili kodlamaların, ortaya çıkan ileti boyutu açısından metin tabanlı kodlamalardan daha üstün olduğu bir alan, resimler, videolar, ses klipleri veya hizmetler ile bunların arasında değiş tokuş edilmesi gereken herhangi bir opak, ikili veri biçimi gibi büyük ikili veri öğeleridir. Tüketici.</span><span class="sxs-lookup"><span data-stu-id="25e69-123">One area where binary encodings are superior to text-based encodings in terms of the resulting message size are large binary data items such as pictures, videos, sound clips, or any other form of opaque, binary data that must be exchanged between services and their consumers.</span></span> <span data-ttu-id="25e69-124">Bu tür verileri XML metnine sığdırmak için ortak yaklaşım, bunları Base64 kodlamasını kullanarak kodlamaktır.</span><span class="sxs-lookup"><span data-stu-id="25e69-124">To fit these types of data into XML text, the common approach is to encode them using the Base64 encoding.</span></span>  
  
 <span data-ttu-id="25e69-125">Base64 kodlanmış bir dizede, her karakter orijinal 8-bit verilerin 6 bitini temsil eder ve bu da Base64 için 4:3 kodlama ek yükü oranıyla sonuçlanır ve genellikle kural kuralı tarafından eklenen ek biçimlendirme karakterlerini (satır başı/satır akışı) saymaz.</span><span class="sxs-lookup"><span data-stu-id="25e69-125">In a Base64-encoded string, each character represents 6-bits of the original 8-bit data, which results in a 4:3 encoding-overhead ratio for Base64, not counting extra formatting characters (carriage return/line feed) that are commonly added by convention.</span></span> <span data-ttu-id="25e69-126">XML ve ikili kodlamalar arasındaki farkların önemi genellikle senaryoya bağlı olsa da, 500 MB'lık bir yükü aktarırken %33'ten fazla bir boyut kazancı genellikle kabul edilemez.</span><span class="sxs-lookup"><span data-stu-id="25e69-126">While the significance of the differences between XML and binary encodings typically depends on the scenario, a size gain of more than 33% when transmitting a 500-MB payload is usually not acceptable.</span></span>  
  
 <span data-ttu-id="25e69-127">Bu kodlama yükü önlemek için, İleti Aktarım Optimizasyonu Mekanizması (MTOM) standardı, iletide bulunan büyük veri öğelerini dışsallaştırmaya ve iletiyle birlikte herhangi bir özel kodlama olmaksızın ikili veri olarak taşımaya olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="25e69-127">To avoid this encoding overhead, the Message Transmission Optimization Mechanism (MTOM) standard allows for externalizing large data elements that are contained in a message and carrying them with the message as binary data without any special encoding.</span></span> <span data-ttu-id="25e69-128">MTOM ile iletiler, ekleri veya gömülü içerik (resimler ve diğer katıştırılmış içerik) içeren Basit Posta Aktarım Protokolü (SMTP) e-posta iletilerine benzer şekilde değiştirilir; MTOM iletileri çok parçalı/ilişkili MIME dizileri olarak paketlenir ve kök kısmı gerçek SOAP iletisi dir.</span><span class="sxs-lookup"><span data-stu-id="25e69-128">With MTOM, messages are exchanged in a similar fashion to Simple Mail Transfer Protocol (SMTP) email messages with attachments or embedded content (pictures and other embedded content); MTOM messages are packaged as multipart/related MIME sequences with the root part being the actual SOAP message.</span></span>  
  
 <span data-ttu-id="25e69-129">Bir MTOM SOAP iletisi, kodlanmamış sürümünden değiştirilir, böylece ilgili MIME parçalarına başvuran özel öğe etiketleri ikili veri içeren iletideki özgün öğelerin yerini alır.</span><span class="sxs-lookup"><span data-stu-id="25e69-129">An MTOM SOAP message is modified from its un-encoded version so that special element tags that refer to the respective MIME parts take the place of the original elements in the message that contained binary data.</span></span> <span data-ttu-id="25e69-130">Sonuç olarak, SOAP iletisi onunla gönderilen MIME parçaları işaret ederek ikili içerik anlamına gelir, ama aksi takdirde sadece XML metin verileri taşır.</span><span class="sxs-lookup"><span data-stu-id="25e69-130">As a result, the SOAP message refers to binary content by pointing to the MIME parts sent with it, but otherwise just carries XML text data.</span></span> <span data-ttu-id="25e69-131">Bu model iyi kurulmuş SMTP modeliyle yakından uyumlu olduğundan, birçok platformda MTOM iletilerini kodlamak ve çözmek için geniş bir araç desteği vardır, bu da onu son derece birlikte çalışabilir bir seçim yapar.</span><span class="sxs-lookup"><span data-stu-id="25e69-131">Because this model is closely aligned with the well-established SMTP model, there is broad tooling support to encode and decode MTOM messages on many platforms, which makes it an extremely interoperable choice.</span></span>  
  
 <span data-ttu-id="25e69-132">Yine de, Base64'te olduğu gibi, MTOM da MIME formatı için gerekli bazı ek yükü ile birlikte gelir, böylece MTOM kullanmanın avantajları yalnızca ikili veri elemanının boyutu yaklaşık 1 KB'yi aştığında görülür.</span><span class="sxs-lookup"><span data-stu-id="25e69-132">Still, as with Base64, MTOM also comes with some necessary overhead for the MIME format, so that advantages of using MTOM are only seen when the size of a binary data element exceeds about 1 KB.</span></span> <span data-ttu-id="25e69-133">Genel ek yük nedeniyle, ikili yük bu eşiğin altında kalırsa, MTOM kodlu iletiler ikili veriler için Base64 kodlamasını kullanan iletilerden daha büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-133">Due to the overhead, MTOM-encoded messages might be larger than messages that use Base64 encoding for binary data, if the binary payload remains under that threshold.</span></span> <span data-ttu-id="25e69-134">Daha fazla bilgi için bu konunun ilerleyen bölümlerindeki "Kodlamalar" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="25e69-134">For more information, see the "Encodings" section later in this topic.</span></span>  
  
### <a name="large-data-content"></a><span data-ttu-id="25e69-135">Büyük Veri İçeriği</span><span class="sxs-lookup"><span data-stu-id="25e69-135">Large Data Content</span></span>  
 <span data-ttu-id="25e69-136">Tel ayak izi bir yana, daha önce bahsedilen 500 MB'lık yük de hizmet ve istemci için büyük bir yerel sorun teşkil etmektedir.</span><span class="sxs-lookup"><span data-stu-id="25e69-136">Wire-footprint aside, the previously mentioned 500-MB payload also poses a great local challenge at for the service and the client.</span></span> <span data-ttu-id="25e69-137">Varsayılan olarak, WCF iletileri *arabelleğe alınan modda*işler.</span><span class="sxs-lookup"><span data-stu-id="25e69-137">By default, WCF processes messages in *buffered mode*.</span></span> <span data-ttu-id="25e69-138">Bu, iletinin tüm içeriğinin gönderilmeden önce veya alındıktan sonra bellekte bulunduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="25e69-138">This means that the entire content of a message is present in memory before it is sent or after it is received.</span></span> <span data-ttu-id="25e69-139">Bu çoğu senaryo için iyi bir strateji olsa da ve dijital imzalar ve güvenilir teslim gibi mesajlaşma özellikleri için gerekli olsa da, büyük iletiler bir sistemin kaynaklarını tüketebilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-139">While that is a good strategy for most scenarios, and necessary for messaging features such as digital signatures and reliable delivery, large messages could exhaust a system's resources.</span></span>  
  
 <span data-ttu-id="25e69-140">Büyük yüklerle başa çıkma stratejisi akıyor.</span><span class="sxs-lookup"><span data-stu-id="25e69-140">The strategy to deal with large payloads is streaming.</span></span> <span data-ttu-id="25e69-141">İletiler, özellikle XML'de ifade edileniletiler genellikle nispeten kompakt veri paketleri olarak düşünülse de, iletinin boyutu birden çok gigabayt olabilir ve bir veri paketinden daha fazla sürekli veri akışına benzeyebilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-141">While messages, especially those expressed in XML, are commonly thought of as being relatively compact data packages, a message might be multiple gigabytes in size and resemble a continuous data stream more than a data package.</span></span> <span data-ttu-id="25e69-142">Veriler arabelleğe alınan mod yerine akış modunda aktarıldığında, gönderen ileti gövdesinin içeriğini akış biçiminde alıcının kullanımına gönderir ve ileti altyapısı verileri gönderenden alıcıya sürekli olarak iletir Kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-142">When data is transferred in streaming mode instead of buffered mode, the sender makes the contents of the message body available to the recipient in the form of a stream and the message infrastructure continuously forwards the data from sender to receiver as it becomes available.</span></span>  
  
 <span data-ttu-id="25e69-143">Bu tür büyük veri içerik aktarımlarının gerçekleştiği en yaygın senaryo, ikili veri nesnelerinin aktarımlarıdır:</span><span class="sxs-lookup"><span data-stu-id="25e69-143">The most common scenario in which such large data content transfers occur are transfers of binary data objects that:</span></span>  
  
- <span data-ttu-id="25e69-144">İleti dizisine kolayca bölünemez.</span><span class="sxs-lookup"><span data-stu-id="25e69-144">Cannot be easily broken up into a message sequence.</span></span>  
  
- <span data-ttu-id="25e69-145">Zamanında teslim edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-145">Must be delivered in a timely manner.</span></span>  
  
- <span data-ttu-id="25e69-146">Aktarım başlatıldığında bunların bütünüyle kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="25e69-146">Are not available in their entirety when the transfer is initiated.</span></span>  
  
 <span data-ttu-id="25e69-147">Bu kısıtlamalara sahip olmayan veriler için, genellikle bir büyük iletiyerine bir oturum kapsamında ileti dizileri göndermek daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-147">For data that does not have these constraints, it is typically better to send sequences of messages within the scope of a session than one large message.</span></span> <span data-ttu-id="25e69-148">Daha fazla bilgi için bu konunun ilerleyen bölümlerindeki "Veri Akışı" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="25e69-148">For more information, see the "Streaming Data" section later in this topic.</span></span>  
  
 <span data-ttu-id="25e69-149">Büyük miktarda veri `maxAllowedContentLength` gönderirken IIS ayarını (daha fazla bilgi için [IIS İstek Limitlerini Yapılandırmaya](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)bakın) ve `maxReceivedMessageSize` bağlayıcı ayarı (örneğin <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A> [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) veya) ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="25e69-149">When sending large amounts of data you will need to set the `maxAllowedContentLength` IIS setting (for more information see [Configuring IIS Request Limits](https://docs.microsoft.com/iis/configuration/system.webServer/security/requestFiltering/requestLimits/)) and the `maxReceivedMessageSize` binding setting (for example [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) or <xref:System.ServiceModel.NetTcpBinding.MaxReceivedMessageSize%2A>).</span></span> <span data-ttu-id="25e69-150">Özellik `maxAllowedContentLength` varsayılan olarak 28,6 MB `maxReceivedMessageSize` ve özellik varsayılan olarak 64KB'dir.</span><span class="sxs-lookup"><span data-stu-id="25e69-150">The `maxAllowedContentLength` property defaults to 28.6 MB and the `maxReceivedMessageSize` property defaults to 64KB.</span></span>  
  
## <a name="encodings"></a><span data-ttu-id="25e69-151">Kodlamalar</span><span class="sxs-lookup"><span data-stu-id="25e69-151">Encodings</span></span>  
 <span data-ttu-id="25e69-152">*Kodlama,* iletilerin kabloya nasıl sunulacağını anlatan bir dizi kural tanımlar.</span><span class="sxs-lookup"><span data-stu-id="25e69-152">An *encoding* defines a set of rules about how to present messages on the wire.</span></span> <span data-ttu-id="25e69-153">Bir *kodlayıcı* böyle bir kodlama yı uygular ve gönderen tarafında, bellek <xref:System.ServiceModel.Channels.Message> içi bir akışın veya ağ üzerinden gönderilebilen bayt arabelleğine dönüştürülmesinden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="25e69-153">An *encoder* implements such an encoding and is responsible, on the sender side, for turning an in-memory <xref:System.ServiceModel.Channels.Message> into a byte stream or byte buffer that can be sent across the network.</span></span> <span data-ttu-id="25e69-154">Alıcı tarafında, kodlayıcı bir bayt dizisini bellek içi iletiye dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="25e69-154">On the receiver side, the encoder turns a sequence of bytes into an in-memory message.</span></span>  
  
 <span data-ttu-id="25e69-155">WCF üç kodlayıcı içerir ve gerekirse kendi kodlayıcılarınızı yazmanızı ve takmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="25e69-155">WCF includes three encoders and allows you to write and plug in your own encoders, if necessary.</span></span>  
  
 <span data-ttu-id="25e69-156">Standart bağlamaların her biri önceden yapılandırılmış bir kodlayıcı içerir, böylece Net\* önekiile bağlanan bağlayıcılar ikili <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> kodlayıcıyı <xref:System.ServiceModel.BasicHttpBinding> <xref:System.ServiceModel.WSHttpBinding> (sınıfı dahil ederek) kullanırken, sınıflar <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> metin iletisi kodlayıcısını (sınıf aracılığı ile) varsayılan olarak kullanır.</span><span class="sxs-lookup"><span data-stu-id="25e69-156">Each of the standard bindings includes a preconfigured encoder, whereby the bindings with the Net\* prefix use the binary encoder (by including the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> class) while the <xref:System.ServiceModel.BasicHttpBinding> and <xref:System.ServiceModel.WSHttpBinding> classes use the text message encoder (by means of the <xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement> class) by default.</span></span>  
  
|<span data-ttu-id="25e69-157">Kodlayıcı bağlama öğesi</span><span class="sxs-lookup"><span data-stu-id="25e69-157">Encoder binding element</span></span>|<span data-ttu-id="25e69-158">Açıklama</span><span class="sxs-lookup"><span data-stu-id="25e69-158">Description</span></span>|  
|-----------------------------|-----------------|  
|<xref:System.ServiceModel.Channels.TextMessageEncodingBindingElement>|<span data-ttu-id="25e69-159">Metin iletisi kodlayıcısı, tüm HTTP tabanlı bağlamalar için varsayılan kodlayıcıdır ve birlikte çalışabilirliğin en yüksek sorun olduğu tüm özel bağlamalar için uygun seçimdir.</span><span class="sxs-lookup"><span data-stu-id="25e69-159">The text message encoder is the default encoder for all HTTP-based bindings and the appropriate choice for all custom bindings where interoperability is the highest concern.</span></span> <span data-ttu-id="25e69-160">Bu kodlayıcı, ikili veriler için özel bir işlem olmadan standart SOAP 1.1/SOAP 1.2 metin mesajlarını okur ve yazar.</span><span class="sxs-lookup"><span data-stu-id="25e69-160">This encoder reads and writes standard SOAP 1.1/SOAP 1.2 text messages with no special handling for binary data.</span></span> <span data-ttu-id="25e69-161">Bir <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> iletinin özelliği <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, SOAP zarf sarıcı çıktıdan atlanır ve yalnızca ileti gövdesi içeriği seri hale getirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="25e69-161">If the <xref:System.ServiceModel.Channels.MessageVersion?displayProperty=nameWithType> property of a message is set to <xref:System.ServiceModel.Channels.MessageVersion.None?displayProperty=nameWithType>, the SOAP envelope wrapper is omitted from the output and only the message body content is serialized.</span></span>|  
|<xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement>|<span data-ttu-id="25e69-162">MTOM ileti kodlayıcısı, ikili veriler için özel işleme uygulayan bir metin kodlayıcısıdır ve standart bağlamaların hiçbirinde varsayılan olarak kullanılmaz, çünkü bu kesinlikle tek tek optimizasyon yardımcı programıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-162">The MTOM message encoder is a text encoder that implements special handling for binary data and is not used by default in any of the standard bindings because it is strictly a case-by-case optimization utility.</span></span> <span data-ttu-id="25e69-163">İleti, MTOM kodlamasının bir yarar sağladığı bir eşiği aşan ikili veri içeriyorsa, veriler ileti zarfını izleyen bir MIME bölümüne dışsallaştırılır.</span><span class="sxs-lookup"><span data-stu-id="25e69-163">If the message contains binary data that exceeds a threshold where MTOM encoding yields a benefit, the data is externalized into a MIME part following the message envelope.</span></span> <span data-ttu-id="25e69-164">Daha sonra bu bölümde MTOM'u etkinleştirme bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="25e69-164">See Enabling MTOM later in this section.</span></span>|  
|<xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement>|<span data-ttu-id="25e69-165">İkili ileti kodlayıcısı, Net\* bağlamaları için varsayılan kodlayıcıdır ve her iki iletişim tarafı wcf'ye dayalı olduğunda uygun seçimdir.</span><span class="sxs-lookup"><span data-stu-id="25e69-165">The binary message encoder is the default encoder for the Net\* bindings and the appropriate choice whenever both communicating parties are based on WCF.</span></span> <span data-ttu-id="25e69-166">İkili ileti kodlayıcısı, xml bilgi kümeleri (Bilgi Kümeleri) için Microsoft'a özgü bir ikili gösterim olan ve genellikle eşdeğer XML 1.0 gösteriminden daha küçük bir ayak izi sağlayan ve ikili verileri bayt olarak kodlayan .NET İkili XML Biçimini kullanır Akışı.</span><span class="sxs-lookup"><span data-stu-id="25e69-166">The binary message encoder uses the .NET Binary XML Format, a Microsoft-specific binary representation for XML Information Sets (Infosets) that generally yields a smaller footprint than the equivalent XML 1.0 representation and encodes binary data as a byte stream.</span></span>|  
  
 <span data-ttu-id="25e69-167">Metin iletisi kodlaması genellikle birlikte çalışabilirlik gerektiren herhangi bir iletişim yolu için en iyi seçimdir, ikili ileti kodlaması ise diğer iletişim yolu için en iyi seçimdir.</span><span class="sxs-lookup"><span data-stu-id="25e69-167">Text message encoding is typically the best choice for any communication path that requires interoperability, while binary message encoding is the best choice for any other communication path.</span></span> <span data-ttu-id="25e69-168">İkili ileti kodlaması genellikle tek bir iletinin metniyle karşılaştırıldığında daha küçük ileti boyutları ve iletişim oturumu süresince giderek daha küçük ileti boyutları verir.</span><span class="sxs-lookup"><span data-stu-id="25e69-168">Binary message encoding typically yields smaller message sizes compared to text for a single message and progressively even smaller message sizes over the duration of a communication session.</span></span> <span data-ttu-id="25e69-169">Metin kodlamanın aksine, ikili kodlama, Base64'ü kullanmak gibi ikili veriler için özel işleme kullanmak zorunda değildir, ancak baytları bayt olarak temsil eder.</span><span class="sxs-lookup"><span data-stu-id="25e69-169">Unlike text encoding, binary encoding does not have to use special handling for binary data, such as using Base64, but represents bytes as bytes.</span></span>  
  
 <span data-ttu-id="25e69-170">Çözümünüz birlikte çalışabilirlik gerektiriyorsa, ancak yine de HTTP aktarımını <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> kullanmak istiyorsanız, taşıma <xref:System.ServiceModel.Channels.HttpTransportBindingElement> için sınıfı kullanan özel bir bağlama oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25e69-170">If your solution does not require interoperability, but you still want to use HTTP transport, you can compose the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> into a custom binding that uses the <xref:System.ServiceModel.Channels.HttpTransportBindingElement> class for the transport.</span></span> <span data-ttu-id="25e69-171">Hizmetinizdeki birkaç istemci birlikte çalışabilirlik gerektiriyorsa, her birinin etkinleştirilen ilgili istemciler için uygun aktarım ve kodlama seçeneklerine sahip olduğu paralel uç noktaları ortaya çıkarmanız önerilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-171">If a number of clients on your service require interoperability, it is recommended that you expose parallel endpoints that each has the appropriate transport and encoding choices for the respective clients enabled.</span></span>  
  
### <a name="enabling-mtom"></a><span data-ttu-id="25e69-172">MTOM'u etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="25e69-172">Enabling MTOM</span></span>  
 <span data-ttu-id="25e69-173">Birlikte çalışabilirlik bir gereklilik olduğunda ve büyük ikili verilerin gönderilmesi gerektiğinde, <xref:System.ServiceModel.BasicHttpBinding> MTOM ileti kodlaması, <xref:System.ServiceModel.WSHttpBinding> ilgili `MessageEncoding` özelliği <xref:System.ServiceModel.WSMessageEncoding.Mtom> <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> bir . <xref:System.ServiceModel.Channels.CustomBinding></span><span class="sxs-lookup"><span data-stu-id="25e69-173">When interoperability is a requirement and large binary data must be sent, then MTOM message encoding is the alternative encoding strategy that you can enable on the standard <xref:System.ServiceModel.BasicHttpBinding> or <xref:System.ServiceModel.WSHttpBinding> bindings by setting the respective `MessageEncoding` property to <xref:System.ServiceModel.WSMessageEncoding.Mtom> or by composing the <xref:System.ServiceModel.Channels.MtomMessageEncodingBindingElement> into a <xref:System.ServiceModel.Channels.CustomBinding>.</span></span> <span data-ttu-id="25e69-174">MTOM Kodlama örneğinden çıkarılan aşağıdaki örnek kod, Yapılandırmada [MTOM'un](../../../../docs/framework/wcf/samples/mtom-encoding.md) nasıl etkinleştirilen olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="25e69-174">The following example code, extracted from the [MTOM Encoding](../../../../docs/framework/wcf/samples/mtom-encoding.md) sample demonstrates how to enable MTOM in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <wsHttpBinding>  
        <binding name="ExampleBinding" messageEncoding="Mtom"/>  
      </wsHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="25e69-175">Daha önce de belirtildiği gibi, MTOM kodlamasını kullanma kararı gönderdiğiniz veri hacmine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-175">As mentioned earlier, the decision to use MTOM encoding depends on the data volume you are sending.</span></span> <span data-ttu-id="25e69-176">Ayrıca, MTOM bağlama düzeyinde etkinleştirildiğinden, MTOM'un belirli bir bitiş noktasındaki tüm işlemleri etkilemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="25e69-176">Also, because MTOM is enabled at the binding level, enabling MTOM affects all operations on a given endpoint.</span></span>  
  
 <span data-ttu-id="25e69-177">MTOM kodlayıcısı, ikili verilerin dışsallaştırılıp sonuçlanmadığına bakılmaksızın her zaman MTOM kodlu bir MIME/çok parçalı ileti yayan lardan, genellikle yalnızca 1 KB'den fazla ikili veri ile ileti alışverişinde bulunan uç noktalar için MTOM'u etkinleştirmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="25e69-177">Because the MTOM encoder always emits an MTOM-encoded MIME/multi-part message regardless of whether binary data ends up being externalized, you should generally only enable MTOM for endpoints that exchange messages with more than 1 KB of binary data.</span></span> <span data-ttu-id="25e69-178">Ayrıca, MTOM özellikli uç noktalarıyla kullanılmak üzere tasarlanmış hizmet sözleşmeleri, mümkün olduğunda bu tür veri aktarım işlemlerini belirtmekle sınırlandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-178">Also, the service contracts designed for use with MTOM-enabled endpoints should, when possible, be constrained to specifying such data transfer operations.</span></span> <span data-ttu-id="25e69-179">İlgili denetim işlevselliği ayrı bir sözleşmede yer almalıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-179">Related control functionality should reside on a separate contract.</span></span> <span data-ttu-id="25e69-180">Bu "Yalnızca MTOM" kuralı yalnızca MTOM etkin bir bitiş noktası üzerinden gönderilen iletiler için geçerlidir; MTOM kodlayıcısı gelen MTOM olmayan iletileri de çözebilir ve ayrıştabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-180">This "MTOM-only" rule applies only to messages sent through an MTOM-enabled endpoint; the MTOM-encoder can decode and parse incoming non-MTOM messages as well.</span></span>  
  
 <span data-ttu-id="25e69-181">MTOM kodlayıcının kullanılması diğer tüm WCF özellikleriyle uyumlu.</span><span class="sxs-lookup"><span data-stu-id="25e69-181">Using the MTOM encoder conforms with all other WCF features.</span></span> <span data-ttu-id="25e69-182">Oturum desteğinin gerekli olduğu durumlar gibi tüm durumlarda bu kurala uymanın mümkün olmayabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="25e69-182">Note that it may not be possible to observe this rule in all cases, such as when session support is required.</span></span>  
  
### <a name="programming-model"></a><span data-ttu-id="25e69-183">Programlama Modeli</span><span class="sxs-lookup"><span data-stu-id="25e69-183">Programming Model</span></span>  
 <span data-ttu-id="25e69-184">Uygulamanızda kullandığınız üç yerleşik kodlayıcıdan hangisiolursa olsun, programlama deneyimi ikili veri aktarımı açısından aynıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-184">Regardless of which of the three built-in encoders you use in your application, the programming experience is identical with regards to transferring binary data.</span></span> <span data-ttu-id="25e69-185">Fark, WCF'nin verileri veri türlerine göre nasıl işlediğidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-185">The difference is in how WCF handles the data based on their data types.</span></span>  
  
```csharp
[DataContract]  
class MyData  
{  
    [DataMember]  
    byte[] binaryBuffer;  
    [DataMember]  
    string someStringData;  
}
```  
  
 <span data-ttu-id="25e69-186">MTOM kullanılırken, önceki veri sözleşmesi aşağıdaki kurallara göre seri hale getirilir:</span><span class="sxs-lookup"><span data-stu-id="25e69-186">When using MTOM, the preceding data contract is serialized according to the following rules:</span></span>  
  
- <span data-ttu-id="25e69-187">Base64 kodlaması ile karşılaştırıldığında MTOM dışsallaştırma yükü (MIME üstbilgileri vb.) haklı çıkarmak için yeterli veri `binaryBuffer` içermiyorsa `null` ve tek tek içeriyorsa, veriler dışsallaştırılır ve iletiyle ikili MIME parçası olarak taşınır.</span><span class="sxs-lookup"><span data-stu-id="25e69-187">If `binaryBuffer` is not `null` and individually contains enough data to justify the MTOM externalization overhead (MIME headers, and so on) when compared to Base64 encoding, the data is externalized and carried with the message as a binary MIME part.</span></span> <span data-ttu-id="25e69-188">Eşik aşıldığında, veriler Base64 olarak kodlanır.</span><span class="sxs-lookup"><span data-stu-id="25e69-188">If the threshold is not exceeded, the data is encoded as Base64.</span></span>  
  
- <span data-ttu-id="25e69-189">Dize (ve ikili olmayan diğer tüm türler) boyutu ne olursa olsun, her zaman ileti gövdesi içinde bir dize olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-189">The string (and all other types that are not binary) is always represented as a string inside the message body, regardless of size.</span></span>  
  
 <span data-ttu-id="25e69-190">MTOM kodlamaüzerindeki etkisi, önceki örnekte gösterildiği gibi açık bir veri sözleşmesi kullanıp kullanmadığınız, bir işlemde parametre listesi kullansanız, veri sözleşmelerini iç içe mi yoksa bir veri sözleşmesi nesnesini bir koleksiyona aktarSanız aynıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-190">The effect on the MTOM encoding is the same whether you use an explicit data contract, as shown in the preceding example, use a parameter list in an operation, have nested data contracts, or transfer a data contract object inside a collection.</span></span> <span data-ttu-id="25e69-191">Bayt dizileri her zaman optimizasyon için adaydır ve optimizasyon eşikleri karşılanıyorsa en iyi duruma getirilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-191">Byte arrays are always candidates for optimization and are optimized if the optimization thresholds are being met.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="25e69-192">Veri sözleşmeleri içinde <xref:System.IO.Stream?displayProperty=nameWithType> türetilmiş türleri kullanmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="25e69-192">You should not be using <xref:System.IO.Stream?displayProperty=nameWithType> derived types inside of data contracts.</span></span> <span data-ttu-id="25e69-193">Akış verileri aşağıdaki "Veri Akışı" bölümünde açıklanan akış modeli kullanılarak iletilmelidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-193">Stream data should be communicated using the streaming model, explained in the following "Streaming Data" section.</span></span>  
  
## <a name="streaming-data"></a><span data-ttu-id="25e69-194">Veri Akışı</span><span class="sxs-lookup"><span data-stu-id="25e69-194">Streaming Data</span></span>  
 <span data-ttu-id="25e69-195">Aktarım için büyük miktarda veri varsa, WCF'deki akış aktarım modu, iletileri bellekte tümüyle arabelleğe alma ve işleme varsayılan davranışına uygun bir alternatiftir.</span><span class="sxs-lookup"><span data-stu-id="25e69-195">When you have a large amount of data to transfer, the streaming transfer mode in WCF is a feasible alternative to the default behavior of buffering and processing messages in memory in their entirety.</span></span>  
  
 <span data-ttu-id="25e69-196">Daha önce de belirtildiği gibi, veriler bölümlere ayrılamıyorsa, iletizamanında teslim edilmesi gerekiyorsa veya aktarım başlatıldığında veriler henüz tam olarak kullanılamıyorsa, yalnızca büyük iletiler (metin veya ikili içerikli) için akışı etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="25e69-196">As mentioned earlier, enable streaming only for large messages (with text or binary content) if the data cannot be segmented, if the message must be delivered in a timely fashion, or if the data is not yet fully available when the transfer is initiated.</span></span>  
  
### <a name="restrictions"></a><span data-ttu-id="25e69-197">Kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="25e69-197">Restrictions</span></span>  
 <span data-ttu-id="25e69-198">Akış etkinleştirildiğinde önemli sayıda WCF özelliği kullanamazsınız:</span><span class="sxs-lookup"><span data-stu-id="25e69-198">You cannot use a significant number of WCF features when streaming is enabled:</span></span>  
  
- <span data-ttu-id="25e69-199">İleti gövdesi için dijital imzalar gerçekleştirilemez, çünkü tüm ileti içeriği üzerinde bir karma bilgisayar gerektirir.</span><span class="sxs-lookup"><span data-stu-id="25e69-199">Digital signatures for the message body cannot be performed because they require computing a hash over the entire message contents.</span></span> <span data-ttu-id="25e69-200">Akış la birlikte, ileti üstbilgisi oluşturulduğunda ve gönderildiğinde içerik tam olarak kullanılamaz ve bu nedenle dijital imza hesaplanamaz.</span><span class="sxs-lookup"><span data-stu-id="25e69-200">With streaming, the content is not fully available when the message headers are constructed and sent and, therefore, a digital signature cannot be computed.</span></span>  
  
- <span data-ttu-id="25e69-201">Şifreleme, verilerin doğru şekilde yeniden oluşturuldurıldığını doğrulamak için dijital imzalara bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-201">Encryption depends on digital signatures to verify that the data has been reconstructed correctly.</span></span>  
  
- <span data-ttu-id="25e69-202">İleti transferde kaybolursa, güvenilir oturumlar istemciye gönderilen iletileri yeniden teslim etmek üzere arabelleğe almalı ve iletilerin alınması durumunda ileti siparişini korumak için hizmet uygulamasına teslim etmeden önce iletileri hizmette tutmalı sıra dışı.</span><span class="sxs-lookup"><span data-stu-id="25e69-202">Reliable sessions must buffer sent messages on the client for redelivery if a message gets lost in transfer and must hold messages on the service before handing them to the service implementation to preserve message order in case messages are received out-of-sequence.</span></span>  
  
 <span data-ttu-id="25e69-203">Bu işlevsel kısıtlamalar nedeniyle, akış için yalnızca aktarım düzeyinde güvenlik seçeneklerini kullanabilirsiniz ve güvenilir oturumları açamazsınız.</span><span class="sxs-lookup"><span data-stu-id="25e69-203">Because of these functional constraints, you can use only transport-level security options for streaming and you cannot turn on reliable sessions.</span></span> <span data-ttu-id="25e69-204">Akış yalnızca aşağıdaki sistem tanımlı bağlamalarla kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="25e69-204">Streaming is only available with the following system-defined bindings:</span></span>  
  
- <xref:System.ServiceModel.BasicHttpBinding>  
  
- <xref:System.ServiceModel.NetTcpBinding>  
  
- <xref:System.ServiceModel.NetNamedPipeBinding>  
  
- <xref:System.ServiceModel.WebHttpBinding>  
  
 <span data-ttu-id="25e69-205">Temel taşımalar <xref:System.ServiceModel.NetTcpBinding> ve <xref:System.ServiceModel.NetNamedPipeBinding> http aksine, doğal güvenilir teslimat ve bağlantı tabanlı oturum desteği olduğundan, bu iki bağlama pratikte, bu kısıtlamalar sadece en az etkilenir.</span><span class="sxs-lookup"><span data-stu-id="25e69-205">Because the underlying transports of <xref:System.ServiceModel.NetTcpBinding> and <xref:System.ServiceModel.NetNamedPipeBinding> have inherent reliable delivery and connection-based session support, unlike HTTP, these two bindings are only minimally affected by these constraints, in practice.</span></span>  
  
 <span data-ttu-id="25e69-206">İleti Sıralaması (MSMQ) aktarımı ile akış kullanılamaz ve bu <xref:System.ServiceModel.NetMsmqBinding> nedenle <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> sınıf la kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="25e69-206">Streaming is not available with the Message Queuing (MSMQ) transport and so cannot be used with the <xref:System.ServiceModel.NetMsmqBinding> or the <xref:System.ServiceModel.MsmqIntegration.MsmqIntegrationBinding> class.</span></span> <span data-ttu-id="25e69-207">İleti Sıraya aktarımı yalnızca kısıtlı ileti boyutuyla arabelleğe alınan veri aktarımlarını desteklerken, diğer tüm aktarımların senaryoların büyük çoğunluğu için herhangi bir pratik ileti boyutu sınırı yoktur.</span><span class="sxs-lookup"><span data-stu-id="25e69-207">The Message Queuing transport only supports buffered data transfers with a constrained message size, while all other transports do not have any practical message size limit for the vast majority of scenarios.</span></span>  
  
 <span data-ttu-id="25e69-208">Eş Kanal aktarımını kullanırken akış da kullanılamıyor, <xref:System.ServiceModel.NetPeerTcpBinding>bu nedenle .</span><span class="sxs-lookup"><span data-stu-id="25e69-208">Streaming is also not available when using the Peer Channel transport, so is not available with the <xref:System.ServiceModel.NetPeerTcpBinding>.</span></span>  
  
#### <a name="streaming-and-sessions"></a><span data-ttu-id="25e69-209">Akış ve Oturumlar</span><span class="sxs-lookup"><span data-stu-id="25e69-209">Streaming and Sessions</span></span>  
 <span data-ttu-id="25e69-210">Oturum tabanlı bağlama yla çağrıları akışa aktarırken beklenmeyen davranışlar alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25e69-210">You may get unexpected behavior when streaming calls with a session-based binding.</span></span> <span data-ttu-id="25e69-211">Tüm akış çağrıları, kullanılan bağlama oturumları kullanmak üzere yapılandırılan olsa bile oturumları desteklemeyen tek bir kanal (datagram kanalı) üzerinden yapılır.</span><span class="sxs-lookup"><span data-stu-id="25e69-211">All streaming calls are made through a single channel (the datagram channel) that does not support sessions even if the binding being used is configured to use sessions.</span></span> <span data-ttu-id="25e69-212">Birden çok istemci oturum tabanlı bağlama üzerinden aynı hizmet nesnesine akış çağrıları yaparsa ve hizmet nesnesinin eşzamanlılık modu tek olarak ayarlanmışsa ve örnek bağlam modu PerSession olarak ayarlanmışsa, tüm aramalar datagram kanalından geçmelidir ve bu nedenle yalnızca bir arama bir defada işlenir.</span><span class="sxs-lookup"><span data-stu-id="25e69-212">If multiple clients make streaming calls to the same service object over a session-based binding and the service object's concurrency mode is set to single and its instance context mode is set to PerSession, all calls must go through the datagram channel and so only one call is processed at a time.</span></span> <span data-ttu-id="25e69-213">Bir veya daha fazla istemci daha sonra zaman dışarı olabilir. Bu sorunu, hizmet nesnesinin Örnek Bağlam Modu'nu PerCall'a veya Eşzamanlılık Modunu Çoklu'ya ayarlayarak çözebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25e69-213">One or more clients may then time out. You can work around this issue by either setting the service object's Instance Context Mode to PerCall or Concurrency to Multiple.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="25e69-214">Yalnızca bir "oturum" olduğundan MaxConcurrentSessions bu durumda hiçbir etkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="25e69-214">MaxConcurrentSessions has no effect in this case because there is only one "session" available.</span></span>  
  
### <a name="enabling-streaming"></a><span data-ttu-id="25e69-215">Akışı Etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="25e69-215">Enabling Streaming</span></span>  
 <span data-ttu-id="25e69-216">Akışı aşağıdaki yollarla etkinleştirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="25e69-216">You can enable streaming in the following ways:</span></span>  
  
- <span data-ttu-id="25e69-217">Akış modunda istek gönderme ve kabul et ve arabelleğe<xref:System.ServiceModel.TransferMode.StreamedRequest>alma modunda yanıtları kabul edip iade eder ( ).</span><span class="sxs-lookup"><span data-stu-id="25e69-217">Send and accept requests in streaming mode, and accept and return responses in buffered mode (<xref:System.ServiceModel.TransferMode.StreamedRequest>).</span></span>  
  
- <span data-ttu-id="25e69-218">Arabelleğe alma modunda istek gönderme ve kabul et ve<xref:System.ServiceModel.TransferMode.StreamedResponse>akışları akış modunda yanıtları kabul edip döndür ( ).</span><span class="sxs-lookup"><span data-stu-id="25e69-218">Send and accept requests in buffered mode, and accept and return responses in streamed mode (<xref:System.ServiceModel.TransferMode.StreamedResponse>).</span></span>  
  
- <span data-ttu-id="25e69-219">Her iki yönde de akış modunda istek ve yanıt gönderin ve alın.</span><span class="sxs-lookup"><span data-stu-id="25e69-219">Send and receive requests and responses in streamed mode in both directions.</span></span> <span data-ttu-id="25e69-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span><span class="sxs-lookup"><span data-stu-id="25e69-220">(<xref:System.ServiceModel.TransferMode.Streamed>).</span></span>  
  
 <span data-ttu-id="25e69-221">Tüm bağlamaların varsayılan ayarı olan <xref:System.ServiceModel.TransferMode.Buffered>aktarım modunu (tüm bağlamalar için varsayılan ayar) ayarlayarak akışı devre dışı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25e69-221">You can disable streaming by setting the transfer mode to <xref:System.ServiceModel.TransferMode.Buffered>, which is the default setting on all bindings.</span></span> <span data-ttu-id="25e69-222">Aşağıdaki kod, yapılandırmada aktarım modunun nasıl ayarlanır olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="25e69-222">The following code shows how to set the transfer mode in configuration.</span></span>  
  
```xml  
<system.serviceModel>  
     …  
    <bindings>  
      <basicHttpBinding>  
        <binding name="ExampleBinding" transferMode="Streamed"/>  
      </basicHttpBinding>  
    </bindings>  
     …  
<system.serviceModel>  
```  
  
 <span data-ttu-id="25e69-223">Parolayla bağlamanızı anında yaptığınızda, bağlamanın ilgili `TransferMode` özelliğini (veya özel bir bağlama oluşturuyorsanız aktarım bağlama öğesi) daha önce belirtilen değerlerden birine ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="25e69-223">When you instantiate your binding in code, you must set the respective `TransferMode` property of the binding (or the transport binding element if you are composing a custom binding) to one of the previously mentioned values.</span></span>  
  
 <span data-ttu-id="25e69-224">İstek ler ve yanıtlar için veya her iki yönde de işlevselliği etkilemeden iletişim taraflarının her iki tarafında bağımsız olarak akış açabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="25e69-224">You can turn on streaming for requests and replies or for both directions independently at either side of the communicating parties without affecting functionality.</span></span> <span data-ttu-id="25e69-225">Ancak, aktarılan veri boyutunun, bir iletişim bağlantısının her iki uç noktasında da akışı etkinleştirmek için çok önemli olduğunu varsaymalısınız.</span><span class="sxs-lookup"><span data-stu-id="25e69-225">However, you should always assume that the transferred data size is so significant that enabling streaming is justified on both endpoints of a communication link.</span></span> <span data-ttu-id="25e69-226">Uç noktalardan birinin WCF ile uygulanmadığı çapraz platform iletişimi için, akış kullanma yeteneği platformun akış özelliklerine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-226">For cross-platform communication where one of the endpoints is not implemented with WCF, the ability to use streaming depends on the platform's streaming capabilities.</span></span> <span data-ttu-id="25e69-227">Başka bir nadir özel durum, istemci veya hizmetin çalışma kümesini en aza indirmesi gereken ve yalnızca küçük arabellek boyutlarını karşılayabileceği bellek tüketimine dayalı bir senaryo olabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-227">Another rare exception might be a memory-consumption driven scenario where a client or service must minimize its working set and can only afford small buffer sizes.</span></span>  
  
### <a name="enabling-asynchronous-streaming"></a><span data-ttu-id="25e69-228">Eşzamanlı Akışı Etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="25e69-228">Enabling Asynchronous Streaming</span></span>  
 <span data-ttu-id="25e69-229">Eşzamanlı akışı etkinleştirmek için, <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> bitiş noktası davranışını hizmet ana <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> bilgisayara ekleyin ve özelliğini '' olarak `true`ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="25e69-229">To enable asynchronous streaming, add the  <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior> endpoint behavior to the service host and set its <xref:System.ServiceModel.Description.DispatcherSynchronizationBehavior.AsynchronousSendEnabled%2A> property to `true`.</span></span> <span data-ttu-id="25e69-230">Ayrıca, gönder tarafında gerçek asynchronous akış yeteneğini de ekledik.</span><span class="sxs-lookup"><span data-stu-id="25e69-230">We have also added the capability of true asynchronous streaming on the send side.</span></span> <span data-ttu-id="25e69-231">Bu, bazıları ağ tıkanıklığı nedeniyle okumada yavaş olan veya hiç okumayan birden çok istemciye ileti akışı yaptığı senaryolarda hizmetin ölçeklenebilirliğini artırır.</span><span class="sxs-lookup"><span data-stu-id="25e69-231">This improves scalability of the service in scenarios where it is streaming messages to multiple clients some of which are slow in reading possibly due to network congestion or are not reading at all.</span></span> <span data-ttu-id="25e69-232">Bu senaryolarda artık istemci başına hizmetteki tek tek iş parçacıklarını engellemeyiz.</span><span class="sxs-lookup"><span data-stu-id="25e69-232">In these scenarios we now do not block individual threads on the service per client.</span></span> <span data-ttu-id="25e69-233">Bu, hizmetin çok daha fazla istemciyi işleme sini sağlayarak hizmetin ölçeklenebilirliğini artırmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="25e69-233">This ensures that the service is able to process many more clients thereby improving the scalability of the service.</span></span>  
  
### <a name="programming-model-for-streamed-transfers"></a><span data-ttu-id="25e69-234">Akışlı Aktarımlar için Programlama Modeli</span><span class="sxs-lookup"><span data-stu-id="25e69-234">Programming Model for Streamed Transfers</span></span>  
 <span data-ttu-id="25e69-235">Akış için programlama modeli basittir.</span><span class="sxs-lookup"><span data-stu-id="25e69-235">The programming model for streaming is straightforward.</span></span> <span data-ttu-id="25e69-236">Akışlı verileri almak için, tek <xref:System.IO.Stream> bir daktilile giriş parametresi olan bir işlem sözleşmesi belirtin.</span><span class="sxs-lookup"><span data-stu-id="25e69-236">For receiving streamed data, specify an operation contract that has a single <xref:System.IO.Stream> typed input parameter.</span></span> <span data-ttu-id="25e69-237">Akışlı verileri döndürmek için <xref:System.IO.Stream> bir başvuru döndürün.</span><span class="sxs-lookup"><span data-stu-id="25e69-237">For returning streamed data, return a <xref:System.IO.Stream> reference.</span></span>  
  
```csharp
[ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]  
public interface IStreamedService  
{  
    [OperationContract]  
    Stream Echo(Stream data);  
    [OperationContract]  
    Stream RequestInfo(string query);  
    [OperationContract(OneWay=true)]  
    void ProvideInfo(Stream data);  
}  
```  
  
 <span data-ttu-id="25e69-238">Önceki `Echo` örnekteki işlem bir akış alır ve döndürür ve <xref:System.ServiceModel.TransferMode.Streamed>bu nedenle bir bağlama kullanılmalıdır .</span><span class="sxs-lookup"><span data-stu-id="25e69-238">The operation `Echo` in the preceding example receives and returns a stream and should therefore be used on a binding with <xref:System.ServiceModel.TransferMode.Streamed>.</span></span> <span data-ttu-id="25e69-239">Operasyon `RequestInfo`için, <xref:System.ServiceModel.TransferMode.StreamedResponse> en uygun, çünkü sadece <xref:System.IO.Stream>bir .</span><span class="sxs-lookup"><span data-stu-id="25e69-239">For the operation `RequestInfo`, <xref:System.ServiceModel.TransferMode.StreamedResponse> is best suited, because it only returns a <xref:System.IO.Stream>.</span></span> <span data-ttu-id="25e69-240">Tek yönlü işlem için en <xref:System.ServiceModel.TransferMode.StreamedRequest>uygun.</span><span class="sxs-lookup"><span data-stu-id="25e69-240">The one-way operation is best suited for <xref:System.ServiceModel.TransferMode.StreamedRequest>.</span></span>  
  
 <span data-ttu-id="25e69-241">Aşağıdaki `Echo` veya `ProvideInfo` işlemlere ikinci bir parametre eklenmesinin hizmet modelinin arabelleğe geçmiş bir stratejiye geri dönmesine ve akışın çalışma zamanı serileştirme gösterimini kullanmasına neden olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="25e69-241">Note that adding a second parameter to the following `Echo` or `ProvideInfo` operations causes the service model to revert back to a buffered strategy and use the run-time serialization representation of the stream.</span></span> <span data-ttu-id="25e69-242">Yalnızca tek bir giriş akışı parametresi olan işlemler uçtan uca istek akışıyla uyumludur.</span><span class="sxs-lookup"><span data-stu-id="25e69-242">Only operations with a single input stream parameter are compatible with end-to-end request streaming.</span></span>  
  
 <span data-ttu-id="25e69-243">Bu kural benzer şekilde ileti sözleşmeleri için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-243">This rule similarly applies to message contracts.</span></span> <span data-ttu-id="25e69-244">Aşağıdaki ileti sözleşmesinde gösterildiği gibi, ileti sözleşmenizde akış olan yalnızca tek bir gövdeli üyeniz olabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-244">As shown in the following message contract, you can have only a single body member in your message contract that is a stream.</span></span> <span data-ttu-id="25e69-245">Akışla ek bilgi iletmek istiyorsanız, bu bilgilerin ileti üstbilgileri nde taşınması gerekir.</span><span class="sxs-lookup"><span data-stu-id="25e69-245">If you want to communicate additional information with the stream, this information must be a carried in message headers.</span></span> <span data-ttu-id="25e69-246">İleti gövdesi yalnızca akış içeriği için ayrılmıştır.</span><span class="sxs-lookup"><span data-stu-id="25e69-246">The message body is exclusively reserved for the stream content.</span></span>  
  
```csharp
[MessageContract]  
public class UploadStreamMessage  
{  
   [MessageHeader]  
   public string appRef;  
   [MessageBodyMember]  
   public Stream data;  
}
```  
  
 <span data-ttu-id="25e69-247">Akışak aktarımları sona erer ve akış dosyanın sonuna (EOF) ulaştığında ileti kapatılır.</span><span class="sxs-lookup"><span data-stu-id="25e69-247">Streamed transfers end and the message is closed when the stream reaches the end of file (EOF).</span></span> <span data-ttu-id="25e69-248">İleti gönderirken (bir değer döndürerek veya bir işlemi <xref:System.IO.FileStream> çağırırken), bir geçişi geçebilir ve WCF altyapısı, akış tamamen okunup EOF'ye ulaşana kadar bu akıştaki tüm verileri çeker.</span><span class="sxs-lookup"><span data-stu-id="25e69-248">When sending a message (returning a value or invoking an operation), you can pass a <xref:System.IO.FileStream> and the WCF infrastructure subsequently pulls all the data from that stream until the stream has been completely read and reached EOF.</span></span> <span data-ttu-id="25e69-249">Önceden oluşturulmuş <xref:System.IO.Stream> türemiş bir sınıfın bulunmadığı kaynak için akışlı veri aktarmak için, böyle bir sınıf oluşturmak, akış kaynağınızın üzerine o sınıfı bindirme ve bunu bağımsız değişken veya iade değeri olarak kullanın.</span><span class="sxs-lookup"><span data-stu-id="25e69-249">To transfer streamed data for the source that no such pre-built <xref:System.IO.Stream> derived class exists, construct such a class, overlay that class over your stream source, and use that as the argument or return value.</span></span>  
  
 <span data-ttu-id="25e69-250">Bir ileti alırken, WCF Base64 kodlanmış ileti gövdesi içeriği (veya MTOM kullanıyorsanız ilgili MIME bölümü) üzerinde bir akış oluşturuyor ve içerik okunduğunda akış EOF'ye ulaşıyor.</span><span class="sxs-lookup"><span data-stu-id="25e69-250">When receiving a message, WCF constructs a stream over the Base64-encoded message body content (or the respective MIME part if using MTOM) and the stream reaches EOF when the content has been read.</span></span>  
  
 <span data-ttu-id="25e69-251">Aktarım düzeyi akışı, diğer ileti sözleşmesi türüyle (parametre listeleri, veri sözleşmesi bağımsız değişkenleri ve açık ileti sözleşmesi) da çalışır, ancak bu tür tür iletilerin serileştirilmesi ve deserializasyonu serileştirici tarafından arabelleğe alma gerektirdiğinden , bu tür sözleşme türevlerini kullanmak tavsiye edilmez.</span><span class="sxs-lookup"><span data-stu-id="25e69-251">Transport-level streaming also works with any other message contract type (parameter lists, data contract arguments, and explicit message contract), but because the serialization and deserialization of such typed messages requires buffering by the serializer, using such contract variants is not advisable.</span></span>  
  
### <a name="special-security-considerations-for-large-data"></a><span data-ttu-id="25e69-252">Büyük Veriler için Özel Güvenlik Hususları</span><span class="sxs-lookup"><span data-stu-id="25e69-252">Special Security Considerations for Large Data</span></span>  
 <span data-ttu-id="25e69-253">Tüm bağlamalar, hizmet reddi saldırılarını önlemek için gelen iletilerin boyutunu kısıtlamanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="25e69-253">All bindings allow you to constrain the size of incoming messages to prevent denial-of-service attacks.</span></span> <span data-ttu-id="25e69-254">Örneğin, <xref:System.ServiceModel.BasicHttpBinding>gelen iletinin boyutunu sınırlayan bir [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) özelliğini ortaya çıkarır ve böylece iletiyi işlerken erişilen maksimum bellek miktarını da sınırlar.</span><span class="sxs-lookup"><span data-stu-id="25e69-254">The <xref:System.ServiceModel.BasicHttpBinding>, for example, exposes a [System.ServiceModel.BasicHttpBinding.MaxReceivedMessageSize](xref:System.ServiceModel.HttpBindingBase.MaxReceivedMessageSize%2A) property that bounds the size of the incoming message, and so also bounds the maximum amount of memory that is accessed when processing the message.</span></span> <span data-ttu-id="25e69-255">Bu birim, varsayılan değeri 65.536 bayt olan baytolarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="25e69-255">This unit is set in bytes with a default value of 65,536 bytes.</span></span>  
  
 <span data-ttu-id="25e69-256">Büyük veri akışı senaryosuna özgü bir güvenlik tehdidi, alıcı akışı istediğinde verilerin arabelleğe alınmasına neden olarak hizmet reddine neden olur.</span><span class="sxs-lookup"><span data-stu-id="25e69-256">A security threat that is specific to the large data streaming scenario provokes a denial of service by causing data to be buffered when the receiver expects it to be streamed.</span></span> <span data-ttu-id="25e69-257">Örneğin, WCF her zaman bir iletinin SOAP üstbilgilerini arabelleğe alır ve bu nedenle saldırgan, verilerin arabelleğe alınmasına zorlamak için tamamen üstbilgilerden oluşan büyük bir kötü amaçlı ileti oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-257">For example, WCF always buffers the SOAP headers of a message, and so an attacker may construct a large malicious message that consists entirely of headers to force the data to be buffered.</span></span> <span data-ttu-id="25e69-258">Akış etkinleştirildiğinde, `MaxReceivedMessageSize` alıcı iletinin tamamının bellekte aynı anda arabelleğe alınmasını beklemediği için, son derece büyük bir değere ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="25e69-258">When streaming is enabled, the `MaxReceivedMessageSize` may be set to an extremely large value, because the receiver never expects the entire message to be buffered in memory at once.</span></span> <span data-ttu-id="25e69-259">WCF iletiyi arabelleğe almaya zorlanırsa, bellek taşması oluşur.</span><span class="sxs-lookup"><span data-stu-id="25e69-259">If WCF is forced to buffer the message, a memory overflow occurs.</span></span>  
  
 <span data-ttu-id="25e69-260">Bu nedenle, bu durumda gelen en büyük ileti boyutunu kısıtlamak yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="25e69-260">Therefore, restricting the maximum incoming message size is not enough in this case.</span></span> <span data-ttu-id="25e69-261">Özellik, `MaxBufferSize` WCF arabelleklerini kısıtlayan belleği kısıtlamak için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-261">The `MaxBufferSize` property is required to constrain the memory that WCF buffers.</span></span> <span data-ttu-id="25e69-262">Akış sırasında bunu güvenli bir değere (veya varsayılan değerde tutmak) ayarlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-262">It is important to set this to a safe value (or keep it at the default value) when streaming.</span></span> <span data-ttu-id="25e69-263">Örneğin, hizmetinizin 4 GB boyutuna kadar dosyaları alması ve bunları yerel diskte depolaması gerektiğini varsayalım.</span><span class="sxs-lookup"><span data-stu-id="25e69-263">For example, suppose your service must receive files up to 4 GB in size and store them on the local disk.</span></span> <span data-ttu-id="25e69-264">Ayrıca, belleğinizin aynı anda yalnızca 64 KB veri arabelleğe alabileceğiniz şekilde kısıtlanmış olduğunu da varsayalım.</span><span class="sxs-lookup"><span data-stu-id="25e69-264">Suppose also that your memory is constrained in such a way that you can only buffer 64 KB of data at a time.</span></span> <span data-ttu-id="25e69-265">Sonra 4 GB `MaxReceivedMessageSize` ve `MaxBufferSize` 64 KB ayarlamak istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="25e69-265">Then you would set the `MaxReceivedMessageSize` to 4 GB and `MaxBufferSize` to 64 KB.</span></span> <span data-ttu-id="25e69-266">Ayrıca, hizmet uygulamanızda, yalnızca 64-KB'lik parçalar halinde gelen akıştan okuduğunuzdan emin olmalısınız ve bir önceki parça diske yazılmadan ve bellekten atılmadan önce bir sonraki parçayı okumamalısınız.</span><span class="sxs-lookup"><span data-stu-id="25e69-266">Also, in your service implementation, you must ensure that you read only from the incoming stream in 64-KB chunks and do not read the next chunk before the previous one has been written to disk and discarded from memory.</span></span>  
  
 <span data-ttu-id="25e69-267">Bu kotanın yalnızca WCF tarafından yapılan arabelleğe alma alanını sınırladığını ve kendi hizmetinizde veya istemci uygulamanızda yaptığınız herhangi bir arabelleğe alma yla sizi koruyamayacağını da anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="25e69-267">It is also important to understand that this quota only limits the buffering done by WCF and cannot protect you against any buffering that you do in your own service or client implementation.</span></span> <span data-ttu-id="25e69-268">Ek güvenlik konuları hakkında daha fazla bilgi için, [Veriler için Güvenlik Hususları'na](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="25e69-268">For more information about additional security considerations, see [Security Considerations for Data](../../../../docs/framework/wcf/feature-details/security-considerations-for-data.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="25e69-269">Arabelleğe alınan veya akışlı aktarımları kullanma kararı bitiş noktasının yerel bir kararıdır.</span><span class="sxs-lookup"><span data-stu-id="25e69-269">The decision to use either buffered or streamed transfers is a local decision of the endpoint.</span></span> <span data-ttu-id="25e69-270">HTTP aktarımları için aktarım modu bir bağlantı boyunca veya proxy sunucuları ve diğer aracılara yayılmaz.</span><span class="sxs-lookup"><span data-stu-id="25e69-270">For HTTP transports, the transfer mode does not propagate across a connection or to proxy servers and other intermediaries.</span></span> <span data-ttu-id="25e69-271">Aktarım modunun ayarlanması hizmet arabiriminin açıklamasına yansıtılmaz.</span><span class="sxs-lookup"><span data-stu-id="25e69-271">Setting the transfer mode is not reflected in the description of the service interface.</span></span> <span data-ttu-id="25e69-272">Bir hizmete bir WCF istemcisi sağladıktan sonra, modu ayarlamak için akışlı aktarımlarla kullanılmak üzere tasarlanmış hizmetler için yapılandırma dosyasını düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="25e69-272">After generating a WCF client to a service, you must edit the configuration file for services intended to be used with streamed transfers to set the mode.</span></span> <span data-ttu-id="25e69-273">TCP ve adlandırılmış boru aktarımları için aktarım modu bir ilke iddiası olarak yayılır.</span><span class="sxs-lookup"><span data-stu-id="25e69-273">For TCP and named pipe transports, the transfer mode is propagated as a policy assertion.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="25e69-274">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="25e69-274">See also</span></span>

- [<span data-ttu-id="25e69-275">Nasıl yapılır: Akışı Etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="25e69-275">How to: Enable Streaming</span></span>](../../../../docs/framework/wcf/feature-details/how-to-enable-streaming.md)
