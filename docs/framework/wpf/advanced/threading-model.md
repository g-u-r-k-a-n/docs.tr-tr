---
title: İş Parçacığı Modeli
description: Windows Presentation Foundation uygulamanızda birden çok iş parçacığına ihtiyacınız olabilecek durumlar hakkında bilgi edinin. Tek iş parçacıklı çözümler tercih edilir.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 9b67b6ea2896e9e6fec57dee8d1013d54fab03fc
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87166378"
---
# <a name="threading-model"></a><span data-ttu-id="8a01d-104">İş Parçacığı Modeli</span><span class="sxs-lookup"><span data-stu-id="8a01d-104">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="8a01d-105">, iş parçacığı zorluklarından geliştiricilerin kaydedileceği şekilde tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-105">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="8a01d-106">Sonuç olarak, geliştiricilerin çoğunluğu birden [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fazla iş parçacığı kullanan bir arabirim yazmak zorunda kalmaz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-106">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="8a01d-107">Çok iş parçacıklı programlar karmaşık olduğu ve hata ayıklamanın zor olduğu için, tek iş parçacıklı çözümler olduğunda bu, kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-107">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="8a01d-108">Bununla birlikte ne kadar iyi mimari olduğuna bakılmaksızın, hiçbir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] çerçeve her bir sorun için tek iş parçacıklı bir çözüm sağlayacaktır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-108">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="8a01d-109">yakın zamanda gelir, ancak birden çok iş parçacığının [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] yanıt hızını veya uygulama performansını artıran durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-109">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="8a01d-110">Bu şekilde, bazı arka plan malzemeleri ele alındıktan sonra bu durum, bu durumların bazılarını araştırır ve daha sonra bazı alt düzey ayrıntıların bir tartışmasına göre sonlanır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-110">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="8a01d-111">Bu konuda, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zaman uyumsuz çağrılar için yöntemi kullanılarak iş parçacığı ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-111">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="8a01d-112">Ayrıca, <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> bir <xref:System.Action> veya parametresi olarak kullanan yöntemini çağırarak zaman uyumsuz çağrılar yapabilirsiniz <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-112">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="8a01d-113"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>Yöntemi, <xref:System.Windows.Threading.DispatcherOperation> özelliği olan bir veya döndürür <xref:System.Windows.Threading.DispatcherOperation%601> <xref:System.Windows.Threading.DispatcherOperation.Task%2A> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-113">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="8a01d-114">`await`Anahtar sözcüğünü ya da ilişkili ile kullanabilirsiniz <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Threading.Tasks.Task> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-114">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="8a01d-115">Veya tarafından döndürülen için eşzamanlı olarak beklemeniz gerekiyorsa <xref:System.Threading.Tasks.Task> <xref:System.Windows.Threading.DispatcherOperation> <xref:System.Windows.Threading.DispatcherOperation%601> , <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> genişletme yöntemini çağırın.</span><span class="sxs-lookup"><span data-stu-id="8a01d-115">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="8a01d-116">Çağırmak <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> kilitlenmeye neden olur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-116">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="8a01d-117">Zaman uyumsuz işlemleri gerçekleştirmek için kullanma hakkında daha fazla bilgi için <xref:System.Threading.Tasks.Task> bkz. Görev Paralelliği.</span><span class="sxs-lookup"><span data-stu-id="8a01d-117">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="8a01d-118"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>Bu yöntemde, bir <xref:System.Action> veya parametresi olarak bir veya olarak alan aşırı yüklemeleri de vardır <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-118">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="8a01d-119"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>Yöntemini, bir temsilciyi geçirerek zaman uyumlu çağrılar yapmak için kullanabilirsiniz <xref:System.Action> <xref:System.Func%601> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-119">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="8a01d-120">Genel bakış ve dağıtıcı</span><span class="sxs-lookup"><span data-stu-id="8a01d-120">Overview and the Dispatcher</span></span>
 <span data-ttu-id="8a01d-121">Genellikle, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalar iki iş parçacığı ile başlar: bir, işleme ve bir diğeri yönetmek için bir diğeri [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-121">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="8a01d-122">İşlem parçacığı, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı girişi aldığında, olayları işlerken, ekranı boyayıp uygulama kodunu çalıştırdığında, arka planda gizli olarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-122">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="8a01d-123">Birçok uygulama tek bir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı kullanır, ancak bazı durumlarda en iyi şekilde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-123">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="8a01d-124">Bunu daha sonra bir örnekle tartışacağız.</span><span class="sxs-lookup"><span data-stu-id="8a01d-124">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="8a01d-125">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]İş parçacığı, adlı bir nesne içindeki iş öğelerini sıralar <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-125">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="8a01d-126">, <xref:System.Windows.Threading.Dispatcher> İş öğelerini öncelik temelinde seçer ve her birini tamamlamada çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-126">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="8a01d-127">Her [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığında en az bir tane olmalıdır <xref:System.Windows.Threading.Dispatcher> ve her biri <xref:System.Windows.Threading.Dispatcher> iş öğelerini tam olarak bir iş parçacığında yürütebilirler.</span><span class="sxs-lookup"><span data-stu-id="8a01d-127">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="8a01d-128">Kullanıcı dostu uygulamalar oluşturma eli, <xref:System.Windows.Threading.Dispatcher> iş öğelerini küçük tutarak aktarım hızını en üst düzeye çıkarabilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a01d-128">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="8a01d-129">Bu şekilde öğeler, <xref:System.Windows.Threading.Dispatcher> işlenmek üzere bekleyen sırada hiç kullanılmıyor.</span><span class="sxs-lookup"><span data-stu-id="8a01d-129">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="8a01d-130">Giriş ve yanıt arasındaki perceivable gecikmesi bir kullanıcıyı rahatsız edebilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-130">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="8a01d-131">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]Uygulamalar, büyük işlemleri işlemek için nasıl kullanılır?</span><span class="sxs-lookup"><span data-stu-id="8a01d-131">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="8a01d-132">Kodunuz büyük bir hesaplama içeriyorsa veya bir veritabanını bir uzak sunucuda sorgulamak için ihtiyaç duyuyorsa ne olacak?</span><span class="sxs-lookup"><span data-stu-id="8a01d-132">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="8a01d-133">Genellikle, yanıt ayrı bir iş parçacığında büyük işlemi idare etmek ve [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığını kuyruktaki öğelere eğilme etmek için serbest bırakır <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-133">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="8a01d-134">Büyük işlem tamamlandığında, sonuçları [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] görüntülenmek üzere iş parçacığına rapor edebilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-134">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="8a01d-135">Tarihsel olarak, Windows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] öğelere yalnızca kendilerini oluşturan iş parçacığından erişilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-135">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="8a01d-136">Bu, uzun süre çalışan bazı görevlerden sorumlu bir arka plan iş parçacığının, tamamlandığında bir metin kutusunu güncelleştiremeyeceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-136">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="8a01d-137">Windows, bileşenleri bütünlüğünü sağlamak için bunu yapar [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-137">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="8a01d-138">Bir liste kutusu, içeriği boyama sırasında arka plan iş parçacığı tarafından güncellendiyse tuhaf görünebilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-138">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="8a01d-139">, bu koordinasyonu zorlayan yerleşik bir karşılıklı dışlama mekanizmasına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-139">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="8a01d-140">İçindeki sınıfların çoğu, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] öğesinden türetilir <xref:System.Windows.Threading.DispatcherObject> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-140">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="8a01d-141">Oluşturma sırasında, <xref:System.Windows.Threading.DispatcherObject> <xref:System.Windows.Threading.Dispatcher> o anda çalışan iş parçacığına bağlı bir başvuru depolar.</span><span class="sxs-lookup"><span data-stu-id="8a01d-141">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="8a01d-142">Aslında, <xref:System.Windows.Threading.DispatcherObject> kendisini oluşturan iş parçacığıyla ilişkilendirir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-142">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="8a01d-143">Program yürütme sırasında, bir <xref:System.Windows.Threading.DispatcherObject> ortak <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> yöntemini çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-143">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="8a01d-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A><xref:System.Windows.Threading.Dispatcher>geçerli iş parçacığıyla ilişkili olduğunu inceler ve <xref:System.Windows.Threading.Dispatcher> oluşturma sırasında saklanan başvuruyla karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="8a01d-145">Eşleşmiyorsa <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-145">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="8a01d-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>, bir öğesine ait her yöntemin başlangıcında çağrılmalıdır <xref:System.Windows.Threading.DispatcherObject> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-146"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="8a01d-147">Yalnızca bir iş parçacığı değişiklik yapabiliyorsanız [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] , arka plan iş parçacıkları kullanıcıyla nasıl etkileşebilir?</span><span class="sxs-lookup"><span data-stu-id="8a01d-147">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="8a01d-148">Bir arka plan iş parçacığı, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığının adına bir işlem gerçekleştirmesini isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-148">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="8a01d-149">İş parçacığını iş parçacığı ile kaydederek bunu yapar <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-149">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-150"><xref:System.Windows.Threading.Dispatcher>Sınıfı, iş öğelerini kaydetmek için iki yöntem sağlar: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ve <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-150">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="8a01d-151">Her iki yöntem de bir temsilciyi yürütmeye zamanlar.</span><span class="sxs-lookup"><span data-stu-id="8a01d-151">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="8a01d-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>zaman uyumlu bir çağrıdır; diğer bir deyişle, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı gerçekten temsilciyi yürütmeyi bitirene kadar döndürmez.</span><span class="sxs-lookup"><span data-stu-id="8a01d-152"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="8a01d-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>zaman uyumsuzdur ve hemen döndürür.</span><span class="sxs-lookup"><span data-stu-id="8a01d-153"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="8a01d-154"><xref:System.Windows.Threading.Dispatcher>Öğeleri sırasıyla sırasına göre sıralar.</span><span class="sxs-lookup"><span data-stu-id="8a01d-154">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="8a01d-155">Kuyruğa bir öğe eklenirken belirtilen on düzey vardır <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-155">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="8a01d-156">Bu öncelikler <xref:System.Windows.Threading.DispatcherPriority> numaralandırmada tutulur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-156">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="8a01d-157">Düzeyler hakkında ayrıntılı bilgi <xref:System.Windows.Threading.DispatcherPriority> Windows SDK belgelerinde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-157">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="8a01d-158">İşlemdeki iş parçacıkları: örnekler</span><span class="sxs-lookup"><span data-stu-id="8a01d-158">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="8a01d-159">Uzun süre çalışan bir hesaplama ile tek Iş parçacıklı bir uygulama</span><span class="sxs-lookup"><span data-stu-id="8a01d-159">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="8a01d-160">Çoğu grafik kullanıcı arabirimi (Gua), kullanıcı etkileşimlerine yanıt olarak oluşturulan olayları beklerken zaman içindeki büyük bir bölümü harcamaktadır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-160">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="8a01d-161">Dikkatli bir programlamayla bu boşta kalma süresi, ' nin yanıt hızını etkilemeden oluşturulabilir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-161">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="8a01d-162">İş parçacığı [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] modeli, girişin iş parçacığında meydana gelen bir işlemi kesmesine izin vermez [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-162">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-163">Bu, <xref:System.Windows.Threading.Dispatcher> bekleyen giriş olaylarını eski olmadan işlemek için düzenli aralıklarla geri döndiğinizden emin olmanız gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-163">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="8a01d-164">Aşağıdaki örneği inceleyin:</span><span class="sxs-lookup"><span data-stu-id="8a01d-164">Consider the following example:</span></span>

 ![Asal sayıların iş parçacığı gösteren ekran görüntüsü.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="8a01d-166">Bu basit uygulama, üç ' dan yukarı doğru sayılır, asal sayılar için arama yapılır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-166">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="8a01d-167">Kullanıcı **Başlat** düğmesine tıkladığında arama başlar.</span><span class="sxs-lookup"><span data-stu-id="8a01d-167">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="8a01d-168">Program bir ana bulduğunda, Kullanıcı arabirimini bulma işlemi ile güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-168">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="8a01d-169">Herhangi bir noktada Kullanıcı aramayı durdurabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-169">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="8a01d-170">Yeterince basit olsa da, asal sayı araması sonsuza kadar devam eder ve bu da bazı zorluklar sunar.</span><span class="sxs-lookup"><span data-stu-id="8a01d-170">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="8a01d-171">Düğmenin tıklama olayı işleyicisi içinde tüm aramayı ele aldık, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığına diğer olayları işleme şansı vermeiyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-171">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="8a01d-172">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]Giriş veya işlem iletilerine yanıt veremezse.</span><span class="sxs-lookup"><span data-stu-id="8a01d-172">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="8a01d-173">Hiçbir şekilde yeniden boyanır ve düğme tıklamalarına hiç yanıt vermez.</span><span class="sxs-lookup"><span data-stu-id="8a01d-173">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="8a01d-174">Ana sayı aramasını ayrı bir iş parçacığında ele geçirebilir, ancak eşitleme sorunlarıyla uğraşmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-174">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="8a01d-175">Tek iş parçacıklı bir yaklaşımla, bulunan en büyük ana alanı listeleyen etiketi doğrudan güncelleştirebiliriz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-175">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="8a01d-176">Hesaplama görevini yönetilebilir parçalara ayırdık, düzenli aralıklarla <xref:System.Windows.Threading.Dispatcher> ve işlem olaylarına geri dönebiliriz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-176">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="8a01d-177">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]Girişi yeniden çizmeyi ve işlemeyi sağlayacak bir fırsat verebiliriz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-177">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="8a01d-178">Hesaplama ve olay işleme arasındaki işleme süresini bölmenin en iyi yolu, ' dan hesaplamayı yönetmekdir <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-178">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="8a01d-179"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>Yöntemini kullanarak, ana sayı denetimlerini olayların çizildiği sırada zamanlayabiliriz [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-179">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="8a01d-180">Bizim örneğimizde, aynı anda yalnızca tek bir ana sayı denetimi zamanladık.</span><span class="sxs-lookup"><span data-stu-id="8a01d-180">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="8a01d-181">Asal sayı denetimi tamamlandıktan sonra sonraki denetimi hemen zamanlıyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-181">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="8a01d-182">Bu denetim yalnızca bekleyen olaylar işlendikten sonra devam eder [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-182">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Dağıtıcı kuyruğunu gösteren ekran görüntüsü.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="8a01d-184">Microsoft Word, bu mekanizmayı kullanarak yazım denetimi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-184">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="8a01d-185">Yazım denetimi, iş parçacığının boşta kalma süresi kullanılarak arka planda yapılır [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-185">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-186">Şimdi koda göz atalım.</span><span class="sxs-lookup"><span data-stu-id="8a01d-186">Let's take a look at the code.</span></span>

 <span data-ttu-id="8a01d-187">Aşağıdaki örnek, Kullanıcı arabirimini oluşturan XAML 'yi gösterir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-187">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="8a01d-188">Aşağıdaki örnek, arka plan kodunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-188">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="8a01d-189">Aşağıdaki örnek, için olay işleyicisini gösterir <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-189">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="8a01d-190">Bu işleyicinin, içindeki metni güncelleştirmesinin yanı sıra, <xref:System.Windows.Controls.Button> kuyruğa bir temsilci ekleyerek ilk asal sayı denetiminin planlanmasından sorumludur <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-190">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="8a01d-191">Bu olay işleyicisi işini tamamladıktan sonra, <xref:System.Windows.Threading.Dispatcher> yürütme için bu temsilciyi seçer.</span><span class="sxs-lookup"><span data-stu-id="8a01d-191">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="8a01d-192">Daha önce bahsedildiği gibi, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> <xref:System.Windows.Threading.Dispatcher> bir temsilciyi yürütmeye zamanlamak için kullanılan üye.</span><span class="sxs-lookup"><span data-stu-id="8a01d-192">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="8a01d-193">Bu durumda öncelik ' i seçeceğiz <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-193">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="8a01d-194"><xref:System.Windows.Threading.Dispatcher>Bu temsilciyi yalnızca işlemek için önemli bir olay olmadığında yürütecektir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-194">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]<span data-ttu-id="8a01d-195">Yanıt verme sayısı, sayı denetlenmeden daha önemlidir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-195">responsiveness is more important than number checking.</span></span> <span data-ttu-id="8a01d-196">Ayrıca, sayı denetimi yordamını temsil eden yeni bir temsilci geçiririz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-196">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="8a01d-197">Bu yöntem, sonraki tek sayının asal olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="8a01d-197">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="8a01d-198">Asal ise, yöntemi, `bigPrime` <xref:System.Windows.Controls.TextBlock> bulmayı yansıtacak şekilde doğrudan öğesini güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-198">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="8a01d-199">Bu, hesaplamayı, bileşeni oluşturmak için kullanılan aynı iş parçacığında gerçekleştiğinden, bunu yapabiliriz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-199">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="8a01d-200">Hesaplama için ayrı bir iş parçacığı kullanmayı seçtik, daha karmaşık bir eşitleme mekanizması kullanmak ve güncelleştirmeyi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığında yürütmek istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-200">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-201">Bu durumu daha sonra göstereceğiz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-201">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="8a01d-202">Bu örneğe ilişkin tam kaynak kodu için, [uzun süre çalışan hesaplama örneğiyle tek Iş parçacıklı uygulamaya](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication) bakın</span><span class="sxs-lookup"><span data-stu-id="8a01d-202">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="8a01d-203">Bir arka plan Iş parçacığı ile engelleyici Işlemi işleme</span><span class="sxs-lookup"><span data-stu-id="8a01d-203">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="8a01d-204">Grafik uygulamada engelleme işlemlerini işleme zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-204">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="8a01d-205">Uygulama dondurmak için göründüğünden olay işleyicilerinden engelleme yöntemlerini çağırmak istemiyorum.</span><span class="sxs-lookup"><span data-stu-id="8a01d-205">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="8a01d-206">Bu işlemleri işlemek için ayrı bir iş parçacığı kullanabiliriz, ancak işiniz bittiğinde [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığından doğrudan GUI 'yi değiştiremedik için iş parçacığıyla eşitliyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-206">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="8a01d-207"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> İş parçacığının içine temsilciler eklemek için veya kullanabilirsiniz <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-207">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-208">Sonuç olarak, bu Temsilciler öğeleri değiştirme izniyle yürütülür [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-208">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="8a01d-209">Bu örnekte, hava durumu tahminini alan bir uzak yordam çağrısını taklit ediyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-209">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="8a01d-210">Bu çağrıyı yürütmek için ayrı bir çalışan iş parçacığı kullanıyoruz ve <xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] bitirtiğimiz sırada iş parçacığında bir güncelleştirme yöntemi zamanladık.</span><span class="sxs-lookup"><span data-stu-id="8a01d-210">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Hava durumu Kullanıcı arabirimini gösteren ekran görüntüsü.](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="8a01d-212">Aşağıda, belirtime bazı ayrıntılar verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-212">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="8a01d-213">Düğme Işleyicisi oluşturma</span><span class="sxs-lookup"><span data-stu-id="8a01d-213">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="8a01d-214">Düğmeye tıklandığında saat çizimi görüntülenir ve canlandırarak başlayın.</span><span class="sxs-lookup"><span data-stu-id="8a01d-214">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="8a01d-215">Düğmeyi devre dışı bıraktık.</span><span class="sxs-lookup"><span data-stu-id="8a01d-215">We disable the button.</span></span> <span data-ttu-id="8a01d-216">`FetchWeatherFromServer`Yöntemi yeni bir iş parçacığında çağırır ve sonra geri döntiğimiz için <xref:System.Windows.Threading.Dispatcher> Hava durumu tahminini toplamayı beklerken olayları işlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a01d-216">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="8a01d-217">Hava durumu getiriliyor</span><span class="sxs-lookup"><span data-stu-id="8a01d-217">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="8a01d-218">Şeyleri basit tutmak için, bu örnekte aslında hiçbir ağ kodu yoktur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-218">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="8a01d-219">Bunun yerine, yeni iş parçacığını dört saniye boyunca uykuya yerleştirerek ağ erişimi gecikmesi benzetimi yapılır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-219">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="8a01d-220">Bu süre içinde, özgün [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı çalışmaya devam eder ve olaylara yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-220">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="8a01d-221">Bunu göstermek için, çalışan bir animasyon kalmadı ve simge durumuna küçült ve büyüt düğmeleri de çalışmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="8a01d-221">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="8a01d-222">Gecikme bittiğinde ve hava durumu tahminimizi gelişigüzel bir şekilde seçtiğimiz zaman, iş parçacığına yeniden rapor veririz [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-222">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-223">Bu, iş parçacığı tarafından iş parçacığında öğesine bir çağrı zamanlayarak yapılır `UpdateUserInterface` [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-223">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="8a01d-224">Bu zamanlanmış yöntem çağrısına hava durumunu açıklayan bir dize geçiririz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-224">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="8a01d-225">Güncelleştirme[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="8a01d-225">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="8a01d-226"><xref:System.Windows.Threading.Dispatcher> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] İş parçacığında zaman olduğunda, zamanlanan çağrısını yürütür `UpdateUserInterface` .</span><span class="sxs-lookup"><span data-stu-id="8a01d-226">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="8a01d-227">Bu yöntem saat animasyonunu durdurup hava durumunu tanımlayacak bir görüntü seçer.</span><span class="sxs-lookup"><span data-stu-id="8a01d-227">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="8a01d-228">Bu görüntüyü görüntüler ve "tahmin getirme" düğmesini geri yükler.</span><span class="sxs-lookup"><span data-stu-id="8a01d-228">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="8a01d-229">Birden çok pencere, birden çok Iş parçacığı</span><span class="sxs-lookup"><span data-stu-id="8a01d-229">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="8a01d-230">Bazı [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalar birden çok üst düzey pencere gerektirir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-230">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="8a01d-231">Birden çok pencere yönetmek için bir Iş parçacığı/birleşim için mükemmel bir kabul edilebilir <xref:System.Windows.Threading.Dispatcher> , ancak bazen birkaç iş parçacığı daha iyi bir iş olur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-231">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="8a01d-232">Bu durum özellikle, bir Windows 'un iş parçacığını tekeline alacak herhangi bir şansınız varsa geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-232">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="8a01d-233">Windows Gezgini bu biçimde çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-233">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="8a01d-234">Her yeni Gezgin penceresi orijinal işleme aittir, ancak bağımsız bir iş parçacığının denetimi altında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-234">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="8a01d-235">Bir denetim kullanarak [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.Controls.Frame> Web sayfalarını görüntüleriz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-235">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="8a01d-236">Kolayca basit bir Internet Explorer yerine kolayca oluşturabiliyoruz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-236">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="8a01d-237">Önemli bir özellik ile başlıyoruz: yeni bir Gezgin penceresi açma özelliği.</span><span class="sxs-lookup"><span data-stu-id="8a01d-237">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="8a01d-238">Kullanıcı "yeni pencere" düğmesine tıkladığında, ayrı bir iş parçacığında penceremizin kopyasını başladık.</span><span class="sxs-lookup"><span data-stu-id="8a01d-238">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="8a01d-239">Bu şekilde, Windows 'un birindeki uzun süreli veya engelleyici işlemler diğer tüm pencereleri kilitlemez.</span><span class="sxs-lookup"><span data-stu-id="8a01d-239">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="8a01d-240">Gerçekte, Web tarayıcısı modelinin karmaşık iş parçacığı modeli vardır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-240">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="8a01d-241">Çoğu okuyucuları tanımak gerektiğinden, bunu seçtik.</span><span class="sxs-lookup"><span data-stu-id="8a01d-241">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="8a01d-242">Aşağıdaki örnek kodu gösterir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-242">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="8a01d-243">Bu kodun aşağıdaki iş parçacığı kesimleri, bu bağlamda bizimle ilgili en ilginç bir koddur:</span><span class="sxs-lookup"><span data-stu-id="8a01d-243">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="8a01d-244">Bu yöntem, "yeni pencere" düğmesine tıklandığında çağrılır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-244">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="8a01d-245">Yeni bir iş parçacığı oluşturur ve zaman uyumsuz olarak başlatır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-245">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="8a01d-246">Bu yöntem, yeni iş parçacığının başlangıç noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-246">This method is the starting point for the new thread.</span></span> <span data-ttu-id="8a01d-247">Bu iş parçacığının denetimi altında yeni bir pencere oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="8a01d-247">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="8a01d-248"><xref:System.Windows.Threading.Dispatcher>yeni iş parçacığını yönetmek için otomatik olarak yeni bir oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-248">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="8a01d-249">Tüm bunları, pencereyi başlatmak için yapmanız gerekir <xref:System.Windows.Threading.Dispatcher> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-249">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="8a01d-250">Teknik ayrıntılar ve geçmiş noktaları</span><span class="sxs-lookup"><span data-stu-id="8a01d-250">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="8a01d-251">Iş parçacığı kullanarak bileşen yazma</span><span class="sxs-lookup"><span data-stu-id="8a01d-251">Writing Components Using Threading</span></span>
 <span data-ttu-id="8a01d-252">Microsoft .NET Framework Geliştirici Kılavuzu, bir bileşenin istemcilerine zaman uyumsuz davranış sergileme şeklini gösteren bir model tanımlar (bkz. [olay tabanlı zaman uyumsuz düzene genel bakış](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="8a01d-252">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="8a01d-253">Örneğin, `FetchWeatherFromServer` yöntemi yeniden kullanılabilir, grafik olmayan bir bileşene paketlemek istediğinizi varsayalım.</span><span class="sxs-lookup"><span data-stu-id="8a01d-253">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="8a01d-254">Standart Microsoft .NET Framework deseninin ardından bu, aşağıdaki gibi görünür.</span><span class="sxs-lookup"><span data-stu-id="8a01d-254">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="8a01d-255">`GetWeatherAsync`, bir arka plan iş parçacığı oluşturma gibi daha önce açıklanan tekniklerin birini kullanarak, çağrıyı zaman uyumsuz olarak işler, çağıran iş parçacığını engeller.</span><span class="sxs-lookup"><span data-stu-id="8a01d-255">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="8a01d-256">Bu düzenin en önemli bölümlerinden biri, *MethodName* `Completed` Ile başlamak için *MethodName* yöntemini çağıran aynı iş parçacığında MethodName metodunu çağırıyor `Async` .</span><span class="sxs-lookup"><span data-stu-id="8a01d-256">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="8a01d-257">Bunu [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] depolayarak oldukça kolay bir şekilde yapabilirsiniz, <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A> ancak grafik olmayan bileşen [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Windows Forms veya ASP.net programlarında değil yalnızca uygulamalarda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-257">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="8a01d-258"><xref:System.Windows.Threading.DispatcherSynchronizationContext>Sınıfı bu ihtiyacı ele <xref:System.Windows.Threading.Dispatcher> alınmaktadır. Bu, diğer çerçeveler ile birlikte da bilinen basitleştirilmiş bir sürümü olarak düşünün [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-258">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="8a01d-259">İç içe pompalama</span><span class="sxs-lookup"><span data-stu-id="8a01d-259">Nested Pumping</span></span>
 <span data-ttu-id="8a01d-260">Bazen iş parçacığının tamamen kilitlenmesinden mümkün değildir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-260">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-261">Sınıfın yöntemini ele alalım <xref:System.Windows.MessageBox.Show%2A> <xref:System.Windows.MessageBox> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-261">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="8a01d-262"><xref:System.Windows.MessageBox.Show%2A>Kullanıcı Tamam düğmesine tıklaana kadar döndürmez.</span><span class="sxs-lookup"><span data-stu-id="8a01d-262"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="8a01d-263">Ancak, etkileşimli olması için ileti döngüsüne sahip olması gereken bir pencere oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-263">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="8a01d-264">Kullanıcının Tamam 'a tıklamasını beklerken, özgün uygulama penceresi Kullanıcı girişine yanıt vermez.</span><span class="sxs-lookup"><span data-stu-id="8a01d-264">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="8a01d-265">Ancak, boyama iletilerini işlemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="8a01d-265">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="8a01d-266">Özgün pencere, kapsandığınızda ve gösterildiğinde kendisini yeniden çizer.</span><span class="sxs-lookup"><span data-stu-id="8a01d-266">The original window redraws itself when covered and revealed.</span></span>

 ![Tamam düğmesi ile MessageBox gösteren ekran görüntüsü](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="8a01d-268">Bazı iş parçacıklarının ileti kutusu penceresinde bir ücret olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-268">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="8a01d-269">yalnızca ileti kutusu penceresi için yeni bir iş parçacığı oluşturulabilir, ancak bu iş parçacığı özgün penceredeki devre dışı bırakılmış öğeleri boyayamadı (karşılıklı dışlamanın önceki tartışmasını hatırlayın).</span><span class="sxs-lookup"><span data-stu-id="8a01d-269">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="8a01d-270">Bunun yerine, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] iç içe geçmiş bir ileti işleme sistemi kullanır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-270">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="8a01d-271"><xref:System.Windows.Threading.Dispatcher>Sınıfı <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> , bir uygulamanın geçerli yürütme noktasını depolayan, sonra yeni bir ileti döngüsü Başlatan adlı özel bir yöntemi içerir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-271">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="8a01d-272">İç içe geçmiş ileti döngüsü tamamlandığında, yürütme özgün çağrıdan sonra devam eder <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-272">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="8a01d-273">Bu durumda, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> çağrısında program bağlamını korur <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType> ve arka plan penceresini yeniden boyamak ve ileti kutusu penceresine girişi işlemek için yeni bir ileti döngüsü başlatır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-273">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="8a01d-274">Kullanıcı Tamam ' ı tıklattığında ve açılır pencereyi temizlediğinde, iç içe geçmiş döngü çıkar ve çağrısından sonra devam eder <xref:System.Windows.MessageBox.Show%2A> .</span><span class="sxs-lookup"><span data-stu-id="8a01d-274">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="8a01d-275">Eski yönlendirilmiş olaylar</span><span class="sxs-lookup"><span data-stu-id="8a01d-275">Stale Routed Events</span></span>
 <span data-ttu-id="8a01d-276">İçindeki yönlendirilmiş olay sistemi, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Olaylar oluşturulduğunda tüm ağaçlara bildirir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-276">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="8a01d-277">Elips üzerinde sol fare düğmesine basıldığında `handler2` yürütülür.</span><span class="sxs-lookup"><span data-stu-id="8a01d-277">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="8a01d-278">`handler2`Tamamlandıktan sonra olay, <xref:System.Windows.Controls.Canvas> işlemek için kullanılan nesnesine geçirilir `handler1` .</span><span class="sxs-lookup"><span data-stu-id="8a01d-278">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="8a01d-279">Bu yalnızca `handler2` olay nesnesini açıkça işlenmiş olarak işaretlemediğinde gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-279">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="8a01d-280">`handler2`Bu olayı işlemek çok uzun sürecek.</span><span class="sxs-lookup"><span data-stu-id="8a01d-280">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="8a01d-281">`handler2`<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, saat döndürmeyen bir iç içe ileti döngüsünü başlatmak için kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-281">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="8a01d-282">`handler2`Bu ileti döngüsü tamamlandığında olayı işlenmiş olarak işaretlemeirse, etkinlik çok eski olsa bile ağaca geçirilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-282">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="8a01d-283">Yeniden giriş ve kilitleme</span><span class="sxs-lookup"><span data-stu-id="8a01d-283">Reentrancy and Locking</span></span>
 <span data-ttu-id="8a01d-284">Ortak dil çalışma zamanının (CLR) kilitleme mekanizması tam olarak tek bir şekilde davranmayabilir; bir kilit istenirken bir iş parçacığının işlemi tamamen durdurmasından kaynaklanabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-284">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="8a01d-285">Gerçekte, iş parçacığı yüksek öncelikli iletileri almaya ve işlemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="8a01d-285">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="8a01d-286">Bu, kilitlenmeleri önlemeye yardımcı olur ve arabirimlerin düşük ölçüde yanıt vermesini sağlar, ancak hafif hatalara yönelik olasılığı ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-286">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="8a01d-287">Bu sürenin büyük çoğunluğunda, bununla ilgili herhangi bir şey bilmeniz gerekmez, ancak nadir koşullarda (genellikle Win32 pencere iletilerini veya COM STA bileşenlerini içeren) Bu durum yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-287">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="8a01d-288">Çoğu arabirim, iş parçacığı güvenliği göz önünde bulundurularak derlenmez çünkü geliştiriciler bir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] tarafından hiç bir iş parçacığı tarafından hiçbir şekilde erişilmediği varsayılarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-288">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="8a01d-289">Bu durumda, bu tek iş parçacığı beklenmedik zamanlarda çevresel değişiklikler yapabilir ve bu da <xref:System.Windows.Threading.DispatcherObject> karşılıklı dışlama mekanizmasının çözülenmesinin beklenen etkileri olur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-289">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="8a01d-290">Aşağıdaki sözde kodu göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="8a01d-290">Consider the following pseudocode:</span></span>

 <span data-ttu-id="8a01d-291">![İş parçacığı yeniden girişi gösteren diyagram.](./media/threading-model/threading-reentrancy.png "Threadingreentrance")</span><span class="sxs-lookup"><span data-stu-id="8a01d-291">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="8a01d-292">Çoğu zaman doğru şeydir, ancak [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Bu tür beklenmeyen yeniden giriş sorunları sorunlara neden olabileceği zamanlar vardır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-292">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="8a01d-293">Bu nedenle, belirli anahtar süreleriyle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] çağırır <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A> , bu iş parçacığının kilit yönergesini, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] her zamanki clr kilidi yerine yeniden giriş, serbest bir kilit kullanacak şekilde değiştirir.</span><span class="sxs-lookup"><span data-stu-id="8a01d-293">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="8a01d-294">Bu nedenle, CLR ekibi neden bu davranışı seçmişmidir?</span><span class="sxs-lookup"><span data-stu-id="8a01d-294">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="8a01d-295">COM STA nesneleri ve sonlandırma iş parçacığı ile yapması gerekiyordu.</span><span class="sxs-lookup"><span data-stu-id="8a01d-295">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="8a01d-296">Bir nesne atık olarak toplandığında, `Finalize` yöntemi iş parçacığı değil, ayrılmış Sonlandırıcı iş parçacığında çalıştırılır [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-296">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-297">İş parçacığı üzerinde oluşturulan bir COM STA nesnesi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] yalnızca iş parçacığı üzerinde atıyacağından, bu da sorunu çıkarmaktadır [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="8a01d-297">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="8a01d-298">CLR, bir öğesinin eşdeğerini yapar <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (Bu örnekte Win32's kullanarak `SendMessage` ).</span><span class="sxs-lookup"><span data-stu-id="8a01d-298">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="8a01d-299">Ancak [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı meşgulse, Sonlandırıcı iş parçacığı durduruldu ve com STA nesnesi atılamaz ve bu da ciddi bir bellek sızıntısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8a01d-299">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="8a01d-300">Bu nedenle, CLR ekibi kilitleri yapmak için zor çağrıyı yaptığı gibi çalışır.</span><span class="sxs-lookup"><span data-stu-id="8a01d-300">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="8a01d-301">İçin görevi, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Bellek sızıntısını yeniden bildirmeden beklenmedik bir şekilde yeniden giriş yapmaktan kaçınmaktır. bu nedenle her yerde yeniden giriş yapmayın.</span><span class="sxs-lookup"><span data-stu-id="8a01d-301">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="8a01d-302">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="8a01d-302">See also</span></span>

- [<span data-ttu-id="8a01d-303">Uzun süre çalışan hesaplama örneği olan tek Iş parçacıklı uygulama</span><span class="sxs-lookup"><span data-stu-id="8a01d-303">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
