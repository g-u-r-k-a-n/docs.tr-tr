---
title: Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı
description: .NET ' te iş parçacığı güvenli bir koleksiyonun ne zaman kullanılacağını öğrenin. Çok iş parçacıklı ekleme & kaldırma işlemlerini desteklemek için özel olarak tasarlanan 5 koleksiyon türü vardır.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: cea9c038896d07d526874e2ae4c33e479eaa3963
ms.sourcegitcommit: 5fd4696a3e5791b2a8c449ccffda87f2cc2d4894
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/15/2020
ms.locfileid: "84769139"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="3a3fa-104">Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı</span><span class="sxs-lookup"><span data-stu-id="3a3fa-104">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="3a3fa-105">.NET Framework 4, çok iş parçacıklı ekleme ve kaldırma işlemlerini desteklemek için özel olarak tasarlanan beş yeni koleksiyon türü sunar.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-105">The .NET Framework 4 introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="3a3fa-106">İş parçacığı güvenliği sağlamak için, bu yeni türler çeşitli verimli kilitleme ve kilitleme ücretsiz eşitleme mekanizmalarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-106">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="3a3fa-107">Eşitleme bir işleme ek yük ekler.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-107">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="3a3fa-108">Ek yük miktarı, kullanılan eşitleme türüne, gerçekleştirilen işlem türüne ve koleksiyona eşzamanlı olarak erişmeye çalışan iş parçacığı sayısı gibi diğer faktörlere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-108">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="3a3fa-109">Bazı senaryolarda, eşitleme ek yükü göz ardı edilebilir değildir ve çok iş parçacıklı türün bir dış kilit tarafından korunurken iş parçacığı açısından güvenli olmayan eşinden daha iyi bir şekilde ölçeklenebilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-109">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="3a3fa-110">Diğer senaryolarda, ek yük, iş parçacığı güvenli türünün aynı veya daha yavaş bir şekilde, bu tür iş parçacığı güvenli olmayan bir sürümüne göre çalışmasını ve ölçeklendirilmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-110">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="3a3fa-111">Aşağıdaki bölümlerde, iş parçacığı güvenli bir koleksiyonun ne zaman kullanıldığı, okuma ve yazma işlemleri etrafında Kullanıcı tarafından sağlanmış bir kilit olan iş parçacığı güvenli olmayan eşdeğerine karşı genel rehberlik sağlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-111">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="3a3fa-112">Performans birçok etkene bağlı olarak farklılık gösterebileceğinden, kılavuz özel değildir ve tüm durumlarda geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-112">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="3a3fa-113">Performans çok önemliyse, hangi koleksiyon türünün kullanılacağını belirlemenin en iyi yolu, temsili bilgisayar yapılandırmalarına ve yüklerine göre performansı ölçmaktır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-113">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="3a3fa-114">Bu belge aşağıdaki terimleri kullanır:</span><span class="sxs-lookup"><span data-stu-id="3a3fa-114">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="3a3fa-115">*Saf üretici-tüketici senaryosu*</span><span class="sxs-lookup"><span data-stu-id="3a3fa-115">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="3a3fa-116">Verilen herhangi bir iş parçacığı öğe ekliyor veya kaldırıyor, ancak her ikisine birden değil.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-116">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="3a3fa-117">*Karma üretici-tüketici senaryosu*</span><span class="sxs-lookup"><span data-stu-id="3a3fa-117">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="3a3fa-118">Verilen herhangi bir iş parçacığı, öğeleri ekleme ve kaldırma.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-118">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="3a3fa-119">*PLINQ 'te hızlandırmayı*</span><span class="sxs-lookup"><span data-stu-id="3a3fa-119">*Speedup*</span></span>  
 <span data-ttu-id="3a3fa-120">Aynı senaryodaki diğer bir türe göre daha hızlı algoritmik performansı.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-120">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="3a3fa-121">*Ölçeklenebilirlik*</span><span class="sxs-lookup"><span data-stu-id="3a3fa-121">*Scalability*</span></span>  
 <span data-ttu-id="3a3fa-122">Performans artışı, bilgisayardaki çekirdek sayısıyla orantılıdır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-122">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="3a3fa-123">Ölçeklendirilen bir algoritma, iki çekirdekden daha fazla sekiz çekirdekli daha hızlı gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-123">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="3a3fa-124">ConcurrentQueue (T) ve Queue (T) karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="3a3fa-124">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="3a3fa-125">Saf üretici-tüketici senaryolarında her öğe için işlem zamanının çok küçük (birkaç yönerge) olduğu durumlarda, <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> bir <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> dış kilidine sahip olan bir üzerinde ila büyüklükteki performans avantajları sunabilir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-125">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="3a3fa-126">Bu senaryoda, <xref:System.Collections.Concurrent.ConcurrentQueue%601> ayrılmış bir iş parçacığının kuyruğa alınması ve ayrılmış bir iş parçacığının de de sıraya alınması durumunda en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-126">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="3a3fa-127">Bu kuralı zorunlu kılmaz, <xref:System.Collections.Generic.Queue%601> <xref:System.Collections.Concurrent.ConcurrentQueue%601> birden fazla çekirdeğe sahip bilgisayarlardan daha hızlı bir şekilde daha hızlı işlem yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-127">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="3a3fa-128">İşlem süresi 500 FLOPS (kayan nokta işlemleri) veya daha fazla olduğunda, iki iş parçacığı kuralı için geçerli değildir <xref:System.Collections.Concurrent.ConcurrentQueue%601> , daha sonra çok iyi ölçeklenebilirlik vardır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-128">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="3a3fa-129"><xref:System.Collections.Generic.Queue%601>Bu senaryoda iyi ölçeklenmez.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-129"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="3a3fa-130">Karma üretici-tüketici senaryolarında, işleme süresi çok küçük olduğunda, bir <xref:System.Collections.Generic.Queue%601> dış kilit ölçeği bundan daha iyidir <xref:System.Collections.Concurrent.ConcurrentQueue%601> .</span><span class="sxs-lookup"><span data-stu-id="3a3fa-130">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="3a3fa-131">Ancak, işleme süresi 500 kat veya daha uzun bir süre içinde olduğunda, <xref:System.Collections.Concurrent.ConcurrentQueue%601> daha sonra ölçeklendirir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-131">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="3a3fa-132">ConcurrentStack ile yığın karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="3a3fa-132">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="3a3fa-133">Saf üretici-tüketici senaryolarında, işlem süresi çok küçük olduğunda <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> ve bir <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> dış kilit varsa, büyük olasılıkla bir ayrılmış gönderme iş parçacığı ve ayrılmış bir kayan iş parçacığı ile aynı şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-133">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="3a3fa-134">Ancak, iş parçacıklarının sayısı arttıkça her iki tür de daha fazla çekişme nedeniyle yavaşlar ve <xref:System.Collections.Generic.Stack%601> bundan daha iyi çalışabilir <xref:System.Collections.Concurrent.ConcurrentStack%601> .</span><span class="sxs-lookup"><span data-stu-id="3a3fa-134">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="3a3fa-135">İşlem süresi 500 kat veya daha uzun bir süre içinde olduğunda her iki tür de aynı fiyata göre ölçeklendirilir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-135">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="3a3fa-136">Karma üretici-tüketici senaryolarında <xref:System.Collections.Concurrent.ConcurrentStack%601> hem küçük hem de büyük iş yükleri için daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-136">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="3a3fa-137">Ve kullanımı, <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> erişim sürelerini önemli ölçüde hızlandırabilir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-137">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="3a3fa-138">ConcurrentDictionary ve sözlük karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="3a3fa-138">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="3a3fa-139">Genel olarak, <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> birden çok iş parçacığından aynı anda anahtar veya değer eklediğiniz ve güncelleştirdiğiniz herhangi bir senaryoda bir kullanın.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-139">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="3a3fa-140">Sık sık güncelleştirmeler ve görece birkaç okuma içeren senaryolarda, genellikle daha fazla <xref:System.Collections.Concurrent.ConcurrentDictionary%602> avantaj sunar.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-140">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="3a3fa-141">Birçok okuma ve birçok güncelleştirme içeren senaryolarda, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> genellikle herhangi bir sayıda çekirdeği olan bilgisayarlarda önemli ölçüde daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-141">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="3a3fa-142">Sık sık güncelleştirmeler içeren senaryolarda, içindeki eşzamanlılık derecesini artırabilir <xref:System.Collections.Concurrent.ConcurrentDictionary%602> ve daha fazla çekirdeğe sahip bilgisayarlarda performansın artmasının yapılıp yapılmayacağını görmek için ölçebilir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-142">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="3a3fa-143">Eşzamanlılık düzeyini değiştirirseniz, genel işlemlerden mümkün olduğunca kaçının.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-143">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="3a3fa-144">Yalnızca anahtar veya değerleri okuyorsanız, <xref:System.Collections.Generic.Dictionary%602> Sözlük hiçbir iş parçacığı tarafından değiştirilmemişse hiçbir eşitleme gerekmediğinden, daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-144">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="3a3fa-145">ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="3a3fa-145">ConcurrentBag</span></span>  
 <span data-ttu-id="3a3fa-146">Saf üretici-tüketici senaryolarında, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> muhtemelen diğer eşzamanlı koleksiyon türlerinden daha yavaş çalışacak.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-146">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="3a3fa-147">Karma üretici-tüketici senaryolarında, <xref:System.Collections.Concurrent.ConcurrentBag%601> genellikle büyük ve küçük iş yükleri için diğer eş zamanlı koleksiyon türünden daha hızlı ve daha ölçeklenebilir olur.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-147">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="3a3fa-148">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="3a3fa-148">BlockingCollection</span></span>  
 <span data-ttu-id="3a3fa-149">Sınırlama ve engelleme semantiği gerektiğinde, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> büyük olasılıkla herhangi bir özel uygulamadan daha hızlı gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-149">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="3a3fa-150">Ayrıca zengin iptal, numaralandırma ve özel durum işlemeyi da destekler.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-150">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3a3fa-151">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="3a3fa-151">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="3a3fa-152">İş parçacığı güvenli Koleksiyonlar</span><span class="sxs-lookup"><span data-stu-id="3a3fa-152">Thread-Safe Collections</span></span>](index.md)
- [<span data-ttu-id="3a3fa-153">Paralel programlama</span><span class="sxs-lookup"><span data-stu-id="3a3fa-153">Parallel Programming</span></span>](../../parallel-programming/index.md)
