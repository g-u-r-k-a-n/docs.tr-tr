---
title: Altyapı kalıcılık katmanını tasarlama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmetleri mimarisi | Altyapı kalıcılığı katmanının tasarımında depo modelini keşfet.
ms.date: 10/08/2018
ms.openlocfilehash: f1c5df1cc5672760374610a416ae22b45cd76c25
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/07/2019
ms.locfileid: "73737930"
---
# <a name="design-the-infrastructure-persistence-layer"></a><span data-ttu-id="bd5c2-103">Altyapı kalıcılığı katmanını tasarlama</span><span class="sxs-lookup"><span data-stu-id="bd5c2-103">Design the infrastructure persistence layer</span></span>

<span data-ttu-id="bd5c2-104">Veri kalıcılığı bileşenleri, bir mikro hizmetin sınırları içinde (bir mikro hizmetin veritabanı) barındırılan verilere erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="bd5c2-105">Bunlar, özel Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> nesneleri gibi depolar ve [iş sınıfları birimi](https://martinfowler.com/eaaCatalog/unitOfWork.html) gibi bileşenlerin gerçek uygulamasını içerirler.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span> <span data-ttu-id="bd5c2-106">EF DbContext, hem depoyu hem de çalışma birimi düzenlerini uygular.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-106">EF DbContext implements both, the Repository and the Unit of Work patterns.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="bd5c2-107">Depo deseninin</span><span class="sxs-lookup"><span data-stu-id="bd5c2-107">The Repository pattern</span></span>

<span data-ttu-id="bd5c2-108">Depolar, veri kaynaklarına erişmek için gereken mantığı kapsülleyen sınıflardır veya bileşenlerdir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="bd5c2-109">Daha iyi bakım sağlar ve etki alanı modeli katmanından veritabanlarına erişmek için kullanılan altyapıyı veya teknolojiyi ayırır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="bd5c2-110">Entity Framework gibi bir nesne Ilişkisel Eşleyici (ORM) kullanıyorsanız, uygulanması gereken kod, LINQ ve güçlü yazma sayesinde basitleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-110">If you use an Object-Relational Mapper (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="bd5c2-111">Bu, veri erişimi sıhhi tesisat yerine veri Kalıcılık mantığına odaklanmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="bd5c2-112">Depo stili, bir veri kaynağıyla çalışma konusunda iyi belgelenmiş bir yoldur.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="bd5c2-113">[Kurumsal uygulama mimarisinin kitap desenlerinde](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Marwler, bir depoyu aşağıda gösterildiği gibi açıklar:</span><span class="sxs-lookup"><span data-stu-id="bd5c2-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="bd5c2-114">Bir depo, etki alanı modeli katmanları ve veri eşleme arasında bir aracı görevleri gerçekleştirerek, bellekteki bir etki alanı nesnesi kümesine benzer bir şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="bd5c2-115">İstemci nesneleri bildirimli olarak sorgu oluşturma ve yanıtlar için depolara gönderme.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="bd5c2-116">Kavramsal olarak, bir depo veritabanında depolanan bir nesne kümesini ve bunlar üzerinde gerçekleştirilebilecek işlemleri, kalıcılık katmanına daha yakın bir şekilde sunar.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="bd5c2-117">Depolar, Ayrıca, iş etki alanı ve veri ayırma veya eşleme arasındaki bağımlılığı açıkça ve tek bir yönde ayırma amacını destekler.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="bd5c2-118">Toplama başına bir depo tanımla</span><span class="sxs-lookup"><span data-stu-id="bd5c2-118">Define one repository per aggregate</span></span>

<span data-ttu-id="bd5c2-119">Her toplama veya toplama kökünde, bir depo sınıfı oluşturmalısınız.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="bd5c2-120">Etki alanı odaklı tasarım (DDD) desenlerine dayanan bir mikro hizmette, veritabanını güncelleştirmek için kullanmanız gereken tek kanal depolar olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-120">In a microservice based on Domain-Driven Design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="bd5c2-121">Bunun nedeni, toplamanın ıntürevlerini ve işlemsel tutarlılığını denetleyen toplam kökle bire bir ilişkiye sahip olmaleridir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="bd5c2-122">Sorgular veritabanının durumunu değiştirmediğinden, veritabanını diğer kanallar aracılığıyla (CQRS yaklaşımını takip edebilirsiniz) sorgulamak çok normaldir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-122">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="bd5c2-123">Ancak, işlem alanı (diğer bir deyişle, güncelleştirmeler) her zaman depolar ve toplam köklerle denetlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-123">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="bd5c2-124">Temel olarak, bir depo, verileri etki alanı varlıkları biçimindeki veritabanından gelen bellekte doldurmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="bd5c2-125">Varlıklar belleğe alındıktan sonra, bunlar değiştirilebilir ve sonra işlemler aracılığıyla veritabanına kalıcı olarak geri alınabilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="bd5c2-126">Daha önce belirtildiği gibi, CQS/CQRS mimari modelini kullanıyorsanız, ilk sorgular, baber kullanılarak basit SQL deyimleriyle gerçekleştirilen, etki alanı modelinden yan sorgular tarafından gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-126">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="bd5c2-127">İhtiyacınız olan tabloları sorgulayabilir ve birleştiremezsiniz ve bu sorgular toplamaların kuralları tarafından kısıtlanmadığından, bu yaklaşım depolardan çok daha esnektir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="bd5c2-128">Bu veriler Sunu katmanına veya istemci uygulamasına gider.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-128">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="bd5c2-129">Kullanıcı değişiklik yaptığında, görüntülenecek veriler istemci uygulamasından veya sunu katmanından uygulama katmanına (örneğin, bir Web API hizmeti) gönderilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-129">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="bd5c2-130">Komut işleyicisinde bir komut aldığınızda, veritabanından güncelleştirmek istediğiniz verileri almak için depoları kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-130">When you receive a command in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="bd5c2-131">Komutları ile geçilen verilerle birlikte güncelleştirir ve sonra bir işlem aracılığıyla veritabanındaki verileri (etki alanı varlıkları) eklersiniz veya güncelleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-131">You update it in memory with the data passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="bd5c2-132">Şekil 7-17 ' de gösterildiği gibi, her bir toplama kökü için yalnızca bir depoyu tanımlamanız gerektiğini bir kez daha vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-132">It's important to emphasize again that you should only define one repository for each aggregate root, as shown in Figure 7-17.</span></span> <span data-ttu-id="bd5c2-133">Toplama içindeki tüm nesneler arasında işlem tutarlılığı sağlamak üzere toplama kökünün amacını elde etmek için, veritabanındaki her tablo için asla bir depo oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![Etki alanı ve diğer altyapının ilişkilerini gösteren diyagram.](./media/infrastructure-persistence-layer-design/repository-aggregate-database-table-relationships.png)

<span data-ttu-id="bd5c2-135">**Şekil 7-17**.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-135">**Figure 7-17**.</span></span> <span data-ttu-id="bd5c2-136">Depolar, Toplamalar ve veritabanı tabloları arasındaki ilişki</span><span class="sxs-lookup"><span data-stu-id="bd5c2-136">The relationship between repositories, aggregates, and database tables</span></span>

<span data-ttu-id="bd5c2-137">Yukarıdaki diyagramda, etki alanı ve altyapı katmanları arasındaki ilişkiler gösterilmektedir: alıcı toplamı, Ibuygurca ve sıra toplama, ıorderrepository arabirimlerine göre değişir, bu arabirimler altyapı katmanında uygulanır UnitOfWork 'e bağlı olan ilgili depolarda, veri katmanındaki tablolara erişen, orada de uygulanmış olan depolar.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-137">The above diagram shows the relationships between Domain and Infrastructure layers: Buyer Aggregate depends on the IBuyerRepository and Order Aggregate depends on the IOrderRepository interfaces, these interfaces are implemented in the Infrastructure layer by the corresponding repositories that depend on UnitOfWork, also implemented there, that accesses the tables in the Data tier.</span></span>

### <a name="enforce-one-aggregate-root-per-repository"></a><span data-ttu-id="bd5c2-138">Her depo için bir toplama kökünü zorla</span><span class="sxs-lookup"><span data-stu-id="bd5c2-138">Enforce one aggregate root per repository</span></span>

<span data-ttu-id="bd5c2-139">Depo tasarımınızın, yalnızca toplam köklerin depolara sahip olması için kuralı zorunlu kıldığı şekilde uygulanması yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-139">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="bd5c2-140">`IAggregateRoot` işaretleyici arabirimine sahip olduklarından emin olmak için, çalıştığı varlıkların türünü kısıtlayan genel veya temel bir depo türü oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-140">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="bd5c2-141">Bu nedenle, altyapı katmanında uygulanan her depo sınıfı, aşağıdaki kodda gösterildiği gibi kendi sözleşmesini veya arabirimini uygular:</span><span class="sxs-lookup"><span data-stu-id="bd5c2-141">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="bd5c2-142">Her belirli depo arabirimi genel ırepository arabirimini uygular:</span><span class="sxs-lookup"><span data-stu-id="bd5c2-142">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="bd5c2-143">Ancak, kodun her deponun tek bir toplama ile ilgili olduğunu bir şekilde zorlayacağından daha iyi bir yol, genel depo türünü uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-143">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="bd5c2-144">Bu şekilde, belirli bir toplamı hedeflemek için bir depo kullandığınızı açıktır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-144">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="bd5c2-145">Bu, aşağıdaki kodda olduğu gibi genel bir `IRepository` temel arabirimi uygulayarak kolayca yapılabilir:</span><span class="sxs-lookup"><span data-stu-id="bd5c2-145">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="bd5c2-146">Depo deseninin test etme, Uygulama mantığınızı daha kolay hale getirir</span><span class="sxs-lookup"><span data-stu-id="bd5c2-146">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="bd5c2-147">Depo deseninin, uygulamanızı birim testlerle kolayca test etmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-147">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="bd5c2-148">Birim testlerinin altyapıyı değil yalnızca kodunuzu test eder, bu nedenle depo soyutlamaları bu amaca ulaşmak için daha kolay hale gelir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-148">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="bd5c2-149">Önceki bölümde belirtildiği gibi, Web API mikro hizmetiniz gibi uygulama katmanının, uyguladığınız altyapı katmanına doğrudan bağlı olmaması için, depo arabirimlerini etki alanı modeli katmanına tanımlamanız ve yerleştirmeniz önerilir gerçek depo sınıfları.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-149">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="bd5c2-150">Bunu yaparak ve Web API 'nizin denetleyicilerine bağımlılık ekleme işlemini kullanarak, veritabanından veri yerine sahte veriler döndüren sahte depolar uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-150">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="bd5c2-151">Bu ayrılmış yaklaşım, veritabanına bağlantı gerektirmeden uygulamanızın mantığını odaklan birim testleri oluşturmanıza ve çalıştırmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-151">This decoupled approach allows you to create and run unit tests that focus the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="bd5c2-152">Veritabanlarına bağlantılar başarısız olabilir ve daha da önemlisi, bir veritabanında yüzlerce testi çalıştırmak iki nedenden dolayı hatalı olur.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-152">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="bd5c2-153">İlk olarak, çok sayıda test yüzünden uzun zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-153">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="bd5c2-154">İkincisi, veritabanı kayıtları, testlerin sonuçlarını değiştirebilir ve etkileyebilir, bu sayede tutarlı olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-154">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="bd5c2-155">Veritabanına karşı test etmek, bir tümleştirme testi değil, bir birim testi değildir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-155">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="bd5c2-156">Hızlı bir şekilde çalışan çok sayıda birim testiniz olması gerekir, ancak veritabanlarına göre daha az tümleştirme testi olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-156">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="bd5c2-157">Birim testleriyle ilgili sorunların ayrılması açısından, mantığınızın belleği içindeki etki alanı varlıkları üzerinde çalışır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-157">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="bd5c2-158">Depo sınıfının bu şekilde teslim edildiğini varsayar.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-158">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="bd5c2-159">Mantığınızın etki alanı varlıklarını değiştirdiğine göre, depo sınıfının bunları doğru depolayabileceği varsayılır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-159">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="bd5c2-160">Buradaki önemli nokta, etki alanı modelinize ve etki alanı mantığınıza göre birim testleri oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-160">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="bd5c2-161">Toplama kökleri, DDD 'daki ana tutarlılık sınırlardır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-161">Aggregate roots are the main consistency boundaries in DDD.</span></span>

<span data-ttu-id="bd5c2-162">EShopOnContainers 'da uygulanan depolar, değişiklik İzleyicisini kullanarak deponun ve Iş desenlerinin DbContext uygulamasını EF Core kullanır, bu nedenle bu işlevi yinelemeler.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-162">The repositories implemented in eShopOnContainers rely on EF Core’s DbContext implementation of the Repository and Unit of Work patterns using its change tracker, so they don’t duplicate this functionality.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="bd5c2-163">Depo deseninin ve eski veri erişim sınıfı (DAL sınıfı) deseninin farkı</span><span class="sxs-lookup"><span data-stu-id="bd5c2-163">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="bd5c2-164">Veri erişim nesnesi doğrudan depolamaya karşı veri erişimi ve Kalıcılık işlemleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-164">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="bd5c2-165">Bir depo, verileri iş nesnesi birimi (<xref:Microsoft.EntityFrameworkCore.DbContext> sınıfı kullanılırken EF olarak) bellekte gerçekleştirmek istediğiniz işlemlere işaret ediyor, ancak bu güncelleştirmeler veritabanına hemen yapılmaz.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-165">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately to the database.</span></span>

<span data-ttu-id="bd5c2-166">Bir iş birimi, birden çok INSERT, Update veya delete işlemi içeren tek bir işlem olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-166">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="bd5c2-167">Basit koşullarda, bir Web sitesindeki kayıt gibi belirli bir kullanıcı eyleminin, tüm ekleme, güncelleştirme ve silme işlemlerinin tek bir işlemde işlendiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-167">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete operations are handled in a single transaction.</span></span> <span data-ttu-id="bd5c2-168">Bu, birden çok veritabanı hareketini bir chattier şekilde işlemeye kıyasla daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-168">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="bd5c2-169">Bu birden çok kalıcılık işlemi daha sonra, uygulama katmanından kodunuz onu komutdaysa tek bir eylemde gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-169">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="bd5c2-170">Gerçek veritabanı depolamasına bellek içi değişiklikleri uygulama kararı genellikle [iş deseninin birimi](https://martinfowler.com/eaaCatalog/unitOfWork.html)temel alınarak hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-170">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="bd5c2-171">EF 'de Iş deseninin birimi <xref:Microsoft.EntityFrameworkCore.DbContext>olarak uygulanır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-171">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="bd5c2-172">Çoğu durumda, bu model veya depolamaya yönelik işlemler uygulamanın yolu uygulama performansını artırabilir ve tutarsızlıklar olasılığını azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-172">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="bd5c2-173">Ayrıca, tüm amaçlanan işlemler bir işlemin parçası olarak yapıldığından veritabanı tablolarında işlem engellemeyi azaltır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-173">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="bd5c2-174">Bu, veritabanında birçok yalıtılmış işlemi yürütmeye yönelik karşılaştırmada daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-174">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="bd5c2-175">Bu nedenle, seçilen ORM birçok küçük ve ayrı işlem yürütmelerinin aksine, aynı işlem içinde birkaç güncelleştirme eylemini gruplandırarak veritabanına karşı yürütmeyi en iyileştirebilir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-175">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="bd5c2-176">Depoların zorunlu olmaması gerekir</span><span class="sxs-lookup"><span data-stu-id="bd5c2-176">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="bd5c2-177">Özel depolar daha önce alıntı yapılan nedenlerle faydalıdır ve bu, eShopOnContainers 'da bir sıralama mikro hizmeti için yaklaşım olur.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-177">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="bd5c2-178">Ancak, bir DDD tasarımında veya genel .NET geliştirmede bile uygulamak için önemli bir model değildir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-178">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="bd5c2-179">Örneğin, cemy Bogard, bu kılavuz için doğrudan geri bildirim sağlarken, aşağıdakileri diyor:</span><span class="sxs-lookup"><span data-stu-id="bd5c2-179">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="bd5c2-180">Büyük olasılıkla en büyük geri bildirimim olacaktır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-180">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="bd5c2-181">Aslında depoların bir fanı değil, temel Kalıcılık mekanizmanın önemli ayrıntılarını gizlemiyor.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-181">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="bd5c2-182">Bu nedenle, komutları için de MediatR 'ye gitmem gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-182">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="bd5c2-183">Kalıcılık katmanının tam gücünü kullanabilir ve tüm etki alanı davranışlarını toplam köklerim halinde gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-183">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="bd5c2-184">Genellikle depolarımı hayata almak istemiyorum; yine de gerçek bir tümleştirme testinin olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-184">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="bd5c2-185">CQRS 'ye devam etmek, gerçekten de depolar için ihtiyaç duymadığımızdan geliyordu.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-185">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="bd5c2-186">Depolar kullanışlı olabilir, ancak toplama deseninin ve zengin etki alanı modelinin olduğu şekilde DDD tasarımınız için kritik değildir.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-186">Repositories might be useful, but they are not critical for your DDD design, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="bd5c2-187">Bu nedenle, uygun gördüğünüz gibi depo düzenini kullanın.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-187">Therefore, use the Repository pattern or not, as you see fit.</span></span> <span data-ttu-id="bd5c2-188">Yine de EF Core kullandığınızda depo deseninin kullanılması gerekir, ancak bu durumda depo tüm mikro hizmet veya sınırlanmış bağlamı kapsamaktadır.</span><span class="sxs-lookup"><span data-stu-id="bd5c2-188">Anyway, you’ll be using the repository pattern whenever you use EF Core although, in this case, the repository covers the whole microservice or bounded context.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="bd5c2-189">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="bd5c2-189">Additional resources</span></span>

### <a name="repository-pattern"></a><span data-ttu-id="bd5c2-190">Depo stili</span><span class="sxs-lookup"><span data-stu-id="bd5c2-190">Repository pattern</span></span>

- <span data-ttu-id="bd5c2-191">**Depo deseninin** </span><span class="sxs-lookup"><span data-stu-id="bd5c2-191">**The Repository pattern** </span></span>\
  <https://deviq.com/repository-pattern/>

- <span data-ttu-id="bd5c2-192">**Edward Hieatt ve Ramiz Me. Depo stili.**</span><span class="sxs-lookup"><span data-stu-id="bd5c2-192">**Edward Hieatt and Rob Mee. Repository pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/repository.html>

- <span data-ttu-id="bd5c2-193">**Depo deseninin** </span><span class="sxs-lookup"><span data-stu-id="bd5c2-193">**The Repository pattern** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)>

- <span data-ttu-id="bd5c2-194">**Eric Evans. Etki alanı odaklı tasarım: yazılım Kalbunda karmaşıklık karmaşıklığı.**</span><span class="sxs-lookup"><span data-stu-id="bd5c2-194">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="bd5c2-195">(Kitap; depo deseninin bir tartışmasını içerir) </span><span class="sxs-lookup"><span data-stu-id="bd5c2-195">(Book; includes a discussion of the Repository pattern) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="bd5c2-196">Çalışma birimi stili</span><span class="sxs-lookup"><span data-stu-id="bd5c2-196">Unit of Work pattern</span></span>

- <span data-ttu-id="bd5c2-197">**Marwler. Çalışma birimi stili.**</span><span class="sxs-lookup"><span data-stu-id="bd5c2-197">**Martin Fowler. Unit of Work pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/unitOfWork.html>

- <span data-ttu-id="bd5c2-198">**Bir ASP.NET MVC uygulamasında depo ve Iş deseni birimi uygulama** </span><span class="sxs-lookup"><span data-stu-id="bd5c2-198">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application** </span></span>\
  <https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application>

>[!div class="step-by-step"]
><span data-ttu-id="bd5c2-199">[Önceki](domain-events-design-implementation.md)
>[İleri](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="bd5c2-199">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
