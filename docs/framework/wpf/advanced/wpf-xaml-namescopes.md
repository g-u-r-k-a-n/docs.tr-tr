---
title: XAML isim skopları
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: f9d4439c6b102d0d430b5201e3649985daee0b7f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186282"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="4ef05-102">WPF XAML Ad Kapsamları</span><span class="sxs-lookup"><span data-stu-id="4ef05-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="4ef05-103">XAML adskopları, XAML'de tanımlanan nesneleri tanımlayan bir kavramdır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="4ef05-104">XAML adskopundaki adlar, nesnelerin XAML tanımlı adları ile nesne ağacındaki örnek eşdeğerleri arasında ilişki kurmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="4ef05-105">Genellikle, yönetilen koddaki [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML adskopları, bir XAML uygulaması için tek tek XAML sayfa köklerini yüklerken oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="4ef05-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="4ef05-106">Programlama nesnesi olarak XAML adskopları <xref:System.Windows.Markup.INameScope> arayüz tarafından tanımlanır ve <xref:System.Windows.NameScope>pratik sınıf tarafından da uygulanır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="4ef05-107">Yüklü XAML Uygulamalarında Namescopes</span><span class="sxs-lookup"><span data-stu-id="4ef05-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="4ef05-108">Daha geniş bir programlama veya bilgisayar bilimi bağlamında, programlama kavramları genellikle bir nesneye erişmek için kullanılabilecek benzersiz bir tanımlayıcı veya ad ilkesini içerir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="4ef05-109">Tanımlayıcılar veya adlar kullanan sistemler için ad kapsamı, bir işlemin veya tekniğin bu ada sahip bir nesnenin istenip istenmediğini veya ad tanımlamanın benzersizliğinin zorlandığı sınırları tanımlar.</span><span class="sxs-lookup"><span data-stu-id="4ef05-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="4ef05-110">Bu genel ilkeler XAML isimskopları için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="4ef05-111">WPF'de, sayfa yüklendiğinde xaml sayfasının kök öğesi üzerinde XAML adskopları oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="4ef05-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="4ef05-112">Sayfa kökünden başlayarak XAML sayfasında belirtilen her ad, ilgili bir XAML adskopuna eklenir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="4ef05-113">WPF XAML'de, ortak kök öğeleri <xref:System.Windows.Controls.Page>olan <xref:System.Windows.Window>öğeler (, ve ) her zaman bir XAML adskopu kontrol eder.</span><span class="sxs-lookup"><span data-stu-id="4ef05-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="4ef05-114">Biçimlendirmedeki <xref:System.Windows.FrameworkElement> sayfanın <xref:System.Windows.FrameworkContentElement> kök öğesi gibi veya öğe ise, [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] işlemci <xref:System.Windows.Controls.Page> çalışan bir XAML adayır <xref:System.Windows.Controls.Page> sağlayabilmek için dolaylı olarak bir kök ekler.</span><span class="sxs-lookup"><span data-stu-id="4ef05-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="4ef05-115">WPF oluşturma eylemleri, `Name` `x:Name` [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] biçimlendirmedeki herhangi bir öğede hiçbir öznitelik tanımlanmamış olsa bile, XAML üretimi için bir XAML adayır oluşturma.</span><span class="sxs-lookup"><span data-stu-id="4ef05-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="4ef05-116">Herhangi bir XAML adalanında aynı adı iki kez kullanmaya çalışırsanız, bir özel durum yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="4ef05-117">Kod arkası olan ve derlenmiş bir uygulamanın parçası olan WPF XAML için, ilk biçimlendirme derlemesi sırasında sayfa için oluşturulan sınıf oluşturulurken, özel durum WPF yapı eylemleri tarafından yapı zamanında yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="4ef05-118">Herhangi bir yapı eylemi tarafından biçimlendirme-derlenmeyen XAML için, XAML yüklendiğinde XAML adayır sorunlarıyla ilgili özel durumlar yükseltilebilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="4ef05-119">XAML tasarımcıları da tasarım zamanda XAML ad-scope sorunları tahmin edebilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="4ef05-120">Çalışma Zamanı Nesne Ağaçlarına Nesne Ekleme</span><span class="sxs-lookup"><span data-stu-id="4ef05-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="4ef05-121">XAML'nin ayrıştırıldığı an, wpf XAML adskopu oluşturulduğu ve tanımlandığı anı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="4ef05-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="4ef05-122">Bir nesneyi, o ağacı oluşturan XAML'den sonraki bir anda bir nesne `Name` eklerseniz, yeni nesnedeki bir veya `x:Name` değer XAML adskopundaki bilgileri otomatik olarak güncelleştirmez.</span><span class="sxs-lookup"><span data-stu-id="4ef05-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="4ef05-123">XAML yüklendikten sonra Bir CIÇIN ad eklemek için, genellikle XAML sayfa kökü <xref:System.Windows.Markup.INameScope.RegisterName%2A> olan XAML adskopu tanımlayan nesneüzerinde uygun uygulama çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="4ef05-124">Ad kaydedilmezse, eklenen nesne <xref:System.Windows.FrameworkElement.FindName%2A>, animasyon hedeflemesi için bu adı kullanamazsınız.</span><span class="sxs-lookup"><span data-stu-id="4ef05-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="4ef05-125">Uygulama geliştiricileri için en yaygın senaryo, sayfanın geçerli kökünde adları XAML adskopuna kaydetmek için kullanacağınız <xref:System.Windows.FrameworkElement.RegisterName%2A> senaryodur.</span><span class="sxs-lookup"><span data-stu-id="4ef05-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="4ef05-126"><xref:System.Windows.FrameworkElement.RegisterName%2A>animasyonlar için nesneleri hedefleyen film panoları için önemli bir senaryonun bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="4ef05-127">Daha fazla bilgi için [Storyboards Genel Bakış'a](../graphics-multimedia/storyboards-overview.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="4ef05-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="4ef05-128">XAML <xref:System.Windows.FrameworkElement.RegisterName%2A> adscope tanımlayan nesne dışında bir nesneyi çağırırsanız, ad, çağrı nesnesinin içinde tutulduğu XAML adskobuna, sanki <xref:System.Windows.FrameworkElement.RegisterName%2A> nesneyi tanımlayan XAML adarağını çağırmışsınız gibi kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="4ef05-129">Koddaki XAML İsimSkopları</span><span class="sxs-lookup"><span data-stu-id="4ef05-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="4ef05-130">Kodda XAML adskopları oluşturabilir ve kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4ef05-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="4ef05-131">ApI'ler ve XAML adskop oluşturma ile ilgili kavramlar saf kod kullanımı için [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bile aynıdır, çünkü XAML işlemci xaml kendisini işlerken bu API'leri ve kavramları kullanır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="4ef05-132">Kavramlar ve API, genellikle XAML'de kısmen veya tamamen tanımlanan bir nesne ağacında nesneleri ada göre bulabilmek amacıyla bulunur.</span><span class="sxs-lookup"><span data-stu-id="4ef05-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="4ef05-133">Yüklü XAML'den değil, programlı olarak oluşturulan uygulamalar için, örneklerinde bir XAML <xref:System.Windows.Markup.INameScope>adskopunun <xref:System.Windows.FrameworkContentElement> oluşturulmasını desteklemek için XAML adskopunu tanımlayan nesnenin uygulamalı veya türetilmiş bir <xref:System.Windows.FrameworkElement> sınıf olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="4ef05-134">Ayrıca, xaml işlemci tarafından yüklenmeyen ve işlenmeyen herhangi bir öğe için, nesnenin XAML adscope'u varsayılan olarak oluşturulmaz veya başharfe faturalandırılmaz.</span><span class="sxs-lookup"><span data-stu-id="4ef05-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="4ef05-135">Adları daha sonra kaydetmeyi istediğiniz herhangi bir nesne için açıkça yeni bir XAML adskopu oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="4ef05-136">XAML adskopu oluşturmak için <xref:System.Windows.NameScope.SetNameScope%2A> statik yöntemi çağırırsınız.</span><span class="sxs-lookup"><span data-stu-id="4ef05-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="4ef05-137">`dependencyObject` Parametre olarak ona sahip olacak nesneyi ve <xref:System.Windows.NameScope.%23ctor%2A> `value` parametre olarak yeni bir oluşturucu çağırın.</span><span class="sxs-lookup"><span data-stu-id="4ef05-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="4ef05-138">`dependencyObject` Amacıyla <xref:System.Windows.NameScope.SetNameScope%2A> sağlanan nesne bir uygulama <xref:System.Windows.Markup.INameScope> değilse <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>veya, <xref:System.Windows.FrameworkElement.RegisterName%2A> herhangi bir alt öğeyi çağırmak hiçbir etkiye sahip olmayacaktır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="4ef05-139">Yeni XAML adscope'u açıkça oluşturamazsanız, <xref:System.Windows.FrameworkElement.RegisterName%2A> çağrıların bir özel durum oluşturacağı.</span><span class="sxs-lookup"><span data-stu-id="4ef05-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="4ef05-140">Kodda XAML adscope API'lerini kullanma örneği [için](../graphics-multimedia/how-to-define-a-name-scope.md)bkz.</span><span class="sxs-lookup"><span data-stu-id="4ef05-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="4ef05-141">Stiller ve Şablonlarda XAML İsim Skopları</span><span class="sxs-lookup"><span data-stu-id="4ef05-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="4ef05-142">İçerikleri basit [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bir şekilde yeniden kullanma ve yeniden uygulama olanağı sağlayan stiller ve şablonlar.</span><span class="sxs-lookup"><span data-stu-id="4ef05-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="4ef05-143">Ancak, stiller ve şablonlar, şablon düzeyinde tanımlanan XAML adlarına sahip öğeler de içerebilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="4ef05-144">Aynı şablon bir sayfada birden çok kez kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="4ef05-145">Bu nedenle, stillerin ve şablonların her ikisi de stil veya şablonun uygulandığı nesne ağacındaki her konumdan bağımsız olarak kendi XAML adskoplarını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="4ef05-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="4ef05-146">Aşağıdaki örneği inceleyin:</span><span class="sxs-lookup"><span data-stu-id="4ef05-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="4ef05-147">Burada, aynı şablon iki farklı düğmeye uygulanır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="4ef05-148">Şablonlarda ayrı xaml adscope'ları yoksa, `TheBorder` şablonda kullanılan ad XAML adskopunda bir ad çakışması neden olur.</span><span class="sxs-lookup"><span data-stu-id="4ef05-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="4ef05-149">Şablonun her anlık kendi XAML adskopu vardır, bu nedenle bu örnekte her anlık şablonun XAML adskopu tam olarak bir ad içerir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="4ef05-150">Stiller ayrıca kendi XAML adskoplarını tanımlar, böylece çoğunlukla film şeridinin bazı bölümleri belirli adlara atanmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="4ef05-151">Bu adlar, şablon denetim özelleştirmesinin bir parçası olarak yeniden tanımlanmış olsa bile, bu adın öğelerini hedef alacak belirli davranışları denetlemeyi sağlar.</span><span class="sxs-lookup"><span data-stu-id="4ef05-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="4ef05-152">Ayrı XAML adskopları nedeniyle, şablonda adlandırılmış öğeleri bulmak, sayfada şablonsuz bir adlandırılmış öğe bulmaktan daha zordur.</span><span class="sxs-lookup"><span data-stu-id="4ef05-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="4ef05-153">Öncelikle, şablonun uygulandığı denetimin <xref:System.Windows.Controls.Control.Template%2A> özellik değerini alarak uygulanan şablonu belirlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="4ef05-154">Ardından, şablonun ikinci <xref:System.Windows.FrameworkTemplate.FindName%2A>parametre olarak uygulandığı denetimi geçen şablon sürümünü çağırırsınız.</span><span class="sxs-lookup"><span data-stu-id="4ef05-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="4ef05-155">Denetim yazarıysanız ve uygulamalı şablondaki belirli bir adlandırılmış öğenin denetimin kendisi tarafından tanımlanan bir davranışın hedefi olduğu <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> bir kuralı oluşturuyorsanız, yöntemi denetim uygulama kodunuzdan kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4ef05-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="4ef05-156">Yöntem <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> korunur, bu nedenle yalnızca denetim yazarı nın bu yönteme erişimi vardır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="4ef05-157">Şablon un içinden çalışıyorsanız ve şablonun uygulandığı XAML adskopuna ulaşmak istiyorsanız, değerini <xref:System.Windows.FrameworkElement.TemplatedParent%2A> <xref:System.Windows.FrameworkElement.FindName%2A> alın ve ardından buradan arayın.</span><span class="sxs-lookup"><span data-stu-id="4ef05-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="4ef05-158">Şablon içinde çalışmanın bir örneği, olayın uygulanan bir şablondaki bir öğeden yükseltilecek olay işleyicisi uygulamasını yazıyorsanız olacaktır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="4ef05-159">XAML İsim Scopes ve Ad ile ilgili API'ler</span><span class="sxs-lookup"><span data-stu-id="4ef05-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="4ef05-160"><xref:System.Windows.FrameworkElement>vardır <xref:System.Windows.FrameworkElement.FindName%2A> <xref:System.Windows.FrameworkElement.RegisterName%2A> ve <xref:System.Windows.FrameworkElement.UnregisterName%2A> yöntemleri vardır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="4ef05-161">Bu yöntemleri üzerinde dediğiniz nesne bir XAML adskopuna sahipse, yöntemler ilgili XAML adskopunun yöntemlerini çağırır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="4ef05-162">Aksi takdirde, üst öğe bir XAML adskopuna sahip olup olmadığını görmek için denetlenir ve bu işlem bir XAML adskopu bulunana kadar özyinelemeli olarak devam eder (XAML işlemci davranışı nedeniyle, kökte bir XAML adskopu olması garanti edilir).</span><span class="sxs-lookup"><span data-stu-id="4ef05-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="4ef05-163"><xref:System.Windows.FrameworkContentElement>hiçbir xaml adskopsahibi <xref:System.Windows.FrameworkContentElement> olacak istisna, benzer davranışları vardır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="4ef05-164">Aramalar sonunda <xref:System.Windows.FrameworkContentElement> bir <xref:System.Windows.FrameworkElement> üst öğeye iletilebilir böylece yöntemler var.</span><span class="sxs-lookup"><span data-stu-id="4ef05-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="4ef05-165"><xref:System.Windows.NameScope.SetNameScope%2A>varolan bir nesneyle yeni bir XAML adskopu eşlemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="4ef05-166">XAML <xref:System.Windows.NameScope.SetNameScope%2A> adkapsamını sıfırlamak veya temizlemek için birden fazla kez arayabilirsiniz, ancak bu yaygın bir kullanım değildir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="4ef05-167">Ayrıca, <xref:System.Windows.NameScope.GetNameScope%2A> genellikle koddan kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="4ef05-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="4ef05-168">XAML Namescope Uygulamaları</span><span class="sxs-lookup"><span data-stu-id="4ef05-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="4ef05-169">Aşağıdaki sınıflar <xref:System.Windows.Markup.INameScope> doğrudan uygular:</span><span class="sxs-lookup"><span data-stu-id="4ef05-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="4ef05-170"><xref:System.Windows.ResourceDictionary>XAML adları veya namescopes kullanmaz; sözlük uygulaması olduğundan, bunun yerine anahtarları kullanır.</span><span class="sxs-lookup"><span data-stu-id="4ef05-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="4ef05-171">Uygulamanın <xref:System.Windows.ResourceDictionary> tek <xref:System.Windows.Markup.INameScope> nedeni, gerçek bir XAML adscope ve nasıl bir <xref:System.Windows.ResourceDictionary> işişler anahtarları arasındaki ayrımı açıklığa kavuşturmak yardımcı kullanıcı kodu için özel durumlar yükseltmek <xref:System.Windows.ResourceDictionary> ve aynı zamanda XAML adskopları bir üst öğeler tarafından uygulanmaz sağlamak için.</span><span class="sxs-lookup"><span data-stu-id="4ef05-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="4ef05-172"><xref:System.Windows.FrameworkTemplate>ve <xref:System.Windows.Style> <xref:System.Windows.Markup.INameScope> açık arayüz tanımları ile uygulayın.</span><span class="sxs-lookup"><span data-stu-id="4ef05-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="4ef05-173">Açık uygulamalar, bu XAML adskoplarının <xref:System.Windows.Markup.INameScope> arabirim üzerinden erişildiğinde geleneksel olarak gibi çalışmasına olanak tanır, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] bu da XAML adskoplarının dahili işlemler tarafından nasıl iletildiğidir.</span><span class="sxs-lookup"><span data-stu-id="4ef05-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="4ef05-174">Ama açık arayüz tanımları geleneksel API yüzeyinin <xref:System.Windows.FrameworkTemplate> <xref:System.Windows.Style>bir parçası değildir ve , <xref:System.Windows.Markup.INameScope> nadiren <xref:System.Windows.FrameworkTemplate> ve <xref:System.Windows.Style> doğrudan yöntemleri aramak gerekir <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>çünkü, ve bunun yerine diğer API kullanır .</span><span class="sxs-lookup"><span data-stu-id="4ef05-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="4ef05-175">Aşağıdaki sınıflar, <xref:System.Windows.NameScope?displayProperty=nameWithType> yardımcı sınıfını kullanarak ve <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> ekli özellik aracılığıyla XAML adskop uygulamasına bağlanarak kendi XAML adskoplarını tanımlar:</span><span class="sxs-lookup"><span data-stu-id="4ef05-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="4ef05-176">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="4ef05-176">See also</span></span>

- [<span data-ttu-id="4ef05-177">WPF XAML için XAML Ad Alanları ve Ad Alanı Eşlemesi</span><span class="sxs-lookup"><span data-stu-id="4ef05-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="4ef05-178">x:Name Yönergesi</span><span class="sxs-lookup"><span data-stu-id="4ef05-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
