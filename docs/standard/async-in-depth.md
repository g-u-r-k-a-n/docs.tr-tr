---
title: Derinlemesine Async
description: .NET Görev tabanlı async modelini kullanarak I/O-bound ve CPU'ya bağlı asynchronous kodunu yazmanın nasıl basit olduğunu öğrenin.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 91fd37ce329c03b43b5472e4579be7f5ef961738
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "70169115"
---
# <a name="async-in-depth"></a><span data-ttu-id="b9c66-103">Derinlemesine Async</span><span class="sxs-lookup"><span data-stu-id="b9c66-103">Async in depth</span></span>

<span data-ttu-id="b9c66-104">.NET Görev tabanlı async modeli kullanılarak G/Ç ve CPU'ya bağlı asynchronous kodu yazmak kolaydır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="b9c66-105">Model, C# `Task` ve `Task<T>` Visual `async` Basic'teki `await` tipler ve anahtar kelimeler tarafından ortaya atılır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="b9c66-106">(Dile özel kaynaklar [Bak](#see-also) bölümünde bulunur.) Bu makalede, .NET async'in nasıl kullanılacağı açıklanmaktadır ve kapakların altında kullanılan async çerçevesihakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-taskt"></a><span data-ttu-id="b9c66-107">Görev ve\<Görev T></span><span class="sxs-lookup"><span data-stu-id="b9c66-107">Task and Task\<T></span></span>

<span data-ttu-id="b9c66-108">Görevler, Eşzamanlılık Vaadi Modeli olarak bilinen şeyi uygulamak için kullanılan [yapılardır.](https://en.wikipedia.org/wiki/Futures_and_promises)</span><span class="sxs-lookup"><span data-stu-id="b9c66-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="b9c66-109">Kısacası, size işlerin daha sonraki bir noktada tamamlanacağını ve temiz bir API ile sözle koordine olmanızı sağlayacak bir "söz" sunarlar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

- <span data-ttu-id="b9c66-110">`Task`bir değer döndürmeyen tek bir işlemi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="b9c66-110">`Task` represents a single operation which does not return a value.</span></span>
- <span data-ttu-id="b9c66-111">`Task<T>`türünde `T`bir değer döndüren tek bir işlemi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="b9c66-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="b9c66-112">İş parçacığı üzerinde bir soyutlama *değil,* eşzamanlı olarak gerçekleşen iş soyutlamaları olarak görevleri hakkında neden önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="b9c66-113">Varsayılan olarak, görevler geçerli iş parçacığı üzerinde yürütülür ve uygun olduğu şekilde İşletim Sistemi'ne yetkiveda çalışır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="b9c66-114">İsteğe bağlı olarak, görevlerin `Task.Run` API üzerinden ayrı bir iş parçacığı üzerinde çalışması açıkça istenebilir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="b9c66-115">Görevler, bir görevin sonuç değerini izlemek, beklemek ve erişim için `Task<T>`bir API protokolünü ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="b9c66-116">Anahtar kelimeyle `await` birlikte dil tümleştirmesi, görevleri kullanmak için daha üst düzey bir soyutlama sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span>

<span data-ttu-id="b9c66-117">Bir `await` görev, görev tamamlanına kadar arayana denetim vererek çalışırken uygulamanızın veya hizmetin yararlı işler gerçekleştirmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="b9c66-118">Görev tamamlandıktan sonra yürütmeye devam etmek için kodunuzun geri aramalara veya olaylara dayanması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="b9c66-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="b9c66-119">Dil ve görev API tümleştirmesi bunu sizin için yapar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="b9c66-120">`Task<T>`Kullanıyorsanız, `await` anahtar kelime ayrıca Görev tamamlandığında döndürülen değeri "açar".</span><span class="sxs-lookup"><span data-stu-id="b9c66-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="b9c66-121">Bu çalışmaların ayrıntıları aşağıda daha ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="b9c66-122">[Görev tabanlı Eşzamanlı Desen (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) konusunda görevler ve bunlarla etkileşim kurmanın farklı yolları hakkında daha fazla bilgi edinebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b9c66-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="b9c66-123">G/Ç'ye Bağlı İşlem için Görevlere Daha Derin Dalış</span><span class="sxs-lookup"><span data-stu-id="b9c66-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="b9c66-124">Aşağıdaki bölümde, tipik bir async G/Ç aramasıyla ne olduğu 10.000 metrelik bir görünüm açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="b9c66-125">Birkaç örnekle başlayalım.</span><span class="sxs-lookup"><span data-stu-id="b9c66-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="b9c66-126">İlk örnek bir async yöntemi çağırır ve büyük olasılıkla henüz tamamlanması için etkin bir görev döndürür.</span><span class="sxs-lookup"><span data-stu-id="b9c66-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="b9c66-127">İkinci örnek, görevde çalışmak `async` `await` için anahtar kelimelerin ve anahtar kelimelerin kullanımını ekler.</span><span class="sxs-lookup"><span data-stu-id="b9c66-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="b9c66-128">Yerel ağ `GetStringAsync()` kitaplığına Bir P/Invoke interop çağrısına ulaşana kadar alt düzey .NET kitaplıkları (belki de diğer async yöntemlerini çağıran) aracılığıyla yapılan aramalara çağrı.</span><span class="sxs-lookup"><span data-stu-id="b9c66-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="b9c66-129">Yerel kitaplık daha sonra bir Sistem API `write()` çağrısına (Linux'taki bir soket gibi) çağrıyapabilir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="b9c66-130">Görev [Tamamlama Kaynağı](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))kullanılarak yerel/yönetilen sınırda bir görev nesnesi oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b9c66-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="b9c66-131">Görev nesnesi katmanlar aracılığıyla geçirilir, muhtemelen çalıştırılır veya doğrudan döndürülür, sonunda ilk arayana döndürülür.</span><span class="sxs-lookup"><span data-stu-id="b9c66-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span>

<span data-ttu-id="b9c66-132">Yukarıdaki ikinci örnekte, `Task<T>` bir nesne `GetStringAsync`.'den döndürülür.</span><span class="sxs-lookup"><span data-stu-id="b9c66-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="b9c66-133">`await` Anahtar kelimenin kullanımı yöntemin yeni oluşturulan görev nesnesini döndürmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="b9c66-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="b9c66-134">Denetim `GetFirstCharactersCountAsync` yöntemde bu konumdan arayana döner.</span><span class="sxs-lookup"><span data-stu-id="b9c66-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="b9c66-135">[Görev&lt;T&gt; ](xref:System.Threading.Tasks.Task%601) nesnesinin yöntemleri ve özellikleri, arayanların GetFirstCharactersCountAsync'de kalan kod yürütüldüğünde tamamlanacak olan görevin ilerlemesini izlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="b9c66-136">Sistem API çağrısından sonra, istek artık çekirdek alanında dır ve işletim sisteminin ağ alt sistemine `/net` (Linux Çekirdeği'nde olduğu gibi) doğru yola çıkar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="b9c66-137">Burada işletim sistemi ağ isteğini *eşit bir şekilde*işleyecek.</span><span class="sxs-lookup"><span data-stu-id="b9c66-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="b9c66-138">Ayrıntılar kullanılan işletim sistemi bağlı olarak farklı olabilir (aygıt sürücüsü arama sı çalıştırılmak için geri gönderilen bir sinyal olarak zamanlanabilir veya bir aygıt sürücüsü araması yapılabilir ve *daha sonra* bir sinyal geri gönderilebilir), ancak sonunda çalışma süresi ağ isteği devam ettiği bildirilir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="b9c66-139">Şu anda, aygıt sürücüsü için çalışma ya zamanlanmış olacak, devam ediyor, ya da zaten bitmiş (istek zaten "tel üzerinde" dışarı) - ama bu tüm eşzamanlı oluyor çünkü, cihaz sürücüsü hemen başka bir şey işlemek mümkün!</span><span class="sxs-lookup"><span data-stu-id="b9c66-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="b9c66-140">Örneğin, Windows'da bir işletim sistemi iş parçacığı ağ aygıtı sürücüsüne bir çağrı yapar ve işlemi temsil eden bir Kesme İstek Paketi (IRP) aracılığıyla ağ işlemini gerçekleştirmesini ister.</span><span class="sxs-lookup"><span data-stu-id="b9c66-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="b9c66-141">Aygıt sürücüsü IRP alır, ağa arama yapar, IRP'yi "beklemede" olarak işaretler ve işletim sistemi'ne geri döner.</span><span class="sxs-lookup"><span data-stu-id="b9c66-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="b9c66-142">İşletim sistemi iş parçacığı artık IRP'nin "beklemede" olduğunu bildiğinden, bu iş için yapacak daha fazla işi yoktur ve diğer işleri gerçekleştirmek için kullanılabilmesi için "geri döner".</span><span class="sxs-lookup"><span data-stu-id="b9c66-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="b9c66-143">İstek yerine getirildiğinde ve veriler aygıt sürücüsünden geri geldiğinde, bir kesinti yle alınan yeni verilerin CPU'ya haber verirken.</span><span class="sxs-lookup"><span data-stu-id="b9c66-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="b9c66-144">Bu kesintinin nasıl işleneceğini os bağlı olarak değişir, ancak sonunda veri bir sistem interop çağrı ulaşana kadar işletim sistemi üzerinden geçirilecektir (örneğin, Linux'ta bir kesme işleyicisi işletim sistemi üzerinden veri geçmek için IRQ alt yarısını zamanlar asynchronously).</span><span class="sxs-lookup"><span data-stu-id="b9c66-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="b9c66-145">Bu *da* eşzamanlı olur unutmayın!</span><span class="sxs-lookup"><span data-stu-id="b9c66-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="b9c66-146">Bir sonraki kullanılabilir iş parçacığı async yöntemini yürütmek ve tamamlanan görevin sonucunu "açmak" mümkün olana kadar sonuç sıraya alınır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-146">The result is queued up until the next available thread is able to execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="b9c66-147">Tüm bu işlem boyunca, önemli bir paket **hiçbir iş parçacığı görevi çalıştırmak için adamıştır.**</span><span class="sxs-lookup"><span data-stu-id="b9c66-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="b9c66-148">Çalışma bazı bağlamlarda yürütülse de (diğer bir deyişle, işletim sistemi verileri aygıt sürücüsüne aktarmak ve kesintiye yanıt vermek zorunda), istekten gelen verilerin geri gelmesini *beklemeye* adanmış bir iş parçacığı yoktur.</span><span class="sxs-lookup"><span data-stu-id="b9c66-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="b9c66-149">Bu, sistemin bazı G/Ç aramalarının tamamlanmasını beklemek yerine çok daha büyük bir iş hacmini işlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="b9c66-150">Yukarıdaki yapılacak bir çok iş gibi görünse de, duvar saati süresi açısından ölçüldüğünde, gerçek G / O iş yapmak için gereken süre ile karşılaştırıldığında küçük.</span><span class="sxs-lookup"><span data-stu-id="b9c66-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="b9c66-151">Tüm kesin olmasa da, böyle bir arama için potansiyel bir zaman çizelgesi şu şekilde görünür:</span><span class="sxs-lookup"><span data-stu-id="b9c66-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="b9c66-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="b9c66-152">0-1————————————————————————————————————————————————–2-3</span></span>

- <span data-ttu-id="b9c66-153">Puanlardan `0` async `1` yöntemi arayana denetim verene kadar harcanan zaman her şeydir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
- <span data-ttu-id="b9c66-154">Puanlardan `1` G/Ç'ye `2` harcanan süre, CPU maliyeti olmadan I/Ç'de harcanan süredir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
- <span data-ttu-id="b9c66-155">Son olarak, `2` puanlardan `3` harcanan zaman denetimi async yöntemine geri (ve potansiyel olarak bir değer) geçiriyor ve bu noktada yeniden yürütülmeye başlıyor.</span><span class="sxs-lookup"><span data-stu-id="b9c66-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="b9c66-156">Bu, sunucu senaryosu için ne anlama gelir?</span><span class="sxs-lookup"><span data-stu-id="b9c66-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="b9c66-157">Bu model, tipik bir sunucu senaryosu iş yükü ile iyi çalışır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="b9c66-158">Tamamlanmamış görevlerde engellemeye adanmış iş parçacıkları olmadığından, sunucu iş parçacığı havuzu çok daha yüksek hacimli web isteklerine hizmet verebilir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="b9c66-159">İki sunucu düşünün: biri async kodu çalıştıran, diğeri çalıştırmayan.</span><span class="sxs-lookup"><span data-stu-id="b9c66-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="b9c66-160">Bu örnek için, her sunucunun hizmet istekleri için yalnızca 5 iş parçacığı vardır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="b9c66-161">Bu sayıların hayali olarak küçük olduğunu ve yalnızca gösterici bir bağlamda hizmet verdiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b9c66-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="b9c66-162">Her iki sunucunun da 6 eşzamanlı istek aldığını varsayalım.</span><span class="sxs-lookup"><span data-stu-id="b9c66-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="b9c66-163">Her istek bir G/Ç işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="b9c66-164">Async kodu *olmayan* sunucu, 5 iş parçacığından biri G/Ç'ye bağlı çalışmayı bitirip yanıt yazana kadar 6.</span><span class="sxs-lookup"><span data-stu-id="b9c66-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="b9c66-165">20. istek geldiği noktada, sıra çok uzun sürdüğü için sunucu yavaşlamaya başlayabilir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="b9c66-166">Üzerinde async kodu *çalışan* sunucu hala 6 istek sıraya, ancak `async` kullandığı `await`için ve , her iş parçacığı, I / O-bound çalışma başladığında, yerine ne zaman bitirir serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="b9c66-167">20. istek gelene kadar, gelen istekler için kuyruk çok daha küçük olacaktır (içinde herhangi bir şey varsa) ve sunucu yavaşlamaz.</span><span class="sxs-lookup"><span data-stu-id="b9c66-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="b9c66-168">Bu contrived bir örnek olmasına rağmen, gerçek dünyada çok benzer bir şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="b9c66-169">Aslında, bir sunucunun aldığı her istek için bir iş `async` parçacığı `await` ayırıyorsa, daha fazla istek kullanarak ve daha büyük bir istek siparişi işlemek mümkün olmasını bekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b9c66-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="b9c66-170">Bu istemci senaryosu için ne anlama geliyor?</span><span class="sxs-lookup"><span data-stu-id="b9c66-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="b9c66-171">Bir istemci uygulamasını `async` `await` kullanmak ve kullanmak için en büyük kazanç yanıt verme deki artıştır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="b9c66-172">Bir uygulamayı iş parçacıklarını el ile yumurtlayarak yanıt vermeye zorlasanız da, bir `async` `await`iş parçacığı nın yumurtlama eylemi, sadece kullanmaya ve .</span><span class="sxs-lookup"><span data-stu-id="b9c66-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="b9c66-173">Özellikle mobil bir oyun gibi bir şey için, I / O söz konusu olduğunda mümkün olduğunca az UI iplik etkileyen çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="b9c66-174">Daha da önemlisi, I / O bağlı çalışma CPU üzerinde hemen hemen hiç zaman harcamak, ancak herhangi bir yararlı iş gerçekleştirmek için tüm bir CPU iş parçacığı adamak kaynakların kötü kullanımı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="b9c66-175">Ayrıca, kullanıcı arabirimi iş parçacığına iş gönderme (kullanıcı arabirimi güncelleştirme `async` gibi) yöntemlerle çok basittir ve ek çalışma gerektirmez (iş parçacığı için güvenli bir temsilci çağırmak gibi).</span><span class="sxs-lookup"><span data-stu-id="b9c66-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="b9c66-176">CPU'ya Bağlı Bir\<İşlem için Görev ve Görev T> Daha Derin dalış</span><span class="sxs-lookup"><span data-stu-id="b9c66-176">Deeper Dive into Task and Task\<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="b9c66-177">CPU'ya `async` bağlı kod, G/Ç'ye `async` bağlı koddan biraz farklıdır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="b9c66-178">İşlem üzerinde iş yapıldığından, bir iş parçacığının hesaplamaya ithaf edilmesinin bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="b9c66-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="b9c66-179">Kullanımı `async` ve `await` bir arka plan iş parçacığı ile etkileşim ve async yönteminin arayan duyarlı tutmak için temiz bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="b9c66-180">Bunun paylaşılan veriler için herhangi bir koruma sağlamadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b9c66-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="b9c66-181">Paylaşılan verileri kullanıyorsanız, yine de uygun bir eşitleme stratejisi uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="b9c66-182">Burada bir CPU bağlı async arama 10.000 ayak görünümü:</span><span class="sxs-lookup"><span data-stu-id="b9c66-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

<span data-ttu-id="b9c66-183">`CalculateResult()`çağrıldığı iş parçacığı üzerinde yürütür.</span><span class="sxs-lookup"><span data-stu-id="b9c66-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="b9c66-184">`Task.Run`Aradığında, iş parçacığı havuzunda pahalı CPU'ya bağlı işlemi `DoExpensiveCalculation()`sıralar ve bir `Task<int>` tutamaç alır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="b9c66-185">`DoExpensiveCalculation()`sonunda aynı anda bir sonraki kullanılabilir iş parçacığı, büyük olasılıkla başka bir CPU çekirdek üzerinde çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="b9c66-186">Başka bir iş parçacığı üzerinde `DoExpensiveCalculation()` meşgul ken eşzamanlı iş yapmak mümkündür, çünkü adlandırılan `CalculateResult()` iş parçacığı hala yürütülmeye devam ediyor.</span><span class="sxs-lookup"><span data-stu-id="b9c66-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="b9c66-187">Bir `await` kez karşılaşılan, `CalculateResult()` yürütme arayan teslim edilir, başka bir iş bir sonuç `DoExpensiveCalculation()` çalkalama ise geçerli iş parçacığı ile yapılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="b9c66-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="b9c66-188">Tamamlandıktan sonra, sonuç ana iş parçacığı üzerinde çalıştırmak için sıraya alınır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="b9c66-189">Sonunda, ana iş parçacığı yürütme `CalculateResult()`dönecektir , hangi noktada sonucu `DoExpensiveCalculation()`olacaktır .</span><span class="sxs-lookup"><span data-stu-id="b9c66-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="b9c66-190">Async neden burada yardımcı olur?</span><span class="sxs-lookup"><span data-stu-id="b9c66-190">Why does async help here?</span></span>

<span data-ttu-id="b9c66-191">`async`ve `await` yanıt verme gereksinimi olduğunda CPU'ya bağlı çalışmayı yönetmek için en iyi yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-191">`async` and `await` are the best practice for managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="b9c66-192">CPU'ya bağlı çalışma ile async kullanmak için birden çok desen vardır.</span><span class="sxs-lookup"><span data-stu-id="b9c66-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="b9c66-193">Bu async kullanarak küçük bir maliyet olduğunu ve sıkı döngüler için tavsiye edilmez dikkat etmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b9c66-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="b9c66-194">Bu yeni özellik etrafında kodunuzu nasıl yazdığınızı belirlemek size kalmış.</span><span class="sxs-lookup"><span data-stu-id="b9c66-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="b9c66-195">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="b9c66-195">See also</span></span>

- [<span data-ttu-id="b9c66-196">C'de asynchronous programlama #</span><span class="sxs-lookup"><span data-stu-id="b9c66-196">Asynchronous programming in C#</span></span>](../csharp/async.md)
- [<span data-ttu-id="b9c66-197">Async ve await ile asynchronous programlama (C#)</span><span class="sxs-lookup"><span data-stu-id="b9c66-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="b9c66-198">F'de Async Programlama #</span><span class="sxs-lookup"><span data-stu-id="b9c66-198">Async Programming in F#</span></span>](../fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="b9c66-199">Async ve Await ile Asynchronous Programlama (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="b9c66-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](../visual-basic/programming-guide/concepts/async/index.md)
