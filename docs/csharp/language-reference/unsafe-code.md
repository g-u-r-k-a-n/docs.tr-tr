---
title: Güvenli olmayan kod, veri işaretçileri ve işlev işaretçileri
description: Güvenli olmayan kod, işaretçiler ve işlev işaretçileri hakkında bilgi edinin. C#, bellek veya işlev işaretçilerini doğrudan işlemek üzere bu özellikleri kullanmak için güvenli olmayan bir bağlam bildirmeniz gerekir.
ms.date: 04/01/2021
helpviewer_keywords:
- security [C#], type safety
- C# language, unsafe code
- type safety [C#]
- unsafe keyword [C#]
- unsafe code [C#]
- C# language, pointers
- pointers [C#], about pointers
ms.assetid: b0fcca10-a92d-4f2a-835b-b0ccae6739ee
ms.openlocfilehash: 9c55fc48b5805ba38dcf289cb5e03626cf3e96ec
ms.sourcegitcommit: 089068389671f6f9e15fd67dcbfb0145bf72f1fb
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/06/2021
ms.locfileid: "106499130"
---
# <a name="unsafe-code-and-pointer-types"></a><span data-ttu-id="1c1ba-104">Güvenli olmayan kod ve işaretçi türleri</span><span class="sxs-lookup"><span data-stu-id="1c1ba-104">Unsafe code and pointer types</span></span>

<span data-ttu-id="1c1ba-105">Yazdığınız C# kodunun çoğu "verifili güvenli kod" dir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-105">Most of the C# code you write is "verifiably safe code."</span></span> <span data-ttu-id="1c1ba-106">*Doğruıda güvenli kod* .NET araçları 'nın kodun güvenli olduğunu doğrulayabileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-106">*Verifiably safe code* means .NET tools can verify that the code is safe.</span></span> <span data-ttu-id="1c1ba-107">Genel olarak, güvenli kod işaretçiler kullanılarak belleğe doğrudan erişemez.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-107">In general, safe code doesn't directly access memory using pointers.</span></span> <span data-ttu-id="1c1ba-108">Ayrıca ham bellek ayırmaz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-108">It also doesn't allocate raw memory.</span></span> <span data-ttu-id="1c1ba-109">Bunun yerine yönetilen nesneler oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-109">It creates managed objects instead.</span></span>

<span data-ttu-id="1c1ba-110">C# [`unsafe`](keywords/unsafe.md) , içinde *doğrulanamayan* kod yazabileceğiniz bir bağlamı destekler.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-110">C# supports an [`unsafe`](keywords/unsafe.md) context, in which you may write *unverifiable* code.</span></span> <span data-ttu-id="1c1ba-111">Bir `unsafe` bağlamda, kod işaretçiler kullanabilir, bellek ayırır ve serbest bellek blokları kullanabilir ve işlev işaretçileri kullanarak yöntemleri çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-111">In an `unsafe` context, code may use pointers, allocate and free blocks of memory, and call methods using function pointers.</span></span> <span data-ttu-id="1c1ba-112">C# ' deki güvenli olmayan kod, tehlikeli değildir; yalnızca güvenliği doğrulanamayan bir koddur.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-112">Unsafe code in C# isn't necessarily dangerous; it's just code whose safety cannot be verified.</span></span>

<span data-ttu-id="1c1ba-113">Güvenli olmayan kod aşağıdaki özelliklere sahiptir:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-113">Unsafe code has the following properties:</span></span>

- <span data-ttu-id="1c1ba-114">Yöntemler, türler ve kod blokları güvenli olmayan şekilde tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-114">Methods, types, and code blocks can be defined as unsafe.</span></span>
- <span data-ttu-id="1c1ba-115">Bazı durumlarda, güvenli olmayan kod, dizi sınırları denetimlerini kaldırarak bir uygulamanın performansını artırabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-115">In some cases, unsafe code may increase an application's performance by removing array bounds checks.</span></span>
- <span data-ttu-id="1c1ba-116">İşaretçi gerektiren yerel işlevleri çağırdığınızda güvenli olmayan kod gereklidir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-116">Unsafe code is required when you call native functions that require pointers.</span></span>
- <span data-ttu-id="1c1ba-117">Güvenli olmayan kod kullanmak güvenlik ve kararlılık riskleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-117">Using unsafe code introduces security and stability risks.</span></span>
- <span data-ttu-id="1c1ba-118">Güvenli olmayan bloklar içeren kodun [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) derleyici seçeneğiyle derlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-118">The code that contains unsafe blocks must be compiled with the [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) compiler option.</span></span>

## <a name="pointer-types"></a><span data-ttu-id="1c1ba-119">İşaretçi türleri</span><span class="sxs-lookup"><span data-stu-id="1c1ba-119">Pointer types</span></span>

<span data-ttu-id="1c1ba-120">Güvenli olmayan bir bağlamda, bir tür, bir değer türüne ek olarak bir işaretçi türü veya bir başvuru türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-120">In an unsafe context, a type may be a pointer type, in addition to a value type, or a reference type.</span></span> <span data-ttu-id="1c1ba-121">Bir işaretçi türü bildirimi, aşağıdaki biçimlerden birini alır:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-121">A pointer type declaration takes one of the following forms:</span></span>

``` csharp
type* identifier;
void* identifier; //allowed but not recommended
```

<span data-ttu-id="1c1ba-122">`*`Bir işaretçi türündeki öğesinden önce belirtilen tür, **başvurulan tür** olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-122">The type specified before the `*` in a pointer type is called the **referent type**.</span></span> <span data-ttu-id="1c1ba-123">Yalnızca [yönetilmeyen bir tür](builtin-types/unmanaged-types.md) , başvurulan bir tür olabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-123">Only an [unmanaged type](builtin-types/unmanaged-types.md) can be a referent type.</span></span>

<span data-ttu-id="1c1ba-124">İşaretçi türleri [nesneden](builtin-types/reference-types.md) aktarılmaz ve işaretçi türleri ve arasında dönüştürme yok `object` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-124">Pointer types don't inherit from [object](builtin-types/reference-types.md) and no conversions exist between pointer types and `object`.</span></span> <span data-ttu-id="1c1ba-125">Ayrıca, kutulama ve kutudan çıkarma işaretçileri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-125">Also, boxing and unboxing don't support pointers.</span></span> <span data-ttu-id="1c1ba-126">Ancak, farklı işaretçi türleri ve işaretçi türleri ve tamsayı türleri arasında dönüştürme yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-126">However, you can convert between different pointer types and between pointer types and integral types.</span></span>

<span data-ttu-id="1c1ba-127">Aynı bildirimde birden çok işaretçi bildirdiğinizde, yıldız işaretini ( `*` ) yalnızca temel alınan türle birlikte yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-127">When you declare multiple pointers in the same declaration, you write the asterisk (`*`) together with the underlying type only.</span></span> <span data-ttu-id="1c1ba-128">Her işaretçi adının öneki olarak kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-128">It isn't used as a prefix to each pointer name.</span></span> <span data-ttu-id="1c1ba-129">Örnek:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-129">For example:</span></span>

```csharp
int* p1, p2, p3;   // Ok
int *p1, *p2, *p3;   // Invalid in C#
```

<span data-ttu-id="1c1ba-130">Bir işaretçi, bir işaretçiye işaret eden bir nesne başvurusu atık olarak toplanabileceğinden, bir başvuruya veya başvuru içeren bir [yapıya](builtin-types/struct.md) işaret edebilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-130">A pointer can't point to a reference or to a [struct](builtin-types/struct.md) that contains references, because an object reference can be garbage collected even if a pointer is pointing to it.</span></span> <span data-ttu-id="1c1ba-131">Çöp toplayıcı, bir nesnenin herhangi bir işaretçi türü tarafından işaret edilip edilmeyeceğini izlememez.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-131">The garbage collector doesn't keep track of whether an object is being pointed to by any pointer types.</span></span>

<span data-ttu-id="1c1ba-132">Türündeki işaretçi değişkeninin değeri, `MyType*` türünde bir değişkenin adresidir `MyType` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-132">The value of the pointer variable of type `MyType*` is the address of a variable of type `MyType`.</span></span> <span data-ttu-id="1c1ba-133">Aşağıda, işaretçi türü bildirimi örnekleri verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-133">The following are examples of pointer type declarations:</span></span>

- <span data-ttu-id="1c1ba-134">`int* p`: `p` tamsayı olan bir işaretçidir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-134">`int* p`: `p` is a pointer to an integer.</span></span>
- <span data-ttu-id="1c1ba-135">`int** p`: bir `p` tamsayı işaretçisinin işaretçisi.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-135">`int** p`: `p` is a pointer to a pointer to an integer.</span></span>
- <span data-ttu-id="1c1ba-136">`int*[] p`: `p` tamsayılara yönelik işaretçilerin tek boyutlu bir dizisidir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-136">`int*[] p`: `p` is a single-dimensional array of pointers to integers.</span></span>
- <span data-ttu-id="1c1ba-137">`char* p`: bir `p` char işaretçisi.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-137">`char* p`: `p` is a pointer to a char.</span></span>
- <span data-ttu-id="1c1ba-138">`void* p`: `p` bilinmeyen bir tür işaretçisi.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-138">`void* p`: `p` is a pointer to an unknown type.</span></span>

<span data-ttu-id="1c1ba-139">İşaretçi yöneltme işleci, `*` işaretçi değişkeni tarafından işaret edilen konumdaki içeriğe erişmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-139">The pointer indirection operator `*` can be used to access the contents at the location pointed to by the pointer variable.</span></span> <span data-ttu-id="1c1ba-140">Örneğin, aşağıdaki bildirimi ele alalım:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-140">For example, consider the following declaration:</span></span>

```csharp
int* myVariable;
```

<span data-ttu-id="1c1ba-141">İfade, `*myVariable` içinde bulunan `int` adreste bulunan değişkeni gösterir `myVariable` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-141">The expression `*myVariable` denotes the `int` variable found at the address contained in `myVariable`.</span></span>

<span data-ttu-id="1c1ba-142">[ `fixed` Deyimdeki](keywords/fixed-statement.md)makalelerde birçok işaretçiyle ilgili birkaç örnek vardır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-142">There are several examples of pointers in the articles on the [`fixed` statement](keywords/fixed-statement.md).</span></span> <span data-ttu-id="1c1ba-143">Aşağıdaki örnek, `unsafe` anahtar sözcüğünü ve ifadesini kullanır `fixed` ve iç işaretçinin nasıl artırılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-143">The following example uses the `unsafe` keyword and the `fixed` statement, and shows how to increment an interior pointer.</span></span>  <span data-ttu-id="1c1ba-144">Bu kodu çalıştırmak için bir konsolun Ana işlevine yapıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-144">You can paste this code into the Main function of a console application to run it.</span></span> <span data-ttu-id="1c1ba-145">Bu örneklerin [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) derleyici seçenek kümesiyle derlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-145">These examples must be compiled with the [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) compiler option set.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="5":::

<span data-ttu-id="1c1ba-146">Yöneltme işlecini türündeki bir işaretçiye uygulayamazsınız `void*` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-146">You can't apply the indirection operator to a pointer of type `void*`.</span></span> <span data-ttu-id="1c1ba-147">Ancak, boş bir işaretçiyi başka herhangi bir türü dönüştürmek veya bunun tersini yapmak için bir yayın kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-147">However, you can use a cast to convert a void pointer to any other pointer type, and vice versa.</span></span>

<span data-ttu-id="1c1ba-148">Bir işaretçi olabilir `null` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-148">A pointer can be `null`.</span></span> <span data-ttu-id="1c1ba-149">Yönlendirme işlecini bir null işaretçiye uygulamak, uygulama tarafından tanımlanan bir davranışa neden olur.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-149">Applying the indirection operator to a null pointer causes an implementation-defined behavior.</span></span>

<span data-ttu-id="1c1ba-150">Yöntemler arasında işaretçiler geçirmek tanımsız davranışlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-150">Passing pointers between methods can cause undefined behavior.</span></span> <span data-ttu-id="1c1ba-151">Bir `in` , `out` veya `ref` parametresi ya da işlev sonucu olarak yerel bir değişkene bir işaretçi döndüren bir yöntem düşünün.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-151">Consider a method that returns a pointer to a local variable through an `in`, `out`, or `ref` parameter or as the function result.</span></span> <span data-ttu-id="1c1ba-152">İşaretçi sabit bir blokta ayarlandıysa, işaret ettiği değişken artık sabit olamaz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-152">If the pointer was set in a fixed block, the variable to which it points may no longer be fixed.</span></span>

<span data-ttu-id="1c1ba-153">Aşağıdaki tabloda, güvenli olmayan bir bağlamda işaretçiler üzerinde işlem yapabilecek işleçler ve deyimler listelenmektedir:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-153">The following table lists the operators and statements that can operate on pointers in an unsafe context:</span></span>

|<span data-ttu-id="1c1ba-154">İşleç/Deyim</span><span class="sxs-lookup"><span data-stu-id="1c1ba-154">Operator/Statement</span></span>|<span data-ttu-id="1c1ba-155">Kullanın</span><span class="sxs-lookup"><span data-stu-id="1c1ba-155">Use</span></span>|
|-------------------------|---------|
|`*`|<span data-ttu-id="1c1ba-156">İşaretçi yöneltmesi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-156">Performs pointer indirection.</span></span>|
|`->`|<span data-ttu-id="1c1ba-157">Bir yapının bir üyesine bir işaretçi yoluyla erişir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-157">Accesses a member of a struct through a pointer.</span></span>|
|`[]`|<span data-ttu-id="1c1ba-158">Bir işaretçiyi dizine ekler.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-158">Indexes a pointer.</span></span>|
|`&`|<span data-ttu-id="1c1ba-159">Bir değişkenin adresini alır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-159">Obtains the address of a variable.</span></span>|
|<span data-ttu-id="1c1ba-160">`++` ve `--`</span><span class="sxs-lookup"><span data-stu-id="1c1ba-160">`++` and `--`</span></span>|<span data-ttu-id="1c1ba-161">İşaretçileri artırır ve azaltır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-161">Increments and decrements pointers.</span></span>|
|<span data-ttu-id="1c1ba-162">`+` ve `-`</span><span class="sxs-lookup"><span data-stu-id="1c1ba-162">`+` and `-`</span></span>|<span data-ttu-id="1c1ba-163">İşaretçi aritmetiği gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-163">Performs pointer arithmetic.</span></span>|
|<span data-ttu-id="1c1ba-164">`==`, `!=` , `<` , `>` , `<=` ve `>=`</span><span class="sxs-lookup"><span data-stu-id="1c1ba-164">`==`, `!=`, `<`, `>`, `<=`, and `>=`</span></span>|<span data-ttu-id="1c1ba-165">İşaretçileri karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-165">Compares pointers.</span></span>|
|[`stackalloc`](operators/stackalloc.md)|<span data-ttu-id="1c1ba-166">Yığında bellek ayırır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-166">Allocates memory on the stack.</span></span>|
|[<span data-ttu-id="1c1ba-167">`fixed` Ekstre</span><span class="sxs-lookup"><span data-stu-id="1c1ba-167">`fixed` statement</span></span>](keywords/fixed-statement.md)|<span data-ttu-id="1c1ba-168">Adresinin bulunamaması için bir değişkeni geçici olarak sabitler.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-168">Temporarily fixes a variable so that its address may be found.</span></span>|

<span data-ttu-id="1c1ba-169">İşaretçiyle ilgili işleçler hakkında daha fazla bilgi için bkz. [işaretçi ile ilgili işleçler](operators/pointer-related-operators.md).</span><span class="sxs-lookup"><span data-stu-id="1c1ba-169">For more information about pointer-related operators, see [Pointer-related operators](operators/pointer-related-operators.md).</span></span>

<span data-ttu-id="1c1ba-170">Herhangi bir işaretçi türü örtük olarak bir türe dönüştürülebilir `void*` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-170">Any pointer type can be implicitly converted to a `void*` type.</span></span> <span data-ttu-id="1c1ba-171">Herhangi bir işaretçi türüne değer atanabilir `null` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-171">Any pointer type can be assigned the value `null`.</span></span> <span data-ttu-id="1c1ba-172">Herhangi bir işaretçi türü, açıkça atama ifadesi kullanan başka bir işaretçi türüne dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-172">Any pointer type can be explicitly converted to any other pointer type using a cast expression.</span></span> <span data-ttu-id="1c1ba-173">Ayrıca, herhangi bir integral türünü bir işaretçi türüne veya herhangi bir işaretçi türüne bir integral türüne dönüştürebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-173">You can also convert any integral type to a pointer type, or any pointer type to an integral type.</span></span> <span data-ttu-id="1c1ba-174">Bu dönüşümler açık bir tür dönüştürme gerektirir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-174">These conversions require an explicit cast.</span></span>

<span data-ttu-id="1c1ba-175">Aşağıdaki örnek bir öğesine dönüştürür `int*` `byte*` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-175">The following example converts an `int*` to a `byte*`.</span></span> <span data-ttu-id="1c1ba-176">İşaretçinin, değişkenin en düşük adresli baytını işaret ettiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-176">Notice that the pointer points to the lowest addressed byte of the variable.</span></span> <span data-ttu-id="1c1ba-177">Sonucu büyük ölçüde arttırdığınızda `int` (4 bayt), değişkenin kalan baytlarını görüntüleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-177">When you successively increment the result, up to the size of `int` (4 bytes), you can display the remaining bytes of the variable.</span></span>

:::code language="csharp" source="snippets/unsafe-code/Conversions.cs" ID="Conversion":::

## <a name="fixed-size-buffers"></a><span data-ttu-id="1c1ba-178">Sabit boyutlu arabellekler</span><span class="sxs-lookup"><span data-stu-id="1c1ba-178">Fixed-size buffers</span></span>

<span data-ttu-id="1c1ba-179">C# ' de, bir veri yapısında sabit boyutlu bir diziye sahip bir arabellek oluşturmak için [fixed](keywords/fixed-statement.md) ifadesini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-179">In C#, you can use the [fixed](keywords/fixed-statement.md) statement to create a buffer with a fixed size array in a data structure.</span></span> <span data-ttu-id="1c1ba-180">Sabit boyutlu arabellekler, diğer dillerdeki veya platformlardaki veri kaynaklarıyla birlikte çalışan Yöntemler yazdığınızda faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-180">Fixed size buffers are useful when you write methods that interoperate with data sources from other languages or platforms.</span></span> <span data-ttu-id="1c1ba-181">Sabit dizi, normal yapı üyeleri için izin verilen herhangi bir özniteliği veya değiştiricilerini alabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-181">The fixed array can take any attributes or modifiers that are allowed for regular struct members.</span></span> <span data-ttu-id="1c1ba-182">Tek kısıtlama, dizi türünün,,,,,,,, `bool` `byte` `char` `short` `int` `long` `sbyte` `ushort` `uint` , `ulong` ,, `float` veya `double` olması olabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-182">The only restriction is that the array type must be `bool`, `byte`, `char`, `short`, `int`, `long`, `sbyte`, `ushort`, `uint`, `ulong`, `float`, or `double`.</span></span>

```csharp
private fixed char name[30];
```

<span data-ttu-id="1c1ba-183">Güvenli kodda, dizi içeren bir C# yapısı dizi öğelerini içermez.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-183">In safe code, a C# struct that contains an array doesn't contain the array elements.</span></span> <span data-ttu-id="1c1ba-184">Struct, bunun yerine öğelerine bir başvuru içerir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-184">The struct contains a reference to the elements instead.</span></span> <span data-ttu-id="1c1ba-185">Bir yapıda sabit boyutlu bir diziyi, [güvenli olmayan](keywords/unsafe.md) bir kod bloğunda kullanıldığında bir [yapıya](builtin-types/struct.md) katıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-185">You can embed an array of fixed size in a [struct](builtin-types/struct.md) when it's used in an [unsafe](keywords/unsafe.md) code block.</span></span>

<span data-ttu-id="1c1ba-186">Aşağıdaki boyut, `struct` bir başvuru olduğundan dizideki öğelerin sayısına bağlı değildir `pathName` :</span><span class="sxs-lookup"><span data-stu-id="1c1ba-186">The size of the following `struct` doesn't depend on the number of elements in the array, since `pathName` is a reference:</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="6":::

<span data-ttu-id="1c1ba-187">`struct`, Güvenli olmayan kodda gömülü bir dizi içerebilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-187">A `struct` can contain an embedded array in unsafe code.</span></span> <span data-ttu-id="1c1ba-188">Aşağıdaki örnekte, `fixedBuffer` dizisinin sabit bir boyutu vardır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-188">In the following example, the `fixedBuffer` array has a fixed size.</span></span> <span data-ttu-id="1c1ba-189">`fixed`İlk öğe için bir işaretçi oluşturmak üzere bir ifade kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-189">You use a `fixed` statement to establish a pointer to the first element.</span></span> <span data-ttu-id="1c1ba-190">Bu işaretçi aracılığıyla dizinin öğelerine erişirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-190">You access the elements of the array through this pointer.</span></span> <span data-ttu-id="1c1ba-191">`fixed`İfade, `fixedBuffer` örnek alanını bellekte belirli bir konuma sabitsabitler.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-191">The `fixed` statement pins the `fixedBuffer` instance field to a specific location in memory.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="7":::

<span data-ttu-id="1c1ba-192">128 öğe `char` dizisinin boyutu 256 bayttır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-192">The size of the 128 element `char` array is 256 bytes.</span></span> <span data-ttu-id="1c1ba-193">Sabit boyutlu [char](builtin-types/char.md) arabellekleri, kodlamadan bağımsız olarak her zaman karakter başına 2 bayt sürer.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-193">Fixed size [char](builtin-types/char.md) buffers always take 2 bytes per character, regardless of the encoding.</span></span> <span data-ttu-id="1c1ba-194">Bu dizi boyutu, karakter arabelleklerinin API yöntemlerine veya ya da yapı birimleri için sıralanmasına karşın aynı olur `CharSet = CharSet.Auto` `CharSet = CharSet.Ansi` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-194">This array size is the same even when char buffers are marshaled to API methods or structs with `CharSet = CharSet.Auto` or `CharSet = CharSet.Ansi`.</span></span> <span data-ttu-id="1c1ba-195">Daha fazla bilgi için bkz. <xref:System.Runtime.InteropServices.CharSet>.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-195">For more information, see <xref:System.Runtime.InteropServices.CharSet>.</span></span>

<span data-ttu-id="1c1ba-196">Yukarıdaki örnekte `fixed` , C# 7,3 ile başlayarak kullanılabilir olan sabitleme olmadan alanlara erişme gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-196">The  preceding example demonstrates accessing `fixed` fields without pinning, which is available starting with C# 7.3.</span></span>

<span data-ttu-id="1c1ba-197">Diğer bir yaygın sabit boyutlu dizi [bool](builtin-types/bool.md) dizidir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-197">Another common fixed-size array is the [bool](builtin-types/bool.md) array.</span></span> <span data-ttu-id="1c1ba-198">Bir `bool` dizideki öğeler her zaman boyutu 1 bayttır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-198">The elements in a `bool` array are always 1 byte in size.</span></span> <span data-ttu-id="1c1ba-199">`bool` diziler, bit dizileri veya arabellekleri oluşturmak için uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-199">`bool` arrays aren't appropriate for creating bit arrays or buffers.</span></span>

<span data-ttu-id="1c1ba-200">Sabit boyutlu arabellekler ile derlenir ve <xref:System.Runtime.CompilerServices.UnsafeValueTypeAttribute?displayProperty=nameWithType> Bu, ortak dil çalışma zamanına (CLR) bir türün, bulunabilecek bir yönetilmeyen dizi içerdiğini söyler.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-200">Fixed size buffers are compiled with the <xref:System.Runtime.CompilerServices.UnsafeValueTypeAttribute?displayProperty=nameWithType>, which instructs the common language runtime (CLR) that a type contains an unmanaged array that can potentially overflow.</span></span> <span data-ttu-id="1c1ba-201">[Stackalloc](operators/stackalloc.md) kullanılarak ayrılan bellek Ayrıca clr 'de arabellek taşması algılama özelliklerini otomatik olarak sunar.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-201">Memory allocated using [stackalloc](operators/stackalloc.md) also automatically enables buffer overrun detection features in the CLR.</span></span> <span data-ttu-id="1c1ba-202">Önceki örnekte, bir sabit boyut arabelleğinin bir içinde nasıl yer aldığı gösterilmektedir `unsafe struct` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-202">The previous example shows how a fixed size buffer could exist in an `unsafe struct`.</span></span>

```csharp
internal unsafe struct Buffer
{
    public fixed char fixedBuffer[128];
}
```

<span data-ttu-id="1c1ba-203">Için derleyici tarafından oluşturulan C# `Buffer` aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-203">The compiler-generated C# for `Buffer` is attributed as follows:</span></span>

```csharp
internal struct Buffer
{
    [StructLayout(LayoutKind.Sequential, Size = 256)]
    [CompilerGenerated]
    [UnsafeValueType]
    public struct <fixedBuffer>e__FixedBuffer
    {
        public char FixedElementField;
    }

    [FixedBuffer(typeof(char), 128)]
    public <fixedBuffer>e__FixedBuffer fixedBuffer;
}
```

<span data-ttu-id="1c1ba-204">Sabit boyutlu arabellekler aşağıdaki yollarla normal dizilerden farklıdır:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-204">Fixed size buffers differ from regular arrays in the following ways:</span></span>

- <span data-ttu-id="1c1ba-205">Yalnızca bir `unsafe` bağlamda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-205">May only be used in an `unsafe` context.</span></span>
- <span data-ttu-id="1c1ba-206">Yalnızca yapıların örnek alanları olabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-206">May only be instance fields of structs.</span></span>
- <span data-ttu-id="1c1ba-207">Bunlar her zaman vektörleridir veya tek boyutlu dizilerdir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-207">They're always vectors, or one-dimensional arrays.</span></span>
- <span data-ttu-id="1c1ba-208">Bildirimin uzunluğu içermesi gerekir, örneğin `fixed char id[8]` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-208">The declaration should include the length, such as `fixed char id[8]`.</span></span> <span data-ttu-id="1c1ba-209">Kullanamazsınız `fixed char id[]` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-209">You can't use `fixed char id[]`.</span></span>

## <a name="how-to-use-pointers-to-copy-an-array-of-bytes"></a><span data-ttu-id="1c1ba-210">Bayt dizisine kopyalamak için işaretçileri kullanma</span><span class="sxs-lookup"><span data-stu-id="1c1ba-210">How to use pointers to copy an array of bytes</span></span>

<span data-ttu-id="1c1ba-211">Aşağıdaki örnek, baytları bir diziden diğerine kopyalamak için işaretçileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-211">The following example uses pointers to copy bytes from one array to another.</span></span>

<span data-ttu-id="1c1ba-212">Bu örnek, yönteminde işaretçiler kullanmanıza olanak tanıyan [unsafe](keywords/unsafe.md) anahtar sözcüğünü kullanır `Copy` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-212">This example uses the [unsafe](keywords/unsafe.md) keyword, which enables you to use pointers in the `Copy` method.</span></span> <span data-ttu-id="1c1ba-213">[Fixed](keywords/fixed-statement.md) deyimleri, kaynak ve hedef dizilere işaretçiler bildirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-213">The [fixed](keywords/fixed-statement.md) statement is used to declare pointers to the source and destination arrays.</span></span> <span data-ttu-id="1c1ba-214">`fixed`İfade, kaynak ve hedef dizilerinin konumunu çöp toplama tarafından taşınmayacak şekilde *sabitler* .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-214">The `fixed` statement *pins* the location of the source and destination arrays in memory so that they will not be moved by garbage collection.</span></span> <span data-ttu-id="1c1ba-215">Blok tamamlandığında diziler için bellek blokları `fixed` sabitlenemez.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-215">The memory blocks for the arrays are unpinned when the `fixed` block is completed.</span></span> <span data-ttu-id="1c1ba-216">`Copy`Bu örnekteki yöntem `unsafe` anahtar sözcüğünü kullandığından, [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) derleyici seçeneğiyle derlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-216">Because the `Copy` method in this example uses the `unsafe` keyword, it must be compiled with the [**AllowUnsafeBlocks**](compiler-options/language.md#allowunsafeblocks) compiler option.</span></span>

<span data-ttu-id="1c1ba-217">Bu örnek, ikinci bir yönetilmeyen işaretçi yerine dizinler kullanılarak her iki dizinin öğelerine erişir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-217">This example accesses the elements of both arrays using indices rather than a second unmanaged pointer.</span></span> <span data-ttu-id="1c1ba-218">`pSource`Ve `pTarget` işaretçilerinin bildirimi dizileri sabitler.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-218">The declaration of the `pSource` and `pTarget` pointers pins the arrays.</span></span> <span data-ttu-id="1c1ba-219">Bu özellik C# 7,3 ile başlayarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-219">This feature is available starting with C# 7.3.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FixedKeywordExamples.cs" ID="8":::

## <a name="function-pointers"></a><span data-ttu-id="1c1ba-220">İşlev işaretçileri</span><span class="sxs-lookup"><span data-stu-id="1c1ba-220">Function pointers</span></span>

<span data-ttu-id="1c1ba-221">C#, [`delegate`](builtin-types/reference-types.md#the-delegate-type) güvenli işlev işaretçisi nesneleri tanımlamak için türler sağlar.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-221">C# provides [`delegate`](builtin-types/reference-types.md#the-delegate-type) types to define safe function pointer objects.</span></span> <span data-ttu-id="1c1ba-222">Bir temsilciyi çağırmak, öğesinden türetilmiş bir türün örneklenmesini <xref:System.Delegate?displayProperty=nameWithType> ve yöntemine bir sanal yöntem çağrısını yapmayı içerir `Invoke` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-222">Invoking a delegate involves instantiating a type derived from <xref:System.Delegate?displayProperty=nameWithType> and making a virtual method call to its `Invoke` method.</span></span> <span data-ttu-id="1c1ba-223">Bu sanal çağrı `callvirt` Il yönergesini kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-223">This virtual call uses the `callvirt` IL instruction.</span></span> <span data-ttu-id="1c1ba-224">Performans açısından kritik kod yollarında `calli` Il yönergesini kullanmak daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-224">In performance critical code paths, using the `calli` IL instruction is more efficient.</span></span>

<span data-ttu-id="1c1ba-225">Sözdizimini kullanarak bir işlev işaretçisi tanımlayabilirsiniz `delegate*` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-225">You can define a function pointer using the `delegate*` syntax.</span></span> <span data-ttu-id="1c1ba-226">Derleyici, `calli` bir nesneyi başlatmak ve çağırmak yerine yönergeyi kullanarak işlevi çağırır `delegate` `Invoke` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-226">The compiler will call the function using the `calli` instruction rather than instantiating a `delegate` object and calling `Invoke`.</span></span> <span data-ttu-id="1c1ba-227">Aşağıdaki kod `delegate` `delegate*` , aynı türde iki nesneyi birleştirmek için bir veya kullanan iki yöntem bildirir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-227">The following code declares two methods that use a `delegate` or a `delegate*` to combine two objects of the same type.</span></span> <span data-ttu-id="1c1ba-228">İlk yöntem bir <xref:System.Func%603?displayProperty=nameWithType> temsilci türü kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-228">The first method uses a <xref:System.Func%603?displayProperty=nameWithType> delegate type.</span></span> <span data-ttu-id="1c1ba-229">İkinci yöntem `delegate*` aynı parametrelere ve dönüş türüne sahip bir bildirim kullanır:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-229">The second method uses a `delegate*` declaration with the same parameters and return type:</span></span>

:::code language="csharp" source="snippets/unsafe-code/FunctionPointers.cs" ID="UseDelegateOrPointer":::

<span data-ttu-id="1c1ba-230">Aşağıdaki kod, statik bir yerel işlevi nasıl bildirebileceğinizi ve `UnsafeCombine` Bu yerel işleve yönelik bir işaretçi kullanarak yöntemi çağırmayı gösterir:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-230">The following code shows how you would declare a static local function and invoke the `UnsafeCombine` method using a pointer to that local function:</span></span>

:::code language="csharp" source="snippets/unsafe-code/FunctionPointers.cs" ID="InvokeViaFunctionPointer":::

<span data-ttu-id="1c1ba-231">Yukarıdaki kod, işlev işaretçisi olarak erişilen işlev üzerindeki kuralların birkaçını gösterir:</span><span class="sxs-lookup"><span data-stu-id="1c1ba-231">The preceding code illustrates several of the rules on the function accessed as a function pointer:</span></span>

- <span data-ttu-id="1c1ba-232">İşlev işaretçileri, yalnızca bir `unsafe` bağlamda bildirilemez.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-232">Function pointers can only be declared in an `unsafe` context.</span></span>
- <span data-ttu-id="1c1ba-233">`delegate*`(Veya döndüren `delegate*` ) Yöntemler, yalnızca bir `unsafe` bağlamda çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-233">Methods that take a `delegate*` (or return a `delegate*`) can only be called in an `unsafe` context.</span></span>
- <span data-ttu-id="1c1ba-234">`&`Bir işlevin adresini elde etmek için olan işlece yalnızca işlevlerde izin verilir `static` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-234">The `&` operator to obtain the address of a function is allowed only on `static` functions.</span></span> <span data-ttu-id="1c1ba-235">(Bu kural hem üye işlevleri hem de yerel işlevler için geçerlidir).</span><span class="sxs-lookup"><span data-stu-id="1c1ba-235">(This rule applies to both member functions and local functions).</span></span>

<span data-ttu-id="1c1ba-236">Sözdizimi, `delegate` türleri bildirme ve işaretçiler kullanma ile paraleller içeriyor.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-236">The syntax has parallels with declaring `delegate` types and using pointers.</span></span> <span data-ttu-id="1c1ba-237">`*`Üzerindeki sonek, `delegate` bildirimin bir *işlev işaretçisi* olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-237">The `*` suffix on `delegate` indicates the declaration is a *function pointer*.</span></span> <span data-ttu-id="1c1ba-238">Bir `&` işlev işaretçisine bir yöntem grubu atanırken işlemin, yöntemin adresini aldığını belirtir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-238">The `&` when assigning a method group to a function pointer indicates the operation takes the address of the method.</span></span>

<span data-ttu-id="1c1ba-239">`delegate*`Anahtar sözcüklerini ve kullanarak bir için çağırma kuralı belirtebilirsiniz `managed` `unmanaged` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-239">You can specify the calling convention for a `delegate*` using the keywords `managed` and `unmanaged`.</span></span> <span data-ttu-id="1c1ba-240">Ayrıca, `unmanaged` işlev işaretçileri için, çağırma kuralını belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-240">In addition, for `unmanaged` function pointers, you can specify the calling convention.</span></span> <span data-ttu-id="1c1ba-241">Aşağıdaki bildirimlerde her birinin örnekleri gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-241">The following declarations show examples of each.</span></span> <span data-ttu-id="1c1ba-242">İlk bildirim, `managed` varsayılan olan çağırma kuralını kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-242">The first declaration uses the `managed` calling convention, which is the default.</span></span> <span data-ttu-id="1c1ba-243">Sonraki üç `unmanaged` çağrı kuralını kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-243">The next three use an `unmanaged` calling convention.</span></span> <span data-ttu-id="1c1ba-244">Her biri ECMA 335 çağırma kurallarından birini belirtir: `Cdecl` , `Stdcall` , `Fastcall` veya `Thiscall` .</span><span class="sxs-lookup"><span data-stu-id="1c1ba-244">Each specifies one of the ECMA 335 calling conventions: `Cdecl`, `Stdcall`, `Fastcall`, or `Thiscall`.</span></span> <span data-ttu-id="1c1ba-245">Son bildirimler, `unmanaged` platform için varsayılan çağırma kuralını seçmek üzere clr 'yi, çağıran kuralını kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-245">The last declarations uses the `unmanaged` calling convention, instructing the CLR to pick the default calling convention for the platform.</span></span> <span data-ttu-id="1c1ba-246">CLR, çalışma zamanında çağrı kuralını seçer.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-246">The CLR will choose the calling convention at run time.</span></span>

:::code language="csharp" source="snippets/unsafe-code/FunctionPointers.cs" ID="UnmanagedFunctionPointers":::

<span data-ttu-id="1c1ba-247">C# 9,0 için [işlev işaretçisi](~/_csharplang/proposals/csharp-9.0/function-pointers.md) teklifinde işlev işaretçileri hakkında daha fazla bilgi edinebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-247">You can learn more about function pointers in the [Function pointer](~/_csharplang/proposals/csharp-9.0/function-pointers.md) proposal for C# 9.0.</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="1c1ba-248">C# dili belirtimi</span><span class="sxs-lookup"><span data-stu-id="1c1ba-248">C# language specification</span></span>

<span data-ttu-id="1c1ba-249">Daha fazla bilgi için [C# dil belirtiminin](~/_csharplang/spec/introduction.md) [güvenli olmayan kod](~/_csharplang/spec/unsafe-code.md) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="1c1ba-249">For more information, see the [Unsafe code](~/_csharplang/spec/unsafe-code.md) chapter of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>
