---
title: İş Parçacığı Koleksiyonları
description: .NET ' te iş parçacığı açısından güvenli ve ölçeklenebilir koleksiyon sınıfları içeren System. Collections. eşzamanlı ad alanını kullanarak iş parçacığı açısından güvenli Koleksiyonlar ile çalışmaya başlayın.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 3a252124ade4c43961c06697367bbc4ca5d0c9cb
ms.sourcegitcommit: 5fd4696a3e5791b2a8c449ccffda87f2cc2d4894
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/15/2020
ms.locfileid: "84768592"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="fbe8b-103">İş Parçacığı Koleksiyonları</span><span class="sxs-lookup"><span data-stu-id="fbe8b-103">Thread-Safe Collections</span></span>
<span data-ttu-id="fbe8b-104">.NET Framework 4, <xref:System.Collections.Concurrent?displayProperty=nameWithType> hem iş parçacığı güvenli hem de ölçeklenebilir olan birkaç koleksiyon sınıfını içeren ad alanını tanıtır.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-104">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="fbe8b-105">Birden çok iş parçacığı, Kullanıcı kodunda ek eşitlemeye gerek duymadan, bu koleksiyonlardan öğeleri güvenle ve etkili bir şekilde ekleyebilir veya kaldırabilir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-105">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="fbe8b-106">Yeni kod yazdığınızda, birden çok iş parçacığının koleksiyona aynı anda yazılacağı her seferinde eşzamanlı koleksiyon sınıflarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-106">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="fbe8b-107">Yalnızca paylaşılan bir koleksiyondan okuyorsanız <xref:System.Collections.Generic?displayProperty=nameWithType> ad alanındaki sınıfları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-107">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="fbe8b-108">.NET Framework 1.1 veya önceki çalışma zamanı sürümünü hedeflemeniz gerekmedikçe 1.0 koleksiyon sınıflarını kullanmamanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-108">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="fbe8b-109">.NET Framework 1.0 ve 2.0 Koleksiyonlarındaki İş Parçacığı Eşitlemesi</span><span class="sxs-lookup"><span data-stu-id="fbe8b-109">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="fbe8b-110">.NET Framework 1.0'da tanıtılan koleksiyonlar <xref:System.Collections?displayProperty=nameWithType> ad alanında bulunur.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-110">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="fbe8b-111">Sık kullanılan <xref:System.Collections.ArrayList> ve <xref:System.Collections.Hashtable> öğelerini içeren bu koleksiyonlar, koleksiyon etrafında bir iş parçacığı güvenlikli sarmalayıcıyı döndüren `Synchronized` özelliği ile biraz iş parçacığı güvenliği sağlar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-111">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="fbe8b-112">Sarmalayıcı, her ekleme veya kaldırma işleminde tüm koleksiyonu kilitleyerek çalışır.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-112">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="fbe8b-113">Bu nedenle, koleksiyona erişmeye çalışan her bir iş parçacığının bir kilidi almak için kendi sırasını beklemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-113">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="fbe8b-114">Bu ölçeklenebilir değildir ve büyük koleksiyonlar için önemli performans düşüşüne neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-114">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="fbe8b-115">Ayrıca tasarım, yarış durumlarına karşı tamamen korumalı değildir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-115">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="fbe8b-116">Daha fazla bilgi için bkz. [genel koleksiyonlardaki eşitleme](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span><span class="sxs-lookup"><span data-stu-id="fbe8b-116">For more information, see [Synchronization in Generic Collections](https://docs.microsoft.com/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="fbe8b-117">.NET Framework 2.0'da tanıtılan koleksiyon sınıfları <xref:System.Collections.Generic?displayProperty=nameWithType> ad alanında bulunur.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-117">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="fbe8b-118">Bunlar <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> ve benzerlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-118">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="fbe8b-119">Bu sınıflar, .NET Framework 1.0 sınıfları ile karşılaştırıldığında geliştirilmiş tür güvenliği ve performans sağlar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-119">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="fbe8b-120">Ancak, .NET Framework 2.0 koleksiyon sınıfları herhangi bir iş parçacığı eşitlemesi sağlamaz; kullanıcı kodunun, öğeler aynı anda birden çok iş parçacığına eklendiğinde veya kaldırıldığında tüm eşitlemeyi sağlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-120">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="fbe8b-121">.NET Framework 2,0 koleksiyon sınıflarının yalnızca tür güvenliğini sağlamadıkları ve ayrıca .NET Framework 1,0 koleksiyonlarından daha verimli ve daha fazla iş parçacığı güvenliği sağladıkları için .NET Framework 4 ' te eşzamanlı koleksiyonlar sınıflarını öneririz.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-121">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="fbe8b-122">Hassas Kilitleme ve Kilitsiz Mekanizmalar</span><span class="sxs-lookup"><span data-stu-id="fbe8b-122">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="fbe8b-123">Bazı eşzamanlı koleksiyon türleri,,, ve gibi basit eşitleme mekanizmalarını <xref:System.Threading.SpinLock> ( <xref:System.Threading.SpinWait> <xref:System.Threading.SemaphoreSlim> <xref:System.Threading.CountdownEvent> .NET Framework 4 ' te yeni) kullanır.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-123">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="fbe8b-124">Bu eşitleme türleri genellikle, iş parçacığını doğru bekleme durumuna almadan önce kısa dönemler için *meşgul dönmesini* kullanır.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-124">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="fbe8b-125">Bekleme sürelerinin çok kısa olması beklendiğinde pahalı bir çekirdek dönüşümünü içeren dönme beklemeden hesaplama açısından çok daha ucuzdur.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-125">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="fbe8b-126">Dönme kullanan koleksiyon sınıfları için bu verimlilik, birden çok iş parçacığının yüksek bir hızda öğe ekleyip kaldırabildiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-126">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="fbe8b-127">Dönme ve engelleme hakkında daha fazla bilgi için bkz. [SpinLock](../../threading/spinlock.md) ve [SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="fbe8b-127">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="fbe8b-128"><xref:System.Collections.Concurrent.ConcurrentQueue%601> ve <xref:System.Collections.Concurrent.ConcurrentStack%601> sınıfları kilitleri hiç kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-128">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="fbe8b-129">Bunun yerine, iş parçacığı güvenliğini sağlamak için <xref:System.Threading.Interlocked> işlemlerine dayanırlar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-129">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fbe8b-130">Eşzamanlı koleksiyon sınıfları <xref:System.Collections.ICollection> öğesini desteklediğinden, ilgisi olmasa bile <xref:System.Collections.ICollection.IsSynchronized%2A> ve <xref:System.Collections.ICollection.SyncRoot%2A> özellikleri için uygulama sağlarlar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-130">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="fbe8b-131">`IsSynchronized` her zaman `false`'i döndürür ve `SyncRoot` her zaman `null` (Visual Basic'te `Nothing`) olarak ayarlıdır.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-131">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="fbe8b-132">Aşağıdaki tablo, <xref:System.Collections.Concurrent?displayProperty=nameWithType> ad alanındaki koleksiyon türlerini listeler.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-132">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="fbe8b-133">Tür</span><span class="sxs-lookup"><span data-stu-id="fbe8b-133">Type</span></span>|<span data-ttu-id="fbe8b-134">Description</span><span class="sxs-lookup"><span data-stu-id="fbe8b-134">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="fbe8b-135"><xref:System.Collections.Concurrent.IProducerConsumerCollection%601> öğesini uygulayan herhangi bir tür için sınırlama ve engelleme işlevleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-135">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="fbe8b-136">Daha fazla bilgi için bkz. [BlockingCollection genel bakış](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="fbe8b-136">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="fbe8b-137">Anahtar-değer çiftlerinin sözlüğünün iş parçacığı açısından güvenli uygulaması.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-137">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="fbe8b-138">Bir FIFO (ilk giren ilk çıkar) sırasının iş parçacığı açısından güvenli uygulaması.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-138">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="fbe8b-139">Bir LIFO (son giren ilk çıkar) yığının iş parçacığı açısından güvenli uygulaması.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-139">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="fbe8b-140">Öğelerin sırasız koleksiyonunun iş parçacığı açısından güvenli uygulaması.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-140">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="fbe8b-141">Bir türün `BlockingCollection` içinde kullanılabilmesi için uygulaması gereken ara birim.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-141">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="fbe8b-142">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="fbe8b-142">Related Topics</span></span>  
  
|<span data-ttu-id="fbe8b-143">Başlık</span><span class="sxs-lookup"><span data-stu-id="fbe8b-143">Title</span></span>|<span data-ttu-id="fbe8b-144">Açıklama</span><span class="sxs-lookup"><span data-stu-id="fbe8b-144">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="fbe8b-145">BlockingCollection Genel Bakışı</span><span class="sxs-lookup"><span data-stu-id="fbe8b-145">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="fbe8b-146"><xref:System.Collections.Concurrent.BlockingCollection%601> türü tarafından sağlanan işlevselliği açıklar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-146">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="fbe8b-147">Nasıl yapılır: Öğeleri Ekleme ve Bir ConcurrentDictionary'dan Alma</span><span class="sxs-lookup"><span data-stu-id="fbe8b-147">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="fbe8b-148">Bir <xref:System.Collections.Concurrent.ConcurrentDictionary%602> öğesine öğelerin nasıl ekleneceğini ve kaldırılacağını açıklar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-148">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="fbe8b-149">Nasıl yapılır: Öğeleri Tek Tek Ekleme ve Bir BlockingCollection'dan Alma</span><span class="sxs-lookup"><span data-stu-id="fbe8b-149">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="fbe8b-150">Salt okunur numaralayıcı kullanmadan bir engelleme koleksiyonundan öğelerin nasıl eklenip alınacağını açıklar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-150">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="fbe8b-151">Nasıl yapılır: Koleksiyona Sınırlama ve Engelleme İşlevi Ekleme</span><span class="sxs-lookup"><span data-stu-id="fbe8b-151">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="fbe8b-152">Bir <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> koleksiyonu için herhangi bir koleksiyon sınıfının temel depolama mekanizması olarak nasıl kullanılacağını açıklar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-152">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="fbe8b-153">Nasıl yapılır: Bir BlockingCollection'daki Öğeleri Kaldırmak için ForEach Kullanma</span><span class="sxs-lookup"><span data-stu-id="fbe8b-153">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="fbe8b-154">Bir engelleme koleksiyondaki tüm öğeleri kaldırmak için `foreach` (Visual Basic'te `For Each`) öğesinin nasıl kullanılacağını açıklar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-154">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="fbe8b-155">Nasıl yapılır: Ardışık Düzende Engelleme Koleksiyonu Dizilerini Kullanma</span><span class="sxs-lookup"><span data-stu-id="fbe8b-155">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="fbe8b-156">Bir ardışık düzeni uygulamak için birden çok engelleme koleksiyonunun aynı anda nasıl kullanılacağını açıklar.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-156">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="fbe8b-157">Nasıl yapılır: ConcurrentBag Kullanarak Nesne Havuzu Oluşturma</span><span class="sxs-lookup"><span data-stu-id="fbe8b-157">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="fbe8b-158">Sürekli yenilerini oluşturmak yerine, nesneleri yeniden kullanabileceğiniz senaryolarda performansı artırmak için eşzamanlı torbaların nasıl kullanılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="fbe8b-158">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="fbe8b-159">Başvuru</span><span class="sxs-lookup"><span data-stu-id="fbe8b-159">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
