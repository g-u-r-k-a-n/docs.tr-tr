---
title: Yavaş Başlatma
description: Nesne oluşturmanın, nesne ilk kez kullanılana kadar ertelenmesi anlamına gelen bir performans geliştirmesi olan .NET ' te yavaş başlatmayı keşfet.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 355fa326fc19e9a50a74e21ace0a6353f5c740c5
ms.sourcegitcommit: 3824ff187947572b274b9715b60c11269335c181
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/17/2020
ms.locfileid: "84904240"
---
# <a name="lazy-initialization"></a><span data-ttu-id="33d73-103">Yavaş Başlatma</span><span class="sxs-lookup"><span data-stu-id="33d73-103">Lazy Initialization</span></span>
<span data-ttu-id="33d73-104">Bir nesnenin *geç başlatılması* , oluşturulması ilk kullanılana kadar ertelenmesi anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33d73-104">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="33d73-105">(Bu konu için, *yavaş başlatma* ve *yavaş örnekleme* terimleri eş anlamlı.) Yavaş başlatma öncelikle performansı artırmak, gereksiz hesaplama önlemek ve program belleği gereksinimlerini azaltmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="33d73-105">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="33d73-106">Bunlar en yaygın senaryolardır:</span><span class="sxs-lookup"><span data-stu-id="33d73-106">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="33d73-107">Oluşturmakta maliyetli bir nesneniz varsa ve program bunu kullanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-107">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="33d73-108">Örneğin, bir `Customer` nesne içinde, başlatılacak olan büyük bir nesne dizisi içeren bir özelliği olan bir nesnesi olduğunu varsayalım `Orders` `Order` , bir veritabanı bağlantısı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="33d73-108">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="33d73-109">Kullanıcı hiçbir şekilde siparişleri görüntülemeyi veya verileri bir hesaplamada kullanmayı istemez, bu durumda sistem belleğini veya bilgi işlem döngülerini oluşturmak için bir neden yoktur.</span><span class="sxs-lookup"><span data-stu-id="33d73-109">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="33d73-110">`Lazy<Orders>` `Orders` Yavaş başlatma için nesneyi bildirmek üzere kullanarak, nesne kullanılmazsa sistem kaynaklarının geri harcanmasını engelleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-110">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="33d73-111">Oluşturma maliyetli bir nesneniz varsa ve diğer maliyetli İşlemler tamamlanana kadar oluşturmayı erteleyin.</span><span class="sxs-lookup"><span data-stu-id="33d73-111">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="33d73-112">Örneğin, programınızın başladığında birkaç nesne örneği yüklediğini varsayın, ancak yalnızca bir kısmı hemen gereklidir.</span><span class="sxs-lookup"><span data-stu-id="33d73-112">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="33d73-113">Gerekli nesneler oluşturuluncaya kadar gerekli olmayan nesneleri başlatmayı erteleyerek programın başlangıç performansını artırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-113">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="33d73-114">Yavaş başlatma gerçekleştirmek için kendi kodunuzu yazabilseniz de, <xref:System.Lazy%601> bunun yerine kullanmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="33d73-114">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="33d73-115"><xref:System.Lazy%601>Ayrıca, ilgili türleri iş parçacığı güvenliğini destekler ve tutarlı bir özel durum yayma ilkesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d73-115"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="33d73-116">Aşağıdaki tabloda, farklı senaryolarda yavaş başlatmayı etkinleştirmek için .NET Framework sürüm 4 ' ün sağladığı türler listelenmektedir.</span><span class="sxs-lookup"><span data-stu-id="33d73-116">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="33d73-117">Tür</span><span class="sxs-lookup"><span data-stu-id="33d73-117">Type</span></span>|<span data-ttu-id="33d73-118">Description</span><span class="sxs-lookup"><span data-stu-id="33d73-118">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="33d73-119">Herhangi bir sınıf kitaplığı veya Kullanıcı tanımlı tür için yavaş başlatma semantiğini sağlayan sarmalayıcı sınıf.</span><span class="sxs-lookup"><span data-stu-id="33d73-119">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="33d73-120"><xref:System.Lazy%601>Buna benzer şekilde, iş parçacığı yerel temelinde yavaş başlatma semantiği sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d73-120">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="33d73-121">Her iş parçacığının kendi benzersiz değerine erişimi vardır.</span><span class="sxs-lookup"><span data-stu-id="33d73-121">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="33d73-122">`static` `Shared` Bir sınıfın ek yükü olmadan nesnelerin yavaş başlatılmasına yönelik gelişmiş (Visual Basic) yöntemler sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d73-122">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="33d73-123">Temel yavaş başlatma</span><span class="sxs-lookup"><span data-stu-id="33d73-123">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="33d73-124">Geç başlatılmış bir tür tanımlamak için, örneğin, `MyType` `Lazy<MyType>` `Lazy(Of MyType)` Aşağıdaki örnekte gösterildiği gibi (Visual Basic) kullanın.</span><span class="sxs-lookup"><span data-stu-id="33d73-124">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="33d73-125">Oluşturucuya hiçbir temsilci geçirilmemişse <xref:System.Lazy%601> , sarmalanmış tür, <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> Value özelliğine ilk erişildiğinde kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="33d73-125">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="33d73-126">Türün parametresiz bir Oluşturucusu yoksa, bir çalışma zamanı özel durumu oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="33d73-126">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="33d73-127">Aşağıdaki örnekte, `Orders` `Order` bir veritabanından alınan nesne dizisini içeren bir sınıf olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="33d73-127">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="33d73-128">Bir `Customer` nesnesi bir örneği içerir `Orders` , ancak kullanıcı eylemlerine bağlı olarak, `Orders` nesnedeki veriler gerekli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-128">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="33d73-129">Ayrıca, <xref:System.Lazy%601> oluşturma zamanında sarmalanmış tür üzerinde belirli bir Oluşturucu aşırı yüklemesini çağıran oluşturucuya bir temsilci geçirebilir ve aşağıdaki örnekte gösterildiği gibi gereken diğer başlatma adımlarını gerçekleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-129">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="33d73-130">Lazy nesnesi oluşturulduktan sonra, `Orders` <xref:System.Lazy%601.Value%2A> geç değişkeninin özelliğine ilk kez erişilene kadar bir örneği oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="33d73-130">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="33d73-131">İlk erişimde, Sarmalanan tür oluşturulur ve döndürülür ve gelecekte herhangi bir erişim için depolanır.</span><span class="sxs-lookup"><span data-stu-id="33d73-131">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="33d73-132">Bir <xref:System.Lazy%601> nesne her zaman ile başlatıldığı nesne veya değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="33d73-132">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="33d73-133">Bu nedenle, <xref:System.Lazy%601.Value%2A> özelliği salt okunurdur.</span><span class="sxs-lookup"><span data-stu-id="33d73-133">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="33d73-134"><xref:System.Lazy%601.Value%2A>Bir başvuru türü depoluyorsa, buna yeni bir nesne atayamazsınız.</span><span class="sxs-lookup"><span data-stu-id="33d73-134">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="33d73-135">(Ancak, ayarlanabilir ortak alanları ve özellikleri değerini değiştirebilirsiniz.) <xref:System.Lazy%601.Value%2A>Değer türünü saklarsa, değerini değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-135">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="33d73-136">Bununla birlikte, yeni bağımsız değişkenler kullanarak değişken oluşturucuyu yeniden çağırarak yeni bir değişken oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-136">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="33d73-137">Daha önceki bir gibi yeni bir geç örnek, `Orders` <xref:System.Lazy%601.Value%2A> özelliği ilk kez erişilene kadar örneklemez.</span><span class="sxs-lookup"><span data-stu-id="33d73-137">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="33d73-138">İş parçacığı güvenli başlatma</span><span class="sxs-lookup"><span data-stu-id="33d73-138">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="33d73-139">Varsayılan olarak, <xref:System.Lazy%601> nesneler iş parçacığı güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="33d73-139">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="33d73-140">Diğer bir deyişle, Oluşturucu iş parçacığı güvenliği türünü belirtmezse, <xref:System.Lazy%601> oluşturduğu nesneler iş parçacığı güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="33d73-140">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="33d73-141">Çok iş parçacıklı senaryolarda, <xref:System.Lazy%601.Value%2A> iş parçacığı açısından güvenli bir nesnenin özelliğine erişmek için ilk iş parçacığı, <xref:System.Lazy%601> tüm iş parçacıklarında sonraki tüm erişimler için onu başlatır ve tüm iş parçacıkları aynı verileri paylaşır.</span><span class="sxs-lookup"><span data-stu-id="33d73-141">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="33d73-142">Bu nedenle, hangi iş parçacığının nesneyi başlattığında ve yarış durumlarının zararsız olması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="33d73-142">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="33d73-143">Özel durum önbelleğe alma özelliğini kullanarak bu tutarlılığı hata koşullarına genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-143">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="33d73-144">Daha fazla bilgi için, [yavaş nesnelerdeki özel durumlar](lazy-initialization.md#ExceptionsInLazyObjects)başlıklı sonraki bölüme bakın.</span><span class="sxs-lookup"><span data-stu-id="33d73-144">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="33d73-145">Aşağıdaki örnek, aynı `Lazy<int>` Örneğin üç ayrı iş parçacığı için aynı değere sahip olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="33d73-145">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="33d73-146">Her iş parçacığında ayrı veriye ihtiyacınız varsa, <xref:System.Threading.ThreadLocal%601> Bu konunun ilerleyen kısımlarında açıklandığı gibi türü kullanın.</span><span class="sxs-lookup"><span data-stu-id="33d73-146">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="33d73-147">Bazı <xref:System.Lazy%601> oluşturucuların `isThreadSafe` , <xref:System.Lazy%601.Value%2A> özelliğe birden çok iş parçacığından erişip erişmeyeceğini belirtmek için kullanılan adlı bir Boolean parametresi vardır.</span><span class="sxs-lookup"><span data-stu-id="33d73-147">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="33d73-148">Özelliğe yalnızca bir iş parçacığından erişmeyi planlıyorsanız, `false` bir ila büyüklükteki performans avantajı elde etmek için geçirin.</span><span class="sxs-lookup"><span data-stu-id="33d73-148">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="33d73-149">Özelliğe birden çok iş parçacığından erişmeyi planlıyorsanız, `true` <xref:System.Lazy%601> bir iş parçacığının başlatma zamanında bir özel durum oluşturan yarış koşullarını doğru şekilde işlemesini bildirmek için geçirin.</span><span class="sxs-lookup"><span data-stu-id="33d73-149">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="33d73-150">Bazı <xref:System.Lazy%601> oluşturucuların adlı bir <xref:System.Threading.LazyThreadSafetyMode> parametresi vardır `mode` .</span><span class="sxs-lookup"><span data-stu-id="33d73-150">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="33d73-151">Bu oluşturucular ek bir iş parçacığı güvenliği modu sağlar.</span><span class="sxs-lookup"><span data-stu-id="33d73-151">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="33d73-152">Aşağıdaki tabloda, bir nesnenin iş parçacığı güvenliği, <xref:System.Lazy%601> iş parçacığı güvenliğini belirten Oluşturucu parametrelerinden nasıl etkileneceği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33d73-152">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="33d73-153">Her oluşturucunun bu tür bir parametresi vardır.</span><span class="sxs-lookup"><span data-stu-id="33d73-153">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="33d73-154">Nesnenin iş parçacığı güvenliği</span><span class="sxs-lookup"><span data-stu-id="33d73-154">Thread safety of the object</span></span>|<span data-ttu-id="33d73-155">`LazyThreadSafetyMode``mode`parametre</span><span class="sxs-lookup"><span data-stu-id="33d73-155">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="33d73-156">Boolean `isThreadSafe` parametresi</span><span class="sxs-lookup"><span data-stu-id="33d73-156">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="33d73-157">İş parçacığı güvenlik parametresi yok</span><span class="sxs-lookup"><span data-stu-id="33d73-157">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="33d73-158">Tam iş parçacığı güvenli; tek seferde yalnızca bir iş parçacığı değeri başlatmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="33d73-158">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="33d73-159">Evet.</span><span class="sxs-lookup"><span data-stu-id="33d73-159">Yes.</span></span>|  
|<span data-ttu-id="33d73-160">İş parçacığı açısından güvenli değildir.</span><span class="sxs-lookup"><span data-stu-id="33d73-160">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="33d73-161">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="33d73-161">Not applicable.</span></span>|  
|<span data-ttu-id="33d73-162">Tam iş parçacığı güvenli; değeri başlatmak için iş parçacıkları Race.</span><span class="sxs-lookup"><span data-stu-id="33d73-162">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="33d73-163">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="33d73-163">Not applicable.</span></span>|<span data-ttu-id="33d73-164">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="33d73-164">Not applicable.</span></span>|  
  
 <span data-ttu-id="33d73-165">Tabloda gösterildiği gibi, <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> parametresi için belirtmek `mode` parametresi için belirtmeyle aynıdır ve belirtme, `true` `isThreadSafe` <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> belirtilerek aynı olur `false` .</span><span class="sxs-lookup"><span data-stu-id="33d73-165">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="33d73-166">Belirtme <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> , örneği başlatmayı denemek için birden çok iş parçacığının kullanılmasına izin verir <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="33d73-166">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="33d73-167">Bu yarış 'i yalnızca bir iş parçacığı alabilir ve diğer tüm iş parçacıkları başarılı iş parçacığı tarafından başlatılan değeri alır.</span><span class="sxs-lookup"><span data-stu-id="33d73-167">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="33d73-168">Başlatma sırasında bir iş parçacığında bir özel durum oluşturulursa, bu iş parçacığı başarılı iş parçacığı tarafından ayarlanan değeri almaz.</span><span class="sxs-lookup"><span data-stu-id="33d73-168">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="33d73-169">Özel durumlar önbelleğe alınmaz, bu nedenle özelliğe daha sonra erişme girişimi <xref:System.Lazy%601.Value%2A> başarıyla başlatılmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-169">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="33d73-170">Bu, özel durumların aşağıdaki bölümde açıklanan diğer modlarda ele alındığı yollardan farklıdır.</span><span class="sxs-lookup"><span data-stu-id="33d73-170">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="33d73-171">Daha fazla bilgi için bkz <xref:System.Threading.LazyThreadSafetyMode> . sabit listesi.</span><span class="sxs-lookup"><span data-stu-id="33d73-171">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="33d73-172">Yavaş nesnelerde özel durumlar</span><span class="sxs-lookup"><span data-stu-id="33d73-172">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="33d73-173">Daha önce belirtildiği gibi, bir <xref:System.Lazy%601> nesne her zaman ile başlatıldığı aynı nesne veya değeri döndürür ve bu nedenle <xref:System.Lazy%601.Value%2A> özellik salt okunurdur.</span><span class="sxs-lookup"><span data-stu-id="33d73-173">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="33d73-174">Özel durum önbelleğe almayı etkinleştirirseniz bu yaklaşım, özel durum davranışına de genişletilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-174">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="33d73-175">Geç başlatılmış bir nesnenin özel durum önbelleğe alma özelliği varsa ve özellik ilk kez erişildiğinde başlatma yönteminden bir özel durum oluşturursa <xref:System.Lazy%601.Value%2A> , bu özelliğe erişmek için sonraki her denemede aynı özel durum oluşturulur <xref:System.Lazy%601.Value%2A> .</span><span class="sxs-lookup"><span data-stu-id="33d73-175">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="33d73-176">Diğer bir deyişle, kaydırılmış türdeki Oluşturucu, çok iş parçacıklı senaryolarda bile hiçbir şekilde yeniden çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="33d73-176">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="33d73-177">Bu nedenle, <xref:System.Lazy%601> nesne tek bir erişim üzerinde bir özel durum oluşturmaz ve sonraki erişimde bir değer döndürmez.</span><span class="sxs-lookup"><span data-stu-id="33d73-177">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="33d73-178"><xref:System.Lazy%601?displayProperty=nameWithType>Bir başlatma yöntemi (parametre) alan herhangi bir Oluşturucu kullandığınızda özel durum önbelleğe alma etkinleştirilir `valueFactory` ; Örneğin, oluşturucuyu kullandığınızda etkinleştirilir `Lazy(T)(Func(T))` .</span><span class="sxs-lookup"><span data-stu-id="33d73-178">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="33d73-179">Oluşturucu aynı zamanda bir <xref:System.Threading.LazyThreadSafetyMode> değer ( `mode` parametre) alırsa, veya belirtin <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="33d73-179">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="33d73-180">Bir başlatma yöntemi belirtildiğinde, bu iki mod için özel durum önbelleğe alma etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-180">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="33d73-181">Başlatma yöntemi çok basit olabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-181">The initialization method can be very simple.</span></span> <span data-ttu-id="33d73-182">Örneğin, `T` `new Lazy<Contents>(() => new Contents(), mode)` C# ' ta veya Visual Basic içinde parametresiz oluşturucuyu çağırabilir `New Lazy(Of Contents)(Function() New Contents())` .</span><span class="sxs-lookup"><span data-stu-id="33d73-182">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="33d73-183"><xref:System.Lazy%601?displayProperty=nameWithType>Bir başlatma yöntemi belirtmeyen bir Oluşturucu kullanırsanız, için parametresiz Oluşturucu tarafından oluşturulan özel durumlar `T` önbelleğe alınmaz.</span><span class="sxs-lookup"><span data-stu-id="33d73-183">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="33d73-184">Daha fazla bilgi için bkz <xref:System.Threading.LazyThreadSafetyMode> . sabit listesi.</span><span class="sxs-lookup"><span data-stu-id="33d73-184">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="33d73-185">Oluşturucu parametresi olarak ayarlanmış bir <xref:System.Lazy%601> nesne `isThreadSafe` `false` veya `mode` olarak ayarlanmış Oluşturucu parametresi oluşturursanız <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> , <xref:System.Lazy%601> nesneye tek bir iş parçacığından erişmeniz veya kendi eşitlemesini sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="33d73-185">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="33d73-186">Bu, özel durum önbelleğe alma da dahil olmak üzere nesnenin tüm yönleri için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="33d73-186">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="33d73-187">Önceki bölümde belirtildiği gibi, <xref:System.Lazy%601> <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> özel durumları farklı değerlendir belirterek oluşturulan nesneler.</span><span class="sxs-lookup"><span data-stu-id="33d73-187">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="33d73-188">İle <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> , birden çok iş parçacığı örneği başlatmak için rekabet edebilir <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="33d73-188">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="33d73-189">Bu durumda, özel durumlar önbelleğe alınmaz ve <xref:System.Lazy%601.Value%2A> başlatma başarılı olana kadar özelliğe erişim girişimleri devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-189">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="33d73-190">Aşağıdaki tabloda, <xref:System.Lazy%601> oluşturucuların özel durum önbelleğe alma yöntemi özetlenmektedir.</span><span class="sxs-lookup"><span data-stu-id="33d73-190">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="33d73-191">Oluşturucu</span><span class="sxs-lookup"><span data-stu-id="33d73-191">Constructor</span></span>|<span data-ttu-id="33d73-192">İş parçacığı güvenlik modu</span><span class="sxs-lookup"><span data-stu-id="33d73-192">Thread safety mode</span></span>|<span data-ttu-id="33d73-193">Başlatma yöntemini kullanır</span><span class="sxs-lookup"><span data-stu-id="33d73-193">Uses initialization method</span></span>|<span data-ttu-id="33d73-194">Özel durumlar önbelleğe alındı</span><span class="sxs-lookup"><span data-stu-id="33d73-194">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="33d73-195">Geç (T) ()</span><span class="sxs-lookup"><span data-stu-id="33d73-195">Lazy(T)()</span></span>|<span data-ttu-id="33d73-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="33d73-196">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="33d73-197">Hayır</span><span class="sxs-lookup"><span data-stu-id="33d73-197">No</span></span>|<span data-ttu-id="33d73-198">Hayır</span><span class="sxs-lookup"><span data-stu-id="33d73-198">No</span></span>|  
|<span data-ttu-id="33d73-199">Geç (T) (Func (T))</span><span class="sxs-lookup"><span data-stu-id="33d73-199">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="33d73-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="33d73-200">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="33d73-201">Yes</span><span class="sxs-lookup"><span data-stu-id="33d73-201">Yes</span></span>|<span data-ttu-id="33d73-202">Yes</span><span class="sxs-lookup"><span data-stu-id="33d73-202">Yes</span></span>|  
|<span data-ttu-id="33d73-203">Geç (T) (Boole)</span><span class="sxs-lookup"><span data-stu-id="33d73-203">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="33d73-204">`True`( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication> ) veya `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="33d73-204">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="33d73-205">Hayır</span><span class="sxs-lookup"><span data-stu-id="33d73-205">No</span></span>|<span data-ttu-id="33d73-206">Hayır</span><span class="sxs-lookup"><span data-stu-id="33d73-206">No</span></span>|  
|<span data-ttu-id="33d73-207">Geç (T) (Func (T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="33d73-207">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="33d73-208">`True`( <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication> ) veya `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="33d73-208">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="33d73-209">Yes</span><span class="sxs-lookup"><span data-stu-id="33d73-209">Yes</span></span>|<span data-ttu-id="33d73-210">Yes</span><span class="sxs-lookup"><span data-stu-id="33d73-210">Yes</span></span>|  
|<span data-ttu-id="33d73-211">Geç (T) (LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="33d73-211">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="33d73-212">Kullanıcı tarafından belirtilen</span><span class="sxs-lookup"><span data-stu-id="33d73-212">User-specified</span></span>|<span data-ttu-id="33d73-213">Hayır</span><span class="sxs-lookup"><span data-stu-id="33d73-213">No</span></span>|<span data-ttu-id="33d73-214">Hayır</span><span class="sxs-lookup"><span data-stu-id="33d73-214">No</span></span>|  
|<span data-ttu-id="33d73-215">Geç (T) (Func (T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="33d73-215">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="33d73-216">Kullanıcı tarafından belirtilen</span><span class="sxs-lookup"><span data-stu-id="33d73-216">User-specified</span></span>|<span data-ttu-id="33d73-217">Yes</span><span class="sxs-lookup"><span data-stu-id="33d73-217">Yes</span></span>|<span data-ttu-id="33d73-218">Kullanıcı belirttiğinde Hayır <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly> ; Aksi takdirde, evet.</span><span class="sxs-lookup"><span data-stu-id="33d73-218">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="33d73-219">Geç başlatılmış bir özellik uygulama</span><span class="sxs-lookup"><span data-stu-id="33d73-219">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="33d73-220">Yavaş başlatma kullanarak ortak bir özellik uygulamak için, özelliğinin yedekleme alanını bir olarak tanımlayın <xref:System.Lazy%601> ve özelliği <xref:System.Lazy%601.Value%2A> `get` özelliğin erişimcisinde döndürün.</span><span class="sxs-lookup"><span data-stu-id="33d73-220">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="33d73-221"><xref:System.Lazy%601.Value%2A>Özelliği salt okunurdur; bu nedenle, onu ortaya çıkaran özelliğin `set` erişimcisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="33d73-221">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="33d73-222">Bir nesne tarafından desteklenen bir okuma/yazma özelliğine ihtiyacınız varsa <xref:System.Lazy%601> , `set` erişimci yeni bir <xref:System.Lazy%601> nesne oluşturmalı ve bunu yedekleme deposuna atamalıdır.</span><span class="sxs-lookup"><span data-stu-id="33d73-222">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="33d73-223">`set`Erişimci, erişimciye geçirilen yeni özellik değerini döndüren bir lambda ifadesi oluşturmalı `set` ve bu lambda ifadesini yeni nesnenin oluşturucusuna geçitirsiniz <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="33d73-223">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="33d73-224">Özelliğin sonraki erişimi, <xref:System.Lazy%601.Value%2A> Yeni ' nin başlatılmasına neden olur <xref:System.Lazy%601> ve <xref:System.Lazy%601.Value%2A> özelliği daha sonra özelliğe atanan yeni değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="33d73-224">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="33d73-225">Bu, bu düzenlemenin nedeni, yerleşik olarak bulunan çok iş parçacıklı korumaların korunmasının nedenidir <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="33d73-225">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="33d73-226">Aksi halde, özellik erişimcileri, özelliği tarafından döndürülen ilk değeri önbelleğe almak <xref:System.Lazy%601.Value%2A> ve yalnızca önbelleğe alınmış değeri değiştirmek ve bunu yapmak için kendi iş parçacığı güvenli kodunuzu yazmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="33d73-226">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="33d73-227">Bir nesne tarafından desteklenen bir okuma/yazma özelliği için gereken ek başlatmalar nedeniyle <xref:System.Lazy%601> , performans kabul edilebilir olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-227">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="33d73-228">Ayrıca, belirli senaryoya bağlı olarak, ayarlayıcılar ve alıcılar arasında yarış durumlarının önüne geçmek için ek koordinasyon gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-228">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="33d73-229">İş parçacığı yerel yavaş başlatma</span><span class="sxs-lookup"><span data-stu-id="33d73-229">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="33d73-230">Bazı çok iş parçacıklı senaryolarda, her iş parçacığına kendi özel verilerini vermek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-230">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="33d73-231">Bu tür veriler, *iş parçacığı yerel verileri*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="33d73-231">Such data is called *thread-local data*.</span></span> <span data-ttu-id="33d73-232">.NET Framework sürüm 3,5 ve önceki sürümlerde, `ThreadStatic` özniteliği bir statik değişkene uygulayabilir ve bunu iş parçacığı yerel hale getirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-232">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="33d73-233">Ancak, özniteliğini kullanmak, `ThreadStatic` hafif hatalara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-233">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="33d73-234">Örneğin, temel başlatma deyimleri bile, aşağıdaki örnekte gösterildiği gibi, değişkenin yalnızca ona erişen ilk iş parçacığında başlatılmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="33d73-234">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="33d73-235">Diğer tüm iş parçacıklarında, değişken varsayılan değeri (sıfır) kullanılarak başlatılır.</span><span class="sxs-lookup"><span data-stu-id="33d73-235">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="33d73-236">.NET Framework sürüm 4 ' te bir alternatif olarak, <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> sağladığınız temsilci tarafından tüm iş parçacıklarında başlatılan örnek tabanlı, iş parçacığı yerel bir değişken oluşturmak için türünü de kullanabilirsiniz <xref:System.Action%601> .</span><span class="sxs-lookup"><span data-stu-id="33d73-236">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="33d73-237">Aşağıdaki örnekte, erişen tüm iş parçacıkları `counter` başlangıç değerini 1 olarak görür.</span><span class="sxs-lookup"><span data-stu-id="33d73-237">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="33d73-238"><xref:System.Threading.ThreadLocal%601>nesnesini <xref:System.Lazy%601> , bu temel farklılıklarla çok benzer şekilde sarmalar:</span><span class="sxs-lookup"><span data-stu-id="33d73-238"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="33d73-239">Her iş parçacığı, iş parçacığı yerel değişkenini diğer iş parçacıklarından erişilemeyen kendi özel verilerini kullanarak başlatır.</span><span class="sxs-lookup"><span data-stu-id="33d73-239">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="33d73-240"><xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType>Özellik okuma-yazma ' dır ve herhangi bir sayıda değişiklik yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-240">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="33d73-241">Bu, özel durum yaymayı etkileyebilir, örneğin, bir `get` işlem özel durum oluşturabilir, ancak bir sonraki değer değeri başarıyla başlatabilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-241">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="33d73-242">Başlatma temsilcisi sağlanmazsa, <xref:System.Threading.ThreadLocal%601> türün varsayılan değerini kullanarak sarmalanmış türünü başlatır.</span><span class="sxs-lookup"><span data-stu-id="33d73-242">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="33d73-243">Bu şekilde, <xref:System.Threading.ThreadLocal%601> <xref:System.ThreadStaticAttribute> özniteliğiyle tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="33d73-243">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="33d73-244">Aşağıdaki örnek, örneğine erişen her iş parçacığının, `ThreadLocal<int>` verilerin kendine ait benzersiz bir kopyasını aldığı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33d73-244">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="33d73-245">Parallel. for ve ForEach olarak iş parçacığı yerel değişkenleri</span><span class="sxs-lookup"><span data-stu-id="33d73-245">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="33d73-246"><xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> Veri kaynaklarını paralel olarak yinelemek için yöntemini veya yöntemini kullandığınızda, iş parçacığı yerel verileri için yerleşik desteğe sahip olan aşırı yüklemeleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-246">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="33d73-247">Bu yöntemlerde, iş parçacığı konum oluşturma, verileri oluşturmak, erişmek ve temizlemek için yerel temsilciler kullanılarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="33d73-247">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="33d73-248">Daha fazla bilgi için bkz. [nasıl yapılır: Iş parçacığı yerel değişkenleriyle paralel. for döngüsü yazma](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) ve [nasıl yapılır: Bölüm Yerel Değişkenleriyle bir Parallel. foreach döngüsü yazma](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="33d73-248">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="33d73-249">Düşük iş yükü senaryolar için yavaş başlatma kullanma</span><span class="sxs-lookup"><span data-stu-id="33d73-249">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="33d73-250">Çok sayıda nesneyi yavaş başlatmak zorunda olduğunuz senaryolarda, bir içindeki her bir nesnenin <xref:System.Lazy%601> çok fazla bellek veya çok fazla bilgi işlem kaynağı gerektirip gerektirdiğine karar verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-250">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="33d73-251">Ya da, yavaş başlatmanın nasıl açığa çıkmasıyla ilgili sıkı gereksinimlere sahip olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33d73-251">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="33d73-252">Bu gibi durumlarda, `static` `Shared` <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> sınıfının bir örneğine sarmalamadan her bir nesneyi geç başlatmak için sınıfının (Visual Basic) yöntemlerini kullanabilirsiniz <xref:System.Lazy%601> .</span><span class="sxs-lookup"><span data-stu-id="33d73-252">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="33d73-253">Aşağıdaki örnekte, tek bir nesnede bir nesnenin tamamını sarmalama yerine `Orders` <xref:System.Lazy%601> `Order` yalnızca gerekli olmaları durumunda ayrı ayrı başlatılan nesneler olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="33d73-253">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="33d73-254">Bu örnekte, başlatma yordamının döngünün her tekrarında çağrıldığına dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="33d73-254">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="33d73-255">Çok iş parçacıklı senaryolarda, başlatma yordamını çağırmak için ilk iş parçacığı değeri tüm iş parçacıkları tarafından görülen bir alandır.</span><span class="sxs-lookup"><span data-stu-id="33d73-255">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="33d73-256">Sonraki iş parçacıkları da başlatma yordamını çağırır, ancak sonuçları kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="33d73-256">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="33d73-257">Bu tür bir olası yarış durumu kabul edilemez ise, ' nin <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> bir Boole bağımsız değişkeni ve bir eşitleme nesnesi alan aşırı yüklemesini kullanın.</span><span class="sxs-lookup"><span data-stu-id="33d73-257">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="33d73-258">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="33d73-258">See also</span></span>

- [<span data-ttu-id="33d73-259">Yönetilen İş Parçacığı Oluşturma Temelleri</span><span class="sxs-lookup"><span data-stu-id="33d73-259">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="33d73-260">İş Parçacıkları ve İş Parçacığı Oluşturma</span><span class="sxs-lookup"><span data-stu-id="33d73-260">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="33d73-261">Görev Paralel Kitaplığı (TPL)</span><span class="sxs-lookup"><span data-stu-id="33d73-261">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="33d73-262">Nasıl yapılır: Nesnelerin Yavaş Başlatılmasını Gerçekleştirme</span><span class="sxs-lookup"><span data-stu-id="33d73-262">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
