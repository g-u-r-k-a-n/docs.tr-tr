---
title: Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400171"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="2df9f-102">Gönderilmiş Olayları İşlenmiş Olarak İşaretleme ve Sınıf İşlemesi</span><span class="sxs-lookup"><span data-stu-id="2df9f-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="2df9f-103">Yönlendirilen bir olayın işleyicileri olay verileri içinde işlenen olayı işaretleyebilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="2df9f-104">Olayı işlemek rotayı etkili bir şekilde kısaltır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="2df9f-105">Sınıf işleme, yönlendirilen olaylar tarafından desteklenen bir programlama kavramıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="2df9f-106">Bir sınıf işleyicisi, sınıfın herhangi bir örneğinde herhangi bir örnek işleyiciönce çağrılan bir işleyici ile bir sınıf düzeyinde belirli bir yönlendirilmiş olay işlemek için fırsat vardır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="2df9f-107">Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="2df9f-107">Prerequisites</span></span>  
 <span data-ttu-id="2df9f-108">Bu [konu, Yönlendirilen Olaylara Genel Bakış'ta](routed-events-overview.md)tanıtılan kavramlar üzerinde ayrıntılı bilgi vermektedir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="2df9f-109">Olaylar İşlenirken Ne Zaman İşaretlenir?</span><span class="sxs-lookup"><span data-stu-id="2df9f-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="2df9f-110">Yönlendirilen bir olay <xref:System.Windows.RoutedEventArgs.Handled%2A> için `true` olay verilerinde özelliğin değerini ayarladığınızda, buna "işlenen olayı işaretleme" adı verilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="2df9f-111">Yönlendirilen olayları bir uygulama yazarı olarak veya varolan yönlendirilmiş olaylara yanıt veren veya yeni yönlendirilmiş olayları uygulayan bir denetim yazarı olarak, işlenmiş olarak işaretlemeniz gerektiğinde mutlak bir kural yoktur.</span><span class="sxs-lookup"><span data-stu-id="2df9f-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="2df9f-112">Çoğunlukla, yönlendirilen etkinliğin olay verilerinde taşınan "ele alma" kavramı, kendi uygulamanızın API'lerde [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] maruz kalan çeşitli yönlendirilmiş olaylara verdiği yanıtlar ve özel yönlendirilmiş olaylar için sınırlı bir protokol olarak kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="2df9f-113">"İşlenen" sorunu değerlendirmenin başka bir yolu da, kodunuz yönlendirilmiş olaya önemli ve nispeten tam bir şekilde yanıt verdiyse, genellikle işlenen yönlendirilmiş bir olayı işaretlemeniz gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="2df9f-114">Genellikle, tek bir yönlendirilmiş olay oluşumu için ayrı işleyici uygulamaları gerektiren birden fazla önemli yanıt olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="2df9f-115">Daha fazla yanıt gerekiyorsa, gerekli kod, yönlendirme için yönlendirilen olay sistemini kullanmak yerine tek bir işleyici içinde zincirlenmiş uygulama mantığı aracılığıyla uygulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="2df9f-116">"Önemli" olan kavram da özneldir ve uygulamanıza veya kodunuza bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="2df9f-117">Genel kılavuz olarak, bazı "önemli yanıt" örnekleri şunlardır: odak ayarlama, genel durumu değiştirme, görsel gösterimi etkileyen özellikleri ayarlama ve diğer yeni olayları yükseltmek.</span><span class="sxs-lookup"><span data-stu-id="2df9f-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="2df9f-118">Önemsiz yanıtlara örnek olarak şunlar verilebilir: özel durumu (görsel etkisi olmadan veya programlı gösterim olmadan) değiştirmek, olayların günlüğe kaydedilmesi veya bir olayın bağımsız değişkenlerine bakma ve buna yanıt vermemeyi seçme.</span><span class="sxs-lookup"><span data-stu-id="2df9f-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="2df9f-119">Yönlendirilmiş olay sistemi davranışı, olay verilerinin zaten işlendiği yönlendirilmiş bir olaya yanıt olarak [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] eklenen işleyiciler <xref:System.Windows.UIElement.AddHandler%2A> veya ortak imza çağrıldığı için, yönlendirilmiş bir olayın işlenmiş durumunu kullanmak için bu "önemli yanıt" modelini güçlendirir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="2df9f-120">Olay rotasında önceki katılımcılar tarafından işlenen yönlendirilmiş olayları işlemek için `handledEventsToo` parametre sürümü ()<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>ile bir işleyici ekleme ekstra çaba geçmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="2df9f-121">Bazı durumlarda, denetimler kendilerini işlenir gibi belirli yönlendirilmiş olayları işaretler.</span><span class="sxs-lookup"><span data-stu-id="2df9f-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="2df9f-122">İşlenmiş bir yönlendirilmiş olay, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] denetim yazarlarının, denetimin yönlendirilen olaya yanıt olarak eylemlerinin denetim uygulamasının bir parçası olarak önemli veya eksiksiz olduğu ve olayın başka işleme gerek olmadığı yönündeki kararını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="2df9f-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="2df9f-123">Genellikle bu, bir olay için bir sınıf işleyicisi ekleyerek veya bir taban sınıf üzerinde var olan sınıf işleyicisanallarından birini geçersiz kılarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="2df9f-124">Gerekirse bu olay işleme etrafında çalışmaya devam edebilirsiniz; Daha sonra bu konunun ilerleyen saatlerinde [Denetimler tarafından Olay Bastırma Etrafında Çalışma](#WorkingAroundEventSuppressionByControls) konusuna bakın.</span><span class="sxs-lookup"><span data-stu-id="2df9f-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="2df9f-125">"Önizleme" (Tünelleme) Olaylar vs Bubbling Olaylar ve Olay Taşıma</span><span class="sxs-lookup"><span data-stu-id="2df9f-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="2df9f-126">Önizleme yönlendirilmiş olaylar, öğe ağacı nın içinden geçen bir tünel izleme yolunu izleyen olaylardır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="2df9f-127">Adlandırma kuralında ifade edilen "Önizleme", önizleme (tünel) yönlendirilen olayları önizlemenin (tünel) yönlendirilen olayların eşdeğer köpüren yönlendirilmiş olaydan önce yükseltildiği giriş olayları için genel ilkenin göstergesidir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="2df9f-128">Ayrıca, bir tünel ve köpüren çifti olan giriş yönlendirilmiş olaylar ayrı bir işleme mantığı var.</span><span class="sxs-lookup"><span data-stu-id="2df9f-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="2df9f-129">Tünelleme/önizleme yönlendirilmiş olay bir olay dinleyicisi tarafından işlenir olarak işaretlenirse, köpüren yönlendirilmiş olay, köpüren yönlendirilmiş olayın dinleyicileri onu almadan önce bile işaretlenir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="2df9f-130">Tünel ve köpüren yönlendirilen olaylar teknik olarak ayrı olaylardır, ancak bu davranışı etkinleştirmek için olay verilerinin aynı örneğini kasıtlı olarak paylaşırlar.</span><span class="sxs-lookup"><span data-stu-id="2df9f-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="2df9f-131">Tünel leme ve yönlendirilen olayları köpürten olaylar arasındaki bağlantı, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] belirli bir sınıfın kendi bildirilen yönlendirilmiş olaylarını nasıl yükselttiğinin iç uygulamasıyla gerçekleştirilir ve bu, eşleştirilmiş giriş yönlendirilmiş olaylar için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="2df9f-132">Ancak bu sınıf düzeyinde uygulama yoksa, bir tünel yönlendirilmiş olay ile adlandırma düzenini paylaşan köpüren yönlendirilmiş olay arasında bir bağlantı yoktur: böyle bir uygulama olmadan tamamen ayrı iki yönlendirilmiş olay olur ve sırayla yükseltilir veya olay verilerini paylaşır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="2df9f-133">Özel bir sınıfta tünel/kabarcık giriş yönlendirilmiş olay çiftleri nasıl uygulanacağı hakkında daha fazla bilgi için [bkz.](how-to-create-a-custom-routed-event.md)</span><span class="sxs-lookup"><span data-stu-id="2df9f-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="2df9f-134">Sınıf İşleyicileri ve Örnek İşleyiciler</span><span class="sxs-lookup"><span data-stu-id="2df9f-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="2df9f-135">Yönlendirilen olaylar, etkinliğe iki farklı dinleyici türünü göz önünde bulundur: sınıf dinleyicileri ve örnek dinleyiciler.</span><span class="sxs-lookup"><span data-stu-id="2df9f-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="2df9f-136">Sınıf dinleyicileri vardır, çünkü <xref:System.Windows.EventManager> türler statik<xref:System.Windows.EventManager.RegisterClassHandler%2A>oluşturucularında belirli bir API'yi çağırmış veya bir öğe taban sınıfından sınıf işleyicisi sanal yöntemi geçersiz kalmıştır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="2df9f-137">Örnek dinleyiciler, bu yönlendirilen olay için bir veya daha fazla işleyicinin bir <xref:System.Windows.UIElement.AddHandler%2A>çağrı yla eklendiği belirli sınıf örnekleri/öğeleridir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="2df9f-138">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Varolan yönlendirilmiş olaylar, ortak dil çalışma zamanı (CLR) olay sarıcının bir parçası <xref:System.Windows.UIElement.AddHandler%2A> olarak çağrılar yapar ve olayın uygulamalarını ekler{} ve kaldırır,{} bu da olay işleyicilerini bir öznitelik sözdizimi aracılığıyla bağlama nın basit [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mekanizmasının nasıl etkinleştirildiğidir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="2df9f-139">Bu nedenle [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] bile basit kullanım sonuçta <xref:System.Windows.UIElement.AddHandler%2A> bir çağrı eşittir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="2df9f-140">Görsel ağaç içindeki öğeler kayıtlı işleyici uygulamaları için denetlenir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="2df9f-141">İşleyiciler, yönlendirilen olay için yönlendirme stratejisinin türünde doğal olan sırada, rota boyunca çağrılır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="2df9f-142">Örneğin, köpüren yönlendirilmiş olaylar ilk olarak yönlendirilen olayı yükselten aynı öğeye bağlı işleyicileri çağırır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="2df9f-143">Daha sonra yönlendirilen olay "kabarcıklar" sonraki üst öğeye ve benzeri uygulama kök öğesi erişilene kadar.</span><span class="sxs-lookup"><span data-stu-id="2df9f-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="2df9f-144">Köpüren bir rotadaki kök öğeperspektifinden, sınıf işleme veya yönlendirilen olayın kaynağına daha yakın herhangi bir öğe, olay bağımsız değişkenlerini işlenen olarak işaretleyen işleyicileri çağırırsa, kök öğelerdeki işleyiciler çağrılmaz ve olay rotası bu kök öğeye ulaşmadan önce etkili bir şekilde kısaltılır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="2df9f-145">Ancak, bir sınıf işleyicisi veya örnek işleyicisi yönlendirilen olayı işlenmiş olarak işaretlemiş olsa bile, işleyiciler yine de çağrılması gereken özel bir koşullu kullanılarak eklenebileceğinden, rota tamamen durdurulamaz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="2df9f-146">Bu, [olaylar işlenirken bile yükseltilen Örnek İşleyiciler Ekleme'de](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled)açıklanır , daha sonra bu konu.</span><span class="sxs-lookup"><span data-stu-id="2df9f-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="2df9f-147">Olay rotasından daha derin bir düzeyde, bir sınıfın belirli bir örneğinde etkili olabilecek birden çok sınıf işleyicileri de vardır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="2df9f-148">Bunun nedeni, yönlendirilen olaylar için sınıf işleme modelinin, her bir yönlendirilmiş olay için her sınıf işleyicisini kaydetmesi için sınıf hiyerarşisindeki tüm olası sınıfların olmasını sağlamasıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="2df9f-149">Her sınıf işleyicisi bir iç depoya eklenir ve bir uygulama için olay rotası oluşturulduğunda, sınıf işleyicilerinin tümü olay rotasına eklenir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="2df9f-150">Sınıf işleyicileri, en çok türetilmiş sınıf işleyicisi ilk çağrılacak şekilde rotaya eklenir ve sonraki her ardışık taban sınıftan sınıf işleyicileri çağrılır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="2df9f-151">Genel olarak, sınıf işleyicileri, zaten işlenmiş olarak işaretlenmiş yönlendirilmiş olaylara da yanıt verecek şekilde kaydedilmez.</span><span class="sxs-lookup"><span data-stu-id="2df9f-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="2df9f-152">Bu nedenle, bu sınıf işleme mekanizması iki seçenekbirini sağlar:</span><span class="sxs-lookup"><span data-stu-id="2df9f-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="2df9f-153">Türemiş sınıflar, alınan işlem olayını işaretlemeyen bir işleyici ekleyerek taban sınıftan devralınan sınıf işlemeyi tamamlayabilir, çünkü taban sınıf işleyicisi türemiş sınıf işleyicisinden sonra çağrılacaktır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="2df9f-154">Türemiş sınıflar, işlenen yönlendirilmiş olayı işaretleyen bir sınıf işleyicisi ekleyerek taban sınıftan sınıf işlemeyerini alabilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="2df9f-155">Görsel görünüm, durum mantığı, giriş işleme ve komut işleme gibi alanlarda amaçlanan temel denetim tasarımını değiştirebileceğinden, bu yaklaşıma karşı dikkatli olmalısınız.</span><span class="sxs-lookup"><span data-stu-id="2df9f-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="2df9f-156">Yönlendirilen Olayların Kontrol Taban Sınıfları tarafından Sınıf Yönetimi</span><span class="sxs-lookup"><span data-stu-id="2df9f-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="2df9f-157">Bir olay rotasında verilen her öğe düğümünde, sınıf dinleyicileri öğedeki herhangi bir örnek dinleyiciden önce yönlendirilen olaya yanıt verme fırsatına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="2df9f-158">Bu nedenle, sınıf işleyicileri bazen belirli bir denetim sınıfı uygulaması nın daha fazla yaymak istemediği yönlendirilmiş olayları bastırmak veya sınıfın bir özelliği olan bu yönlendirilmiş olayın özel kullanımını sağlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="2df9f-159">Örneğin, bir sınıf, belirli bir sınıfın bağlamında bazı kullanıcı giriş koşulunun ne anlama geldiğini hakkında daha fazla ayrıntı içeren kendi sınıfa özgü olayı yükseltebilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="2df9f-160">Sınıf uygulaması daha sonra daha genel yönlendirilmiş olayı işlenmiş olarak işaretleyebilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="2df9f-161">Sınıf işleyicileri genellikle paylaşılan olay verilerinin zaten işlendiği yönlendirilmiş olaylar için çağrılmadıkları şekilde eklenir, ancak <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> atipik durumlarda, yönlendirilen olaylar işleildiğinde bile sınıf işleyicilerini çağırmak üzere kaydeden bir imza da vardır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="2df9f-162">Sınıf Işleyici Sanalları</span><span class="sxs-lookup"><span data-stu-id="2df9f-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="2df9f-163">Bazı öğeler, özellikle temel öğeler, <xref:System.Windows.UIElement>boş "On\*Event" ve\*"OnPreview Event" gibi ortak yönlendirilmiş olaylar listesine karşılık gelen sanal yöntemleri ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="2df9f-164">Bu sanal yöntemler, bu yönlendirilen olay için bir sınıf işleyicisi uygulamak için geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="2df9f-165">Temel öğe sınıfları, daha önce açıklandığı gibi kullanarak <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> bu tür yönlendirilen her olay için bu sanal yöntemleri sınıf işleyicisi olarak kaydeder.</span><span class="sxs-lookup"><span data-stu-id="2df9f-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="2df9f-166">On\*Event sanal yöntemleri, her tür için statik oluşturucularda özel başlatma gerektirmeden, ilgili yönlendirilen olaylar için sınıf işlemeyi uygulamayı çok daha kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="2df9f-167">Örneğin, <xref:System.Windows.UIElement.OnDragEnter%2A> sanal yöntemi geçersiz kılarak, <xref:System.Windows.UIElement> türetilen herhangi bir <xref:System.Windows.UIElement.DragEnter> sınıftaolay için sınıf işleme ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="2df9f-168">Geçersiz kılma içinde, yönlendirilen olayı işleyebilir, diğer olayları yükseltebilir, örneklerdeki öğe özelliklerini veya bu eylemlerin herhangi bir birleşimini değiştirebilecek sınıfa özgü mantık başlatabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="2df9f-169">İşlenen olayı işaretleseniz bile genellikle bu tür geçersiz kılmalarda temel uygulamayı çağırmalısınız.</span><span class="sxs-lookup"><span data-stu-id="2df9f-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="2df9f-170">Sanal yöntem taban sınıfta olduğundan, temel uygulamayı çağırmanın güçlü bir şekilde önerilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="2df9f-171">Her sanal dan temel uygulamaları çağıran standart korumalı sanal desen aslında değiştirir ve bir sınıf hiyerarşisi tüm sınıflar için sınıf işleyicileri, yönlendirilmiş olay sınıfı işleme yerli benzer bir mekanizma en türetilmiş sınıfın işleyicisi ile başlayan ve taban sınıf işleyicisi devam eden, herhangi bir örnek çağırdı.</span><span class="sxs-lookup"><span data-stu-id="2df9f-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="2df9f-172">Yalnızca sınıfınızın taban sınıf işleme mantığını değiştirmek için kasıtlı bir gereksinimi varsa temel uygulama çağrısını atlamalısınız.</span><span class="sxs-lookup"><span data-stu-id="2df9f-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="2df9f-173">Geçersiz kılma kodunuzdan önce veya sonra temel uygulamayı arayıp aramadığınız, uygulamanızın niteliğine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="2df9f-174">Giriş Olay Sınıf Taşıma</span><span class="sxs-lookup"><span data-stu-id="2df9f-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="2df9f-175">Sınıf işleyicisanal yöntemlerinin tümü, yalnızca paylaşılan olay verilerinin zaten işlenmemiş olduğu durumlarda çağrılacak şekilde kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="2df9f-176">Ayrıca, benzersiz giriş olayları için, tünel ve köpüren sürümleri genellikle sırayla yükseltilir ve olay verilerini paylaşır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="2df9f-177">Bu, biri tünel sürümü ve diğer köpüren sürümü olan giriş olayları sınıf işleyicileri belirli bir çift için, hemen ele olay işaretlemek istemeyebilirsiniz gerektirir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="2df9f-178">İşlenen olayı işaretlemek için tünel sınıfı işleme sanal yöntemini uygularsanız, bu köpüren sınıf işleyicisinin çağrılmasını önler (tünel leme veya köpürme olayı için normal olarak kayıtlı örnek işleyicileri önleme çağrılmaktadır).</span><span class="sxs-lookup"><span data-stu-id="2df9f-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="2df9f-179">Bir düğüm üzerinde sınıf işleme tamamlandıktan sonra, örnek dinleyiciler kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="2df9f-180">Olaylar İşaretlendiğinde Bile Yükseltilen Örnek İşleyiciler Ekleme</span><span class="sxs-lookup"><span data-stu-id="2df9f-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="2df9f-181">Yöntem, <xref:System.Windows.UIElement.AddHandler%2A> bir olay rotadaki işleme öğesine ulaştığında olay sistemi tarafından çağrılacak işleyiciler eklemenize olanak tanıyan belirli bir aşırı yük sağlar, ancak başka bir işleyici olay verilerini bu olayı işlenmiş olarak işaretlemek için zaten ayarlamış olsa bile.</span><span class="sxs-lookup"><span data-stu-id="2df9f-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="2df9f-182">Bu genellikle yapılmaz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-182">This is not typically done.</span></span> <span data-ttu-id="2df9f-183">Genellikle, işleyiciler, birden çok son sonuç istense bile, bir öğenin bir öğede nerede işlendiğine bakılmaksızın, uygulama kodunun bir olaydan etkilenebilecek tüm alanlarını ayarlamak için yazılabilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="2df9f-184">Ayrıca, genellikle bu olaya yanıt vermesi gereken tek bir öğe vardır ve uygun uygulama mantığı zaten gerçekleşmişti.</span><span class="sxs-lookup"><span data-stu-id="2df9f-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="2df9f-185">Ancak `handledEventsToo` aşırı yük, bir öğe ağacındaki veya denetim birleştirme deki diğer bazı öğelerin zaten işlenmiş bir olayı işaretlediği istisnai durumlar için kullanılabilir, ancak öğe ağacındaki diğer öğeler (rotaya bağlı olarak) hala kendi işleyicilerinin çağrılmasını ister.</span><span class="sxs-lookup"><span data-stu-id="2df9f-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="2df9f-186">İşlenmemiş Olarak İşlenme Olayları Ne Zaman İşaretlenir?</span><span class="sxs-lookup"><span data-stu-id="2df9f-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="2df9f-187">Genellikle, işlenen işaretli olaylar, üzerinde<xref:System.Windows.RoutedEventArgs.Handled%2A> `false` `handledEventsToo`hareket eden işleyiciler tarafından bile işlenmemiş (geri ayarlanmış) işaretlenmemelidir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="2df9f-188">Ancak, bazı giriş olayları, üst düzey olay ağaçta bir konumda ve başka bir konumda düşük düzey olay görüldüğünde çakışabilir üst düzey ve alt düzey olay gösterimleri vardır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="2df9f-189">Örneğin, bir alt öğenin üst öğe gibi <xref:System.Windows.UIElement.TextInput> <xref:System.Windows.UIElement.KeyDown>düşük düzeyli bir olayı dinlerken üst düzey bir önemli olayı dinlediği durumu göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="2df9f-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="2df9f-190">Üst öğe alt düzey olayı işlerse, üst düzey olay, olayı işlemek için sezgisel olarak ilk fırsatolması gereken alt öğede bile bastırılabilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="2df9f-191">Bu gibi durumlarda, alt düzey olay için hem üst öğelere hem de alt öğelere işleyiciler eklemek gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="2df9f-192">Alt öğe işleyicisi uygulaması, alt düzey olayı işlenmiş olarak işaretleyebilir, ancak üst öğe işleyicisi uygulaması, ağacın diğer öğeleri (yanı sıra üst düzey olay) yanıt verme fırsatı olabilir, böylece yeniden işlenmemiş ayarlar.</span><span class="sxs-lookup"><span data-stu-id="2df9f-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="2df9f-193">Bu durum oldukça nadir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="2df9f-194">Kontrol Birleştirme Için Giriş Olaylarını Kasıtlı Olarak Bastırma</span><span class="sxs-lookup"><span data-stu-id="2df9f-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="2df9f-195">Yönlendirilen olayların sınıf işlemesinin kullanıldığı ana senaryo, giriş olayları ve birleştirilmiş denetimler içindir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="2df9f-196">Bileşik denetim, tanım gereği birden çok pratik denetim veya denetim taban sınıflarından oluşur.</span><span class="sxs-lookup"><span data-stu-id="2df9f-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="2df9f-197">Denetimin yazarı genellikle, tüm denetimi tekil olay kaynağı olarak bildirmek için alt bileşenlerin her birinin yükseltebileceği olası giriş olaylarının tümünün biraraya getirmesini ister.</span><span class="sxs-lookup"><span data-stu-id="2df9f-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="2df9f-198">Bazı durumlarda denetim yazarı olayları bileşenlerden tamamen bastırmak veya daha fazla bilgi taşıyan veya daha belirli bir davranışı ima eden bileşen tanımlı bir olayın yerine geçebilecek.</span><span class="sxs-lookup"><span data-stu-id="2df9f-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="2df9f-199">Herhangi bir bileşen yazar tarafından hemen görülebilen [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> kanonik örnek, bir fare olayını nasıl işlediğive sonunda tüm <xref:System.Windows.Controls.Primitives.ButtonBase.Click> düğmelerin sahip olduğu sezgisel olaya nasıl çözüm verdiğidir: bir olay.</span><span class="sxs-lookup"><span data-stu-id="2df9f-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="2df9f-200">Temel <xref:System.Windows.Controls.Button> sınıf<xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Control> ( ) hangi sırayla türetilmiştir <xref:System.Windows.FrameworkElement> <xref:System.Windows.UIElement>ve , ve çok kontrol girişi işleme için gerekli <xref:System.Windows.UIElement> olay altyapısı düzeyinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="2df9f-201">Özellikle, <xref:System.Windows.UIElement> fare <xref:System.Windows.Input.Mouse> imlecini kendi sınırları içinde işleyen genel olayları işler ve <xref:System.Windows.UIElement.MouseLeftButtonDown>en yaygın düğme eylemleri için farklı olaylar sağlar.</span><span class="sxs-lookup"><span data-stu-id="2df9f-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="2df9f-202"><xref:System.Windows.UIElement>ayrıca, önceden <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> kaydedilmiş sınıf işleyicisi <xref:System.Windows.UIElement.MouseLeftButtonDown>olarak <xref:System.Windows.Controls.Primitives.ButtonBase> boş bir sanal sağlar ve geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="2df9f-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="2df9f-203">Benzer şekilde, <xref:System.Windows.Controls.Primitives.ButtonBase> sınıf işleyicileri kullanır. <xref:System.Windows.UIElement.MouseLeftButtonUp></span><span class="sxs-lookup"><span data-stu-id="2df9f-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="2df9f-204">Olay verilerinden geçirilen geçersiz kılmalarda, uygulamalar bu <xref:System.Windows.RoutedEventArgs> örneği ayarlayarak <xref:System.Windows.RoutedEventArgs.Handled%2A> `true`işlenirken işaretler ve aynı olay verileri, diğer sınıf işleyicilerine ve ayrıca örnek işleyicilerine veya olay ayarlayıcılarına giden rotanın geri kalanı boyunca devam eden şeydir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="2df9f-205">Ayrıca, <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> geçersiz kılma sonraki <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı yükseltecektir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="2df9f-206">Çoğu dinleyici için sonuç, <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> olayların "kaybolması" ve bunun <xref:System.Windows.Controls.Primitives.ButtonBase.Click>yerine, bu olayın düğmenin bir kısmı veya tamamen başka bir öğeden değil, gerçek bir düğmeden kaynaklandığı bilindiği için daha fazla anlam ifade eden bir olay la değiştirilecektir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="2df9f-207">Denetimler tarafından Olay Bastırma Etrafında Çalışma</span><span class="sxs-lookup"><span data-stu-id="2df9f-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="2df9f-208">Bazen tek tek denetimler içindeki bu olay bastırma davranışı, uygulamanız için olay işleme mantığının daha genel amaçlarına engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="2df9f-209">Örneğin, uygulamanızın uygulama kök öğesinde <xref:System.Windows.UIElement.MouseLeftButtonDown> bulunan bir işleyicisi nedense, bir düğmeye tıklayan farenin kök düzeyinde çağrıda bulunmayacağını veya <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> işleyicileri çağırmayacağını fark elabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="2df9f-210">Olayın kendisi aslında kabarcık yaptı (yine, olay yolları gerçekten sona ermedi, ancak yönlendirilen olay sistemi işleyici çağırma davranışını değiştirmektedir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="2df9f-211">Yönlendirilen olay düğmeye ulaştığında, <xref:System.Windows.Controls.Primitives.ButtonBase> <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı daha <xref:System.Windows.UIElement.MouseLeftButtonDown> anlamlı bir şekilde değiştirmek istediği için sınıf işleme işlem işlem yerini işaretledi.</span><span class="sxs-lookup"><span data-stu-id="2df9f-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="2df9f-212">Bu nedenle, <xref:System.Windows.UIElement.MouseLeftButtonDown> rotanın daha yukarısı herhangi bir standart işleyici çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="2df9f-213">İşleyicilerinizin bu durumda çağrılmasını sağlamak için kullanabileceğiniz iki teknik vardır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="2df9f-214">İlk teknik, işleyiciyi imzasını `handledEventsToo` kullanarak kasten <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>eklemektir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="2df9f-215">Bu yaklaşımın bir sınırlama bir olay işleyicisi eklemek için bu teknik yalnızca kod değil, biçimlendirme mümkün olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="2df9f-216">Olay işleyicisi adını olay özniteliği değeri üzerinden belirtmenin basit sözdizimi bu davranışı [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] etkinleştirmez.</span><span class="sxs-lookup"><span data-stu-id="2df9f-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="2df9f-217">İkinci teknik yalnızca, yönlendirilen olayın tünel ve köpüren sürümlerinin eşleştiği giriş olayları için çalışır.</span><span class="sxs-lookup"><span data-stu-id="2df9f-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="2df9f-218">Bu yönlendirilen olaylar için, önizleme/tünel eşdeğeri yönlendirilmiş olaya işleyiciler ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="2df9f-219">Bu yönlendirilen olay kökten başlayarak rotadan tünel açacaktır, böylece düğme sınıfı işleme kodu, uygulamanın öğe ağacındaki bazı ata öğesi düzeyinde Önizleme işleyicisini taktığınızı varsayarak onu engellemez.</span><span class="sxs-lookup"><span data-stu-id="2df9f-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="2df9f-220">Bu yaklaşımı kullanırsanız, işlenen herhangi bir Önizleme olayını işaretleme konusunda dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="2df9f-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="2df9f-221">Kök öğede <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> ele alınması ile verilen örnekiçin, olay <xref:System.Windows.RoutedEventArgs.Handled%2A> işleyici uygulamasında olduğu gibi işaretlediyseniz, aslında <xref:System.Windows.Controls.Primitives.ButtonBase.Click> olayı bastırırsınız.</span><span class="sxs-lookup"><span data-stu-id="2df9f-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="2df9f-222">Bu genellikle arzu edilen bir davranış değildir.</span><span class="sxs-lookup"><span data-stu-id="2df9f-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2df9f-223">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="2df9f-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="2df9f-224">Önizleme Olayları</span><span class="sxs-lookup"><span data-stu-id="2df9f-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="2df9f-225">Özel Yönlendirilmiş Olay Oluşturma</span><span class="sxs-lookup"><span data-stu-id="2df9f-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="2df9f-226">Gönderilmiş Olaylara Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="2df9f-226">Routed Events Overview</span></span>](routed-events-overview.md)
