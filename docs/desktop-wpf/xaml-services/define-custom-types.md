---
title: .NET XAML Hizmetlerinde Kullanılacak Özel Türleri Tanımlama
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 2c0578b5397172814c708706173c69ef69f91b2a
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90551784"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="678a8-102">.NET XAML Hizmetleri ile kullanılacak özel türleri tanımlama</span><span class="sxs-lookup"><span data-stu-id="678a8-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="678a8-103">İş nesneleri olan veya belirli çerçevelere bağımlılığı olmayan türler olan özel türler tanımladığınızda, kullanabileceğiniz XAML için bazı en iyi uygulamalar vardır.</span><span class="sxs-lookup"><span data-stu-id="678a8-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="678a8-104">Bu uygulamaları izlerseniz, .NET XAML Hizmetleri ve XAML okuyucuları ve XAML yazarları, bu türden XAML özelliklerini bulabilir ve xaml tür sistemini kullanarak XAML düğüm akışında uygun gösterimi verebilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="678a8-105">Bu konuda tür tanımları, üye tanımları ve tür veya üyelerin CLR Attributing için en iyi yöntemler açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="678a8-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="678a8-106">XAML için Oluşturucu desenleri ve tür tanımları</span><span class="sxs-lookup"><span data-stu-id="678a8-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="678a8-107">XAML 'de bir nesne öğesi olarak örneklendirmak için, özel bir sınıf aşağıdaki gereksinimleri karşılamalıdır:</span><span class="sxs-lookup"><span data-stu-id="678a8-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="678a8-108">Özel sınıf ortak olmalıdır ve parametresiz bir ortak oluşturucuyu kullanıma sunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="678a8-109">(Yapılar hakkında notlar için aşağıdaki bölüme bakın.)</span><span class="sxs-lookup"><span data-stu-id="678a8-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="678a8-110">Özel sınıf iç içe geçmiş bir sınıf olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="678a8-111">Tam ad yolundaki fazladan "nokta", sınıf ad alanı bölümünün belirsizleşmesini sağlar ve ekli özellikler gibi diğer XAML özellikleriyle kesintiye uğratır.</span><span class="sxs-lookup"><span data-stu-id="678a8-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="678a8-112">Bir nesne bir nesne öğesi olarak örneklenebilir, oluşturulan nesne nesneyi temel alınan türü olarak alan özelliklerin özellik öğesi biçimini doldurabilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="678a8-113">Değer dönüştürücüsünü etkinleştirirseniz, bu kriterleri karşılamayan türler için nesne değerleri de sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="678a8-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="678a8-114">Daha fazla bilgi için bkz. [xaml Için tür dönüştürücüleri ve biçimlendirme uzantıları](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="678a8-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="678a8-115">Yapılar</span><span class="sxs-lookup"><span data-stu-id="678a8-115">Structures</span></span>

<span data-ttu-id="678a8-116">Yapılar, CLR tanımına göre her zaman XAML 'de oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="678a8-117">Bunun nedeni, bir CLR derleyicisinin bir yapı için örtük olarak parametresiz bir Oluşturucu oluşturmasıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="678a8-118">Bu Oluşturucu tüm özellik değerlerini varsayılan değerlerine başlatır.</span><span class="sxs-lookup"><span data-stu-id="678a8-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="678a8-119">Bazı durumlarda, bir yapı için varsayılan yapım davranışı istenmez.</span><span class="sxs-lookup"><span data-stu-id="678a8-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="678a8-120">Bunun nedeni, yapının değerleri birleşim olarak kavramsal bir şekilde doldurmasını amaçladığı bir durum olabilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="678a8-121">Birleşim olarak, içerilen değerler birbirini dışlayan yorumlayıcıya sahip olabilir ve bu nedenle, özelliklerinden hiçbiri ayarlanabilir değildir.</span><span class="sxs-lookup"><span data-stu-id="678a8-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="678a8-122">WPF sözlüğbir yapısına örnek olarak <xref:System.Windows.GridLength> .</span><span class="sxs-lookup"><span data-stu-id="678a8-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="678a8-123">Bu tür yapılar, değerlerin öznitelik biçiminde ifade edilmesi için, farklı yorumlamalar veya yapı değerlerinin modlarını oluşturan dize kurallarını kullanarak bir tür dönüştürücüsü uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="678a8-124">Yapı Ayrıca, parametresiz bir Oluşturucu aracılığıyla kod oluşturma için benzer davranışları kullanıma sunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="678a8-125">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="678a8-125">Interfaces</span></span>

<span data-ttu-id="678a8-126">Arabirimler, temel üye türleri olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="678a8-127">XAML tür sistemi atanabilir listeyi denetler ve değer olarak belirtilen nesnenin arabirime atanabileceği bekliyor.</span><span class="sxs-lookup"><span data-stu-id="678a8-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="678a8-128">İlgili atanabilir bir tür XAML oluşturma gereksinimlerini desteklediği sürece, arabirimin XAML türü olarak nasıl sunulması gerektiği konusunda bir kavram yoktur.</span><span class="sxs-lookup"><span data-stu-id="678a8-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="678a8-129">Fabrika yöntemleri</span><span class="sxs-lookup"><span data-stu-id="678a8-129">Factory Methods</span></span>

<span data-ttu-id="678a8-130">Fabrika yöntemleri bir XAML 2009 özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="678a8-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="678a8-131">Nesneler parametresiz oluşturuculara sahip olması gereken XAML ilkesini değiştirir.</span><span class="sxs-lookup"><span data-stu-id="678a8-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="678a8-132">Bu makalede Fabrika yöntemleri açıklanmamıştır.</span><span class="sxs-lookup"><span data-stu-id="678a8-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="678a8-133">Bkz. [X:FactoryMethod yönergesi](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="678a8-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="678a8-134">Listelemeler</span><span class="sxs-lookup"><span data-stu-id="678a8-134">Enumerations</span></span>

<span data-ttu-id="678a8-135">Numaralandırmalar XAML yerel tür dönüştürme davranışına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="678a8-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="678a8-136">XAML 'de belirtilen sabit listesi sabit adları, temeldeki numaralandırma türüne göre çözümlenir ve sabit listesi değerini bir XAML nesne yazıcısına döndürür.</span><span class="sxs-lookup"><span data-stu-id="678a8-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="678a8-137">XAML, uygulanan Numaralandırmalar için bir bayraklar stili kullanımını destekler <xref:System.FlagsAttribute> .</span><span class="sxs-lookup"><span data-stu-id="678a8-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="678a8-138">Daha fazla bilgi için bkz. [XAML sözdizimi ayrıntılı](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span><span class="sxs-lookup"><span data-stu-id="678a8-138">For more information, see [XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail).</span></span> <span data-ttu-id="678a8-139">([Ayrıntılı XAML SÖZDIZIMI](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) WPF hedef kitlesi için yazılmıştır, ancak bu konudaki bilgilerin çoğu, belirli bir uygulama çerçevesine özgü olmayan XAML için geçerlidir.)</span><span class="sxs-lookup"><span data-stu-id="678a8-139">([XAML Syntax In Detail](/dotnet/desktop/wpf/advanced/xaml-syntax-in-detail) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="678a8-140">Üye tanımları</span><span class="sxs-lookup"><span data-stu-id="678a8-140">Member Definitions</span></span>

<span data-ttu-id="678a8-141">Türler, XAML kullanımı için üyeleri tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="678a8-142">Türlerin XAML ile kullanılabilir olması, bu tür XAML ile kullanılabilir olmasa bile, XAML ile kullanılabilen üyeleri tanımlamak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="678a8-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="678a8-143">Bu, CLR devralımı nedeniyle mümkündür.</span><span class="sxs-lookup"><span data-stu-id="678a8-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="678a8-144">Bu nedenle, üyeyi devralan bir tür bir tür olarak XAML kullanımını desteklediğinden ve üye temel alınan türü için XAML kullanımını desteklediğinde ya da kullanılabilir yerel XAML sözdizimi varsa, bu üye XAML ile kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="678a8-145">Özellikler</span><span class="sxs-lookup"><span data-stu-id="678a8-145">Properties</span></span>

<span data-ttu-id="678a8-146">Tipik CLR ve erişimci düzenlerini ve dile uygun KeySize özelliğini kullanarak genel bir CLR özelliği olarak Özellikler tanımlarsanız `get` `set` , XAML tür sistemi özelliği, ve gibi özellikler için belirtilen uygun bilgileri içeren bir üye olarak rapor edebilir <xref:System.Xaml.XamlMember> <xref:System.Xaml.XamlMember.IsReadPublic%2A> <xref:System.Xaml.XamlMember.IsWritePublic%2A> .</span><span class="sxs-lookup"><span data-stu-id="678a8-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="678a8-147">Belirli özellikler, bir metin söz dizimini uygulayarak etkinleştirebilir <xref:System.ComponentModel.TypeConverterAttribute> .</span><span class="sxs-lookup"><span data-stu-id="678a8-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="678a8-148">Daha fazla bilgi için bkz. [xaml Için tür dönüştürücüleri ve biçimlendirme uzantıları](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="678a8-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="678a8-149">Bir metin sözdizimi veya yerel XAML dönüştürmesi yokluğunda ve biçimlendirme uzantısı kullanımı gibi daha fazla yöneltme yokluğunda bir özelliğin türü ( <xref:System.Xaml.XamlMember.TargetType%2A> xaml tür sisteminde), hedef türü clr türü olarak davranarak bir ÖRNEĞI xaml nesne yazıcısına döndürebilmelidir.</span><span class="sxs-lookup"><span data-stu-id="678a8-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="678a8-150">XAML 2009 kullanıyorsanız, önceki noktalara uyulmazsa değer sağlamak için [X:Reference Işaretleme uzantısı](xreference-markup-extension.md) kullanılabilir; Ancak, bir tür tanımı sorunundan daha fazla kullanım sorunu vardır.</span><span class="sxs-lookup"><span data-stu-id="678a8-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="678a8-151">Ekinlikler</span><span class="sxs-lookup"><span data-stu-id="678a8-151">Events</span></span>

<span data-ttu-id="678a8-152">Olayları ortak bir CLR olayı olarak tanımlarsanız, XAML tür sistemi olayı olarak bir üye olarak rapor edebilir <xref:System.Xaml.XamlMember.IsEvent%2A> `true` .</span><span class="sxs-lookup"><span data-stu-id="678a8-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="678a8-153">Olay işleyicilerinin kablolaması .NET XAML Hizmetleri özellikleri kapsamında değildir; kablolama, belirli çerçeveler ve uygulamalar için bırakılır.</span><span class="sxs-lookup"><span data-stu-id="678a8-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="678a8-154">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="678a8-154">Methods</span></span>

<span data-ttu-id="678a8-155">Metotlar için satır içi kod varsayılan XAML özelliği değildir.</span><span class="sxs-lookup"><span data-stu-id="678a8-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="678a8-156">Çoğu durumda, XAML 'deki Yöntem üyelerine doğrudan başvurmayın ve XAML içindeki yöntemlerin rolü yalnızca belirli XAML desenleri için destek sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="678a8-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="678a8-157">[X:FactoryMethod yönergesi](xfactorymethod-directive.md) özel bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="678a8-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="678a8-158">Alanlar</span><span class="sxs-lookup"><span data-stu-id="678a8-158">Fields</span></span>

<span data-ttu-id="678a8-159">CLR tasarım yönergeleri statik olmayan alanları önleyin.</span><span class="sxs-lookup"><span data-stu-id="678a8-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="678a8-160">Statik alanlar için yalnızca [X:static biçimlendirme uzantısı](xstatic-markup-extension.md)aracılığıyla statik alan değerlerine erişebilirsiniz; Bu durumda, [X:static](xstatic-markup-extension.md) kullanımlar için bir alan sunmak üzere clr tanımında özel bir şey yapmamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="678a8-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="678a8-161">Eklenebilir Üyeler</span><span class="sxs-lookup"><span data-stu-id="678a8-161">Attachable Members</span></span>

<span data-ttu-id="678a8-162">Eklenebilir Üyeler, tanımlama türündeki bir erişimci yöntemi düzeniyle XAML 'ye sunulur.</span><span class="sxs-lookup"><span data-stu-id="678a8-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="678a8-163">Tanımlama türünün kendisi bir nesne olarak kullanılabilir olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="678a8-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="678a8-164">Aslında ortak bir model, rolü eklenebilir üyeye sahip olan bir hizmet sınıfı bildirmek ve ilgili davranışları uygulamaktır, ancak kullanıcı arabirimi gösterimi gibi başka bir işlev sunmaz.</span><span class="sxs-lookup"><span data-stu-id="678a8-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="678a8-165">Aşağıdaki bölümlerde yer tutucu *PropertyName* , eklenebilir üyenin adını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="678a8-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="678a8-166">Bu ad, [XamlName dilbilgisinde](xamlname-grammar.md)geçerli olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="678a8-167">Bu desenler ve bir türün diğer yöntemleri arasındaki ad çarpışmalarının dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="678a8-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="678a8-168">Desenlerden biriyle eşleşen bir üye varsa, sizin amacınız olmasa bile bir XAML işlemcisi tarafından eklenebilir üye kullanım patika olarak yorumlanamaz.</span><span class="sxs-lookup"><span data-stu-id="678a8-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="678a8-169">GetPropertyName erişimcisi</span><span class="sxs-lookup"><span data-stu-id="678a8-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="678a8-170">Erişimcinin imzası şu olmalıdır `GetPropertyName` :</span><span class="sxs-lookup"><span data-stu-id="678a8-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="678a8-171">`target`Nesne, uygulamanızda daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="678a8-172">Bunu, eklenebilir üyenin kullanımını kapsam için kullanabilirsiniz; hedeflenen kapsamınız dışında kullanımlar, daha sonra bir XAML ayrıştırma hatası ile ortaya çıkacak geçersiz atama özel durumları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="678a8-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="678a8-173">Parametre adı `target` bir gereksinim değildir, ancak `target` çoğu uygulamada kuralına göre adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="678a8-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="678a8-174">Dönüş değeri, uygulamanızda daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="678a8-175"><xref:System.ComponentModel.TypeConverter>Eklenebilir üyenin öznitelik kullanımı için etkin bir metin sözdizimini desteklemek için, <xref:System.ComponentModel.TypeConverterAttribute> `GetPropertyName` erişimciye uygulayın.</span><span class="sxs-lookup"><span data-stu-id="678a8-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="678a8-176">Yerine öğesine uygulamak, `get` `set` sezgisel olmayan görünebilir; ancak, bu kural, tasarımcı senaryolarında yararlı olan, seri hale getirilebilir olan salt okunurdur eklenebilir Üyeler kavramını destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="678a8-177">SetPropertyName erişimcisi</span><span class="sxs-lookup"><span data-stu-id="678a8-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="678a8-178">Erişimcinin imzası şu olmalıdır `SetPropertyName` :</span><span class="sxs-lookup"><span data-stu-id="678a8-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="678a8-179">`target`Nesnesi, uygulamanızda, önceki bölümde açıklandığı gibi aynı mantık ve sonuçlarla daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="678a8-180">`value`Nesne, uygulamanızda daha belirli bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="678a8-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="678a8-181">Bu yöntemin değerinin, genellikle öznitelik biçiminde XAML kullanımının geldiği giriş olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="678a8-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="678a8-182">Öznitelik formunda, bir metin sözdizimi için değer Dönüştürücüsü desteği ve `GetPropertyName` s erişimcisinde özniteliği olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="678a8-183">Eklenebilir üye depoları</span><span class="sxs-lookup"><span data-stu-id="678a8-183">Attachable Member Stores</span></span>

<span data-ttu-id="678a8-184">Erişimci yöntemleri genellikle, eklenebilir üye değerlerinin bir nesne grafiğine yerleştirileceği veya nesne grafiğinin dışına değer alıp bunları doğru şekilde serileştirmek için bir yol sağlamak üzere yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="678a8-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="678a8-185">Bu işlevi sağlamak için, `target` önceki erişimci imzalarındaki nesnelerin değerleri depolaması yeterli olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="678a8-186">Depolama mekanizması, eklenebilir üyenin üye listesinde olmadığı yerde, üyenin iliştirilebildiği üye ilkesiyle tutarlı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="678a8-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="678a8-187">.NET XAML Hizmetleri, API 'Ler ve aracılığıyla eklenebilir üye depoları için bir uygulama tekniği <xref:System.Xaml.IAttachedPropertyStore> sağlar <xref:System.Xaml.AttachablePropertyServices> .</span><span class="sxs-lookup"><span data-stu-id="678a8-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="678a8-188"><xref:System.Xaml.IAttachedPropertyStore> , bir mağaza uygulamasını keşfetmesi için XAML yazarları tarafından kullanılır ve erişimcilerinin bir türü üzerinde uygulanmalıdır `target` .</span><span class="sxs-lookup"><span data-stu-id="678a8-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="678a8-189">Statik <xref:System.Xaml.AttachablePropertyServices> API 'ler erişimcilerinin gövdesinde kullanılır ve eklenebilir üyeye öğesine başvurur <xref:System.Xaml.AttachableMemberIdentifier> .</span><span class="sxs-lookup"><span data-stu-id="678a8-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="678a8-190">XAML ile Ilgili CLR öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="678a8-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="678a8-191">Türler, Üyeler ve derlemeleriniz, XAML türü sistem bilgilerini .NET XAML hizmetlerine raporlamak için önemli Attributing.</span><span class="sxs-lookup"><span data-stu-id="678a8-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="678a8-192">Aşağıdaki durumlardan biri geçerliyse, raporlama XAML türü sistem bilgileri geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="678a8-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="678a8-193">Türlerinizi, .NET XAML Hizmetleri XAML okuyucuları ve XAML yazıcılarında doğrudan temel alan XAML sistemleri ile kullanım için amaçlamıştınız.</span><span class="sxs-lookup"><span data-stu-id="678a8-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="678a8-194">Bu XAML okuyucuları ve XAML yazıcılarını temel alan XAML kullanan bir çerçeve tanımlar veya kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="678a8-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="678a8-195">Özel türleriniz için XAML desteğiyle ilgili olan XAML ile ilgili her özniteliğin listelenmesi için bkz. [özel türler ve kitaplıklar Için xaml ıle ılgılı clr öznitelikleri](clr-attributes-with-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="678a8-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="678a8-196">Kullanım</span><span class="sxs-lookup"><span data-stu-id="678a8-196">Usage</span></span>

<span data-ttu-id="678a8-197">Özel türlerin kullanımı, biçimlendirme yazarının, özel türü içeren derleme ve CLR ad alanı için bir önek eşlemesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="678a8-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="678a8-198">Bu yordam, bu konuda açıklanmamıştır.</span><span class="sxs-lookup"><span data-stu-id="678a8-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="678a8-199">Erişim düzeyi</span><span class="sxs-lookup"><span data-stu-id="678a8-199">Access Level</span></span>

<span data-ttu-id="678a8-200">XAML, erişim düzeyi olan türleri yüklemek ve örneklemek için bir yol sağlar `internal` .</span><span class="sxs-lookup"><span data-stu-id="678a8-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="678a8-201">Bu özellik, kullanıcı kodunun kendi türlerini tanımlayabilmesi ve ardından aynı kullanıcı kodu kapsamının bir parçası olan biçimlendirmeden bu sınıfların örneklemesinin sağlanması için sağlanır.</span><span class="sxs-lookup"><span data-stu-id="678a8-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="678a8-202">WPF 'den bir örnek, Kullanıcı kodu, bir <xref:System.Windows.Controls.UserControl> UI davranışını yeniden düzenleme yöntemi olarak tasarlanan, ancak destekleme sınıfı erişim düzeyiyle tanımlanarak ima edilebilir olan herhangi bir uzantı mekanizmalarının bir parçası olarak değil, her ne zaman bir örnektir `public` .</span><span class="sxs-lookup"><span data-stu-id="678a8-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="678a8-203">Bu tür bir <xref:System.Windows.Controls.UserControl> `internal` , yedekleme kodu bir xaml türü olarak başvurulduğu aynı derlemeye derlenirse erişim ile bildirilemez.</span><span class="sxs-lookup"><span data-stu-id="678a8-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="678a8-204">Tam güven ve kullanımları altında XAML yükleyen bir uygulama için <xref:System.Xaml.XamlObjectWriter> , erişim düzeyiyle sınıfları yüklemek `internal` her zaman etkindir.</span><span class="sxs-lookup"><span data-stu-id="678a8-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="678a8-205">Kısmi güven altına XAML yükleyen bir uygulama için, API 'yi kullanarak erişim düzeyi özelliklerini kontrol edebilirsiniz <xref:System.Xaml.Permissions.XamlAccessLevel> .</span><span class="sxs-lookup"><span data-stu-id="678a8-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="678a8-206">Ayrıca, erteleme mekanizmaları (WPF şablon sistemi gibi), herhangi bir erişim düzeyi izni yayabilir ve bunları nihai çalışma süresi değerlendirmelerine karşı koruyabilmelidir; Bu, bilgileri geçirerek dahili olarak işlenir <xref:System.Xaml.Permissions.XamlAccessLevel> .</span><span class="sxs-lookup"><span data-stu-id="678a8-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="678a8-207">WPF uygulama</span><span class="sxs-lookup"><span data-stu-id="678a8-207">WPF Implementation</span></span>

<span data-ttu-id="678a8-208">WPF XAML, kısmi güven altında BAML 'nin yüklendiği durumlarda kısmi güven erişim modeli kullanır, <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> Bu da BAML kaynağı olan derleme için erişim kısıtlıdır.</span><span class="sxs-lookup"><span data-stu-id="678a8-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="678a8-209">Deferral için WPF, <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> erişim düzeyi bilgilerini geçirmek için bir mekanizma kullanır.</span><span class="sxs-lookup"><span data-stu-id="678a8-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="678a8-210">WPF XAML terminolojisinde, *dahili bir tür* , başvuran xaml de içeren aynı derleme tarafından tanımlanan bir türdür.</span><span class="sxs-lookup"><span data-stu-id="678a8-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="678a8-211">Böyle bir tür, bir eşlemenin derleme = bölümünü (örneğin,) kasıtlı olarak atbir XAML ad alanı aracılığıyla eşlenebilir `xmlns:local="clr-namespace:WPFApplication1"` .</span><span class="sxs-lookup"><span data-stu-id="678a8-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="678a8-212">BAML bir iç türe başvuruyorsa ve bu türün `internal` erişim düzeyi varsa, bu `GeneratedInternalTypeHelper` derleme için bir sınıf oluşturur.</span><span class="sxs-lookup"><span data-stu-id="678a8-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="678a8-213">Kaçınmak isterseniz `GeneratedInternalTypeHelper` , erişim düzeyini kullanmanız ya da `public` ilgili sınıfı ayrı bir derlemede çarpanlara katmalıdır ve bu derlemeye bağımlı hale gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="678a8-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="678a8-214">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="678a8-214">See also</span></span>

- [<span data-ttu-id="678a8-215">Özel Türler ve Kitaplıkar İçin XAML İlişkili CLR Öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="678a8-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="678a8-216">XAML Hizmetleri</span><span class="sxs-lookup"><span data-stu-id="678a8-216">XAML Services</span></span>](../../../api/index.md)
