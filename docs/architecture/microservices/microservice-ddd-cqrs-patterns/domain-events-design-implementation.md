---
title: Etki alanı olayları. tasarım ve uygulama
description: .NET Microservices Mimari Containerized .NET Uygulamaları için | Agregalar arasında iletişim kurmak için önemli bir kavram olan etki alanı olaylarının ayrıntılı bir görünümünü alın.
ms.date: 10/08/2018
ms.openlocfilehash: 3bba18d4a77b47abee55c16bae8a64ed27ac9aba
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "74884234"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="12b5e-104">Etki alanı olayları: tasarım ve uygulama</span><span class="sxs-lookup"><span data-stu-id="12b5e-104">Domain events: design and implementation</span></span>

<span data-ttu-id="12b5e-105">Etki alanınızdaki değişikliklerin yan etkilerini açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="12b5e-106">Başka bir deyişle, ve DDD terminolojisi kullanarak, birden çok agrega arasında yan etkileri açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="12b5e-107">İsteğe bağlı olarak, veritabanı kilitlerinde daha iyi ölçeklenebilirlik ve daha az etki için, aynı etki alanındaki agregalar arasında nihai tutarlılık kullanın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="12b5e-108">Etki alanı olayı nedir?</span><span class="sxs-lookup"><span data-stu-id="12b5e-108">What is a domain event?</span></span>

<span data-ttu-id="12b5e-109">Bir olay geçmişte olan bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="12b5e-110">Etki alanı olayı, aynı etki alanının diğer bölümlerinin (işlem içi) farkında olmasını istediğiniz etki alanında gerçekleşen bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="12b5e-111">Bildirilen parçalar genellikle olaylara bir şekilde tepki verir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="12b5e-112">Etki alanı olaylarının önemli bir yararı, yan etkilerin açıkça ifade edilebilmektedir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="12b5e-113">Örneğin, varlık framework'u kullanıyorsanız ve bazı olaya tepki vermek zorundaysanız, büyük olasılıkla olayı tetikleyen şeye yakın bir şekilde ne gerekiyorsa kodlarsınız.</span><span class="sxs-lookup"><span data-stu-id="12b5e-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="12b5e-114">Yani kural, dolaylı olarak, kodla birleşir ve kodun içine bakmanız gerekir, umarım, kuralın orada uygulandığını fark etmek için.</span><span class="sxs-lookup"><span data-stu-id="12b5e-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="12b5e-115">Öte yandan, etki alanı olaylarının kullanılması kavramı açık `DomainEvent` hale getirir, çünkü en az bir `DomainEventHandler` tane söz konusudur.</span><span class="sxs-lookup"><span data-stu-id="12b5e-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="12b5e-116">Örneğin, eShopOnContainers uygulamasında, bir sipariş oluşturulduğunda, kullanıcı bir alıcı `OrderStartedDomainEvent` olur, bu nedenle `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`bir yükseltilir ve ele alınır , böylece temel kavramı açıktır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="12b5e-117">Kısacası, etki alanı olayları, etki alanı uzmanları tarafından sağlanan her yerde bulunan dilde dayalı etki alanı kurallarını açıkça ifade etmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="12b5e-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="12b5e-118">Etki alanı olayları da aynı etki alanındaki sınıflar arasında endişelerin daha iyi ayrılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="12b5e-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="12b5e-119">Bir veritabanı hareketi gibi, bir etki alanı olayıyla ilgili tüm işlemlerin başarılı bir şekilde sona ermesini veya hiçbirinin bunu yapmamasını sağlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="12b5e-120">Etki alanı olayları, önemli bir farkla mesajlaşma tarzı olaylara benzer.</span><span class="sxs-lookup"><span data-stu-id="12b5e-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="12b5e-121">Gerçek mesajlaşma, ileti sıraya alma, ileti aracıları veya AMQP kullanan bir servis veri birimi yle, bir ileti her zaman eşzamanlı olarak gönderilir ve süreçler ve makineler arasında iletilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-121">With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="12b5e-122">Bu, birden çok Bağlı Bağlamları, mikro hizmetleri ve hatta farklı uygulamaları tümleştirmek için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="12b5e-123">Ancak, etki alanı olayları ile, şu anda çalıştırmakta olduğunuz etki alanı işleminden bir olay yükseltmek istiyorsunuz, ancak aynı etki alanı içinde herhangi bir yan efektin oluşmasını istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="12b5e-124">Etki alanı olayları ve bunların yan etkileri (olay işleyicileri tarafından yönetilen daha sonra tetiklenen eylemler) hemen, genellikle süreç içinde ve aynı etki alanı içinde meydana gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="12b5e-125">Böylece, etki alanı olayları senkron veya eşzamanlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="12b5e-126">Ancak tümleştirme olayları her zaman eşzamanlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="12b5e-127">Etki alanı olayları ve tümleştirme olayları</span><span class="sxs-lookup"><span data-stu-id="12b5e-127">Domain events versus integration events</span></span>

<span data-ttu-id="12b5e-128">Semantically, etki alanı ve tümleştirme olayları aynı şey: sadece oldu bir şey hakkında bildirimler.</span><span class="sxs-lookup"><span data-stu-id="12b5e-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="12b5e-129">Ancak, bunların uygulanması farklı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-129">However, their implementation must be different.</span></span> <span data-ttu-id="12b5e-130">Etki alanı olayları, ioC kapsayıcısına veya başka bir yönteme dayalı bellek içi aracı olarak uygulanabilen bir etki alanı olay göndericisine itilen iletilerdir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="12b5e-131">Diğer taraftan, tümleştirme olaylarının amacı, diğer mikro hizmetler, Sınırlı Bağlamlar ve hatta dış uygulamalar olsun, taahhüt edilen işlemleri ve güncelleştirmeleri ek alt sistemlere yaymaktır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="12b5e-132">Bu nedenle, bunlar yalnızca varlık başarıyla devam ederse meydana gelmelidir, aksi takdirde tüm işlem hiç olmamış gibi olur.</span><span class="sxs-lookup"><span data-stu-id="12b5e-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="12b5e-133">Daha önce de belirtildiği gibi, tümleştirme olayları birden çok mikro hizmet (diğer Sınırlı Bağlamlar) ve hatta dış sistemler/uygulamalar arasındaki eşzamanlı iletişimi temel almalıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="12b5e-134">Bu nedenle, olay veri birimi arabiriminin, olası uzak hizmetler arasında süreçler arası ve dağıtılmış iletişimsağlayan bazı altyapıya ihtiyacı vardır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="12b5e-135">Ticari hizmet veri yolunda, kuyruklara, posta kutusu olarak kullanılan paylaşılan bir veritabanına veya dağıtılmış ve ideal olarak itilen herhangi bir ileti sistemine dayalı olabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="12b5e-136">Etki alanı olayları, aynı etki alanı içinde birden fazla agrega arasında yan etkileri tetiklemek için tercih edilen bir yol olarak</span><span class="sxs-lookup"><span data-stu-id="12b5e-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="12b5e-137">Bir toplu örnekle ilgili bir komutun yürütülmesi, bir veya daha fazla ek toplamda çalıştırılması için ek etki alanı kuralları gerektiriyorsa, etki alanı olayları tarafından tetiklenecek bu yan efektleri tasarlamalı ve uygulamalısınız.</span><span class="sxs-lookup"><span data-stu-id="12b5e-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="12b5e-138">Şekil 7-14'te gösterildiği gibi ve en önemli kullanım örneklerinden biri olarak, aynı etki alanı modelinde durum değişikliklerini birden çok agrega da yaymak için bir etki alanı olayı kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![Alıcı toplamına verileri denetleyen bir etki alanı olayını gösteren diyagram.](./media/domain-events-design-implementation/domain-model-ordering-microservice.png)

<span data-ttu-id="12b5e-140">**Şekil 7-14**.</span><span class="sxs-lookup"><span data-stu-id="12b5e-140">**Figure 7-14**.</span></span> <span data-ttu-id="12b5e-141">Aynı etki alanı içinde birden fazla agrega arasında tutarlılık zorlamak için etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="12b5e-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="12b5e-142">Şekil 7-14, etki alanı olayları tarafından agregalar arasındaki tutarlılığın nasıl sağlandığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-142">Figure 7-14 shows how consistency between aggregates is achieved by domain events.</span></span> <span data-ttu-id="12b5e-143">Kullanıcı bir sipariş başlattığında, Sipariş Toplamı `OrderStarted` bir etki alanı olayı gönderir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-143">When the user initiates an order, the Order Aggregate sends an `OrderStarted` domain event.</span></span> <span data-ttu-id="12b5e-144">OrderStarted etki alanı olayı, kimlik microservice'in orijinal kullanıcı bilgilerine (CreateOrder komutunda sağlanan bilgilerle) dayalı olarak, sipariş mikrohizmetinde bir Alıcı nesnesi oluşturmak için Alıcı Toplamı tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-144">The OrderStarted domain event is handled by the Buyer Aggregate to create a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span>

<span data-ttu-id="12b5e-145">Alternatif olarak, toplam kökün, onun toplamlarının (alt varlıklar) üyeleri tarafından yükseltilen olaylar için abone olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-145">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="12b5e-146">Örneğin, her OrderItem alt varlık, madde fiyatı belirli bir tutardan yüksek olduğunda veya ürün madde miktarı çok yüksekolduğunda bir olay yükseltebilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-146">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="12b5e-147">Daha sonra toplu kök bu olayları alabilir ve genel bir hesaplama veya toplama gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-147">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="12b5e-148">Bu olay tabanlı iletişimin doğrudan toplamlar içinde uygulanmadığını anlamak önemlidir; etki alanı olay işleyicileri uygulamak gerekir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-148">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="12b5e-149">Etki alanı olayları işleme bir uygulama endişe.</span><span class="sxs-lookup"><span data-stu-id="12b5e-149">Handling the domain events is an application concern.</span></span> <span data-ttu-id="12b5e-150">Etki alanı modeli katmanı yalnızca etki alanı mantığına odaklanmalıdır— etki alanı uzmanının anlayacağı şeyler, depoları kullanarak işleyiciler ve yan etki kalıcılığı eylemleri gibi uygulama altyapısı değil.</span><span class="sxs-lookup"><span data-stu-id="12b5e-150">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="12b5e-151">Bu nedenle, uygulama katmanı düzeyi, etki alanı olayı yükseltildiğinde eylemleri tetikleyen etki alanı olay işleyicileri olması gereken yerdir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-151">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="12b5e-152">Etki alanı olayları da uygulama eylemleri herhangi bir sayı tetiklemek için kullanılabilir ve daha da önemlisi, ayrılmış bir şekilde gelecekte bu sayıyı artırmak için açık olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-152">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="12b5e-153">Örneğin, sipariş başlatıldığında, bu bilgileri diğer toplamlara yaymak ve hatta bildirimler gibi uygulama eylemlerini yükseltmek için bir etki alanı olayı yayımlamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-153">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="12b5e-154">Önemli nokta, bir etki alanı olayı oluştuğunda yürütülecek açık eylem sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-154">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="12b5e-155">Sonunda, etki alanı ve uygulama eylemleri ve kuralları büyüyecek.</span><span class="sxs-lookup"><span data-stu-id="12b5e-155">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="12b5e-156">Bir şey olduğunda yan etki eylemlerinin karmaşıklığı veya sayısı büyür, ancak kodunuz "tutkal" ile birleştiğinde (diğer bir şekilde, belirli nesneler `new`oluşturma), yeni bir eylem eklemek için gereken her zaman da çalışma ve test kodu değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-156">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="12b5e-157">Bu değişiklik yeni hatalara neden olabilir ve bu yaklaşım [SOLID'in](https://en.wikipedia.org/wiki/SOLID) [Açık/Kapalı ilkesine](https://en.wikipedia.org/wiki/Open/closed_principle) de aykırıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-157">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="12b5e-158">Sadece bu değil, operasyonları düzenleyen orijinal sınıf büyümek ve tek [sorumluluk ilkesi (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle)aykırı büyüyecek.</span><span class="sxs-lookup"><span data-stu-id="12b5e-158">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="12b5e-159">Diğer taraftan, etki alanı olayları kullanıyorsanız, bu yaklaşımı kullanarak sorumlulukları ayırarak ince taneli ve ayrılmış bir uygulama oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="12b5e-159">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="12b5e-160">Komut gönderin (örneğin, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="12b5e-160">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="12b5e-161">Komut işleyicisi komutu alın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-161">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="12b5e-162">Tek bir toplamın işlemini yürütün.</span><span class="sxs-lookup"><span data-stu-id="12b5e-162">Execute a single aggregate’s transaction.</span></span>
   - <span data-ttu-id="12b5e-163">(İsteğe bağlı) Yan etkiler için etki alanı olaylarını yükseltin (örneğin, OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="12b5e-163">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="12b5e-164">Birden çok toplama veya uygulama eyleminde açık sayıda yan etki yürütecek etki alanı olaylarını (geçerli işlem içinde) işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-164">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="12b5e-165">Örnek:</span><span class="sxs-lookup"><span data-stu-id="12b5e-165">For example:</span></span>
   - <span data-ttu-id="12b5e-166">Doğrulayın veya alıcı ve ödeme yöntemi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="12b5e-166">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="12b5e-167">Durumları mikro hizmetler arasında yaymak veya alıcıya e-posta göndermek gibi dış eylemleri tetiklemek için ilgili bir tümleştirme olayı oluşturun ve olay veri tonuna gönderin.</span><span class="sxs-lookup"><span data-stu-id="12b5e-167">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="12b5e-168">Diğer yan etkileri ele alın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-168">Handle other side effects.</span></span>

<span data-ttu-id="12b5e-169">Şekil 7-15'te gösterildiği gibi, aynı etki alanı olayından başlayarak, etki alanındaki diğer toplamlarla ilgili birden çok eylemi veya tümleştirme olayları ve olay veri yolunu birbirine bağlayan mikro hizmetler de gerçekleştirmeniz gereken ek uygulama eylemlerini işleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-169">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Birkaç olay işleyicisine veri aktaran bir etki alanı olayını gösteren diyagram.](./media/domain-events-design-implementation/aggregate-domain-event-handlers.png)

<span data-ttu-id="12b5e-171">**Şekil 7-15**.</span><span class="sxs-lookup"><span data-stu-id="12b5e-171">**Figure 7-15**.</span></span> <span data-ttu-id="12b5e-172">Etki alanı başına birden çok eylemi işleme</span><span class="sxs-lookup"><span data-stu-id="12b5e-172">Handling multiple actions per domain</span></span>

<span data-ttu-id="12b5e-173">Uygulama Katmanı'nda aynı etki alanı olayı için birkaç işleyici olabilir, bir işleyici agregalar arasındaki tutarlılığı çözebilir ve başka bir işleyici bir tümleştirme olayı yayımlayabilir, böylece diğer mikro hizmetler onunla bir şeyler yapabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-173">There can be several handlers for the same domain event in the Application Layer, one handler can solve consistency between aggregates and another handler can publish an integration event, so other microservices can do something with it.</span></span> <span data-ttu-id="12b5e-174">Mikro hizmetin davranışı için depolar veya uygulama API'si gibi altyapı nesnelerini kullanacağınız için olay işleyicileri genellikle uygulama katmanındadır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-174">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="12b5e-175">Bu anlamda, olay işleyicileri komut işleyicileri benzer, bu nedenle her ikisi de uygulama katmanının bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-175">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="12b5e-176">Önemli fark, bir komutun yalnızca bir kez işlenmesidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-176">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="12b5e-177">Etki alanı olayı, her işleyici için farklı bir amaca sahip birden çok alıcı veya olay işleyicisi tarafından alınabileceğinden, sıfır veya *n* kez işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-177">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="12b5e-178">Etki alanı olayı başına açık sayıda işleyiciolması, geçerli kodu etkilemeden gerektiği kadar etki alanı kuralı eklemenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-178">Having an open number of handlers per domain event allows you to add as many domain rules as needed, without affecting  current code.</span></span> <span data-ttu-id="12b5e-179">Örneğin, aşağıdaki iş kuralını uygulamak birkaç olay işleyicisi eklemek kadar kolay olabilir (hatta sadece bir tane):</span><span class="sxs-lookup"><span data-stu-id="12b5e-179">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="12b5e-180">Mağazada bir müşteri tarafından satın alınan toplam tutar, herhangi bir sayıda sipariş te 6.000 TL'yi aştığında, her yeni siparişe %10 indirim uygulayın ve müşteriye gelecekteki siparişler için bu indirim hakkında bir e-posta ile bildirin.</span><span class="sxs-lookup"><span data-stu-id="12b5e-180">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="12b5e-181">Etki alanı etkinliklerini uygulama</span><span class="sxs-lookup"><span data-stu-id="12b5e-181">Implement domain events</span></span>

<span data-ttu-id="12b5e-182">C#'da, etki alanı olayı, aşağıdaki örnekte gösterildiği gibi, etki alanında olanlarla ilgili tüm bilgileri içeren, dto gibi basit bir veri tutma yapısı veya sınıfıdır:</span><span class="sxs-lookup"><span data-stu-id="12b5e-182">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="12b5e-183">Bu aslında OrderStarted olayıyla ilgili tüm verileri tutan bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-183">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="12b5e-184">Etki alanının her yerde bulunan dili açısından, bir olay geçmişte olan bir şey olduğundan, olayın sınıf adı OrderStartedDomainEvent veya OrderShippedDomainEvent gibi geçmiş zamanlı bir fiil olarak temsil edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-184">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="12b5e-185">Etki alanı olayı, eShopOnContainers'da sipariş mikrohizmetinde bu şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-185">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="12b5e-186">Daha önce de belirtildiği gibi, olayların önemli bir özelliği, bir olay geçmişte olan bir şey olduğundan, bu değişmemesi gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-186">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="12b5e-187">Bu nedenle, değişmez bir sınıf olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-187">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="12b5e-188">Önceki kodda özelliklerin salt okunur olduğunu görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-188">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="12b5e-189">Nesneyi güncelleştirmenin bir yolu yoktur, değerleri yalnızca oluşturduğunuzda ayarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-189">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="12b5e-190">Burada vurgulamak önemlidir, eğer etki alanı olayları eşit bir şekilde işlenecekse, olay nesnelerini serihale ve deserialize etmeyi gerektiren bir sıra kullanılarak, özelliklerin salt okunur değil "özel küme" olması gerekir, bu nedenle deserializer değerleri dequeuing üzerine atamak mümkün.</span><span class="sxs-lookup"><span data-stu-id="12b5e-190">It’s important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be “private set” instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="12b5e-191">Etki alanı olay pub / alt MediatR kullanılarak eşzamanlı olarak uygulandığından, bu Sipariş microservice bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-191">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="12b5e-192">Etki alanı olaylarını yükseltme</span><span class="sxs-lookup"><span data-stu-id="12b5e-192">Raise domain events</span></span>

<span data-ttu-id="12b5e-193">Bir sonraki soru, ilgili olay işleyicilerine ulaşması için bir etki alanı olayının nasıl yükseltilen olduğudur.</span><span class="sxs-lookup"><span data-stu-id="12b5e-193">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="12b5e-194">Birden çok yaklaşım kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-194">You can use multiple approaches.</span></span>

<span data-ttu-id="12b5e-195">Udi Dahan başlangıçta olayları yönetmek ve yükseltmek için statik bir sınıf kullanarak (örneğin, [Etki Alanı Etkinlikleri – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)gibi ilgili birkaç gönderide) önerilmiştir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-195">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="12b5e-196">Bu, etki alanı olaylarını çağrıldığında hemen yükseltecek Etki Alanı Etkinlikleri `DomainEvents.Raise(Event myEvent)`adlı statik bir sınıf içerebilir, '' gibi sözdizimi kullanarak.</span><span class="sxs-lookup"><span data-stu-id="12b5e-196">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="12b5e-197">Jimmy Bogard benzer bir yaklaşım önerir bir blog yazısı yazdı ([Etki alanı güçlendirilmesi: Etki Alanı Olaylar)](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/).</span><span class="sxs-lookup"><span data-stu-id="12b5e-197">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="12b5e-198">Ancak, etki alanı olayları sınıfı statik olduğunda, işleyicilere de hemen gönderir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-198">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="12b5e-199">Bu, yan efekt mantığına sahip olay işleyicileri olay yükseltildikten hemen sonra yürütüldolduğundan, sınama ve hata ayıklamayı zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-199">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="12b5e-200">Test ederken ve hata ayıklarken, şu anki toplam sınıflarda neler olup bittiğine odaklanmak istersiniz; aniden diğer agregalar veya uygulama mantığı ile ilgili yan etkileri için diğer olay işleyicileri yönlendirilmeye istemiyorum.</span><span class="sxs-lookup"><span data-stu-id="12b5e-200">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="12b5e-201">Bu nedenle, bir sonraki bölümde açıklandığı gibi diğer yaklaşımlar da gelişmiştir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-201">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="12b5e-202">Olayları yükseltmek ve göndermek için ertelenmiş yaklaşım</span><span class="sxs-lookup"><span data-stu-id="12b5e-202">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="12b5e-203">Bir etki alanı olay işleyicisine hemen göndermek yerine, daha iyi bir yaklaşım etki alanı olaylarını bir koleksiyona eklemek ve bu etki alanı olaylarını işlemi gerçekleştirmeden *hemen önce* veya *hemen* *sonra* göndermektir (EF'deki SaveChanges'ta olduğu gibi).</span><span class="sxs-lookup"><span data-stu-id="12b5e-203">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="12b5e-204">(Bu yaklaşım Jimmy Bogard tarafından bu yazı [daha iyi bir etki alanı olayları desen](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)açıklanmıştır.)</span><span class="sxs-lookup"><span data-stu-id="12b5e-204">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="12b5e-205">Etki alanı olaylarını işlemi gerçekleştirmeden hemen önce veya hemen önce mi gönderdiğinizönemli, çünkü yan etkileri aynı işlemin bir parçası olarak mı yoksa farklı hareketlere mi dahil edeceğiniz belirlenir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-205">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="12b5e-206">İkinci durumda, birden çok agrega arasında nihai tutarlılık ile uğraşmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-206">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="12b5e-207">Bu konu sonraki bölümde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-207">This topic is discussed in the next section.</span></span>

<span data-ttu-id="12b5e-208">Ertelenmiş yaklaşım eShopOnContainers ne kullanır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-208">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="12b5e-209">İlk olarak, varlıklarınızda meydana gelen olayları bir koleksiyona veya varlık başına olaylar listesine eklersiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-209">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="12b5e-210">Bu liste, Varlık taban sınıfının aşağıdaki örneğinde gösterildiği gibi, varlık nesnesinin veya daha iyisi, taban varlık sınıfının bir parçası olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="12b5e-210">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //...
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents;

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="12b5e-211">Bir olayı yükseltmek istediğinizde, toplu kök varlığın herhangi bir yönteminde koddan olay koleksiyonuna eklemeniz önemlidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-211">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="12b5e-212">Aşağıdaki kod, [eShopOnContainers sipariş toplam kök](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs)parçası, bir örnek gösterir:</span><span class="sxs-lookup"><span data-stu-id="12b5e-212">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="12b5e-213">AddDomainEvent yönteminin yaptığı tek şeyin listeye bir olay eklemek olduğuna dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="12b5e-213">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="12b5e-214">Henüz olay gönderilmedi ve henüz hiçbir olay işleyicisi çağrılmadı.</span><span class="sxs-lookup"><span data-stu-id="12b5e-214">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="12b5e-215">Aslında, hareketi veritabanına işlediğinde olayları daha sonra göndermek istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-215">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="12b5e-216">Varlık Framework Core kullanıyorsanız, bu, EF DbContext'ınızın SaveChanges yönteminde aşağıdaki kodda olduğu gibi anlamına gelir:</span><span class="sxs-lookup"><span data-stu-id="12b5e-216">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="12b5e-217">Bu kodla, varlık olaylarını ilgili olay işleyicilerine gönderirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-217">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="12b5e-218">Genel sonuç, bir etki alanı olayının yükseltilmesini (bellekteki bir listeye basit bir ekleme) bir olay işleyicisine göndermekten ayırmanızdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-218">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="12b5e-219">Buna ek olarak, ne tür bir sevk irsaliyesi kullandığınıza bağlı olarak, olayları eşzamanlı veya eşzamanlı olarak gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-219">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="12b5e-220">İşlemsel sınırların burada önemli bir oyuna girdiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-220">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="12b5e-221">Çalışma ve işlem biriminiz birden fazla toplama (EF Core ve ilişkisel veritabanı kullanırken olduğu gibi) yayılabilirse, bu iyi çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-221">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="12b5e-222">Ancak, Azure CosmosDB gibi bir NoSQL veritabanı kullanıyorsanız gibi işlem toplamlara yayılamıyorsa, tutarlılık elde etmek için ek adımlar uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-222">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="12b5e-223">Bu, sebat cehalet evrensel değildir başka bir nedenidir; kullandığınız depolama sistemine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-223">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="12b5e-224">Agregalar arasında tek işlem ve agregalar arasında nihai tutarlılık</span><span class="sxs-lookup"><span data-stu-id="12b5e-224">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="12b5e-225">Bu toplamlar arasında nihai tutarlılığa güvenmek yerine agregalar arasında tek bir işlem gerçekleştirip gerçekleştirmeyeceği sorusu tartışmalıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-225">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="12b5e-226">Eric Evans ve Vaughn Vernon gibi birçok DDD yazarları bir işlem = bir toplam ve bu nedenle toplamlar arasında nihai tutarlılık için tartışmak kuralı savunucusu.</span><span class="sxs-lookup"><span data-stu-id="12b5e-226">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="12b5e-227">Örneğin, kitabında *Etki Alanı Odaklı Tasarım*, Eric Evans bu diyor:</span><span class="sxs-lookup"><span data-stu-id="12b5e-227">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="12b5e-228">Toplamları kapsayan herhangi bir kuralın her zaman güncel olması beklenmez.</span><span class="sxs-lookup"><span data-stu-id="12b5e-228">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="12b5e-229">Olay işleme, toplu iş işleme veya diğer güncelleştirme mekanizmaları sayesinde, diğer bağımlılıklar belirli bir süre içinde çözülebilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-229">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="12b5e-230">(sayfa 128)</span><span class="sxs-lookup"><span data-stu-id="12b5e-230">(page 128)</span></span>

<span data-ttu-id="12b5e-231">Vaughn Vernon Etkili [Agrega Tasarım aşağıdaki diyor. Bölüm II: Agregaların Birlikte Çalışmasını Sağlamak](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="12b5e-231">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="12b5e-232">Bu nedenle, bir komutu toplu bir örnekte yürütmek, ek iş kurallarının bir \[veya daha fazla toplamda yürütülmesini gerektiriyorsa, nihai tutarlılığı kullanın ... \] Bir DDD modelinde nihai tutarlılığı desteklemenin pratik bir yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-232">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="12b5e-233">Toplu yöntem, bir veya daha fazla eşzamanlı aboneye zamanında teslim edilen bir etki alanı olayı yayımlar.</span><span class="sxs-lookup"><span data-stu-id="12b5e-233">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="12b5e-234">Bu mantık, birçok agrega veya varlığı kapsayan işlemler yerine ince taneli hareketleri kucaklamaya dayanır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-234">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="12b5e-235">Fikir ikinci durumda, veritabanı kilitleri sayısı yüksek ölçeklenebilirlik gereksinimleri ile büyük ölçekli uygulamalarda önemli olacaktır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-235">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="12b5e-236">Yüksek ölçeklenebilir uygulamaların birden fazla agrega arasında anlık işlem tutarlılığına sahip olmaması gerektiği gerçeğini benimsemek, nihai tutarlılık kavramını kabul etmeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="12b5e-236">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="12b5e-237">Atomik değişiklikler genellikle işletme tarafından gerekli değildir ve her durumda belirli işlemlerin atomik işlemlere gerek olup olmadığını söylemek etki alanı uzmanlarının sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-237">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="12b5e-238">Bir işlemin her zaman birden çok agrega arasında atomik bir işlem eihtiyacı varsa, agreganızın daha büyük mü yoksa doğru şekilde tasarlanmaması mı gerektiğini sorabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-238">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="12b5e-239">Ancak, Jimmy Bogard gibi diğer geliştiriciler ve mimarlar birkaç agrega arasında tek bir işlem yayılan tamam-ama sadece bu ek toplamlar aynı orijinal komut için yan etkileri ile ilgili olduğunda.</span><span class="sxs-lookup"><span data-stu-id="12b5e-239">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="12b5e-240">Örneğin, [daha iyi bir etki alanı olayları desen,](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)Bogard bu diyor:</span><span class="sxs-lookup"><span data-stu-id="12b5e-240">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="12b5e-241">Genellikle, bir etki alanı olayının yan etkilerinin aynı mantıksal işlem içinde gerçekleşmesini istiyorum, ancak etki \[alanı olayını yükseltme kapsamında olması gerekmez ... \] İşlemimizi gerçekleştirmeden hemen önce, etkinliklerimizi ilgili amirlerine göndeririz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-241">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="12b5e-242">İlk işlemi gerçekleştirmeden *hemen önce* etki alanı olaylarını gönderirseniz, bunun nedeni bu olayların yan etkilerinin aynı işleme dahil olmasını istemenizdir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-242">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="12b5e-243">Örneğin, EF DbContext SaveChanges yöntemi başarısız olursa, hareket, ilgili etki alanı olay işleyicileri tarafından uygulanan herhangi bir yan etki işlemlerinin sonucu da dahil olmak üzere tüm değişiklikleri geri alır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-243">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="12b5e-244">Bunun nedeni, DbContext yaşam kapsamının varsayılan olarak "kapsamlı" olarak tanımlanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-244">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="12b5e-245">Bu nedenle, DbContext nesnesi, aynı kapsam veya nesne grafiği içinde anlık olarak bulunan birden çok depo nesnesi arasında paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-245">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="12b5e-246">Bu, Web API veya MVC uygulamaları geliştirirken HttpRequest kapsamıyla çakışıyor.</span><span class="sxs-lookup"><span data-stu-id="12b5e-246">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="12b5e-247">Aslında, her iki yaklaşım (tek atomik işlem ve nihai tutarlılık) doğru olabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-247">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="12b5e-248">Bu gerçekten etki alanı veya iş gereksinimleri ve etki alanı uzmanları size ne söyler bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-248">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="12b5e-249">Ayrıca, hizmetin ne kadar ölçeklenebilir olmasına da bağlıdır (daha ayrıntılı işlemlerveritabanı kilitlerine göre daha az etkiye sahiptir).</span><span class="sxs-lookup"><span data-stu-id="12b5e-249">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="12b5e-250">Ve bu, agregalar arasında olası tutarsızlıkları ve telafi edici eylemleri uygulama gereksinimini algılamak için daha karmaşık kod gerektirdiğinden, kodunuza ne kadar yatırım yapmak istediğinize bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-250">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="12b5e-251">Orijinal toplamda değişiklikler yaparsanız ve daha sonra, olaylar gönderilirken, bir sorun varsa ve olay işleyicileri yan etkilerini gerçekleştiremiyorsa, toplamlar arasında tutarsızlıklar olacağını düşünün.</span><span class="sxs-lookup"><span data-stu-id="12b5e-251">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="12b5e-252">Telafi edici eylemlere izin vermenin bir yolu, etki alanı olaylarını özgün işlemin bir parçası olabilmesi için ek veritabanı tablolarında depolamak olacaktır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-252">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="12b5e-253">Daha sonra, tutarsızlıkları algılayan ve olayların listesini agregaların geçerli durumuyla karşılaştırarak telafi edici eylemler çalıştıran bir toplu işlem olabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-253">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="12b5e-254">Telafi edici eylemler, iş kullanıcısı ve etki alanı uzmanlarıyla tartışmayı da içeren, sizin tarafınızdan derin analizler gerektiren karmaşık bir konunun parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-254">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="12b5e-255">Her durumda, ihtiyacınız olan yaklaşımı seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-255">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="12b5e-256">Ancak, işlemeden önce olayları yükselten ilk ertelenmiş yaklaşım, böylece tek bir işlem kullanırsanız, EF Core ve ilişkisel bir veritabanı nı kullanırken en basit yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-256">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="12b5e-257">Birçok iş durumunda uygulanması daha kolaydır ve geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-257">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="12b5e-258">Aynı zamanda eShopOnContainers sipariş microservice kullanılan bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-258">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="12b5e-259">Ama bu olayları kendi etkinlik işleyicilerine nasıl gönderirsiniz?</span><span class="sxs-lookup"><span data-stu-id="12b5e-259">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="12b5e-260">Önceki örnekte `_mediator` gördüğünüz nesne nedir?</span><span class="sxs-lookup"><span data-stu-id="12b5e-260">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="12b5e-261">Olaylar ve olay işleyicileri arasında harita kullanmak teknikleri ve eserler ile ilgili.</span><span class="sxs-lookup"><span data-stu-id="12b5e-261">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="12b5e-262">Etki alanı olay gönderici: olaylardan olay işleyicilerine eşleme</span><span class="sxs-lookup"><span data-stu-id="12b5e-262">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="12b5e-263">Olayları gönderebildiğinizde veya yayımlayabildiğinizde, ilgili her işleyicinin olayı alabilmeleri ve bu olaya göre yan efektleri işleyebilmeleri için olayı yayımlayacak bir tür yapıya ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-263">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="12b5e-264">Bir yaklaşım gerçek bir mesajlaşma sistemi ya da muhtemelen bellek olayların aksine bir servis verime dayalı bir olay otobüsü vardır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-264">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="12b5e-265">Ancak, ilk durumda, gerçek ileti etki alanı olaylarını işlemek için aşırı yayılacak, çünkü bu olayları aynı işlem içinde işlemeniz gerekir (diğer bir süre aynı etki alanı ve uygulama katmanı içinde).</span><span class="sxs-lookup"><span data-stu-id="12b5e-265">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="12b5e-266">Olayları birden çok olay işleyicisi ile eşlemenin başka bir yolu da, olayları nereye göndereceğinizi dinamik olarak çıkarabilmeniz için bir IoC kapsayıcısındaki tür kaydını kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-266">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="12b5e-267">Başka bir deyişle, belirli bir olayı elde etmek için hangi olay işleyicilerinin neye ihtiyacı olduğunu bilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-267">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="12b5e-268">Şekil 7-16 bu yaklaşım için basitleştirilmiş bir yaklaşım gösterir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-268">Figure 7-16 shows a simplified approach for this approach.</span></span>

![Olayları uygun işleyicilere gönderen etki alanı olay göndericisini gösteren diyagram.](./media/domain-events-design-implementation/domain-event-dispatcher.png)

<span data-ttu-id="12b5e-270">**Şekil 7-16.**</span><span class="sxs-lookup"><span data-stu-id="12b5e-270">**Figure 7-16**.</span></span> <span data-ttu-id="12b5e-271">IoC kullanarak etki alanı olay gönderici</span><span class="sxs-lookup"><span data-stu-id="12b5e-271">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="12b5e-272">Tüm sıhhi tesisat ve eserler kendiniz bu yaklaşımı uygulamak için inşa edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-272">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="12b5e-273">Ancak, IoC kapsayıcınızı kapakların altında kullanan [MediatR](https://github.com/jbogard/MediatR) gibi kullanılabilir kitaplıkları da kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-273">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="12b5e-274">Bu nedenle, önceden tanımlanmış arabirimleri ve aracı nesnenin yayımlama/gönderme yöntemlerini doğrudan kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-274">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="12b5e-275">Kod olarak, öncelikle ioC kapsayıcınızda olay işleyicisi türlerini kaydetmeniz gerekir, aşağıdaki örnekte gösterildiği gibi [eShopOnContainers Sipariş mikroservice:](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs)</span><span class="sxs-lookup"><span data-stu-id="12b5e-275">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="12b5e-276">Kod ilk olarak işleyicilerden herhangi birini tutan derlemeyi (typeof(ValidateOrAddBuyerAggregateXxxx kullanarak) bularak etki alanı olay işleyicilerini içeren derlemeyi tanımlar, ancak derlemeyi bulmak için başka bir olay işleyicisi seçmiş olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="12b5e-276">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="12b5e-277">Tüm olay işleyicileri IAsyncNotificationHandler arabirimini uyguladığından, kod yalnızca bu türleri arar ve tüm olay işleyicilerini kaydeder.</span><span class="sxs-lookup"><span data-stu-id="12b5e-277">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="12b5e-278">Etki alanı etkinliklerine nasıl abone olunur?</span><span class="sxs-lookup"><span data-stu-id="12b5e-278">How to subscribe to domain events</span></span>

<span data-ttu-id="12b5e-279">MediatR'ı kullandığınızda, her olay işleyicisi aşağıdaki kodda görebileceğiniz gibi INotificationHandler arabiriminin genel parametresinde sağlanan bir olay türü kullanmalıdır:</span><span class="sxs-lookup"><span data-stu-id="12b5e-279">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="12b5e-280">Etkinlik ve olay işleyicisi arasındaki ve abonelik olarak kabul edilebilen ilişkiye bağlı olarak, MediatR artifakı her olay için tüm olay işleyicilerini keşfedebilir ve bu olay işleyicilerinin her birini tetikleyebilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-280">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="12b5e-281">Etki alanı olayları nasıl işleyebilir</span><span class="sxs-lookup"><span data-stu-id="12b5e-281">How to handle domain events</span></span>

<span data-ttu-id="12b5e-282">Son olarak, olay işleyicisi genellikle gerekli ek agregaları elde etmek ve yan etki alanı mantığını yürütmek için altyapı depolarını kullanan uygulama katmanı kodu uygular.</span><span class="sxs-lookup"><span data-stu-id="12b5e-282">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="12b5e-283">[eShopOnContainers aşağıdaki etki alanı olay işleyici kodu,](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs)bir uygulama örneği gösterir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-283">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer)
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="12b5e-284">Altyapı kalıcılığı katmanının bir sonraki bölümünde açıklandığı gibi altyapı depolarını kullandığından, önceki etki alanı olay işleyicisi kodu uygulama katmanı kodu olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-284">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="12b5e-285">Olay işleyicileri diğer altyapı bileşenlerini de kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-285">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="12b5e-286">Etki alanı olayları, mikro hizmet sınırları dışında yayımlanacak tümleştirme olayları oluşturabilir</span><span class="sxs-lookup"><span data-stu-id="12b5e-286">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="12b5e-287">Son olarak, olayları bazen birden çok mikro hizmete yaymak isteyebileceğini belirtmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-287">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="12b5e-288">Bu yayılma bir tümleştirme olayıdır ve belirli bir etki alanı olay işleyicisinden bir olay veri günü aracılığıyla yayınlanabilir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-288">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="12b5e-289">Etki alanı olayları yla ilgili sonuçlar</span><span class="sxs-lookup"><span data-stu-id="12b5e-289">Conclusions on domain events</span></span>

<span data-ttu-id="12b5e-290">Belirtildiği gibi, etki alanınızdaki değişikliklerin yan etkilerini açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-290">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="12b5e-291">DDD terminolojisini kullanmak için, bir veya birden çok agrega da yan etkileri açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-291">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="12b5e-292">Ayrıca, daha iyi ölçeklenebilirlik ve veritabanı kilitleri üzerinde daha az etki için, aynı etki alanındaki agregalar arasında nihai tutarlılık kullanın.</span><span class="sxs-lookup"><span data-stu-id="12b5e-292">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

<span data-ttu-id="12b5e-293">Başvuru uygulaması, etki alanı olaylarını tek bir işlem içinde, toplu olarak eşzamanlı olarak yaymak için [MediatR'ı](https://github.com/jbogard/MediatR) kullanır.</span><span class="sxs-lookup"><span data-stu-id="12b5e-293">The reference app uses [MediatR](https://github.com/jbogard/MediatR) to propagate domain events synchronously across aggregates, within a single transaction.</span></span> <span data-ttu-id="12b5e-294">Ancak, etki alanı olaylarını eşzamanlı olarak yaymak için [RabbitMQ](https://www.rabbitmq.com/) veya [Azure Hizmet Veri Servisi](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) gibi bazı AMQP uygulamalarını da kullanabilirsiniz, ancak yukarıda da belirtildiği gibi, hata durumunda telafi edici eylemlere ihtiyaç duymanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="12b5e-294">However, you could also use some AMQP implementation like [RabbitMQ](https://www.rabbitmq.com/) or [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) to propagate domain events asynchronously, using eventual consistency but, as mentioned above, you have to consider the need for compensatory actions in case of failures.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="12b5e-295">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="12b5e-295">Additional resources</span></span>

- <span data-ttu-id="12b5e-296">**Greg Young' ı. Etki Alanı Etkinliği nedir?**</span><span class="sxs-lookup"><span data-stu-id="12b5e-296">**Greg Young. What is a Domain Event?**</span></span> \
  <https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25>

- <span data-ttu-id="12b5e-297">**Jan Stenberg. Etki Alanı Olayları ve Nihai Tutarlılık** </span><span class="sxs-lookup"><span data-stu-id="12b5e-297">**Jan Stenberg. Domain Events and Eventual Consistency** </span></span>\
  <https://www.infoq.com/news/2015/09/domain-events-consistency>

- <span data-ttu-id="12b5e-298">**Jimmy Bogard' ı. Daha iyi bir etki alanı olayları deseni** </span><span class="sxs-lookup"><span data-stu-id="12b5e-298">**Jimmy Bogard. A better domain events pattern** </span></span>\
  <https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/>

- <span data-ttu-id="12b5e-299">**Vaughn Vernon' u. Etkili Agrega Tasarımı Bölüm II: Agregaların Birlikte Çalışmasını Sağlamak** </span><span class="sxs-lookup"><span data-stu-id="12b5e-299">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** </span></span>\
  [https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="12b5e-300">**Jimmy Bogard' ı. Etki alanınızı güçlendirme: Etki Alanı Etkinlikleri** </span><span class="sxs-lookup"><span data-stu-id="12b5e-300">**Jimmy Bogard. Strengthening your domain: Domain Events** </span></span>\
  <https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>

- <span data-ttu-id="12b5e-301">**Tony Truong' ı. Etki Alanı Olayları Desen Örneği** </span><span class="sxs-lookup"><span data-stu-id="12b5e-301">**Tony Truong. Domain Events Pattern Example** </span></span>\
  <https://www.tonytruong.net/domain-events-pattern-example/>

- <span data-ttu-id="12b5e-302">**Udi Dahan. Tam kapsüllü Etki Alanı Modelleri nasıl oluşturulur?** </span><span class="sxs-lookup"><span data-stu-id="12b5e-302">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

- <span data-ttu-id="12b5e-303">**Udi Dahan. Etki Alanı Etkinlikleri – Take 2** </span><span class="sxs-lookup"><span data-stu-id="12b5e-303">**Udi Dahan. Domain Events – Take 2** </span></span>\
  <http://udidahan.com/2008/08/25/domain-events-take-2/>

- <span data-ttu-id="12b5e-304">**Udi Dahan. Etki Alanı Etkinlikleri – Kurtuluş** </span><span class="sxs-lookup"><span data-stu-id="12b5e-304">**Udi Dahan. Domain Events – Salvation** </span></span>\
  <http://udidahan.com/2009/06/14/domain-events-salvation/>

- <span data-ttu-id="12b5e-305">**Jan Kronquist. Etki Alanı Etkinlikleri'ni yayımlamayın, iade edin!**</span><span class="sxs-lookup"><span data-stu-id="12b5e-305">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  <https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/>

- <span data-ttu-id="12b5e-306">**Cesar de la Torre. DDD ve mikro hizmet mimarilerinde Etki Alanı Etkinlikleri ve Tümleştirme Etkinlikleri** </span><span class="sxs-lookup"><span data-stu-id="12b5e-306">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** </span></span>\
  <https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/>

>[!div class="step-by-step"]
><span data-ttu-id="12b5e-307">[Önceki](client-side-validation.md)
>[Sonraki](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="12b5e-307">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>
