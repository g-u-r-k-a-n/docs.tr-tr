---
title: Uygulama dayanıklılığı desenleri
description: Azure için Cloud Native .NET uygulamaları tasarlama | Uygulama dayanıklılığı desenleri
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: bb72e47704c833a2ce86f103a66b0414ce3a37ff
ms.sourcegitcommit: 27db07ffb26f76912feefba7b884313547410db5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 05/19/2020
ms.locfileid: "83614336"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="e5edf-103">Uygulama dayanıklılığı desenleri</span><span class="sxs-lookup"><span data-stu-id="e5edf-103">Application resiliency patterns</span></span>

<span data-ttu-id="e5edf-104">İlk savunma hattı uygulama dayanıklılığı ' dır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-104">The first line of defense is application resiliency.</span></span>

<span data-ttu-id="e5edf-105">Kendi dayanıklılık çatısını yazarken önemli ölçüde yatırım yapabilirsiniz, ancak bu tür ürünler zaten var.</span><span class="sxs-lookup"><span data-stu-id="e5edf-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="e5edf-106">[Polly](http://www.thepollyproject.org/) , geliştiricilerin dayanıklılık ilkelerini akıcı ve iş parçacığı açısından güvenli bir şekilde ifade etmesine olanak tanıyan kapsamlı bir .net esnekliği ve geçici hata işleme kitaplığıdır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-106">[Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="e5edf-107">.NET Framework veya .NET Core ile oluşturulan uygulamaları Polly hedefler.</span><span class="sxs-lookup"><span data-stu-id="e5edf-107">Polly targets applications built with either the .NET Framework or .NET Core.</span></span> <span data-ttu-id="e5edf-108">Aşağıdaki tabloda `policies` , Polly kitaplığı 'nda bulunan olarak adlandırılan dayanıklılık özellikleri açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-108">The following table describes the resiliency features, called `policies`, available in the Polly Library.</span></span> <span data-ttu-id="e5edf-109">Bunlar ayrı ayrı uygulanabilir veya birlikte gruplandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-109">They can be applied individually or grouped together.</span></span>

| <span data-ttu-id="e5edf-110">İlke</span><span class="sxs-lookup"><span data-stu-id="e5edf-110">Policy</span></span> | <span data-ttu-id="e5edf-111">Deneyim</span><span class="sxs-lookup"><span data-stu-id="e5edf-111">Experience</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="e5edf-112">Yeniden Dene</span><span class="sxs-lookup"><span data-stu-id="e5edf-112">Retry</span></span> | <span data-ttu-id="e5edf-113">Belirlenen işlemlerde yeniden deneme işlemlerini yapılandırır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-113">Configures retry operations on designated operations.</span></span> |
| <span data-ttu-id="e5edf-114">Devre Kesici</span><span class="sxs-lookup"><span data-stu-id="e5edf-114">Circuit Breaker</span></span> | <span data-ttu-id="e5edf-115">Hatalar yapılandırılan eşiği aştığında önceden tanımlanmış bir süre için istenen işlemleri engeller</span><span class="sxs-lookup"><span data-stu-id="e5edf-115">Blocks requested operations for a predefined period when faults exceed a configured threshold</span></span> |
| <span data-ttu-id="e5edf-116">Zaman aşımı</span><span class="sxs-lookup"><span data-stu-id="e5edf-116">Timeout</span></span> | <span data-ttu-id="e5edf-117">Bir arayanın yanıt bekleneceği süreye göre sınır koyar.</span><span class="sxs-lookup"><span data-stu-id="e5edf-117">Places limit on the duration for which a caller can wait for a response.</span></span> |
| <span data-ttu-id="e5edf-118">Bölme Perdesi</span><span class="sxs-lookup"><span data-stu-id="e5edf-118">Bulkhead</span></span> | <span data-ttu-id="e5edf-119">Bir kaynağın çok fazla başarısız olan aramalarını engellemek için eylemleri sabit boyutlu kaynak havuzuna kısıtlar.</span><span class="sxs-lookup"><span data-stu-id="e5edf-119">Constrains actions to fixed-size resource pool to prevent failing calls from swamping a resource.</span></span> |
| <span data-ttu-id="e5edf-120">Önbellek</span><span class="sxs-lookup"><span data-stu-id="e5edf-120">Cache</span></span> | <span data-ttu-id="e5edf-121">Yanıtları otomatik olarak depolar.</span><span class="sxs-lookup"><span data-stu-id="e5edf-121">Stores responses automatically.</span></span> |
| <span data-ttu-id="e5edf-122">Geri dönüş</span><span class="sxs-lookup"><span data-stu-id="e5edf-122">Fallback</span></span> | <span data-ttu-id="e5edf-123">Hata durumunda yapılandırılmış davranışı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e5edf-123">Defines structured behavior upon a failure.</span></span> |

<span data-ttu-id="e5edf-124">Önceki şekilde, bir dış istemciden veya arka uç hizmetinden gelen istek iletilerine yönelik dayanıklılık ilkelerinin nasıl uygulanacağını göz önünde bulun.</span><span class="sxs-lookup"><span data-stu-id="e5edf-124">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or back-end service.</span></span> <span data-ttu-id="e5edf-125">Amaç, geçici olarak kullanılamayan bir hizmet için isteği telafi olmaktır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-125">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="e5edf-126">Bu kısa süreli kesintiler tipik olarak, aşağıdaki tabloda gösterilen HTTP durum kodlarıyla birlikte yapılır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-126">These short-lived interruptions typically manifest themselves with the HTTP status codes shown in the following table.</span></span>

| <span data-ttu-id="e5edf-127">HTTP durum kodu</span><span class="sxs-lookup"><span data-stu-id="e5edf-127">HTTP Status Code</span></span>| <span data-ttu-id="e5edf-128">Nedeni</span><span class="sxs-lookup"><span data-stu-id="e5edf-128">Cause</span></span> |
| :-------- | :-------- |
| <span data-ttu-id="e5edf-129">404</span><span class="sxs-lookup"><span data-stu-id="e5edf-129">404</span></span> | <span data-ttu-id="e5edf-130">Bulunamadı</span><span class="sxs-lookup"><span data-stu-id="e5edf-130">Not Found</span></span> |
| <span data-ttu-id="e5edf-131">408</span><span class="sxs-lookup"><span data-stu-id="e5edf-131">408</span></span> | <span data-ttu-id="e5edf-132">İstek zaman aşımı</span><span class="sxs-lookup"><span data-stu-id="e5edf-132">Request timeout</span></span> |
| <span data-ttu-id="e5edf-133">429</span><span class="sxs-lookup"><span data-stu-id="e5edf-133">429</span></span> | <span data-ttu-id="e5edf-134">Çok fazla istek (büyük olasılıkla kısıtlamış olabilirsiniz)</span><span class="sxs-lookup"><span data-stu-id="e5edf-134">Too many requests (you've most likely been throttled)</span></span> |
| <span data-ttu-id="e5edf-135">502</span><span class="sxs-lookup"><span data-stu-id="e5edf-135">502</span></span> | <span data-ttu-id="e5edf-136">Hatalı ağ geçidi</span><span class="sxs-lookup"><span data-stu-id="e5edf-136">Bad gateway</span></span> |
| <span data-ttu-id="e5edf-137">503</span><span class="sxs-lookup"><span data-stu-id="e5edf-137">503</span></span> | <span data-ttu-id="e5edf-138">Hizmet kullanılamıyor</span><span class="sxs-lookup"><span data-stu-id="e5edf-138">Service unavailable</span></span> |
| <span data-ttu-id="e5edf-139">504</span><span class="sxs-lookup"><span data-stu-id="e5edf-139">504</span></span> | <span data-ttu-id="e5edf-140">Ağ geçidi zaman aşımı</span><span class="sxs-lookup"><span data-stu-id="e5edf-140">Gateway timeout</span></span> |

<span data-ttu-id="e5edf-141">Soru: 403-Yasak HTTP durum kodunu yeniden denesin mi?</span><span class="sxs-lookup"><span data-stu-id="e5edf-141">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="e5edf-142">Hayır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-142">No.</span></span> <span data-ttu-id="e5edf-143">Burada, sistem düzgün şekilde çalışır, ancak çağrıyı yapana istenen işlemi gerçekleştirme yetkisine sahip olmadıkları konusunda bilgilendirilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-143">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="e5edf-144">Yalnızca hatalardan kaynaklanan işlemleri yeniden denemek için dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-144">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="e5edf-145">Bölüm 1 ' de önerildiği gibi, bulutta yerel uygulamalar oluştururken Microsoft geliştiricilerinin .NET Core platformunu hedeflemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-145">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target the .NET Core platform.</span></span> <span data-ttu-id="e5edf-146">Sürüm 2,1, URL tabanlı kaynaklarla etkileşim kurmak için HTTP Istemci örnekleri oluşturmak üzere [Httpclientfactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) kitaplığı 'nı kullanıma sunmuştur.</span><span class="sxs-lookup"><span data-stu-id="e5edf-146">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="e5edf-147">Özgün HTTPClient sınıfını yerine, Factory sınıfı birçok gelişmiş özelliği destekler, bunlardan biri de Polly dayanıklılık kitaplığıyla [sıkı bir şekilde tümleştirilmiştir](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) .</span><span class="sxs-lookup"><span data-stu-id="e5edf-147">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="e5edf-148">Bununla birlikte, kısmi hataları ve bağlantı sorunlarını ele almak için uygulama başlangıç sınıfındaki dayanıklılık ilkelerini kolayca tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e5edf-148">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="e5edf-149">Sonra, yeniden deneme ve devre kesici desenlerinde genişletelim.</span><span class="sxs-lookup"><span data-stu-id="e5edf-149">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="e5edf-150">Yeniden deneme düzeni</span><span class="sxs-lookup"><span data-stu-id="e5edf-150">Retry pattern</span></span>

<span data-ttu-id="e5edf-151">Dağıtılmış bir bulutta yerel ortamda, hizmet ve bulut kaynaklarına yapılan çağrılar, genellikle kısa bir süre sonra kendilerini düzelttiğinden geçici (kısa süreli) hatalardan dolayı başarısız olabilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-151">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="e5edf-152">Yeniden deneme stratejisi uygulamak, bulutta yerel bir hizmetin bu senaryoları azaltmasının sağlanmasına yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="e5edf-152">Implementing a retry strategy helps a cloud-native service mitigate these scenarios.</span></span>

<span data-ttu-id="e5edf-153">[Yeniden deneme](https://docs.microsoft.com/azure/architecture/patterns/retry) sürümü, bir hizmetin başarısız istek işlemini yeniden denemesini sağlar (yapılandırılabilir) ve bir bekleme süresini üstel olarak artırır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-153">The [Retry pattern](https://docs.microsoft.com/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="e5edf-154">Şekil 6-2, bir yeniden deneme işlemini gösterir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-154">Figure 6-2 shows a retry in action.</span></span>

![Yeniden deneme deseninin eylemi](./media/retry-pattern.png)

<span data-ttu-id="e5edf-156">**Şekil 6-2**.</span><span class="sxs-lookup"><span data-stu-id="e5edf-156">**Figure 6-2**.</span></span> <span data-ttu-id="e5edf-157">Yeniden deneme deseninin eylemi</span><span class="sxs-lookup"><span data-stu-id="e5edf-157">Retry pattern in action</span></span>

<span data-ttu-id="e5edf-158">Önceki şekilde, bir istek işlemi için yeniden deneme biçimi uygulandı.</span><span class="sxs-lookup"><span data-stu-id="e5edf-158">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="e5edf-159">Bir geri alma aralığı (bekleme süresi) ile başarısız olmadan önce, sonraki her denemede katlanarak çift yönlü olan iki saniyeden oluşan en fazla dört denemeye izin verecek şekilde yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-159">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="e5edf-160">İlk çağırma başarısız olur ve 500 HTTP durum kodunu döndürür.</span><span class="sxs-lookup"><span data-stu-id="e5edf-160">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="e5edf-161">Uygulama iki saniye bekler ve çağrıyı yeniden dener.</span><span class="sxs-lookup"><span data-stu-id="e5edf-161">The application waits for two seconds and retries the call.</span></span>
- <span data-ttu-id="e5edf-162">İkinci çağrı da başarısız olur ve 500 HTTP durum kodunu döndürür.</span><span class="sxs-lookup"><span data-stu-id="e5edf-162">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="e5edf-163">Uygulama artık geri alma aralığını dört saniyeye ikiye katlanır ve çağrıyı yeniden dener.</span><span class="sxs-lookup"><span data-stu-id="e5edf-163">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="e5edf-164">Son olarak, üçüncü çağrı başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="e5edf-164">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="e5edf-165">Bu senaryoda, yeniden deneme işlemi, çağrı başarısız olmadan önce geri alma süresini ikiye katlarken dört yeniden denemeye girişdi.</span><span class="sxs-lookup"><span data-stu-id="e5edf-165">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>
- <span data-ttu-id="e5edf-166">4 yeniden deneme denemesi başarısız oldu, sorunu düzgün şekilde işlemek için bir geri dönüş ilkesi çağırılır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-166">Had the 4th retry attempt failed, a fallback policy would be invoked to gracefully handle the problem.</span></span>

<span data-ttu-id="e5edf-167">Hizmet süresinin kendine doğru olması için çağrıyı yeniden denemeden önce geri alma döneminin artırılması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-167">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="e5edf-168">Yeterli düzeltme süresine izin vermek için, sınırsız bir şekilde artan bir artırma (her yeniden denemeli dönemi katlama) uygulamak en iyi uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-168">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="e5edf-169">Devre kesici stili</span><span class="sxs-lookup"><span data-stu-id="e5edf-169">Circuit breaker pattern</span></span>

<span data-ttu-id="e5edf-170">Yeniden deneme stili, bir isteği kısmi bir hata halinde ölçeklendirmesine yardımcı olmakla kalmaz, hataların daha uzun süre içinde çözülmesi gereken beklenmeyen olaylar nedeniyle hatalara neden olabilecek durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-170">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="e5edf-171">Bu hataların önem derecesi kısmi bağlantı kaybıyla bir hizmetin tamamen çökmesi arasında değişebilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-171">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="e5edf-172">Bu durumlarda, bir uygulamanın başarılı olması olası olmayan bir işlemi sürekli olarak yeniden denemesi için daha az kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-172">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="e5edf-173">Kötü, yanıt vermeyen bir hizmette sürekli yeniden deneme işlemleri gerçekleştirmek için, önemli olmayan bir hizmette sürekli olarak gerçekleştirilen bir hizmet reddi senaryosuna taşınabilir ve bu da, bellek, iş parçacıkları ve veritabanı bağlantıları gibi kaynakları tüketerek, aynı kaynakları kullanan sistemin ilgisiz kısımlarında hata oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-173">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="e5edf-174">Bu durumlarda, işlemin hemen başarısız olması ve yalnızca başarılı olma olasılığı varsa hizmeti çağırmayı denemesi tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-174">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="e5edf-175">[Devre kesici stili](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) , bir uygulamanın başarısız olma olasılığı olan bir işlemi tekrar tekrar yürütmeye engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-175">The [Circuit Breaker pattern](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="e5edf-176">Önceden tanımlı bir dizi başarısız çağrı yapıldıktan sonra, hizmete giden tüm trafiği engeller.</span><span class="sxs-lookup"><span data-stu-id="e5edf-176">After a pre-defined number of failed calls, it blocks all traffic to the service.</span></span> <span data-ttu-id="e5edf-177">Düzenli aralıklarla, hatanın çözümlenip çözümlenmediğini tespit etmek için bir deneme çağrısına izin verir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-177">Periodically, it will allow a trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="e5edf-178">Şekil 6-3, devre kesici düzeninin eylemde olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-178">Figure 6-3 shows the Circuit Breaker pattern in action.</span></span>

![Devreye ayırıcı stili eylem içinde](./media/circuit-breaker-pattern.png)

<span data-ttu-id="e5edf-180">**Şekil 6-3**.</span><span class="sxs-lookup"><span data-stu-id="e5edf-180">**Figure 6-3**.</span></span> <span data-ttu-id="e5edf-181">Devreye ayırıcı stili eylem içinde</span><span class="sxs-lookup"><span data-stu-id="e5edf-181">Circuit breaker pattern in action</span></span>

<span data-ttu-id="e5edf-182">Önceki şekilde, özgün yeniden deneme düzenine bir devre kesici stili eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-182">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="e5edf-183">100 başarısız isteklerin nasıl yapılacağı, devre kesicilerin açılmadığını ve hizmete çağrı yapılmasına izin vermez.</span><span class="sxs-lookup"><span data-stu-id="e5edf-183">Note how after 100 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="e5edf-184">Checkdevresi değeri 30 saniye olarak ayarlandığında, kitaplığın bir isteğin hizmete ne sıklıkta devam etmesine izin verdiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-184">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="e5edf-185">Bu çağrı başarılı olursa, devre kapanır ve hizmet tekrar trafik için kullanılabilir olur.</span><span class="sxs-lookup"><span data-stu-id="e5edf-185">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="e5edf-186">Devre kesici deseninin amacını, yeniden deneme düzeninden *farklı* olduğunu aklınızda bulundurun.</span><span class="sxs-lookup"><span data-stu-id="e5edf-186">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="e5edf-187">Yeniden deneme stili, bir uygulamanın başarılı olacağı beklentide bir işlemi yeniden denemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="e5edf-187">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="e5edf-188">Devre kesici stili, bir uygulamanın başarısız olma olasılığı olan bir işlem gerçekleştirmesini engeller.</span><span class="sxs-lookup"><span data-stu-id="e5edf-188">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="e5edf-189">Genellikle, bir uygulama devre kesici aracılığıyla bir işlemi çağırmak için yeniden deneme desenini kullanarak bu iki deseni *birleştirir* .</span><span class="sxs-lookup"><span data-stu-id="e5edf-189">Typically, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span>

## <a name="testing-for-resiliency"></a><span data-ttu-id="e5edf-190">Dayanıklılığı test etme</span><span class="sxs-lookup"><span data-stu-id="e5edf-190">Testing for resiliency</span></span>

<span data-ttu-id="e5edf-191">Dayanıklılık testi, uygulama işlevlerini test ettiğiniz şekilde (birim testlerini, tümleştirme testlerini vb.) her zaman yapılamaz.</span><span class="sxs-lookup"><span data-stu-id="e5edf-191">Testing for resiliency cannot always be done the same way that you test application functionality (by running unit tests, integration tests and so on).</span></span> <span data-ttu-id="e5edf-192">Bunun yerine, yalnızca zaman zaman ortaya çıkan hata koşulları altında uçtan uca iş yükünün ne performans göstereceğini test etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-192">Instead, you must test how the end-to-end workload performs under failure conditions which only occur intermittently.</span></span> <span data-ttu-id="e5edf-193">Örneğin: işlemlere kilitlenme, süre dolma sertifikaları, bağımlı hizmetleri kullanılamaz hale getirerek ekleme. [Chaos-maymun](https://github.com/Netflix/chaosmonkey) gibi çerçeveler, böyle bir Chaos testi için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-193">For example: inject failures by crashing processes, expired certificates, make dependent services unavailable etc. Frameworks like [chaos-monkey](https://github.com/Netflix/chaosmonkey) can be used for such chaos testing.</span></span>

<span data-ttu-id="e5edf-194">Uygulama dayanıklılığı, sorunlu istenen işlemleri işlemek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="e5edf-194">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="e5edf-195">Ancak, hikayenin yalnızca yarısı vardır.</span><span class="sxs-lookup"><span data-stu-id="e5edf-195">But, it's only half of the story.</span></span> <span data-ttu-id="e5edf-196">Daha sonra, Azure bulutu 'nda bulunan dayanıklılık özelliklerini ele aldık.</span><span class="sxs-lookup"><span data-stu-id="e5edf-196">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e5edf-197">[Önceki](resiliency.md) 
> [Sonraki](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="e5edf-197">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
