---
title: Bulutta yerel veri desenleri
description: Azure için Cloud Native .NET uygulamaları tasarlama | Bulutta yerel veri desenleri
ms.date: 06/30/2019
ms.openlocfilehash: 0d251f3046fcd3f3a2f5d856a123a35d3f7ecff2
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73087697"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="a5081-103">Bulutta yerel veri desenleri</span><span class="sxs-lookup"><span data-stu-id="a5081-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="a5081-104">Veri merkezi olmayan veriler, geliştirilmiş performans, ölçeklenebilirlik ve maliyet tasarruflarına yol açacağından, birçok zorluk da sunar.</span><span class="sxs-lookup"><span data-stu-id="a5081-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="a5081-105">Mikro hizmetler genelinde veri sorgulama karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="a5081-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="a5081-106">Mikro hizmetleri kapsayan bir işlem, dağıtılmış işlemler bulutta yerel uygulamalarda desteklenmediğinden programlı bir şekilde yönetilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a5081-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="a5081-107">*Anında tutarlılık* dünyasının *nihai tutarlılığa*geçiş yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a5081-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="a5081-108">Bu güçlükleri şimdi tartıştık.</span><span class="sxs-lookup"><span data-stu-id="a5081-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="a5081-109">Çapraz hizmet sorguları</span><span class="sxs-lookup"><span data-stu-id="a5081-109">Cross-service queries</span></span>

<span data-ttu-id="a5081-110">Bir uygulama çok sayıda bağımsız mikro hizmete yayılan verileri nasıl sorgular?</span><span class="sxs-lookup"><span data-stu-id="a5081-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="a5081-111">Şekil 5-4, bu senaryoyu gösterir.</span><span class="sxs-lookup"><span data-stu-id="a5081-111">Figure 5-4 shows this scenario.</span></span>

![Mikro hizmetler genelinde sorgulama](./media/cross-service-query.png)

<span data-ttu-id="a5081-113">**Şekil 5-4**.</span><span class="sxs-lookup"><span data-stu-id="a5081-113">**Figure 5-4**.</span></span> <span data-ttu-id="a5081-114">Mikro hizmetler genelinde sorgulama</span><span class="sxs-lookup"><span data-stu-id="a5081-114">Querying across microservices</span></span>

<span data-ttu-id="a5081-115">Önceki şekilde bir kullanıcının alışveriş sepetine bir öğe ekleyen bir alışveriş sepeti mikro hizmeti görtiğimiz hakkında bilgi alın.</span><span class="sxs-lookup"><span data-stu-id="a5081-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="a5081-116">Alışveriş sepetinin veri deposu bir sepet ve LineItem tablosu içerdiğinde, bu öğeler üründe ve fiyat mikro hizmetlerinde bulunduğundan ürün veya fiyatlandırma verilerini içermez.</span><span class="sxs-lookup"><span data-stu-id="a5081-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="a5081-117">Bir öğe eklemek için, alışveriş sepeti mikro hizmeti ürün verilerine ve fiyatlandırma verilerine ihtiyaç duyuyor.</span><span class="sxs-lookup"><span data-stu-id="a5081-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="a5081-118">Ürün ve fiyatlandırma verilerini almaya yönelik seçenekler nelerdir?</span><span class="sxs-lookup"><span data-stu-id="a5081-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="a5081-119">Şekil 5-5, ürün kataloğu ve fiyatlandırma mikro hizmetleri için doğrudan HTTP çağrısı yapan alışveriş sepeti mikro hizmetini gösterir.</span><span class="sxs-lookup"><span data-stu-id="a5081-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Doğrudan HTTP iletişimi](./media/direct-http-communication.png)

<span data-ttu-id="a5081-121">**Şekil 5-5**.</span><span class="sxs-lookup"><span data-stu-id="a5081-121">**Figure 5-5**.</span></span> <span data-ttu-id="a5081-122">Doğrudan HTTP iletişimi</span><span class="sxs-lookup"><span data-stu-id="a5081-122">Direct HTTP communication</span></span>

<span data-ttu-id="a5081-123">Uygulama için uygun olsa da, Bölüm 4 ' te, mikro hizmetler genelinde doğrudan HTTP çağrılarının sistem tarafından ne kadar iyi bir uygulama olarak düşünüldük.</span><span class="sxs-lookup"><span data-stu-id="a5081-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="a5081-124">Şekil 5-6 ' de gösterilen bir toplayıcı mikro hizmeti uygulayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="a5081-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Toplayıcı mikro hizmeti](./media/aggregator-microservice.png)

<span data-ttu-id="a5081-126">**Şekil 5-6.**</span><span class="sxs-lookup"><span data-stu-id="a5081-126">**Figure 5-6.**</span></span> <span data-ttu-id="a5081-127">Toplayıcı mikro hizmeti</span><span class="sxs-lookup"><span data-stu-id="a5081-127">Aggregator microservice</span></span>

<span data-ttu-id="a5081-128">Bu yaklaşım, tek bir mikro hizmette iş işlemi iş akışını kapsüller, ancak doğrudan HTTP çağrılarına neden olan karmaşıklığa sahiptir.</span><span class="sxs-lookup"><span data-stu-id="a5081-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="a5081-129">Çapraz hizmet sorgularını yürütmeye yönelik yaygın bir yaklaşım, Şekil 5-7 ' de gösterilen [gerçekleştirilmiş görünüm düzenlerini](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)kullanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Gerçekleştirilmiş görünüm deseninin](./media/materialized-view-pattern.png)

<span data-ttu-id="a5081-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="a5081-131">**Figure5-7**.</span></span> <span data-ttu-id="a5081-132">Gerçekleştirilmiş görünüm deseninin</span><span class="sxs-lookup"><span data-stu-id="a5081-132">Materialized View Pattern</span></span>

<span data-ttu-id="a5081-133">Bu düzende, ürün ve fiyatlandırma mikro hizmetleri için gereken verilerin yoğun bir kopyasını içeren alışveriş sepeti hizmetine doğrudan bir yerel tablo ( *okuma modeli*olarak bilinir) yerleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a5081-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="a5081-134">Bu verilerin alışveriş sepeti mikro hizmeti içine yerleştirilmesi, pahalı çapraz hizmet çağrılarını çağırma gereksinimini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="a5081-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="a5081-135">Hizmetin yerel verileri ile yanıt süresini ve güvenilirliği geliştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a5081-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="a5081-136">Bu yaklaşım ile catch, artık sisteminizde Yinelenen veriler var.</span><span class="sxs-lookup"><span data-stu-id="a5081-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="a5081-137">Bulutta yerel sistemlerde Yinelenen veriler bir [kenar yumuşatma](https://en.wikipedia.org/wiki/Anti-pattern) kabul edilmez ve genellikle bulutta yerel sistemlerde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="a5081-138">Ancak, bir ve yalnızca bir sistem herhangi bir veri kümesinin sahibi olabilir ve temel alınan verilerde yapılan her değişiklik gerçekleştiğinde ilişkili tüm okuma modellerini güncelleştirmek için kayıt sistemine yönelik bir eşitleme mekanizması uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a5081-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="a5081-139">İşlem desteği</span><span class="sxs-lookup"><span data-stu-id="a5081-139">Transactional support</span></span>

<span data-ttu-id="a5081-140">Mikro hizmetler genelinde sorgular zorlayıcı olsa da, mikro hizmetler genelinde bir işlem uygulamak karmaşık olabilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="a5081-141">Farklı mikro hizmetlerde bulunan veri kaynakları arasında veri tutarlılığı sağlamanın devralınmış bir şekilde belirtilmedi.</span><span class="sxs-lookup"><span data-stu-id="a5081-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="a5081-142">Şekil 5-8 sorunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="a5081-142">Figure 5-8 shows the problem.</span></span>

![Saga düzeninde işlem](./media/saga-transaction-operation.png)

<span data-ttu-id="a5081-144">**Şekil 5-8**.</span><span class="sxs-lookup"><span data-stu-id="a5081-144">**Figure 5-8**.</span></span> <span data-ttu-id="a5081-145">Mikro hizmetler genelinde işlem uygulama</span><span class="sxs-lookup"><span data-stu-id="a5081-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="a5081-146">Önceki şekilde beş bağımsız mikro hizmetin her türlü dağıtılmış bir *Sipariş oluşturma* işlemine nasıl katıldığına göz önünde.</span><span class="sxs-lookup"><span data-stu-id="a5081-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="a5081-147">Ancak, her bir beş tek mikro hizmetin işlemi başarılı olmalıdır veya tümü iptal ve işlemi geri alma olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a5081-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll-back the operation.</span></span> <span data-ttu-id="a5081-148">Mikro hizmetlerin her birinde yerleşik işlem desteği kullanılabilir olsa da, beş hizmetin tümünde dağıtılmış işlem desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="a5081-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="a5081-149">Bu işlem için işlem desteği, verileri mikro hizmetlerde her birinde tutarlı tutmak için gerekli olduğundan, programlı bir şekilde dağıtılmış işlem oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a5081-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="a5081-150">İşlem desteğini programlı olarak eklemeye yönelik popüler bir model, [Saga örüntü](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="a5081-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="a5081-151">Yerel işlemler birlikte gruplanarak ve her biri sırayla çağırılırken uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="a5081-152">Yerel bir işlem başarısız olursa, Saga işlemi iptal eder ve önceki yerel işlemler tarafından yapılan değişiklikleri geri almak için bir [dengeleyici](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) işlem kümesi çağırır.</span><span class="sxs-lookup"><span data-stu-id="a5081-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="a5081-153">Şekil 5-9, Saga düzeniyle başarısız olan bir işlemi gösterir.</span><span class="sxs-lookup"><span data-stu-id="a5081-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Saga düzeninde geri alma](./media/saga-rollback-operation.png)

<span data-ttu-id="a5081-155">**Şekil 5-9**.</span><span class="sxs-lookup"><span data-stu-id="a5081-155">**Figure 5-9**.</span></span> <span data-ttu-id="a5081-156">Bir işlem geri alınıyor</span><span class="sxs-lookup"><span data-stu-id="a5081-156">Rolling back a transaction</span></span>

<span data-ttu-id="a5081-157">Önceki şekilde, müzik mikro hizmetinde *Generatecontent* işleminin başarısız olduğunu aklınızda edin.</span><span class="sxs-lookup"><span data-stu-id="a5081-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="a5081-158">Saga, içeriği kaldırmak için telafi işlemlerini (kırmızı renkte) çağırır, ödemeyi iptal eder ve her bir mikro hizmet için verileri tutarlı bir duruma geri döndürerek sırayı iptal eder.</span><span class="sxs-lookup"><span data-stu-id="a5081-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="a5081-159">Saga desenleri genellikle bir dizi ilgili olay olarak ayarlanabilir veya ilgili komutlar kümesi olarak düzenlenir.</span><span class="sxs-lookup"><span data-stu-id="a5081-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="a5081-160">CQRS stili</span><span class="sxs-lookup"><span data-stu-id="a5081-160">CQRS pattern</span></span>

<span data-ttu-id="a5081-161">CQRS veya [komut ve sorgu sorumluluklarının ayrılığı](https://docs.microsoft.com/azure/architecture/patterns/cqrs), verileri yazanlardan verileri okuyan işlemleri ayıran mimari bir modeldir.</span><span class="sxs-lookup"><span data-stu-id="a5081-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="a5081-162">Bu model performans, ölçeklenebilirlik ve güvenliğin en üst düzeye çıkmasına yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="a5081-163">Normal veri erişimi senaryolarında, hem okuma hem *de* yazma veri işlemlerini gerçekleştiren tek bir model (varlık ve depo nesnesi) uygulacağınızı görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="a5081-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="a5081-164">Ancak, daha gelişmiş bir veri erişim senaryosu, okuma ve yazma işlemleri için ayrı modellerden ve veri tablolarından faydalanabilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="a5081-165">Performansı artırmak için, *sorgu*olarak bilinen okuma işlemi, pahalı yinelenen tablo birleştirmelerini önlemek için verilerin yüksek oranda büyük bir gösterimine karşı sorgu gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="a5081-166">*Komut*olarak bilinen *yazma* işlemi, verilerin tamamen normalleştirilmiş bir gösterimine karşı güncelleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="a5081-167">Ardından her iki gösterimi de eşitlenmiş halde tutmak için bir mekanizma uygulamanız gerekir. Genellikle, yazma tablosu her değiştirildiğinde, veri değişikliğini okuma tablosuna çoğaltan bir olay oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a5081-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="a5081-168">Şekil 5-10, CQRS deseninin bir uygulamasını gösterir.</span><span class="sxs-lookup"><span data-stu-id="a5081-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![CQRS uygulama](./media/cqrs-implementation.png)

<span data-ttu-id="a5081-170">**Şekil 5-10**.</span><span class="sxs-lookup"><span data-stu-id="a5081-170">**Figure 5-10**.</span></span> <span data-ttu-id="a5081-171">CQRS uygulama</span><span class="sxs-lookup"><span data-stu-id="a5081-171">CQRS implementation</span></span>

<span data-ttu-id="a5081-172">Önceki şekilde ayrı komut ve sorgu modellerinin nasıl uygulandığını aklınızda edin.</span><span class="sxs-lookup"><span data-stu-id="a5081-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="a5081-173">Üstelik, her veri yazma işlemi yazma deposuna kaydedilir ve sonra okuma deposuna yayılır.</span><span class="sxs-lookup"><span data-stu-id="a5081-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="a5081-174">Yayma işleminin [nihai tutarlılık](https://www.cloudcomputingpatterns.org/eventual_consistency/)ilkesi üzerinde nasıl çalıştığı hakkında daha fazla dikkat edin, ancak okuma modeli yazma modeliyle eşitlenir, ancak işlemde bazı gecikme olabilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="a5081-175">Ayrımı uygulayarak, okuma ve yazma işlemlerini ayrı olarak ölçeklendirmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="a5081-176">Ayrıca, yazma işlemlerinde okuma işlemleriyle daha sıkı güvenlik sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a5081-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="a5081-177">Genellikle, CQRS desenleri belirli gereksinimlere göre sisteminizin sınırlı bölümlerine uygulanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="a5081-178">İlişkisel vs NoSQL</span><span class="sxs-lookup"><span data-stu-id="a5081-178">Relational vs NoSQL</span></span>

<span data-ttu-id="a5081-179">[NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) teknolojilerinin etkisi, özellikle dağıtılmış bulut Yerel sistemleri için geçersiz şekilde belirtilemez.</span><span class="sxs-lookup"><span data-stu-id="a5081-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="a5081-180">Bu alandaki yeni veri teknolojilerinin bir şekilde, ilişkisel veritabanlarına özel olarak bir şekilde güvenilme çözümleri bozulur.</span><span class="sxs-lookup"><span data-stu-id="a5081-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="a5081-181">Bir tarafta ilişkisel veritabanları, Decades 'in yaygın bir teknolojisinden biridir.</span><span class="sxs-lookup"><span data-stu-id="a5081-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="a5081-182">Bunlar, Yetişkin, kanıtlanmış ve yaygın olarak uygulanan bir uygulamalılar.</span><span class="sxs-lookup"><span data-stu-id="a5081-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="a5081-183">Rekabet veritabanı ürünleri, uzmanlığı ve araç abounds.</span><span class="sxs-lookup"><span data-stu-id="a5081-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="a5081-184">İlişkisel veritabanları ilgili veri tablolarının bir deposunu sağlar.</span><span class="sxs-lookup"><span data-stu-id="a5081-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="a5081-185">Bu tablolar sabit bir şemaya sahiptir, verileri yönetmek için SQL (Yapılandırılmış Sorgu Dili) kullanın ve [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (Atomicity, tutarlılık, yalıtım ve dayanıklılık olarak da bilinir) garantisi vardır.</span><span class="sxs-lookup"><span data-stu-id="a5081-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="a5081-186">SQL veritabanları yok, diğer tarafta, yüksek performanslı, ilişkisel olmayan veri depolarına bakın.</span><span class="sxs-lookup"><span data-stu-id="a5081-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="a5081-187">Bu kişiler, kullanım kolaylığı, ölçeklenebilirlik, esnekliği ve kullanılabilirlik özellikleriyle Excel.</span><span class="sxs-lookup"><span data-stu-id="a5081-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="a5081-188">NoSQL, normalleştirilmiş verilerin tablolarını birleştirmek yerine, genellikle JSON belgelerinde kendi kendini açıklayan (schemaless) verileri depolar.</span><span class="sxs-lookup"><span data-stu-id="a5081-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="a5081-189">Bunlar, [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) garantisi sunmaz.</span><span class="sxs-lookup"><span data-stu-id="a5081-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="a5081-190">Bu tür veritabanları arasındaki farklılıkları anlamanın bir yolu, durumu depolayan dağıtılmış sistemlere uygulanabilen bir ilke kümesi olan üst [sınır](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e)içinde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="a5081-191">Şekil 5-11, CAP 'in üç özelliğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="a5081-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![CAP 'ler](./media/cap-theorem.png)

<span data-ttu-id="a5081-193">**Şekil 5-11**.</span><span class="sxs-lookup"><span data-stu-id="a5081-193">**Figure 5-11**.</span></span> <span data-ttu-id="a5081-194">Üst sınır</span><span class="sxs-lookup"><span data-stu-id="a5081-194">The CAP theorem</span></span>

<span data-ttu-id="a5081-195">Bu, herhangi bir dağıtılmış veri sisteminin tutarlılık, kullanılabilirlik ve bölüm toleransı arasında bir denge sunabileceğini ve herhangi bir veritabanının yalnızca iki özelliği garanti edebileceğini belirtir:</span><span class="sxs-lookup"><span data-stu-id="a5081-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="a5081-196">*Tutarlılık*: kümedeki her düğüm, tüm çoğaltmalar doğru şekilde güncelleştirilene kadar bir isteğin engellenmesini gerektirse bile en son verilerle yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="a5081-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="a5081-197">*Kullanılabilirlik*: her düğüm, bu yanıt en son veriler olmasa bile makul bir süre içinde yanıt döndürür.</span><span class="sxs-lookup"><span data-stu-id="a5081-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="a5081-198">*Bölüm toleransı*: bir düğüm başarısız olursa veya başka bir bağlantı kesilirse sistemin çalışmaya devam etmesini güvence altına alır.</span><span class="sxs-lookup"><span data-stu-id="a5081-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="a5081-199">İlişkisel veritabanları tutarlılık ve kullanılabilirlik sergiler, ancak bölüm toleransı sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="a5081-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="a5081-200">Parçalara ayırma gibi ilişkisel bir veritabanının bölümlenmesi zordur ve performansı etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="a5081-201">Öte yandan, NoSQL veritabanları genellikle yatay ölçeklenebilirlik ve yüksek kullanılabilirlik olarak bilinen bölüm dayanıklılığı sergiler.</span><span class="sxs-lookup"><span data-stu-id="a5081-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="a5081-202">CAP 'ler tarafından belirtildiği gibi, üç ilkeden yalnızca iki ilke olabilir ve tutarlılık özelliğini kaybedersiniz.</span><span class="sxs-lookup"><span data-stu-id="a5081-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="a5081-203">NoSQL veritabanları dağıtılır ve genellikle emtia sunucularında ölçeklendirilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="a5081-204">Bunun yapılması, hem coğrafi bölgeler içinde hem de daha düşük bir maliyetle büyük kullanılabilirlik sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="a5081-205">Veriler, bu makinelerde veya düğümlerde bölümlenebilir ve çoğaltılarak yedeklenebilir ve hataya dayanıklılık sağlar.</span><span class="sxs-lookup"><span data-stu-id="a5081-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="a5081-206">Downsıde, tutardır.</span><span class="sxs-lookup"><span data-stu-id="a5081-206">The downside is consistency.</span></span> <span data-ttu-id="a5081-207">Bir NoSQL düğümündeki verilerde yapılan değişikliğin, diğer düğümlere yayılması biraz zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="a5081-208">Genellikle, bir NoSQL veritabanı düğümü, sunum yaptığı veriler eski ve henüz güncelleştirilmemiş olsa bile bir sorguya anında yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="a5081-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="a5081-209">Bu, ACID işlemlerinin desteklenmediği dağıtılmış veri sistemlerinin bir özelliği olan, [nihai tutarlılık](https://www.cloudcomputingpatterns.org/eventual_consistency/)bilinmektedir.</span><span class="sxs-lookup"><span data-stu-id="a5081-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="a5081-210">Bu, bir veri öğesi güncelleştirmesi ve bu güncelleştirmenin her bir çoğaltma düğümüne yayılması için geçen süre arasında kısa bir gecikmeden oluşur.</span><span class="sxs-lookup"><span data-stu-id="a5081-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="a5081-211">Birleşik Devletler bir NoSQL veritabanında bir ürün öğesini güncelleştirirseniz, ancak aynı zamanda Avrupa 'daki bir çoğaltma düğümünden aynı veri öğesini sorgulayıp, Avrupa düğümü ürün değişikliği ile güncellenene kadar önceki ürün bilgilerini alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a5081-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="a5081-212">Bu denge, güçlü tutarlılık vererek, bir sorgu sonucu döndürmeden önce tüm çoğaltma düğümlerinin güncelleştirilmesini beklerken, büyük ölçekli ölçek ve trafik hacminin yanı sıra eski verileri sunma [olasılığından](https://en.wikipedia.org/wiki/Strong_consistency)de daha fazla bir şekilde destek alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a5081-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="a5081-213">NoSQL veritabanları aşağıdaki dört modele göre kategorize edilebilir:</span><span class="sxs-lookup"><span data-stu-id="a5081-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="a5081-214">*Belge deposu* (MongoDB, Couşdb, Couşbase): veriler (ve karşılık gelen meta veriler), veritabanının içindeki, kapsamdaki JSON tabanlı belgelerde ilişki dışı olarak depolanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="a5081-215">*Anahtar/değer deposu* (Redg, Riak, memönbelleğe alınmış): veriler, Kullanıcı verileri değeriyle eşlenen benzersiz bir erişim anahtarına karşı gerçekleştirilen sistem işlemlerine sahip basit anahtar-değer çiftlerine depolanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="a5081-216">*Geniş sütun deposu* (HBase, Cassandra): ilgili veriler, genellikle birden çok tabloya birlikte katılması gerekmeden tek bir sütun içinde iç içe geçmiş anahtar/değer çiftleri kümesi olarak bir sütunlu biçimde depolanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="a5081-217">*Grafik depoları* (NEO4J, Titan): veriler, düğümler arasındaki ilişkiyi belirten kenarlarla birlikte bir düğüm içindeki bir grafik gösterimi olarak depolanır.</span><span class="sxs-lookup"><span data-stu-id="a5081-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="a5081-218">NoSQL veritabanları, özellikle de veriler görece basit olduğunda büyük ölçekli verilerle uğraşmak için iyileştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="a5081-219">Şu durumlarda bir NoSQL veritabanı göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="a5081-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="a5081-220">İş yükünüz büyük ölçekli ve yüksek eşzamanlılık gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a5081-220">Your workload requires large-scale and high-concurrency.</span></span>
- <span data-ttu-id="a5081-221">Çok sayıda kullanıcınız var.</span><span class="sxs-lookup"><span data-stu-id="a5081-221">You have large numbers of users.</span></span>
- <span data-ttu-id="a5081-222">Verileriniz yalnızca ilişkiler olmadan ifade edilebilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="a5081-223">Verilerinizi coğrafi olarak dağıtmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a5081-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="a5081-224">ACID garantisi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="a5081-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="a5081-225">, Emtia donanımına dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="a5081-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="a5081-226">Ardından, şu durumlarda ilişkisel bir veritabanı düşünün:</span><span class="sxs-lookup"><span data-stu-id="a5081-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="a5081-227">İş yükleriniz orta ila büyük ölçekli bir ölçek gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a5081-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="a5081-228">Eşzamanlılık önemli bir sorun değil.</span><span class="sxs-lookup"><span data-stu-id="a5081-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="a5081-229">ACID garantisi gereklidir.</span><span class="sxs-lookup"><span data-stu-id="a5081-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="a5081-230">Veriler en iyi şekilde ifade edilir.</span><span class="sxs-lookup"><span data-stu-id="a5081-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="a5081-231">Uygulamanız büyük ve yüksek kaliteli donanıma dağıtılacak.</span><span class="sxs-lookup"><span data-stu-id="a5081-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="a5081-232">Daha sonra, Azure bulutu 'nda veri depolamaya bakacağız.</span><span class="sxs-lookup"><span data-stu-id="a5081-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a5081-233">[Önceki](distributed-data.md)
>[İleri](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="a5081-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
