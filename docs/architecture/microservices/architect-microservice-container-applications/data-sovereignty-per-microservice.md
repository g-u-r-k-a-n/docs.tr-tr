---
title: Mikro hizmet başına veri hakimiyeti
description: Mikro hizmet başına veri egemenliği, mikro hizmetlerin kilit noktalarından biridir. Her microservice kendi veritabanının tek sahibi olmalı, başka bir ile paylaşan. Tabii ki bir microservice tüm örnekleri aynı yüksek kullanılabilirlik veritabanına bağlayın.
ms.date: 09/20/2018
ms.openlocfilehash: f606d6314f38bf3e2c163871af432806dddc7446
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "73191912"
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="4c48f-105">Mikro hizmet başına veri hakimiyeti</span><span class="sxs-lookup"><span data-stu-id="4c48f-105">Data sovereignty per microservice</span></span>

<span data-ttu-id="4c48f-106">Mikro hizmetler mimarisi için önemli bir kural, her microservice kendi etki alanı veri ve mantık sahibi olması gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-106">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="4c48f-107">Tam bir uygulamanın kendi mantığına ve verilerine sahip olması gibi, her mikro hizmet in kendi mantığına ve verilerine, mikro hizmet başına bağımsız dağıtımla özerk bir yaşam döngüsü altında sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-107">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="4c48f-108">Bu, etki alanının kavramsal modelinin alt sistemler veya mikro hizmetler arasında farklılık olacağı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-108">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="4c48f-109">Müşteri ilişkileri yönetimi (CRM) uygulamalarının, işlemsel satın alma alt sistemlerinin ve müşteri destek alt sistemlerinin her birinin benzersiz müşteri varlık öznitelikleri ve verilerini aradığı ve her birinin farklı bir Sınırlanmış Bağlam (BC).</span><span class="sxs-lookup"><span data-stu-id="4c48f-109">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="4c48f-110">Bu ilke, her [Sınırlı Bağlam](https://martinfowler.com/bliki/BoundedContext.html) veya özerk alt sistem veya hizmetin etki alanı modeline (veri artı mantık ve davranış) sahip olması gereken Etki Alanı [tabanlı tasarımda (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)benzerdir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-110">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="4c48f-111">Her DDD Sınırlı Bağlam, bir iş microservice (bir veya birkaç hizmet) ile ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-111">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="4c48f-112">Bağlı Bağlam deseni yle ilgili bu nokta sonraki bölümde genişletilir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-112">This point about the Bounded Context pattern is expanded in the next section.</span></span>

<span data-ttu-id="4c48f-113">Öte yandan, birçok uygulamada kullanılan geleneksel (yekpare veri) yaklaşımı tek bir merkezi veritabanı veya sadece birkaç veritabanları olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-113">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="4c48f-114">Bu genellikle Şekil 4-7'de gösterildiği gibi, tüm uygulama ve tüm dahili alt sistemleri için kullanılan normalleştirilmiş bir SQL veritabanıdır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-114">This is often a normalized SQL database that's used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![İki veritabanı yaklaşımını güsteren diyagram.](./media/data-sovereignty-per-microservice/data-sovereignty-comparison.png)

<span data-ttu-id="4c48f-116">**Şekil 4-7**.</span><span class="sxs-lookup"><span data-stu-id="4c48f-116">**Figure 4-7**.</span></span> <span data-ttu-id="4c48f-117">Veri egemenliği karşılaştırması: monolitik veritabanı ve mikrohizmetler</span><span class="sxs-lookup"><span data-stu-id="4c48f-117">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="4c48f-118">Geleneksel yaklaşımda, genellikle katmanlı mimaride tüm hizmetler arasında paylaşılan tek bir veritabanı vardır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-118">In the traditional approach, there's a single database shared across all services, typically in a tiered architecture.</span></span> <span data-ttu-id="4c48f-119">Mikro hizmetler yaklaşımında, her microservice kendi modeline/verilerine sahip.</span><span class="sxs-lookup"><span data-stu-id="4c48f-119">In the microservices approach, each microservice owns its model/data.</span></span> <span data-ttu-id="4c48f-120">Merkezi leştirilmiş veritabanı yaklaşımı başlangıçta daha basit görünür ve her şeyi tutarlı hale getirmek için farklı alt sistemlerdeki varlıkların yeniden kullanılmasını sağlar gibi görünür.</span><span class="sxs-lookup"><span data-stu-id="4c48f-120">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="4c48f-121">Ama gerçek şu ki, birçok farklı alt sistemlere hizmet veren ve çoğu durumda gerekli olmayan öznitelikleri ve sütunları içeren büyük tablolarla sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-121">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that aren't needed in most cases.</span></span> <span data-ttu-id="4c48f-122">Kısa bir patikada yürüyüş yapmak, bir günlük araba gezisi yapmak ve coğrafya öğrenmek için aynı fiziksel haritayı kullanmaya çalışmak gibi.</span><span class="sxs-lookup"><span data-stu-id="4c48f-122">It's like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="4c48f-123">Genellikle tek bir ilişkisel veritabanına sahip yekpare bir uygulamanın iki önemli faydası vardır: [ASİt hareketleri](https://en.wikipedia.org/wiki/ACID) ve SQL dili, hem uygulamanızla ilgili tüm tablolarda hem de verilerde çalışır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-123">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="4c48f-124">Bu yaklaşım, birden çok tablodaki verileri birleştiren bir sorguyazmak için kolayca bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="4c48f-124">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="4c48f-125">Ancak, bir mikro hizmetler mimarisine geçtikçe veri erişimi çok daha karmaşık hale gelir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-125">However, data access becomes much more complicated when you move to a microservices architecture.</span></span> <span data-ttu-id="4c48f-126">Bir microservice veya Bounded Context içinde ACID işlemleri kullanırken bile, her bir mikro hizmete ait verilerin bu mikro hizmete özel olduğunu ve yalnızca API uç noktaları üzerinden eşzamanlı olarak erişilmesi gerektiğini göz önünde bulundurmak önemlidir (REST, gRPC, SOAP, vb) veya mesajlaşma (AMQP veya benzeri) yoluyla eşzamanlı olarak.</span><span class="sxs-lookup"><span data-stu-id="4c48f-126">Even when using ACID transactions within a microservice or Bounded Context, it is crucial to consider that the data owned by each microservice is private to that microservice and should only be accessed either synchronously through its API endpoints(REST, gRPC, SOAP, etc) or asynchronously via messaging(AMQP or similar).</span></span>

<span data-ttu-id="4c48f-127">Verilerin kapsüllemesi, mikro hizmetlerin gevşek bir şekilde birleştiğini ve birbirinden bağımsız olarak evrimleşebilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="4c48f-127">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="4c48f-128">Birden çok hizmet aynı verilere erişiyorsa, şema güncelleştirmeleri tüm hizmetler için eşgüdümlü güncelleştirmeler gerektirir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-128">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="4c48f-129">Bu mikrohizmet yaşam döngüsü özerkliğini kıracak.</span><span class="sxs-lookup"><span data-stu-id="4c48f-129">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="4c48f-130">Ancak dağıtılmış veri yapıları, mikro hizmetler arasında tek bir ASİt işlemi yapamadığınız anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-130">But distributed data structures mean that you can't make a single ACID transaction across microservices.</span></span> <span data-ttu-id="4c48f-131">Bu da, bir iş süreci birden çok mikro hizmeti kapsadığında nihai tutarlılığı kullanmanız gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-131">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="4c48f-132">Bunu uygulamak basit SQL birleşimlerinden çok daha zordur, çünkü daha sonra açıklayacağımız gibi, bütünlük kısıtlamaları oluşturamaz veya ayrı veritabanları arasında dağıtılmış hareketler kullanamazsınız.</span><span class="sxs-lookup"><span data-stu-id="4c48f-132">This is much harder to implement than simple SQL joins, because you can't create integrity constraints or use distributed transactions between separate databases, as we'll explain later on.</span></span> <span data-ttu-id="4c48f-133">Benzer şekilde, diğer birçok ilişkisel veritabanı özelliği birden çok mikro hizmette kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="4c48f-133">Similarly, many other relational database features aren't available across multiple microservices.</span></span>

<span data-ttu-id="4c48f-134">Daha da ileri giderek, farklı mikro hizmetler genellikle farklı *veritabanları kullanır.*</span><span class="sxs-lookup"><span data-stu-id="4c48f-134">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="4c48f-135">Modern uygulamalar çeşitli veri türlerini depolar ve işlenir ve ilişkisel veritabanı her zaman en iyi seçim değildir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-135">Modern applications store and process diverse kinds of data, and a relational database isn't always the best choice.</span></span> <span data-ttu-id="4c48f-136">Bazı kullanım durumlarında, Azure CosmosDB veya MongoDB gibi bir NoSQL veritabanı daha kullanışlı bir veri modeline sahip olabilir ve SQL Server veya Azure SQL Veritabanı gibi bir SQL veritabanından daha iyi performans ve ölçeklenebilirlik sunabilir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-136">For some use cases, a NoSQL database such as Azure CosmosDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="4c48f-137">Diğer durumlarda, ilişkisel bir veritabanı hala en iyi yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-137">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="4c48f-138">Bu nedenle, mikrohizmet tabanlı uygulamalar genellikle bazen [çokdilli kalıcılık](https://martinfowler.com/bliki/PolyglotPersistence.html) yaklaşımı olarak adlandırılan SQL ve NoSQL veritabanlarının bir karışımını kullanır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-138">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="4c48f-139">Veri depolama için bölümlenmiş, çok dilli kalıcı mimarinin birçok faydası vardır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-139">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="4c48f-140">Bunlar arasında gevşek birleştirilmiş hizmetler ve daha iyi performans, ölçeklenebilirlik, maliyetler ve yönetilebilirlik yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-140">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="4c48f-141">Ancak, bu bölümün ilerleyen bölümlerinde " Etki[alanı modeli sınırlarını belirleme"](identify-microservice-domain-model-boundaries.md)bölümünde açıklandığı gibi, bazı dağıtılmış veri yönetimi zorlukları getirebilir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-141">However, it can introduce some distributed data management challenges, as explained in "[Identifying domain-model boundaries](identify-microservice-domain-model-boundaries.md)" later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="4c48f-142">Mikro hizmetler ve Sınırlı Bağlam deseni arasındaki ilişki</span><span class="sxs-lookup"><span data-stu-id="4c48f-142">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="4c48f-143">Mikrohizmet [kavramı, etki alanı odaklı tasarımda (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design) [Sınırlı Bağlam (BC) deseninden](https://martinfowler.com/bliki/BoundedContext.html) türetilmiştir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-143">The concept of microservice derives from the [Bounded Context (BC) pattern](https://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="4c48f-144">DDD, büyük modelleri birden çok BC'ye bölerek ve sınırları hakkında açık olarak ele alar.</span><span class="sxs-lookup"><span data-stu-id="4c48f-144">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="4c48f-145">Her BC'nin kendi modeli ve veritabanı olmalıdır; aynı şekilde, her microservice kendi ilgili verilere sahip.</span><span class="sxs-lookup"><span data-stu-id="4c48f-145">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="4c48f-146">Buna ek olarak, her BC genellikle yazılım [geliştiricileri](https://martinfowler.com/bliki/UbiquitousLanguage.html) ve etki alanı uzmanları arasındaki iletişimyardımcı olmak için kendi her yerde dil vardır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-146">In addition, each BC usually has its own [ubiquitous language](https://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="4c48f-147">Her yerde bulunan dildeki bu terimler (özellikle etki alanı varlıkları), farklı etki alanı varlıkları aynı kimliği paylaşsa bile (diğer bir deyişle, varlığı depolamadan okumak için kullanılan benzersiz kimlik) farklı Bağlı Bağlamlarda farklı adlara sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-147">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that's used to read the entity from storage).</span></span> <span data-ttu-id="4c48f-148">Örneğin, kullanıcı profili Sınırlanmış Bağlam'da, Kullanıcı etki alanı varlığı, Sınırlı Bağlam'ı sıralayan alan varlığında kimliği Alıcı etki alanı varlığıyla paylaşabilir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-148">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="4c48f-149">Bir microservice bu nedenle Sınırlı Bağlam gibidir, ancak dağıtılmış bir hizmet olduğunu da belirtir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-149">A microservice is therefore like a Bounded Context, but it also specifies that it's a distributed service.</span></span> <span data-ttu-id="4c48f-150">Her Bağlı Bağlam için ayrı bir işlem olarak oluşturulmuştur ve http/HTTPS, WebSockets veya [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)gibi daha önce belirtilen dağıtılmış protokolleri kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-150">It's built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="4c48f-151">Ancak, Sınırlandırılmış Bağlam deseni, Sınırlandırılmış Bağlam'ın dağıtılmış bir hizmet olup olmadığını veya tek şey liyakatli dağıtım uygulaması içinde yalnızca mantıksal bir sınır (genel bir alt sistem gibi) olup olmadığını belirtmez.</span><span class="sxs-lookup"><span data-stu-id="4c48f-151">The Bounded Context pattern, however, doesn't specify whether the Bounded Context is a distributed service or if it's simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="4c48f-152">Her Bağlı Bağlam için bir hizmet tanımlamanın başlamak için iyi bir yer olduğunu vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-152">It's important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="4c48f-153">Ama tasarımınızı buna kısıtlamak zorunda değilsiniz.</span><span class="sxs-lookup"><span data-stu-id="4c48f-153">But you don't have to constrain your design to it.</span></span> <span data-ttu-id="4c48f-154">Bazen, çeşitli fiziksel hizmetlerden oluşan Bir Sınırlı Bağlam veya iş microservice tasarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-154">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="4c48f-155">Ama sonuçta, her iki desen -Sınırlı Bağlam ve microservice- yakından ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-155">But ultimately, both patterns -Bounded Context and microservice- are closely related.</span></span>

<span data-ttu-id="4c48f-156">DDD, dağıtılmış mikro hizmetler şeklinde gerçek sınırlar elde ederek mikro hizmetlerden yararlanır.</span><span class="sxs-lookup"><span data-stu-id="4c48f-156">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="4c48f-157">Ancak modeli mikro hizmetler arasında paylaşmamak gibi fikirler, Sınırlı Bağlamda da istediğiniz şeydir.</span><span class="sxs-lookup"><span data-stu-id="4c48f-157">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="4c48f-158">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="4c48f-158">Additional resources</span></span>

- <span data-ttu-id="4c48f-159">**Chris Richardson' ı. Desen: Hizmet başına veritabanı** </span><span class="sxs-lookup"><span data-stu-id="4c48f-159">**Chris Richardson. Pattern: Database per service** </span></span>\
  <https://microservices.io/patterns/data/database-per-service.html>

- <span data-ttu-id="4c48f-160">**Martin Fowler' ı. Sınırlı Bağlam** </span><span class="sxs-lookup"><span data-stu-id="4c48f-160">**Martin Fowler. BoundedContext** </span></span>\
  <https://martinfowler.com/bliki/BoundedContext.html>

- <span data-ttu-id="4c48f-161">**Martin Fowler' ı. PoliglotKalıcılık** </span><span class="sxs-lookup"><span data-stu-id="4c48f-161">**Martin Fowler. PolyglotPersistence** </span></span>\
  <https://martinfowler.com/bliki/PolyglotPersistence.html>

- <span data-ttu-id="4c48f-162">**Alberto Brandolini. Bağlam Haritalama ile Stratejik Etki Alanı Odaklı Tasarım** </span><span class="sxs-lookup"><span data-stu-id="4c48f-162">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping** </span></span>\
  <https://www.infoq.com/articles/ddd-contextmapping>

>[!div class="step-by-step"]
><span data-ttu-id="4c48f-163">[Önceki](microservices-architecture.md)
>[Sonraki](logical-versus-physical-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="4c48f-163">[Previous](microservices-architecture.md)
[Next](logical-versus-physical-architecture.md)</span></span>
