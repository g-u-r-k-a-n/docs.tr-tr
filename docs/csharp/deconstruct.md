---
title: Demetleri ve diğer türleri ayrıştırma
description: Tanımlama gruplarını ve diğer türleri oluşturmayı öğrenin.
ms.technology: csharp-fundamentals
ms.date: 11/23/2017
ms.assetid: 0b0c4b0f-4a47-4f66-9b8e-f5c63b195960
ms.openlocfilehash: 5aaf7157b87de4f67f6e4beba18794a6dd13b6d0
ms.sourcegitcommit: 65af0f0ad316858882845391d60ef7e303b756e8
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/05/2021
ms.locfileid: "99585357"
---
# <a name="deconstructing-tuples-and-other-types"></a><span data-ttu-id="98182-103">Demetleri ve diğer türleri ayrıştırma</span><span class="sxs-lookup"><span data-stu-id="98182-103">Deconstructing tuples and other types</span></span>

<span data-ttu-id="98182-104">Kayıt düzeni, bir yöntem çağrısından birden çok değer almanın hafif bir yolunu sağlar.</span><span class="sxs-lookup"><span data-stu-id="98182-104">A tuple provides a lightweight way to retrieve multiple values from a method call.</span></span> <span data-ttu-id="98182-105">Ancak, tanımlama grubunu aldıktan sonra ayrı öğelerini işlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="98182-105">But once you retrieve the tuple, you have to handle its individual elements.</span></span> <span data-ttu-id="98182-106">Bu işlem, aşağıdaki örnekte gösterildiği gibi, öğe temelinde tek yapmanız gereken bir öğedir.</span><span class="sxs-lookup"><span data-stu-id="98182-106">Doing this on an element-by-element basis is cumbersome, as the following example shows.</span></span> <span data-ttu-id="98182-107">`QueryCityData`Yöntemi 3 tanımlama grubu döndürür ve öğelerinden her biri ayrı bir işlemde bir değişkene atanır.</span><span class="sxs-lookup"><span data-stu-id="98182-107">The `QueryCityData` method returns a 3-tuple, and each of its elements is assigned to a variable in a separate operation.</span></span>

[!code-csharp[WithoutDeconstruction](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple1.cs)]

<span data-ttu-id="98182-108">Bir nesneden birden çok alan ve özellik değeri alınması eşit bir şekilde olabilir: üye üye temelinde bir değişkene bir alan veya özellik değeri atamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="98182-108">Retrieving multiple field and property values from an object can be equally cumbersome: you have to assign a field or property value to a variable on a member-by-member basis.</span></span>

<span data-ttu-id="98182-109">C# 7,0 ' den başlayarak, bir tanımlama grubundan birden fazla öğe alabilir veya tek bir *Yapı* işlemindeki bir nesneden birden fazla alan, özellik ve hesaplanan değer alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-109">Starting with C# 7.0, you can retrieve multiple elements from a tuple or retrieve multiple field, property, and computed values from an object in a single *deconstruct* operation.</span></span> <span data-ttu-id="98182-110">Bir tanımlama grubu oluştururken, öğelerini ayrı değişkenlere atarsınız.</span><span class="sxs-lookup"><span data-stu-id="98182-110">When you deconstruct a tuple, you assign its elements to individual variables.</span></span> <span data-ttu-id="98182-111">Bir nesneyi kaldırdığınızda, seçili değerleri ayrı değişkenlere atarsınız.</span><span class="sxs-lookup"><span data-stu-id="98182-111">When you deconstruct an object, you assign selected values to individual variables.</span></span>

## <a name="deconstructing-a-tuple"></a><span data-ttu-id="98182-112">Kayıt düzeni kaldırma</span><span class="sxs-lookup"><span data-stu-id="98182-112">Deconstructing a tuple</span></span>

<span data-ttu-id="98182-113">C# özellikleri, tek bir işlemde bir kayıt grubundaki tüm öğeleri paketlemenizi sağlayan tanımlama grupları için yerleşik destek sunar.</span><span class="sxs-lookup"><span data-stu-id="98182-113">C# features built-in support for deconstructing tuples, which lets you unpackage all the items in a tuple in a single operation.</span></span> <span data-ttu-id="98182-114">Bir kayıt düzeni oluşturmak için genel sözdizimi, bir tanımlama sözdizimine benzer. bir atama ifadesinin sol tarafında parantez içine atanacak olan değişkenleri çevrelemektir.</span><span class="sxs-lookup"><span data-stu-id="98182-114">The general syntax for deconstructing a tuple is similar to the syntax for defining one: you enclose the variables to which each element is to be assigned in parentheses in the left side of an assignment statement.</span></span> <span data-ttu-id="98182-115">Örneğin, aşağıdaki ifade 4 kayıt öğelerinin öğelerini dört ayrı değişkene atar:</span><span class="sxs-lookup"><span data-stu-id="98182-115">For example, the following statement assigns the elements of a 4-tuple to four separate variables:</span></span>

```csharp
var (name, address, city, zip) = contact.GetAddressInfo();
```

<span data-ttu-id="98182-116">Tanımlama grubu oluşturmanın üç yolu vardır:</span><span class="sxs-lookup"><span data-stu-id="98182-116">There are three ways to deconstruct a tuple:</span></span>

- <span data-ttu-id="98182-117">Her alanın türünü parantez içinde açık bir şekilde bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-117">You can explicitly declare the type of each field inside parentheses.</span></span> <span data-ttu-id="98182-118">Aşağıdaki örnek, yöntemi tarafından döndürülen 3 kayıt düzeni oluşturmak için bu yaklaşımı kullanır `QueryCityData` .</span><span class="sxs-lookup"><span data-stu-id="98182-118">The following example uses this approach to deconstruct the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Explicit](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple2.cs#1)]

- <span data-ttu-id="98182-119">`var`C# ' ın her değişkenin türünü bilmesi için anahtar sözcüğünü kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-119">You can use the `var` keyword so that C# infers the type of each variable.</span></span> <span data-ttu-id="98182-120">`var`Anahtar sözcüğünü parantezlerin dışında yerleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-120">You place the `var` keyword outside of the parentheses.</span></span> <span data-ttu-id="98182-121">Aşağıdaki örnek, yöntem tarafından döndürülen 3 kayıt düzeni oluştururken tür çıkarımı kullanır `QueryCityData` .</span><span class="sxs-lookup"><span data-stu-id="98182-121">The following example uses type inference when deconstructing the 3-tuple returned by the `QueryCityData` method.</span></span>

    [!code-csharp[Deconstruction-Infer](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple3.cs#1)]

    <span data-ttu-id="98182-122">`var`Anahtar sözcüğünü, parantez içindeki değişken bildirimlerinin herhangi biri veya tümü ile ayrı ayrı de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-122">You can also use the `var` keyword individually with any or all of the variable declarations inside the parentheses.</span></span>

    [!code-csharp[Deconstruction-Infer-Some](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple4.cs#1)]

    <span data-ttu-id="98182-123">Bu, kısabera ve önerilmez.</span><span class="sxs-lookup"><span data-stu-id="98182-123">This is cumbersome and is not recommended.</span></span>

- <span data-ttu-id="98182-124">Son olarak, tanımlama grubunu zaten önceden tanımlanmış değişkenler halinde oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-124">Lastly, you may deconstruct the tuple into variables that have already been declared.</span></span>

    [!code-csharp[Deconstruction-Declared](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-tuple5.cs#1)]

<span data-ttu-id="98182-125">Kayıt grubundaki her alan aynı türde olsa bile, parantez dışında belirli bir tür belirtemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-125">Note that you cannot specify a specific type outside the parentheses even if every field in the tuple has the same type.</span></span> <span data-ttu-id="98182-126">Bu bir derleyici hatası oluşturur CS8136, "Deinşaat" var (...) ' formu, ' var ' için belirli bir türe izin vermez. ".</span><span class="sxs-lookup"><span data-stu-id="98182-126">This generates compiler error CS8136, "Deconstruction 'var (...)' form disallows a specific type for 'var'.".</span></span>

<span data-ttu-id="98182-127">Ayrıca, kayıt düzeni öğelerinin her birini bir değişkene atamanız gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="98182-127">Note that you must also assign each element of the tuple to a variable.</span></span> <span data-ttu-id="98182-128">Herhangi bir öğeyi atlarsanız, derleyici CS8132 hatasını üretir, "' x ' öğelerinden oluşan bir demet ' y ' değişkenlerine parçalanamaz."</span><span class="sxs-lookup"><span data-stu-id="98182-128">If you omit any elements, the compiler generates error CS8132, "Cannot deconstruct a tuple of 'x' elements into 'y' variables."</span></span>

<span data-ttu-id="98182-129">Bir oluşturma 'nın sol tarafındaki mevcut değişkenlere bildirimleri ve atamaları karıştırmayacağınızı unutmayın.</span><span class="sxs-lookup"><span data-stu-id="98182-129">Note that you cannot mix declarations and assignments to existing variables on the left-hand side of a deconstruction.</span></span> <span data-ttu-id="98182-130">Derleyici hata CS8184 oluşturuyor, "bir oluşturma, sol taraftaki bildirimleri ve ifadeleri karıştıramaz."</span><span class="sxs-lookup"><span data-stu-id="98182-130">The compiler generates error CS8184, "a deconstruction cannot mix declarations and expressions on the left-hand-side."</span></span> <span data-ttu-id="98182-131">üyeler yeni tanımlanan ve mevcut değişkenleri içerenleri içerir.</span><span class="sxs-lookup"><span data-stu-id="98182-131">when the members include newly declared and existing variables.</span></span>

## <a name="deconstructing-tuple-elements-with-discards"></a><span data-ttu-id="98182-132">Kayıt düzeni öğeleri atma ile kaldırılıyor</span><span class="sxs-lookup"><span data-stu-id="98182-132">Deconstructing tuple elements with discards</span></span>

<span data-ttu-id="98182-133">Genellikle bir kayıt düzeni oluştururken yalnızca bazı öğelerin değerleriyle ilgileniyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="98182-133">Often when deconstructing a tuple, you're interested in the values of only some elements.</span></span> <span data-ttu-id="98182-134">C# 7,0 ' den başlayarak,, değerlerini yok saymayı seçtiğiniz salt yazılır değişkenler olan, C# ' nin *atma* desteğinden faydalanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-134">Starting with C# 7.0, you can take advantage of C#'s support for *discards*, which are write-only variables whose values you've chosen to ignore.</span></span> <span data-ttu-id="98182-135">Atma, bir atamada bir alt çizgi karakteriyle (" \_ ") belirtilir.</span><span class="sxs-lookup"><span data-stu-id="98182-135">A discard is designated by an underscore character ("\_") in an assignment.</span></span> <span data-ttu-id="98182-136">İstediğiniz sayıda değeri atabilirsiniz; tümü, tek atma tarafından temsil edilir `_` .</span><span class="sxs-lookup"><span data-stu-id="98182-136">You can discard as many values as you like; all are represented by the single discard, `_`.</span></span>

<span data-ttu-id="98182-137">Aşağıdaki örnek, atma ile başlıkların kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="98182-137">The following example illustrates the use of tuples with discards.</span></span> <span data-ttu-id="98182-138">Bu `QueryCityDataForYears` Yöntem, şehir adı, alanı, bir yıl, bu yıl için şehir popülasyonu, ikinci bir yıl ve bu ikinci yıl için şehir popülasyonu içeren 6 tanımlama grubu döndürür.</span><span class="sxs-lookup"><span data-stu-id="98182-138">The `QueryCityDataForYears` method returns a 6-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="98182-139">Örnek, bu iki yıl arasındaki popülasyondaki değişikliği gösterir.</span><span class="sxs-lookup"><span data-stu-id="98182-139">The example shows the change in population between those two years.</span></span> <span data-ttu-id="98182-140">Kayıt kümesinden kullanılabilen veriler, şehir alanıyla ilgilentik ve tasarım zamanında şehir adını ve iki tarihi biliyoruz.</span><span class="sxs-lookup"><span data-stu-id="98182-140">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="98182-141">Sonuç olarak, yalnızca kayıt düzeninde depolanan iki popülasyon değeri ile ilgileniyoruz ve kalan değerlerini atma olarak işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="98182-141">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

[!code-csharp[Tuple-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/discard-tuple1.cs)]

## <a name="deconstructing-user-defined-types"></a><span data-ttu-id="98182-142">Kullanıcı tanımlı türleri kaldırma</span><span class="sxs-lookup"><span data-stu-id="98182-142">Deconstructing user-defined types</span></span>

<span data-ttu-id="98182-143">C#, kayıt olmayan türler oluşturmak için yerleşik destek sunmaz.</span><span class="sxs-lookup"><span data-stu-id="98182-143">C# does not offer built-in support for deconstructing non-tuple types.</span></span> <span data-ttu-id="98182-144">Ancak, bir sınıfın yazarı, bir struct veya Interface olarak, bir veya daha fazla yöntem uygulayarak tür örneklerinin çıkarılması için izin verebilirsiniz `Deconstruct` .</span><span class="sxs-lookup"><span data-stu-id="98182-144">However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more `Deconstruct` methods.</span></span> <span data-ttu-id="98182-145">Yöntemi void döndürür ve kaldırılacak her değer, yöntem imzasında bir [Out](language-reference/keywords/out-parameter-modifier.md) parametresi ile belirtilir.</span><span class="sxs-lookup"><span data-stu-id="98182-145">The method returns void, and each value to be deconstructed is indicated by an [out](language-reference/keywords/out-parameter-modifier.md) parameter in the method signature.</span></span> <span data-ttu-id="98182-146">Örneğin, `Deconstruct` bir sınıfın aşağıdaki yöntemi `Person` Birinci, orta ve soyadı döndürür:</span><span class="sxs-lookup"><span data-stu-id="98182-146">For example, the following `Deconstruct` method of a `Person` class returns the first, middle, and last name:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#1)]

<span data-ttu-id="98182-147">Daha sonra `Person` `p` , aşağıdaki gibi bir atamayla adlı sınıfının bir örneğini kaldırabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="98182-147">You can then deconstruct an instance of the `Person` class named `p` with an assignment like the following:</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class1.cs#2)]

<span data-ttu-id="98182-148">Aşağıdaki örnek, `Deconstruct` bir nesnesinin özelliklerinin çeşitli birleşimlerini döndürmek için yöntemini aşırı yükler `Person` .</span><span class="sxs-lookup"><span data-stu-id="98182-148">The following example overloads the `Deconstruct` method to return various combinations of properties of a `Person` object.</span></span> <span data-ttu-id="98182-149">Tek tek aşırı yükleme dönüşü:</span><span class="sxs-lookup"><span data-stu-id="98182-149">Individual overloads return:</span></span>

- <span data-ttu-id="98182-150">Ad ve soyadı.</span><span class="sxs-lookup"><span data-stu-id="98182-150">A first and last name.</span></span>
- <span data-ttu-id="98182-151">Birinci, orta ve soyadı.</span><span class="sxs-lookup"><span data-stu-id="98182-151">A first, middle, and last name.</span></span>
- <span data-ttu-id="98182-152">Ad, soyadı, şehir adı ve durum adı.</span><span class="sxs-lookup"><span data-stu-id="98182-152">A first name, a last name, a city name, and a state name.</span></span>

[!code-csharp[Class-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-class2.cs)]

<span data-ttu-id="98182-153">`Deconstruct`Aynı sayıda parametreye sahip birden çok yöntem belirsiz.</span><span class="sxs-lookup"><span data-stu-id="98182-153">Multiple `Deconstruct` methods having the same number of parameters are ambiguous.</span></span> <span data-ttu-id="98182-154">`Deconstruct`Farklı sayıda parametreye veya "parametre sayısına" sahip yöntemleri tanımlamaya dikkat etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="98182-154">You must be careful to define `Deconstruct` methods with different numbers of parameters, or "arity".</span></span> <span data-ttu-id="98182-155">`Deconstruct` aynı sayıda parametreye sahip Yöntemler aşırı yükleme çözümlemesi sırasında ayırt edilemez.</span><span class="sxs-lookup"><span data-stu-id="98182-155">`Deconstruct` methods with the same number of parameters cannot be distinguished during overload resolution.</span></span>

## <a name="deconstructing-a-user-defined-type-with-discards"></a><span data-ttu-id="98182-156">Kullanıcı tanımlı bir türü atma ile kaldırma</span><span class="sxs-lookup"><span data-stu-id="98182-156">Deconstructing a user-defined type with discards</span></span>

<span data-ttu-id="98182-157">[Tanımlama grupları](#deconstructing-tuple-elements-with-discards)ile yaptığınız gibi, bir yöntem tarafından döndürülen seçili öğeleri yoksaymak için atarsa ' u kullanabilirsiniz `Deconstruct` .</span><span class="sxs-lookup"><span data-stu-id="98182-157">Just as you do with [tuples](#deconstructing-tuple-elements-with-discards), you can use discards to ignore selected items returned by a `Deconstruct` method.</span></span> <span data-ttu-id="98182-158">Her atma "" adlı bir değişken tarafından tanımlanır \_ ve tek bir ayrıştırma işlemi birden çok atma içerebilir.</span><span class="sxs-lookup"><span data-stu-id="98182-158">Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.</span></span>

<span data-ttu-id="98182-159">Aşağıdaki örnek, bir `Person` nesnesini dört dizeye (ilk ve son adlar, şehir ve eyalet) ayırır, ancak son adı ve durumu atar.</span><span class="sxs-lookup"><span data-stu-id="98182-159">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state) but discards the last name and the state.</span></span>

[!code-csharp[Class-discard](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/class-discard1.cs#1)]

## <a name="deconstructing-a-user-defined-type-with-an-extension-method"></a><span data-ttu-id="98182-160">Uzantı yöntemiyle kullanıcı tanımlı bir tür kaldırma</span><span class="sxs-lookup"><span data-stu-id="98182-160">Deconstructing a user-defined type with an extension method</span></span>

<span data-ttu-id="98182-161">Bir sınıf, yapı veya arabirim yazmadıysanız, ilgilendiğiniz değerleri döndürmek için bir veya daha fazla `Deconstruct` [genişletme yöntemi](programming-guide/classes-and-structs/extension-methods.md) uygulayarak o türdeki nesneleri yine de oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="98182-161">If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more `Deconstruct` [extension methods](programming-guide/classes-and-structs/extension-methods.md) to return the values in which you're interested.</span></span>

<span data-ttu-id="98182-162">Aşağıdaki örnek `Deconstruct` , sınıfı için iki genişletme yöntemini tanımlar <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="98182-162">The following example defines two `Deconstruct` extension methods for the <xref:System.Reflection.PropertyInfo?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="98182-163">İlki, özelliğin özelliklerini gösteren, türü, statik mi, örnek mi olduğunu, salt okunurdur ve dizine eklenip eklenmeyeceğini içeren bir değerler kümesi döndürür.</span><span class="sxs-lookup"><span data-stu-id="98182-163">The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed.</span></span> <span data-ttu-id="98182-164">İkincisi, özelliğin erişilebilirliğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="98182-164">The second indicates the property's accessibility.</span></span> <span data-ttu-id="98182-165">Get ve set erişimcilerinin erişilebilirliği farklı olabileceğinden, Boole değerleri özelliğin ayrı Get ve set erişimcilerine sahip olup olmadığını ve varsa aynı erişilebilirliği içerip içermediğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="98182-165">Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility.</span></span> <span data-ttu-id="98182-166">Yalnızca bir erişimci varsa veya hem Get hem de set erişimcisinin aynı erişilebilirliği varsa `access` değişkeni, özelliğin erişilebilirliğini bir bütün olarak gösterir.</span><span class="sxs-lookup"><span data-stu-id="98182-166">If there is only one accessor or both the get and the set accessor have the same accessibility, the `access` variable indicates the accessibility of the property as a whole.</span></span> <span data-ttu-id="98182-167">Aksi takdirde, Get ve set erişimcilerinin erişilebilirliği `getAccess` ve değişkenleri tarafından gösterilir `setAccess` .</span><span class="sxs-lookup"><span data-stu-id="98182-167">Otherwise, the accessibility of the get and set accessors are indicated by the `getAccess` and `setAccess` variables.</span></span>

[!code-csharp[Extension-deconstruct](../../samples/snippets/csharp/programming-guide/deconstructing-tuples/deconstruct-extension1.cs)]

## <a name="see-also"></a><span data-ttu-id="98182-168">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="98182-168">See also</span></span>

- [<span data-ttu-id="98182-169">Atılanlar</span><span class="sxs-lookup"><span data-stu-id="98182-169">Discards</span></span>](discards.md)
- [<span data-ttu-id="98182-170">Demet türleri</span><span class="sxs-lookup"><span data-stu-id="98182-170">Tuple types</span></span>](language-reference/builtin-types/value-tuples.md)
