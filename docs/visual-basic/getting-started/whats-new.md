---
title: Visual Basic için yenilikler
ms.date: 10/24/2018
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
ms.openlocfilehash: 3ab468f6c68429a3a5cb8706152288afae520df3
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "79187136"
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="feb1d-102">Visual Basic için yenilikler</span><span class="sxs-lookup"><span data-stu-id="feb1d-102">What's new for Visual Basic</span></span>

<span data-ttu-id="feb1d-103">Bu konu, Visual Basic'in her sürümü için anahtar özellik adlarını listeler ve dilin en son sürümlerindeki yeni ve geliştirilmiş özelliklerin ayrıntılı açıklamalarını listeler.</span><span class="sxs-lookup"><span data-stu-id="feb1d-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the latest versions of the language.</span></span>

## <a name="current-version"></a><span data-ttu-id="feb1d-104">Geçerli sürüm</span><span class="sxs-lookup"><span data-stu-id="feb1d-104">Current version</span></span>

<span data-ttu-id="feb1d-105">Visual Basic 16.0 / Visual Studio 2019 sürüm 16.0</span><span class="sxs-lookup"><span data-stu-id="feb1d-105">Visual Basic 16.0 / Visual Studio 2019 version 16.0</span></span>\
<span data-ttu-id="feb1d-106">Yeni özellikler için [Visual Basic 16.0'a](#visual-basic-160)bakın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-106">For new features, see [Visual Basic 16.0](#visual-basic-160).</span></span>

## <a name="previous-versions"></a><span data-ttu-id="feb1d-107">Önceki sürümler</span><span class="sxs-lookup"><span data-stu-id="feb1d-107">Previous versions</span></span>

<span data-ttu-id="feb1d-108">Visual Basic 15.8 / Visual Studio 2017 sürüm 15.8</span><span class="sxs-lookup"><span data-stu-id="feb1d-108">Visual Basic 15.8 / Visual Studio 2017 version 15.8</span></span>\
<span data-ttu-id="feb1d-109">Yeni özellikler için [Visual Basic 15.8'e](#visual-basic-158)bakın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-109">For new features, see [Visual Basic 15.8](#visual-basic-158).</span></span>

<span data-ttu-id="feb1d-110">Visual Basic 15.5 / Visual Studio 2017 sürüm 15.5</span><span class="sxs-lookup"><span data-stu-id="feb1d-110">Visual Basic 15.5 / Visual Studio 2017 version 15.5</span></span>\
<span data-ttu-id="feb1d-111">Yeni özellikler için [Visual Basic 15.5'e](#visual-basic-155)bakın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-111">For new features, see [Visual Basic 15.5](#visual-basic-155).</span></span>

<span data-ttu-id="feb1d-112">Visual Basic 15.3 / Visual Studio 2017 sürüm 15.3</span><span class="sxs-lookup"><span data-stu-id="feb1d-112">Visual Basic 15.3 / Visual Studio 2017 version 15.3</span></span>\
<span data-ttu-id="feb1d-113">Yeni özellikler için [Visual Basic 15.3'e](#visual-basic-153)bakın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-113">For new features, see [Visual Basic 15.3](#visual-basic-153).</span></span>

<span data-ttu-id="feb1d-114">Visual Basic 2017 / Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="feb1d-114">Visual Basic 2017 / Visual Studio 2017</span></span>\
<span data-ttu-id="feb1d-115">Yeni özellikler için [Visual Basic 2017'ye](#visual-basic-2017)bakın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-115">For new features, see [Visual Basic 2017](#visual-basic-2017).</span></span>

<span data-ttu-id="feb1d-116">Visual Basic / Visual Studio 2015</span><span class="sxs-lookup"><span data-stu-id="feb1d-116">Visual Basic / Visual Studio 2015</span></span>\
<span data-ttu-id="feb1d-117">Yeni özellikler için [Visual Basic 14'e](#visual-basic-14)bakın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-117">For new features, see [Visual Basic 14](#visual-basic-14).</span></span>

<span data-ttu-id="feb1d-118">Visual Basic / Visual Studio 2013</span><span class="sxs-lookup"><span data-stu-id="feb1d-118">Visual Basic / Visual Studio 2013</span></span>\
<span data-ttu-id="feb1d-119">.NET Derleyici Platformu'nun teknoloji önizlemeleri ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="feb1d-119">Technology previews of the .NET Compiler Platform ("Roslyn")</span></span>

<span data-ttu-id="feb1d-120">Visual Basic / Visual Studio 2012</span><span class="sxs-lookup"><span data-stu-id="feb1d-120">Visual Basic / Visual Studio 2012</span></span>\
<span data-ttu-id="feb1d-121">`Async`ve `await` anahtar kelimeler, yineleyiciler, arayan bilgi öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="feb1d-121">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="feb1d-122">Visual Basic, Visual Studio 2010</span><span class="sxs-lookup"><span data-stu-id="feb1d-122">Visual Basic, Visual Studio 2010</span></span>\
<span data-ttu-id="feb1d-123">Otomatik olarak uygulanan özellikler, koleksiyon başlatıcıları, örtük çizgi devamı, dinamik, genel co/kontra varyans, genel ad alanı erişimi</span><span class="sxs-lookup"><span data-stu-id="feb1d-123">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="feb1d-124">Visual Basic / Visual Studio 2008</span><span class="sxs-lookup"><span data-stu-id="feb1d-124">Visual Basic / Visual Studio 2008</span></span>\
<span data-ttu-id="feb1d-125">Dil Tümleşik Sorgu (LINQ), XML literals, yerel tür çıkarım, nesne `var` başlatma, anonim türleri, uzantı `if` yöntemleri, yerel tür çıkarım, lambda ifadeler, operatör, kısmi yöntemler, nullable değer türleri</span><span class="sxs-lookup"><span data-stu-id="feb1d-125">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>

<span data-ttu-id="feb1d-126">Visual Basic / Visual Studio 2005</span><span class="sxs-lookup"><span data-stu-id="feb1d-126">Visual Basic / Visual Studio 2005</span></span>\
<span data-ttu-id="feb1d-127">Tür `My` ve yardımcı türleri (uygulamaya, bilgisayara, dosya sistemine, ağa erişim)</span><span class="sxs-lookup"><span data-stu-id="feb1d-127">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="feb1d-128">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="feb1d-128">Visual Basic / Visual Studio .NET 2003</span></span>\
<span data-ttu-id="feb1d-129">Bit kaydırma işleçleri, döngü değişken bildirimi</span><span class="sxs-lookup"><span data-stu-id="feb1d-129">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="feb1d-130">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="feb1d-130">Visual Basic / Visual Studio .NET 2002</span></span>\
<span data-ttu-id="feb1d-131">Visual Basic .NET'in ilk sürümü</span><span class="sxs-lookup"><span data-stu-id="feb1d-131">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-160"></a><span data-ttu-id="feb1d-132">Görsel Temel 16.0</span><span class="sxs-lookup"><span data-stu-id="feb1d-132">Visual Basic 16.0</span></span>

<span data-ttu-id="feb1d-133">Visual Basic 16.0, .NET Core'a Visual Basic Runtime (microsoft.visualbasic.dll) özelliklerinin daha fazlasını sağlamaya odaklanır ve Visual Basic'in .NET Core'a odaklanan ilk sürümüdür.</span><span class="sxs-lookup"><span data-stu-id="feb1d-133">Visual Basic 16.0 focuses on supplying more of the features of the Visual Basic Runtime (microsoft.visualbasic.dll) to .NET Core and is the first version of Visual Basic focused on .NET Core.</span></span> <span data-ttu-id="feb1d-134">Visual Basic Runtime'ın birçok bölümü WinForms'a bağlıdır ve bunlar Visual Basic'in sonraki bir sürümüne eklenir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-134">Many portions of the Visual Basic Runtime depend on WinForms and these will be added in a later version of Visual Basic.</span></span>

<span data-ttu-id="feb1d-135">**Açıklamalar içinde daha fazla yerde izin verilen yorumlar**</span><span class="sxs-lookup"><span data-stu-id="feb1d-135">**Comments allowed in more places within statements**</span></span>

<span data-ttu-id="feb1d-136">Visual Basic 15.8 ve önceki sürümlerinde, yorumlara yalnızca boş satırlarda, deyimin sonunda veya örtülü satır devamına izin verilen bir deyim içinde belirli yerlerde izin verilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-136">In Visual Basic 15.8 and earlier versions, comments are only allowed on blank lines, at the end of a statement, or in specific places within a statement where an implicit line continuation is allowed.</span></span> <span data-ttu-id="feb1d-137">Visual Basic 16.0 ile başlayarak, açık satır devamlarından sonra ve bir alt çizgi ile başlayan bir satırda bir deyim içinde yorumlara da izin verilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-137">Starting with Visual Basic 16.0, comments are also allowed after explicit line continuations and within a statement on a line beginning with a space followed by an underscore.</span></span>

```vb
Public Sub Main()
    cmd.CommandText = ' Comment is allowed here without _
        "SELECT * FROM Titles JOIN Publishers " _ ' This is a comment
        & "ON Publishers.PubId = Titles.PubID " _
 _ ' This is a comment on a line without code
        & "WHERE Publishers.State = 'CA'"
End Sub
```

## <a name="visual-basic-158"></a><span data-ttu-id="feb1d-138">Görsel Temel 15.8</span><span class="sxs-lookup"><span data-stu-id="feb1d-138">Visual Basic 15.8</span></span>

<span data-ttu-id="feb1d-139">**En iyi leştirilmiş kayan nokta ile tümer dönüştürme**</span><span class="sxs-lookup"><span data-stu-id="feb1d-139">**Optimized floating-point to integer conversion**</span></span>

<span data-ttu-id="feb1d-140">Visual Basic'in önceki sürümlerinde, [Çift](../language-reference/data-types/double-data-type.md) ve [Tek](../language-reference/data-types/single-data-type.md) değerlerin integer'lara dönüştürülmesi nispeten düşük performans sunar.</span><span class="sxs-lookup"><span data-stu-id="feb1d-140">In previous versions of Visual Basic, conversion of [Double](../language-reference/data-types/double-data-type.md) and [Single](../language-reference/data-types/single-data-type.md) values to integers offered relatively poor performance.</span></span> <span data-ttu-id="feb1d-141">Visual Basic 15.8, aşağıdaki yöntemlerden herhangi biri tarafından döndürülen değeri [içsel Visual Basic integer dönüşüm işlevlerinden](../language-reference/functions/type-conversion-functions.md) birine (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CUShort, CUInt, CULng) aktardığınızda veya aşağıdaki yöntemlerden herhangi biri `Off`tarafından döndürülen [değer, katı](../language-reference/statements/option-strict-statement.md) bir seçenek olarak belirlenen bir integral türüne aktarıldığında kayan nokta dönüşümlerinin performansını önemli ölçüde artırır :</span><span class="sxs-lookup"><span data-stu-id="feb1d-141">Visual Basic 15.8 significantly enhances the performance of floating-point conversions to integers when you pass the value returned by any of the following methods to one of the [intrinsic Visual Basic integer conversion functions](../language-reference/functions/type-conversion-functions.md) (CByte, CShort, CInt, CLng, CSByte, CUShort, CUInt, CULng), or when the value returned by any of the following methods is implicitly cast to an integral type when [Option Strict](../language-reference/statements/option-strict-statement.md) is set to `Off`:</span></span>

- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Fix(System.Single)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Double)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Object)?displayProperty=nameWithType>
- <xref:Microsoft.VisualBasic.Conversion.Int(System.Single)?displayProperty=nameWithType>
- <xref:System.Math.Ceiling(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Floor(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Round(System.Double)?displayProperty=nameWithType>
- <xref:System.Math.Truncate(System.Double)?displayProperty=nameWithType>

<span data-ttu-id="feb1d-142">Bu optimizasyon, kodun daha hızlı çalışmasına olanak tanır -- çok sayıda tamsayı türüne dönüşüm yapan kod için iki kata kadar daha hızlı.</span><span class="sxs-lookup"><span data-stu-id="feb1d-142">This optimization allows code to run faster -- up to twice as fast for code that does a large number of conversions to integer types.</span></span> <span data-ttu-id="feb1d-143">Aşağıdaki örnek, bu optimizasyondan etkilenen bazı basit yöntem çağrılarını göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="feb1d-143">The following example illustrates some simple method calls that are affected by this optimization:</span></span>

```vb
Dim s As Single = 173.7619
Dim d As Double = s

Dim i1 As Integer = CInt(Fix(s))               ' Result: 173
Dim b1 As Byte = CByte(Int(d))                 ' Result: 173
Dim s1 AS Short = CShort(Math.Truncate(s))     ' Result: 173
Dim i2 As Integer = CInt(Math.Ceiling(d))      ' Result: 174
Dim i3 As Integer = CInt(Math.Round(s))        ' Result: 174
```

<span data-ttu-id="feb1d-144">Bu, kayan nokta değerlerini yuvarlamaktan çok doyurur.</span><span class="sxs-lookup"><span data-stu-id="feb1d-144">Note that this truncates rather than rounds floating-point values.</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="feb1d-145">Görsel Temel 15.5</span><span class="sxs-lookup"><span data-stu-id="feb1d-145">Visual Basic 15.5</span></span>

[<span data-ttu-id="feb1d-146">Girintili olmayan adlandırılmış bağımsız değişkenler</span><span class="sxs-lookup"><span data-stu-id="feb1d-146">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="feb1d-147">Visual Basic 15.3 ve önceki sürümlerinde, bir yöntem çağrısı hem konuma hem de ada göre bağımsız değişkenler içeriyorsa, konumsal bağımsız değişkenler adlandırılmış bağımsız değişkenler önce gelmek zorunda kaldı.</span><span class="sxs-lookup"><span data-stu-id="feb1d-147">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="feb1d-148">Visual Basic 15.5 ile başlayarak, son konumsal bağımsız değişkene kadar tüm bağımsız değişkenler doğru konumda olduğu sürece konumsal ve adlandırılmış bağımsız değişkenler herhangi bir sırada görünebilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-148">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="feb1d-149">Bu, özellikle kod daha okunabilir hale getirmek için adlandırılmış bağımsız değişkenler kullanıldığında yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-149">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="feb1d-150">Örneğin, aşağıdaki yöntem çağrısı, adlandırılmış bir bağımsız değişken arasında iki konumsal bağımsız değişkene sahiptir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-150">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="feb1d-151">Adlandırılmış bağımsız değişken, 19 değerinin bir çağı temsil ettiğini açıkça ortaya koyuyor.</span><span class="sxs-lookup"><span data-stu-id="feb1d-151">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

[<span data-ttu-id="feb1d-152">`Private Protected`üye erişim değiştirici</span><span class="sxs-lookup"><span data-stu-id="feb1d-152">`Private Protected` member access modifier</span></span>](../language-reference/modifiers/private-protected.md)

<span data-ttu-id="feb1d-153">Bu yeni anahtar kelime birleşimi, içerdiği sınıftaki tüm üyelerin yanı sıra içeren sınıftan türetilen türler tarafından erişilebilen, ancak yalnızca içeren derlemede de bulunursa erişilebilen bir üyetanımlar.</span><span class="sxs-lookup"><span data-stu-id="feb1d-153">This new keyword combination defines a member that is accessible by all members in its containing class as well as by types derived from the containing class, but only if they are also found in the containing assembly.</span></span> <span data-ttu-id="feb1d-154">Yapılar devralınamadığından, `Private Protected` yalnızca bir sınıfın üyelerine uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-154">Because structures cannot be inherited, `Private Protected` can only be applied to the members of a class.</span></span>

<span data-ttu-id="feb1d-155">**Önde gelen hex/ikili/oktal ayırıcı**</span><span class="sxs-lookup"><span data-stu-id="feb1d-155">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="feb1d-156">Visual Basic 2017, alt skor`_`karakteri için bir basamak ayırıcısı olarak destek ekledi.</span><span class="sxs-lookup"><span data-stu-id="feb1d-156">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="feb1d-157">Visual Basic 15.5 ile başlayarak, önek ve heksadecimal, ikili veya sekizli basamaklar arasında alt çizici karakteri önde gelen ayırıcı olarak kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-157">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="feb1d-158">Aşağıdaki örnek, 3.271.948.384'ü hexadecimal sayı olarak tanımlamak için önde gelen bir basamak ayırıcısı kullanır:</span><span class="sxs-lookup"><span data-stu-id="feb1d-158">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
```

<span data-ttu-id="feb1d-159">Alt alt seperatifkarakterini önde gelen ayırıcı olarak kullanmak için\*Visual Basic projenize (.vbproj) aşağıdaki öğeyi eklemeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="feb1d-159">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="feb1d-160">Görsel Temel 15.3</span><span class="sxs-lookup"><span data-stu-id="feb1d-160">Visual Basic 15.3</span></span>

[<span data-ttu-id="feb1d-161">**Adlandırılmış tuple çıkarım**</span><span class="sxs-lookup"><span data-stu-id="feb1d-161">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="feb1d-162">Değişkenlerden tuple elemanlarının değerini atadığınızda, Visual Basic tuple elemanlarının adını ilgili değişken adlarından çıkar; bir tuple öğesini açıkça adlandırmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="feb1d-162">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="feb1d-163">Aşağıdaki örnek, üç adlandırılmış öğeile bir tuple `state` `stateName`oluşturmak `capital`için çıkarım kullanır, , ve .</span><span class="sxs-lookup"><span data-stu-id="feb1d-163">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="feb1d-164">**Ek derleyici anahtarları**</span><span class="sxs-lookup"><span data-stu-id="feb1d-164">**Additional compiler switches**</span></span>

<span data-ttu-id="feb1d-165">Visual Basic komut satırı derleyicisi artık başvuru derlemelerinin çıktısını denetlemek için [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) ve [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) derleyici seçeneklerini destekler.</span><span class="sxs-lookup"><span data-stu-id="feb1d-165">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="feb1d-166">**-refout,** başvuru derlemesinin çıktı dizini tanımlar ve **-refonly yalnızca** bir başvuru derlemesinin çıktı olacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-166">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="feb1d-167">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="feb1d-167">Visual Basic 2017</span></span>

[<span data-ttu-id="feb1d-168">**Dizilerini**</span><span class="sxs-lookup"><span data-stu-id="feb1d-168">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="feb1d-169">Tuples, tek bir yöntem çağrısından birden çok değer döndürmek için en sık kullanılan hafif bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-169">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="feb1d-170">Normalde, bir yöntemden birden çok değer döndürmek için aşağıdakilerden birini yapmanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="feb1d-170">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="feb1d-171">Özel bir tür `Class` (a `Structure`veya a) tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-171">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="feb1d-172">Bu ağır siklet bir çözüm.</span><span class="sxs-lookup"><span data-stu-id="feb1d-172">This is a heavyweight solution.</span></span>

- <span data-ttu-id="feb1d-173">Yöntemden bir `ByRef` değer döndürmeye ek olarak bir veya daha fazla parametre tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-173">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>

<span data-ttu-id="feb1d-174">Visual Basic'in tuples desteği, bir tuple'ı hızlı bir şekilde tanımlamanızı, isteğe bağlı olarak değerlere anlamsal adlar atamanızı ve değerlerini hızla almanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-174">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="feb1d-175">Aşağıdaki örnek, <xref:System.Int32.TryParse%2A> yönteme bir çağrı yıkıyor ve bir tuple döndürür.</span><span class="sxs-lookup"><span data-stu-id="feb1d-175">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="feb1d-176">Daha sonra yöntemi arayabilir ve aşağıdaki gibi kodile döndürülen tuple işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-176">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]

<span data-ttu-id="feb1d-177">**İkili edebi ve basamak ayırıcıları**</span><span class="sxs-lookup"><span data-stu-id="feb1d-177">**Binary literals and digit separators**</span></span>

<span data-ttu-id="feb1d-178">Önek `&B` veya `&b`.</span><span class="sxs-lookup"><span data-stu-id="feb1d-178">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="feb1d-179">Buna ek olarak, okunabilirliği artırmak `_`için bir basamak ayırıcı olarak alt karakter kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-179">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="feb1d-180">Aşağıdaki örnek, bir `Byte` değeri atamak ve ondalık, hexadecimal ve ikili sayı olarak görüntülemek için her iki özelliği kullanır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-180">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="feb1d-181">Daha fazla bilgi için, [Byte,](../language-reference/data-types/byte-data-type.md#literal-assignments) [Tümsa,](../language-reference/data-types/integer-data-type.md#literal-assignments) [Uzun,](../language-reference/data-types/long-data-type.md#literal-assignments) [Kısa,](../language-reference/data-types/short-data-type.md#literal-assignments) [SByte,](../language-reference/data-types/sbyte-data-type.md#literal-assignments) [UInteger,](../language-reference/data-types/uinteger-data-type.md#literal-assignments) [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments)ve [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) veri türlerinin "Literal atamaları" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-181">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

[<span data-ttu-id="feb1d-182">**C# referans iade değerleri için destek**</span><span class="sxs-lookup"><span data-stu-id="feb1d-182">**Support for C# reference return values**</span></span>](../programming-guide/language-features/procedures/ref-return-values.md)

<span data-ttu-id="feb1d-183">C# 7.0 ile başlayarak, C# referans dönüş değerlerini destekler.</span><span class="sxs-lookup"><span data-stu-id="feb1d-183">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="feb1d-184">Diğer bir süre, arama yöntemi başvuru yla döndürülen bir değer aldığında, başvurunun değerini değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-184">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="feb1d-185">Visual Basic, başvuru iade değerleriyle yöntemler yazmanıza izin vermez, ancak başvuru döndürme değerlerini tüketmenize ve değiştirmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="feb1d-185">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="feb1d-186">Örneğin, C# `Sentence` ile yazılmış bir `FindNext` sonraki sınıf, belirtilen bir alt dizeyle başlayan bir cümlede bir sonraki sözcüğü bulan bir yöntem içerir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-186">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="feb1d-187">Dize bir başvuru dönüş değeri olarak `Boolean` döndürülür ve yönteme başvuru ile geçirilen bir değişken aramanın başarılı olup olmadığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-187">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="feb1d-188">Bu, döndürülen değeri okumanın yanı sıra, arayanın da değiştirebileceği ve `Sentence` bu değişikliğin sınıfa yansıttığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-188">This means that in addition to reading the returned value, the caller can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="feb1d-189">En basit haliyle, cümlede bulunan sözcüğü aşağıdaki gibi kod kullanarak değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-189">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="feb1d-190">Yönteme bir değer atamadığınızı değil, yöntemin döndürdüğü ifadeye, yani referans iade değişimi olduğunusını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="feb1d-190">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="feb1d-191">Ancak bu kodla ilgili bir sorun, bir eşleşme bulunamazsa, yöntemin ilk sözcüğü döndürmesidir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-191">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="feb1d-192">Örnek, eşleşme bulunup bulunmadığını `Boolean` belirlemek için bağımsız değişkenin değerini incelemediğinden, eşleşme yoksa ilk sözcüğü değiştirir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-192">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="feb1d-193">Aşağıdaki örnek, eşleşme yoksa ilk sözcüğü kendisiyle değiştirerek bunu düzeltir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-193">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="feb1d-194">Daha iyi bir çözüm, başvuru iade değerinin başvuru yla geçirildiği bir yardımcı yöntemi kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-194">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="feb1d-195">Yardımcı yöntemi daha sonra başvuru ile ona geçirilen bağımsız değişkeni değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-195">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="feb1d-196">Aşağıdaki örnek bunu yapar.</span><span class="sxs-lookup"><span data-stu-id="feb1d-196">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="feb1d-197">Daha fazla bilgi için [Bkz. Başvuru İade Değerleri.](../programming-guide/language-features/procedures/ref-return-values.md)</span><span class="sxs-lookup"><span data-stu-id="feb1d-197">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="feb1d-198">Görsel Temel 14</span><span class="sxs-lookup"><span data-stu-id="feb1d-198">Visual Basic 14</span></span>

[<span data-ttu-id="feb1d-199">İsim</span><span class="sxs-lookup"><span data-stu-id="feb1d-199">NameOf</span></span>](../language-reference/operators/nameof.md)

<span data-ttu-id="feb1d-200">Bir dize kodlama olmadan bir hata iletisinde kullanılmak üzere bir türün veya üyenin niteliksiz dize adını alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-200">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="feb1d-201">Bu, yeniden düzenleme yaparken kodunuzun doğru kalmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="feb1d-201">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="feb1d-202">Bu özellik, model görünümü denetleyicim MVC bağlantılarını bağlamak ve değiştirilen olayları ateşlemek için de yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-202">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>

[<span data-ttu-id="feb1d-203">Dize ilişkilendirme</span><span class="sxs-lookup"><span data-stu-id="feb1d-203">String interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)

<span data-ttu-id="feb1d-204">Dizeleri oluşturmak için dize enterpolasyon ifadeleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-204">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="feb1d-205">Enterpolasyonlu dize ifadesi, ifadeler içeren bir şablon dizegibi görünür.</span><span class="sxs-lookup"><span data-stu-id="feb1d-205">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="feb1d-206">Enterpolasyonlu bir dize, bağımsız değişkenlerle ilgili olarak bileşik [biçimlendirmeden](../../standard/base-types/composite-formatting.md)daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-206">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-formatting.md).</span></span>

[<span data-ttu-id="feb1d-207">Null-koşullu üye erişimi ve dizinleme</span><span class="sxs-lookup"><span data-stu-id="feb1d-207">Null-conditional member access and indexing</span></span>](../language-reference/operators/null-conditional-operators.md)

<span data-ttu-id="feb1d-208">Bir üye erişimi ( ) veya dizin (`?.``?[]`) işlemini gerçekleştirmeden önce çok hafif bir sözdizimdizimi ile null için test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-208">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="feb1d-209">Bu işleçler, özellikle veri yapılarına inmek için null denetimleri işlemek için daha az kod yazmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="feb1d-209">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="feb1d-210">Sol operand veya nesne başvurusu null ise, işlemler null döndürür.</span><span class="sxs-lookup"><span data-stu-id="feb1d-210">If the left operand or object reference is null, the operations returns null.</span></span>

[<span data-ttu-id="feb1d-211">Çok çizgili dize edebi</span><span class="sxs-lookup"><span data-stu-id="feb1d-211">Multi-line string literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)

<span data-ttu-id="feb1d-212">String literals newline dizileri içerebilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-212">String literals can contain newline sequences.</span></span>  <span data-ttu-id="feb1d-213">Artık kullanma etrafında eski çalışma gerekir`<xml><![CDATA[...text with newlines...]]></xml>.Value`</span><span class="sxs-lookup"><span data-stu-id="feb1d-213">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>

<span data-ttu-id="feb1d-214">**Açıklamalar**</span><span class="sxs-lookup"><span data-stu-id="feb1d-214">**Comments**</span></span>

<span data-ttu-id="feb1d-215">Örtük satır devamlarından sonra, baş harf ifadelerin in içine ve LINQ ifade terimlerine yorum koyabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-215">You can put comments after implicit line continuations, inside initializer expressions, and among LINQ expression terms.</span></span>

<span data-ttu-id="feb1d-216">**Daha akıllı tam nitelikli ad çözünürlüğü**</span><span class="sxs-lookup"><span data-stu-id="feb1d-216">**Smarter fully-qualified name resolution**</span></span>

<span data-ttu-id="feb1d-217">"Threading" `Threading.Thread.Sleep(1000)`ad alanını aramak için kullanılan Visual Basic gibi kodlar göz önüne alındığında, System.Threading ve System.Windows.Threading arasında belirsiz olduğunu keşfedin ve ardından bir hata bildirin.</span><span class="sxs-lookup"><span data-stu-id="feb1d-217">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="feb1d-218">Visual Basic artık her iki olası ad alanlarını birlikte ele alır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-218">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="feb1d-219">Tamamlanma listesini gösterirseniz, Visual Studio düzenleyicisi tamamlanma listesinde ki her iki türdeki üyeleri listeler.</span><span class="sxs-lookup"><span data-stu-id="feb1d-219">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>

<span data-ttu-id="feb1d-220">**Yıl-ilk tarih literals**</span><span class="sxs-lookup"><span data-stu-id="feb1d-220">**Year-first date literals**</span></span>

<span data-ttu-id="feb1d-221">Tarih edebi yy-mm-dd formatında `#2015-03-17 16:10 PM#`olabilir.</span><span class="sxs-lookup"><span data-stu-id="feb1d-221">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>

<span data-ttu-id="feb1d-222">**Readonly arabirim özellikleri**</span><span class="sxs-lookup"><span data-stu-id="feb1d-222">**Readonly interface properties**</span></span>

<span data-ttu-id="feb1d-223">Readwrite özelliğini kullanarak readonly arabirim özelliklerini uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-223">You can implement readonly interface properties using a readwrite property.</span></span> <span data-ttu-id="feb1d-224">Arabirim minimum işlevselliği garanti eder ve uygulama sınıfının özelliğin ayarlanmasına izin vermesini engellemez.</span><span class="sxs-lookup"><span data-stu-id="feb1d-224">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>

[<span data-ttu-id="feb1d-225">TypeOf \<expr> \<IsNot türü></span><span class="sxs-lookup"><span data-stu-id="feb1d-225">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)

<span data-ttu-id="feb1d-226">Kodunuzu daha fazla okunabilirlik için, `TypeOf` `IsNot`artık .</span><span class="sxs-lookup"><span data-stu-id="feb1d-226">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>

[<span data-ttu-id="feb1d-227">#Disable \<Uyarı Kimliği> \<ve #Enable Uyarı Kimliği></span><span class="sxs-lookup"><span data-stu-id="feb1d-227">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/index.md)

<span data-ttu-id="feb1d-228">Kaynak dosyadaki bölgeler için belirli uyarıları devre dışı bırakıp etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-228">You can disable and enable specific warnings for regions within a source file.</span></span>

<span data-ttu-id="feb1d-229">**XML doc yorum geliştirmeleri**</span><span class="sxs-lookup"><span data-stu-id="feb1d-229">**XML doc comment improvements**</span></span>

<span data-ttu-id="feb1d-230">Doküman yorumları yazarken, akıllı düzenleyici alır sınız ve parametre adlarını doğrulamak, `crefs` (genel ler, operatörler, vb.) doğru şekilde işlemek, renklendirme kılabilir ve yeniden düzenleme için destek oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-230">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>

[<span data-ttu-id="feb1d-231">Kısmi modül ve arayüz tanımları</span><span class="sxs-lookup"><span data-stu-id="feb1d-231">Partial module and interface definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)

<span data-ttu-id="feb1d-232">Sınıflara ve yapılara ek olarak, kısmi modülleri ve arabirimleri bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-232">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>

[<span data-ttu-id="feb1d-233">yöntem gövdeleri içinde #Region direktifleri</span><span class="sxs-lookup"><span data-stu-id="feb1d-233">#Region directives inside method bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)

<span data-ttu-id="feb1d-234">#Region...#End Bölge sınırlayıcılarını bir dosyanın herhangi bir yerine, işlevlerin içinde ve hatta işlev gövdeleri arasında yayılan herhangi bir yere koyabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-234">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>

[<span data-ttu-id="feb1d-235">Geçersiz kılar tanımlar örtülü olarak aşırı yükler</span><span class="sxs-lookup"><span data-stu-id="feb1d-235">Overrides definitions are implicitly overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)

<span data-ttu-id="feb1d-236">`Overrides` Değiştiriciyi bir tanıma eklerseniz, derleyici genellikle `Overloads` daha az kod yazabilmeniz için dolaylı olarak ekler.</span><span class="sxs-lookup"><span data-stu-id="feb1d-236">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>

<span data-ttu-id="feb1d-237">**CObj öznitelikleri bağımsız değişkenlerde izin**</span><span class="sxs-lookup"><span data-stu-id="feb1d-237">**CObj allowed in attributes arguments**</span></span>

<span data-ttu-id="feb1d-238">Derleyici, öznitelik yapılarında kullanıldığında CObj(...) sabit olmadığı hatasını vermek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="feb1d-238">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>

<span data-ttu-id="feb1d-239">**Farklı arabirimlerden belirsiz yöntemleri bildirme ve tüketme**</span><span class="sxs-lookup"><span data-stu-id="feb1d-239">**Declaring and consuming ambiguous methods from different interfaces**</span></span>

<span data-ttu-id="feb1d-240">Daha önce aşağıdaki kod, bildirmenizi `IMock` veya aramanızı `GetDetails` engelleyen hatalar ortaya çıkar (bunlar C#'da bildirilmişse):</span><span class="sxs-lookup"><span data-stu-id="feb1d-240">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>

```vb
Interface ICustomer
  Sub GetDetails(x As Integer)
End Interface

Interface ITime
  Sub GetDetails(x As String)
End Interface

Interface IMock : Inherits ICustomer, ITime
  Overloads Sub GetDetails(x As Char)
End Interface

Interface IMock2 : Inherits ICustomer, ITime
End Interface
```

<span data-ttu-id="feb1d-241">Şimdi derleyici, aramak için en uygun `GetDetails` olanı seçmek için normal aşırı yük çözümleme kurallarını kullanır ve örnekte gösterildiği gibi Visual Basic'te arabirim ilişkilerini bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-241">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>

## <a name="see-also"></a><span data-ttu-id="feb1d-242">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="feb1d-242">See also</span></span>

- [<span data-ttu-id="feb1d-243">Visual Studio 2017'de Yenilikler</span><span class="sxs-lookup"><span data-stu-id="feb1d-243">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-visual-studio-2017)
- [<span data-ttu-id="feb1d-244">Visual Studio 2019'da Yenilikler</span><span class="sxs-lookup"><span data-stu-id="feb1d-244">What's New in Visual Studio 2019</span></span>](/visualstudio/ide/whats-new-visual-studio-2019)
