---
title: Kapsayıcılardan ve düzenleyicilerden yararlanma
description: Azure 'da Docker kapsayıcılarını ve Kubernetes düzenleyicilerinden yararlanın
ms.date: 01/19/2021
ms.openlocfilehash: 63ac91b05a88dc13b7c62e6e04eecb0550cd4652
ms.sourcegitcommit: f2ab02d9a780819ca2e5310bbcf5cfe5b7993041
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/03/2021
ms.locfileid: "99505760"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="981cf-103">Kapsayıcılardan ve düzenleyicilerden yararlanma</span><span class="sxs-lookup"><span data-stu-id="981cf-103">Leveraging containers and orchestrators</span></span>

<span data-ttu-id="981cf-104">Kapsayıcılar ve düzenleyiciler, tek parçalı dağıtım yaklaşımları için ortak olan sorunları çözmeye yönelik olarak tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="981cf-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="981cf-105">Tek parçalı dağıtımlar ile ilgili sorunlar</span><span class="sxs-lookup"><span data-stu-id="981cf-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="981cf-106">Geleneksel olarak, çoğu uygulama tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="981cf-107">Bu tür uygulamalar tek bir olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="981cf-108">Bu genel yaklaşım, birden çok modülden oluşsa bile veya derlemeler şekil 3-1 ' de gösterildiği gibi tek parçalı mimari olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="981cf-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![Tek parçalı mimari.](./media/monolithic-design.png)

<span data-ttu-id="981cf-110">**Şekil 3-1**.</span><span class="sxs-lookup"><span data-stu-id="981cf-110">**Figure 3-1**.</span></span> <span data-ttu-id="981cf-111">Tek parçalı mimari.</span><span class="sxs-lookup"><span data-stu-id="981cf-111">Monolithic architecture.</span></span>

<span data-ttu-id="981cf-112">Basitlik avantajlarına sahip olsalar da tek parçalı mimarilerin bir dizi zorluk yüzü vardır:</span><span class="sxs-lookup"><span data-stu-id="981cf-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="981cf-113">Dağıtım</span><span class="sxs-lookup"><span data-stu-id="981cf-113">Deployment</span></span>

<span data-ttu-id="981cf-114">Ayrıca, dağıtım sırasında sıfır kesinti süresi tekniklerin uygulanmadığında kullanılabilirliği geçici olarak etkileyebilecek uygulamanın yeniden başlatılmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="981cf-114">Additionally, they require a restart of the application, which may temporarily impact availability if zero-downtime techniques are not applied while deploying.</span></span>

### <a name="scaling"></a><span data-ttu-id="981cf-115">Ölçeklendirme</span><span class="sxs-lookup"><span data-stu-id="981cf-115">Scaling</span></span>

<span data-ttu-id="981cf-116">Tek parçalı bir uygulama, genellikle yüksek yetenek donanımlar gerektiren tek bir makine örneğinde barındırılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-116">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="981cf-117">Tekinin herhangi bir bölümü ölçeklendirmeyi gerektiriyorsa, uygulamanın tamamının başka bir kopyasının başka bir makineye dağıtılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="981cf-117">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="981cf-118">Tek tek, uygulama bileşenlerini ayrı ayrı ölçeklendiremez. Bu, hepsi veya hiçbir şey değildir.</span><span class="sxs-lookup"><span data-stu-id="981cf-118">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="981cf-119">Ölçeklendirme gerektirmeyen bileşenleri ölçeklendirme, verimsiz ve maliyetli kaynak kullanımı ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="981cf-119">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="981cf-120">Ortam</span><span class="sxs-lookup"><span data-stu-id="981cf-120">Environment</span></span>

<span data-ttu-id="981cf-121">Tek parçalı uygulamalar, genellikle önceden yüklenmiş bir işletim sistemi, çalışma zamanı ve kitaplık bağımlılıkları olan bir barındırma ortamına dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-121">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="981cf-122">Bu ortam, uygulamanın geliştirildiğini veya test edildiğini eşleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-122">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="981cf-123">Uygulama ortamları genelinde tutarsızlıklar, tek parçalı dağıtımlar için ortak bir sorun kaynağıdır.</span><span class="sxs-lookup"><span data-stu-id="981cf-123">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="981cf-124">Bağlantısı</span><span class="sxs-lookup"><span data-stu-id="981cf-124">Coupling</span></span>

<span data-ttu-id="981cf-125">Tek parçalı bir uygulama, işlevsel bileşenleri arasında yüksek bir bağ deneyimlidir.</span><span class="sxs-lookup"><span data-stu-id="981cf-125">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="981cf-126">Sabit sınır olmadan sistem değişiklikleri genellikle istenmeden ve pahalı yan etkilere neden olur.</span><span class="sxs-lookup"><span data-stu-id="981cf-126">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="981cf-127">Yeni özellikler/düzeltmeler, uygulama için karmaşık, zaman alan ve pahalı hale gelir.</span><span class="sxs-lookup"><span data-stu-id="981cf-127">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="981cf-128">Güncelleştirmeler kapsamlı test gerektirir.</span><span class="sxs-lookup"><span data-stu-id="981cf-128">Updates require extensive testing.</span></span> <span data-ttu-id="981cf-129">Ayrıca, geçiş, bileşenleri yeniden düzenleme veya alternatif uygulamalarda değiştirme olanağı da zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="981cf-129">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="981cf-130">Sıkı bir sorun ayrımı ile oluşturulduğunda bile, tek parçalı kod tabanı olarak ' deki mimari liflik kümeleri, hiçbir zaman sonlandırma "özel durumlar" ile birlikte oluşur.</span><span class="sxs-lookup"><span data-stu-id="981cf-130">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="981cf-131">Platform kilidi-ın</span><span class="sxs-lookup"><span data-stu-id="981cf-131">Platform lock-in</span></span>

<span data-ttu-id="981cf-132">Tek parçalı bir uygulama tek bir teknoloji yığını ile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="981cf-132">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="981cf-133">Bu taahhüt, bir yeniliği sunarken, yeniliklere bir engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-133">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="981cf-134">Yeni özellikler ve bileşenler, daha modern teknolojiler daha iyi bir seçim olabileceği halde uygulamanın geçerli yığını kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="981cf-134">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="981cf-135">Daha uzun süreli bir risk, teknoloji yığınınızın süresi geçmiş ve kullanım dışı olma sürecinde.</span><span class="sxs-lookup"><span data-stu-id="981cf-135">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="981cf-136">Tüm uygulamayı yeni, daha modern bir platforma yeniden tasarlama en iyi maliyetli ve riskli bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="981cf-136">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="981cf-137">Kapsayıcıların ve düzenleyicilerinin avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="981cf-137">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="981cf-138">Bölüm 1 ' de kapsayıcılar tanıtıldık.</span><span class="sxs-lookup"><span data-stu-id="981cf-138">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="981cf-139">Cloud Native Bilgi Işlem altyapısı 'nın (CNCF) kapsayıcının bulut Yerel [Izleme haritalarındaki](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) ilk adım olarak nasıl derecelendirmiş olduğunu vurgularız.</span><span class="sxs-lookup"><span data-stu-id="981cf-139">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="981cf-140">Bu bölümde, kapsayıcıların avantajları tartışıyoruz.</span><span class="sxs-lookup"><span data-stu-id="981cf-140">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="981cf-141">Docker en popüler kapsayıcı yönetimi platformudur.</span><span class="sxs-lookup"><span data-stu-id="981cf-141">Docker is the most popular container management platform.</span></span> <span data-ttu-id="981cf-142">Hem Linux hem de Windows üzerinde kapsayıcılarla birlikte çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="981cf-142">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="981cf-143">Kapsayıcılar, her sistemde aynı şekilde çalışan ayrı ancak tekrarlanabilir uygulama ortamları sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-143">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="981cf-144">Bu boyut, bulutta yerel hizmetler geliştirmek ve barındırmak için ideal hale getirir.</span><span class="sxs-lookup"><span data-stu-id="981cf-144">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="981cf-145">Kapsayıcılar bir diğerinden yalıtılmıştır.</span><span class="sxs-lookup"><span data-stu-id="981cf-145">Containers are isolated from one another.</span></span> <span data-ttu-id="981cf-146">Aynı konak donanımında iki kapsayıcı, çakışmalara neden olmadan farklı yazılım sürümlerine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-146">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="981cf-147">Kapsayıcılar, proje yapıtları haline gelen ve kaynak denetimine işaretlenmiş basit metin tabanlı dosyalar tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="981cf-147">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="981cf-148">Tam sunucular ve sanal makinelerin güncelleştirilmesi için el ile çaba gerektirmesi durumunda, kapsayıcılar kolayca sürüm denetlenir.</span><span class="sxs-lookup"><span data-stu-id="981cf-148">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="981cf-149">Kapsayıcılarda çalışmak üzere oluşturulan uygulamalar, derleme işlem hattının parçası olarak otomatikleştirilmiş araçlar kullanılarak geliştirilebilir, test edilebilir ve dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-149">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="981cf-150">Kapsayıcılar sabittir.</span><span class="sxs-lookup"><span data-stu-id="981cf-150">Containers are immutable.</span></span> <span data-ttu-id="981cf-151">Bir kapsayıcı tanımladıktan sonra, tam olarak aynı şekilde yeniden oluşturabilir ve çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-151">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="981cf-152">Bu, bu şekilde bileşen tabanlı tasarıma yönelik olarak kullanılabilirlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-152">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="981cf-153">Bir uygulamanın bazı bölümleri diğerlerinden farklı şekilde geliştikçe, en sık değiştiren parçaları yalnızca dağıtırken uygulamanın tamamını yeniden dağıtmanız gerekir mi?</span><span class="sxs-lookup"><span data-stu-id="981cf-153">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="981cf-154">Bir uygulamanın farklı özellikleri ve çapraz kesme sorunları ayrı birimlere ayrılabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-154">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="981cf-155">Şekil 3-2, tek parçalı bir uygulamanın belirli özellikler veya işlevler için kapsayıcılardan ve mikro hizmetlerden nasıl yararlanabileceğiz gösterir.</span><span class="sxs-lookup"><span data-stu-id="981cf-155">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="981cf-156">Uygulamanın kendisindeki diğer işlevsellik de Kapsayıcılı hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-156">The remaining functionality in the app itself has also been containerized.</span></span>

![Arka uçta mikro hizmetleri kullanmak için tek parçalı bir uygulamayı bölmek.](./media/cloud-native-design.png)

<span data-ttu-id="981cf-158">**Şekil 3-2**.</span><span class="sxs-lookup"><span data-stu-id="981cf-158">**Figure 3-2**.</span></span> <span data-ttu-id="981cf-159">Tek parçalı bir uygulamayı, mikro hizmetlere çok parçalı bir uygulama oluşturmayı kaldırma.</span><span class="sxs-lookup"><span data-stu-id="981cf-159">Decomposing a monolithic app to embrace microservices.</span></span>

<span data-ttu-id="981cf-160">Her bulut Yerel hizmeti ayrı bir kapsayıcıda oluşturulup dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-160">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="981cf-161">Her biri gerektiğinde güncelleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-161">Each can update as needed.</span></span> <span data-ttu-id="981cf-162">Her hizmet için uygun kaynakları olan düğümlerde tek tek hizmetler barındırılabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-162">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="981cf-163">Her hizmetin çalıştığı ortam, geliştirme, test ve üretim ortamlarında paylaşılan ve kolayca sürümlü bir sabittir.</span><span class="sxs-lookup"><span data-stu-id="981cf-163">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="981cf-164">Uygulamanın farklı alanlarında, tek başına derleme zamanı bağımlılıkları değil, hizmetler arasında doğrudan çağrı veya ileti olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-164">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="981cf-165">Ayrıca, uygulamanın geri kalanında değişiklik gerektirmeden belirli bir özelliği en iyi şekilde sunan teknolojiyi de seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-165">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="981cf-166">Kapsayıcılı hizmetler otomatik yönetim gerektirir.</span><span class="sxs-lookup"><span data-stu-id="981cf-166">Containerized services require automated management.</span></span> <span data-ttu-id="981cf-167">Bağımsız olarak dağıtılan kapsayıcıların büyük bir kümesini el ile yönetmek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="981cf-167">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="981cf-168">Örneğin, aşağıdaki görevleri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="981cf-168">For example, consider the following tasks:</span></span>

- <span data-ttu-id="981cf-169">Kapsayıcı örnekleri birçok makinenin bir kümesi arasında nasıl sağlanacak?</span><span class="sxs-lookup"><span data-stu-id="981cf-169">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="981cf-170">Dağıtıldıktan sonra kapsayıcılar birbirleriyle nasıl keşfedilir ve birbirleriyle iletişim kurar?</span><span class="sxs-lookup"><span data-stu-id="981cf-170">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="981cf-171">Kapsayıcılar isteğe bağlı olarak nasıl ölçeklenebilen veya kullanıma hazır?</span><span class="sxs-lookup"><span data-stu-id="981cf-171">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="981cf-172">Her kapsayıcının durumunu nasıl izleyebilirim?</span><span class="sxs-lookup"><span data-stu-id="981cf-172">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="981cf-173">Bir kapsayıcıyı donanım ve yazılım hatalarıyla nasıl koruyabilirim?</span><span class="sxs-lookup"><span data-stu-id="981cf-173">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="981cf-174">Canlı bir uygulama için kapsayıcıları sıfır kapalı kalma süresiyle nasıl yükseltebilirim?</span><span class="sxs-lookup"><span data-stu-id="981cf-174">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="981cf-175">Kapsayıcı yöneticileri bu ve diğer kaygıları ele alır ve otomatikleştirin.</span><span class="sxs-lookup"><span data-stu-id="981cf-175">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="981cf-176">Bulut Yerel ekonomik sistemde, Kubernetes, kapsayıcı Orchestrator ' ı d haline geldi.</span><span class="sxs-lookup"><span data-stu-id="981cf-176">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="981cf-177">Bu, bulut Yerel Bilgi Işlem altyapısı (CNCF) tarafından yönetilen açık kaynaklı bir platformdur.</span><span class="sxs-lookup"><span data-stu-id="981cf-177">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="981cf-178">Kubernetes, bir makine kümesi içindeki Kapsayıcılı iş yüklerinin dağıtım, ölçeklendirme ve işlevsel sorunlarını otomatikleştirir.</span><span class="sxs-lookup"><span data-stu-id="981cf-178">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="981cf-179">Ancak, Kubernetes 'nin yüklenmesi ve yönetilmesi, önemli bir karmaşıkdır.</span><span class="sxs-lookup"><span data-stu-id="981cf-179">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="981cf-180">Daha iyi bir yaklaşım, Kubernetes 'in bir bulut satıcısından yönetilen hizmet olarak faydalanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="981cf-180">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="981cf-181">Azure bulut, [Azure Kubernetes hizmeti (AKS)](https://azure.microsoft.com/services/kubernetes-service/)ile tam olarak yönetilen bir Kubernetes platformu sunar.</span><span class="sxs-lookup"><span data-stu-id="981cf-181">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="981cf-182">AKS, Kubernetes yönetiminin karmaşıklık ve operasyonel yükünü soyutlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-182">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="981cf-183">Kubernetes 'i bir bulut hizmeti olarak kullanırsınız; Microsoft, yönetim ve destekleme sorumluluğunu kullanır.</span><span class="sxs-lookup"><span data-stu-id="981cf-183">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="981cf-184">AKS, diğer Azure hizmetleri ve geliştirme araçlarıyla da sıkı bir şekilde tümleşir.</span><span class="sxs-lookup"><span data-stu-id="981cf-184">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="981cf-185">AKS, küme temelli bir teknolojidir.</span><span class="sxs-lookup"><span data-stu-id="981cf-185">AKS is a cluster-based technology.</span></span> <span data-ttu-id="981cf-186">Federasyon sanal makineleri veya düğümleri havuzu Azure bulutuna dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-186">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="981cf-187">Bunlar, yüksek oranda kullanılabilir bir ortam veya küme oluşturur.</span><span class="sxs-lookup"><span data-stu-id="981cf-187">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="981cf-188">Küme, bulutta yerel uygulamanıza sorunsuz, tek bir varlık olarak görünür.</span><span class="sxs-lookup"><span data-stu-id="981cf-188">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="981cf-189">Bu şekilde, AKS 'ler, yükü eşit bir şekilde dağıtan önceden tanımlanmış bir stratejiye göre Kapsayıcılı hizmetlerinizi bu düğümler arasında dağıtır.</span><span class="sxs-lookup"><span data-stu-id="981cf-189">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="981cf-190">Ölçeklendirme avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="981cf-190">What are the scaling benefits?</span></span>

<span data-ttu-id="981cf-191">Kapsayıcılarda oluşturulan hizmetler, Kubernetes gibi Orchestration araçları tarafından sunulan ölçeklendirme avantajlarından yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-191">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="981cf-192">Tasarım kapsayıcıları tarafından yalnızca kendileri hakkında bilgi sahibi.</span><span class="sxs-lookup"><span data-stu-id="981cf-192">By design containers only know about themselves.</span></span> <span data-ttu-id="981cf-193">Birlikte çalışması gereken birden çok kapsayıcınız varsa, bunları daha yüksek bir düzeyde düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="981cf-193">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="981cf-194">Çok sayıda kapsayıcıyı ve ağ yapılandırması gibi paylaşılan bağımlılıklarını organize etmek, düzenleme araçlarının günü kaydetmek için nereden geldiği yerdir!</span><span class="sxs-lookup"><span data-stu-id="981cf-194">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="981cf-195">Kubernetes kapsayıcı grupları üzerinde bir soyutlama katmanı oluşturur ve bunları *Pod* olarak düzenler.</span><span class="sxs-lookup"><span data-stu-id="981cf-195">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="981cf-196">*Düğüm* olarak adlandırılan çalışan makinelerdeki pods çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-196">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="981cf-197">Bu düzenlenmiş yapı, *küme* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-197">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="981cf-198">Şekil 3-3, bir Kubernetes kümesinin farklı bileşenlerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="981cf-198">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="981cf-199">![Kubernetes kümesi bileşenleri. ](./media/kubernetes-cluster-components.png)
 **Şekil 3-3**.</span><span class="sxs-lookup"><span data-stu-id="981cf-199">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="981cf-200">Kubernetes kümesi bileşenleri.</span><span class="sxs-lookup"><span data-stu-id="981cf-200">Kubernetes cluster components.</span></span>

<span data-ttu-id="981cf-201">Kapsayıcılı iş yüklerinin ölçeklendirilmesi, kapsayıcı düzenleyicilerinin temel bir özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="981cf-201">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="981cf-202">AKS iki boyut genelinde otomatik ölçeklendirmeyi destekler: kapsayıcı örnekleri ve işlem düğümleri.</span><span class="sxs-lookup"><span data-stu-id="981cf-202">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="981cf-203">Birlikte, isteğe bağlı olarak ani artışları hızla ve verimli bir şekilde yanıtlama ve ek kaynaklar ekleme olanağı sunar.</span><span class="sxs-lookup"><span data-stu-id="981cf-203">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="981cf-204">Bu bölümün ilerleyen kısımlarında, ölçeklendirilirken ölçeklendirmeyi tartıştık.</span><span class="sxs-lookup"><span data-stu-id="981cf-204">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="981cf-205">Bildirime dayalı ve kesinlik</span><span class="sxs-lookup"><span data-stu-id="981cf-205">Declarative versus imperative</span></span>

<span data-ttu-id="981cf-206">Kubernetes hem bildirime dayalı hem de kesinlik temelli yapılandırmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="981cf-206">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="981cf-207">Zorunlu yaklaşım, Kubernetes 'in her adımın nasıl yapılacağını söyleyen çeşitli komutları çalıştırmayı içerir.</span><span class="sxs-lookup"><span data-stu-id="981cf-207">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="981cf-208">Bu görüntüyü çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="981cf-208">Run this image.</span></span> <span data-ttu-id="981cf-209">Bu Pod öğesini silin.</span><span class="sxs-lookup"><span data-stu-id="981cf-209">Delete this pod.</span></span> <span data-ttu-id="981cf-210">Bu bağlantı noktasını kullanıma sunun.</span><span class="sxs-lookup"><span data-stu-id="981cf-210">Expose this port.</span></span> <span data-ttu-id="981cf-211">Bildirim temelli yaklaşımla, ne yapmak istediğinizi belirlemek için bildirim olarak adlandırılan bir yapılandırma dosyası oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="981cf-211">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="981cf-212">Kubernetes bildirimi okur ve istediğiniz bitiş durumunu gerçek bitiş durumuna dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="981cf-212">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="981cf-213">Zorunlu komutların öğrenimi ve etkileşimli deneme için harika olması.</span><span class="sxs-lookup"><span data-stu-id="981cf-213">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="981cf-214">Ancak, güvenilir ve tekrarlanabilir dağıtımlar sağlayan bir altyapıyı kod yaklaşımı olarak ayraç içine almak için, bildirimli olarak Kubernetes bildirim dosyalarını oluşturmak isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-214">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="981cf-215">Bildirim dosyası bir proje yapıtı haline gelir ve Kubernetes dağıtımlarını otomatikleştirmek için CI/CD işlem hattınızda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-215">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="981cf-216">Kümenizi tanımlayıcı komutları kullanarak zaten yapılandırdıysanız, kullanarak bildirim temelli bir bildirimi dışarı aktarabilirsiniz `kubectl get svc SERVICENAME -o yaml > service.yaml` .</span><span class="sxs-lookup"><span data-stu-id="981cf-216">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="981cf-217">Bu komut aşağıda gösterilene benzer bir bildirim üretir:</span><span class="sxs-lookup"><span data-stu-id="981cf-217">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="981cf-218">Bildirim temelli yapılandırma kullanırken, `kubectl diff -f FOLDERNAME` yapılandırma dosyalarınızın bulunduğu klasöre karşı uygulamadan önce yapılacak değişikliklerin önizlemesini yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-218">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="981cf-219">Değişiklikleri uygulamak istediğinize emin olduktan sonra çalıştırın `kubectl apply -f FOLDERNAME` .</span><span class="sxs-lookup"><span data-stu-id="981cf-219">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="981cf-220">`-R`Bir klasör hiyerarşisini yinelemeli olarak işlemeye ekleyin.</span><span class="sxs-lookup"><span data-stu-id="981cf-220">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="981cf-221">Ayrıca, biri dağıtımları olan diğer Kubernetes özellikleriyle bildirim temelli yapılandırma de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-221">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="981cf-222">Bildirim temelli dağıtımlar, yayınları, güncelleştirmeleri ve ölçeklendirmeyi yönetmeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="981cf-222">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="981cf-223">Bu kişiler, Kubernetes dağıtım denetleyicisine yeni değişiklikler dağıtma, yük genişletme veya önceki bir düzeltmeye geri dönme işlemlerini yönlendirir.</span><span class="sxs-lookup"><span data-stu-id="981cf-223">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="981cf-224">Bir küme kararsız durumdaysa, bildirime dayalı bir dağıtım otomatik olarak kümeyi istenen duruma geri döndürür.</span><span class="sxs-lookup"><span data-stu-id="981cf-224">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="981cf-225">Örneğin, bir düğüm kilitlenmelidir, dağıtım mekanizması istediğiniz duruma ulaşmak için bir değişikliği yeniden dağıtırsınız</span><span class="sxs-lookup"><span data-stu-id="981cf-225">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="981cf-226">Bildirim temelli yapılandırma kullanmak, altyapının uygulama kodu ile birlikte denetlenebilen ve sürümü oluşturulmuş bir kod olarak temsil etmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="981cf-226">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="981cf-227">Yapı ve dağıtım işlem hattı kullanarak sürekli dağıtım için geliştirilmiş değişiklik denetimi ve daha iyi destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-227">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="981cf-228">Kapsayıcılar ve düzenleyiciler için hangi senaryolar idealdir?</span><span class="sxs-lookup"><span data-stu-id="981cf-228">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="981cf-229">Aşağıdaki senaryolar kapsayıcıları ve düzenlemeleri kullanmak için idealdir.</span><span class="sxs-lookup"><span data-stu-id="981cf-229">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="981cf-230">Yüksek çalışma süresi ve ölçeklenebilirlik gerektiren uygulamalar</span><span class="sxs-lookup"><span data-stu-id="981cf-230">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="981cf-231">Yüksek çalışma süresi ve ölçeklenebilirlik gereksinimleri olan bireysel uygulamalar, mikro hizmetler, kapsayıcılar ve düzenleyicilerin kullanıldığı bulutta yerel mimariler için ideal adaylardır.</span><span class="sxs-lookup"><span data-stu-id="981cf-231">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="981cf-232">Bunlar kapsayıcılarda geliştirilir, sürümlü ortamlar arasında test edilebilir ve sıfır kapalı kalma süresiyle üretime dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="981cf-232">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="981cf-233">Kubernetes kümelerinin kullanımı, bu tür uygulamaların talep üzerine ölçeklenmesini ve düğüm hatalarından otomatik olarak kurtarılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-233">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="981cf-234">Çok sayıda uygulama</span><span class="sxs-lookup"><span data-stu-id="981cf-234">Large numbers of applications</span></span>

<span data-ttu-id="981cf-235">Çok sayıda uygulamayı dağıtan ve bunları yöneten kuruluşlar, kapsayıcılardan ve düzenleyicilerinden faydalanır.</span><span class="sxs-lookup"><span data-stu-id="981cf-235">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="981cf-236">Kapsayıcılı ortamları ve Kubernetes kümelerini ayarlamanın en ön çabası, birincil olarak sabit bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="981cf-236">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="981cf-237">Bireysel uygulamaların dağıtımı, sürdürülmesi ve güncelleştirilmesi, uygulama sayısıyla değişen bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="981cf-237">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="981cf-238">Az sayıda uygulamanın ötesinde, özel uygulamaları korumanın karmaşıklığı kapsayıcıları ve düzenlemeleri kullanarak bir çözüm uygulama masrafını daha da aşıyor.</span><span class="sxs-lookup"><span data-stu-id="981cf-238">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="981cf-239">Kapsayıcıları ve düzenlemeleri kullanmaktan ne zaman kaçınmalısınız?</span><span class="sxs-lookup"><span data-stu-id="981cf-239">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="981cf-240">Uygulamanızı Twelve-Factor uygulama ilkelerine göre derlemenize, kapsayıcılardan ve düzenleyicilerinin önlenmemesini düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-240">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="981cf-241">Bu durumlarda, VM tabanlı bir barındırma platformunu veya büyük olasılıkla bazı karma sistemleri göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="981cf-241">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="981cf-242">Bununla birlikte, belirli işlevsellik parçalarını her zaman ayrı kapsayıcılara veya hatta sunucusuz işlevlere ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-242">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="981cf-243">Geliştirme kaynakları</span><span class="sxs-lookup"><span data-stu-id="981cf-243">Development resources</span></span>

<span data-ttu-id="981cf-244">Bu bölümde, bir sonraki uygulamanız için kapsayıcıları ve düzenlemeleri kullanmaya başlamanıza yardımcı olabilecek geliştirme kaynaklarının kısa bir listesi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="981cf-244">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="981cf-245">Bulut Yerel mikro hizmetleri mimari uygulamanızı nasıl tasarlayacağımızı öğrenmek istiyorsanız bu kitabın yardımcı, [.net mikro hizmetleri: Kapsayıcılı .NET uygulamaları Için mimari](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)makalesini okuyun.</span><span class="sxs-lookup"><span data-stu-id="981cf-245">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="981cf-246">Yerel Kubernetes geliştirme</span><span class="sxs-lookup"><span data-stu-id="981cf-246">Local Kubernetes Development</span></span>

<span data-ttu-id="981cf-247">Kubernetes dağıtımları üretim ortamlarında harika bir değer sağlar, ancak geliştirme makinenizde yerel olarak da çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-247">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="981cf-248">Bağımsız mikro hizmetlerde bağımsız olarak çalışabilir, ancak üretime dağıtıldığında çalıştırılacak şekilde tüm sistemi yerel olarak çalıştırmanız gereken zamanlar olabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-248">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="981cf-249">Yardımcı olabilecek çeşitli araçlar vardır: Minikube ve Docker Desktop.</span><span class="sxs-lookup"><span data-stu-id="981cf-249">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="981cf-250">Visual Studio, Docker geliştirmesi için de araç sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-250">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="981cf-251">Minikube</span><span class="sxs-lookup"><span data-stu-id="981cf-251">Minikube</span></span>

<span data-ttu-id="981cf-252">Minikube nedir?</span><span class="sxs-lookup"><span data-stu-id="981cf-252">What is Minikube?</span></span> <span data-ttu-id="981cf-253">Minikube projesi, "Minikube macOS, Linux ve Windows üzerinde yerel bir Kubernetes kümesi uygular" diyor.</span><span class="sxs-lookup"><span data-stu-id="981cf-253">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="981cf-254">Birincil hedefleri, "yerel Kubernetes uygulama geliştirmesi için en iyi araç olacak ve sığan Kubernetes özelliklerini desteklemeye yöneliktir."</span><span class="sxs-lookup"><span data-stu-id="981cf-254">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="981cf-255">Minikube yükleme Docker 'dan ayrıdır, ancak Minikube, Docker Desktop 'ın desteklediğinden farklı hiper yöneticileri destekler.</span><span class="sxs-lookup"><span data-stu-id="981cf-255">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="981cf-256">Aşağıdaki Kubernetes özellikleri şu anda Minikube tarafından desteklenmektedir:</span><span class="sxs-lookup"><span data-stu-id="981cf-256">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="981cf-257">DNS</span><span class="sxs-lookup"><span data-stu-id="981cf-257">DNS</span></span>
- <span data-ttu-id="981cf-258">NodePorts</span><span class="sxs-lookup"><span data-stu-id="981cf-258">NodePorts</span></span>
- <span data-ttu-id="981cf-259">ConfigMaps ve gizlilikler</span><span class="sxs-lookup"><span data-stu-id="981cf-259">ConfigMaps and secrets</span></span>
- <span data-ttu-id="981cf-260">Panolar</span><span class="sxs-lookup"><span data-stu-id="981cf-260">Dashboards</span></span>
- <span data-ttu-id="981cf-261">Kapsayıcı çalışma zamanları: Docker, RKT, CRı-O ve containerd</span><span class="sxs-lookup"><span data-stu-id="981cf-261">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="981cf-262">Kapsayıcı ağ arabirimini etkinleştirme (CNı)</span><span class="sxs-lookup"><span data-stu-id="981cf-262">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="981cf-263">Giriş</span><span class="sxs-lookup"><span data-stu-id="981cf-263">Ingress</span></span>

<span data-ttu-id="981cf-264">Minikube yükledikten sonra, `minikube start` bir görüntüyü yükleyen ve yerel Kubernetes kümesini Başlatan komutunu çalıştırarak hızlı bir şekilde kullanmaya başlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-264">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="981cf-265">Küme başlatıldıktan sonra, standart Kubernetes komutlarını kullanarak onunla etkileşime geçin `kubectl` .</span><span class="sxs-lookup"><span data-stu-id="981cf-265">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="981cf-266">Docker Masaüstü</span><span class="sxs-lookup"><span data-stu-id="981cf-266">Docker Desktop</span></span>

<span data-ttu-id="981cf-267">Ayrıca, Kubernetes ile doğrudan Windows 'daki Docker Desktop 'tan da çalışabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-267">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="981cf-268">Windows kapsayıcıları kullanıyorsanız tek seçeneğiniz vardır ve Windows dışı kapsayıcılar için harika bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="981cf-268">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="981cf-269">Şekil 3-4, Docker Desktop çalıştırılırken yerel Kubernetes desteğinin nasıl etkinleştirileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="981cf-269">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![Docker Desktop 'ta Kubernetes 'i yapılandırma](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="981cf-271">**Şekil 3-4**.</span><span class="sxs-lookup"><span data-stu-id="981cf-271">**Figure 3-4**.</span></span> <span data-ttu-id="981cf-272">Docker Desktop 'ta Kubernetes 'i yapılandırma.</span><span class="sxs-lookup"><span data-stu-id="981cf-272">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="981cf-273">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak yapılandırmaya ve çalıştırmaya yönelik en popüler araçtır.</span><span class="sxs-lookup"><span data-stu-id="981cf-273">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="981cf-274">Docker Desktop ile çalışırken, üretime dağıtacağınız Docker kapsayıcı görüntüleri kümesine göre yerel olarak geliştirme yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-274">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="981cf-275">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak derlemek, test etmek ve teslim etmek üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="981cf-275">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="981cf-276">Hem Linux hem de Windows kapsayıcılarını destekler.</span><span class="sxs-lookup"><span data-stu-id="981cf-276">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="981cf-277">Görüntülerinizi Azure Container Registry veya Docker Hub gibi bir görüntü kayıt defterine gönderdikten sonra AKS 'ler onları üretime çekebilir ve bunları dağıtabilir.</span><span class="sxs-lookup"><span data-stu-id="981cf-277">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="981cf-278">Visual Studio Docker Araçları</span><span class="sxs-lookup"><span data-stu-id="981cf-278">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="981cf-279">Visual Studio, Web tabanlı uygulamalar için Docker geliştirmeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="981cf-279">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="981cf-280">Yeni bir ASP.NET Core uygulaması oluşturduğunuzda, Şekil 3-5 ' de gösterildiği gibi, Docker desteğiyle yapılandırma seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="981cf-280">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio Docker desteğini etkinleştir](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="981cf-282">**Şekil 3-5**.</span><span class="sxs-lookup"><span data-stu-id="981cf-282">**Figure 3-5**.</span></span> <span data-ttu-id="981cf-283">Visual Studio Docker desteğini etkinleştir</span><span class="sxs-lookup"><span data-stu-id="981cf-283">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="981cf-284">Bu seçenek belirlendiğinde proje, bir `Dockerfile` Docker kapsayıcısında uygulamayı derlemek ve barındırmak için kullanılabilen bir kökünde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="981cf-284">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="981cf-285">Şekil 3 -6. git 'de örnek bir Dockerfile gösterilmektedir</span><span class="sxs-lookup"><span data-stu-id="981cf-285">An example Dockerfile is shown in Figure 3-6.git</span></span>

```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:5.0-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/sdk:5.0-buster-slim AS build
WORKDIR /src
COPY ["eShopWeb/eShopWeb.csproj", "eShopWeb/"]
RUN dotnet restore "eShopWeb/eShopWeb.csproj"
COPY . .
WORKDIR "/src/eShopWeb"
RUN dotnet build "eShopWeb.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "eShopWeb.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "eShopWeb.dll"]
```

<span data-ttu-id="981cf-286">**Şekil 3-6**.</span><span class="sxs-lookup"><span data-stu-id="981cf-286">**Figure 3-6**.</span></span> <span data-ttu-id="981cf-287">Visual Studio tarafından oluşturulan Dockerfile</span><span class="sxs-lookup"><span data-stu-id="981cf-287">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="981cf-288">Uygulamanın çalışması için varsayılan davranış, Docker 'ı kullanmak üzere yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="981cf-288">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="981cf-289">Şekil 3-7, Docker desteği eklenmiş şekilde oluşturulan yeni bir ASP.NET Core projesinden kullanılabilir farklı çalıştırma seçeneklerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="981cf-289">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker çalıştırma seçenekleri](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="981cf-291">**Şekil 3-7**.</span><span class="sxs-lookup"><span data-stu-id="981cf-291">**Figure 3-7**.</span></span> <span data-ttu-id="981cf-292">Visual Studio Docker çalıştırma seçenekleri</span><span class="sxs-lookup"><span data-stu-id="981cf-292">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="981cf-293">[Azure dev Spaces](/azure/dev-spaces/) , yerel geliştirmeye ek olarak, birden çok geliştiricinin Azure 'Da kendi Kubernetes yapılandırmalarına göre çalışması için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-293">In addition to local development, [Azure Dev Spaces](/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="981cf-294">Şekil 3-7 ' de görebileceğiniz gibi, uygulamayı Azure Dev Spaces de çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-294">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="981cf-295">Ayrıca, dilediğiniz zaman mevcut bir ASP.NET Core uygulamasına Docker desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-295">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="981cf-296">Visual Studio Çözüm Gezgini, Şekil 3-8 ' de gösterildiği gibi projeye sağ tıklayın ve   >  **Docker desteği** Ekle ' yi seçin.</span><span class="sxs-lookup"><span data-stu-id="981cf-296">From the Visual Studio Solution Explorer, right-click on the project and select **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio Docker desteği ekle](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="981cf-298">**Şekil 3-8**.</span><span class="sxs-lookup"><span data-stu-id="981cf-298">**Figure 3-8**.</span></span> <span data-ttu-id="981cf-299">Visual Studio 'ya Docker desteği ekleme</span><span class="sxs-lookup"><span data-stu-id="981cf-299">Adding Docker support to Visual Studio</span></span>

<span data-ttu-id="981cf-300">Ayrıca şekil 3-8 ' de gösterilen kapsayıcı düzenleme desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="981cf-300">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="981cf-301">Varsayılan olarak Orchestrator, Kubernetes ve Held kullanır.</span><span class="sxs-lookup"><span data-stu-id="981cf-301">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="981cf-302">Orchestrator 'ı seçtikten sonra `azds.yaml` Proje köküne bir dosya eklenir ve `charts` uygulamayı yapılandırmak ve Kubernetes 'e dağıtmak Için kullanılan helk grafiklerini içeren bir klasör eklenir.</span><span class="sxs-lookup"><span data-stu-id="981cf-302">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="981cf-303">Şekil 3-9 yeni bir projedeki sonuç dosyalarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="981cf-303">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio Orchestrator desteği ekle](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="981cf-305">**Şekil 3-9**.</span><span class="sxs-lookup"><span data-stu-id="981cf-305">**Figure 3-9**.</span></span> <span data-ttu-id="981cf-306">Visual Studio 'ya düzenleme desteği ekleme</span><span class="sxs-lookup"><span data-stu-id="981cf-306">Adding orchestration support to Visual Studio</span></span>

### <a name="visual-studio-code-docker-tooling"></a><span data-ttu-id="981cf-307">Docker Tooling Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="981cf-307">Visual Studio Code Docker Tooling</span></span>

<span data-ttu-id="981cf-308">Docker geliştirmeyi destekleyen Visual Studio Code için kullanılabilen birçok uzantı vardır.</span><span class="sxs-lookup"><span data-stu-id="981cf-308">There are a number of extensions available for Visual Studio Code that support Docker development.</span></span>

<span data-ttu-id="981cf-309">Microsoft, [Visual Studio Code uzantısı Için Docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-309">Microsoft provides the [Docker for Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).</span></span> <span data-ttu-id="981cf-310">Bu uzantı, uygulamalara kapsayıcı desteği ekleme sürecini basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="981cf-310">This extension simplifies the process of adding container support to applications.</span></span> <span data-ttu-id="981cf-311">Gerekli dosyaları, Docker görüntülerini oluşturur ve bir kapsayıcı içinde uygulamanızın hatalarını ayıklamanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="981cf-311">It scaffolds required files, builds Docker images, and enables you to debug your app inside a container.</span></span> <span data-ttu-id="981cf-312">Uzantı; başlatma, durdurma, İnceleme, kaldırma ve daha fazlasını içeren kapsayıcılar ve görüntüler üzerinde işlem yapmayı kolaylaştıran bir görsel gezgin sunar.</span><span class="sxs-lookup"><span data-stu-id="981cf-312">The extension features a visual explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.</span></span> <span data-ttu-id="981cf-313">Uzantı Ayrıca birden çok çalışan kapsayıcıyı tek bir birim olarak yönetmenizi sağlayan Docker Compose destekler.</span><span class="sxs-lookup"><span data-stu-id="981cf-313">The extension also supports Docker Compose enabling you to manage multiple running containers as a single unit.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="981cf-314">[Önceki](scale-applications.md) 
> [Sonraki](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="981cf-314">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
