---
title: Yerel işlevler-C# Programlama Kılavuzu
description: C# ' deki yerel işlevler, başka bir üyede iç içe yerleştirilmiş ve kendi kapsayıcı üyelerinden çağrılabilecek özel yöntemlerdir.
ms.date: 10/02/2020
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: a91995757048c8c54253d7f4b923d5194f69bc7b
ms.sourcegitcommit: 4d45bda8cd9558ea8af4be591e3d5a29360c1ece
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/02/2020
ms.locfileid: "91654926"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="d658e-103">Yerel işlevler (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="d658e-103">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="d658e-104">C# 7,0 ' den başlayarak, c# *Yerel Işlevleri*destekler.</span><span class="sxs-lookup"><span data-stu-id="d658e-104">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="d658e-105">Yerel işlevler, başka bir üyede iç içe yerleştirilmiş bir türün özel yöntemleridir.</span><span class="sxs-lookup"><span data-stu-id="d658e-105">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="d658e-106">Yalnızca kendi kapsayıcı üyelerinden çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-106">They can only be called from their containing member.</span></span> <span data-ttu-id="d658e-107">Yerel işlevler içinde bildirilebilecek ve şuradan çağrılabilir:</span><span class="sxs-lookup"><span data-stu-id="d658e-107">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="d658e-108">Yöntemler, özellikle Yineleyici yöntemleri ve zaman uyumsuz yöntemler</span><span class="sxs-lookup"><span data-stu-id="d658e-108">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="d658e-109">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="d658e-109">Constructors</span></span>
- <span data-ttu-id="d658e-110">Özellik erişimcileri</span><span class="sxs-lookup"><span data-stu-id="d658e-110">Property accessors</span></span>
- <span data-ttu-id="d658e-111">Olay erişimcileri</span><span class="sxs-lookup"><span data-stu-id="d658e-111">Event accessors</span></span>
- <span data-ttu-id="d658e-112">Anonim Yöntemler</span><span class="sxs-lookup"><span data-stu-id="d658e-112">Anonymous methods</span></span>
- <span data-ttu-id="d658e-113">Lambda ifadeleri</span><span class="sxs-lookup"><span data-stu-id="d658e-113">Lambda expressions</span></span>
- <span data-ttu-id="d658e-114">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="d658e-114">Finalizers</span></span>
- <span data-ttu-id="d658e-115">Diğer yerel işlevler</span><span class="sxs-lookup"><span data-stu-id="d658e-115">Other local functions</span></span>

<span data-ttu-id="d658e-116">Ancak, yerel işlevler ifade-Bodied üyesi içinde bildirilemez.</span><span class="sxs-lookup"><span data-stu-id="d658e-116">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="d658e-117">Bazı durumlarda, bir yerel işlev tarafından desteklenen işlevselliği uygulamak için bir lambda ifadesi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d658e-117">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="d658e-118">Bir karşılaştırma için bkz [. yerel işlevler ve lambda ifadeleri](#local-functions-vs-lambda-expressions).</span><span class="sxs-lookup"><span data-stu-id="d658e-118">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="d658e-119">Yerel işlevler, kodunuzun amacını açık hale getirir.</span><span class="sxs-lookup"><span data-stu-id="d658e-119">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="d658e-120">Kodunuzu okuyan herkes, yöntemin kapsayan Yöntem dışında çağrılabilir olmadığını görebilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-120">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="d658e-121">Ekip projeleri için, başka bir geliştiricinin yöntemi doğrudan sınıf veya yapı içinde başka bir yerde çağırmak olanaksız hale getirir.</span><span class="sxs-lookup"><span data-stu-id="d658e-121">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="d658e-122">Yerel işlev sözdizimi</span><span class="sxs-lookup"><span data-stu-id="d658e-122">Local function syntax</span></span>

<span data-ttu-id="d658e-123">Yerel bir işlev, kapsayan bir üye içinde iç içe geçmiş bir yöntem olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="d658e-123">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="d658e-124">Tanımı aşağıdaki sözdizimine sahiptir:</span><span class="sxs-lookup"><span data-stu-id="d658e-124">Its definition has the following syntax:</span></span>

```csharp
<modifiers> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="d658e-125">Aşağıdaki değiştiricileri yerel bir işlevle kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="d658e-125">You can use the following modifiers with a local function:</span></span>

- [`async`](../../language-reference/keywords/async.md)
- [`unsafe`](../../language-reference/keywords/unsafe.md)
- <span data-ttu-id="d658e-126">[`static`](../../language-reference/keywords/static.md) (C# 8,0 ve üzeri sürümlerde).</span><span class="sxs-lookup"><span data-stu-id="d658e-126">[`static`](../../language-reference/keywords/static.md) (in C# 8.0 and later).</span></span> <span data-ttu-id="d658e-127">Statik bir yerel işlev yerel değişkenler veya örnek durumu yakalayamaz.</span><span class="sxs-lookup"><span data-stu-id="d658e-127">A static local function can't capture local variables or instance state.</span></span>
- <span data-ttu-id="d658e-128">[`extern`](../../language-reference/keywords/extern.md) (C# 9,0 ve üzeri sürümlerde).</span><span class="sxs-lookup"><span data-stu-id="d658e-128">[`extern`](../../language-reference/keywords/extern.md) (in C# 9.0 and later).</span></span> <span data-ttu-id="d658e-129">Dış yerel işlev olmalıdır `static` .</span><span class="sxs-lookup"><span data-stu-id="d658e-129">An external local function must be `static`.</span></span>

<span data-ttu-id="d658e-130">Yöntem parametreleri de dahil olmak üzere, kapsayan üyede tanımlanan tüm yerel değişkenlere statik olmayan bir yerel işlevde erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-130">All local variables that are defined in the containing member, including its method parameters, are accessible in a non-static local function.</span></span>

<span data-ttu-id="d658e-131">Bir yöntem tanımının aksine, yerel bir işlev tanımı üye erişim değiştiricisini içeremez.</span><span class="sxs-lookup"><span data-stu-id="d658e-131">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="d658e-132">Tüm yerel işlevler özel olduğundan, anahtar sözcüğü gibi bir erişim değiştiricisi de dahil olmak üzere, `private` "özel ' değiştiricisi Bu öğe için geçerli değil."</span><span class="sxs-lookup"><span data-stu-id="d658e-132">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

<span data-ttu-id="d658e-133">Ayrıca, öznitelikler yerel işleve veya parametrelerine ve parametre türüne uygulanamaz.</span><span class="sxs-lookup"><span data-stu-id="d658e-133">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="d658e-134">Aşağıdaki örnek adlı bir yerel işlevi tanımlar `AppendPathSeparator` `GetText` :</span><span class="sxs-lookup"><span data-stu-id="d658e-134">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="d658e-135">Yerel işlevler ve özel durumlar</span><span class="sxs-lookup"><span data-stu-id="d658e-135">Local functions and exceptions</span></span>

<span data-ttu-id="d658e-136">Yerel işlevlerin yararlı özelliklerinden biri, özel durumların hemen yüzeyine izin verebilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-136">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="d658e-137">Yöntem yineleyiciler için, özel durumlar yalnızca döndürülen dizi numaralandırıldıktan sonra, yineleyici alındığında değil, ortaya çıkacak.</span><span class="sxs-lookup"><span data-stu-id="d658e-137">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="d658e-138">Zaman uyumsuz metotlar için, bir zaman uyumsuz yöntemde oluşturulan özel durumlar, döndürülen görev beklendiğinde gözlemlenir.</span><span class="sxs-lookup"><span data-stu-id="d658e-138">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="d658e-139">Aşağıdaki örnek, `OddSequence` belirtilen bir Aralık arasındaki tek sayıları numaralandırır bir yöntemi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="d658e-139">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="d658e-140">Numaralandırıcı yöntemine 100 ' den büyük bir sayı geçirdiğinden `OddSequence` , yöntemi bir oluşturur <xref:System.ArgumentOutOfRangeException> .</span><span class="sxs-lookup"><span data-stu-id="d658e-140">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="d658e-141">Örneğin çıkışının gösterdiği gibi, özel durum yalnızca sayıları tekrarladığı zaman, numaralandırıcıyı alırken değil, yüzeyleri.</span><span class="sxs-lookup"><span data-stu-id="d658e-141">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="d658e-142">Bunun yerine, aşağıdaki örnekte gösterildiği gibi, bir yerel işlevden Yineleyici döndürerek, doğrulama gerçekleştirirken ve yineleyici almadan önce bir özel durum oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d658e-142">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="d658e-143">Yerel işlevler, zaman uyumsuz işlem dışındaki özel durumları işlemek için benzer bir şekilde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-143">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="d658e-144">Genellikle, zaman uyumsuz yöntemde oluşturulan özel durumlar, öğesinin iç özel durumlarını incelemenizi gerektirir <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="d658e-144">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="d658e-145">Yerel işlevler, kodunuzun hızlı bir şekilde başarısız olmasına olanak tanır ve özel durumun hem zaman uyumlu olarak hem de aynı şekilde gözlemlenip</span><span class="sxs-lookup"><span data-stu-id="d658e-145">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="d658e-146">Aşağıdaki örnek, belirtilen saniye sayısını duraklatmak için adlı zaman uyumsuz bir yöntem kullanır `GetMultipleAsync` ve bu sayıda saniyeden oluşan rastgele bir değer döndürür.</span><span class="sxs-lookup"><span data-stu-id="d658e-146">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="d658e-147">En fazla gecikme 5 saniyedir; <xref:System.ArgumentOutOfRangeException> değer 5 ' ten büyükse bir sonuç elde edilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-147">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="d658e-148">Aşağıdaki örnekte gösterildiği gibi, yöntemine 6 değeri geçirildiğinde oluşturulan özel durum, `GetMultipleAsync` <xref:System.AggregateException> Yöntem yürütmeye başladıktan sonra bir öğesine kaydırılır `GetMultipleAsync` .</span><span class="sxs-lookup"><span data-stu-id="d658e-148">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="d658e-149">Yöntem yineleyicisi ile yaptığımız gibi, zaman uyumsuz metodu çağırmadan önce doğrulamayı gerçekleştirmek için bu örnekteki kodu yeniden düzenleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d658e-149">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="d658e-150">Aşağıdaki örnekteki Çıktının gösterdiği gibi, ' <xref:System.ArgumentOutOfRangeException> a sarmalanmaz <xref:System.AggregateException> .</span><span class="sxs-lookup"><span data-stu-id="d658e-150">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="d658e-151">Yerel işlevler ve lambda ifadeleri karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="d658e-151">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="d658e-152">İlk bakışta, yerel işlevler ve [lambda ifadeleri](../../language-reference/operators/lambda-expressions.md) çok benzerdir.</span><span class="sxs-lookup"><span data-stu-id="d658e-152">At first glance, local functions and [lambda expressions](../../language-reference/operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="d658e-153">Birçok durumda, lambda ifadeleri ve yerel işlevler kullanma arasında seçim stili ve kişisel tercihlerden bağımsız olur.</span><span class="sxs-lookup"><span data-stu-id="d658e-153">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="d658e-154">Ancak, dikkat etmeniz gereken bir veya diğerini kullanabileceğiniz gerçek farklılıklar vardır.</span><span class="sxs-lookup"><span data-stu-id="d658e-154">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="d658e-155">Bu, yerel işlev ve çarpınımı algoritmasının lambda ifadesi uygulamaları arasındaki farkları inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="d658e-155">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="d658e-156">Yerel bir işlev kullanan ilk sürüm:</span><span class="sxs-lookup"><span data-stu-id="d658e-156">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="d658e-157">Bu uygulamayı lambda ifadeleri kullanan bir sürümle karşıtlık:</span><span class="sxs-lookup"><span data-stu-id="d658e-157">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="d658e-158">Yerel işlevlerin adları vardır.</span><span class="sxs-lookup"><span data-stu-id="d658e-158">The local functions have names.</span></span> <span data-ttu-id="d658e-159">Lambda ifadeleri, veya türündeki değişkenlere atanan anonim yöntemlerdir `Func` `Action` .</span><span class="sxs-lookup"><span data-stu-id="d658e-159">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="d658e-160">Yerel bir işlev bildirdiğinizde, bağımsız değişken türleri ve dönüş türü, işlev bildiriminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="d658e-160">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="d658e-161">Lambda ifadesinin gövdesi bir parçası olmak yerine, bağımsız değişken türleri ve dönüş türü, lambda ifadesinin değişken türü bildiriminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="d658e-161">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="d658e-162">Bu iki fark kodun daha net bir şekilde oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-162">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="d658e-163">Yerel işlevler, lambda ifadelerinden kesin atama için farklı kurallara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d658e-163">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="d658e-164">Bir yerel işlev bildirimine, kapsamdaki herhangi bir kod konumundan başvurulabilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-164">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="d658e-165">Bir lambda ifadesi, erişilebilmesi için önce bir temsilci değişkenine atanmalıdır (veya lambda ifadesine başvuran temsilci aracılığıyla çağrılabilir).</span><span class="sxs-lookup"><span data-stu-id="d658e-165">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="d658e-166">Lambda ifadesini kullanan sürümün, lambda ifadesini tanımlamadan önce bildirmelidir ve başlatması gerektiğini unutmayın `nthFactorial` .</span><span class="sxs-lookup"><span data-stu-id="d658e-166">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="d658e-167">Bu nedenle, atamadan önce başvurmak için derleme zamanı hatasına neden `nthFactorial` olur.</span><span class="sxs-lookup"><span data-stu-id="d658e-167">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="d658e-168">Bu farklılıklar özyinelemeli algoritmaların yerel işlevler kullanılarak oluşturulması daha kolay hale gelir.</span><span class="sxs-lookup"><span data-stu-id="d658e-168">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="d658e-169">Kendisini çağıran bir yerel işlev tanımlayabilir ve tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d658e-169">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="d658e-170">Lambda ifadeleri, aynı lambda ifadesine başvuran bir gövdeye yeniden atanabilmeleri için bildirilmelidir ve varsayılan bir değer atanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d658e-170">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="d658e-171">Belirli atama kuralları, yerel işlev veya lambda ifadesi tarafından yakalanan tüm değişkenleri de etkiler.</span><span class="sxs-lookup"><span data-stu-id="d658e-171">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="d658e-172">Yerel işlev veya lambda ifadesi bir temsilciye dönüştürüldüğünde, her iki yerel işlev ve lambda ifadesi kuralı, yakalanan değişkenlerin herhangi bir noktaya kesinlikle atandığını talep edilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-172">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="d658e-173">Fark, lambda ifadelerinin bildirildiği zaman temsilcilere dönüştürülmesidir.</span><span class="sxs-lookup"><span data-stu-id="d658e-173">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="d658e-174">Yerel işlevler yalnızca temsilci olarak kullanıldığında temsilcilere dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="d658e-174">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="d658e-175">Yerel bir işlev bildirirseniz ve yalnızca bir yöntem gibi çağırarak buna başvurmanız durumunda, bir temsilciye dönüştürülmez.</span><span class="sxs-lookup"><span data-stu-id="d658e-175">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="d658e-176">Bu kural, kapsayan kapsamındaki herhangi bir uygun konumda yerel bir işlev bildirmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="d658e-176">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="d658e-177">Herhangi bir dönüş deyiminden sonra, üst yöntemin sonunda yerel işlevleri bildirmek yaygın bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="d658e-177">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="d658e-178">Üçüncü olarak derleyici, yerel işlevlerin kapsayan kapsamda kesin olarak yakalanan değişkenleri atamasını sağlayan statik analiz gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-178">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="d658e-179">Bu örneği ele alalım:</span><span class="sxs-lookup"><span data-stu-id="d658e-179">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="d658e-180">Derleyici, `LocalFunction` çağrıldığında kesinlikle atayıp atamayacağını tespit edebilir `y` .</span><span class="sxs-lookup"><span data-stu-id="d658e-180">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="d658e-181">, `LocalFunction` Deyimden önce çağrıldığı için `return` , `y` ifadeye kesin olarak atanır `return` .</span><span class="sxs-lookup"><span data-stu-id="d658e-181">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="d658e-182">Örnek analizine izin veren analiz, dördüncü farkı mümkün kıdır.</span><span class="sxs-lookup"><span data-stu-id="d658e-182">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="d658e-183">Yerel işlevler, kullanım amaçlarına bağlı olarak, lambda ifadeleri için her zaman gerekli olan yığın ayırmalara engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-183">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="d658e-184">Yerel bir işlev hiçbir şekilde temsilciye dönüştürülürse ve yerel işlev tarafından yakalanan değişkenlerden hiçbiri, başka Lambdalar veya temsilcilere dönüştürülen yerel işlevler tarafından yakalanmazsa, derleyici yığın ayırmalara engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-184">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="d658e-185">Bu zaman uyumsuz örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="d658e-185">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="d658e-186">Bu lambda ifadesinin kapanışı `address` , `index` ve `name` değişkenlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="d658e-186">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="d658e-187">Yerel işlevler söz konusu olduğunda, kapanışı uygulayan nesne bir `struct` tür olabilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-187">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="d658e-188">Bu yapı türü yerel işleve başvuruya göre geçirilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-188">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="d658e-189">Uygulamadaki bu fark bir ayırmaya kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="d658e-189">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="d658e-190">Lambda ifadeleri için gereken örnek oluşturma, zaman açısından kritik kod yollarındaki bir performans faktörü olabilecek fazladan bellek ayırmaları anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d658e-190">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="d658e-191">Yerel işlevler bu ek yüke neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="d658e-191">Local functions do not incur this overhead.</span></span> <span data-ttu-id="d658e-192">Yukarıdaki örnekte, yerel işlevlerin sürümünde lambda ifadesi sürümünden daha az sayıda ayırma bulunur.</span><span class="sxs-lookup"><span data-stu-id="d658e-192">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="d658e-193">Bu yöntemin yerel işlev eşdeğeri, kapanış için bir sınıf de kullanır.</span><span class="sxs-lookup"><span data-stu-id="d658e-193">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="d658e-194">Yerel bir işlev için Kapanışın bir veya olarak uygulanıp uygulanmadığı bir `class` `struct` uygulama ayrıntısı.</span><span class="sxs-lookup"><span data-stu-id="d658e-194">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="d658e-195">Yerel bir işlev bir kullanabilir, `struct` ancak bir lambda her zaman bir kullanır `class` .</span><span class="sxs-lookup"><span data-stu-id="d658e-195">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="d658e-196">Bu örnekte gösterilmeyen bir son avantaj, yerel işlevlerin yineleyiciler olarak uygulanabilmesinin yanı `yield return` sıra bir değer dizisi oluşturmak için söz dizimini kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="d658e-196">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="d658e-197">`yield return`Lambda ifadelerinde ifadeye izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="d658e-197">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="d658e-198">Yerel işlevler Lambda ifadelerinde gereksiz gibi görünse de, bu işlemler aslında farklı amaçlara hizmet eder ve farklı kullanımlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="d658e-198">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="d658e-199">Yalnızca başka bir yöntemin bağlamından çağrılan bir işlev yazmak istediğinizde yerel işlevler bu durum için daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="d658e-199">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="d658e-200">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="d658e-200">See also</span></span>

- [<span data-ttu-id="d658e-201">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="d658e-201">Methods</span></span>](methods.md)
