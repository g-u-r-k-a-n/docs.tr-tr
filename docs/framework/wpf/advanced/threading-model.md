---
title: İş Parçacığı Modeli
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: ae120311e7e58b34437de987e9f9a18e917043c0
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/12/2019
ms.locfileid: "73974083"
---
# <a name="threading-model"></a><span data-ttu-id="1e57b-102">İş Parçacığı Modeli</span><span class="sxs-lookup"><span data-stu-id="1e57b-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="1e57b-103">, geliştiricilerin iş parçacığı zorluklarından kaydedileceği şekilde tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="1e57b-104">Sonuç olarak, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] geliştiricilerin çoğunluğu birden fazla iş parçacığı kullanan bir arabirim yazmak zorunda kalmaz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="1e57b-105">Çok iş parçacıklı programlar karmaşık olduğu ve hata ayıklamanın zor olduğu için, tek iş parçacıklı çözümler olduğunda bu, kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="1e57b-106">Ancak, ne kadar iyi bir şekilde uygun olduğuna bakılmaksızın, hiçbir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] çerçevesi her bir sorun için tek iş parçacıklı bir çözüm sağlayacaktır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="1e57b-107">yakın, ancak birden çok iş parçacığının [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] yanıt verme hızını veya uygulama performansını geliştirmediği durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="1e57b-108">Bu şekilde, bazı arka plan malzemeleri ele alındıktan sonra bu durum, bu durumların bazılarını araştırır ve daha sonra bazı alt düzey ayrıntıların bir tartışmasına göre sonlanır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="1e57b-109">Bu konuda, zaman uyumsuz çağrılar için <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> yöntemi kullanılarak iş parçacığı ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="1e57b-110">Ayrıca, bir <xref:System.Action> veya <xref:System.Func%601> parametre olarak kullanan <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> yöntemini çağırarak zaman uyumsuz çağrılar yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="1e57b-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> yöntemi, <xref:System.Windows.Threading.DispatcherOperation.Task%2A> özelliğine sahip <xref:System.Windows.Threading.DispatcherOperation> veya <xref:System.Windows.Threading.DispatcherOperation%601>döndürür.</span><span class="sxs-lookup"><span data-stu-id="1e57b-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="1e57b-112">`await` anahtar sözcüğünü <xref:System.Windows.Threading.DispatcherOperation> ya da ilişkili <xref:System.Threading.Tasks.Task>kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="1e57b-113">Bir <xref:System.Windows.Threading.DispatcherOperation> veya <xref:System.Windows.Threading.DispatcherOperation%601>tarafından döndürülen <xref:System.Threading.Tasks.Task> için zaman uyumlu olarak beklemeniz gerekiyorsa, <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> genişletme yöntemini çağırın.</span><span class="sxs-lookup"><span data-stu-id="1e57b-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="1e57b-114"><xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> çağırmak kilitlenmeye neden olur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="1e57b-115">Zaman uyumsuz işlemleri gerçekleştirmek için <xref:System.Threading.Tasks.Task> kullanma hakkında daha fazla bilgi için bkz. Görev Paralelliği.</span><span class="sxs-lookup"><span data-stu-id="1e57b-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="1e57b-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> yönteminde, bir <xref:System.Action> veya <xref:System.Func%601> parametre olarak alan aşırı yüklemeleri de vardır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="1e57b-117">Bir temsilci, <xref:System.Action> veya <xref:System.Func%601>geçirerek zaman uyumlu çağrılar yapmak için <xref:System.Windows.Threading.Dispatcher.Invoke%2A> yöntemini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="1e57b-118">Genel bakış ve dağıtıcı</span><span class="sxs-lookup"><span data-stu-id="1e57b-118">Overview and the Dispatcher</span></span>
 <span data-ttu-id="1e57b-119">Genellikle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalar iki iş parçacığı ile başlar: bir diğeri, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]yönetmek için işleme ve bir diğeri.</span><span class="sxs-lookup"><span data-stu-id="1e57b-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="1e57b-120">İşleme iş parçacığı, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı girişi aldığında, olayları işlerken, ekranı boyayıp uygulama kodunu çalıştırdığında arka planda gizli olarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="1e57b-121">Birçok uygulama tek bir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı kullanır, ancak bazı durumlarda en iyi şekilde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="1e57b-122">Bunu daha sonra bir örnekle tartışacağız.</span><span class="sxs-lookup"><span data-stu-id="1e57b-122">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="1e57b-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı, <xref:System.Windows.Threading.Dispatcher>adlı bir nesne içindeki iş öğelerini sıralar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1e57b-124"><xref:System.Windows.Threading.Dispatcher>, iş öğelerini öncelik temelinde seçer ve her birini tamamlamaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="1e57b-125">Her [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığında en az bir <xref:System.Windows.Threading.Dispatcher>olmalı ve her <xref:System.Windows.Threading.Dispatcher> iş öğelerini tam olarak bir iş parçacığında yürütebilirler.</span><span class="sxs-lookup"><span data-stu-id="1e57b-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="1e57b-126">Kullanıcı dostu uygulamalar oluşturma eli, iş öğelerini küçük tutarak <xref:System.Windows.Threading.Dispatcher> aktarım hızını en üst düzeye çıkarabilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="1e57b-127">Bu şekilde öğeler, işlenmek üzere bekleyen <xref:System.Windows.Threading.Dispatcher> kuyrukta hiç kullanılmıyor.</span><span class="sxs-lookup"><span data-stu-id="1e57b-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="1e57b-128">Giriş ve yanıt arasındaki perceivable gecikmesi bir kullanıcıyı rahatsız edebilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-128">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="1e57b-129">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalar büyük işlemleri nasıl işleymelidir?</span><span class="sxs-lookup"><span data-stu-id="1e57b-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="1e57b-130">Kodunuz büyük bir hesaplama içeriyorsa veya bir veritabanını bir uzak sunucuda sorgulamak için ihtiyaç duyuyorsa ne olacak?</span><span class="sxs-lookup"><span data-stu-id="1e57b-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="1e57b-131">Genellikle, yanıt ayrı bir iş parçacığında büyük işlemi işleymaktır ve bu [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığını <xref:System.Windows.Threading.Dispatcher> sırasındaki öğelere eğilimli olarak bırakır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1e57b-132">Büyük işlem tamamlandığında, sonuçları görüntülenmek üzere [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığına rapor edebilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="1e57b-133">Tarihsel olarak, Windows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] öğelerine yalnızca kendilerini oluşturan iş parçacığından erişilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-133">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="1e57b-134">Bu, uzun süre çalışan bazı görevlerden sorumlu bir arka plan iş parçacığının, tamamlandığında bir metin kutusunu güncelleştiremeyeceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="1e57b-135">Windows, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] bileşenlerinin bütünlüğünü sağlamak için bunu yapar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-135">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="1e57b-136">Bir liste kutusu, içeriği boyama sırasında arka plan iş parçacığı tarafından güncellendiyse tuhaf görünebilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="1e57b-137">, bu koordinasyonu zorlayan yerleşik bir karşılıklı dışlama mekanizmasına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="1e57b-138">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] çoğu sınıf <xref:System.Windows.Threading.DispatcherObject>türetilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="1e57b-139">Oluşturma sırasında <xref:System.Windows.Threading.DispatcherObject>, çalışmakta olan iş parçacığına bağlı <xref:System.Windows.Threading.Dispatcher> bir başvuru depolar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="1e57b-140">Aslında <xref:System.Windows.Threading.DispatcherObject>, kendisini oluşturan iş parçacığıyla ilişkilendirir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="1e57b-141">Program yürütme sırasında, <xref:System.Windows.Threading.DispatcherObject> ortak <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> metodunu çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="1e57b-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>, geçerli iş parçacığıyla ilişkili <xref:System.Windows.Threading.Dispatcher> inceler ve oluşturma sırasında saklanan <xref:System.Windows.Threading.Dispatcher> başvurusuyla karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="1e57b-143">Eşleşmiyorsa, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="1e57b-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>, bir <xref:System.Windows.Threading.DispatcherObject>ait her yöntemin başlangıcında çağrılması amaçlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="1e57b-145">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]yalnızca bir iş parçacığı değiştirebilir, arka plan iş parçacıkları kullanıcıyla nasıl etkileşime geçebilir?</span><span class="sxs-lookup"><span data-stu-id="1e57b-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="1e57b-146">Arka plan iş parçacığı [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığından adına bir işlem gerçekleştirmesini isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="1e57b-147">Bu, bir iş öğesini [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığının <xref:System.Windows.Threading.Dispatcher> kaydederek yapar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-148"><xref:System.Windows.Threading.Dispatcher> sınıfı, iş öğelerini kaydetmek için iki yöntem sunar: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> ve <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="1e57b-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="1e57b-149">Her iki yöntem de bir temsilciyi yürütmeye zamanlar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="1e57b-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> zaman uyumlu bir çağrıdır; diğer bir deyişle, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı gerçekten temsilciyi yürütmeyi bitirene kadar döndürmez.</span><span class="sxs-lookup"><span data-stu-id="1e57b-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="1e57b-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> zaman uyumsuzdur ve hemen döndürülür.</span><span class="sxs-lookup"><span data-stu-id="1e57b-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="1e57b-152"><xref:System.Windows.Threading.Dispatcher>, sırasındaki öğeleri önceliğe göre sıralar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="1e57b-153"><xref:System.Windows.Threading.Dispatcher> kuyruğuna bir öğe eklenirken belirtime gereken on düzey vardır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1e57b-154">Bu öncelikler <xref:System.Windows.Threading.DispatcherPriority> numaralandırmasında tutulur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="1e57b-155"><xref:System.Windows.Threading.DispatcherPriority> düzeyler hakkında ayrıntılı bilgi Windows SDK belgelerinde bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="1e57b-156">İşlemdeki iş parçacıkları: örnekler</span><span class="sxs-lookup"><span data-stu-id="1e57b-156">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="1e57b-157">Uzun süre çalışan bir hesaplama ile tek Iş parçacıklı bir uygulama</span><span class="sxs-lookup"><span data-stu-id="1e57b-157">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="1e57b-158">Çoğu grafik kullanıcı arabirimi (Gua), kullanıcı etkileşimlerine yanıt olarak oluşturulan olayları beklerken zaman içindeki büyük bir bölümü harcamaktadır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-158">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="1e57b-159">Dikkatli bir programlamayla bu boşta kalma süresi, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]yanıt hızını etkilemeden oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="1e57b-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] iş parçacığı modeli, girişin [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığında meydana gelen bir işlemi kesmesine izin vermez.</span><span class="sxs-lookup"><span data-stu-id="1e57b-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-161">Bu, bekleyen giriş olaylarını eski olmadan işlemek için <xref:System.Windows.Threading.Dispatcher> düzenli aralıklarla geri döndürtığınızdan emin olmanız gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="1e57b-162">Aşağıdaki örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="1e57b-162">Consider the following example:</span></span>

 ![Asal sayıların iş parçacığı gösteren ekran görüntüsü.](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="1e57b-164">Bu basit uygulama, üç ' dan yukarı doğru sayılır, asal sayılar için arama yapılır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="1e57b-165">Kullanıcı **Başlat** düğmesine tıkladığında arama başlar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="1e57b-166">Program bir ana bulduğunda, Kullanıcı arabirimini bulma işlemi ile güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="1e57b-167">Herhangi bir noktada Kullanıcı aramayı durdurabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-167">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="1e57b-168">Yeterince basit olsa da, asal sayı araması sonsuza kadar devam eder ve bu da bazı zorluklar sunar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="1e57b-169">Düğmenin tıklama olayı işleyicisi içinde tüm aramayı ele aldık, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığına diğer olayları işleme şansı vermeiyoruz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="1e57b-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] giriş veya işlem iletilerine yanıt veremezse.</span><span class="sxs-lookup"><span data-stu-id="1e57b-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="1e57b-171">Hiçbir şekilde yeniden boyanır ve düğme tıklamalarına hiç yanıt vermez.</span><span class="sxs-lookup"><span data-stu-id="1e57b-171">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="1e57b-172">Ana sayı aramasını ayrı bir iş parçacığında ele geçirebilir, ancak eşitleme sorunlarıyla uğraşmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="1e57b-173">Tek iş parçacıklı bir yaklaşımla, bulunan en büyük ana alanı listeleyen etiketi doğrudan güncelleştirebiliriz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="1e57b-174">Hesaplama görevini yönetilebilir parçalara ayırdık, düzenli aralıklarla <xref:System.Windows.Threading.Dispatcher> ve olayları işleyecek şekilde geri dönebiliriz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="1e57b-175">Girişi yeniden boyamak ve işlemek için bir fırsat [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] verebiliriz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="1e57b-176">Hesaplama ve olay işleme arasındaki işleme süresini bölmenin en iyi yolu <xref:System.Windows.Threading.Dispatcher>hesaplamayı yönetmekdir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1e57b-177"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> yöntemi kullanılarak, ana sayı denetimlerini [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] olaylarının çizildiği sırada zamanlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="1e57b-178">Bizim örneğimizde, aynı anda yalnızca tek bir ana sayı denetimi zamanladık.</span><span class="sxs-lookup"><span data-stu-id="1e57b-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="1e57b-179">Asal sayı denetimi tamamlandıktan sonra sonraki denetimi hemen zamanlıyoruz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="1e57b-180">Bu denetim yalnızca bekleyen [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] olayları işlendikten sonra devam eder.</span><span class="sxs-lookup"><span data-stu-id="1e57b-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![Dağıtıcı kuyruğunu gösteren ekran görüntüsü.](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="1e57b-182">Microsoft Word, bu mekanizmayı kullanarak yazım denetimi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-182">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="1e57b-183">Yazım denetimi, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığının boşta kalma süresi kullanılarak arka planda yapılır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-184">Şimdi koda göz atalım.</span><span class="sxs-lookup"><span data-stu-id="1e57b-184">Let's take a look at the code.</span></span>

 <span data-ttu-id="1e57b-185">Aşağıdaki örnek, Kullanıcı arabirimini oluşturan XAML 'yi gösterir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-185">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="1e57b-186">Aşağıdaki örnek, arka plan kodunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-186">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="1e57b-187">Aşağıdaki örnekte <xref:System.Windows.Controls.Button>için olay işleyicisi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="1e57b-188"><xref:System.Windows.Controls.Button>metnin güncelleştirilmesinin yanı sıra, bu işleyici, <xref:System.Windows.Threading.Dispatcher> kuyruğuna bir temsilci ekleyerek ilk asal sayı denetimini zamanlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="1e57b-189">Bu olay işleyicisi işini tamamladıktan sonra, <xref:System.Windows.Threading.Dispatcher> yürütülmek üzere bu temsilciyi seçer.</span><span class="sxs-lookup"><span data-stu-id="1e57b-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="1e57b-190">Daha önce bahsedildiği gibi <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>, bir temsilciyi yürütmeye zamanlamak için kullanılan <xref:System.Windows.Threading.Dispatcher> üyesidir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="1e57b-191">Bu durumda <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> önceliğini seçeceğiz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="1e57b-192"><xref:System.Windows.Threading.Dispatcher> bu temsilciyi yalnızca işlemek için önemli bir olay olmadığında yürütecektir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <span data-ttu-id="1e57b-193">yanıt verme sayısı, sayı denetlemeden daha önemlidir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-193">responsiveness is more important than number checking.</span></span> <span data-ttu-id="1e57b-194">Ayrıca, sayı denetimi yordamını temsil eden yeni bir temsilci geçiririz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-194">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="1e57b-195">Bu yöntem, sonraki tek sayının asal olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="1e57b-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="1e57b-196">Asal ise Yöntem, bulmayı yansıtmak için `bigPrime`<xref:System.Windows.Controls.TextBlock> doğrudan güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="1e57b-197">Bu, hesaplamayı, bileşeni oluşturmak için kullanılan aynı iş parçacığında gerçekleştiğinden, bunu yapabiliriz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="1e57b-198">Hesaplama için ayrı bir iş parçacığı kullanmayı seçtik, daha karmaşık bir eşitleme mekanizması kullanmak ve güncelleştirmeyi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığında yürütmek istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-199">Bu durumu daha sonra göstereceğiz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-199">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="1e57b-200">Bu örneğe ilişkin tam kaynak kodu için, [uzun süre çalışan hesaplama örneğiyle tek Iş parçacıklı uygulamaya](https://go.microsoft.com/fwlink/?LinkID=160038) bakın</span><span class="sxs-lookup"><span data-stu-id="1e57b-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="1e57b-201">Bir arka plan Iş parçacığı ile engelleyici Işlemi işleme</span><span class="sxs-lookup"><span data-stu-id="1e57b-201">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="1e57b-202">Grafik uygulamada engelleme işlemlerini işleme zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="1e57b-203">Uygulama dondurmak için göründüğünden olay işleyicilerinden engelleme yöntemlerini çağırmak istemiyorum.</span><span class="sxs-lookup"><span data-stu-id="1e57b-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="1e57b-204">Bu işlemleri işlemek için ayrı bir iş parçacığı kullanabiliriz, ancak işiniz bittiğinde, GUI 'yi çalışan iş parçacığından doğrudan değiştireemdiğimiz için [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığıyla eşitliyoruz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="1e57b-205">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığının <xref:System.Windows.Threading.Dispatcher> içine temsilciler eklemek için <xref:System.Windows.Threading.Dispatcher.Invoke%2A> veya <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-206">Sonuç olarak, bu Temsilciler [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] öğeleri değiştirme izniyle yürütülür.</span><span class="sxs-lookup"><span data-stu-id="1e57b-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="1e57b-207">Bu örnekte, hava durumu tahminini alan bir uzak yordam çağrısını taklit ediyoruz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="1e57b-208">Bu çağrıyı yürütmek için ayrı bir çalışan iş parçacığı kullanıyoruz ve tamamlandığımızda [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığının <xref:System.Windows.Threading.Dispatcher> bir güncelleştirme yöntemi zamanladık.</span><span class="sxs-lookup"><span data-stu-id="1e57b-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![Hava durumu Kullanıcı arabirimini gösteren ekran görüntüsü.](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="1e57b-210">Aşağıda, belirtime bazı ayrıntılar verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-210">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="1e57b-211">Düğme Işleyicisi oluşturma</span><span class="sxs-lookup"><span data-stu-id="1e57b-211">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="1e57b-212">Düğmeye tıklandığında saat çizimi görüntülenir ve canlandırarak başlayın.</span><span class="sxs-lookup"><span data-stu-id="1e57b-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="1e57b-213">Düğmeyi devre dışı bıraktık.</span><span class="sxs-lookup"><span data-stu-id="1e57b-213">We disable the button.</span></span> <span data-ttu-id="1e57b-214">Yeni bir iş parçacığında `FetchWeatherFromServer` yöntemini çağırdık ve sonra geri dönediğimiz için, hava durumu tahminini toplamayı beklerken <xref:System.Windows.Threading.Dispatcher> olayları işlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="1e57b-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="1e57b-215">Hava durumu getiriliyor</span><span class="sxs-lookup"><span data-stu-id="1e57b-215">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="1e57b-216">Şeyleri basit tutmak için, bu örnekte aslında hiçbir ağ kodu yoktur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="1e57b-217">Bunun yerine, yeni iş parçacığını dört saniye boyunca uykuya yerleştirerek ağ erişimi gecikmesi benzetimi yapılır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="1e57b-218">Bu süre içinde, özgün [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı çalışmaya devam eder ve olaylara yanıt verir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="1e57b-219">Bunu göstermek için, çalışan bir animasyon kalmadı ve simge durumuna küçült ve büyüt düğmeleri de çalışmaya devam eder.</span><span class="sxs-lookup"><span data-stu-id="1e57b-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="1e57b-220">Gecikme bittiğinde ve hava durumu tahminimizi rastgele seçtiğimiz zaman, [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığına yeniden rapor vereceğiz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-221">Bunu, iş parçacığı <xref:System.Windows.Threading.Dispatcher>kullanarak [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığında `UpdateUserInterface` bir çağrı zamanlayarak yapacağız.</span><span class="sxs-lookup"><span data-stu-id="1e57b-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="1e57b-222">Bu zamanlanmış yöntem çağrısına hava durumunu açıklayan bir dize geçiririz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-222">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="1e57b-223">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] güncelleştiriliyor</span><span class="sxs-lookup"><span data-stu-id="1e57b-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="1e57b-224">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığındaki <xref:System.Windows.Threading.Dispatcher> zamanı olduğunda, `UpdateUserInterface`zamanlanan çağrısını yürütür.</span><span class="sxs-lookup"><span data-stu-id="1e57b-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="1e57b-225">Bu yöntem saat animasyonunu durdurup hava durumunu tanımlayacak bir görüntü seçer.</span><span class="sxs-lookup"><span data-stu-id="1e57b-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="1e57b-226">Bu görüntüyü görüntüler ve "tahmin getirme" düğmesini geri yükler.</span><span class="sxs-lookup"><span data-stu-id="1e57b-226">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="1e57b-227">Birden çok pencere, birden çok Iş parçacığı</span><span class="sxs-lookup"><span data-stu-id="1e57b-227">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="1e57b-228">Bazı [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalar birden çok üst düzey pencere gerektirir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="1e57b-229">Birden çok pencere yönetmek için bir Iş parçacığı/<xref:System.Windows.Threading.Dispatcher> birleşimi için mükemmel bir kabul edilebilir, ancak bazen birkaç iş parçacığı daha iyi bir iş olur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="1e57b-230">Bu durum özellikle, bir Windows 'un iş parçacığını tekeline alacak herhangi bir şansınız varsa geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="1e57b-231">Windows Gezgini bu biçimde çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-231">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="1e57b-232">Her yeni Gezgin penceresi orijinal işleme aittir, ancak bağımsız bir iş parçacığının denetimi altında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="1e57b-233">Bir [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> denetimi kullanarak Web sayfalarını görüntüleriz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="1e57b-234">Kolayca basit bir Internet Explorer yerine kolayca oluşturabiliyoruz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-234">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="1e57b-235">Önemli bir özellik ile başlıyoruz: yeni bir Gezgin penceresi açma özelliği.</span><span class="sxs-lookup"><span data-stu-id="1e57b-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="1e57b-236">Kullanıcı "yeni pencere" düğmesine tıkladığında, ayrı bir iş parçacığında penceremizin kopyasını başladık.</span><span class="sxs-lookup"><span data-stu-id="1e57b-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="1e57b-237">Bu şekilde, Windows 'un birindeki uzun süreli veya engelleyici işlemler diğer tüm pencereleri kilitlemez.</span><span class="sxs-lookup"><span data-stu-id="1e57b-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="1e57b-238">Gerçekte, Web tarayıcısı modelinin karmaşık iş parçacığı modeli vardır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="1e57b-239">Çoğu okuyucuları tanımak gerektiğinden, bunu seçtik.</span><span class="sxs-lookup"><span data-stu-id="1e57b-239">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="1e57b-240">Aşağıdaki örnek kodu gösterir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-240">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="1e57b-241">Bu kodun aşağıdaki iş parçacığı kesimleri, bu bağlamda bizimle ilgili en ilginç bir koddur:</span><span class="sxs-lookup"><span data-stu-id="1e57b-241">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="1e57b-242">Bu yöntem, "yeni pencere" düğmesine tıklandığında çağrılır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="1e57b-243">Yeni bir iş parçacığı oluşturur ve zaman uyumsuz olarak başlatır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-243">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="1e57b-244">Bu yöntem, yeni iş parçacığının başlangıç noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="1e57b-245">Bu iş parçacığının denetimi altında yeni bir pencere oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="1e57b-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="1e57b-246">, yeni bir iş parçacığını yönetmek için otomatik olarak yeni bir <xref:System.Windows.Threading.Dispatcher> oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="1e57b-247">Her şey, pencerenin işlevsel olmasını sağlamak için <xref:System.Windows.Threading.Dispatcher>.</span><span class="sxs-lookup"><span data-stu-id="1e57b-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="1e57b-248">Teknik ayrıntılar ve geçmiş noktaları</span><span class="sxs-lookup"><span data-stu-id="1e57b-248">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="1e57b-249">Iş parçacığı kullanarak bileşen yazma</span><span class="sxs-lookup"><span data-stu-id="1e57b-249">Writing Components Using Threading</span></span>
 <span data-ttu-id="1e57b-250">Microsoft .NET Framework Geliştirici Kılavuzu, bir bileşenin istemcilerine zaman uyumsuz davranış sergileme şeklini gösteren bir model tanımlar (bkz. [olay tabanlı zaman uyumsuz düzene genel bakış](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span><span class="sxs-lookup"><span data-stu-id="1e57b-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="1e57b-251">Örneğin, `FetchWeatherFromServer` yöntemini yeniden kullanılabilir, grafik olmayan bir bileşene paketlemek istediğimiz varsayın.</span><span class="sxs-lookup"><span data-stu-id="1e57b-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="1e57b-252">Standart Microsoft .NET Framework deseninin ardından bu, aşağıdaki gibi görünür.</span><span class="sxs-lookup"><span data-stu-id="1e57b-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="1e57b-253">`GetWeatherAsync`, bir arka plan iş parçacığı oluşturma gibi daha önce açıklanan tekniklerin birini kullanarak, çağrıyı zaman uyumsuz olarak işler, çağıran iş parçacığını engellemiyor.</span><span class="sxs-lookup"><span data-stu-id="1e57b-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="1e57b-254">Bu düzenin en önemli bölümlerinden biri, ile başlamak için *methodname*`Async` yöntemini çağıran aynı Iş parçacığında *MethodName*`Completed` yöntemini çağırmaktadır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="1e57b-255">Bunu, <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>depolayarak [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] oldukça kolay bir şekilde yapabilirsiniz ancak grafik olmayan bileşen yalnızca [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalarda kullanılabilir, [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] veya ASP.NET programlarında kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET programs.</span></span>

 <span data-ttu-id="1e57b-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext> sınıfı bu gereksinimi giderir. Bu, diğer [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] çerçeveleri ile de birlikte çalışarak Basitleştirilmiş <xref:System.Windows.Threading.Dispatcher> bir sürümü olarak düşünün.</span><span class="sxs-lookup"><span data-stu-id="1e57b-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="1e57b-257">İç içe pompalama</span><span class="sxs-lookup"><span data-stu-id="1e57b-257">Nested Pumping</span></span>
 <span data-ttu-id="1e57b-258">Bazen [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığını tamamen kilitlemek uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-259"><xref:System.Windows.MessageBox> sınıfının <xref:System.Windows.MessageBox.Show%2A> yöntemini ele alalım.</span><span class="sxs-lookup"><span data-stu-id="1e57b-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="1e57b-260"><xref:System.Windows.MessageBox.Show%2A>, Kullanıcı Tamam düğmesine tıklaana kadar dönmez.</span><span class="sxs-lookup"><span data-stu-id="1e57b-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="1e57b-261">Ancak, etkileşimli olması için ileti döngüsüne sahip olması gereken bir pencere oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="1e57b-262">Kullanıcının Tamam 'a tıklamasını beklerken, özgün uygulama penceresi Kullanıcı girişine yanıt vermez.</span><span class="sxs-lookup"><span data-stu-id="1e57b-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="1e57b-263">Ancak, boyama iletilerini işlemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="1e57b-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="1e57b-264">Özgün pencere, kapsandığınızda ve gösterildiğinde kendisini yeniden çizer.</span><span class="sxs-lookup"><span data-stu-id="1e57b-264">The original window redraws itself when covered and revealed.</span></span>

 ![Tamam düğmesi ile MessageBox gösteren ekran görüntüsü](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="1e57b-266">Bazı iş parçacıklarının ileti kutusu penceresinde bir ücret olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="1e57b-267">yalnızca ileti kutusu penceresi için yeni bir iş parçacığı oluşturabilir, ancak bu iş parçacığı özgün penceredeki devre dışı bırakılmış öğeleri boyayamadı (karşılıklı dışlamanın önceki tartışmasını hatırlayın).</span><span class="sxs-lookup"><span data-stu-id="1e57b-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="1e57b-268">Bunun yerine, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] iç içe geçmiş bir ileti işleme sistemi kullanır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="1e57b-269"><xref:System.Windows.Threading.Dispatcher> sınıfı, bir uygulamanın geçerli yürütme noktasını depolayan <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>adlı özel bir yöntemi içerir ve sonra yeni bir ileti döngüsü başlatır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="1e57b-270">İç içe geçmiş ileti döngüsü tamamlandığında, yürütme özgün <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> çağrısından sonra devam eder.</span><span class="sxs-lookup"><span data-stu-id="1e57b-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="1e57b-271">Bu durumda <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>çağrısında program bağlamını korur ve arka plan penceresini yeniden boyamak ve ileti kutusu penceresine girişi işlemek için yeni bir ileti döngüsü başlatır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="1e57b-272">Kullanıcı Tamam ' ı tıklattığında ve açılır pencereyi temizlediğinde, iç içe geçmiş döngü çıkar ve <xref:System.Windows.MessageBox.Show%2A>çağrısından sonra devam eder.</span><span class="sxs-lookup"><span data-stu-id="1e57b-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="1e57b-273">Eski yönlendirilmiş olaylar</span><span class="sxs-lookup"><span data-stu-id="1e57b-273">Stale Routed Events</span></span>
 <span data-ttu-id="1e57b-274">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ' deki yönlendirilmiş olay sistemi, olaylar oluşturulduğunda tüm ağaçları bilgilendirir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="1e57b-275">Elips üzerinde sol fare düğmesine basıldığında `handler2` yürütülür.</span><span class="sxs-lookup"><span data-stu-id="1e57b-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="1e57b-276">`handler2` tamamlandıktan sonra olay, işlemek için `handler1` kullanan <xref:System.Windows.Controls.Canvas> nesnesine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="1e57b-277">Bu yalnızca `handler2` olay nesnesini açıkça işlenmiş olarak işaretlemediğinde gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="1e57b-278">`handler2`, bu olayı işlemek için harika bir süre sürer.</span><span class="sxs-lookup"><span data-stu-id="1e57b-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="1e57b-279">`handler2`, saat döndürmeyen bir iç içe ileti döngüsünü başlatmak için <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="1e57b-280">Bu ileti döngüsü tamamlandığında olayı işlenmiş olarak işaretlemeirse, etkinlik çok eski olsa bile ağaca geçirilir. `handler2`</span><span class="sxs-lookup"><span data-stu-id="1e57b-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="1e57b-281">Yeniden giriş ve kilitleme</span><span class="sxs-lookup"><span data-stu-id="1e57b-281">Reentrancy and Locking</span></span>
 <span data-ttu-id="1e57b-282">Ortak dil çalışma zamanının (CLR) kilitleme mekanizması tam olarak tek bir şekilde davranmayabilir; bir kilit istenirken bir iş parçacığının işlemi tamamen durdurmasından kaynaklanabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-282">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="1e57b-283">Gerçekte, iş parçacığı yüksek öncelikli iletileri almaya ve işlemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="1e57b-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="1e57b-284">Bu, kilitlenmeleri önlemeye yardımcı olur ve arabirimlerin düşük ölçüde yanıt vermesini sağlar, ancak hafif hatalara yönelik olasılığı ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="1e57b-285">Bu sürenin büyük çoğunluğunda, bununla ilgili herhangi bir şey bilmeniz gerekmez, ancak nadir koşullarda (genellikle [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] pencere iletilerini veya COM STA bileşenlerini içeren) Bu durum farkında olabilir.</span><span class="sxs-lookup"><span data-stu-id="1e57b-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="1e57b-286">Çoğu arabirim, iş parçacığı güvenliği göz önünde bulundurularak derlenmez çünkü geliştiriciler bir [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] birden fazla iş parçacığı tarafından hiçbir şekilde erişilmediği varsayılarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="1e57b-287">Bu durumda, bu tek iş parçacığı beklenmedik zamanlarda çevresel değişiklikler yapabilir ve bu durum, <xref:System.Windows.Threading.DispatcherObject> karşılıklı dışlama mekanizmasının çözülmesinin gerekmemesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="1e57b-288">Aşağıdaki sözde kodu göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="1e57b-288">Consider the following pseudocode:</span></span>

 <span data-ttu-id="1e57b-289">![İş parçacığı yeniden girişi gösteren diyagram.](./media/threading-model/threading-reentrancy.png "Threadingreentrance")</span><span class="sxs-lookup"><span data-stu-id="1e57b-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="1e57b-290">Çoğu zaman doğru bir şeydir, ancak bu, beklenmeyen yeniden giriş [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sorunlara neden olabilecek zamanlar vardır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="1e57b-291">Bu nedenle, belirli bir anahtar süreleriyle [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], bu iş parçacığının kilit yönergesini, olağan CLR kilidi yerine [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] yeniden giriş ve serbest bir kilit kullanacak şekilde değiştiren <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>çağırır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="1e57b-292">Bu nedenle, CLR ekibi neden bu davranışı seçmişmidir?</span><span class="sxs-lookup"><span data-stu-id="1e57b-292">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="1e57b-293">COM STA nesneleri ve sonlandırma iş parçacığı ile yapması gerekiyordu.</span><span class="sxs-lookup"><span data-stu-id="1e57b-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="1e57b-294">Bir nesne atık olarak toplandığında, `Finalize` yöntemi [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı değil, ayrılmış Sonlandırıcı iş parçacığında çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-295">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı üzerinde oluşturulan bir COM STA nesnesi yalnızca [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı üzerinde atıyacağından, bu sorun oluşur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="1e57b-296">CLR, bir <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> eşdeğerini yapar (Bu durumda Win32's `SendMessage`kullanılarak).</span><span class="sxs-lookup"><span data-stu-id="1e57b-296">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="1e57b-297">Ancak [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] iş parçacığı meşgulse, Sonlandırıcı iş parçacığı durduruldu ve COM STA nesnesi atılamaz ve bu da ciddi bir bellek sızıntısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1e57b-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="1e57b-298">Bu nedenle, CLR ekibi kilitleri yapmak için zor çağrıyı yaptığı gibi çalışır.</span><span class="sxs-lookup"><span data-stu-id="1e57b-298">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="1e57b-299">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] görevi, Bellek sızıntısını yeniden bildirmeden beklenmedik bir şekilde yeniden giriş yapmaktan kaçınmaktır. bu nedenle her yerde yeniden giriş yapmayın.</span><span class="sxs-lookup"><span data-stu-id="1e57b-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="1e57b-300">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="1e57b-300">See also</span></span>

- [<span data-ttu-id="1e57b-301">Uzun süre çalışan hesaplama örneği olan tek Iş parçacıklı uygulama</span><span class="sxs-lookup"><span data-stu-id="1e57b-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
