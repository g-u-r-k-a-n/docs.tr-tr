---
title: Yavaş Başlatma
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 4f2b585dded6e20bb604f623217c6d1f1505c097
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79180575"
---
# <a name="lazy-initialization"></a><span data-ttu-id="8a6fc-102">Yavaş Başlatma</span><span class="sxs-lookup"><span data-stu-id="8a6fc-102">Lazy Initialization</span></span>
<span data-ttu-id="8a6fc-103">Bir nesnenin *tembel başlatılması,* oluşturmanın ilk kullanılana kadar ertelendiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="8a6fc-104">(Bu konu için, *terimler tembel başlatma* ve tembel *anlık* eşanlamlıdır.) Tembel başlatma öncelikle performansı artırmak, savurgan hesaplamaönlemek ve program bellek gereksinimlerini azaltmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="8a6fc-105">Bunlar en yaygın senaryolar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="8a6fc-105">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="8a6fc-106">Oluşturması pahalı bir nesneniz olduğunda ve program onu kullanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="8a6fc-107">Örneğin, bellekte, baş harflere başlatı lacak büyük `Order` bir nesne dizisi içeren bir `Customer` `Orders` nesneye sahip bir nesneniz olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="8a6fc-108">Kullanıcı siparişleri görüntülemek veya verileri bir hesaplamada kullanmak için hiçbir zaman İstemezse, bunu oluşturmak için sistem belleği veya bilgi işlem döngülerini kullanmak için bir neden yoktur.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="8a6fc-109">Sözcükte sözcük başlatma için nesneyi `Lazy<Orders>` `Orders` bildirmek için kullanarak, nesne kullanılmadığında sistem kaynaklarının boşa harcanmasını önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="8a6fc-110">Oluşturması pahalı bir nesneniz olduğunda ve diğer pahalı işlemler tamamlanana kadar oluşturmasını ertelemek istediğinizde.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="8a6fc-111">Örneğin, programınız başladığında birkaç nesne örneği yüklediğini, ancak bunlardan yalnızca bazılarının hemen gerekli olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="8a6fc-112">Gerekli nesneler oluşturulana kadar gerekli olmayan nesnelerin başlatılmasını erteleyerek programın başlangıç performansını artırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="8a6fc-113">Tembel başlatma gerçekleştirmek için kendi kodunuzu yazabiliyor olsanız da, bunun yerine kullanmanızı <xref:System.Lazy%601> öneririz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="8a6fc-114"><xref:System.Lazy%601>ve ilgili türleri de iş parçacığı güvenliğini destekler ve tutarlı bir özel durum yayma ilkesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="8a6fc-115">Aşağıdaki tabloda,.NET Framework sürüm 4'ün farklı senaryolarda tembel bir başlangıç sağlamak için sağladığı türleri listelemesi.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="8a6fc-116">Tür</span><span class="sxs-lookup"><span data-stu-id="8a6fc-116">Type</span></span>|<span data-ttu-id="8a6fc-117">Açıklama</span><span class="sxs-lookup"><span data-stu-id="8a6fc-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="8a6fc-118">Herhangi bir sınıf kitaplığı veya kullanıcı tanımlı türü için tembel başlatma semantik sağlayan bir sarmalayıcı sınıfı.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="8a6fc-119">Bir <xref:System.Lazy%601> iş parçacığı yerel olarak tembel başlatma semantik sağlar dışında benzer.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="8a6fc-120">Her iş parçacığının kendi benzersiz değerine erişimi vardır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="8a6fc-121">Bir `static` sınıfın`Shared` yükü olmadan nesnelerin tembel başlatılması için gelişmiş (Visual Basic) yöntemleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="8a6fc-122">Temel Tembel Başlatma</span><span class="sxs-lookup"><span data-stu-id="8a6fc-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="8a6fc-123">Aşağıdaki örnekte gösterildiği gibi, örneğin, `MyType` `Lazy<MyType>` (Visual`Lazy(Of MyType)` Basic'te) tembel-başharfe bürünen bir türü tanımlamak için.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="8a6fc-124"><xref:System.Lazy%601> Oluşturucuda temsilci geçirilirse, değer özelliğine ilk <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> erişildiğinde sarılmış tür kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="8a6fc-125">Türde parametresiz bir oluşturucu yoksa, çalışma zamanı özel bir durum atılır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-125">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="8a6fc-126">Aşağıdaki örnekte, veritabanından alınan bir `Orders` `Order` dizi nesne içeren bir sınıf olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="8a6fc-127">Bir `Customer` nesne `Orders`, ancak kullanıcı eylemlerine bağlı olarak, `Orders` nesneden veri gerekli olmayabilir bir örnek içerir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="8a6fc-128">Ayrıca, oluşturma zamanında sarılmış <xref:System.Lazy%601> türde belirli bir kurucu aşırı yükleme çağıran bir temsilciyi oluşturucuya geçirebilir ve aşağıdaki örnekte gösterildiği gibi gerekli olan diğer başlatma adımlarını gerçekleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="8a6fc-129">Lazy nesnesi oluşturulduktan sonra, Lazy `Orders` <xref:System.Lazy%601.Value%2A> değişkeninin özelliğine ilk kez erişilene kadar hiçbir örnek oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="8a6fc-130">İlk erişimde, sarılmış tür oluşturulur ve döndürülür ve gelecekteki erişim için depolanır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="8a6fc-131">Bir <xref:System.Lazy%601> nesne her zaman başharfle başlandı aynı nesne veya değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="8a6fc-132">Bu nedenle, <xref:System.Lazy%601.Value%2A> özellik salt okunur.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="8a6fc-133">Bir <xref:System.Lazy%601.Value%2A> başvuru türünü depolarsanız, ona yeni bir nesne atamazsınız.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="8a6fc-134">(Ancak, ayarlanabilir ortak alanların ve özelliklerinin değerini değiştirebilirsiniz.) Bir <xref:System.Lazy%601.Value%2A> değer türünü depolarsanız, değerini değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="8a6fc-135">Bununla birlikte, yeni bağımsız değişkenler kullanarak değişken oluşturucuyu yeniden çağırarak yeni bir değişken oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="8a6fc-136">Yeni tembel örnek, önceki gibi, özelliği ilk `Orders` erişilene <xref:System.Lazy%601.Value%2A> kadar anlık değildir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="8a6fc-137">İş Parçacığı Güvenli Başlatma</span><span class="sxs-lookup"><span data-stu-id="8a6fc-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="8a6fc-138">Varsayılan olarak, <xref:System.Lazy%601> nesneler iş parçacığı güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="8a6fc-139">Diğer bir nokta, oluşturucu iş parçacığı nın türünü <xref:System.Lazy%601> belirtmezse, oluşturduğu nesneler iş parçacığı için güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="8a6fc-140">Çok iş parçacığı senaryolarında, iş parçacığı <xref:System.Lazy%601.Value%2A> güvenli <xref:System.Lazy%601> bir nesnenin özelliğine erişmek için ilk iş parçacığı tüm iş parçacıkları üzerinde sonraki tüm erişimler için başlatılan ve tüm iş parçacıkları aynı verileri paylaşır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="8a6fc-141">Bu nedenle, hangi iş parçacığı nesneyi baş harfe doğru başlatmaktadır ve yarış koşulları iyi huyludur.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8a6fc-142">Özel durum önbelleğe alma kullanarak bu tutarlılığı hata koşullarına genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="8a6fc-143">Daha fazla bilgi için, sonraki bölüme bakın, [Tembel Nesneler özel durumlar.](lazy-initialization.md#ExceptionsInLazyObjects)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-143">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="8a6fc-144">Aşağıdaki örnek, aynı `Lazy<int>` örneğin üç ayrı iş parçacığı için aynı değere sahip olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="8a6fc-145">Her iş parçacığı için ayrı veri <xref:System.Threading.ThreadLocal%601> gerekiyorsa, bu konuda daha sonra açıklandığı gibi türü kullanın.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="8a6fc-146">Bazı <xref:System.Lazy%601> oluşturucular, <xref:System.Lazy%601.Value%2A> özelliğin birden `isThreadSafe` çok iş parçacığından erişilip erişilmeyeceğini belirtmek için kullanılan boolean parametresi adlı bir parametreye sahiptir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="8a6fc-147">Eğer sadece bir iş parçacığı özelliği erişmek `false` niyetinde iseniz, mütevazı bir performans avantajı elde etmek için geçmek.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="8a6fc-148">Özelliğe birden çok iş parçacığından erişmeye `true` yönelikseniz, bir iş parçacığının <xref:System.Lazy%601> başlatma zamanında özel bir durum attığı yarış koşullarını doğru şekilde işlemesi için örneği talimat vermek için geçiş edin.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="8a6fc-149">Bazı <xref:System.Lazy%601> oluşturucuların <xref:System.Threading.LazyThreadSafetyMode> bir parametresi vardır. `mode`</span><span class="sxs-lookup"><span data-stu-id="8a6fc-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="8a6fc-150">Bu oluşturucular ek bir iş parçacığı güvenlik modu sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="8a6fc-151">Aşağıdaki tablo, bir <xref:System.Lazy%601> nesnenin iş parçacığı güvenliğinin iş parçacığı güvenliğini belirten oluşturucu parametreleri tarafından nasıl etkilendiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="8a6fc-152">Her oluşturucunun en fazla bir parametresi vardır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="8a6fc-153">Nesnenin iş parçacığı güvenliği</span><span class="sxs-lookup"><span data-stu-id="8a6fc-153">Thread safety of the object</span></span>|<span data-ttu-id="8a6fc-154">`LazyThreadSafetyMode``mode` parametre</span><span class="sxs-lookup"><span data-stu-id="8a6fc-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="8a6fc-155">Boolean `isThreadSafe` parametresi</span><span class="sxs-lookup"><span data-stu-id="8a6fc-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="8a6fc-156">İş parçacığı güvenlik parametreleri yok</span><span class="sxs-lookup"><span data-stu-id="8a6fc-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="8a6fc-157">Tamamen iş parçacığı güvenli; değeri başlatmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="8a6fc-158">Evet.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-158">Yes.</span></span>|  
|<span data-ttu-id="8a6fc-159">İş parçacığı güvenli değil.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="8a6fc-160">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-160">Not applicable.</span></span>|  
|<span data-ttu-id="8a6fc-161">Tamamen iş parçacığı güvenli; konuları değeri başlatmaya yarış.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="8a6fc-162">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-162">Not applicable.</span></span>|<span data-ttu-id="8a6fc-163">Geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="8a6fc-164">Tablonun gösterdiği gibi, <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> `mode` parametre için `true` belirtme, `isThreadSafe` parametre için belirtme ile <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> aynıdır ve belirtme `false`de .</span><span class="sxs-lookup"><span data-stu-id="8a6fc-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="8a6fc-165">Belirtme, <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> birden çok iş parçacığının <xref:System.Lazy%601> örneği başlatmaya çalışmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="8a6fc-166">Bu yarışı yalnızca bir iş parçacığı kazanabilir ve diğer tüm iş parçacıkları başarılı iş parçacığı tarafından başlatı edilen değeri alır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="8a6fc-167">Başlatma sırasında bir iş parçacığına bir özel durum atılırsa, bu iş parçacığı başarılı iş parçacığı tarafından ayarlanan değeri almaz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="8a6fc-168">Özel durumlar önbelleğe alınmaz, bu nedenle <xref:System.Lazy%601.Value%2A> sonraki bir girişim özelliğine erişmek için başarılı bir başlatma neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="8a6fc-169">Bu, aşağıdaki bölümde açıklanan diğer modlarda özel durumlara işlenir şekilde farklıdır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="8a6fc-170">Daha fazla bilgi <xref:System.Threading.LazyThreadSafetyMode> için numaralandırmaya bakın.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="8a6fc-171">Tembel Nesnelerdeki Özel Durumlar</span><span class="sxs-lookup"><span data-stu-id="8a6fc-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="8a6fc-172">Daha önce belirtildiği <xref:System.Lazy%601> gibi, bir nesne her zaman ile başharfe <xref:System.Lazy%601.Value%2A> başlandı aynı nesne veya değer döndürür ve bu nedenle özellik salt okunur.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="8a6fc-173">Özel durum önbelleğe alma özelliğini etkinleştirirseniz, bu değişmezlik özel durum davranışına da uzanır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="8a6fc-174">Tembel olarak başlatılan bir nesne özel durum önbelleğe alma özelliğietkin ve <xref:System.Lazy%601.Value%2A> özelliği ilk erişildiğinde onun başlatma yönteminden bir özel <xref:System.Lazy%601.Value%2A> durum atıyorsa, aynı özel durum özelliği erişmek için sonraki her girişimde atılır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="8a6fc-175">Başka bir deyişle, sarılmış tür oluşturucu, çok iş parçacığı senaryolarında bile hiçbir zaman yeniden çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="8a6fc-176">Bu nedenle, <xref:System.Lazy%601> nesne bir erişim bir özel durum atamaz ve sonraki bir erişim bir değer döndüremez.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="8a6fc-177">Bir başlatma yöntemi (parametre) <xref:System.Lazy%601?displayProperty=nameWithType> `valueFactory` alan herhangi bir oluşturucu kullandığınızda özel durum önbelleğe alma etkindir; örneğin, `Lazy(T)(Func(T))`oluşturucuyu kullandığınızda etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="8a6fc-178">Oluşturucu <xref:System.Threading.LazyThreadSafetyMode> da bir değer`mode` (parametre) <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>alıyorsa, belirtin veya .</span><span class="sxs-lookup"><span data-stu-id="8a6fc-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8a6fc-179">Bir başlatma yöntemi belirtilmesi, bu iki mod için özel durum önbelleğe alınmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="8a6fc-180">Başlatma yöntemi çok basit olabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-180">The initialization method can be very simple.</span></span> <span data-ttu-id="8a6fc-181">Örneğin, parametresiz oluşturucu `T`: `new Lazy<Contents>(() => new Contents(), mode)` C#veya Visual Basic `New Lazy(Of Contents)(Function() New Contents())` olarak adlandırabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-181">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="8a6fc-182">Bir başlatma <xref:System.Lazy%601?displayProperty=nameWithType> yöntemi belirtmeyen bir oluşturucu kullanıyorsanız, parametresiz oluşturucu `T` tarafından atılan özel durumlar önbelleğe alınmaz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="8a6fc-183">Daha fazla bilgi <xref:System.Threading.LazyThreadSafetyMode> için numaralandırmaya bakın.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8a6fc-184">`isThreadSafe` Kurucu parametresi ayarlı `false` bir `mode` <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> <xref:System.Lazy%601> <xref:System.Lazy%601> nesne veya kurucu parametre ayarlanmışsa, nesneye tek bir iş parçacığından erişmeniz veya kendi eşitlemenizi sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="8a6fc-185">Bu, özel durum önbelleğe alma da dahil olmak üzere nesnenin tüm yönleri için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="8a6fc-186">Önceki bölümde belirtildiği gibi, <xref:System.Lazy%601> özel durumları <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> farklı şekilde ele alarak oluşturulan nesneler.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="8a6fc-187">Ile, <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>birden çok iş parçacığı <xref:System.Lazy%601> örneği başlatmak için rekabet edebilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="8a6fc-188">Bu durumda, özel durumlar önbelleğe alınmaz ve <xref:System.Lazy%601.Value%2A> başlatma başarılı olana kadar özelliğe erişim girişimleri devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="8a6fc-189">Aşağıdaki tablo, <xref:System.Lazy%601> oluşturucuların özel durum önbelleğe alma biçimini özetler.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="8a6fc-190">Oluşturucu</span><span class="sxs-lookup"><span data-stu-id="8a6fc-190">Constructor</span></span>|<span data-ttu-id="8a6fc-191">İş parçacığı güvenlik modu</span><span class="sxs-lookup"><span data-stu-id="8a6fc-191">Thread safety mode</span></span>|<span data-ttu-id="8a6fc-192">Başlatma yöntemini kullanır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-192">Uses initialization method</span></span>|<span data-ttu-id="8a6fc-193">Özel durumlar önbelleğe alınır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="8a6fc-194">Tembel(T)()</span><span class="sxs-lookup"><span data-stu-id="8a6fc-194">Lazy(T)()</span></span>|<span data-ttu-id="8a6fc-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="8a6fc-196">Hayır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-196">No</span></span>|<span data-ttu-id="8a6fc-197">Hayır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-197">No</span></span>|  
|<span data-ttu-id="8a6fc-198">Tembel(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="8a6fc-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="8a6fc-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="8a6fc-200">Evet</span><span class="sxs-lookup"><span data-stu-id="8a6fc-200">Yes</span></span>|<span data-ttu-id="8a6fc-201">Evet</span><span class="sxs-lookup"><span data-stu-id="8a6fc-201">Yes</span></span>|  
|<span data-ttu-id="8a6fc-202">Tembel(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="8a6fc-203">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) `false` <xref:System.Threading.LazyThreadSafetyMode.None>veya ( )</span><span class="sxs-lookup"><span data-stu-id="8a6fc-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="8a6fc-204">Hayır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-204">No</span></span>|<span data-ttu-id="8a6fc-205">Hayır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-205">No</span></span>|  
|<span data-ttu-id="8a6fc-206">Tembel(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="8a6fc-207">`True`(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) `false` <xref:System.Threading.LazyThreadSafetyMode.None>veya ( )</span><span class="sxs-lookup"><span data-stu-id="8a6fc-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="8a6fc-208">Evet</span><span class="sxs-lookup"><span data-stu-id="8a6fc-208">Yes</span></span>|<span data-ttu-id="8a6fc-209">Evet</span><span class="sxs-lookup"><span data-stu-id="8a6fc-209">Yes</span></span>|  
|<span data-ttu-id="8a6fc-210">Tembel(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="8a6fc-211">Kullanıcı tarafından belirtilen</span><span class="sxs-lookup"><span data-stu-id="8a6fc-211">User-specified</span></span>|<span data-ttu-id="8a6fc-212">Hayır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-212">No</span></span>|<span data-ttu-id="8a6fc-213">Hayır</span><span class="sxs-lookup"><span data-stu-id="8a6fc-213">No</span></span>|  
|<span data-ttu-id="8a6fc-214">Tembel(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="8a6fc-215">Kullanıcı tarafından belirtilen</span><span class="sxs-lookup"><span data-stu-id="8a6fc-215">User-specified</span></span>|<span data-ttu-id="8a6fc-216">Evet</span><span class="sxs-lookup"><span data-stu-id="8a6fc-216">Yes</span></span>|<span data-ttu-id="8a6fc-217">Kullanıcı belirtirse <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>hayır; Aksi takdirde, evet.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="8a6fc-218">Tembel-Başharfe Bünyeyle Özellik Uygulama</span><span class="sxs-lookup"><span data-stu-id="8a6fc-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="8a6fc-219">Tembel başlatma kullanarak bir kamu malı uygulamak için, bir <xref:System.Lazy%601>olarak özelliğin <xref:System.Lazy%601.Value%2A> destek alanı `get` tanımlamak ve özelliği erişimci den geri.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="8a6fc-220">Özellik <xref:System.Lazy%601.Value%2A> salt okunur; bu nedenle, onu ortaya çıkaran `set` özelliği hiçbir erişimci vardır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="8a6fc-221">Bir nesne tarafından desteklenen bir <xref:System.Lazy%601> okuma/yazma özelliğine ihtiyacınız varsa, `set` erişimcinin yeni <xref:System.Lazy%601> bir nesne oluşturması ve bunu destek deposuna ataması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="8a6fc-222">Erişimci, `set` `set` erişime geçen yeni özellik değerini döndüren bir lambda ifadesi oluşturmalı ve bu lambda <xref:System.Lazy%601> ifadesini yeni nesne için oluşturucuya geçirmelidir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="8a6fc-223"><xref:System.Lazy%601.Value%2A> Özelliğin bir sonraki erişimi yeni <xref:System.Lazy%601>nin başlatılmasına neden olur ve özelliği <xref:System.Lazy%601.Value%2A> bundan sonra özelliğe atanan yeni değeri döndürecektir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="8a6fc-224">Bu dolambaçlı düzenlemenin nedeni, yerleşik <xref:System.Lazy%601>çok iş parçacığı korumalarını korumaktır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="8a6fc-225">Aksi takdirde, özellik erişimedenlerin <xref:System.Lazy%601.Value%2A> özellik tarafından döndürülen ilk değeri önbelleğe alması ve yalnızca önbelleğe alınmış değeri değiştirmesi ve bunu yapmak için kendi iş parçacığı güvenli kodunuzu yazmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="8a6fc-226">Bir <xref:System.Lazy%601> nesne tarafından desteklenen okuma/yazma özelliği nin gerektirdiği ek başlatmalar nedeniyle, performans kabul edilemez olabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="8a6fc-227">Ayrıca, belirli senaryoya bağlı olarak, ayarlayıcılar ve ayarlayıcılar arasındaki yarış koşullarını önlemek için ek koordinasyon gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="8a6fc-228">Konu-Yerel Tembel Başlatma</span><span class="sxs-lookup"><span data-stu-id="8a6fc-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="8a6fc-229">Bazı çok iş parçacığı senaryolarında, her iş parçacığıkendi özel veri vermek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="8a6fc-230">Bu tür verilere *iş parçacığı yerel verileri*denir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="8a6fc-231">.NET Framework sürüm 3.5 ve daha önceki `ThreadStatic` sürümde, iş parçacığı yerel yapmak için statik bir değişkenöznitelik uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="8a6fc-232">Ancak, öznitelik kullanarak `ThreadStatic` ince hatalara yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="8a6fc-233">Örneğin, temel başlatma deyimleri bile aşağıdaki örnekte gösterildiği gibi, değişkenin yalnızca ona erişen ilk iş parçacığında başlatılmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="8a6fc-234">Diğer tüm iş parçacıklarında, değişken varsayılan değeri (sıfır) kullanılarak başharfe çevrilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="8a6fc-235">.NET Framework sürüm 4'te alternatif olarak, <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> tür, sağladığınız <xref:System.Action%601> temsilci tarafından tüm iş parçacıklarında başharfe çevrilmiş örnek tabanlı, iş parçacığı yerel değişkeni oluşturmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="8a6fc-236">Aşağıdaki örnekte, erişen `counter` tüm iş parçacıkları başlangıç değerini 1 olarak görür.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="8a6fc-237"><xref:System.Threading.ThreadLocal%601><xref:System.Lazy%601>nesnesini, bu temel farklılıklarla aynı şekilde sarar:</span><span class="sxs-lookup"><span data-stu-id="8a6fc-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="8a6fc-238">Her iş parçacığı, diğer iş parçacıklarından erişilemeyen kendi özel verilerini kullanarak iş parçacığı yerel değişkenini başlangıç olarak kullanır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="8a6fc-239">Özellik <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> okuma-yazma özelliğidir ve herhangi bir sayıda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="8a6fc-240">Bu, özel durum yayılmasını etkileyebilir, `get` örneğin, bir işlem özel durum artırabilir, ancak bir sonraki değeri başarıyla başlatmaolabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="8a6fc-241">Hiçbir başlatma temsilcisi sağlanmazsa, <xref:System.Threading.ThreadLocal%601> türün varsayılan değerini kullanarak sarılmış türünü başolarak alacaktır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="8a6fc-242">Bu bağlamda, <xref:System.Threading.ThreadLocal%601> öznitelik <xref:System.ThreadStaticAttribute> ile tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="8a6fc-243">Aşağıdaki örnek, örneğe `ThreadLocal<int>` erişen her iş parçacığının verilerin kendi benzersiz kopyasını aldığını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="8a6fc-244">Paralel.For ve ForEach'de İş Parçacığı-Yerel Değişkenler</span><span class="sxs-lookup"><span data-stu-id="8a6fc-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="8a6fc-245">Veri kaynakları <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> üzerinde <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> paralel olarak yeniden doğrulamak için yöntem veya yöntemi kullandığınızda, iş parçacığı yerel verileri için yerleşik desteği olan aşırı yüklemeleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="8a6fc-246">Bu yöntemlerde, iş parçacığı yerelliği, verileri oluşturmak, erişmek ve temizlemek için yerel temsilciler kullanılarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="8a6fc-247">Daha fazla bilgi için [bkz: Thread-Local Variables ile Parallel.For Loop yazın](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) ve [Nasıl: Partition-Local Variables ile Parallel.ForEach Loop yazın.](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="8a6fc-248">Düşük Tepeyle Senaryolar için Tembel Başlatma kullanma</span><span class="sxs-lookup"><span data-stu-id="8a6fc-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="8a6fc-249">Çok sayıda nesneyi tembelleştirmeniz gereken senaryolarda, her nesneyi çok <xref:System.Lazy%601> fazla bellek veya çok fazla bilgi işlem kaynağı na sarmanın gerektirdiğine karar verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="8a6fc-250">Veya, nasıl tembel başlatma maruz olduğu hakkında sıkı gereksinimleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="8a6fc-251">Bu gibi durumlarda, sınıfın `static` `Shared` (Visual Basic'te) <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> yöntemlerini kullanarak her nesneyi bir örneğinde <xref:System.Lazy%601>sarmadan tembel-baş harfe bekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="8a6fc-252">Aşağıdaki örnekte, bir nesnenin tamamını `Orders` tek <xref:System.Lazy%601> bir nesneye sarmak yerine, `Order` yalnızca gerekliyse, tek tek nesneleri tembelolarak başlatmanız gerektiğini varsayalım.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="8a6fc-253">Bu örnekte, başlatma yordamı döngü her yineleme üzerinde çağrılır dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="8a6fc-254">Çok iş parçacığı senaryolarında, başlatma yordamını çağıran ilk iş parçacığı, değeri tüm iş parçacıkları tarafından görülen iş parçacığıdır.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="8a6fc-255">Daha sonraki iş parçacıkları da başlatma yordamını çağırır, ancak sonuçları kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="8a6fc-256">Bu tür bir olası yarış koşulu kabul edilemezse, boolean bağımsız değişkeni ve eşitleme nesnesi <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> gereken aşırı yük kullanın.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8a6fc-257">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="8a6fc-257">See also</span></span>

- [<span data-ttu-id="8a6fc-258">Yönetilen İş Parçacığı Oluşturma Temelleri</span><span class="sxs-lookup"><span data-stu-id="8a6fc-258">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="8a6fc-259">İş Parçacıkları ve İş Parçacığı Oluşturma</span><span class="sxs-lookup"><span data-stu-id="8a6fc-259">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="8a6fc-260">Görev Paralel Kitaplığı (TPL)</span><span class="sxs-lookup"><span data-stu-id="8a6fc-260">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="8a6fc-261">Nasıl yapılır: Nesnelerin Yavaş Başlatılmasını Gerçekleştirme</span><span class="sxs-lookup"><span data-stu-id="8a6fc-261">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
