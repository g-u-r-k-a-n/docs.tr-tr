---
title: Performans Hususları (Varlık Çerçevesi)
ms.date: 03/30/2017
ms.assetid: 61913f3b-4f42-4d9b-810f-2a13c2388a4a
ms.openlocfilehash: 0ff018fe0d8199dcd790bcd3de18751662e0a92b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79149745"
---
# <a name="performance-considerations-entity-framework"></a><span data-ttu-id="3337f-102">Performans Hususları (Varlık Çerçevesi)</span><span class="sxs-lookup"><span data-stu-id="3337f-102">Performance Considerations (Entity Framework)</span></span>
<span data-ttu-id="3337f-103">Bu konu, varlık çerçevesinin ADO.NET performans özelliklerini açıklar ve Varlık Çerçevesi uygulamalarının performansını artırmaya yardımcı olmak için bazı hususlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="3337f-103">This topic describes performance characteristics of the ADO.NET Entity Framework and provides some considerations to help improve the performance of Entity Framework applications.</span></span>  
  
## <a name="stages-of-query-execution"></a><span data-ttu-id="3337f-104">Sorgu Yürütme Aşamaları</span><span class="sxs-lookup"><span data-stu-id="3337f-104">Stages of Query Execution</span></span>  
 <span data-ttu-id="3337f-105">Varlık Çerçevesi'ndeki sorguların performansını daha iyi anlamak için, bir sorgu kavramsal bir modele karşı yürütüldüğünde ve verileri nesne olarak döndürdüğünde oluşan işlemleri anlamak yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="3337f-105">In order to better understand the performance of queries in the Entity Framework, it is helpful to understand the operations that occur when a query executes against a conceptual model and returns data as objects.</span></span> <span data-ttu-id="3337f-106">Aşağıdaki tabloda bu işlem dizilimi açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="3337f-106">The following table describes this series of operations.</span></span>  
  
|<span data-ttu-id="3337f-107">İşlem</span><span class="sxs-lookup"><span data-stu-id="3337f-107">Operation</span></span>|<span data-ttu-id="3337f-108">Göreli Maliyet</span><span class="sxs-lookup"><span data-stu-id="3337f-108">Relative Cost</span></span>|<span data-ttu-id="3337f-109">Frequency</span><span class="sxs-lookup"><span data-stu-id="3337f-109">Frequency</span></span>|<span data-ttu-id="3337f-110">Yorumlar</span><span class="sxs-lookup"><span data-stu-id="3337f-110">Comments</span></span>|  
|---------------|-------------------|---------------|--------------|  
|<span data-ttu-id="3337f-111">Meta verileri yükleme</span><span class="sxs-lookup"><span data-stu-id="3337f-111">Loading metadata</span></span>|<span data-ttu-id="3337f-112">Orta</span><span class="sxs-lookup"><span data-stu-id="3337f-112">Moderate</span></span>|<span data-ttu-id="3337f-113">Her uygulama etki alanında bir kez.</span><span class="sxs-lookup"><span data-stu-id="3337f-113">Once in each application domain.</span></span>|<span data-ttu-id="3337f-114">Varlık Çerçevesi tarafından kullanılan model ve eşleme <xref:System.Data.Metadata.Edm.MetadataWorkspace>meta verileri bir .</span><span class="sxs-lookup"><span data-stu-id="3337f-114">Model and mapping metadata used by the Entity Framework is loaded into a <xref:System.Data.Metadata.Edm.MetadataWorkspace>.</span></span> <span data-ttu-id="3337f-115">Bu meta veriler genel olarak önbelleğe alınır ve <xref:System.Data.Objects.ObjectContext> aynı uygulama etki alanında diğer örnekleri için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-115">This metadata is cached globally and is available to other instances of <xref:System.Data.Objects.ObjectContext> in the same application domain.</span></span>|  
|<span data-ttu-id="3337f-116">Veritabanı bağlantısını açma</span><span class="sxs-lookup"><span data-stu-id="3337f-116">Opening the database connection</span></span>|<span data-ttu-id="3337f-117">Orta<sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-117">Moderate<sup>1</sup></span></span>|<span data-ttu-id="3337f-118">Gerektiği gibi.</span><span class="sxs-lookup"><span data-stu-id="3337f-118">As needed.</span></span>|<span data-ttu-id="3337f-119">Veritabanına açık bir bağlantı değerli bir kaynak tükettiği için, Varlık Çerçevesi veritabanı bağlantısını yalnızca gerektiği gibi açar ve kapatır.</span><span class="sxs-lookup"><span data-stu-id="3337f-119">Because an open connection to the database consumes a valuable resource, the Entity Framework opens and closes the database connection only as needed.</span></span> <span data-ttu-id="3337f-120">Ayrıca bağlantıyı açıkça açabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-120">You can also explicitly open the connection.</span></span> <span data-ttu-id="3337f-121">Daha fazla bilgi için [bkz.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-121">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>|  
|<span data-ttu-id="3337f-122">Görünüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="3337f-122">Generating views</span></span>|<span data-ttu-id="3337f-123">Yüksek</span><span class="sxs-lookup"><span data-stu-id="3337f-123">High</span></span>|<span data-ttu-id="3337f-124">Her uygulama etki alanında bir kez.</span><span class="sxs-lookup"><span data-stu-id="3337f-124">Once in each application domain.</span></span> <span data-ttu-id="3337f-125">(Önceden oluşturulabilir.)</span><span class="sxs-lookup"><span data-stu-id="3337f-125">(Can be pre-generated.)</span></span>|<span data-ttu-id="3337f-126">Varlık Çerçevesi'nin bir sorguyu kavramsal bir modele karşı yürütemeden veya veri kaynağında değişiklik kaydedebilmek için veritabanına erişmek için bir dizi yerel sorgu görünümü oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="3337f-126">Before the Entity Framework can execute a query against a conceptual model or save changes to the data source, it must generate a set of local query views to access the database.</span></span> <span data-ttu-id="3337f-127">Bu görünümleri oluşturmanın yüksek maliyeti nedeniyle, görünümleri önceden oluşturabilir ve tasarım zamanında projeye ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-127">Because of the high cost of generating these views, you can pre-generate the views and add them to the project at design-time.</span></span> <span data-ttu-id="3337f-128">Daha fazla bilgi için [bkz: Sorgu Performansını Artırmak için Görünümleri Önceden Oluştur.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-128">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>|  
|<span data-ttu-id="3337f-129">Sorguyu hazırlama</span><span class="sxs-lookup"><span data-stu-id="3337f-129">Preparing the query</span></span>|<span data-ttu-id="3337f-130">Orta<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-130">Moderate<sup>2</sup></span></span>|<span data-ttu-id="3337f-131">Her benzersiz sorgu için bir kez.</span><span class="sxs-lookup"><span data-stu-id="3337f-131">Once for each unique query.</span></span>|<span data-ttu-id="3337f-132">Sorgu komutunu oluşturmak, modele dayalı bir komut ağacı oluşturmak ve meta verileri eşleme maliyetlerini içerir ve döndürülen verilerin şeklini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="3337f-132">Includes the costs to compose the query command, generate a command tree based on model and mapping metadata, and define the shape of the returned data.</span></span> <span data-ttu-id="3337f-133">Artık hem Entity SQL sorgu komutları hem de LINQ sorguları önbelleğe alındığından, aynı sorgunun daha sonraki yürütmeleri daha az zaman alır.</span><span class="sxs-lookup"><span data-stu-id="3337f-133">Because now both Entity SQL query commands and LINQ queries are cached, later executions of the same query take less time.</span></span> <span data-ttu-id="3337f-134">Daha sonraki yürütmelerde bu maliyeti azaltmak için derlenmiş LINQ sorgularını kullanmaya devam edebilirsiniz ve derlenen sorgular otomatik olarak önbelleğe alınmış LINQ sorgularından daha verimli olabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-134">You can still use compiled LINQ queries to reduce this cost in later executions and compiled queries can be more efficient than LINQ queries that are automatically cached.</span></span> <span data-ttu-id="3337f-135">Daha fazla bilgi için [derlenmiş sorgulara (LINQ to Ntities)](./language-reference/compiled-queries-linq-to-entities.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="3337f-135">For more information, see [Compiled Queries  (LINQ to Entities)](./language-reference/compiled-queries-linq-to-entities.md).</span></span> <span data-ttu-id="3337f-136">LINQ sorgu yürütmesi hakkında genel bilgi için [LINQ to Ntities 'a](./language-reference/linq-to-entities.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="3337f-136">For general information about LINQ query execution, see [LINQ to Entities](./language-reference/linq-to-entities.md).</span></span> <span data-ttu-id="3337f-137">**Not:**  `Enumerable.Contains` Işleci bellek içi koleksiyonlara uygulayan Varlıklara LINQ sorguları otomatik olarak önbelleğe alınmaz.</span><span class="sxs-lookup"><span data-stu-id="3337f-137">**Note:**  LINQ to Entities queries that apply the `Enumerable.Contains` operator to in-memory collections are not automatically cached.</span></span> <span data-ttu-id="3337f-138">Ayrıca derlenmiş LINQ sorgularında bellek içi koleksiyonları parametrelendirmeye izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="3337f-138">Also parameterizing in-memory collections in compiled LINQ queries is not allowed.</span></span>|  
|<span data-ttu-id="3337f-139">Sorguyu yürütme</span><span class="sxs-lookup"><span data-stu-id="3337f-139">Executing the query</span></span>|<span data-ttu-id="3337f-140">Düşük<sup>2</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-140">Low<sup>2</sup></span></span>|<span data-ttu-id="3337f-141">Her sorgu için bir kez.</span><span class="sxs-lookup"><span data-stu-id="3337f-141">Once for each query.</span></span>|<span data-ttu-id="3337f-142">ADO.NET veri sağlayıcısını kullanarak komutu veri kaynağına karşı yürütme maliyeti.</span><span class="sxs-lookup"><span data-stu-id="3337f-142">The cost of executing the command against the data source by using the ADO.NET data provider.</span></span> <span data-ttu-id="3337f-143">Çoğu veri kaynağı sorgu planlarını önbelleğe aldığı için, aynı sorgunun daha sonraki yürütmeleri daha da kısa sürebilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-143">Because most data sources cache query plans, later executions of the same query may take even less time.</span></span>|  
|<span data-ttu-id="3337f-144">Yükleme ve doğrulama türleri</span><span class="sxs-lookup"><span data-stu-id="3337f-144">Loading and validating types</span></span>|<span data-ttu-id="3337f-145">Düşük<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-145">Low<sup>3</sup></span></span>|<span data-ttu-id="3337f-146">Her örnek <xref:System.Data.Objects.ObjectContext> için bir kez.</span><span class="sxs-lookup"><span data-stu-id="3337f-146">Once for each <xref:System.Data.Objects.ObjectContext> instance.</span></span>|<span data-ttu-id="3337f-147">Türler, kavramsal modelin tanımladığı türlere göre yüklenir ve doğrulanır.</span><span class="sxs-lookup"><span data-stu-id="3337f-147">Types are loaded and validated against the types that the conceptual model defines.</span></span>|  
|<span data-ttu-id="3337f-148">İzleme</span><span class="sxs-lookup"><span data-stu-id="3337f-148">Tracking</span></span>|<span data-ttu-id="3337f-149">Düşük<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-149">Low<sup>3</sup></span></span>|<span data-ttu-id="3337f-150">Bir sorgunun döndürdettiği her nesne için bir kez.</span><span class="sxs-lookup"><span data-stu-id="3337f-150">Once for each object that a query returns.</span></span> <span data-ttu-id="3337f-151"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-151"><sup>4</sup></span></span>|<span data-ttu-id="3337f-152">Bir sorgu birleştirme <xref:System.Data.Objects.MergeOption.NoTracking> seçeneğini kullanıyorsa, bu aşama performansı etkilemez.</span><span class="sxs-lookup"><span data-stu-id="3337f-152">If a query uses the <xref:System.Data.Objects.MergeOption.NoTracking> merge option, this stage does not affect performance.</span></span><br /><br /> <span data-ttu-id="3337f-153">Sorgu <xref:System.Data.Objects.MergeOption.AppendOnly>, , <xref:System.Data.Objects.MergeOption.PreserveChanges>veya <xref:System.Data.Objects.MergeOption.OverwriteChanges> birleştirme seçeneğini kullanırsa, <xref:System.Data.Objects.ObjectStateManager>sorgu sonuçları .</span><span class="sxs-lookup"><span data-stu-id="3337f-153">If the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly>, <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> merge option, query results are tracked in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="3337f-154">Sorgunun döndürdüğü her <xref:System.Data.Objects.ObjectStateEntry> izlenen <xref:System.Data.Objects.ObjectStateManager>nesne için bir <xref:System.Data.EntityKey> ürün oluştur</span><span class="sxs-lookup"><span data-stu-id="3337f-154">An <xref:System.Data.EntityKey> is generated for each tracked object that the query returns and is used to create an <xref:System.Data.Objects.ObjectStateEntry> in the <xref:System.Data.Objects.ObjectStateManager>.</span></span> <span data-ttu-id="3337f-155">Varolan <xref:System.Data.Objects.ObjectStateEntry> bir nesne için <xref:System.Data.EntityKey>bulunabilir, varolan nesne döndürülür.</span><span class="sxs-lookup"><span data-stu-id="3337f-155">If an existing <xref:System.Data.Objects.ObjectStateEntry> can be found for the <xref:System.Data.EntityKey>, the existing object is returned.</span></span> <span data-ttu-id="3337f-156"><xref:System.Data.Objects.MergeOption.PreserveChanges>, veya <xref:System.Data.Objects.MergeOption.OverwriteChanges> seçenek kullanılırsa, nesne döndürülmeden önce güncelleştirilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-156">If the <xref:System.Data.Objects.MergeOption.PreserveChanges>, or <xref:System.Data.Objects.MergeOption.OverwriteChanges> option is used, the object is updated before it is returned.</span></span><br /><br /> <span data-ttu-id="3337f-157">Daha fazla bilgi için [bkz: Kimlik Çözümü, Devlet Yönetimi ve Değişiklik İzleme.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-157">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
|<span data-ttu-id="3337f-158">Nesneleri maddeleştirme</span><span class="sxs-lookup"><span data-stu-id="3337f-158">Materializing the objects</span></span>|<span data-ttu-id="3337f-159">Orta<sup>3</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-159">Moderate<sup>3</sup></span></span>|<span data-ttu-id="3337f-160">Bir sorgunun döndürdettiği her nesne için bir kez.</span><span class="sxs-lookup"><span data-stu-id="3337f-160">Once for each object that a query returns.</span></span> <span data-ttu-id="3337f-161"><sup>4</sup></span><span class="sxs-lookup"><span data-stu-id="3337f-161"><sup>4</sup></span></span>|<span data-ttu-id="3337f-162">Döndürülen <xref:System.Data.Common.DbDataReader> nesneyi okuma ve nesneleri oluşturma ve <xref:System.Data.Common.DbDataRecord> sınıfın her örneğindeki değerleri temel alan özellik değerlerini ayarlama işlemi.</span><span class="sxs-lookup"><span data-stu-id="3337f-162">The process of reading the returned <xref:System.Data.Common.DbDataReader> object and creating objects and setting property values that are based on the values in each instance of the <xref:System.Data.Common.DbDataRecord> class.</span></span> <span data-ttu-id="3337f-163">Nesne zaten varsa <xref:System.Data.Objects.ObjectContext> ve sorgu veya <xref:System.Data.Objects.MergeOption.AppendOnly> <xref:System.Data.Objects.MergeOption.PreserveChanges> birleştirme seçeneklerini kullanıyorsa, bu aşama performansı etkilemez.</span><span class="sxs-lookup"><span data-stu-id="3337f-163">If the object already exists in the <xref:System.Data.Objects.ObjectContext> and the query uses the <xref:System.Data.Objects.MergeOption.AppendOnly> or <xref:System.Data.Objects.MergeOption.PreserveChanges> merge options, this stage does not affect performance.</span></span> <span data-ttu-id="3337f-164">Daha fazla bilgi için [bkz: Kimlik Çözümü, Devlet Yönetimi ve Değişiklik İzleme.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-164">For more information, see [Identity Resolution, State Management, and Change Tracking](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896269(v=vs.100)).</span></span>|  
  
 <span data-ttu-id="3337f-165"><sup>1</sup> Bir veri kaynağı sağlayıcısı bağlantı havuzu uyguladığında, bağlantı açma maliyeti havuz adedine dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="3337f-165"><sup>1</sup> When a data source provider implements connection pooling, the cost of opening a connection is distributed across the pool.</span></span> <span data-ttu-id="3337f-166">SQL Server için .NET Sağlayıcısı bağlantı havuzunu destekler.</span><span class="sxs-lookup"><span data-stu-id="3337f-166">The .NET Provider for SQL Server supports connection pooling.</span></span>  
  
 <span data-ttu-id="3337f-167"><sup>2</sup> Artan sorgu karmaşıklığıyla maliyet artar.</span><span class="sxs-lookup"><span data-stu-id="3337f-167"><sup>2</sup> Cost increases with increased query complexity.</span></span>  
  
 <span data-ttu-id="3337f-168"><sup>3</sup> Toplam maliyet, sorgu tarafından döndürülen nesne sayısıyla orantılı olarak artar.</span><span class="sxs-lookup"><span data-stu-id="3337f-168"><sup>3</sup> Total cost increases proportional to the number of objects returned by the query.</span></span>  
  
 <span data-ttu-id="3337f-169"><sup>4</sup> EntityClient sorguları nesneler yerine bir <xref:System.Data.EntityClient.EntityDataReader> döndürüldeğinden, bu genel ek bilgi EntityClient sorguları için gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="3337f-169"><sup>4</sup> This overhead is not required for EntityClient queries because EntityClient queries return an <xref:System.Data.EntityClient.EntityDataReader> instead of objects.</span></span> <span data-ttu-id="3337f-170">Daha fazla bilgi için Entity [Framework için EntityClient Sağlayıcısı'na](entityclient-provider-for-the-entity-framework.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="3337f-170">For more information, see [EntityClient Provider for the Entity Framework](entityclient-provider-for-the-entity-framework.md).</span></span>  
  
## <a name="additional-considerations"></a><span data-ttu-id="3337f-171">Ek Hususlar</span><span class="sxs-lookup"><span data-stu-id="3337f-171">Additional Considerations</span></span>  
 <span data-ttu-id="3337f-172">Aşağıda, Varlık Çerçevesi uygulamalarının performansını etkileyebilecek diğer hususlar yer alınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3337f-172">The following are other considerations that may affect the performance of Entity Framework applications.</span></span>  
  
### <a name="query-execution"></a><span data-ttu-id="3337f-173">Sorgu Yürütme</span><span class="sxs-lookup"><span data-stu-id="3337f-173">Query Execution</span></span>  
 <span data-ttu-id="3337f-174">Sorgular kaynak yoğun olabileceğinden, kodunuzun hangi noktada ve sorgunun hangi bilgisayarda yürütüleceğini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="3337f-174">Because queries can be resource intensive, consider at what point in your code and on what computer a query is executed.</span></span>  
  
#### <a name="deferred-versus-immediate-execution"></a><span data-ttu-id="3337f-175">Ertelenmiş karşı hemen yürütme</span><span class="sxs-lookup"><span data-stu-id="3337f-175">Deferred versus immediate execution</span></span>  
 <span data-ttu-id="3337f-176">Bir <xref:System.Data.Objects.ObjectQuery%601> veya LINQ sorgusu oluşturduğunuzda, sorgu hemen yürütülmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-176">When you create an <xref:System.Data.Objects.ObjectQuery%601> or LINQ query, the query may not be executed immediately.</span></span> <span data-ttu-id="3337f-177">Sorgu yürütmesi, `foreach` (C#) veya (Visual Basic) numaralandırma sırasında veya `For Each` bir <xref:System.Collections.Generic.List%601> koleksiyonu doldurmak için atandığında olduğu gibi sonuçlar gerekli olana kadar ertelenir.</span><span class="sxs-lookup"><span data-stu-id="3337f-177">Query execution is deferred until the results are needed, such as during a `foreach` (C#) or `For Each` (Visual Basic) enumeration or when it is assigned to fill a <xref:System.Collections.Generic.List%601> collection.</span></span> <span data-ttu-id="3337f-178">Sorgu yürütme <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> hemen bir <xref:System.Data.Objects.ObjectQuery%601> yöntem çağırdığınızda veya bir tekton sorgusu döndüren bir <xref:System.Linq.Enumerable.First%2A> <xref:System.Linq.Enumerable.Any%2A>LINQ yöntemi çağırdığınızda başlar, gibi veya .</span><span class="sxs-lookup"><span data-stu-id="3337f-178">Query execution begins immediately when you call the <xref:System.Data.Objects.ObjectQuery%601.Execute%2A> method on an <xref:System.Data.Objects.ObjectQuery%601> or when you call a LINQ method that returns a singleton query, such as <xref:System.Linq.Enumerable.First%2A> or <xref:System.Linq.Enumerable.Any%2A>.</span></span> <span data-ttu-id="3337f-179">Daha fazla bilgi için bkz. [Nesne Sorguları](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) ve [Sorgu Yürütme (LinQ to Varlıklar)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="3337f-179">For more information, see [Object Queries](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896241(v=vs.100)) and [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
#### <a name="client-side-execution-of-linq-queries"></a><span data-ttu-id="3337f-180">LINQ sorgularının istemci tarafı yürütmesi</span><span class="sxs-lookup"><span data-stu-id="3337f-180">Client-side execution of LINQ queries</span></span>  
 <span data-ttu-id="3337f-181">Linq sorgusunun yürütülmesi veri kaynağını barındıran bilgisayarda gerçekleşse de, LINQ sorgusunun bazı bölümleri istemci bilgisayarda değerlendirilebilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-181">Although the execution of a LINQ query occurs on the computer that hosts the data source, some parts of a LINQ query may be evaluated on the client computer.</span></span> <span data-ttu-id="3337f-182">Daha fazla bilgi için Sorgu Yürütmenin Mağaza Yürütme [bölümüne bakın (LINQ to Ntities)](./language-reference/query-execution.md).</span><span class="sxs-lookup"><span data-stu-id="3337f-182">For more information, see the Store Execution section of [Query Execution (LINQ to Entities)](./language-reference/query-execution.md).</span></span>  
  
### <a name="query-and-mapping-complexity"></a><span data-ttu-id="3337f-183">Sorgu ve Eşleme Karmaşıklığı</span><span class="sxs-lookup"><span data-stu-id="3337f-183">Query and Mapping Complexity</span></span>  
 <span data-ttu-id="3337f-184">Tek tek sorguların ve varlık modelindeki eşlemenin karmaşıklığı sorgu performansı üzerinde önemli bir etkiye sahip olacaktır.</span><span class="sxs-lookup"><span data-stu-id="3337f-184">The complexity of individual queries and of the mapping in the entity model will have a significant effect on query performance.</span></span>  
  
#### <a name="mapping-complexity"></a><span data-ttu-id="3337f-185">Harita karmaşıklığı</span><span class="sxs-lookup"><span data-stu-id="3337f-185">Mapping complexity</span></span>  
 <span data-ttu-id="3337f-186">Kavramsal modeldeki varlıklar ve depolama modelindeki tablolar arasındaki basit bire bir eşlemeden daha karmaşık olan modeller, bire bir eşlenebilen modellere göre daha karmaşık komutlar oluşturur.</span><span class="sxs-lookup"><span data-stu-id="3337f-186">Models that are more complex than a simple one-to-one mapping between entities in the conceptual model and tables in the storage model generate more complex commands than models that have a one-to-one mapping.</span></span>  
  
#### <a name="query-complexity"></a><span data-ttu-id="3337f-187">Sorgu karmaşıklığı</span><span class="sxs-lookup"><span data-stu-id="3337f-187">Query complexity</span></span>  
 <span data-ttu-id="3337f-188">Veri kaynağına karşı yürütülen komutlarda çok sayıda birleştirme gerektiren veya büyük miktarda veri döndüren sorgular performansı aşağıdaki şekillerde etkileyebilir:</span><span class="sxs-lookup"><span data-stu-id="3337f-188">Queries that require a large number of joins in the commands that are executed against the data source or that return a large amount of data may affect performance in the following ways:</span></span>  
  
- <span data-ttu-id="3337f-189">Basit görünen kavramsal bir modele karşı sorgular, veri kaynağına karşı daha karmaşık sorguların yürütülmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-189">Queries against a conceptual model that seem simple may result in the execution of more complex queries against the data source.</span></span> <span data-ttu-id="3337f-190">Varlık Çerçevesi, kavramsal bir modele karşı bir sorguyu veri kaynağına karşı eşdeğer bir sorguya çevirdiği için bu durum oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-190">This can occur because the Entity Framework translates a query against a conceptual model into an equivalent query against the data source.</span></span> <span data-ttu-id="3337f-191">Kavramsal modelde tek bir varlık, veri kaynağında birden fazla tabloyla eşlendiğinde veya varlıklar arasındaki ilişki bir birleştirme tablosuna eşlendiğinde, veri kaynağı sorgusuna karşı yürütülen sorgu komutu bir veya daha fazla birleştirme gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-191">When a single entity set in the conceptual model maps to more than one table in the data source, or when a relationship between entities is mapped to a join table, the query command executed against the data source query may require one or more joins.</span></span>  
  
    > [!NOTE]
    > <span data-ttu-id="3337f-192">Belirli <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> bir sorgu <xref:System.Data.Objects.ObjectQuery%601> <xref:System.Data.EntityClient.EntityCommand> için veri kaynağına karşı yürütülen komutları görüntülemek için veya sınıfların yöntemini kullanın.</span><span class="sxs-lookup"><span data-stu-id="3337f-192">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method of the <xref:System.Data.Objects.ObjectQuery%601> or <xref:System.Data.EntityClient.EntityCommand> classes to view the commands that are executed against the data source for a given query.</span></span> <span data-ttu-id="3337f-193">Daha fazla bilgi için [bkz: Mağaza Komutlarını görüntüleyin.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-193">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
- <span data-ttu-id="3337f-194">İç içe varlık SQL sorguları sunucuda birleştirmeler oluşturabilir ve çok sayıda satır döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-194">Nested Entity SQL queries may create joins on the server and can return a large number of rows.</span></span>  
  
     <span data-ttu-id="3337f-195">Aşağıdaki, projeksiyon yan tümcesindeki iç içe bir sorgu örneğiverilmiştir:</span><span class="sxs-lookup"><span data-stu-id="3337f-195">The following is an example of a nested query in a projection clause:</span></span>  
  
    ```sql  
    SELECT c, (SELECT c, (SELECT c FROM AdventureWorksModel.Vendor AS c  ) As Inner2
        FROM AdventureWorksModel.JobCandidate AS c  ) As Inner1
        FROM AdventureWorksModel.EmployeeDepartmentHistory AS c  
    ```  
  
     <span data-ttu-id="3337f-196">Ayrıca, bu tür sorgular sorgu ardışık bir iç içe sorgular arasında nesnelerin çoğaltılması ile tek bir sorgu oluşturmak için neden olur.</span><span class="sxs-lookup"><span data-stu-id="3337f-196">In addition, such queries cause the query pipeline to generate a single query with duplication of objects across nested queries.</span></span> <span data-ttu-id="3337f-197">Bu nedenle, tek bir sütun birden çok kez çoğaltılabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-197">Because of this, a single column may be duplicated multiple times.</span></span> <span data-ttu-id="3337f-198">SQL Server da dahil olmak üzere bazı veritabanlarında, bu, TempDB tablosunun çok büyük büyümesine neden olabilir ve bu da sunucu performansını düşürebilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-198">On some databases, including SQL Server, this can cause the TempDB table to grow very large, which can decrease server performance.</span></span> <span data-ttu-id="3337f-199">İç içe sorguları çalıştırdığınızda dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3337f-199">Care should be taken when you execute nested queries.</span></span>  
  
- <span data-ttu-id="3337f-200">Büyük miktarda veri döndüren sorgular, istemci kaynak tüketen işlemleri sonuç kümesinin boyutuyla orantılı bir şekilde gerçekleştiriyorsa performansın düşmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-200">Any queries that return a large amount of data can cause decreased performance if the client is performing operations that consume resources in a way that is proportional to the size of the result set.</span></span> <span data-ttu-id="3337f-201">Bu gibi durumlarda, sorgu tarafından döndürülen veri miktarını sınırlamayı düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-201">In such cases, you should consider limiting the amount of data returned by the query.</span></span> <span data-ttu-id="3337f-202">Daha fazla bilgi için [bkz: Sorgu Sonuçları Aracılığıyla Sayfa](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="3337f-202">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3337f-203">Varlık Çerçevesi tarafından otomatik olarak oluşturulan komutlar, bir veritabanı geliştiricisi tarafından açıkça yazılmış benzer komutlardan daha karmaşık olabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-203">Any commands automatically generated by the Entity Framework may be more complex than similar commands written explicitly by a database developer.</span></span> <span data-ttu-id="3337f-204">Veri kaynağınıza karşı yürütülen komutlar üzerinde açık denetime ihtiyacınız varsa, tablo değerindeki bir işleve veya depolanan yordama eşleme tanımlamayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="3337f-204">If you need explicit control over the commands executed against your data source, consider defining a mapping to a table-valued function or stored procedure.</span></span>  
  
#### <a name="relationships"></a><span data-ttu-id="3337f-205">İlişkiler</span><span class="sxs-lookup"><span data-stu-id="3337f-205">Relationships</span></span>  
 <span data-ttu-id="3337f-206">En iyi sorgu performansı için, varlıklar arasındaki ilişkileri hem varlık modelinde ilişkilendirmeler hem de veri kaynağındaki mantıksal ilişkiler olarak tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3337f-206">For optimal query performance, you must define relationships between entities both as associations in the entity model and as logical relationships in the data source.</span></span>  
  
### <a name="query-paths"></a><span data-ttu-id="3337f-207">Sorgu Yolları</span><span class="sxs-lookup"><span data-stu-id="3337f-207">Query Paths</span></span>  
 <span data-ttu-id="3337f-208">Varsayılan olarak, bir <xref:System.Data.Objects.ObjectQuery%601>, ilgili nesneleri yürüttettiğinizde döndürülmez (ilişkileri temsil eden nesneler olsa da).</span><span class="sxs-lookup"><span data-stu-id="3337f-208">By default, when you execute an <xref:System.Data.Objects.ObjectQuery%601>, related objects are not returned (although objects that represent the relationships themselves are).</span></span> <span data-ttu-id="3337f-209">İlgili nesneleri üç şekilde yükleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="3337f-209">You can load related objects in one of three ways:</span></span>  
  
1. <span data-ttu-id="3337f-210">Yürütülmeden önce <xref:System.Data.Objects.ObjectQuery%601> sorgu yolunu ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="3337f-210">Set the query path before the <xref:System.Data.Objects.ObjectQuery%601> is executed.</span></span>  
  
2. <span data-ttu-id="3337f-211">Nesnenin `Load` maruz karadığı gezinti özelliğindeki yöntemi arayın.</span><span class="sxs-lookup"><span data-stu-id="3337f-211">Call the `Load` method on the navigation property that the object exposes.</span></span>  
  
3. <span data-ttu-id="3337f-212"><xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> Seçeneğini şu şekilde <xref:System.Data.Objects.ObjectContext> `true`ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="3337f-212">Set the <xref:System.Data.Objects.ObjectContextOptions.LazyLoadingEnabled%2A> option on the <xref:System.Data.Objects.ObjectContext> to `true`.</span></span> <span data-ttu-id="3337f-213">[Varlık Veri Modeli Tasarımcısı](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100))ile nesne katmanı kodu oluşturduğunuzda bunun otomatik olarak yapıldığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="3337f-213">Note that this is done automatically when you generate object-layer code with the [Entity Data Model Designer](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc716685(v=vs.100)).</span></span> <span data-ttu-id="3337f-214">Daha fazla bilgi için [oluşturulan koda genel bakış](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100))ala.</span><span class="sxs-lookup"><span data-stu-id="3337f-214">For more information see [Generated Code Overview](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/cc982041(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3337f-215">Hangi seçeneği kullanacağınızı düşündüğünüzde, veritabanına karşı istek sayısı ile tek bir sorguda döndürülen veri miktarı arasında bir denge olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="3337f-215">When you consider which option to use, be aware that there is a tradeoff between the number of requests against the database and the amount of data returned in a single query.</span></span> <span data-ttu-id="3337f-216">Daha fazla bilgi için Bkz. [İlgili Nesneleri Yükleme.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-216">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
#### <a name="using-query-paths"></a><span data-ttu-id="3337f-217">Sorgu yollarını kullanma</span><span class="sxs-lookup"><span data-stu-id="3337f-217">Using query paths</span></span>  
 <span data-ttu-id="3337f-218">Sorgu yolları, sorgunun döndürdettiği nesnelerin grafiğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="3337f-218">Query paths define the graph of objects that a query returns.</span></span> <span data-ttu-id="3337f-219">Bir sorgu yolu tanımladığınızda, yolun tanımladığı tüm nesneleri döndürmek için veritabanına karşı yalnızca tek bir istek gerekir.</span><span class="sxs-lookup"><span data-stu-id="3337f-219">When you define a query path, only a single request against the database is required to return all objects that the path defines.</span></span> <span data-ttu-id="3337f-220">Sorgu yollarının kullanılması, basit görünen nesne sorgularından veri kaynağına karşı yürütülen karmaşık komutlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-220">Using query paths can result in complex commands being executed against the data source from seemingly simple object queries.</span></span> <span data-ttu-id="3337f-221">Bir veya daha fazla birleştirmenin tek bir sorguda ilgili nesneleri döndürmek için gerekli olması nedeniyle bu oluşur.</span><span class="sxs-lookup"><span data-stu-id="3337f-221">This occurs because one or more joins are required to return related objects in a single query.</span></span> <span data-ttu-id="3337f-222">Bu karmaşıklık, kalıtımlı bir varlık veya çok-çok ilişkileri içeren bir yol gibi karmaşık bir varlık modeline karşı sorgularda daha büyüktür.</span><span class="sxs-lookup"><span data-stu-id="3337f-222">This complexity is greater in queries against a complex entity model, such as an entity with inheritance or a path that includes many-to-many relationships.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3337f-223">Bir <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> <xref:System.Data.Objects.ObjectQuery%601>. tarafından oluşturulacak komutu görmek için yöntemi kullanın</span><span class="sxs-lookup"><span data-stu-id="3337f-223">Use the <xref:System.Data.Objects.ObjectQuery.ToTraceString%2A> method to see the command that will be generated by an <xref:System.Data.Objects.ObjectQuery%601>.</span></span> <span data-ttu-id="3337f-224">Daha fazla bilgi için [bkz: Mağaza Komutlarını görüntüleyin.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-224">For more information, see [How to: View the Store Commands](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896348(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3337f-225">Bir sorgu yolu çok fazla ilgili nesne içeriyorsa veya nesneler çok fazla satır verisi içeriyorsa, veri kaynağı sorguyu tamamlayamayabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-225">When a query path includes too many related objects or the objects contain too much row data, the data source might be unable to complete the query.</span></span> <span data-ttu-id="3337f-226">Bu, sorgu veri kaynağının yeteneklerini aşan ara geçici depolama gerektiriyorsa oluşur.</span><span class="sxs-lookup"><span data-stu-id="3337f-226">This occurs if the query requires intermediate temporary storage that exceeds the capabilities of the data source.</span></span> <span data-ttu-id="3337f-227">Bu durumda, ilgili nesneleri açıkça yükleyerek veri kaynağı sorgusunun karmaşıklığını azaltabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-227">When this occurs, you can reduce the complexity of the data source query by explicitly loading related objects.</span></span>  
  
#### <a name="explicitly-loading-related-objects"></a><span data-ttu-id="3337f-228">İlgili nesneleri açıkça yükleme</span><span class="sxs-lookup"><span data-stu-id="3337f-228">Explicitly loading related objects</span></span>  
 <span data-ttu-id="3337f-229">Bir <xref:System.Data.Objects.DataClasses.EntityCollection%601> veya <xref:System.Data.Objects.DataClasses.EntityReference%601>. döndüren bir `Load` gezinti özelliği üzerinde yöntemi çağırarak ilgili nesneleri açıkça yükleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-229">You can explicitly load related objects by calling the `Load` method on a navigation property that returns an <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601>.</span></span> <span data-ttu-id="3337f-230">Nesnelerin açıkça yüklenmesi, her çağrıldığında `Load` veritabanına gidiş-dönüş gerektirir.</span><span class="sxs-lookup"><span data-stu-id="3337f-230">Explicitly loading objects requires a round-trip to the database every time `Load` is called.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3337f-231">deyimi kullandığınızda (Visual Basic'te) `Load` `For Each` döndürülen nesneler topluluğu üzerinden döngü oluştururken ararsanız, veri kaynağına özgü sağlayıcının tek bir bağlantıda birden çok etkin sonuç kümesini desteklemesi gerekir. `foreach`</span><span class="sxs-lookup"><span data-stu-id="3337f-231">if you call `Load` while looping through a collection of returned objects, such as when you use the `foreach` statement (`For Each` in Visual Basic), the data source-specific provider must support multiple active results sets on a single connection.</span></span> <span data-ttu-id="3337f-232">BIR SQL Server veritabanı için sağlayıcı `MultipleActiveResultSets = true` bağlantı dizesinde bir değer belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="3337f-232">For a SQL Server database, you must specify a value of `MultipleActiveResultSets = true` in the provider connection string.</span></span>  
  
 <span data-ttu-id="3337f-233">Varlıklar da yoksa <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> <xref:System.Data.Objects.DataClasses.EntityCollection%601> özellik <xref:System.Data.Objects.DataClasses.EntityReference%601> olmadığında da yöntemi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-233">You can also use the <xref:System.Data.Objects.ObjectContext.LoadProperty%2A> method when there is no <xref:System.Data.Objects.DataClasses.EntityCollection%601> or <xref:System.Data.Objects.DataClasses.EntityReference%601> properties on entities.</span></span> <span data-ttu-id="3337f-234">Bu, POCO varlıklarını kullanırken kullanışlıdır.</span><span class="sxs-lookup"><span data-stu-id="3337f-234">This is useful when you are using POCO entities.</span></span>  
  
 <span data-ttu-id="3337f-235">İlgili nesnelerin açıkça yüklenmesi birleştirme sayısını azaltacak ve gereksiz veri miktarını azaltsa da, `Load` veritabanına yinelenen bağlantılar gerektirir ve bu da çok sayıda nesneyi açıkça yüklerken maliyetli olabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-235">Although explicitly loading related objects will reduce the number of joins and reduced the amount of redundant data, `Load` requires repeated connections to the database, which can become costly when explicitly loading a large number of objects.</span></span>  
  
### <a name="saving-changes"></a><span data-ttu-id="3337f-236">Değişiklikleri Kaydetme</span><span class="sxs-lookup"><span data-stu-id="3337f-236">Saving Changes</span></span>  
 <span data-ttu-id="3337f-237">Bir , <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> bağlam içinde <xref:System.Data.Objects.ObjectContext>eklenen, güncelleştirilen veya silinen her nesne için ayrı bir oluşturma, güncelleştirme veya silme komutu üzerinde yöntem çağırdığınızda.</span><span class="sxs-lookup"><span data-stu-id="3337f-237">When you call the <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> method on an <xref:System.Data.Objects.ObjectContext>, a separate create, update, or delete command is generated for every added, updated, or deleted object in the context.</span></span> <span data-ttu-id="3337f-238">Bu komutlar tek bir işlemde veri kaynağında yürütülür.</span><span class="sxs-lookup"><span data-stu-id="3337f-238">These commands are executed on the data source in a single transaction.</span></span> <span data-ttu-id="3337f-239">Sorgularda olduğu gibi, oluşturma, güncelleştirme ve silme işlemlerinin performansı, kavramsal modeldeki eşlemenin karmaşıklığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="3337f-239">As with queries, the performance of create, update, and delete operations depends on the complexity of the mapping in the conceptual model.</span></span>  
  
### <a name="distributed-transactions"></a><span data-ttu-id="3337f-240">Dağıtılmış İşlemler</span><span class="sxs-lookup"><span data-stu-id="3337f-240">Distributed Transactions</span></span>  
 <span data-ttu-id="3337f-241">Dağıtılmış hareket koordinatörü (DTC) tarafından yönetilen kaynakları gerektiren açık bir işlemdeki işlemler, DTC gerektirmeyen benzer bir işlemden çok daha pahalı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="3337f-241">Operations in an explicit transaction that require resources that are managed by the distributed transaction coordinator (DTC) will be much more expensive than a similar operation that does not require the DTC.</span></span> <span data-ttu-id="3337f-242">DTC'ye terfi aşağıdaki durumlarda gerçekleşecektir:</span><span class="sxs-lookup"><span data-stu-id="3337f-242">Promotion to the DTC will occur in the following situations:</span></span>  
  
- <span data-ttu-id="3337f-243">Bir SQL Server 2000 veritabanına veya DTC'ye müstehcen hareketleri her zaman tanıtan başka bir veri kaynağına karşı yapılan bir işlemle yapılan açık bir işlem.</span><span class="sxs-lookup"><span data-stu-id="3337f-243">An explicit transaction with an operation against a SQL Server 2000 database or other data source that always promote explicit transactions to the DTC.</span></span>  
  
- <span data-ttu-id="3337f-244">Bağlantı Entity Framework tarafından yönetildiğinde SQL Server 2005'e karşı yapılan bir işlemle açık bir işlem.</span><span class="sxs-lookup"><span data-stu-id="3337f-244">An explicit transaction with an operation against SQL Server 2005 when the connection is managed by the Entity Framework.</span></span> <span data-ttu-id="3337f-245">Bunun nedeni, SQL Server 2005'in, varlık çerçevesinin varsayılan davranışı olan tek bir işlem içinde bir bağlantı kapatıldığında ve yeniden açıldığında DTC'ye terfi etmesidir.</span><span class="sxs-lookup"><span data-stu-id="3337f-245">This occurs because SQL Server 2005 promotes to a DTC whenever a connection is closed and reopened within a single transaction, which is the default behavior of the Entity Framework.</span></span> <span data-ttu-id="3337f-246">Bu DTC promosyonu SQL Server 2008 kullanırken gerçekleşmez.</span><span class="sxs-lookup"><span data-stu-id="3337f-246">This DTC promotion does not occur when using SQL Server 2008.</span></span> <span data-ttu-id="3337f-247">SQL Server 2005'i kullanırken bu promosyonu önlemek için işlem içindeki bağlantıyı açıkça açmanız ve kapatmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3337f-247">To avoid this promotion when using SQL Server 2005, you must explicitly open and close the connection within the transaction.</span></span> <span data-ttu-id="3337f-248">Daha fazla bilgi için [bkz.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-248">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3337f-249">Bir işlem içinde bir veya daha fazla <xref:System.Transactions> işlem yürütüldüğünde açık bir işlem kullanılır.</span><span class="sxs-lookup"><span data-stu-id="3337f-249">An explicit transaction is used when one or more operations are executed inside a <xref:System.Transactions> transaction.</span></span> <span data-ttu-id="3337f-250">Daha fazla bilgi için [bkz.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-250">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="strategies-for-improving-performance"></a><span data-ttu-id="3337f-251">Performansı Artırma Stratejileri</span><span class="sxs-lookup"><span data-stu-id="3337f-251">Strategies for Improving Performance</span></span>  
 <span data-ttu-id="3337f-252">Aşağıdaki stratejileri kullanarak Varlık Çerçevesi'ndeki sorguların genel performansını artırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-252">You can improve the overall performance of queries in the Entity Framework by using the following strategies.</span></span>  
  
#### <a name="pre-generate-views"></a><span data-ttu-id="3337f-253">Önceden oluşturma görünümleri</span><span class="sxs-lookup"><span data-stu-id="3337f-253">Pre-generate views</span></span>  
 <span data-ttu-id="3337f-254">Bir varlık modeline dayalı görünüm oluşturma, bir uygulamanın bir sorguyu ilk kez yürütmesi önemli bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="3337f-254">Generating views based on an entity model is a significant cost the first time that an application executes a query.</span></span> <span data-ttu-id="3337f-255">Tasarım sırasında projeye eklenebilecek görsel temel veya C# kodu dosyası olarak görünümleri önceden oluşturmak için EdmGen.exe yardımcı programını kullanın.</span><span class="sxs-lookup"><span data-stu-id="3337f-255">Use the EdmGen.exe utility to pre-generate views as a Visual Basic or C# code file that can be added to the project during design.</span></span> <span data-ttu-id="3337f-256">Önceden derlenmiş görünümler oluşturmak için Metin Şablonu Dönüştürme Araç Kiti'ni de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3337f-256">You could also use the Text Template Transformation Toolkit to generate pre-compiled views.</span></span> <span data-ttu-id="3337f-257">Önceden oluşturulan görünümler, belirtilen varlık modelinin geçerli sürümüyle tutarlı olduğundan emin olmak için çalışma zamanında doğrulanır.</span><span class="sxs-lookup"><span data-stu-id="3337f-257">Pre-generated views are validated at runtime to ensure that they are consistent with the current version of the specified entity model.</span></span> <span data-ttu-id="3337f-258">Daha fazla bilgi için [bkz: Sorgu Performansını Artırmak için Görünümleri Önceden Oluştur.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-258">For more information, see [How to: Pre-Generate Views to Improve Query Performance](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896240(v=vs.100)).</span></span>
  
 <span data-ttu-id="3337f-259">Çok büyük modellerle çalışırken aşağıdaki hususlar geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="3337f-259">When working with very large models, the following consideration applies:</span></span>  
  
 <span data-ttu-id="3337f-260">.NET meta veri biçimi, belirli bir ikilideki kullanıcı dize karakter sayısını 16.777.215 (0xFFFFFF) ile sınırlar.</span><span class="sxs-lookup"><span data-stu-id="3337f-260">The .NET metadata format limits the number of user string characters in a given binary to 16,777,215 (0xFFFFFF).</span></span> <span data-ttu-id="3337f-261">Çok büyük bir model için görünüm ler oluşturuyorsanız ve görünüm dosyası bu boyut sınırına ulaşıyorsa, "Daha fazla kullanıcı dizeleri oluşturmak için mantıksal alan kalmaz."</span><span class="sxs-lookup"><span data-stu-id="3337f-261">If you are generating views for a very large model and the view file reaches this size limit, you will get the "No logical space left to create more user strings."</span></span> <span data-ttu-id="3337f-262">hata derlemek.</span><span class="sxs-lookup"><span data-stu-id="3337f-262">compile error.</span></span> <span data-ttu-id="3337f-263">Bu boyut sınırlaması tüm yönetilen ikililer için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="3337f-263">This size limitation applies to all managed binaries.</span></span> <span data-ttu-id="3337f-264">Daha fazla bilgi için, büyük ve karmaşık modellerle çalışırken hatadan nasıl kaçınılanın gösteriş yapan [bloga](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) bakın.</span><span class="sxs-lookup"><span data-stu-id="3337f-264">For more information see the [blog](https://docs.microsoft.com/archive/blogs/appfabriccat/solving-the-no-logical-space-left-to-create-more-user-strings-error-and-improving-performance-of-pre-generated-views-in-visual-studio-net4-entity-framework) that demonstrates how to avoid the error when working with large and complex models.</span></span>  
  
#### <a name="consider-using-the-notracking-merge-option-for-queries"></a><span data-ttu-id="3337f-265">Sorgular için NoTracking birleştirme seçeneğini kullanmayı düşünün</span><span class="sxs-lookup"><span data-stu-id="3337f-265">Consider using the NoTracking merge option for queries</span></span>  
 <span data-ttu-id="3337f-266">Nesne bağlamında döndürülen nesneleri izlemek için gereken bir maliyet vardır.</span><span class="sxs-lookup"><span data-stu-id="3337f-266">There is a cost required to track returned objects in the object context.</span></span> <span data-ttu-id="3337f-267">Nesnelerdeki değişiklikleri algılamak ve aynı mantıksal varlık için birden çok isteğin aynı nesne örneğini döndürmesini sağlamak, nesnelerin bir <xref:System.Data.Objects.ObjectContext> örne eklenmesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="3337f-267">Detecting changes to objects and ensuring that multiple requests for the same logical entity return the same object instance requires that objects be attached to an <xref:System.Data.Objects.ObjectContext> instance.</span></span> <span data-ttu-id="3337f-268">Nesnelere güncelleştirmeler veya silmeler yapmayı planlamıyorsanız ve kimlik yönetimi <xref:System.Data.Objects.MergeOption.NoTracking> gerektirmiyorsa, sorguları yürütürken birleştirme seçeneklerini kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="3337f-268">If you do not plan to make updates or deletes to objects and do not require identity management, consider using the <xref:System.Data.Objects.MergeOption.NoTracking> merge options when you execute queries.</span></span>  
  
#### <a name="return-the-correct-amount-of-data"></a><span data-ttu-id="3337f-269">Doğru veri miktarını döndürme</span><span class="sxs-lookup"><span data-stu-id="3337f-269">Return the correct amount of data</span></span>  
 <span data-ttu-id="3337f-270">Bazı senaryolarda, <xref:System.Data.Objects.ObjectQuery%601.Include%2A> yöntemi kullanarak bir sorgu yolu belirtmek çok daha hızlıdır, çünkü veritabanına daha az gidiş dönüş gerektirir.</span><span class="sxs-lookup"><span data-stu-id="3337f-270">In some scenarios, specifying a query path using the <xref:System.Data.Objects.ObjectQuery%601.Include%2A> method is much faster because it requires fewer round trips to the database.</span></span> <span data-ttu-id="3337f-271">Ancak, diğer senaryolarda, ilgili nesneleri yüklemek için veritabanına ek gidiş-dönüş gezileri daha hızlı olabilir, çünkü daha az birleşimiçeren basit sorgular daha az veri artıklığıyla sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="3337f-271">However, in other scenarios, additional round trips to the database to load related objects may be faster because the simpler queries with fewer joins result in less redundancy of data.</span></span> <span data-ttu-id="3337f-272">Bu nedenle, ilgili nesneleri almak için çeşitli yolların performansını test öneririz.</span><span class="sxs-lookup"><span data-stu-id="3337f-272">Because of this, we recommend that you test the performance of various ways to retrieve related objects.</span></span> <span data-ttu-id="3337f-273">Daha fazla bilgi için Bkz. [İlgili Nesneleri Yükleme.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-273">For more information, see [Loading Related Objects](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896272(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3337f-274">Tek bir sorguda çok fazla veri döndürmeyi önlemek için, sorgunun sonuçlarını daha yönetilebilir gruplara ayırmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="3337f-274">To avoid returning too much data in a single query, consider paging the results of the query into more manageable groups.</span></span> <span data-ttu-id="3337f-275">Daha fazla bilgi için [bkz: Sorgu Sonuçları Aracılığıyla Sayfa](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="3337f-275">For more information, see [How to: Page Through Query Results](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb738702(v=vs.100)).</span></span>  
  
#### <a name="limit-the-scope-of-the-objectcontext"></a><span data-ttu-id="3337f-276">Nesne Bağlamının kapsamını sınırlandırın</span><span class="sxs-lookup"><span data-stu-id="3337f-276">Limit the scope of the ObjectContext</span></span>  
 <span data-ttu-id="3337f-277">Çoğu durumda, bir deyim <xref:System.Data.Objects.ObjectContext> içinde `using` (Visual`Using…End Using` Basic' de) bir örnek oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3337f-277">In most cases, you should create an <xref:System.Data.Objects.ObjectContext> instance within a `using` statement (`Using…End Using` in Visual Basic).</span></span> <span data-ttu-id="3337f-278">Bu, kod ekstre bloğundan çıktığında nesne bağlamıyla ilişkili kaynakların otomatik olarak elden çıkarılmasını sağlayarak performansı artırabilir.</span><span class="sxs-lookup"><span data-stu-id="3337f-278">This can increase performance by ensuring that the resources associated with the object context are disposed automatically when the code exits the statement block.</span></span> <span data-ttu-id="3337f-279">Ancak, denetimler nesne bağlamı tarafından yönetilen nesnelere bağlandığında, <xref:System.Data.Objects.ObjectContext> bağlama gerekli olduğu sürece örnek tutulmalıdır ve el ile imha.</span><span class="sxs-lookup"><span data-stu-id="3337f-279">However, when controls are bound to objects managed by the object context, the <xref:System.Data.Objects.ObjectContext> instance should be maintained as long as the binding is needed and disposed of manually.</span></span> <span data-ttu-id="3337f-280">Daha fazla bilgi için [bkz.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-280">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
#### <a name="consider-opening-the-database-connection-manually"></a><span data-ttu-id="3337f-281">Veritabanı bağlantısını el ile açmayı düşünün</span><span class="sxs-lookup"><span data-stu-id="3337f-281">Consider opening the database connection manually</span></span>  
 <span data-ttu-id="3337f-282">Uygulamanız oluşturma, güncelleştirme ve veri kaynağına <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> işlemleri silmek için bir dizi nesne sorgusu veya sık sık çağrıda bulunduğunda, Varlık Çerçevesi'nin veri kaynağına olan bağlantıyı sürekli olarak açması ve kapatması gerekir.</span><span class="sxs-lookup"><span data-stu-id="3337f-282">When your application executes a series of object queries or frequently calls <xref:System.Data.Objects.ObjectContext.SaveChanges%2A> to persist create, update, and delete operations to the data source, the Entity Framework must continuously open and close the connection to the data source.</span></span> <span data-ttu-id="3337f-283">Bu gibi durumlarda, bu işlemlerin başlangıcında bağlantıyı el ile açmayı ve işlemler tamamlandığında bağlantıyı kapatmayı veya atmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="3337f-283">In these situations, consider manually opening the connection at the start of these operations and either closing or disposing of the connection when the operations are complete.</span></span> <span data-ttu-id="3337f-284">Daha fazla bilgi için [bkz.](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="3337f-284">For more information, see [Managing Connections and Transactions](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/bb896325(v=vs.100)).</span></span>  
  
## <a name="performance-data"></a><span data-ttu-id="3337f-285">Performans Verileri</span><span class="sxs-lookup"><span data-stu-id="3337f-285">Performance Data</span></span>  
 <span data-ttu-id="3337f-286">Varlık Çerçevesi için bazı performans verileri [ADO.NET takım blogunda](https://docs.microsoft.com/archive/blogs/adonet/)aşağıdaki gönderilerde yayınlanır:</span><span class="sxs-lookup"><span data-stu-id="3337f-286">Some performance data for the Entity Framework is published in the following posts on the [ADO.NET team blog](https://docs.microsoft.com/archive/blogs/adonet/):</span></span>  
  
- [<span data-ttu-id="3337f-287">ADO.NET Varlık Çerçevesinin Performansını Keşfetmek - Bölüm 1</span><span class="sxs-lookup"><span data-stu-id="3337f-287">Exploring the Performance of the ADO.NET Entity Framework - Part 1</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-1)  
  
- [<span data-ttu-id="3337f-288">ADO.NET Varlık Çerçevesinin Performansını Keşfetmek – Bölüm 2</span><span class="sxs-lookup"><span data-stu-id="3337f-288">Exploring the Performance of the ADO.NET Entity Framework – Part 2</span></span>](https://docs.microsoft.com/archive/blogs/adonet/exploring-the-performance-of-the-ado-net-entity-framework-part-2)  
  
- [<span data-ttu-id="3337f-289">ADO.NET Varlık Çerçeve Performans Karşılaştırması</span><span class="sxs-lookup"><span data-stu-id="3337f-289">ADO.NET Entity Framework Performance Comparison</span></span>](https://docs.microsoft.com/archive/blogs/adonet/ado-net-entity-framework-performance-comparison)  
  
## <a name="see-also"></a><span data-ttu-id="3337f-290">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="3337f-290">See also</span></span>

- [<span data-ttu-id="3337f-291">Geliştirme ve Dağıtım Konuları</span><span class="sxs-lookup"><span data-stu-id="3337f-291">Development and Deployment Considerations</span></span>](development-and-deployment-considerations.md)
