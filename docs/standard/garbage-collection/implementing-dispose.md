---
title: Dispose metodu uygulama
description: Bu makalede, .NET 'teki kodunuzun kullandığı yönetilmeyen kaynakları serbest bırakarak Dispose yöntemini uygulamayı öğrenin.
ms.date: 05/27/2020
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: c8b4b9a79577776bc049ef77e222d63374178708
ms.sourcegitcommit: b16c00371ea06398859ecd157defc81301c9070f
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/05/2020
ms.locfileid: "84447179"
---
# <a name="implement-a-dispose-method"></a><span data-ttu-id="df52e-103">Dispose metodu uygulama</span><span class="sxs-lookup"><span data-stu-id="df52e-103">Implement a Dispose method</span></span>

<span data-ttu-id="df52e-104">Yöntemi uygulamak, <xref:System.IDisposable.Dispose%2A> birincil olarak kodunuzun kullandığı yönetilmeyen kaynakları serbest bırakmakta olur.</span><span class="sxs-lookup"><span data-stu-id="df52e-104">Implementing the <xref:System.IDisposable.Dispose%2A> method is primarily for releasing unmanaged resources used by your code.</span></span> <span data-ttu-id="df52e-105">Uygulamalar olan örnek üyeleriyle çalışırken <xref:System.IDisposable> , basamaklı <xref:System.IDisposable.Dispose%2A> çağrılar yaygındır.</span><span class="sxs-lookup"><span data-stu-id="df52e-105">When working with instance members that are <xref:System.IDisposable> implementations, it's common to cascade <xref:System.IDisposable.Dispose%2A> calls.</span></span> <span data-ttu-id="df52e-106"><xref:System.IDisposable.Dispose%2A>Daha önce yapılan bir şeyi geri alma gibi, uygulama için başka nedenler de vardır.</span><span class="sxs-lookup"><span data-stu-id="df52e-106">There are additional reasons for implementing <xref:System.IDisposable.Dispose%2A>, such as undoing something that was previously done.</span></span> <span data-ttu-id="df52e-107">Örneğin, ayrılan belleği serbest bırakma, eklenen bir koleksiyondan öğe kaldırma, alınmış bir kilidin bulunduğu bir kilidi sinyal verme ve benzeri.</span><span class="sxs-lookup"><span data-stu-id="df52e-107">For example, freeing memory that was allocated, removing an item from a collection that was added, signaling the release of a lock that was acquired, and so on.</span></span>

<span data-ttu-id="df52e-108">[.Net atık toplayıcısı](index.md) , yönetilmeyen bellek ayırır veya serbest bırakmaz.</span><span class="sxs-lookup"><span data-stu-id="df52e-108">The [.NET garbage collector](index.md) does not allocate or release unmanaged memory.</span></span> <span data-ttu-id="df52e-109">Dispose düzeni olarak adlandırılan bir nesneyi elden atma düzeni, bir nesnenin kullanım ömrüne göre sıra uygular.</span><span class="sxs-lookup"><span data-stu-id="df52e-109">The pattern for disposing an object, referred to as the dispose pattern, imposes order on the lifetime of an object.</span></span> <span data-ttu-id="df52e-110">Dispose deseninin, arabirimi uygulayan nesneler için kullanılır <xref:System.IDisposable> ve dosya ve kanal tutamaçları, kayıt defteri tutamaçları, bekleme tutamaçları veya yönetilmeyen bellek bloklarına yönelik işaretçilerle etkileşim kurarken yaygındır.</span><span class="sxs-lookup"><span data-stu-id="df52e-110">The dispose pattern is used for objects that implement the <xref:System.IDisposable> interface, and is common when interacting with file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="df52e-111">Bunun nedeni, çöp toplayıcının yönetilmeyen nesneleri geri kazanmamadır.</span><span class="sxs-lookup"><span data-stu-id="df52e-111">This is because the garbage collector is unable to reclaim unmanaged objects.</span></span>

<span data-ttu-id="df52e-112">Kaynakların her zaman uygun şekilde temizlendiğinden emin olmak için bir <xref:System.IDisposable.Dispose%2A> Yöntem, özel durum oluşturmadan birden çok kez çağrılabilir şekilde ıdempotent olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="df52e-112">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be idempotent, such that it is callable multiple times without throwing an exception.</span></span> <span data-ttu-id="df52e-113">Ayrıca, sonraki çağırmaları <xref:System.IDisposable.Dispose%2A> hiçbir şey yapmaz.</span><span class="sxs-lookup"><span data-stu-id="df52e-113">Furthermore, subsequent invocations of <xref:System.IDisposable.Dispose%2A> should do nothing.</span></span>

<span data-ttu-id="df52e-114">Yöntemi için belirtilen kod örneği, <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> çöp toplamanın bir sonlandırıcının çalışmasına nasıl neden olabileceği, nesneye veya üyelerine yönetilmeyen bir başvuru hala kullanımda olduğunda gösterir.</span><span class="sxs-lookup"><span data-stu-id="df52e-114">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how garbage collection can cause a finalizer to run, while an unmanaged reference to the object or its members is still in use.</span></span> <span data-ttu-id="df52e-115"><xref:System.GC.KeepAlive%2A?displayProperty=nameWithType>Nesneyi, geçerli yordamın başından bu yöntemin çağrıldığı noktaya kadar çöp toplama için uygun hale getirmek için kullanılması anlamlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="df52e-115">It may make sense to utilize <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> to make the object ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span>

## <a name="safe-handles"></a><span data-ttu-id="df52e-116">Güvenli işleyiciler</span><span class="sxs-lookup"><span data-stu-id="df52e-116">Safe handles</span></span>

<span data-ttu-id="df52e-117">Bir nesnenin sonlandırıcısı için kod yazmak, doğru yapılmaması durumunda sorunlara neden olabilecek karmaşık bir görevdir.</span><span class="sxs-lookup"><span data-stu-id="df52e-117">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="df52e-118">Bu nedenle, <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> bir Sonlandırıcı uygulamak yerine nesneleri oluşturmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="df52e-118">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>

<span data-ttu-id="df52e-119"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>, Yönetilmeyen bir kaynağı tanımlayan bir soyut yönetilen türdür <xref:System.IntPtr?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="df52e-119">A <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract managed type that wraps an <xref:System.IntPtr?displayProperty=nameWithType> that identifies an unmanaged resource.</span></span> <span data-ttu-id="df52e-120">Windows üzerinde, bir dosya tanımlayıcısı olan UNIX üzerinde bir tanıtıcıyı tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="df52e-120">On Windows it might identify a handle while on Unix, a file descriptor.</span></span> <span data-ttu-id="df52e-121">Bu kaynağın bir kez ve yalnızca bir kez serbest bırakıldığını sağlamak için gereken tüm mantığı sağlar. Bu, ' nin ve ' a `SafeHandle` yapılan tüm başvurular `SafeHandle` atıldıktan sonra ve `SafeHandle` örnek sonlandırıldığında.</span><span class="sxs-lookup"><span data-stu-id="df52e-121">It provides all of the logic necessary to ensure that this resource is released once and only once, when the `SafeHandle` is disposed of or when all references to the `SafeHandle` have been dropped and the `SafeHandle` instance is finalized.</span></span>

<span data-ttu-id="df52e-122">, <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> Soyut bir temel sınıftır.</span><span class="sxs-lookup"><span data-stu-id="df52e-122">The <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> is an abstract base class.</span></span> <span data-ttu-id="df52e-123">Türetilmiş sınıflar, farklı tanıtıcı türleri için belirli örnekler sağlar.</span><span class="sxs-lookup"><span data-stu-id="df52e-123">Derived classes provide specific instances for different kinds of handle.</span></span> <span data-ttu-id="df52e-124">Bu türetilmiş sınıflar, için hangi değerlerin <xref:System.IntPtr?displayProperty=nameWithType> geçersiz kabul edildiği ve tanıtıcıyı gerçekten serbest bırakma işlemlerinin nasıl yapıldığını doğrular.</span><span class="sxs-lookup"><span data-stu-id="df52e-124">These derived classes validate what values for the <xref:System.IntPtr?displayProperty=nameWithType> are considered invalid and how to actually free the handle.</span></span> <span data-ttu-id="df52e-125">Örneğin, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> `SafeHandle` `IntPtrs` Açık dosya tutamaçlarını/tanımlayıcılarını tanımlayan sarmadan türeyebilir ve <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> bunu kapatmak için yöntemini geçersiz kılar ( `close` UNIX veya `CloseHandle` Windows üzerinde işlev aracılığıyla).</span><span class="sxs-lookup"><span data-stu-id="df52e-125">For example, <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> derives from `SafeHandle` to wrap `IntPtrs` that identify open file handles/descriptors, and overrides its <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method to close it (via the `close` function on Unix or `CloseHandle` function on Windows).</span></span> <span data-ttu-id="df52e-126">Yönetilmeyen bir kaynağı oluşturan .NET kitaplıklarında API 'Lerin çoğu, bunu bir içinde saracaktır `SafeHandle` ve `SafeHandle` ham işaretçiyi geri almak yerine size gerektiğinde döndürür.</span><span class="sxs-lookup"><span data-stu-id="df52e-126">Most APIs in .NET libraries that create an unmanaged resource will wrap it in a `SafeHandle` and return that `SafeHandle` to you as needed, rather than handing back the raw pointer.</span></span> <span data-ttu-id="df52e-127">Yönetilmeyen bir bileşenle etkileşim kuran ve yönetilmeyen bir kaynak için kullanabileceğiniz durumlarda `IntPtr` , `SafeHandle` onu kaydırmak için kendi türünü de oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="df52e-127">In situations where you interact with an unmanaged component and get an `IntPtr` for an unmanaged resource, you can create your own `SafeHandle` type to wrap it.</span></span> <span data-ttu-id="df52e-128">Sonuç olarak, `SafeHandle` bazı tür olmayan işlem sonlandırıcıları uygulamanız gerekir; çoğu atılabilir model uygulaması yalnızca diğer yönetilen kaynakların sarmalanması, bazıları bazı ' `SafeHandle` lar olabilir.</span><span class="sxs-lookup"><span data-stu-id="df52e-128">As a result, few non-`SafeHandle` types need to implement finalizers; most disposable pattern implementations only end up wrapping other managed resources, some of which may be `SafeHandle`s.</span></span>

<span data-ttu-id="df52e-129">Ad alanındaki aşağıdaki türetilmiş sınıflar, <xref:Microsoft.Win32.SafeHandles> güvenli işleyiciler sağlar:</span><span class="sxs-lookup"><span data-stu-id="df52e-129">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>

- <span data-ttu-id="df52e-130"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> , Ve <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> sınıfı, dosyalar, bellek eşlemeli dosyalar ve kanallar için.</span><span class="sxs-lookup"><span data-stu-id="df52e-130">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>
- <span data-ttu-id="df52e-131"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle>Bellek görünümleri için sınıfı.</span><span class="sxs-lookup"><span data-stu-id="df52e-131">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>
- <span data-ttu-id="df52e-132"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle> <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle> <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> Şifreleme yapıları için, ve sınıfları.</span><span class="sxs-lookup"><span data-stu-id="df52e-132">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>
- <span data-ttu-id="df52e-133"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle>Kayıt defteri anahtarları için sınıfı.</span><span class="sxs-lookup"><span data-stu-id="df52e-133">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>
- <span data-ttu-id="df52e-134"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>Wait tutamaçları için sınıfı.</span><span class="sxs-lookup"><span data-stu-id="df52e-134">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>

## <a name="dispose-and-disposebool"></a><span data-ttu-id="df52e-135">Dispose () ve Dispose (bool)</span><span class="sxs-lookup"><span data-stu-id="df52e-135">Dispose() and Dispose(bool)</span></span>

<span data-ttu-id="df52e-136"><xref:System.IDisposable>Arabirim, tek parametresiz bir yöntemin uygulanmasını gerektirir <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="df52e-136">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="df52e-137">Ayrıca, korumalı olmayan herhangi bir sınıfın uygulanması için ek bir `Dispose(bool)` aşırı yükleme yöntemi olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="df52e-137">Also, any non-sealed class should have an additional `Dispose(bool)` overload method to be implemented:</span></span>

- <span data-ttu-id="df52e-138">`public`Parametresi olmayan, sanal olmayan ( `NonInheritable` Visual Basic) bir <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> uygulama.</span><span class="sxs-lookup"><span data-stu-id="df52e-138">A `public` non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>

- <span data-ttu-id="df52e-139">`protected virtual`İmzası şu olan bir ( `Overridable` Visual Basic) `Dispose` yöntemi:</span><span class="sxs-lookup"><span data-stu-id="df52e-139">A `protected virtual` (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>

  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]

  > [!IMPORTANT]
  > <span data-ttu-id="df52e-140">`disposing`Parametresi `false` bir Sonlandırıcı 'dan çağrıldığında ve `true` yönteminden çağrıldığında olmalıdır <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="df52e-140">The `disposing` parameter should be `false` when called from a finalizer, and `true` when called from the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="df52e-141">Diğer bir deyişle, `true` belirleyici olmayan ve belirleyici olmayan bir şekilde `false` çağrılmayan bir değer.</span><span class="sxs-lookup"><span data-stu-id="df52e-141">In other words, it is `true` when deterministically called and `false` when non-deterministically called.</span></span>

### <a name="the-dispose-method"></a><span data-ttu-id="df52e-142">Dispose () yöntemi</span><span class="sxs-lookup"><span data-stu-id="df52e-142">The Dispose() method</span></span>

<span data-ttu-id="df52e-143">`public`, Sanal olmayan ( `NonInheritable` Visual Basic), parametresiz `Dispose` Yöntem türünün bir tüketicisi tarafından çağrıldığından, amacı yönetilmeyen kaynakları serbest bırakmak, genel temizlik gerçekleştirmek ve bir Sonlandırıcı varsa sonlandırıcının çalışması gerektiğini belirtmek için.</span><span class="sxs-lookup"><span data-stu-id="df52e-143">Because the `public`, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources, perform general cleanup, and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="df52e-144">Yönetilen bir nesneyle ilişkili gerçek bellek boşaltılırken her zaman [çöp toplayıcının](index.md)etki alanıdır.</span><span class="sxs-lookup"><span data-stu-id="df52e-144">Freeing the actual memory associated with a managed object is always the domain of the [garbage collector](index.md).</span></span> <span data-ttu-id="df52e-145">Bu nedenle, standart bir uygulaması vardır:</span><span class="sxs-lookup"><span data-stu-id="df52e-145">Because of this, it has a standard implementation:</span></span>

[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]

<span data-ttu-id="df52e-146">`Dispose`Yöntemi tüm nesne temizleme işlemini gerçekleştirir, bu nedenle çöp toplayıcının artık nesnelerin <xref:System.Object.Finalize%2A?displayProperty=nameWithType> geçersiz kılmasını çağırması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="df52e-146">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="df52e-147">Bu nedenle, yöntemine yapılan çağrı <xref:System.GC.SuppressFinalize%2A> çöp toplayıcısının sonlandırıcıyı çalıştırmasını önler.</span><span class="sxs-lookup"><span data-stu-id="df52e-147">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="df52e-148">Türün Sonlandırıcı yoksa, çağrısının <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> hiçbir etkisi olmaz.</span><span class="sxs-lookup"><span data-stu-id="df52e-148">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="df52e-149">Gerçek temizleme işleminin yöntem aşırı yüklemesi tarafından gerçekleştirildiğini unutmayın `Dispose(bool)` .</span><span class="sxs-lookup"><span data-stu-id="df52e-149">Note that the actual cleanup is performed by the `Dispose(bool)` method overload.</span></span>

### <a name="the-disposebool-method-overload"></a><span data-ttu-id="df52e-150">Dispose (bool) yöntemi aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="df52e-150">The Dispose(bool) method overload</span></span>

<span data-ttu-id="df52e-151">Aşırı yüklemede `disposing` parametresi, <xref:System.Boolean> yöntem çağrısının bir <xref:System.IDisposable.Dispose%2A> yöntemden (değer `true` ) mi yoksa sonlandırıcının mi (değer) geldiğini belirten bir ' dir `false` .</span><span class="sxs-lookup"><span data-stu-id="df52e-151">In the overload, the `disposing` parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>

<span data-ttu-id="df52e-152">Yöntemin gövdesi iki kod bloğundan oluşur:</span><span class="sxs-lookup"><span data-stu-id="df52e-152">The body of the method consists of two blocks of code:</span></span>

- <span data-ttu-id="df52e-153">Yönetilmeyen kaynakları serbest bırakan bir blok.</span><span class="sxs-lookup"><span data-stu-id="df52e-153">A block that frees unmanaged resources.</span></span> <span data-ttu-id="df52e-154">Bu blok, parametrenin değerinden bağımsız olarak yürütülür `disposing` .</span><span class="sxs-lookup"><span data-stu-id="df52e-154">This block executes regardless of the value of the `disposing` parameter.</span></span>
- <span data-ttu-id="df52e-155">Yönetilen kaynakları serbest bırakan koşullu bir blok.</span><span class="sxs-lookup"><span data-stu-id="df52e-155">A conditional block that frees managed resources.</span></span> <span data-ttu-id="df52e-156">Değeri ise bu blok yürütülür `disposing` `true` .</span><span class="sxs-lookup"><span data-stu-id="df52e-156">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="df52e-157">Serbest bıraktığı yönetilen kaynaklar şunları içerebilir:</span><span class="sxs-lookup"><span data-stu-id="df52e-157">The managed resources that it frees can include:</span></span>

  - <span data-ttu-id="df52e-158">**Uygulayan yönetilen nesneler <xref:System.IDisposable> .**</span><span class="sxs-lookup"><span data-stu-id="df52e-158">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="df52e-159">Koşullu blok, uygulamasını çağırmak için kullanılabilir <xref:System.IDisposable.Dispose%2A> (Cascade Dispose).</span><span class="sxs-lookup"><span data-stu-id="df52e-159">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation (cascade dispose).</span></span> <span data-ttu-id="df52e-160">Yönetilmeyen kaynağınızı kaydırmak için türetilmiş bir sınıf kullandıysanız <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> , <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> uygulamayı buradan çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="df52e-160">If you have used a derived class of <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose?displayProperty=nameWithType> implementation here.</span></span>

  - <span data-ttu-id="df52e-161">**Büyük miktarlarda bellek kullanan veya nadir kaynaklarını tüketen yönetilen nesneler.**</span><span class="sxs-lookup"><span data-stu-id="df52e-161">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="df52e-162">' A büyük yönetilen nesne başvuruları atayarak, `null` ulaşılamaz olma olasılığı yüksektir.</span><span class="sxs-lookup"><span data-stu-id="df52e-162">Assign large managed object references to `null` to make them more likely to be unreachable.</span></span> <span data-ttu-id="df52e-163">Bu, bunları belirleyici olmayan şekilde geri kazanıladıklarından daha hızlı bırakır.</span><span class="sxs-lookup"><span data-stu-id="df52e-163">This releases them faster than if they were reclaimed non-deterministically.</span></span>

<span data-ttu-id="df52e-164">Yöntem çağrısı bir sonlandırıcının geliyorsa, yalnızca yönetilmeyen kaynakları serbest bırakma kodu yürütmelidir.</span><span class="sxs-lookup"><span data-stu-id="df52e-164">If the method call comes from a finalizer, only the code that frees unmanaged resources should execute.</span></span> <span data-ttu-id="df52e-165">Gerçekleştirici, yanlış yolun, geri kazanılabileceğini yönetilen nesnelerle etkileşimde olmamasını sağlamaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="df52e-165">The implementer is responsible for ensuring the the false path doesn't interact with managed objects that may have been reclaimed.</span></span> <span data-ttu-id="df52e-166">Bu önemlidir çünkü çöp toplayıcının sonlandırma sırasında yönetilen nesneleri yok sayılamayan sıra belirleyici değildir.</span><span class="sxs-lookup"><span data-stu-id="df52e-166">This is important because the order in which the garbage collector destroys managed objects during finalization is non-deterministic.</span></span>

## <a name="cascade-dispose-calls"></a><span data-ttu-id="df52e-167">Basamaklı atma çağrıları</span><span class="sxs-lookup"><span data-stu-id="df52e-167">Cascade dispose calls</span></span>

<span data-ttu-id="df52e-168">Sınıfınız bir alan veya özelliğe sahipse ve türü uygularsa <xref:System.IDisposable> , kapsayan sınıfın kendisi de uygulamalıdır <xref:System.IDisposable> .</span><span class="sxs-lookup"><span data-stu-id="df52e-168">If your class owns a field or property, and its type implements <xref:System.IDisposable>, the containing class itself should also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="df52e-169">Bir uygulamayı örnekleyen <xref:System.IDisposable> ve örnek üye olarak depolayan bir sınıf, temizlemeden de sorumludur.</span><span class="sxs-lookup"><span data-stu-id="df52e-169">A class that instantiates an <xref:System.IDisposable> implementation and storing it as an instance member, is also responsible for its cleanup.</span></span> <span data-ttu-id="df52e-170">Bu, başvurulan atılabilir türlerine, yöntemi aracılığıyla temizlemeyi kesin bir şekilde gerçekleştirmeyi sağlayan fırsat verilmesini sağlamaya yardımcı olur <xref:System.IDisposable.Dispose%2A> .</span><span class="sxs-lookup"><span data-stu-id="df52e-170">This is to help ensure that the referenced disposable types are given the opportunity to deterministically perform clean up through the <xref:System.IDisposable.Dispose%2A> method.</span></span> <span data-ttu-id="df52e-171">Bu örnekte, sınıfı `sealed` (veya `NotInheritable` Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="df52e-171">In this example, the class is `sealed` (or `NotInheritable` in Visual Basic).</span></span>

[!code-csharp[Conceptual.Disposable#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/disposable1.cs#1)]
[!code-vb[Conceptual.Disposable#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/disposable1.vb#1)]

## <a name="implement-the-dispose-pattern"></a><span data-ttu-id="df52e-172">Dispose modelini uygulama</span><span class="sxs-lookup"><span data-stu-id="df52e-172">Implement the dispose pattern</span></span>

<span data-ttu-id="df52e-173">Korumalı olmayan tüm sınıflar veya (Visual Basic sınıfları olarak değiştirilmez `NotInheritable` ), devralınabileceğinden, olası bir temel sınıf olarak düşünülmelidir.</span><span class="sxs-lookup"><span data-stu-id="df52e-173">All non-sealed classes or (Visual Basic classes not modified as `NotInheritable`) should be considered a potential base class, because they could be inherited.</span></span> <span data-ttu-id="df52e-174">Herhangi bir olası temel sınıf için Dispose modelini uygularsanız, aşağıdakileri sağlamalısınız:</span><span class="sxs-lookup"><span data-stu-id="df52e-174">If you implement the dispose pattern for any potential base class, you must provide the following:</span></span>

- <span data-ttu-id="df52e-175"><xref:System.IDisposable.Dispose%2A>Yöntemini çağıran bir uygulama `Dispose(bool)` .</span><span class="sxs-lookup"><span data-stu-id="df52e-175">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(bool)` method.</span></span>
- <span data-ttu-id="df52e-176">`Dispose(bool)`Gerçek temizleme işlemini gerçekleştiren bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="df52e-176">A `Dispose(bool)` method that performs the actual cleanup.</span></span>
- <span data-ttu-id="df52e-177">Öğesinden türetilen bir sınıf <xref:System.Runtime.InteropServices.SafeHandle> , Yönetilmeyen kaynağınızı sarmalanmış (önerilir) veya yöntemine bir geçersiz kılma <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="df52e-177">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="df52e-178"><xref:System.Runtime.InteropServices.SafeHandle>Sınıfı bir Sonlandırıcı sağlar, bu nedenle kendiniz yazmak zorunda değilsiniz.</span><span class="sxs-lookup"><span data-stu-id="df52e-178">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer, so you do not have to write one yourself.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="df52e-179">Temel sınıfın yalnızca yönetilen nesnelere başvurması ve Dispose deseninin uygulanması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="df52e-179">It is possible for a base class to only reference managed objects, and implement the dispose pattern.</span></span> <span data-ttu-id="df52e-180">Bu durumlarda, sonlandırıcısı gereksizdir.</span><span class="sxs-lookup"><span data-stu-id="df52e-180">In these cases, a finalizer is unnecessary.</span></span> <span data-ttu-id="df52e-181">Sonlandırıcı yalnızca yönetilmeyen kaynaklara doğrudan başvurdıysanız gereklidir.</span><span class="sxs-lookup"><span data-stu-id="df52e-181">A finalizer is only required if you directly reference unmanaged resources.</span></span>

<span data-ttu-id="df52e-182">Aşağıda, güvenli tanıtıcı kullanan bir temel sınıf için Dispose deseninin uygulanması için genel bir model verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="df52e-182">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>

[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]

> [!NOTE]
> <span data-ttu-id="df52e-183">Önceki örnek, bir <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> nesneyi göstermek için bir nesnesi kullanır; bunun yerine ondan türetilmiş herhangi bir nesne <xref:System.Runtime.InteropServices.SafeHandle> kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="df52e-183">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="df52e-184">Örneğin nesnesinin düzgün şekilde örneklemez olduğunu unutmayın <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> .</span><span class="sxs-lookup"><span data-stu-id="df52e-184">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="df52e-185">Geçersiz kılan bir temel sınıf için Dispose deseninin uygulanması için genel bir model <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="df52e-185">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>

[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]

> [!TIP]
> <span data-ttu-id="df52e-186">C# dilinde, geçersiz kılarak bir [Sonlandırıcı](../../csharp/programming-guide/classes-and-structs/destructors.md) oluşturursunuz <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="df52e-186">In C#, you create a [finalizer](../../csharp/programming-guide/classes-and-structs/destructors.md) by overriding <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="df52e-187">Visual Basic, ile yapılır `Protected Overrides Sub Finalize()` .</span><span class="sxs-lookup"><span data-stu-id="df52e-187">In Visual Basic, this is done with `Protected Overrides Sub Finalize()`.</span></span>

## <a name="implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="df52e-188">Türetilmiş bir sınıf için Dispose modelini uygulama</span><span class="sxs-lookup"><span data-stu-id="df52e-188">Implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="df52e-189"><xref:System.IDisposable> <xref:System.IDisposable> Temel sınıf uygulaması <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> türetilmiş sınıfları tarafından devralındığından, arabirimini uygulayan bir sınıftan türetilmiş bir sınıf uygulanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="df52e-189">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="df52e-190">Bunun yerine, türetilmiş bir sınıfı temizlemek için şunları sağlarsınız:</span><span class="sxs-lookup"><span data-stu-id="df52e-190">Instead, to cleanup a derived class, you provide the following:</span></span>

- <span data-ttu-id="df52e-191">`protected override void Dispose(bool)`Temel sınıf yöntemini geçersiz kılan ve türetilmiş sınıfın gerçek temizleme işlemini gerçekleştiren bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="df52e-191">A `protected override void Dispose(bool)` method that overrides the base class method and performs the actual cleanup of the derived class.</span></span> <span data-ttu-id="df52e-192">Bu yöntem ayrıca `base.Dispose(bool)` `MyBase.Dispose(bool)` temel sınıfın (Visual Basic) metodunu çağırmalıdır ve bağımsız değişkeni için disposing durumunu iletmelidir.</span><span class="sxs-lookup"><span data-stu-id="df52e-192">This method must also call the `base.Dispose(bool)` (`MyBase.Dispose(bool)` in Visual Basic) method of the base class and pass its disposing status for the argument.</span></span>
- <span data-ttu-id="df52e-193">Öğesinden türetilen bir sınıf <xref:System.Runtime.InteropServices.SafeHandle> , Yönetilmeyen kaynağınızı sarmalanmış (önerilir) veya yöntemine bir geçersiz kılma <xref:System.Object.Finalize%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="df52e-193">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="df52e-194"><xref:System.Runtime.InteropServices.SafeHandle>Sınıfı, sizi kod içine almak zorunda kalmanızı sağlayan bir Sonlandırıcı sağlar.</span><span class="sxs-lookup"><span data-stu-id="df52e-194">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="df52e-195">Bir Sonlandırıcı sağlarsanız, `Dispose(bool)` bir bağımsız değişkeniyle aşırı yüklemeyi çağırmalıdır `disposing` `false` .</span><span class="sxs-lookup"><span data-stu-id="df52e-195">If you do provide a finalizer, it must call the `Dispose(bool)` overload with a `disposing` argument of `false`.</span></span>

<span data-ttu-id="df52e-196">Güvenli tanıtıcı kullanan bir türetilen sınıf için dispose deseni uygulamada genel düzen aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="df52e-196">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>

[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]

> [!NOTE]
> <span data-ttu-id="df52e-197">Önceki örnek, bir <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> nesneyi göstermek için bir nesnesi kullanır; bunun yerine ondan türetilmiş herhangi bir nesne <xref:System.Runtime.InteropServices.SafeHandle> kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="df52e-197">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="df52e-198">Örneğin nesnesinin düzgün şekilde örneklemez olduğunu unutmayın <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> .</span><span class="sxs-lookup"><span data-stu-id="df52e-198">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>

<span data-ttu-id="df52e-199">Geçersiz kılan türetilmiş bir sınıf için Dispose deseninin uygulanması için genel bir model aşağıda verilmiştir <xref:System.Object.Finalize%2A?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="df52e-199">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>

[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]

## <a name="implement-the-dispose-pattern-with-safe-handles"></a><span data-ttu-id="df52e-200">Güvenli tanıtıcılarla Dispose modelini uygulama</span><span class="sxs-lookup"><span data-stu-id="df52e-200">Implement the dispose pattern with safe handles</span></span>

<span data-ttu-id="df52e-201">Aşağıdaki örnek, `DisposableStreamResource` yönetilmeyen kaynakları kapsüllemek için güvenli bir tanıtıcı kullanan bir temel sınıf için Dispose modelini göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="df52e-201">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="df52e-202">`DisposableStreamResource` <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> Açık bir dosyayı temsil eden bir nesneyi kaydırmak için öğesini kullanan bir sınıfı tanımlar <xref:System.IO.Stream> .</span><span class="sxs-lookup"><span data-stu-id="df52e-202">It defines a `DisposableStreamResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="df52e-203">Sınıfı ayrıca `Size` , dosya akışındaki toplam bayt sayısını döndüren tek bir özelliğini de içerir.</span><span class="sxs-lookup"><span data-stu-id="df52e-203">The class also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>

[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]

## <a name="implement-the-dispose-pattern-for-a-derived-class-with-safe-handles"></a><span data-ttu-id="df52e-204">Güvenli tanıtıcılarla türetilmiş bir sınıf için Dispose modelini uygulama</span><span class="sxs-lookup"><span data-stu-id="df52e-204">Implement the dispose pattern for a derived class with safe handles</span></span>

<span data-ttu-id="df52e-205">Aşağıdaki örnek, `DisposableStreamResource2` `DisposableStreamResource` Önceki örnekte sunulan sınıftan devralan türetilmiş bir sınıf için Dispose modelini göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="df52e-205">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="df52e-206">Sınıfı ek bir yöntemi ekler, `WriteFileInfo` ve <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> yazılabilir dosyanın tanıtıcısını kaydırmak için bir nesnesi kullanır.</span><span class="sxs-lookup"><span data-stu-id="df52e-206">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>

[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]

## <a name="see-also"></a><span data-ttu-id="df52e-207">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="df52e-207">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="df52e-208">Sınıfları ve yapıları tanımlama ve kullanma (C++/CLı)</span><span class="sxs-lookup"><span data-stu-id="df52e-208">Define and consume classes and structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
