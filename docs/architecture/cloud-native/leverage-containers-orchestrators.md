---
title: Kapsayıcılardan ve düzenleyicilerden yararlanma
description: Azure 'da Docker kapsayıcılarını ve Kubernetes düzenleyicilerinden yararlanın
ms.date: 04/13/2020
ms.openlocfilehash: 3d94433250f02a8df2c27ebc89a101e1e8d15030
ms.sourcegitcommit: 5988e9a29cedb8757320817deda3c08c6f44a6aa
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/28/2020
ms.locfileid: "82199839"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="39455-103">Kapsayıcılardan ve düzenleyicilerden yararlanma</span><span class="sxs-lookup"><span data-stu-id="39455-103">Leveraging containers and orchestrators</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="39455-104">Kapsayıcılar ve düzenleyiciler, tek parçalı dağıtım yaklaşımları için ortak olan sorunları çözmeye yönelik olarak tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="39455-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="39455-105">Tek parçalı dağıtımlar ile ilgili sorunlar</span><span class="sxs-lookup"><span data-stu-id="39455-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="39455-106">Geleneksel olarak, çoğu uygulama tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="39455-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="39455-107">Bu tür uygulamalar tek bir olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="39455-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="39455-108">Bu genel yaklaşım, birden çok modülden oluşsa bile veya derlemeler şekil 3-1 ' de gösterildiği gibi tek parçalı mimari olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="39455-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![Tek parçalı mimari.](./media/monolithic-architecture.png)

<span data-ttu-id="39455-110">**Şekil 3-1**.</span><span class="sxs-lookup"><span data-stu-id="39455-110">**Figure 3-1**.</span></span> <span data-ttu-id="39455-111">Tek parçalı mimari.</span><span class="sxs-lookup"><span data-stu-id="39455-111">Monolithic architecture.</span></span>

<span data-ttu-id="39455-112">Basitlik avantajlarına sahip olsalar da tek parçalı mimarilerin bir dizi zorluk yüzü vardır:</span><span class="sxs-lookup"><span data-stu-id="39455-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="39455-113">Dağıtım</span><span class="sxs-lookup"><span data-stu-id="39455-113">Deployment</span></span>

<span data-ttu-id="39455-114">Tek parçalı uygulamalar, yalnızca küçük bir değişiklik yapılmış olsa bile tüm uygulamanın tam dağıtımını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="39455-114">Monolithic applications require a full deployment of the entire application, even if only a small change has been made.</span></span> <span data-ttu-id="39455-115">Tam dağıtımlar pahalı ve hataya açık olabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-115">Full deployments can be expensive and error prone.</span></span> <span data-ttu-id="39455-116">Ayrıca, uygulamanın yeniden başlatılması gerekir ve bu, kullanım dışı olarak geçici olarak etkiler.</span><span class="sxs-lookup"><span data-stu-id="39455-116">Additionally, they require a restart of the application, which temporarily impacts unavailability.</span></span>

### <a name="scaling"></a><span data-ttu-id="39455-117">Ölçeklendirme</span><span class="sxs-lookup"><span data-stu-id="39455-117">Scaling</span></span>

<span data-ttu-id="39455-118">Tek parçalı bir uygulama, genellikle yüksek yetenek donanımlar gerektiren tek bir makine örneğinde barındırılır.</span><span class="sxs-lookup"><span data-stu-id="39455-118">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="39455-119">Tekinin herhangi bir bölümü ölçeklendirmeyi gerektiriyorsa, uygulamanın tamamının başka bir kopyasının başka bir makineye dağıtılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="39455-119">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="39455-120">Tek tek, uygulama bileşenlerini ayrı ayrı ölçeklendiremez. Bu, hepsi veya hiçbir şey değildir.</span><span class="sxs-lookup"><span data-stu-id="39455-120">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="39455-121">Ölçeklendirme gerektirmeyen bileşenleri ölçeklendirme, verimsiz ve maliyetli kaynak kullanımı ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="39455-121">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="39455-122">Ortam</span><span class="sxs-lookup"><span data-stu-id="39455-122">Environment</span></span>

<span data-ttu-id="39455-123">Tek parçalı uygulamalar, genellikle önceden yüklenmiş bir işletim sistemi, çalışma zamanı ve kitaplık bağımlılıkları olan bir barındırma ortamına dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="39455-123">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="39455-124">Bu ortam, uygulamanın geliştirildiğini veya test edildiğini eşleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="39455-124">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="39455-125">Uygulama ortamları genelinde tutarsızlıklar, tek parçalı dağıtımlar için ortak bir sorun kaynağıdır.</span><span class="sxs-lookup"><span data-stu-id="39455-125">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="39455-126">Bağlantısı</span><span class="sxs-lookup"><span data-stu-id="39455-126">Coupling</span></span>

<span data-ttu-id="39455-127">Tek parçalı bir uygulama, işlevsel bileşenleri arasında yüksek bir bağ deneyimlidir.</span><span class="sxs-lookup"><span data-stu-id="39455-127">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="39455-128">Sabit sınır olmadan sistem değişiklikleri genellikle istenmeden ve pahalı yan etkilere neden olur.</span><span class="sxs-lookup"><span data-stu-id="39455-128">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="39455-129">Yeni özellikler/düzeltmeler, uygulama için karmaşık, zaman alan ve pahalı hale gelir.</span><span class="sxs-lookup"><span data-stu-id="39455-129">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="39455-130">Güncelleştirmeler kapsamlı test gerektirir.</span><span class="sxs-lookup"><span data-stu-id="39455-130">Updates require extensive testing.</span></span> <span data-ttu-id="39455-131">Ayrıca, geçiş, bileşenleri yeniden düzenleme veya alternatif uygulamalarda değiştirme olanağı da zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="39455-131">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="39455-132">Sıkı bir sorun ayrımı ile oluşturulduğunda bile, tek parçalı kod tabanı olarak ' deki mimari liflik kümeleri, hiçbir zaman sonlandırma "özel durumlar" ile birlikte oluşur.</span><span class="sxs-lookup"><span data-stu-id="39455-132">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="39455-133">Platform kilidi-ın</span><span class="sxs-lookup"><span data-stu-id="39455-133">Platform lock-in</span></span>

<span data-ttu-id="39455-134">Tek parçalı bir uygulama tek bir teknoloji yığını ile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="39455-134">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="39455-135">Bu taahhüt, bir yeniliği sunarken, yeniliklere bir engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-135">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="39455-136">Yeni özellikler ve bileşenler, daha modern teknolojiler daha iyi bir seçim olabileceği halde uygulamanın geçerli yığını kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="39455-136">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="39455-137">Daha uzun süreli bir risk, teknoloji yığınınızın süresi geçmiş ve kullanım dışı olma sürecinde.</span><span class="sxs-lookup"><span data-stu-id="39455-137">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="39455-138">Tüm uygulamayı yeni, daha modern bir platforma yeniden tasarlama en iyi maliyetli ve riskli bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="39455-138">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="39455-139">Kapsayıcıların ve düzenleyicilerinin avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="39455-139">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="39455-140">Bölüm 1 ' de kapsayıcılar tanıtıldık.</span><span class="sxs-lookup"><span data-stu-id="39455-140">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="39455-141">Cloud Native Bilgi Işlem altyapısı 'nın (CNCF) kapsayıcının bulut Yerel [Izleme haritalarındaki](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) ilk adım olarak nasıl derecelendirmiş olduğunu vurgularız.</span><span class="sxs-lookup"><span data-stu-id="39455-141">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="39455-142">Bu bölümde, kapsayıcıların avantajları tartışıyoruz.</span><span class="sxs-lookup"><span data-stu-id="39455-142">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="39455-143">Docker en popüler kapsayıcı yönetimi platformudur.</span><span class="sxs-lookup"><span data-stu-id="39455-143">Docker is the most popular container management platform.</span></span> <span data-ttu-id="39455-144">Hem Linux hem de Windows üzerinde kapsayıcılarla birlikte çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="39455-144">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="39455-145">Kapsayıcılar, her sistemde aynı şekilde çalışan ayrı ancak tekrarlanabilir uygulama ortamları sağlar.</span><span class="sxs-lookup"><span data-stu-id="39455-145">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="39455-146">Bu boyut, bulutta yerel hizmetler geliştirmek ve barındırmak için ideal hale getirir.</span><span class="sxs-lookup"><span data-stu-id="39455-146">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="39455-147">Kapsayıcılar bir diğerinden yalıtılmıştır.</span><span class="sxs-lookup"><span data-stu-id="39455-147">Containers are isolated from one another.</span></span> <span data-ttu-id="39455-148">Aynı konak donanımında iki kapsayıcı, çakışmalara neden olmadan farklı yazılım sürümlerine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-148">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="39455-149">Kapsayıcılar, proje yapıtları haline gelen ve kaynak denetimine işaretlenmiş basit metin tabanlı dosyalar tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="39455-149">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="39455-150">Tam sunucular ve sanal makinelerin güncelleştirilmesi için el ile çaba gerektirmesi durumunda, kapsayıcılar kolayca sürüm denetlenir.</span><span class="sxs-lookup"><span data-stu-id="39455-150">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="39455-151">Kapsayıcılarda çalışmak üzere oluşturulan uygulamalar, derleme işlem hattının parçası olarak otomatikleştirilmiş araçlar kullanılarak geliştirilebilir, test edilebilir ve dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-151">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="39455-152">Kapsayıcılar sabittir.</span><span class="sxs-lookup"><span data-stu-id="39455-152">Containers are immutable.</span></span> <span data-ttu-id="39455-153">Bir kapsayıcı tanımladıktan sonra, tam olarak aynı şekilde yeniden oluşturabilir ve çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-153">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="39455-154">Bu, bu şekilde bileşen tabanlı tasarıma yönelik olarak kullanılabilirlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="39455-154">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="39455-155">Bir uygulamanın bazı bölümleri diğerlerinden farklı şekilde geliştikçe, en sık değiştiren parçaları yalnızca dağıtırken uygulamanın tamamını yeniden dağıtmanız gerekir mi?</span><span class="sxs-lookup"><span data-stu-id="39455-155">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="39455-156">Bir uygulamanın farklı özellikleri ve çapraz kesme sorunları ayrı birimlere ayrılabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-156">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="39455-157">Şekil 3-2, tek parçalı bir uygulamanın belirli özellikler veya işlevler için kapsayıcılardan ve mikro hizmetlerden nasıl yararlanabileceğiz gösterir.</span><span class="sxs-lookup"><span data-stu-id="39455-157">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="39455-158">Uygulamanın kendisindeki diğer işlevsellik de Kapsayıcılı hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="39455-158">The remaining functionality in the app itself has also been containerized.</span></span>

<span data-ttu-id="39455-159">![Arka uçta mikro hizmetleri kullanmak için tek parçalı bir uygulamayı bölmek. ](./media/breaking-up-monolith-with-backend-microservices.png)
 **Şekil 3-2**.</span><span class="sxs-lookup"><span data-stu-id="39455-159">![Breaking up a monolithic app to use microservices in the back end.](./media/breaking-up-monolith-with-backend-microservices.png)
**Figure 3-2**.</span></span> <span data-ttu-id="39455-160">Arka uçta mikro hizmetleri kullanmak için tek parçalı bir uygulamayı bölmek.</span><span class="sxs-lookup"><span data-stu-id="39455-160">Breaking up a monolithic app to use microservices in the back end.</span></span>

<span data-ttu-id="39455-161">Her bulut Yerel hizmeti ayrı bir kapsayıcıda oluşturulup dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="39455-161">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="39455-162">Her biri gerektiğinde güncelleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="39455-162">Each can update as needed.</span></span> <span data-ttu-id="39455-163">Her hizmet için uygun kaynakları olan düğümlerde tek tek hizmetler barındırılabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-163">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="39455-164">Her hizmetin çalıştığı ortam, geliştirme, test ve üretim ortamlarında paylaşılan ve kolayca sürümlü bir sabittir.</span><span class="sxs-lookup"><span data-stu-id="39455-164">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="39455-165">Uygulamanın farklı alanlarında, tek başına derleme zamanı bağımlılıkları değil, hizmetler arasında doğrudan çağrı veya ileti olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="39455-165">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="39455-166">Ayrıca, uygulamanın geri kalanında değişiklik gerektirmeden belirli bir özelliği en iyi şekilde sunan teknolojiyi de seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-166">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="39455-167">Kapsayıcılı hizmetler otomatik yönetim gerektirir.</span><span class="sxs-lookup"><span data-stu-id="39455-167">Containerized services require automated management.</span></span> <span data-ttu-id="39455-168">Bağımsız olarak dağıtılan kapsayıcıların büyük bir kümesini el ile yönetmek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="39455-168">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="39455-169">Örneğin, aşağıdaki görevleri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="39455-169">For example, consider the following tasks:</span></span>

- <span data-ttu-id="39455-170">Kapsayıcı örnekleri birçok makinenin bir kümesi arasında nasıl sağlanacak?</span><span class="sxs-lookup"><span data-stu-id="39455-170">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="39455-171">Dağıtıldıktan sonra kapsayıcılar birbirleriyle nasıl keşfedilir ve birbirleriyle iletişim kurar?</span><span class="sxs-lookup"><span data-stu-id="39455-171">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="39455-172">Kapsayıcılar isteğe bağlı olarak nasıl ölçeklenebilen veya kullanıma hazır?</span><span class="sxs-lookup"><span data-stu-id="39455-172">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="39455-173">Her kapsayıcının durumunu nasıl izleyebilirim?</span><span class="sxs-lookup"><span data-stu-id="39455-173">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="39455-174">Bir kapsayıcıyı donanım ve yazılım hatalarıyla nasıl koruyabilirim?</span><span class="sxs-lookup"><span data-stu-id="39455-174">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="39455-175">Canlı bir uygulama için kapsayıcıları sıfır kapalı kalma süresiyle nasıl yükseltebilirim?</span><span class="sxs-lookup"><span data-stu-id="39455-175">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="39455-176">Kapsayıcı yöneticileri bu ve diğer kaygıları ele alır ve otomatikleştirin.</span><span class="sxs-lookup"><span data-stu-id="39455-176">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="39455-177">Bulut Yerel ekonomik sistemde, Kubernetes, kapsayıcı Orchestrator ' ı d haline geldi.</span><span class="sxs-lookup"><span data-stu-id="39455-177">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="39455-178">Bu, bulut Yerel Bilgi Işlem altyapısı (CNCF) tarafından yönetilen açık kaynaklı bir platformdur.</span><span class="sxs-lookup"><span data-stu-id="39455-178">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="39455-179">Kubernetes, bir makine kümesi içindeki Kapsayıcılı iş yüklerinin dağıtım, ölçeklendirme ve işlevsel sorunlarını otomatikleştirir.</span><span class="sxs-lookup"><span data-stu-id="39455-179">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="39455-180">Ancak, Kubernetes 'nin yüklenmesi ve yönetilmesi, önemli bir karmaşıkdır.</span><span class="sxs-lookup"><span data-stu-id="39455-180">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="39455-181">Daha iyi bir yaklaşım, Kubernetes 'in bir bulut satıcısından yönetilen hizmet olarak faydalanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="39455-181">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="39455-182">Azure bulut, [Azure Kubernetes hizmeti (AKS)](https://azure.microsoft.com/services/kubernetes-service/)ile tam olarak yönetilen bir Kubernetes platformu sunar.</span><span class="sxs-lookup"><span data-stu-id="39455-182">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="39455-183">AKS, Kubernetes yönetiminin karmaşıklık ve operasyonel yükünü soyutlar.</span><span class="sxs-lookup"><span data-stu-id="39455-183">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="39455-184">Kubernetes 'i bir bulut hizmeti olarak kullanırsınız; Microsoft, yönetim ve destekleme sorumluluğunu kullanır.</span><span class="sxs-lookup"><span data-stu-id="39455-184">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="39455-185">AKS, diğer Azure hizmetleri ve geliştirme araçlarıyla da sıkı bir şekilde tümleşir.</span><span class="sxs-lookup"><span data-stu-id="39455-185">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="39455-186">AKS, küme temelli bir teknolojidir.</span><span class="sxs-lookup"><span data-stu-id="39455-186">AKS is a cluster-based technology.</span></span> <span data-ttu-id="39455-187">Federasyon sanal makineleri veya düğümleri havuzu Azure bulutuna dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="39455-187">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="39455-188">Bunlar, yüksek oranda kullanılabilir bir ortam veya küme oluşturur.</span><span class="sxs-lookup"><span data-stu-id="39455-188">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="39455-189">Küme, bulutta yerel uygulamanıza sorunsuz, tek bir varlık olarak görünür.</span><span class="sxs-lookup"><span data-stu-id="39455-189">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="39455-190">Bu şekilde, AKS 'ler, yükü eşit bir şekilde dağıtan önceden tanımlanmış bir stratejiye göre Kapsayıcılı hizmetlerinizi bu düğümler arasında dağıtır.</span><span class="sxs-lookup"><span data-stu-id="39455-190">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="39455-191">Ölçeklendirme avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="39455-191">What are the scaling benefits?</span></span>

<span data-ttu-id="39455-192">Kapsayıcılarda oluşturulan hizmetler, Kubernetes gibi Orchestration araçları tarafından sunulan ölçeklendirme avantajlarından yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-192">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="39455-193">Tasarım kapsayıcıları tarafından yalnızca kendileri hakkında bilgi sahibi.</span><span class="sxs-lookup"><span data-stu-id="39455-193">By design containers only know about themselves.</span></span> <span data-ttu-id="39455-194">Birlikte çalışması gereken birden çok kapsayıcınız varsa, bunları daha yüksek bir düzeyde düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="39455-194">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="39455-195">Çok sayıda kapsayıcıyı ve ağ yapılandırması gibi paylaşılan bağımlılıklarını organize etmek, düzenleme araçlarının günü kaydetmek için nereden geldiği yerdir!</span><span class="sxs-lookup"><span data-stu-id="39455-195">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="39455-196">Kubernetes kapsayıcı grupları üzerinde bir soyutlama katmanı oluşturur ve bunları *Pod*olarak düzenler.</span><span class="sxs-lookup"><span data-stu-id="39455-196">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="39455-197">*Düğüm*olarak adlandırılan çalışan makinelerdeki pods çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="39455-197">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="39455-198">Bu düzenlenmiş yapı, *küme*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="39455-198">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="39455-199">Şekil 3-3, bir Kubernetes kümesinin farklı bileşenlerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="39455-199">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="39455-200">![Kubernetes kümesi bileşenleri. ](./media/kubernetes-cluster-components.png)
 **Şekil 3-3**.</span><span class="sxs-lookup"><span data-stu-id="39455-200">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="39455-201">Kubernetes kümesi bileşenleri.</span><span class="sxs-lookup"><span data-stu-id="39455-201">Kubernetes cluster components.</span></span>

<span data-ttu-id="39455-202">Kapsayıcılı iş yüklerinin ölçeklendirilmesi, kapsayıcı düzenleyicilerinin temel bir özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="39455-202">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="39455-203">AKS iki boyut genelinde otomatik ölçeklendirmeyi destekler: kapsayıcı örnekleri ve işlem düğümleri.</span><span class="sxs-lookup"><span data-stu-id="39455-203">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="39455-204">Birlikte, isteğe bağlı olarak ani artışları hızla ve verimli bir şekilde yanıtlama ve ek kaynaklar ekleme olanağı sunar.</span><span class="sxs-lookup"><span data-stu-id="39455-204">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="39455-205">Bu bölümün ilerleyen kısımlarında, ölçeklendirilirken ölçeklendirmeyi tartıştık.</span><span class="sxs-lookup"><span data-stu-id="39455-205">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="39455-206">Bildirime dayalı ve kesinlik</span><span class="sxs-lookup"><span data-stu-id="39455-206">Declarative versus imperative</span></span>

<span data-ttu-id="39455-207">Kubernetes hem bildirime dayalı hem de kesinlik temelli yapılandırmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="39455-207">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="39455-208">Zorunlu yaklaşım, Kubernetes 'in her adımın nasıl yapılacağını söyleyen çeşitli komutları çalıştırmayı içerir.</span><span class="sxs-lookup"><span data-stu-id="39455-208">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="39455-209">Bu görüntüyü çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="39455-209">Run this image.</span></span> <span data-ttu-id="39455-210">Bu Pod öğesini silin.</span><span class="sxs-lookup"><span data-stu-id="39455-210">Delete this pod.</span></span> <span data-ttu-id="39455-211">Bu bağlantı noktasını kullanıma sunun.</span><span class="sxs-lookup"><span data-stu-id="39455-211">Expose this port.</span></span> <span data-ttu-id="39455-212">Bildirim temelli yaklaşımla, ne yapmak istediğinizi belirlemek için bildirim olarak adlandırılan bir yapılandırma dosyası oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="39455-212">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="39455-213">Kubernetes bildirimi okur ve istediğiniz bitiş durumunu gerçek bitiş durumuna dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="39455-213">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="39455-214">Zorunlu komutların öğrenimi ve etkileşimli deneme için harika olması.</span><span class="sxs-lookup"><span data-stu-id="39455-214">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="39455-215">Ancak, güvenilir ve tekrarlanabilir dağıtımlar sağlayan bir altyapıyı kod yaklaşımı olarak ayraç içine almak için, bildirimli olarak Kubernetes bildirim dosyalarını oluşturmak isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-215">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="39455-216">Bildirim dosyası bir proje yapıtı haline gelir ve Kubernetes dağıtımlarını otomatikleştirmek için CI/CD işlem hattınızda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="39455-216">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="39455-217">Kümenizi tanımlayıcı komutları kullanarak zaten yapılandırdıysanız, kullanarak `kubectl get svc SERVICENAME -o yaml > service.yaml`bildirim temelli bir bildirimi dışarı aktarabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-217">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="39455-218">Bu komut aşağıda gösterilene benzer bir bildirim üretir:</span><span class="sxs-lookup"><span data-stu-id="39455-218">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="39455-219">Bildirim temelli yapılandırma kullanırken, yapılandırma dosyalarınızın bulunduğu klasöre `kubectl diff -f FOLDERNAME` karşı uygulamadan önce yapılacak değişikliklerin önizlemesini yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-219">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="39455-220">Değişiklikleri uygulamak istediğinize emin olduktan sonra çalıştırın `kubectl apply -f FOLDERNAME`.</span><span class="sxs-lookup"><span data-stu-id="39455-220">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="39455-221">Bir `-R` klasör hiyerarşisini yinelemeli olarak işlemeye ekleyin.</span><span class="sxs-lookup"><span data-stu-id="39455-221">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="39455-222">Ayrıca, biri dağıtımları olan diğer Kubernetes özellikleriyle bildirim temelli yapılandırma de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-222">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="39455-223">Bildirim temelli dağıtımlar, yayınları, güncelleştirmeleri ve ölçeklendirmeyi yönetmeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="39455-223">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="39455-224">Bu kişiler, Kubernetes dağıtım denetleyicisine yeni değişiklikler dağıtma, yük genişletme veya önceki bir düzeltmeye geri dönme işlemlerini yönlendirir.</span><span class="sxs-lookup"><span data-stu-id="39455-224">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="39455-225">Bir küme kararsız durumdaysa, bildirime dayalı bir dağıtım otomatik olarak kümeyi istenen duruma geri döndürür.</span><span class="sxs-lookup"><span data-stu-id="39455-225">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="39455-226">Örneğin, bir düğüm kilitlenmelidir, dağıtım mekanizması istediğiniz duruma ulaşmak için bir değişikliği yeniden dağıtırsınız</span><span class="sxs-lookup"><span data-stu-id="39455-226">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="39455-227">Bildirim temelli yapılandırma kullanmak, altyapının uygulama kodu ile birlikte denetlenebilen ve sürümü oluşturulmuş bir kod olarak temsil etmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="39455-227">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="39455-228">Yapı ve dağıtım işlem hattı kullanarak sürekli dağıtım için geliştirilmiş değişiklik denetimi ve daha iyi destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="39455-228">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="39455-229">Kapsayıcılar ve düzenleyiciler için hangi senaryolar idealdir?</span><span class="sxs-lookup"><span data-stu-id="39455-229">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="39455-230">Aşağıdaki senaryolar kapsayıcıları ve düzenlemeleri kullanmak için idealdir.</span><span class="sxs-lookup"><span data-stu-id="39455-230">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="39455-231">Yüksek çalışma süresi ve ölçeklenebilirlik gerektiren uygulamalar</span><span class="sxs-lookup"><span data-stu-id="39455-231">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="39455-232">Yüksek çalışma süresi ve ölçeklenebilirlik gereksinimleri olan bireysel uygulamalar, mikro hizmetler, kapsayıcılar ve düzenleyicilerin kullanıldığı bulutta yerel mimariler için ideal adaylardır.</span><span class="sxs-lookup"><span data-stu-id="39455-232">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="39455-233">Bunlar kapsayıcılarda geliştirilir, sürümlü ortamlar arasında test edilebilir ve sıfır kapalı kalma süresiyle üretime dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="39455-233">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="39455-234">Kubernetes kümelerinin kullanımı, bu tür uygulamaların talep üzerine ölçeklenmesini ve düğüm hatalarından otomatik olarak kurtarılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="39455-234">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="39455-235">Çok sayıda uygulama</span><span class="sxs-lookup"><span data-stu-id="39455-235">Large numbers of applications</span></span>

<span data-ttu-id="39455-236">Çok sayıda uygulamayı dağıtan ve bunları yöneten kuruluşlar, kapsayıcılardan ve düzenleyicilerinden faydalanır.</span><span class="sxs-lookup"><span data-stu-id="39455-236">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="39455-237">Kapsayıcılı ortamları ve Kubernetes kümelerini ayarlamanın en ön çabası, birincil olarak sabit bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="39455-237">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="39455-238">Bireysel uygulamaların dağıtımı, sürdürülmesi ve güncelleştirilmesi, uygulama sayısıyla değişen bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="39455-238">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="39455-239">Az sayıda uygulamanın ötesinde, özel uygulamaları korumanın karmaşıklığı kapsayıcıları ve düzenlemeleri kullanarak bir çözüm uygulama masrafını daha da aşıyor.</span><span class="sxs-lookup"><span data-stu-id="39455-239">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="39455-240">Kapsayıcıları ve düzenlemeleri kullanmaktan ne zaman kaçınmalısınız?</span><span class="sxs-lookup"><span data-stu-id="39455-240">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="39455-241">Uygulamanızı on Iki öğeli uygulama ilkelerine göre derlemenize izin verirseniz kapsayıcılardan ve düzenleyicilerinin önlenmemesini göz önünde bulundurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="39455-241">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="39455-242">Bu durumlarda, VM tabanlı bir barındırma platformunu veya büyük olasılıkla bazı karma sistemleri göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="39455-242">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="39455-243">Bununla birlikte, belirli işlevsellik parçalarını her zaman ayrı kapsayıcılara veya hatta sunucusuz işlevlere ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-243">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="39455-244">Geliştirme kaynakları</span><span class="sxs-lookup"><span data-stu-id="39455-244">Development resources</span></span>

<span data-ttu-id="39455-245">Bu bölümde, bir sonraki uygulamanız için kapsayıcıları ve düzenlemeleri kullanmaya başlamanıza yardımcı olabilecek geliştirme kaynaklarının kısa bir listesi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="39455-245">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="39455-246">Bulut Yerel mikro hizmetleri mimari uygulamanızı nasıl tasarlayacağımızı öğrenmek istiyorsanız bu kitabın yardımcı, [.net mikro hizmetleri: Kapsayıcılı .NET uygulamaları Için mimari](https://aka.ms/microservicesebook)makalesini okuyun.</span><span class="sxs-lookup"><span data-stu-id="39455-246">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://aka.ms/microservicesebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="39455-247">Yerel Kubernetes geliştirme</span><span class="sxs-lookup"><span data-stu-id="39455-247">Local Kubernetes Development</span></span>

<span data-ttu-id="39455-248">Kubernetes dağıtımları üretim ortamlarında harika bir değer sağlar, ancak geliştirme makinenizde yerel olarak da çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-248">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="39455-249">Bağımsız mikro hizmetlerde bağımsız olarak çalışabilir, ancak üretime dağıtıldığında çalıştırılacak şekilde tüm sistemi yerel olarak çalıştırmanız gereken zamanlar olabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-249">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="39455-250">Yardımcı olabilecek çeşitli araçlar vardır: Minikube ve Docker Desktop.</span><span class="sxs-lookup"><span data-stu-id="39455-250">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="39455-251">Visual Studio, Docker geliştirmesi için de araç sağlar.</span><span class="sxs-lookup"><span data-stu-id="39455-251">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="39455-252">Minikube</span><span class="sxs-lookup"><span data-stu-id="39455-252">Minikube</span></span>

<span data-ttu-id="39455-253">Minikube nedir?</span><span class="sxs-lookup"><span data-stu-id="39455-253">What is Minikube?</span></span> <span data-ttu-id="39455-254">Minikube projesi, "Minikube macOS, Linux ve Windows üzerinde yerel bir Kubernetes kümesi uygular" diyor.</span><span class="sxs-lookup"><span data-stu-id="39455-254">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="39455-255">Birincil hedefleri, "yerel Kubernetes uygulama geliştirmesi için en iyi araç olacak ve sığan Kubernetes özelliklerini desteklemeye yöneliktir."</span><span class="sxs-lookup"><span data-stu-id="39455-255">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="39455-256">Minikube yükleme Docker 'dan ayrıdır, ancak Minikube, Docker Desktop 'ın desteklediğinden farklı hiper yöneticileri destekler.</span><span class="sxs-lookup"><span data-stu-id="39455-256">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="39455-257">Aşağıdaki Kubernetes özellikleri şu anda Minikube tarafından desteklenmektedir:</span><span class="sxs-lookup"><span data-stu-id="39455-257">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="39455-258">DNS</span><span class="sxs-lookup"><span data-stu-id="39455-258">DNS</span></span>
- <span data-ttu-id="39455-259">NodePorts</span><span class="sxs-lookup"><span data-stu-id="39455-259">NodePorts</span></span>
- <span data-ttu-id="39455-260">ConfigMaps ve gizlilikler</span><span class="sxs-lookup"><span data-stu-id="39455-260">ConfigMaps and secrets</span></span>
- <span data-ttu-id="39455-261">Panolar</span><span class="sxs-lookup"><span data-stu-id="39455-261">Dashboards</span></span>
- <span data-ttu-id="39455-262">Kapsayıcı çalışma zamanları: Docker, RKT, CRı-O ve containerd</span><span class="sxs-lookup"><span data-stu-id="39455-262">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="39455-263">Kapsayıcı ağ arabirimini etkinleştirme (CNı)</span><span class="sxs-lookup"><span data-stu-id="39455-263">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="39455-264">Giriş</span><span class="sxs-lookup"><span data-stu-id="39455-264">Ingress</span></span>

<span data-ttu-id="39455-265">Minikube yükledikten sonra, bir görüntüyü yükleyen ve yerel Kubernetes kümesini başlatan `minikube start` komutunu çalıştırarak hızlı bir şekilde kullanmaya başlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-265">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="39455-266">Küme başlatıldıktan sonra, standart Kubernetes `kubectl` komutlarını kullanarak onunla etkileşime geçin.</span><span class="sxs-lookup"><span data-stu-id="39455-266">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="39455-267">Docker Masaüstü</span><span class="sxs-lookup"><span data-stu-id="39455-267">Docker Desktop</span></span>

<span data-ttu-id="39455-268">Ayrıca, Kubernetes ile doğrudan Windows 'daki Docker Desktop 'tan da çalışabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-268">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="39455-269">Windows kapsayıcıları kullanıyorsanız tek seçeneğiniz vardır ve Windows dışı kapsayıcılar için harika bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="39455-269">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="39455-270">Şekil 3-4, Docker Desktop çalıştırılırken yerel Kubernetes desteğinin nasıl etkinleştirileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="39455-270">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![Docker Desktop 'ta Kubernetes 'i yapılandırma](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="39455-272">**Şekil 3-4**.</span><span class="sxs-lookup"><span data-stu-id="39455-272">**Figure 3-4**.</span></span> <span data-ttu-id="39455-273">Docker Desktop 'ta Kubernetes 'i yapılandırma.</span><span class="sxs-lookup"><span data-stu-id="39455-273">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="39455-274">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak yapılandırmaya ve çalıştırmaya yönelik en popüler araçtır.</span><span class="sxs-lookup"><span data-stu-id="39455-274">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="39455-275">Docker Desktop ile çalışırken, üretime dağıtacağınız Docker kapsayıcı görüntüleri kümesine göre yerel olarak geliştirme yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-275">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="39455-276">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak derlemek, test etmek ve teslim etmek üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="39455-276">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="39455-277">Hem Linux hem de Windows kapsayıcılarını destekler.</span><span class="sxs-lookup"><span data-stu-id="39455-277">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="39455-278">Görüntülerinizi Azure Container Registry veya Docker Hub gibi bir görüntü kayıt defterine gönderdikten sonra AKS 'ler onları üretime çekebilir ve bunları dağıtabilir.</span><span class="sxs-lookup"><span data-stu-id="39455-278">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="39455-279">Visual Studio Docker Araçları</span><span class="sxs-lookup"><span data-stu-id="39455-279">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="39455-280">Visual Studio, Web tabanlı uygulamalar için Docker geliştirmeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="39455-280">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="39455-281">Yeni bir ASP.NET Core uygulaması oluşturduğunuzda, Şekil 3-5 ' de gösterildiği gibi, Docker desteğiyle yapılandırma seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="39455-281">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio Docker desteğini etkinleştir](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="39455-283">**Şekil 3-5**.</span><span class="sxs-lookup"><span data-stu-id="39455-283">**Figure 3-5**.</span></span> <span data-ttu-id="39455-284">Visual Studio Docker desteğini etkinleştir</span><span class="sxs-lookup"><span data-stu-id="39455-284">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="39455-285">Bu seçenek belirlendiğinde proje, bir Docker kapsayıcısında uygulamayı derlemek ve `Dockerfile` barındırmak için kullanılabilen bir kökünde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="39455-285">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="39455-286">Şekil 3 -6. git 'de örnek bir Dockerfile gösterilmektedir</span><span class="sxs-lookup"><span data-stu-id="39455-286">An example Dockerfile is shown in Figure 3-6.git</span></span>

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0-stretch AS build
WORKDIR /src
COPY ["WebApplication3/WebApplication3.csproj", "WebApplication3/"]
RUN dotnet restore "WebApplication3/WebApplication3.csproj"
COPY . .
WORKDIR "/src/WebApplication3"
RUN dotnet build "WebApplication3.csproj" -c Release -o /app

FROM build AS publish
RUN dotnet publish "WebApplication3.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication3.dll"]
```

<span data-ttu-id="39455-287">**Şekil 3-6**.</span><span class="sxs-lookup"><span data-stu-id="39455-287">**Figure 3-6**.</span></span> <span data-ttu-id="39455-288">Visual Studio tarafından oluşturulan Dockerfile</span><span class="sxs-lookup"><span data-stu-id="39455-288">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="39455-289">Uygulamanın çalışması için varsayılan davranış, Docker 'ı kullanmak üzere yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="39455-289">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="39455-290">Şekil 3-7, Docker desteği eklenmiş şekilde oluşturulan yeni bir ASP.NET Core projesinden kullanılabilir farklı çalıştırma seçeneklerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="39455-290">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker çalıştırma seçenekleri](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="39455-292">**Şekil 3-7**.</span><span class="sxs-lookup"><span data-stu-id="39455-292">**Figure 3-7**.</span></span> <span data-ttu-id="39455-293">Visual Studio Docker çalıştırma seçenekleri</span><span class="sxs-lookup"><span data-stu-id="39455-293">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="39455-294">[Azure dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) , yerel geliştirmeye ek olarak, birden çok geliştiricinin Azure 'Da kendi Kubernetes yapılandırmalarına göre çalışması için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="39455-294">In addition to local development, [Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="39455-295">Şekil 3-7 ' de görebileceğiniz gibi, uygulamayı Azure Dev Spaces de çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-295">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="39455-296">Ayrıca, dilediğiniz zaman mevcut bir ASP.NET Core uygulamasına Docker desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-296">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="39455-297">Visual Studio Çözüm Gezgini, Şekil 3-8 ' de gösterildiği gibi projeye sağ tıklayın ve**Docker desteği** **ekleyin** > .</span><span class="sxs-lookup"><span data-stu-id="39455-297">From the Visual Studio Solution Explorer, right click on the project and **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio Docker desteği ekle](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="39455-299">**Şekil 3-8**.</span><span class="sxs-lookup"><span data-stu-id="39455-299">**Figure 3-8**.</span></span> <span data-ttu-id="39455-300">Visual Studio Docker desteği ekle</span><span class="sxs-lookup"><span data-stu-id="39455-300">Visual Studio Add Docker Support</span></span>

<span data-ttu-id="39455-301">Ayrıca şekil 3-8 ' de gösterilen kapsayıcı düzenleme desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="39455-301">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="39455-302">Varsayılan olarak Orchestrator, Kubernetes ve Held kullanır.</span><span class="sxs-lookup"><span data-stu-id="39455-302">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="39455-303">Orchestrator 'ı seçtikten sonra proje köküne bir `azds.yaml` dosya eklenir ve uygulamayı yapılandırmak ve Kubernetes 'e dağıtmak Için kullanılan helk grafiklerini içeren bir `charts` klasör eklenir.</span><span class="sxs-lookup"><span data-stu-id="39455-303">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="39455-304">Şekil 3-9 yeni bir projedeki sonuç dosyalarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="39455-304">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio Orchestrator desteği ekle](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="39455-306">**Şekil 3-9**.</span><span class="sxs-lookup"><span data-stu-id="39455-306">**Figure 3-9**.</span></span> <span data-ttu-id="39455-307">Visual Studio Orchestrator desteği ekle</span><span class="sxs-lookup"><span data-stu-id="39455-307">Visual Studio Add Orchestrator Support</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="39455-308">[Önceki](scale-applications.md)
>[İleri](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="39455-308">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
