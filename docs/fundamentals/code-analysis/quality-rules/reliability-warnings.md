---
title: Güvenilirlik kuralları (kod analizi)
description: Kod Analizi güvenilirlik kuralları hakkında bilgi edinin.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.reliabilityrules
helpviewer_keywords:
- rules, reliability
- reliability rules
- managed code analysis rules, reliability rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: a747dd4dcda351a1ddb0f3d069bb7bac895c32f8
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/07/2020
ms.locfileid: "96589438"
---
# <a name="reliability-rules"></a><span data-ttu-id="7b4f1-103">Güvenilirlik kuralları</span><span class="sxs-lookup"><span data-stu-id="7b4f1-103">Reliability rules</span></span>

<span data-ttu-id="7b4f1-104">Güvenilirlik kuralları, doğru bellek ve iş parçacığı kullanımı gibi kitaplık ve uygulama güvenilirliğini destekler.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-104">Reliability rules support library and application reliability, such as correct memory and thread usage.</span></span> <span data-ttu-id="7b4f1-105">Güvenilirlik kuralları şunları içerir:</span><span class="sxs-lookup"><span data-stu-id="7b4f1-105">The reliability rules include:</span></span>

|<span data-ttu-id="7b4f1-106">Kural</span><span class="sxs-lookup"><span data-stu-id="7b4f1-106">Rule</span></span>|<span data-ttu-id="7b4f1-107">Açıklama</span><span class="sxs-lookup"><span data-stu-id="7b4f1-107">Description</span></span>|
|----------|-----------------|
|[<span data-ttu-id="7b4f1-108">CA2000: Kapsamı kaybetmeden önce nesneleri bırakın</span><span class="sxs-lookup"><span data-stu-id="7b4f1-108">CA2000: Dispose objects before losing scope</span></span>](ca2000.md)|<span data-ttu-id="7b4f1-109">Bir nesnenin sonlandırıcısının çalışmasını engelleyecek olağanüstü bir durum gerçekleşebileceği için, nesne ona olan tüm başvurular kapsam dışına çıkmadan açıkça atılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-109">Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</span></span>|
|[<span data-ttu-id="7b4f1-110">CA2002: Zayıf kimliği olan nesneleri kilitlemeyin</span><span class="sxs-lookup"><span data-stu-id="7b4f1-110">CA2002: Do not lock on objects with weak identity</span></span>](ca2002.md)|<span data-ttu-id="7b4f1-111">Bir nesneye uygulama etki alanları arasından erişilebiliyorsa o nesnenin zayıf bir kimliğe sahip olduğu söylenir.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-111">An object is said to have a weak identity when it can be directly accessed across application domain boundaries.</span></span> <span data-ttu-id="7b4f1-112">Zayıf kimliğe sahip bir nesne üzerinde kilit almayı deneyen iş parçacığı aynı nesne üzerinde bir kilide sahip olan farklı uygulama etki alanı içindeki ikinci iş parçacığı tarafından engellenebilir.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-112">A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</span></span>|
|[<span data-ttu-id="7b4f1-113">CA2007: Doğrudan bir Görevi beklemeyin</span><span class="sxs-lookup"><span data-stu-id="7b4f1-113">CA2007: Do not directly await a Task</span></span>](ca2007.md)|<span data-ttu-id="7b4f1-114">Zaman uyumsuz bir [awaits](../../../csharp/language-reference/operators/await.md) yöntem doğrudan bekler <xref:System.Threading.Tasks.Task> .</span><span class="sxs-lookup"><span data-stu-id="7b4f1-114">An asynchronous method [awaits](../../../csharp/language-reference/operators/await.md) a <xref:System.Threading.Tasks.Task> directly.</span></span>|
|[<span data-ttu-id="7b4f1-115">CA2008: TaskScheduler geçirmeden görev oluşturmayın</span><span class="sxs-lookup"><span data-stu-id="7b4f1-115">CA2008: Do not create tasks without passing a TaskScheduler</span></span>](ca2008.md)|<span data-ttu-id="7b4f1-116">Bir görev oluşturma veya devamlılık işlemi, bir parametre belirtmeyen bir yöntem aşırı yüklemesi kullanır <xref:System.Threading.Tasks.TaskScheduler> .</span><span class="sxs-lookup"><span data-stu-id="7b4f1-116">A task creation or continuation operation uses a method overload that does not specify a <xref:System.Threading.Tasks.TaskScheduler> parameter.</span></span>|
|[<span data-ttu-id="7b4f1-117">CA2009: Bir ImmutableCollection değeri üzerinde ToImmutableCollection çağırma</span><span class="sxs-lookup"><span data-stu-id="7b4f1-117">CA2009: Do not call ToImmutableCollection on an ImmutableCollection value</span></span>](ca2009.md)|<span data-ttu-id="7b4f1-118">`ToImmutable` Yöntem, ad alanından sabit bir koleksiyonda gereksiz şekilde çağrıldı <xref:System.Collections.Immutable> .</span><span class="sxs-lookup"><span data-stu-id="7b4f1-118">`ToImmutable` method was unnecessarily called on an immutable collection from <xref:System.Collections.Immutable> namespace.</span></span>|
|[<span data-ttu-id="7b4f1-119">CA2011: Özelliği, ayarlayıcısı içinde atama</span><span class="sxs-lookup"><span data-stu-id="7b4f1-119">CA2011: Do not assign property within its setter</span></span>](ca2011.md) | <span data-ttu-id="7b4f1-120">Bir özelliğe yanlışlıkla kendi [set erişimcisi](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor)içinde bir değer atandı.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-120">A property was accidentally assigned a value within its own [set accessor](../../../csharp/programming-guide/classes-and-structs/using-properties.md#the-set-accessor).</span></span> |
|[<span data-ttu-id="7b4f1-121">CA2012: ValueTask’leri doğru kullanın</span><span class="sxs-lookup"><span data-stu-id="7b4f1-121">CA2012: Use ValueTasks correctly</span></span>](ca2012.md) | <span data-ttu-id="7b4f1-122">Üye etkinleştirmeleri tarafından döndürülen ValueTasks, doğrudan beklenmek üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-122">ValueTasks returned from member invocations are intended to be directly awaited.</span></span>  <span data-ttu-id="7b4f1-123">Bir ValueTask 'ı birden çok kez kullanmaya çalışır veya tamamlanması bilinmadan önce bir sonuca doğrudan erişmek için bir özel durumla veya bozulmaya neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-123">Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.</span></span>  <span data-ttu-id="7b4f1-124">Bu tür bir ValueTask, büyük olasılıkla işlevsel bir hatanın göstergesidir ve performansın düşmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-124">Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.</span></span> |
|[<span data-ttu-id="7b4f1-125">CA2013: ReferenceEquals metodunu değer türleriyle birlikte kullanmayın</span><span class="sxs-lookup"><span data-stu-id="7b4f1-125">CA2013: Do not use ReferenceEquals with value types</span></span>](ca2013.md) | <span data-ttu-id="7b4f1-126">Kullanılarak değerler karşılaştırılırken <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> , objA ve objB değer türlerseler, yönteme geçirilmeden önce bunlar paketlenirler <xref:System.Object.ReferenceEquals%2A> .</span><span class="sxs-lookup"><span data-stu-id="7b4f1-126">When comparing values using <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName>, if objA and objB are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="7b4f1-127">Bu, hem objA hem de objB bir değer türünün aynı örneğini temsil ediyorsa bile, <xref:System.Object.ReferenceEquals%2A> Yöntem false değerini döndürür.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-127">This means that even if both objA and objB represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns false.</span></span> |
|[<span data-ttu-id="7b4f1-128">CA2014: Döngülerde stackalloc kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-128">CA2014: Do not use stackalloc in loops.</span></span>](ca2014.md) | <span data-ttu-id="7b4f1-129">Bir stackalloc tarafından ayrılan yığın alanı yalnızca geçerli metodun çağrısının sonunda serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-129">Stack space allocated by a stackalloc is only released at the end of the current method's invocation.</span></span>  <span data-ttu-id="7b4f1-130">Bunu bir döngüde kullanmak, sınırsız yığın büyümesi ve nihai yığın taşması koşullarına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-130">Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.</span></span> |
|[<span data-ttu-id="7b4f1-131">CA2015: MemoryManager T 'den türetilmiş türler için sonlandırıcılar tanımlama &lt;&gt;</span><span class="sxs-lookup"><span data-stu-id="7b4f1-131">CA2015: Do not define finalizers for types derived from MemoryManager&lt;T&gt;</span></span>](ca2015.md) | <span data-ttu-id="7b4f1-132">' Dan türetilmiş bir türe Sonlandırıcı eklemek <xref:System.Buffers.MemoryManager%601> , bir tarafından kullanılmaya devam edilirken belleğin serbest olmasına izin verebilir <xref:System.Span%601> .</span><span class="sxs-lookup"><span data-stu-id="7b4f1-132">Adding a finalizer to a type derived from <xref:System.Buffers.MemoryManager%601> may permit memory to be freed while it is still in use by a <xref:System.Span%601>.</span></span> |
|[<span data-ttu-id="7b4f1-133">CA2016: CancellationToken parametresini, parametre alan metotlara iletin</span><span class="sxs-lookup"><span data-stu-id="7b4f1-133">CA2016: Forward the CancellationToken parameter to methods that take one</span></span>](ca2016.md) | <span data-ttu-id="7b4f1-134">`CancellationToken`İşlem iptal bildirimlerinin düzgün şekilde yayıldığından emin olmak için parametreyi bir tane alan yöntemlere iletin veya `CancellationToken.None` açıkça belirteci yaymadığınızı belirtmek için açıkça geçiş yapın.</span><span class="sxs-lookup"><span data-stu-id="7b4f1-134">Forward the `CancellationToken` parameter to methods that take one to ensure the operation cancellation notifications gets properly propagated, or pass in `CancellationToken.None` explicitly to indicate intentionally not propagating the token.</span></span> |
