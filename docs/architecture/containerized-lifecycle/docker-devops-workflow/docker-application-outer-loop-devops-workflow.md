---
title: Bir Docker uygulaması için dış döngü DevOps iş akışındaki adımlar
description: DevOps iş akışının "dış döngü" adımlarını öğrenin
ms.date: 02/15/2019
ms.openlocfilehash: 735f92c00cd6279649ec3b0c35cfb00543f21a8c
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "75936776"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="89f69-103">Bir Docker uygulaması için dış döngü DevOps iş akışındaki adımlar</span><span class="sxs-lookup"><span data-stu-id="89f69-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="89f69-104">Şekil 5-1, DevOps dış döngü iş akışını içeren adımların uçtan uca bir tasvirini sunar.</span><span class="sxs-lookup"><span data-stu-id="89f69-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span> <span data-ttu-id="89f69-105">DevOps'un "dış halkasını" gösterir.</span><span class="sxs-lookup"><span data-stu-id="89f69-105">It shows the "outer loop" of DevOps.</span></span> <span data-ttu-id="89f69-106">Kod repo'ya itildiğinde, bir CI ardışık hattı başlatılır ve ardından uygulamanın dağıtıldığı CD ardışık</span><span class="sxs-lookup"><span data-stu-id="89f69-106">When code is pushed to the repo, a CI pipeline is started, then begins the CD pipeline, where the application gets deployed.</span></span> <span data-ttu-id="89f69-107">Dağıtılan uygulamalardan toplanan ölçümler, "iç döngü"nün oluştuğu geliştirme iş yüküne geri beslenir, bu nedenle geliştirme ekipleri kullanıcı ve iş gereksinimlerine yanıt vermek için gerçek verilere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="89f69-107">Metrics collected from deployed applications are fed back into the development workload, where the "inner loop" occurs, so development teams have actual data to respond to user and business needs.</span></span>

![DevOps dış döngü iş akışının 6 adımını gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/overview-dev-ops-outter-loop-workflow.png)

<span data-ttu-id="89f69-109">**Şekil 5-1**.</span><span class="sxs-lookup"><span data-stu-id="89f69-109">**Figure 5-1**.</span></span> <span data-ttu-id="89f69-110">Microsoft araçları yla Docker uygulamaları için DevOps dış döngü iş akışı</span><span class="sxs-lookup"><span data-stu-id="89f69-110">DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="89f69-111">Şimdi, bu adımların her birini daha ayrıntılı olarak inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="89f69-111">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="89f69-112">Adım 1: İç-döngü geliştirme iş akışı</span><span class="sxs-lookup"><span data-stu-id="89f69-112">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="89f69-113">Bu adım Bölüm 4'te ayrıntılı olarak açıklanmıştır, ancak özetlemek gerekirse, burada dış döngü nün başladığı yer, bir geliştiricinin KODU KAYNAK Denetim Yönetim Sistemi'ne (Git gibi) ittiği an, CI boru hattı eylemlerini başlatMıştır.</span><span class="sxs-lookup"><span data-stu-id="89f69-113">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="89f69-114">Adım 2: Azure DevOps Hizmetleri ve Git ile Kaynak Kod Denetimi entegrasyonu ve yönetimi</span><span class="sxs-lookup"><span data-stu-id="89f69-114">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="89f69-115">Bu adımda, takımdaki farklı geliştiricilerden gelen tüm kodun birleştirilmiş sürümünü toplamak için bir sürüm denetim sistemine sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="89f69-115">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="89f69-116">Kaynak kod denetimi (SCC) ve kaynak kod yönetimi çoğu geliştirici için ikinci doğa gibi görünse de, DevOps yaşam döngüsünde Docker uygulamaları oluştururken, Docker görüntülerini uygulamayla birlikte göndermemeniz gerektiğini vurgulamak çok önemlidir doğrudan geliştiricinin makinesinden küresel Docker Registry'ye (Azure Konteyner Kayıt Defteri veya Docker Hub gibi) yerleştirin.</span><span class="sxs-lookup"><span data-stu-id="89f69-116">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it's critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="89f69-117">Tam tersine, piyasaya sürülecek ve üretim ortamlarına dağıtılacak Docker görüntüleri, yalnızca kaynak kod deponuza (Git gibi) dayalı olarak küresel yapınıza veya CI ardışık hattınıza entegre edilen kaynak kodunda oluşturulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="89f69-117">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that's being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="89f69-118">Geliştiriciler tarafından oluşturulan yerel görüntüler, sadece kendi makineleri içinde test ederken onlar tarafından kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="89f69-118">The local images, generated by developers, should just be used by them when testing within their own machines.</span></span> <span data-ttu-id="89f69-119">Bu yüzden DevOps boru hattının SCC kodundan aktif hale getirilmiş olması çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="89f69-119">That's why it's critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="89f69-120">Azure DevOps Hizmetleri ve Team Foundation Server, Git ve Team Foundation Sürüm Denetimini destekler.</span><span class="sxs-lookup"><span data-stu-id="89f69-120">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="89f69-121">Aralarında seçim yapabilir ve uça bir Microsoft deneyimi için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-121">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="89f69-122">Ancak, kodunuzu harici depolarda (GitHub, şirket içi Git depoları veya Subversion gibi) yönetebilir ve yine de bu depoya bağlanabilir ve Kodu DevOps CI ardışık ardınız için başlangıç noktası olarak alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-122">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="89f69-123">Adım 3: Azure DevOps Hizmetleri ve Docker ile Oluşturma, CI, Tümleştirme ve Test</span><span class="sxs-lookup"><span data-stu-id="89f69-123">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="89f69-124">CI modern yazılım testi ve teslimat için bir standart olarak ortaya çıkmıştır.</span><span class="sxs-lookup"><span data-stu-id="89f69-124">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="89f69-125">Docker çözümü, geliştirme ve operasyon ekipleri arasındaki endişeleri net bir şekilde birbirinden korur.</span><span class="sxs-lookup"><span data-stu-id="89f69-125">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="89f69-126">Docker görüntülerinin değişmezliği, geliştirilen, CI aracılığıyla test edilen ve üretimde çalışan arasında tekrarlanabilir bir dağıtım sağlar.</span><span class="sxs-lookup"><span data-stu-id="89f69-126">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="89f69-127">Docker Engine geliştirici dizüstü bilgisayarlar ve test altyapısı arasında dağıtılan kapsayıcılar ortamlar arasında taşınabilir hale getirir.</span><span class="sxs-lookup"><span data-stu-id="89f69-127">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="89f69-128">Bu noktada, gönderilen doğru kodu içeren bir sürüm denetim sistemine sahip olduktan sonra, kodu almak ve genel yapı ve testleri çalıştırmak için bir *yapı hizmetine* ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="89f69-128">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="89f69-129">Bu adımiçin dahili iş akışı (CI, inşa, test) kod deponuz (Git, vb.), yapı sunucunuz (Azure DevOps Hizmetleri), Docker Engine ve Docker Registry'nizden oluşan bir CI ardışık hattının inşası ile ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="89f69-129">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="89f69-130">Azure DevOps Hizmetlerini, uygulamalarınızı oluşturmak ve CI ardınızı ayarlamak ve inşa edilen "yapıları" bir sonraki adımda açıklanan bir "yapı deposuna" yayımlamak için temel olarak kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-130">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="89f69-131">Dağıtım için Docker'ı kullanırken, dağıtılacak "son yapılar" uygulamanızın veya hizmetlerinizin içinde gömülü olduğu Docker görüntüleridir.</span><span class="sxs-lookup"><span data-stu-id="89f69-131">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="89f69-132">Bu görüntüler, Docker *Registry'ye* (Azure Konteyner Kayıt Defteri'nde sahip olabileceğiniz özel bir depo veya resmi temel resimler için yaygın olarak kullanılan Docker Hub Kayıt Defteri gibi herkese açık bir depo) itilir veya yayımlanır.</span><span class="sxs-lookup"><span data-stu-id="89f69-132">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="89f69-133">Burada temel kavram: CI boru hattı git gibi bir SCC deposu na taahhüt tarafından başladı olacak.</span><span class="sxs-lookup"><span data-stu-id="89f69-133">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="89f69-134">Taahhüt, Azure DevOps Hizmetlerinin bir Docker kapsayıcısı içinde bir yapı işi çalıştırmasını ve bu işi başarıyla tamamladıktan sonra Şekil 5-2'de gösterildiği gibi Docker görüntüsünü Docker Registry'ye itmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="89f69-134">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span> <span data-ttu-id="89f69-135">Dış döngünün ilk bölümü, kod, çalıştır, hata ayıklama ve doğrulama, ardından kod repo'su oluşturma ve test CI adımına kadar 1'den 3'e kadar olan adımları içerir.</span><span class="sxs-lookup"><span data-stu-id="89f69-135">The first part of the outer loop involves steps 1 to 3, from code, run, debug and validate, then the code repo up to the build and test CI step.</span></span>

![CI iş akışında yer alan üç adımı gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/continuous-integration-steps.png)

<span data-ttu-id="89f69-137">**Şekil 5-2**.</span><span class="sxs-lookup"><span data-stu-id="89f69-137">**Figure 5-2**.</span></span> <span data-ttu-id="89f69-138">CI dahil adımlar</span><span class="sxs-lookup"><span data-stu-id="89f69-138">The steps involved in CI</span></span>

<span data-ttu-id="89f69-139">Docker ve Azure DevOps Hizmetleri ile temel CI iş akışı adımları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="89f69-139">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1. <span data-ttu-id="89f69-140">Geliştirici bir SCC deposuna (Git/Azure DevOps Hizmetleri, GitHub, vb.) taahhüt eder.</span><span class="sxs-lookup"><span data-stu-id="89f69-140">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2. <span data-ttu-id="89f69-141">Azure DevOps Services veya Git kullanıyorsanız, CI yerleşiktir, bu da Azure DevOps Hizmetlerinde onay kutusu seçmek kadar basit olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="89f69-141">If you're using Azure DevOps Services or Git, CI is built in, which means that it's as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="89f69-142">Harici bir SCC kullanıyorsanız (GitHub gibi), azure `webhook` DevOps Hizmetlerini güncelleştirmehakkında bilgilendirecek veya Git/GitHub'a itecektir.</span><span class="sxs-lookup"><span data-stu-id="89f69-142">If you're using an external SCC (like GitHub), a `webhook` will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3. <span data-ttu-id="89f69-143">Azure DevOps Hizmetleri, görüntüyü açıklayan Dockerfile'ın yanı sıra uygulama ve test kodu da dahil olmak üzere SCC deposunu çeker.</span><span class="sxs-lookup"><span data-stu-id="89f69-143">Azure DevOps Services pulls the SCC repository, including the Dockerfile describing the image, as well as the application and test code.</span></span>

4. <span data-ttu-id="89f69-144">Azure DevOps Hizmetleri bir Docker görüntüsü oluşturur ve bir yapı numarasıyla etiketler.</span><span class="sxs-lookup"><span data-stu-id="89f69-144">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5. <span data-ttu-id="89f69-145">Azure DevOps Hizmetleri, Docker konteynerini sağlanan Docker Host'ta anında kullanır ve uygun testleri çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="89f69-145">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6. <span data-ttu-id="89f69-146">Testler başarılı olursa, görüntü önce anlamlı bir ada yeniden etiketlenir, böylece "kutsanmış yapı" ("/1.0.0" veya başka bir etiket gibi) olduğunu bilmeniz ve ardından Docker Registry'nize (Docker Hub, Azure Konteyner Kayıt Defteri, DTR, vb.) itilir.</span><span class="sxs-lookup"><span data-stu-id="89f69-146">If the tests are successful, the image is first relabeled to a meaningful name so that you know it's a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="89f69-147">Azure DevOps Hizmetleri ve Azure DevOps Hizmetleri için Docker uzantısı ile CI ardışık hattını uygulama</span><span class="sxs-lookup"><span data-stu-id="89f69-147">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="89f69-148">Visual Studio Azure DevOps Hizmetleri, Docker görüntüleri oluşturabileceğiniz, Docker görüntülerini kimlik doğrulanmış docker kayıt defterine taşıyabileceğiniz, Docker görüntülerini çalıştırabileceğiniz veya Docker CLI tarafından sunulan diğer işlemleri çalıştırabileceğiniz CI/CD ardışık ardışık ardışık ardışık ardışık ardışık ğınızda kullanabileceğiniz Yapı & Sürüm Şablonları içerir.</span><span class="sxs-lookup"><span data-stu-id="89f69-148">Visual Studio Azure DevOps Services contains Build & Release Templates that you can use in your CI/CD pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="89f69-149">Ayrıca, şekil 5-3'te gösterildiği gibi, çok kapsayıcı Docker uygulamalarını oluşturmak, itmek ve çalıştırmak veya Docker Compose CLI tarafından sunulan diğer işlemleri çalıştırmak için kullanabileceğiniz bir Docker Compose görevi de ekler.</span><span class="sxs-lookup"><span data-stu-id="89f69-149">It also adds a Docker Compose task that you can use to build, push, and run multi-container Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![Azure DevOps'taki Docker CI boru hattının ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/docker-ci-pipeline-azure-devops.png)

<span data-ttu-id="89f69-151">**Şekil 5-3**.</span><span class="sxs-lookup"><span data-stu-id="89f69-151">**Figure 5-3**.</span></span> <span data-ttu-id="89f69-152">Yapı & Sürüm Şablonları ve ilişkili görevler de dahil olmak üzere Azure DevOps Hizmetlerinde Docker CI ardışık hattı.</span><span class="sxs-lookup"><span data-stu-id="89f69-152">The Docker CI pipeline in Azure DevOps Services including Build & Release Templates and associated tasks.</span></span>

<span data-ttu-id="89f69-153">Bu şablonları ve görevleri, Azure Hizmet Kumaşı, Azure Kubernetes Hizmeti ve benzeri teklifleroluşturmak/ test etmek ve dağıtmak için CI/CD yapılarınızı oluşturmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-153">You can use these templates and tasks to construct your CI/CD artifacts to Build / Test and Deploy in Azure Service Fabric, Azure Kubernetes Service, and similar offerings.</span></span>

<span data-ttu-id="89f69-154">Bu Visual Studio Takım Hizmetleri görevleri, Azure'da sağlanan bir Linux-Docker Host/VM ve tercih ettiğiniz Docker kayıt defteri (Azure Konteyner Kayıt Defteri, Docker Hub, özel Docker DTR veya diğer Docker kayıt defteri) ile Docker CI boru hattınızı çok tutarlı bir şekilde monte edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-154">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="89f69-155">***Gereksinim -leri:***</span><span class="sxs-lookup"><span data-stu-id="89f69-155">***Requirements:***</span></span>

- <span data-ttu-id="89f69-156">Azure DevOps Hizmetleri veya şirket içi yüklemeler için Team Foundation Server 2015 Update 3 veya sonraki.</span><span class="sxs-lookup"><span data-stu-id="89f69-156">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

- <span data-ttu-id="89f69-157">Docker ikililerine sahip bir Azure DevOps Hizmetleri aracısı.</span><span class="sxs-lookup"><span data-stu-id="89f69-157">An Azure DevOps Services agent that has the Docker binaries.</span></span>

  <span data-ttu-id="89f69-158">Bu aracılardan birini oluşturmanın kolay bir yolu, Azure DevOps Hizmetleri aracısı Docker görüntüsünü temel alan bir kapsayıcıyı çalıştırmak için Docker'ı kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="89f69-158">An easy way to create one of these agents is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

> <span data-ttu-id="89f69-159">[! BİlGİ: Azure DevOps Services Docker CI ardışık hattını birleştirme hakkında daha fazla bilgi almak ve iz geçitleri görüntülemek için aşağıdaki siteleri ziyaret edin:</span><span class="sxs-lookup"><span data-stu-id="89f69-159">[!INFORMATION] To read more about assembling an Azure DevOps Services Docker CI pipeline and view the walkthroughs, visit these sites:</span></span>
>
> - <span data-ttu-id="89f69-160">Docker konteyneri olarak Visual Studio Takım Hizmetleri (Şimdi Azure DevOps Hizmetleri) aracısı çalıştırma: </span><span class="sxs-lookup"><span data-stu-id="89f69-160">Running a Visual Studio Team Services (Now Azure DevOps Services) agent as a Docker container: </span></span>\
>   <https://hub.docker.com/_/microsoft-azure-pipelines-vsts-agent>
>
> - <span data-ttu-id="89f69-161">Azure DevOps Hizmetleri ile .NET Core Linux Docker görüntüleri oluşturma: </span><span class="sxs-lookup"><span data-stu-id="89f69-161">Building .NET Core Linux Docker images with Azure DevOps Services: </span></span>\
>   <https://docs.microsoft.com/archive/blogs/stevelasker/building-net-core-linux-docker-images-with-visual-studio-team-services>
>
> - <span data-ttu-id="89f69-162">Docker desteği ile Linux tabanlı Visual Studio Team Service inşa makinesi oluşturma: </span><span class="sxs-lookup"><span data-stu-id="89f69-162">Building a Linux-based Visual Studio Team Service build machine with Docker support: </span></span>\
>   <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support>

### <a name="integrate-test-and-validate-multi-container-docker-applications"></a><span data-ttu-id="89f69-163">Çoklu kapsayıcı Docker uygulamalarını tümleştirin, test edin ve doğrulayın</span><span class="sxs-lookup"><span data-stu-id="89f69-163">Integrate, test, and validate multi-container Docker applications</span></span>

<span data-ttu-id="89f69-164">Genellikle, çoğu Docker uygulamaları tek bir kapsayıcı yerine birden çok kapsayıcıoluşur.</span><span class="sxs-lookup"><span data-stu-id="89f69-164">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="89f69-165">İyi bir örnek, mikrohizmet başına bir konteyner olurdu için mikro hizmetler odaklı bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="89f69-165">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="89f69-166">Ancak, mikro hizmetler yaklaşım modellerini kesinlikle takip etmeden bile Docker uygulamanızın birden fazla kapsayıcı veya hizmetten oluşması olasıdır.</span><span class="sxs-lookup"><span data-stu-id="89f69-166">But, even without strictly following the microservices approach patterns, it's probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="89f69-167">Bu nedenle, CI boru hattında uygulama kapsayıcıları inşa ettikten sonra, aynı zamanda dağıtmak gerekir, entegre ve bir entegrasyon Docker ana bilgisayar içinde tüm kapları ile bir bütün olarak uygulama entegre ve hatta konteynerler hangi bir test kümesi içine Dağıtılmış.</span><span class="sxs-lookup"><span data-stu-id="89f69-167">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="89f69-168">Tek bir ana bilgisayar kullanıyorsanız, docker-compose gibi Docker komutlarını kullanarak ilgili kapsayıcıları tek bir VM'de Docker ortamını test etmek ve doğrulamak için dağıtabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-168">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="89f69-169">Ancak, DC/OS, Kubernetes veya Docker Swarm gibi bir orkestratör kümesiyle çalışıyorsanız, seçtiğiniz küme/zamanlayıcıya bağlı olarak kapsayıcılarınızı farklı bir mekanizma veya orkestratör aracılığıyla dağıtmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="89f69-169">But, if you're working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="89f69-170">Docker kapsayıcılarına karşı çalıştırabileceğiniz çeşitli test türleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="89f69-170">The following are several types of tests that you can run against Docker containers:</span></span>

- <span data-ttu-id="89f69-171">Docker konteynerleri için birim testleri</span><span class="sxs-lookup"><span data-stu-id="89f69-171">Unit tests for Docker containers</span></span>

- <span data-ttu-id="89f69-172">Birbiriyle ilişkili uygulamaların veya mikro hizmetlerin test grupları</span><span class="sxs-lookup"><span data-stu-id="89f69-172">Testing groups of interrelated applications or microservices</span></span>

- <span data-ttu-id="89f69-173">Üretim testi ve "kanarya" bültenleri</span><span class="sxs-lookup"><span data-stu-id="89f69-173">Test in production and "canary" releases</span></span>

<span data-ttu-id="89f69-174">Önemli nokta, tümleştirme ve işlevsel testleri çalıştırırken, bu testleri kapsayıcıların dışından çalıştırmanız gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="89f69-174">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="89f69-175">Kapsayıcılar, üretime dağıtacağınız kaplara tam olarak benzeyen statik görüntülere dayandığından, testler içermez veya dağıtacağınız kapsayıcılarda çalıştırılamaz.</span><span class="sxs-lookup"><span data-stu-id="89f69-175">Tests are not contained or run in the containers you're deploying, because the containers are based on static images that should be exactly like the ones you'll be deploying to production.</span></span>

<span data-ttu-id="89f69-176">Birkaç küme (test kümesi, hazırlama kümesi ve üretim kümesi) gibi daha gelişmiş senaryoları sınarken pratik bir seçenek, görüntüleri bir kayıt defterine yayımlamaktır, böylece çeşitli kümelerde sınanabilir.</span><span class="sxs-lookup"><span data-stu-id="89f69-176">A practical option when testing more advanced scenarios, like including several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry, so it can be tested in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="89f69-177">Özel uygulama Docker imajını küresel Docker Registry'nize itin</span><span class="sxs-lookup"><span data-stu-id="89f69-177">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="89f69-178">Docker görüntüleri test edildikten ve doğrulandıktan sonra, bunları etiketlemek ve Docker kayıt defterinize yayınlamak isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-178">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="89f69-179">Docker kayıt defteri Docker uygulama yaşam döngüsünde kritik bir parçadır, çünkü ÖZEL TESTINIZI ("kutsanmış görüntüler" olarak da bilinir) QA ve üretim ortamlarına dağıtılmak üzere depoladığınız merkezi yerdir.</span><span class="sxs-lookup"><span data-stu-id="89f69-179">The Docker registry is a critical piece in the Docker application life cycle because it's the central place where you store your custom test (also known as "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="89f69-180">SCC deponuzda (Git, vb.) depolanan uygulama kodunun sizin "doğruluk kaynağınız" olması gibi, Docker kayıt defteri de ikili uygulamanız veya bitlerinizin QA veya üretim ortamlarına dağıtılması için "doğruluk kaynağınız"dır.</span><span class="sxs-lookup"><span data-stu-id="89f69-180">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="89f69-181">Tipik olarak, özel görüntüleriniz için özel depolarınızı Azure Kapsayıcı Kayıt Defteri'ndeki özel bir depoda veya Docker Trusted Registry gibi bir şirket içi kayıt defterinde veya kısıtlı erişime sahip genel bulut kayıt defterinde bulundurmak isteyebilirsiniz (örneğin, Docker Hub), bu son durumda kodunuz açık kaynak değilse, satıcının güvenliğine güvenmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="89f69-181">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="89f69-182">Her iki durumda da, kullandığınız yöntem benzerdir ve Şekil 5-4'te gösterildiği gibi komutu `docker push` temel alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-182">Either way, the method you use is similar and is based on the `docker push` command, as shown in Figure 5-4.</span></span>

![Özel görüntülerin bir kapsayıcı kayıt defterine itmesini gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/docker-push-custom-images.png)

<span data-ttu-id="89f69-184">**Şekil 5-4**.</span><span class="sxs-lookup"><span data-stu-id="89f69-184">**Figure 5-4**.</span></span> <span data-ttu-id="89f69-185">Docker Registry'ye özel görüntüler yayınlama</span><span class="sxs-lookup"><span data-stu-id="89f69-185">Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="89f69-186">3. adımda, bina tümleştirmesi ve sınama (CI) için ortaya çıkan docker görüntülerini özel veya genel kayıt defterine yayımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-186">In step 3, for building integration and testing (CI) you might publish the resulting docker images to a private or public registry.</span></span> <span data-ttu-id="89f69-187">Azure Konteyner Kayıt Defteri, Amazon Web Hizmetleri Konteyner Kayıt Defteri, Google Konteyner Kayıt Defteri, Quay Registry gibi bulut satıcılarından birden fazla Docker kayıt şirketi teklifi vardır.</span><span class="sxs-lookup"><span data-stu-id="89f69-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="89f69-188">Docker görevlerini kullanarak, bir `docker-compose.yml` dosya tarafından tanımlanan ve birden çok etiketiçeren bir hizmet görsel kümesini Şekil 5-5'te gösterildiği gibi kimlik doğrulaması alınmış docker kayıt defterine (Azure Konteyner Kayıt Defteri gibi) taşıyabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-188">Using the Docker tasks, you can push a set of service images defined by a `docker-compose.yml` file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![Görüntüleri kayıt defterine yayımlama adımını gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/publish-custom-image-to-docker-registry.png)

<span data-ttu-id="89f69-190">**Şekil 5-5**.</span><span class="sxs-lookup"><span data-stu-id="89f69-190">**Figure 5-5**.</span></span> <span data-ttu-id="89f69-191">Docker Kayıt Defterine özel görüntüler yayınlamak için Azure DevOps Hizmetlerini kullanma</span><span class="sxs-lookup"><span data-stu-id="89f69-191">Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

> <span data-ttu-id="89f69-192">[! BİlGİ: Azure Kapsayıcı Kayıt Defteri <https://aka.ms/azurecontainerregistry>hakkında daha fazla bilgi için bkz.</span><span class="sxs-lookup"><span data-stu-id="89f69-192">[!INFORMATION] For more information about Azure Container Registry, see <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="89f69-193">Adım 4: CD, Dağıtım</span><span class="sxs-lookup"><span data-stu-id="89f69-193">Step 4: CD, Deploy</span></span>

<span data-ttu-id="89f69-194">Docker görüntülerinin değişmezliği, geliştirilen, CI aracılığıyla test edilen ve üretimde çalışan larla tekrarlanabilir bir dağıtım sağlar.</span><span class="sxs-lookup"><span data-stu-id="89f69-194">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="89f69-195">Docker kayıt defterinizde yayınlanan uygulama Docker görüntülerini (özel veya herkese açık) yayımladıktan sonra, bunları Azure DevOps Hizmetlerini kullanarak CD ardışık ardınızdan sahip olabileceğiniz çeşitli ortamlara (üretim, QA, evreleme, vb.) dağıtabilirsiniz. boru hattı görevleri veya Azure DevOps Hizmetleri Yayın Yönetimi.</span><span class="sxs-lookup"><span data-stu-id="89f69-195">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="89f69-196">Ancak, bu noktada bu, ne tür Docker uygulaması dağıttığınız için bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="89f69-196">However, at this point it depends on what kind of Docker application you're deploying.</span></span> <span data-ttu-id="89f69-197">Birkaç kapsayıcı veya hizmetten oluşan ve birkaç sunucuya veya VM'ye dağıtılan yekpare bir uygulama gibi basit bir uygulamayı (kompozisyon ve dağıtım açısından) dağıtmak, daha karmaşık bir uygulamayı hiperölçekli yetenekleri ile mikrohizmet odaklı uygulama.</span><span class="sxs-lookup"><span data-stu-id="89f69-197">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="89f69-198">Bu iki senaryo aşağıdaki bölümlerde açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="89f69-198">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="89f69-199">Oluşan Docker uygulamalarını birden çok Docker ortamına dağıtma</span><span class="sxs-lookup"><span data-stu-id="89f69-199">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="89f69-200">Önce daha az karmaşık olan senaryoya bakalım: basit Docker ana bilgisayarlarına (VM'ler veya sunucular) tek bir ortamda veya birden çok ortamda (QA, evreleme ve üretim) dağıtım.</span><span class="sxs-lookup"><span data-stu-id="89f69-200">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="89f69-201">Bu senaryoda, CD ardınız, Şekil 5-6'da gösterildiği gibi Docker uygulamalarını ilgili kapsayıcı veya hizmet kümesiyle dağıtmak için docker-compose'i (Azure DevOps Hizmetleri dağıtım görevlerinizden) kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="89f69-201">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![Üç ortama dağıtılabasma adımını gösteren CD diyagramı.](./media/docker-application-outer-loop-devops-workflow/deploy-app-containers-to-docker-host-environments.png)

<span data-ttu-id="89f69-203">**Şekil 5-6**.</span><span class="sxs-lookup"><span data-stu-id="89f69-203">**Figure 5-6**.</span></span> <span data-ttu-id="89f69-204">Uygulama kaplarını basit Docker ana bilgisayar ortamları kayıt defterine dağıtma</span><span class="sxs-lookup"><span data-stu-id="89f69-204">Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="89f69-205">Şekil 5-7, Görev Ekle iletişim kutusunda Docker Oluştur'u tıklatarak yapı CI'nizi Azure DevOps Hizmetleri aracılığıyla QA/test ortamlarına nasıl bağleyebileceğinizin altını çiziyor.</span><span class="sxs-lookup"><span data-stu-id="89f69-205">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="89f69-206">Ancak, evreleme veya üretim ortamlarına dağıtılırken, genellikle birden çok ortamı (QA, evreleme ve üretim gibi) işleyen Sürüm Yönetimi özelliklerini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="89f69-206">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="89f69-207">Tek Docker ana bilgisayarlarına dağıtım yapıyorsanız, Azure DevOps Hizmetleri "Docker Compose" görevini kullanıyor `docker-compose up` (başlık altındaki komutu çağırmaktır).</span><span class="sxs-lookup"><span data-stu-id="89f69-207">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the `docker-compose up` command under the hood).</span></span> <span data-ttu-id="89f69-208">Azure Kubernetes Hizmeti'ne (AKS) dağıtım yapıyorsanız, aşağıdaki bölümde açıklandığı gibi Docker Dağıtım görevini kullanır.</span><span class="sxs-lookup"><span data-stu-id="89f69-208">If you're deploying to Azure Kubernetes Service (AKS), it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![Docker Compose görevinin görev ekle iletişim kutusunu gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/add-tasks-docker-compose.png)

<span data-ttu-id="89f69-210">**Şekil 5-7**.</span><span class="sxs-lookup"><span data-stu-id="89f69-210">**Figure 5-7**.</span></span> <span data-ttu-id="89f69-211">Azure DevOps Hizmetleri boru hattında Docker Oluşturma görevi ekleme</span><span class="sxs-lookup"><span data-stu-id="89f69-211">Adding a Docker Compose task in an Azure DevOps Services pipeline</span></span>

<span data-ttu-id="89f69-212">Azure DevOps Hizmetleri'nde bir sürüm oluşturduğunuzda, bir dizi giriş yapıları alır.</span><span class="sxs-lookup"><span data-stu-id="89f69-212">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="89f69-213">Bu eserler, tüm ortamlarda, sürüm ömrü için değişmez olması amaçlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="89f69-213">These artifacts are intended to be immutable for the lifetime of the release, across all environments.</span></span> <span data-ttu-id="89f69-214">Kapsayıcıları tanıttığınızda, giriş yapıları dağıtmak için bir kayıt defterindeki görüntüleri tanımlar.</span><span class="sxs-lookup"><span data-stu-id="89f69-214">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="89f69-215">Bu görüntülerin nasıl tanımlandığına bağlı olarak, bu görüntülerin sürüm süresi boyunca aynı kalacağı garanti edilmez, `myimage:latest` en `docker-compose` belirgin durum bir dosyadan referans aldığınızda olur.</span><span class="sxs-lookup"><span data-stu-id="89f69-215">Depending on how these images are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference `myimage:latest` from a `docker-compose` file.</span></span>

<span data-ttu-id="89f69-216">Azure DevOps Hizmetleri şablonları, aynı görüntü ikilisini benzersiz olarak tanımlamayı garanti eden belirli kayıt defteri görüntü özetleri içeren yapı yapıları oluşturma olanağı sağlar.</span><span class="sxs-lookup"><span data-stu-id="89f69-216">The Azure DevOps Services templates give you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="89f69-217">Bunlar gerçekten bir sürüm giriş olarak kullanmak istediğiniz şeylerdir.</span><span class="sxs-lookup"><span data-stu-id="89f69-217">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="89f69-218">Azure DevOps Hizmetleri Yayın Yönetimi'ni kullanarak Docker ortamlarına sürüm leri yönetme</span><span class="sxs-lookup"><span data-stu-id="89f69-218">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="89f69-219">Azure DevOps Hizmetleri şablonları aracılığıyla, yeni bir resim oluşturabilir, Docker kayıt defterinde yayımlayabilir, Linux veya Windows `docker-compose` ana bilgisayarlarında çalıştırabilir ve Şekil 5-8'de gösterildiği gibi birden çok ortama yönelik Azure DevOps Hizmetleri Yayın Yönetimi özellikleri aracılığıyla birden çok kapsayıcıyı tüm uygulama olarak dağıtmak gibi komutlar kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-219">Through the Azure DevOps Services templates, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as `docker-compose` to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![Docker oluşturma sürümlerinin yapılandırmasını gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/configure-docker-compose-release.png)

<span data-ttu-id="89f69-221">**Şekil 5-8**.</span><span class="sxs-lookup"><span data-stu-id="89f69-221">**Figure 5-8**.</span></span> <span data-ttu-id="89f69-222">Azure DevOps Hizmetlerinin Yapılandırılması Azure DevOps Hizmetleri Yayın Yönetimi'nden görevler oluşturun</span><span class="sxs-lookup"><span data-stu-id="89f69-222">Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="89f69-223">Ancak, Şekil 5-6'da gösterilen ve Şekil 5-8'de uygulanan senaryonun basit olduğunu (tek Docker ana bilgisayarlarına ve VM'lere dağıtılacak ve görüntü başına tek bir kapsayıcı veya örnek olacak) ve büyük olasılıkla yalnızca geliştirme veya test için kullanılması gerektiğini unutmayın Senaryo.</span><span class="sxs-lookup"><span data-stu-id="89f69-223">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is a simple one (it's deploying to single Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="89f69-224">Çoğu kurumsal üretim senaryosunda, birden çok düğüm, sunucu ve VM arasında yük dengelemesi ve sunucu veya düğüm başarısız olursa , hizmetleri ve kapsayıcıları için "akıllı arızalar" ile yüksek kullanılabilirlik (HA) ve kolay yönetilebilirlik olmasını istersiniz başka bir ana bilgisayar sunucusuna veya VM'ye taşınır.</span><span class="sxs-lookup"><span data-stu-id="89f69-224">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="89f69-225">Bu durumda, konteyner kümeleri, orkestratörler ve zamanlayıcılar gibi daha gelişmiş teknolojilere ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="89f69-225">In that case, you need more advanced technologies such as container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="89f69-226">Bu nedenle, bu kümelere dağıtmanın yolu, bir sonraki bölümde açıklanan gelişmiş senaryoları işlemektir.</span><span class="sxs-lookup"><span data-stu-id="89f69-226">Thus, the way to deploy to those clusters is by handling the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-docker-applications-to-docker-clusters"></a><span data-ttu-id="89f69-227">Docker uygulamalarını Docker kümelerine dağıtma</span><span class="sxs-lookup"><span data-stu-id="89f69-227">Deploying Docker applications to Docker clusters</span></span>

<span data-ttu-id="89f69-228">Dağıtılmış uygulamaların niteliği, dağıtılan bilgi işlem kaynaklarını da gerektirir.</span><span class="sxs-lookup"><span data-stu-id="89f69-228">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="89f69-229">Üretim ölçeğinde yeteneklere sahip olmak için, birleştirilmiş kaynaklara dayalı olarak yüksek ölçeklenebilirlik ve yüksek kullanılabilirlik sağlayan kümeleme özelliklerine sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="89f69-229">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and high availability based on pooled resources.</span></span>

<span data-ttu-id="89f69-230">Kapsayıcıları bir CLI aracından veya web Kullanıcı Arabirimi'nden bu kümelere el ile dağıtabilirsiniz, ancak dağıtım sınama veya ölçeklendirme veya izleme gibi yönetim amaçlarını tespit etmek için bu tür el ile çalışmayı rezerve etmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="89f69-230">You could deploy containers manually to those clusters from a CLI tool or a web UI, but you should reserve that kind of manual work to spot deployment testing or management purposes like scaling-out or monitoring.</span></span>

<span data-ttu-id="89f69-231">CD bakış açısından ve Azure DevOps Hizmetleri özellikle, kapsayıcı uygulamalarınızı Kapsayıcı'daki dağıtılmış kümelere dağıtacak Azure DevOps Hizmetleri Yayın Yönetimi ortamlarınızdan özel olarak yapılmış dağıtım görevlerini çalıştırabilirsiniz Hizmet, Şekil 5-9'da gösterildiği gibi.</span><span class="sxs-lookup"><span data-stu-id="89f69-231">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments that will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![CD'nin orkestratörlere dağıtıla adım dağıtan adımını gösteren diyagram.](./media/docker-application-outer-loop-devops-workflow/cd-deploy-to-orchestrators.png)

<span data-ttu-id="89f69-233">**Şekil 5-9**.</span><span class="sxs-lookup"><span data-stu-id="89f69-233">**Figure 5-9**.</span></span> <span data-ttu-id="89f69-234">Dağıtılmış uygulamaları Konteyner Hizmetine dağıtma</span><span class="sxs-lookup"><span data-stu-id="89f69-234">Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="89f69-235">Başlangıçta, belirli kümelere veya orkestratörlere dağıtılırken, `docker-compose` `docker-compose.yml` tanım dosyasına dayalı daha basit ve kullanımı kolay araç yerine geleneksel olarak her orchestrator (diğer bir şekilde Kubernetes ve Hizmet Dokusu farklı dağıtım mekanizmalarına sahiptir) başına belirli dağıtım komut dosyalarını ve mekanizmalarını kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="89f69-235">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Kubernetes and Service Fabric have different deployment mechanisms) instead of the simpler and easy-to-use `docker-compose` tool based on the `docker-compose.yml` definition file.</span></span> <span data-ttu-id="89f69-236">Ancak, Şekil 5-10'da gösterilen Azure DevOps Hizmetleri Docker Dağıtma görevi sayesinde, artık yalnızca tanıdık `docker-compose.yml` dosyanızı kullanarak desteklenen orkestratörlere dağıtabilirsiniz, çünkü `docker-compose.yml` araç sizin için bu "çeviri"yi gerçekleştirir (dosyanızdan orkestratörün ihtiyaç duyduğu biçime kadar).</span><span class="sxs-lookup"><span data-stu-id="89f69-236">However, thanks to the Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to the supported orchestrators by just using your familiar `docker-compose.yml` file because the tool performs that “translation” for you (from your `docker-compose.yml` file to the format needed by the orchestrator).</span></span>

![Kubernetes'e Dağıt görevini gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/add-deploy-to-kubernetes-task.png)

<span data-ttu-id="89f69-238">**Şekil 5-10**.</span><span class="sxs-lookup"><span data-stu-id="89f69-238">**Figure 5-10**.</span></span> <span data-ttu-id="89f69-239">Kubernetes'e Dağıtma görevini Ortamınıza Ekleme</span><span class="sxs-lookup"><span data-stu-id="89f69-239">Adding the Deploy to Kubernetes task to your Environment</span></span>

<span data-ttu-id="89f69-240">Şekil 5-11, yapılandırma için kullanılabilir bölümlerle Kubernetes'e Dağıt görevini nasıl ayarlayabileceğinizi gösterir.</span><span class="sxs-lookup"><span data-stu-id="89f69-240">Figure 5-11 demonstrates how you can edit the Deploy to Kubernetes task with the sections available for configuration.</span></span> <span data-ttu-id="89f69-241">Bu, kümede kapsayıcı olarak dağıtılacak kullanıma hazır özel Docker görüntülerinizi alacak görevdir.</span><span class="sxs-lookup"><span data-stu-id="89f69-241">This is the task that will retrieve your ready-to-use custom Docker images to be deployed as containers in the cluster.</span></span>

![Kubernetes görev yapılandırmasına Dağıt'ı gösteren ekran görüntüsü.](./media/docker-application-outer-loop-devops-workflow/edit-deploy-to-kubernetes-task.png)

<span data-ttu-id="89f69-243">**Şekil 5-11**.</span><span class="sxs-lookup"><span data-stu-id="89f69-243">**Figure 5-11**.</span></span> <span data-ttu-id="89f69-244">ACS DC/OS'ye dağıtım görevi tanımını dağıtan Docker Deploy</span><span class="sxs-lookup"><span data-stu-id="89f69-244">Docker Deploy task definition deploying to ACS DC/OS</span></span>

> <span data-ttu-id="89f69-245">[! BİlGİ: Azure DevOps Hizmetleri ve Docker ile CD boru hattı hakkında daha fazla bilgi için,<https://azure.microsoft.com/services/devops/pipelines></span><span class="sxs-lookup"><span data-stu-id="89f69-245">[!INFORMATION] To read more about the CD pipeline with Azure DevOps Services and Docker, visit <https://azure.microsoft.com/services/devops/pipelines></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="89f69-246">Adım 5: Çalıştır ın ve yönetin</span><span class="sxs-lookup"><span data-stu-id="89f69-246">Step 5: Run and manage</span></span>

<span data-ttu-id="89f69-247">Uygulamaları işletme-üretim düzeyinde çalıştırmak ve yönetmek başlı başına önemli bir konu olduğundan ve bu düzeyde çalışan operasyonların ve kişilerin (BT işlemleri) yanı sıra bu alanın geniş kapsamı nedeniyle, bir sonraki bölümün tamamı açıklıyor.</span><span class="sxs-lookup"><span data-stu-id="89f69-247">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, the entire next chapter is devoted to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="89f69-248">Adım 6: İzleme ve tanılama</span><span class="sxs-lookup"><span data-stu-id="89f69-248">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="89f69-249">Bu konu, BT'nin üretim sistemlerinde gerçekleştirdiği görevlerin bir parçası olarak bir sonraki bölümde de ele alınmıştır; ancak, bu adımda elde edilen öngörülerin, uygulamanın sürekli olarak geliştirilen şekilde geliştirme ekibine geri beslemesi gerektiğini vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="89f69-249">This topic also is covered in the next chapter as part of the tasks that IT performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="89f69-250">Bu açıdan bakıldığında, görevler ve işlemler genellikle BT tarafından gerçekleştirilse de, DevOps'lerin de bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="89f69-250">From that point of view, it's also part of DevOps, although the tasks and operations are commonly performed by IT.</span></span>

<span data-ttu-id="89f69-251">Sadece izleme ve tanılama DevOps alanı içinde% 100 olduğunda test veya beta ortamlarına karşı geliştirme ekibi tarafından gerçekleştirilen izleme süreçleri ve analitik vardır.</span><span class="sxs-lookup"><span data-stu-id="89f69-251">Only when monitoring and diagnostics are 100% within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="89f69-252">Bu, yük testi yaparak veya beta test edicilerin yeni sürümleri denedikleri beta veya QA ortamlarını izleyerek yapılır.</span><span class="sxs-lookup"><span data-stu-id="89f69-252">This is done either by performing load testing or by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="89f69-253">[Önceki](index.md)
>[Sonraki](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="89f69-253">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
