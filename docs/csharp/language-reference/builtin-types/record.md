---
title: Kayıtlar-C# başvurusu
description: "C 'de kayıt türü hakkında bilgi edinin #"
ms.date: 02/25/2021
f1_keywords:
- record_CSharpKeyword
helpviewer_keywords:
- record keyword [C#]
- record type [C#]
ms.openlocfilehash: 067046a66c6eb1f314c123de8bde2d023f1f374a
ms.sourcegitcommit: e7e0921d0a10f85e9cb12f8b87cc1639a6c8d3fe
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/09/2021
ms.locfileid: "107255122"
---
# <a name="records-c-reference"></a><span data-ttu-id="852a6-103">Kayıtlar (C# Başvurusu)</span><span class="sxs-lookup"><span data-stu-id="852a6-103">Records (C# reference)</span></span>

<span data-ttu-id="852a6-104">C# 9 ' dan başlayarak, `record` verileri kapsüllemek için yerleşik işlevsellik sağlayan bir [başvuru türü](reference-types.md) tanımlamak için anahtar sözcüğünü kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="852a6-104">Beginning with C# 9, you use the `record` keyword to define a [reference type](reference-types.md) that provides built-in functionality for encapsulating data.</span></span> <span data-ttu-id="852a6-105">Konumsal parametreleri veya standart özellik sözdizimini kullanarak, değişmez özelliklerle kayıt türleri oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="852a6-105">You can create record types with immutable properties by using positional parameters or standard property syntax:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="snippets/shared/RecordType.cs" id="ImmutableRecord":::

<span data-ttu-id="852a6-106">Ayrıca, değişebilir Özellikler ve alanlarla kayıt türleri de oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="852a6-106">You can also create record types with mutable properties and fields:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MutableRecord":::

<span data-ttu-id="852a6-107">Kayıtlar değişebilir olsa da, Bunlar öncelikle sabit veri modellerini desteklemeye yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="852a6-107">While records can be mutable, they are primarily intended for supporting immutable data models.</span></span> <span data-ttu-id="852a6-108">Kayıt türü aşağıdaki özellikleri sunar:</span><span class="sxs-lookup"><span data-stu-id="852a6-108">The record type offers the following features:</span></span>

* [<span data-ttu-id="852a6-109">Sabit özelliklerle başvuru türü oluşturmak için kısa sözdizimi</span><span class="sxs-lookup"><span data-stu-id="852a6-109">Concise syntax for creating a reference type with immutable properties</span></span>](#positional-syntax-for-property-definition)
* <span data-ttu-id="852a6-110">Veri merkezli bir başvuru türü için yerleşik davranış yararlı olur:</span><span class="sxs-lookup"><span data-stu-id="852a6-110">Built-in behavior useful for a data-centric reference type:</span></span>
  * [<span data-ttu-id="852a6-111">Değer eşitlik</span><span class="sxs-lookup"><span data-stu-id="852a6-111">Value equality</span></span>](#value-equality)
  * [<span data-ttu-id="852a6-112">Geri dönüşlü mutasyon için kısa sözdizimi</span><span class="sxs-lookup"><span data-stu-id="852a6-112">Concise syntax for nondestructive mutation</span></span>](#nondestructive-mutation)
  * [<span data-ttu-id="852a6-113">Görüntüleme için yerleşik biçimlendirme</span><span class="sxs-lookup"><span data-stu-id="852a6-113">Built-in formatting for display</span></span>](#built-in-formatting-for-display)
* [<span data-ttu-id="852a6-114">Devralma hiyerarşileri için destek</span><span class="sxs-lookup"><span data-stu-id="852a6-114">Support for inheritance hierarchies</span></span>](#inheritance)

<span data-ttu-id="852a6-115">Ayrıca, değer eşitlik ve çok az davranış sağlayan veri merkezli türler tasarlamak için [yapı türlerini](struct.md) de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="852a6-115">You can also use [structure types](struct.md) to design data-centric types that provide value equality and little or no behavior.</span></span> <span data-ttu-id="852a6-116">Ancak görece büyük veri modelleri için yapı türlerinin bazı dezavantajları vardır:</span><span class="sxs-lookup"><span data-stu-id="852a6-116">But for relatively large data models, structure types have some disadvantages:</span></span>

* <span data-ttu-id="852a6-117">Devralma desteği yoktur.</span><span class="sxs-lookup"><span data-stu-id="852a6-117">They don't support inheritance.</span></span>
* <span data-ttu-id="852a6-118">Değer eşitliğini belirlemede daha az verimlidir.</span><span class="sxs-lookup"><span data-stu-id="852a6-118">They're less efficient at determining value equality.</span></span> <span data-ttu-id="852a6-119">Değer türlerinde, <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> yöntemi tüm alanları bulmak için yansıma kullanır.</span><span class="sxs-lookup"><span data-stu-id="852a6-119">For value types, the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method uses reflection to find all fields.</span></span> <span data-ttu-id="852a6-120">Kayıtlar için derleyici `Equals` yöntemini oluşturur.</span><span class="sxs-lookup"><span data-stu-id="852a6-120">For records, the compiler generates the `Equals` method.</span></span> <span data-ttu-id="852a6-121">Uygulamada, kayıtlardaki değer eşitlik uygulaması yaşamları daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="852a6-121">In practice, the implementation of value equality in records is measurably faster.</span></span>
* <span data-ttu-id="852a6-122">Her örnek tüm verilerin tamamen bir kopyasına sahip olduğundan, bazı senaryolarda daha fazla bellek kullanırlar.</span><span class="sxs-lookup"><span data-stu-id="852a6-122">They use more memory in some scenarios, since every instance has a complete copy of all of the data.</span></span> <span data-ttu-id="852a6-123">Kayıt türleri [başvuru türlerdir](reference-types.md), bu nedenle bir kayıt örneği yalnızca verilerin bir başvurusunu içerir.</span><span class="sxs-lookup"><span data-stu-id="852a6-123">Record types are [reference types](reference-types.md), so a record instance contains only a reference to the data.</span></span>

## <a name="positional-syntax-for-property-definition"></a><span data-ttu-id="852a6-124">Özellik tanımı için Konumsal sözdizimi</span><span class="sxs-lookup"><span data-stu-id="852a6-124">Positional syntax for property definition</span></span>

<span data-ttu-id="852a6-125">Bir kaydın özelliklerini bildirmek ve bir örnek oluştururken özellik değerlerini başlatmak için Konumsal parametreleri kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="852a6-125">You can use positional parameters to declare properties of a record and to initialize the property values when you create an instance:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InstantiatePositional":::

<span data-ttu-id="852a6-126">Özellik tanımı için Konumsal sözdizimini kullandığınızda, derleyici şunları oluşturur:</span><span class="sxs-lookup"><span data-stu-id="852a6-126">When you use the positional syntax for property definition, the compiler creates:</span></span>

* <span data-ttu-id="852a6-127">Kayıt bildiriminde belirtilen her Konumsal parametre için genel bir init-tek otomatik uygulanan özellik.</span><span class="sxs-lookup"><span data-stu-id="852a6-127">A public init-only auto-implemented property for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="852a6-128">[Yalnızca bir init](../keywords/init.md) özelliği, oluşturucuda veya bir özellik başlatıcısı kullanılarak ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="852a6-128">An [init-only](../keywords/init.md) property can only be set in the constructor or by using a property initializer.</span></span>
* <span data-ttu-id="852a6-129">Parametreleri, kayıt bildiriminde konumsal parametrelerle eşleşen bir birincil Oluşturucu.</span><span class="sxs-lookup"><span data-stu-id="852a6-129">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
* <span data-ttu-id="852a6-130">`Deconstruct` `out` Kayıt bildiriminde belirtilen her Konumsal parametre için parametreye sahip bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="852a6-130">A `Deconstruct` method with an `out` parameter for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="852a6-131">Bu yöntem yalnızca iki veya daha fazla Konumsal parametre varsa sağlanır.</span><span class="sxs-lookup"><span data-stu-id="852a6-131">This method is provided only if there are two or more positional parameters.</span></span> <span data-ttu-id="852a6-132">Yöntemi konumsal sözdizimi kullanılarak tanımlanan özellikleri kaldırır; Standart özellik sözdizimi kullanılarak tanımlanan özellikleri yoksayar.</span><span class="sxs-lookup"><span data-stu-id="852a6-132">The method deconstructs properties defined by using positional syntax; it ignores properties that are defined by using standard property syntax.</span></span>

<span data-ttu-id="852a6-133">Oluşturulan otomatik uygulanan özellik tanımı istediğiniz gibi değilse, aynı ada sahip kendi özelliğini tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="852a6-133">If the generated auto-implemented property definition isn't what you want, you can define your own property of the same name.</span></span> <span data-ttu-id="852a6-134">Bunu yaparsanız, oluşturulan Oluşturucu ve Deconstructor Özellik tanımınızı kullanacaktır.</span><span class="sxs-lookup"><span data-stu-id="852a6-134">If you do that, the generated constructor and deconstructor will use your property definition.</span></span> <span data-ttu-id="852a6-135">Örneğin, aşağıdaki örnek `FirstName` yerine konumsal özelliği yapar `internal` `public` .</span><span class="sxs-lookup"><span data-stu-id="852a6-135">For instance, the following example makes the `FirstName` positional property `internal` instead of `public`.</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalWithManualProperty":::

<span data-ttu-id="852a6-136">Kayıt türü herhangi bir Konumsal özellik bildirmek zorunda değildir.</span><span class="sxs-lookup"><span data-stu-id="852a6-136">A record type doesn't have to declare any positional properties.</span></span> <span data-ttu-id="852a6-137">Herhangi bir konum özelliği olmadan bir kayıt bildirebilir ve aşağıdaki örnekte olduğu gibi ek alanlar ve özellikler bildirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="852a6-137">You can declare a record without any positional properties, and you can declare additional fields and properties, as in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="MixedSyntax":::

<span data-ttu-id="852a6-138">Standart özellik söz dizimini kullanarak Özellikler tanımlayabilir ancak erişim değiştiricisini atlarsanız, Özellikler örtülü olarak bulunur `public` .</span><span class="sxs-lookup"><span data-stu-id="852a6-138">If you define properties by using standard property syntax but omit the access modifier, the properties are implicitly `public`.</span></span>
<!-- Todo -- Explain issues surrounding use of attributes on positional properties. -->

## <a name="immutability"></a><span data-ttu-id="852a6-139">Değiştirilemezlik</span><span class="sxs-lookup"><span data-stu-id="852a6-139">Immutability</span></span>

<span data-ttu-id="852a6-140">Kayıt türü sabit değildir.</span><span class="sxs-lookup"><span data-stu-id="852a6-140">A record type is not necessarily immutable.</span></span> <span data-ttu-id="852a6-141">Özellikleri, `set` erişimciler ve olmayan alanlarla bildirebilirsiniz `readonly` .</span><span class="sxs-lookup"><span data-stu-id="852a6-141">You can declare properties with `set` accessors and fields that aren't `readonly`.</span></span> <span data-ttu-id="852a6-142">Ancak kayıtlar değişebilir, ancak değişmez veri modelleri oluşturmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="852a6-142">But while records can be mutable, they make it easier to create immutable data models.</span></span>

<span data-ttu-id="852a6-143">Kullanım açısından kullanılabilirlik, iş parçacığı açısından güvenli olması için veri merkezli bir türün olması gerektiğinde veya karma bir tabloda aynı kalan bir karma koda bağlı olduğunuzda yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="852a6-143">Immutability can be useful when you need a data-centric type to be thread-safe or you're depending on a hash code remaining the same in a hash table.</span></span> <span data-ttu-id="852a6-144">Ancak tüm veri senaryoları için uygun olmayan bir şekilde kullanılabilirlik yoktur.</span><span class="sxs-lookup"><span data-stu-id="852a6-144">Immutability isn't appropriate for all data scenarios, however.</span></span> <span data-ttu-id="852a6-145">Örneğin, [Entity Framework Core](/ef/core/), sabit varlık türleriyle güncellemeyi desteklemez.</span><span class="sxs-lookup"><span data-stu-id="852a6-145">[Entity Framework Core](/ef/core/), for example, doesn't support updating with immutable entity types.</span></span>

<span data-ttu-id="852a6-146">Konumsal parametrelerden oluşturulup veya erişimciler belirtilerek basit bir şekilde kullanılabilirlik sağlamak için yalnızca Init özellikleri `init` . </span><span class="sxs-lookup"><span data-stu-id="852a6-146">Init-only properties, whether created from positional parameters or by specifying `init` accessors, have *shallow immutability*.</span></span> <span data-ttu-id="852a6-147">Başlatma işleminden sonra değer türü özelliklerinin değerini veya başvuru türü özelliklerinin başvurusunu değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="852a6-147">After initialization, you can't change the value of value-type properties or the reference of reference-type properties.</span></span> <span data-ttu-id="852a6-148">Ancak, başvuru türü bir özelliğin başvurduğu veriler değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="852a6-148">However, the data that a reference-type property refers to can be changed.</span></span> <span data-ttu-id="852a6-149">Aşağıdaki örnek, bir başvuru türü sabit özelliğinin (Bu durumda bir dizi)) içeriğinin değişebilir olduğunu gösterir:</span><span class="sxs-lookup"><span data-stu-id="852a6-149">The following example shows that the content of a reference-type immutable property (an array in this case) is mutable:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ShallowImmutability":::

<span data-ttu-id="852a6-150">Kayıt türlerine özgü özellikler derleyici birleştirilmemiş yöntemler tarafından uygulanır ve bu yöntemlerin hiçbiri, nesne durumunu değiştirerek değişiklik imkanlarını önler.</span><span class="sxs-lookup"><span data-stu-id="852a6-150">The features unique to record types are implemented by compiler-synthesized methods, and none of these methods compromises immutability by modifying object state.</span></span>

## <a name="value-equality"></a><span data-ttu-id="852a6-151">Değer eşitlik</span><span class="sxs-lookup"><span data-stu-id="852a6-151">Value equality</span></span>

<span data-ttu-id="852a6-152">Değer eşitliği, türlerin eşleşmesi ve tüm özellik ve alan değerleri eşleşiyorsa bir kayıt türünün iki değişkeninin eşit olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="852a6-152">Value equality means that two variables of a record type are equal if the types match and all property and field values match.</span></span> <span data-ttu-id="852a6-153">Diğer başvuru türleri için eşitlik, kimlik anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="852a6-153">For other reference types, equality means identity.</span></span> <span data-ttu-id="852a6-154">Diğer bir deyişle, bir başvuru türünün iki değişkeni aynı nesneye başvurduklarında eşittir.</span><span class="sxs-lookup"><span data-stu-id="852a6-154">That is, two variables of a reference type are equal if they refer to the same object.</span></span>

<span data-ttu-id="852a6-155">Bazı veri modelleri için başvuru eşitliği gereklidir.</span><span class="sxs-lookup"><span data-stu-id="852a6-155">Reference equality is required for some data models.</span></span> <span data-ttu-id="852a6-156">Örneğin, [Entity Framework Core](/ef/core/) kavramsal bir varlık olan varlık türünün yalnızca bir örneğini kullandığından emin olmak için başvuru eşitliğine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="852a6-156">For example, [Entity Framework Core](/ef/core/) depends on reference equality to ensure that it uses only one instance of an entity type for what is conceptually one entity.</span></span> <span data-ttu-id="852a6-157">Bu nedenle, kayıt türleri Entity Framework Core varlık türleri olarak kullanım için uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="852a6-157">For this reason, record types aren't appropriate for use as entity types in Entity Framework Core.</span></span>

<span data-ttu-id="852a6-158">Aşağıdaki örnek, kayıt türlerinin değer eşitliğini gösterir:</span><span class="sxs-lookup"><span data-stu-id="852a6-158">The following example illustrates value equality of record types:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="Equality":::

<span data-ttu-id="852a6-159">Değer eşitliği uygulamak için, derleyici aşağıdaki yöntemleri birleştirmelidir:</span><span class="sxs-lookup"><span data-stu-id="852a6-159">To implement value equality, the compiler synthesizes the following methods:</span></span>

* <span data-ttu-id="852a6-160">Bir geçersiz kılma <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="852a6-160">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>

  <span data-ttu-id="852a6-161">Bu yöntem, <xref:System.Object.Equals(System.Object,System.Object)?displayProperty=nameWithType> her iki parametre de null olmadığında statik metodun temeli olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="852a6-161">This method is used as the basis for the <xref:System.Object.Equals(System.Object,System.Object)?displayProperty=nameWithType> static method when both parameters are non-null.</span></span>

* <span data-ttu-id="852a6-162">`Equals`Parametresi kayıt türü olan bir sanal yöntem.</span><span class="sxs-lookup"><span data-stu-id="852a6-162">A virtual `Equals` method whose parameter is the record type.</span></span> <span data-ttu-id="852a6-163">Bu yöntem uygular <xref:System.IEquatable%601> .</span><span class="sxs-lookup"><span data-stu-id="852a6-163">This method implements <xref:System.IEquatable%601>.</span></span>

* <span data-ttu-id="852a6-164">Bir geçersiz kılma <xref:System.Object.GetHashCode?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="852a6-164">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>

* <span data-ttu-id="852a6-165">Operatörlerin ve geçersiz kılmaları `==` `!=` .</span><span class="sxs-lookup"><span data-stu-id="852a6-165">Overrides of operators `==` and `!=`.</span></span>

<span data-ttu-id="852a6-166">Türler ' de `class` , eşitlik yöntemlerini ve işleçleri değer eşitlik elde etmek için el ile geçersiz kılabilirsiniz, ancak bu kodun geliştirilmesi ve test edilmesi zaman alabilir ve hataya açıktır.</span><span class="sxs-lookup"><span data-stu-id="852a6-166">In `class` types, you could manually override equality methods and operators to achieve value equality, but developing and testing that code would be time-consuming and error-prone.</span></span> <span data-ttu-id="852a6-167">Bu işlevin yerleşik olması, özellikler veya alanlar eklendiğinde veya değiştirildiğinde özel geçersiz kılma kodunu güncelleştirmeye neden olan hataları önler.</span><span class="sxs-lookup"><span data-stu-id="852a6-167">Having this functionality built-in prevents bugs that would result from forgetting to update custom override code when properties or fields are added or changed.</span></span>

<span data-ttu-id="852a6-168">Bu sentezlenmiş yöntemlerin herhangi birini değiştirmek için kendi uygulamalarınızı yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="852a6-168">You can write your own implementations to replace any of these synthesized methods.</span></span> <span data-ttu-id="852a6-169">Bir kayıt türünün herhangi bir sentezlenmiş yöntemin imzasıyla eşleşen bir yöntemi varsa, derleyici bu yöntemi birleştirmez.</span><span class="sxs-lookup"><span data-stu-id="852a6-169">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span>

<span data-ttu-id="852a6-170">`Equals`Bir kayıt türünde kendi uygulamanızı sağlarsanız, bir de uygulamasını sağlayın `GetHashCode` .</span><span class="sxs-lookup"><span data-stu-id="852a6-170">If you provide your own implementation of `Equals` in a record type, provide an implementation of `GetHashCode` also.</span></span>

## <a name="nondestructive-mutation"></a><span data-ttu-id="852a6-171">Geri dönüşlü mutasyon</span><span class="sxs-lookup"><span data-stu-id="852a6-171">Nondestructive mutation</span></span>

<span data-ttu-id="852a6-172">Bir kayıt örneğinin sabit özelliklerini mukumanız gerekirse, geri dönüşlü bir zaman `with` elde etmek için bir ifade kullanabilirsiniz .</span><span class="sxs-lookup"><span data-stu-id="852a6-172">If you need to mutate immutable properties of a record instance, you can use a `with` expression to achieve *nondestructive mutation*.</span></span> <span data-ttu-id="852a6-173">Bir `with` ifade, belirtilen özellikler ve alanlarla değiştirilen mevcut bir kayıt örneğinin kopyası olan yeni bir kayıt örneği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="852a6-173">A `with` expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.</span></span> <span data-ttu-id="852a6-174">Aşağıdaki örnekte gösterildiği gibi, değiştirilecek değerleri belirtmek için [nesne Başlatıcısı](../../programming-guide/classes-and-structs/object-and-collection-initializers.md) sözdizimini kullanın:</span><span class="sxs-lookup"><span data-stu-id="852a6-174">You use [object initializer](../../programming-guide/classes-and-structs/object-and-collection-initializers.md) syntax to specify the values to be changed, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressions":::

<span data-ttu-id="852a6-175">`with`İfade, konumsal özellikleri veya standart özellik söz dizimi kullanılarak oluşturulan özellikleri ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="852a6-175">The `with` expression can set positional properties or properties created by using standard property syntax.</span></span> <span data-ttu-id="852a6-176">Konumsal olmayan özelliklerin `init` `set` bir ifadede değişmesi için bir veya erişimcisi olmalıdır `with` .</span><span class="sxs-lookup"><span data-stu-id="852a6-176">Non-positional properties must have an `init` or `set` accessor to be changed in a `with` expression.</span></span>

<span data-ttu-id="852a6-177">Bir `with` ifadenin sonucu *basit bir kopyadır*. Bu, başvuru özelliği için yalnızca bir örneğe olan başvurunun kopyalandığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="852a6-177">The result of a `with` expression is a *shallow copy*, which means that for a reference property, only the reference to an instance is copied.</span></span> <span data-ttu-id="852a6-178">Hem özgün kayıt hem de kopya aynı örneğe bir başvuru ile sona erdir.</span><span class="sxs-lookup"><span data-stu-id="852a6-178">Both the original record and the copy end up with a reference to the same instance.</span></span>

<span data-ttu-id="852a6-179">Bu özelliği uygulamak için derleyici bir Clone yöntemi ve bir kopya Oluşturucu birleştirmelidir.</span><span class="sxs-lookup"><span data-stu-id="852a6-179">To implement this feature, the compiler synthesizes a clone method and a copy constructor.</span></span> <span data-ttu-id="852a6-180">Oluşturucu, kopyalanacak kaydın bir örneğini alır ve Clone metodunu çağırır.</span><span class="sxs-lookup"><span data-stu-id="852a6-180">The constructor takes an instance of the record to be copied and calls the clone method.</span></span> <span data-ttu-id="852a6-181">Bir `with` ifade kullandığınızda, derleyici kopya oluşturucuyu çağıran kodu oluşturur ve sonra ifadede belirtilen özellikleri ayarlar `with` .</span><span class="sxs-lookup"><span data-stu-id="852a6-181">When you use a `with` expression, the compiler creates code that calls the copy constructor and then sets the properties that are specified in the `with` expression.</span></span>

<span data-ttu-id="852a6-182">Farklı kopyalama davranışına ihtiyacınız varsa, kendi kopya oluşturucunuzu yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="852a6-182">If you need different copying behavior, you can write your own copy constructor.</span></span> <span data-ttu-id="852a6-183">Bunu yaparsanız, derleyici bir tane birleştirmez.</span><span class="sxs-lookup"><span data-stu-id="852a6-183">If you do that, the compiler won't synthesize one.</span></span> <span data-ttu-id="852a6-184">`private`Kayıt varsa oluşturucuyu yapın `sealed` , aksi takdirde yapın `protected` .</span><span class="sxs-lookup"><span data-stu-id="852a6-184">Make your constructor `private` if the record is `sealed`, otherwise make it `protected`.</span></span>

<span data-ttu-id="852a6-185">Kopyalama yöntemini geçersiz kılamazsınız ve adında bir üye oluşturamazsınız `Clone` .</span><span class="sxs-lookup"><span data-stu-id="852a6-185">You can't override the clone method, and you can't create a member named `Clone`.</span></span> <span data-ttu-id="852a6-186">Kopya yönteminin gerçek adı derleyici tarafından oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="852a6-186">The actual name of the clone method is compiler-generated.</span></span>

## <a name="built-in-formatting-for-display"></a><span data-ttu-id="852a6-187">Görüntüleme için yerleşik biçimlendirme</span><span class="sxs-lookup"><span data-stu-id="852a6-187">Built-in formatting for display</span></span>

<span data-ttu-id="852a6-188">Kayıt türlerinde <xref:System.Object.ToString%2A> , ortak özelliklerin ve alanların adlarını ve değerlerini görüntüleyen bir derleyici tarafından oluşturulan yöntem vardır.</span><span class="sxs-lookup"><span data-stu-id="852a6-188">Record types have a compiler-generated <xref:System.Object.ToString%2A> method that displays the names and values of public properties and fields.</span></span> <span data-ttu-id="852a6-189">`ToString`Yöntemi aşağıdaki biçimde bir dize döndürür:</span><span class="sxs-lookup"><span data-stu-id="852a6-189">The `ToString` method returns a string of the following format:</span></span>

> <span data-ttu-id="852a6-190">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span><span class="sxs-lookup"><span data-stu-id="852a6-190">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span></span>

<span data-ttu-id="852a6-191">Başvuru türleri için, özelliğin başvurduğu nesnenin tür adı, özellik değeri yerine görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="852a6-191">For reference types, the type name of the object that the property refers to is displayed instead of the property value.</span></span> <span data-ttu-id="852a6-192">Aşağıdaki örnekte, dizi bir başvuru türüdür, bu nedenle `System.String[]` gerçek dizi öğesi değerleri yerine görüntülenir:</span><span class="sxs-lookup"><span data-stu-id="852a6-192">In the following example, the array is a reference type, so `System.String[]` is displayed instead of the actual array element values:</span></span>

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

<span data-ttu-id="852a6-193">Bu özelliği uygulamak için, derleyici sanal bir `PrintMembers` yöntemi ve bir <xref:System.Object.ToString%2A> geçersiz kılmayı birleştirir.</span><span class="sxs-lookup"><span data-stu-id="852a6-193">To implement this feature, the compiler synthesizes a virtual `PrintMembers` method and a <xref:System.Object.ToString%2A> override.</span></span>
<span data-ttu-id="852a6-194">`ToString`Geçersiz kılma, <xref:System.Text.StringBuilder> tür adı ve ardından bir açılış ayracı ile bir nesne oluşturur.</span><span class="sxs-lookup"><span data-stu-id="852a6-194">The `ToString` override creates a <xref:System.Text.StringBuilder> object with the type name followed by an opening bracket.</span></span> <span data-ttu-id="852a6-195">`PrintMembers`Özellik adları ve değerler eklemek için öğesini çağırır, sonra da kapanış ayracını ekler.</span><span class="sxs-lookup"><span data-stu-id="852a6-195">It calls `PrintMembers` to add property names and values, then adds the closing bracket.</span></span> <span data-ttu-id="852a6-196">Aşağıdaki örnek, sentezleştirilmiş geçersiz kılmanın neleri içerdiğini gösteren kodu gösterir:</span><span class="sxs-lookup"><span data-stu-id="852a6-196">The following example shows code similar to what the synthesized override contains:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringOverrideDefault":::

<span data-ttu-id="852a6-197">Kendi uygulamanızı `PrintMembers` veya `ToString` geçersiz kılma işlemini sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="852a6-197">You can provide your own implementation of `PrintMembers` or the `ToString` override.</span></span> <span data-ttu-id="852a6-198">Örnekler, bu makalenin ilerleyen kısımlarında [ `PrintMembers` türetilen kayıtlardaki biçimlendirme](#printmembers-formatting-in-derived-records) bölümünde verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="852a6-198">Examples are provided in the [`PrintMembers` formatting in derived records](#printmembers-formatting-in-derived-records) section later in this article.</span></span>

## <a name="inheritance"></a><span data-ttu-id="852a6-199">Devralma</span><span class="sxs-lookup"><span data-stu-id="852a6-199">Inheritance</span></span>

<span data-ttu-id="852a6-200">Bir kayıt, başka bir kayıttan devralınabilir.</span><span class="sxs-lookup"><span data-stu-id="852a6-200">A record can inherit from another record.</span></span> <span data-ttu-id="852a6-201">Ancak, bir kayıt bir sınıftan devralınabilir ve bir sınıf bir kayıttan devralınabilir.</span><span class="sxs-lookup"><span data-stu-id="852a6-201">However, a record can't inherit from a class, and a class can't inherit from a record.</span></span>

### <a name="positional-parameters-in-derived-record-types"></a><span data-ttu-id="852a6-202">Türetilmiş kayıt türlerinde Konumsal parametreler</span><span class="sxs-lookup"><span data-stu-id="852a6-202">Positional parameters in derived record types</span></span>

<span data-ttu-id="852a6-203">Türetilmiş kayıt, temel kayıt birincil oluşturucusunda bulunan tüm parametrelerin konumsal parametrelerini bildirir.</span><span class="sxs-lookup"><span data-stu-id="852a6-203">The derived record declares positional parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="852a6-204">Temel kayıt bu özellikleri bildirir ve başlatır.</span><span class="sxs-lookup"><span data-stu-id="852a6-204">The base record declares and initializes those properties.</span></span> <span data-ttu-id="852a6-205">Türetilmiş kayıt onları gizlemez, ancak temel kaydında bildirilmeyen parametreler için Özellikler oluşturur ve başlatır.</span><span class="sxs-lookup"><span data-stu-id="852a6-205">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span>

<span data-ttu-id="852a6-206">Aşağıdaki örnek, konumsal Özellik söz dizimi ile devralmayı göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="852a6-206">The following example illustrates inheritance with positional property syntax:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PositionalInheritance":::

### <a name="equality-in-inheritance-hierarchies"></a><span data-ttu-id="852a6-207">Devralma hiyerarşilerinde eşitlik</span><span class="sxs-lookup"><span data-stu-id="852a6-207">Equality in inheritance hierarchies</span></span>

<span data-ttu-id="852a6-208">İki kayıt değişkeninin eşit olması için, çalışma zamanı türünün eşit olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="852a6-208">For two record variables to be equal, the run-time type must be equal.</span></span> <span data-ttu-id="852a6-209">Kapsayan değişkenlerin türleri farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="852a6-209">The types of the containing variables might be different.</span></span> <span data-ttu-id="852a6-210">Bu, aşağıdaki kod örneğinde gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="852a6-210">This is illustrated in the following code example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="InheritanceEquality":::

<span data-ttu-id="852a6-211">Örnekte, tüm örnekler aynı özelliklere ve aynı özellik değerlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="852a6-211">In the example, all instances have the same properties and the same property values.</span></span> <span data-ttu-id="852a6-212">Ancak `student == teacher` , `False` her ikisi de `Person` -tür değişkenleri olsa da `student == student2` , `True` biri `Person` değişken ve diğeri bir `Student` değişken olsa da döndürür.</span><span class="sxs-lookup"><span data-stu-id="852a6-212">But `student == teacher` returns `False` although both are `Person`-type variables, and `student == student2` returns `True` although one is a `Person` variable and one is a `Student` variable.</span></span>

<span data-ttu-id="852a6-213">Bu davranışı uygulamak için derleyici, `EqualityContract` kaydın türüyle eşleşen bir nesne döndüren bir özelliği sentezler <xref:System.Type> .</span><span class="sxs-lookup"><span data-stu-id="852a6-213">To implement this behavior, the compiler synthesizes an `EqualityContract` property that returns a <xref:System.Type> object that matches the type of the record.</span></span> <span data-ttu-id="852a6-214">Bu, eşitlik için Denetim sırasında nesnelerin çalışma zamanı türünü karşılaştırmalarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="852a6-214">This enables the equality methods to compare the runtime type of objects when they are checking for equality.</span></span> <span data-ttu-id="852a6-215">Bir kaydın temel türü ise, `object` Bu özellik olur `virtual` .</span><span class="sxs-lookup"><span data-stu-id="852a6-215">If the base type of a record is `object`, this property is `virtual`.</span></span> <span data-ttu-id="852a6-216">Temel tür başka bir kayıt türü ise, bu özellik bir geçersiz kılma olur.</span><span class="sxs-lookup"><span data-stu-id="852a6-216">If the base type is another record type, this property is an override.</span></span> <span data-ttu-id="852a6-217">Kayıt türü ise, `sealed` Bu özellik olur `sealed` .</span><span class="sxs-lookup"><span data-stu-id="852a6-217">If the record type is `sealed`, this property is `sealed`.</span></span>

<span data-ttu-id="852a6-218">Türetilmiş bir türün iki örneğini karşılaştırırken, birleştirilmiş eşitlik yöntemleri temel ve türetilmiş türlerin tüm özelliklerini bir eşitlik için denetler.</span><span class="sxs-lookup"><span data-stu-id="852a6-218">When comparing two instances of a derived type, the synthesized equality methods check all properties of the base and derived types for equality.</span></span> <span data-ttu-id="852a6-219">Sentezlenmiş `GetHashCode` Yöntem, `GetHashCode` temel türde ve türetilmiş kayıt türünde belirtilen tüm özelliklerden ve alanlardan yöntemini kullanır.</span><span class="sxs-lookup"><span data-stu-id="852a6-219">The synthesized `GetHashCode` method uses the `GetHashCode` method from all properties and fields declared in the base type and the derived record type.</span></span>

### <a name="with-expressions-in-derived-records"></a><span data-ttu-id="852a6-220">`with` türetilmiş kayıtlardaki ifadeler</span><span class="sxs-lookup"><span data-stu-id="852a6-220">`with` expressions in derived records</span></span>

<span data-ttu-id="852a6-221">Sentezlenmiş kopya yöntemi bir [covaryant dönüş türü](~/_csharplang/proposals/csharp-9.0/covariant-returns.md)kullandığından, `with` ifadenin sonucu ifadenin işleneni ile aynı çalışma zamanı türüne sahip.</span><span class="sxs-lookup"><span data-stu-id="852a6-221">Because the synthesized clone method uses a [covariant return type](~/_csharplang/proposals/csharp-9.0/covariant-returns.md), the result of a `with` expression has the same run-time type as the expression's operand.</span></span> <span data-ttu-id="852a6-222">Çalışma zamanı türünün tüm özellikleri kopyalanırlar, ancak aşağıdaki örnekte gösterildiği gibi yalnızca derleme zamanı türünün özelliklerini ayarlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="852a6-222">All properties of the run-time type get copied, but you can only set properties of the compile-time type, as the following example shows:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="WithExpressionInheritance":::

### <a name="printmembers-formatting-in-derived-records"></a><span data-ttu-id="852a6-223">`PrintMembers` türetilmiş kayıtlarda biçimlendirme</span><span class="sxs-lookup"><span data-stu-id="852a6-223">`PrintMembers` formatting in derived records</span></span>

<span data-ttu-id="852a6-224">`PrintMembers`Türetilmiş bir kayıt türünün sentezlenmiş yöntemi temel uygulamayı çağırır.</span><span class="sxs-lookup"><span data-stu-id="852a6-224">The synthesized `PrintMembers` method of a derived record type calls the base implementation.</span></span> <span data-ttu-id="852a6-225">Sonuç `ToString` olarak, aşağıdaki örnekte gösterildiği gibi, hem türetilmiş hem de temel türlerin tüm ortak özellikleri ve alanları çıkışa dahil edilir:</span><span class="sxs-lookup"><span data-stu-id="852a6-225">The result is that all public properties and fields of both derived and base types are included in the `ToString` output, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="ToStringInheritance":::

<span data-ttu-id="852a6-226">Yöntemi için kendi uygulamanızı sağlayabilirsiniz `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="852a6-226">You can provide your own implementation of the `PrintMembers` method.</span></span> <span data-ttu-id="852a6-227">Bunu yaparsanız, aşağıdaki imzayı kullanın:</span><span class="sxs-lookup"><span data-stu-id="852a6-227">If you do that, use the following signature:</span></span>

* <span data-ttu-id="852a6-228">`sealed`Öğesinden türetilen bir kayıt için `object` (bir temel kayıt bildirmez): `private bool PrintMembers(StringBuilder builder)` ;</span><span class="sxs-lookup"><span data-stu-id="852a6-228">For a `sealed` record that derives from `object` (doesn't declare a base record): `private bool PrintMembers(StringBuilder builder)`;</span></span>
* <span data-ttu-id="852a6-229">Başka bir `sealed` Kayıttan türetilen kayıt için: `protected sealed override bool PrintMembers(StringBuilder builder)` ;</span><span class="sxs-lookup"><span data-stu-id="852a6-229">For a `sealed` record that derives from another record: `protected sealed override bool PrintMembers(StringBuilder builder)`;</span></span>
* <span data-ttu-id="852a6-230">`sealed`Nesnesinden türetilmiş ve türetilen bir kayıt için:`protected virtual bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="852a6-230">For a record that isn't `sealed` and derives from object: `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
* <span data-ttu-id="852a6-231">Başka bir kayıttan olmayan ve türetilen bir kayıt için `sealed` : `protected override bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="852a6-231">For a record that isn't `sealed` and derives from another record: `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="852a6-232">İşte, `PrintMembers` biri nesneden türeyen bir kayıt türü için ve diğeri başka bir kayıttan türetilen kayıt türü için, birleştirilmiş yöntemlerin yerini alan bir kod örneği aşağıdadır:</span><span class="sxs-lookup"><span data-stu-id="852a6-232">Here is an example of code that replaces the synthesized `PrintMembers` methods, one for a record type that derives from object, and one for a record type that derives from another record:</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="PrintMembersImplementation":::

### <a name="deconstructor-behavior-in-derived-records"></a><span data-ttu-id="852a6-233">Türetilmiş kayıtlarda Oluşturucu kaldırma davranışı</span><span class="sxs-lookup"><span data-stu-id="852a6-233">Deconstructor behavior in derived records</span></span>

<span data-ttu-id="852a6-234">`Deconstruct`Türetilmiş bir kaydın yöntemi, derleme zamanı türünün tüm konumsal özelliklerinin değerlerini döndürür.</span><span class="sxs-lookup"><span data-stu-id="852a6-234">The `Deconstruct` method of a derived record returns the values of all positional properties of the compile-time type.</span></span> <span data-ttu-id="852a6-235">Değişken türü bir temel kayıt ise, nesne türetilmiş türe yayınlanmadığı müddetçe yalnızca temel kayıt özellikleri kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="852a6-235">If the variable type is a base record, only the base record properties are deconstructed unless the object is cast to the derived type.</span></span> <span data-ttu-id="852a6-236">Aşağıdaki örnekte, türetilmiş bir kayıttaki bir Deconstructor çağrısı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="852a6-236">The following example demonstrates calling a deconstructor on a derived record.</span></span>

:::code language="csharp" source="snippets/shared/RecordType.cs" id="DeconstructorInheritance":::

## <a name="generic-constraints"></a><span data-ttu-id="852a6-237">Genel kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="852a6-237">Generic constraints</span></span>

<span data-ttu-id="852a6-238">Bir türün kayıt olmasını gerektiren genel kısıtlama yoktur.</span><span class="sxs-lookup"><span data-stu-id="852a6-238">There is no generic constraint that requires a type to be a record.</span></span> <span data-ttu-id="852a6-239">Kısıtlamayı karşılayan kayıtlar `class` .</span><span class="sxs-lookup"><span data-stu-id="852a6-239">Records satisfy the `class` constraint.</span></span> <span data-ttu-id="852a6-240">Belirli bir kayıt türü hiyerarşisinde kısıtlama yapmak için, kısıtlamayı temel bir sınıf olacak şekilde temel kayda koyun.</span><span class="sxs-lookup"><span data-stu-id="852a6-240">To make a constraint on a specific hierarchy of record types, put the constraint on the base record as you would a base class.</span></span> <span data-ttu-id="852a6-241">Daha fazla bilgi için bkz. [tür parametrelerindeki kısıtlamalar](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="852a6-241">For more information, see [Constraints on type parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="852a6-242">C# dili belirtimi</span><span class="sxs-lookup"><span data-stu-id="852a6-242">C# language specification</span></span>

<span data-ttu-id="852a6-243">Daha fazla bilgi için [C# dil belirtiminin](~/_csharplang/spec/introduction.md) [sınıflar](~/_csharplang/spec/classes.md) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="852a6-243">For more information, see the [Classes](~/_csharplang/spec/classes.md) section of the [C# language specification](~/_csharplang/spec/introduction.md).</span></span>

<span data-ttu-id="852a6-244">C# 9 ve sonraki sürümlerde tanıtılan özellikler hakkında daha fazla bilgi için aşağıdaki özellik teklifi notlarına bakın:</span><span class="sxs-lookup"><span data-stu-id="852a6-244">For more information about features introduced in C# 9 and later, see the following feature proposal notes:</span></span>

- [<span data-ttu-id="852a6-245">Kayıtlar</span><span class="sxs-lookup"><span data-stu-id="852a6-245">Records</span></span>](~/_csharplang/proposals/csharp-9.0/records.md)
- [<span data-ttu-id="852a6-246">Yalnızca Init ayarlayıcıları</span><span class="sxs-lookup"><span data-stu-id="852a6-246">Init-only setters</span></span>](~/_csharplang/proposals/csharp-9.0/init.md)
- [<span data-ttu-id="852a6-247">Birlikte değişken dönüşler</span><span class="sxs-lookup"><span data-stu-id="852a6-247">Covariant returns</span></span>](~/_csharplang/proposals/csharp-9.0/covariant-returns.md)

## <a name="see-also"></a><span data-ttu-id="852a6-248">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="852a6-248">See also</span></span>

- [<span data-ttu-id="852a6-249">C# başvurusu</span><span class="sxs-lookup"><span data-stu-id="852a6-249">C# reference</span></span>](../index.md)
- [<span data-ttu-id="852a6-250">Tasarım yönergeleri-sınıf ve yapı arasında seçim yapma</span><span class="sxs-lookup"><span data-stu-id="852a6-250">Design guidelines - Choosing between class and struct</span></span>](../../../standard/design-guidelines/choosing-between-class-and-struct.md)
- [<span data-ttu-id="852a6-251">Tasarım yönergeleri-yapı tasarımı</span><span class="sxs-lookup"><span data-stu-id="852a6-251">Design guidelines - Struct design</span></span>](../../../standard/design-guidelines/struct.md)
- [<span data-ttu-id="852a6-252">Sınıflar ve yapılar</span><span class="sxs-lookup"><span data-stu-id="852a6-252">Classes and structs</span></span>](../../programming-guide/classes-and-structs/index.md)
- [<span data-ttu-id="852a6-253">`with` ifadesini</span><span class="sxs-lookup"><span data-stu-id="852a6-253">`with` expression</span></span>](../operators/with-expression.md)
