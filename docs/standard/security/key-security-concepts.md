---
title: Temel Güvenlik Kavramları
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- unauthorized access
- permissions [.NET Framework]
- security [.NET Framework], about security
ms.assetid: 3cfced4f-ea02-4e66-ae98-d69286363e98
ms.openlocfilehash: b7bcb7e56ca14d129eadcaeac19452d4a443713d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79400661"
---
# <a name="key-security-concepts"></a><span data-ttu-id="fe1d0-102">Temel Güvenlik Kavramları</span><span class="sxs-lookup"><span data-stu-id="fe1d0-102">Key Security Concepts</span></span>
<span data-ttu-id="fe1d0-103">Microsoft .NET Framework, mobil kodla ilgili güvenlik endişelerini gidermeye yardımcı olmak ve bileşenlerin kullanıcıların ne yapmaya yetkili olduğunu belirlemesine olanak tanıyan destek sağlamak için rol tabanlı güvenlik sunar.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-103">The Microsoft .NET Framework offers role-based security to help address security concerns about mobile code and to provide support that enables components to determine what users are authorized to do.</span></span>  
  
## <a name="type-safety-and-security"></a><span data-ttu-id="fe1d0-104">Tip güvenliği ve emniyet</span><span class="sxs-lookup"><span data-stu-id="fe1d0-104">Type safety and security</span></span>  
 <span data-ttu-id="fe1d0-105">Tür güvenli kod, yalnızca erişmeye yetkili olduğu bellek konumlarına erişir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-105">Type-safe code accesses only the memory locations it is authorized to access.</span></span> <span data-ttu-id="fe1d0-106">(Bu tartışma için, tür güvenliği özellikle bellek türü güvenliği anlamına gelir ve daha geniş bir açıdan tür güvenliği ile karıştırılmamalıdır.) Örneğin, tür güvenli kod başka bir nesnenin özel alanlarından değerleri okuyamaz.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-106">(For this discussion, type safety specifically refers to memory type safety and should not be confused with type safety in a broader respect.) For example, type-safe code cannot read values from another object's private fields.</span></span> <span data-ttu-id="fe1d0-107">Türlere yalnızca iyi tanımlanmış, izin verilebilen yollarla erişir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-107">It accesses types only in well-defined, allowable ways.</span></span>  
  
 <span data-ttu-id="fe1d0-108">Tam zamanında (JIT) derleme sırasında, isteğe bağlı bir doğrulama işlemi, tür güvenli olduklarını doğrulamak için jit tarafından derlenecek bir yöntemin meta verilerini ve Microsoft ara dilini (MSIL) inceler.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-108">During just-in-time (JIT) compilation, an optional verification process examines the metadata and Microsoft intermediate language (MSIL) of a method to be JIT-compiled into native machine code to verify that they are type safe.</span></span> <span data-ttu-id="fe1d0-109">Kodun doğrulamayı atlama izni varsa bu işlem atlanır.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-109">This process is skipped if the code has permission to bypass verification.</span></span> <span data-ttu-id="fe1d0-110">Doğrulama hakkında daha fazla bilgi için Yönetilen [Yürütme Süreci'ne](../../../docs/standard/managed-execution-process.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-110">For more information about verification, see [Managed Execution Process](../../../docs/standard/managed-execution-process.md).</span></span>  
  
 <span data-ttu-id="fe1d0-111">Yönetilen kodu çalıştırmak için tür güvenliğinin doğrulanması zorunlu olmasa da, tür güvenliği montaj yalıtımı ve güvenlik zorlamada önemli bir rol oynar.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-111">Although verification of type safety is not mandatory to run managed code, type safety plays a crucial role in assembly isolation and security enforcement.</span></span> <span data-ttu-id="fe1d0-112">Kod güvenli bir tür olduğunda, ortak dil çalışma zamanı derlemeleri birbirinden tamamen yalıtabilir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-112">When code is type safe, the common language runtime can completely isolate assemblies from each other.</span></span> <span data-ttu-id="fe1d0-113">Bu yalıtım, derlemelerin birbirini olumsuz etkilememesini sağlamaya yardımcı olur ve uygulama güvenilirliğini artırır.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-113">This isolation helps ensure that assemblies cannot adversely affect each other and it increases application reliability.</span></span> <span data-ttu-id="fe1d0-114">Tür-güvenli bileşenler, farklı düzeylerde güvenilen olsalar bile aynı işlemde güvenli bir şekilde çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-114">Type-safe components can execute safely in the same process even if they are trusted at different levels.</span></span> <span data-ttu-id="fe1d0-115">Kod güvenli bir şekilde yazılmamışsa, istenmeyen yan etkiler oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-115">When code is not type safe, unwanted side effects can occur.</span></span> <span data-ttu-id="fe1d0-116">Örneğin, çalışma zamanı yönetilen kodun yerel (yönetilmeyen) koda çağrılmasını ve kötü amaçlı işlemler gerçekleştirmesini engelleyemez.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-116">For example, the runtime cannot prevent managed code from calling into native (unmanaged) code and performing malicious operations.</span></span> <span data-ttu-id="fe1d0-117">Kod güvenli olduğunda, çalışma zamanının güvenlik zorlama mekanizması, izin verilmedikçe yerel koda erişmemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-117">When code is type safe, the runtime's security enforcement mechanism ensures that it does not access native code unless it has permission to do so.</span></span> <span data-ttu-id="fe1d0-118">Güvenli olmayan tüm kod, çalıştırmak için <xref:System.Security.Permissions.SecurityPermission> geçen enum <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A> üyesi ile verilmiş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-118">All code that is not type safe must have been granted <xref:System.Security.Permissions.SecurityPermission> with the passed enum member <xref:System.Security.Permissions.SecurityPermissionAttribute.SkipVerification%2A> to run.</span></span>  
  
 <span data-ttu-id="fe1d0-119">Daha fazla bilgi için [Kod Erişim Güvenlik Temelleri'ne](../../../docs/framework/misc/code-access-security-basics.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-119">For more information, see [Code Access Security Basics](../../../docs/framework/misc/code-access-security-basics.md).</span></span>  
  
## <a name="principal"></a><span data-ttu-id="fe1d0-120">Asıl</span><span class="sxs-lookup"><span data-stu-id="fe1d0-120">Principal</span></span>  
 <span data-ttu-id="fe1d0-121">Bir asıl, kullanıcının kimliğini ve rolünü temsil eder ve kullanıcı adına hareket eder.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-121">A principal represents the identity and role of a user and acts on the user's behalf.</span></span> <span data-ttu-id="fe1d0-122">.NET Framework'deki rol tabanlı güvenlik üç tür temeli destekler:</span><span class="sxs-lookup"><span data-stu-id="fe1d0-122">Role-based security in the .NET Framework supports three kinds of principals:</span></span>  
  
- <span data-ttu-id="fe1d0-123">Genel ilkeler, Windows kullanıcıları ve rollerinden bağımsız olarak var olan kullanıcıları ve rolleri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-123">Generic principals represent users and roles that exist independent of Windows users and roles.</span></span>  
  
- <span data-ttu-id="fe1d0-124">Windows ilkeleri, Windows kullanıcılarını ve rollerini (veya Windows gruplarını) temsil eder.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-124">Windows principals represent Windows users and their roles (or their Windows groups).</span></span> <span data-ttu-id="fe1d0-125">Windows ilkesi başka bir kullanıcının kimliğine bürünebilir, bu da ana bilgisayarın o kullanıcıya ait kimliği sunarken bir kaynağa kullanıcı adına erişebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-125">A Windows principal can impersonate another user, which means that the principal can access a resource on a user's behalf while presenting the identity that belongs to that user.</span></span>  
  
- <span data-ttu-id="fe1d0-126">Özel ilkeler, bir uygulama tarafından, o uygulama için gerekli olan herhangi bir şekilde tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-126">Custom principals can be defined by an application in any way that is needed for that particular application.</span></span> <span data-ttu-id="fe1d0-127">Müdürün kimliği ve rolleri hakkında temel kavramları genişletebilirler.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-127">They can extend the basic notion of the principal's identity and roles.</span></span>  
  
 <span data-ttu-id="fe1d0-128">Daha fazla bilgi için [Bkz. Asıl ve Kimlik Nesneleri.](../../../docs/standard/security/principal-and-identity-objects.md)</span><span class="sxs-lookup"><span data-stu-id="fe1d0-128">For more information, see [Principal and Identity Objects](../../../docs/standard/security/principal-and-identity-objects.md).</span></span>  
  
## <a name="authentication"></a><span data-ttu-id="fe1d0-129">Kimlik Doğrulaması</span><span class="sxs-lookup"><span data-stu-id="fe1d0-129">Authentication</span></span>  
 <span data-ttu-id="fe1d0-130">Kimlik doğrulaması, kullanıcının kimlik bilgilerini inceleyerek ve bu kimlik bilgilerini bazı yetkilere karşı doğrulayarak bir müdürün kimliğini bulma ve doğrulama işlemidir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-130">Authentication is the process of discovering and verifying the identity of a principal by examining the user's credentials and validating those credentials against some authority.</span></span> <span data-ttu-id="fe1d0-131">Kimlik doğrulama sırasında elde edilen bilgiler doğrudan kodunuz tarafından kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-131">The information obtained during authentication is directly usable by your code.</span></span> <span data-ttu-id="fe1d0-132">Geçerli kullanıcının kimliğini doğrulamak ve bu müdürün kodunuza erişmesine izin verip vermeyeceğinizi belirlemek için .NET Framework rol tabanlı güvenliği de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-132">You can also use .NET Framework role-based security to authenticate the current user and to determine whether to allow that principal to access your code.</span></span> <span data-ttu-id="fe1d0-133">Belirli roller için <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> asılın nasıl doğrulaşdırılabildiğini örnekler için yöntemin aşırı yüklerine bakın.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-133">See the overloads of the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%2A?displayProperty=nameWithType> method for examples of how to authenticate the principal for specific roles.</span></span> <span data-ttu-id="fe1d0-134">Örneğin, geçerli kullanıcının <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> Yöneticiler grubunun bir üyesi olup olmadığını belirlemek için aşırı yüklemeyi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-134">For example, you can use the <xref:System.Security.Principal.WindowsPrincipal.IsInRole%28System.String%29?displayProperty=nameWithType> overload to determine if the current user is a member of the Administrators group.</span></span>  
  
 <span data-ttu-id="fe1d0-135">Günümüzde birçoğu .NET Framework rol tabanlı güvenlik ile kullanılabilen çeşitli kimlik doğrulama mekanizmaları kullanılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-135">A variety of authentication mechanisms are used today, many of which can be used with .NET Framework role-based security.</span></span> <span data-ttu-id="fe1d0-136">En sık kullanılan mekanizmalardan bazıları temel, özet, Pasaport, işletim sistemi (NTLM veya Kerberos gibi) veya uygulama tanımlı mekanizmalardır.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-136">Some of the most commonly used mechanisms are basic, digest, Passport, operating system (such as NTLM or Kerberos), or application-defined mechanisms.</span></span>  
  
### <a name="example"></a><span data-ttu-id="fe1d0-137">Örnek</span><span class="sxs-lookup"><span data-stu-id="fe1d0-137">Example</span></span>  
 <span data-ttu-id="fe1d0-138">Aşağıdaki örnek, etkin müdürün yönetici olmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-138">The following example requires that the active principal be an administrator.</span></span> <span data-ttu-id="fe1d0-139">`name` Parametre, yönetici olan herhangi bir kullanıcının talebi geçirmesini `null`sağlar.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-139">The `name` parameter is `null`, which allows any user who is an administrator to pass the demand.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fe1d0-140">Windows Vista'da, Kullanıcı Hesabı Denetimi (UAC) bir kullanıcının ayrıcalıklarını belirler.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-140">In Windows Vista, User Account Control (UAC) determines the privileges of a user.</span></span> <span data-ttu-id="fe1d0-141">Yerleşik Yöneticiler grubunun bir üyesi iseniz, size iki çalışma zamanı erişim belirteci atanır: Standart kullanıcı erişim belirteci ve yönetici erişim belirteci.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-141">If you are a member of the Built-in Administrators group, you are assigned two run-time access tokens: a standard user access token and an administrator access token.</span></span> <span data-ttu-id="fe1d0-142">Varsayılan olarak, standart kullanıcı rolünde olursunuz.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-142">By default, you are in the standard user role.</span></span> <span data-ttu-id="fe1d0-143">Yönetici olmanızı gerektiren kodu yürütmek için öncelikle ayrıcalıklarınızı standart kullanıcıdan yöneticiye yükseltmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-143">To execute the code that requires you to be an administrator, you must first elevate your privileges from standard user to administrator.</span></span> <span data-ttu-id="fe1d0-144">Bunu, uygulama simgesine sağ tıklayarak ve yönetici olarak çalıştırmak istediğinizi belirterek bir uygulamayı başlattığınızda yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-144">You can do this when you start an application by right-clicking the application icon and indicating that you want to run as an administrator.</span></span>  
  
 [!code-cpp[Classic PrincipalPermission Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CPP/source.cpp#1)]
 [!code-csharp[Classic PrincipalPermission Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/CS/source.cs#1)]
 [!code-vb[Classic PrincipalPermission Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic PrincipalPermission Example/VB/source.vb#1)]  
  
 <span data-ttu-id="fe1d0-145">Aşağıdaki örnek, asılın kimliğinin ve asılların kullanabileceği rollerin nasıl belirlenip belirlendirilebildiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-145">The following example demonstrates how to determine the identity of the principal and the roles available to the principal.</span></span> <span data-ttu-id="fe1d0-146">Bu örneğin bir uygulaması, geçerli kullanıcının uygulamanızı kullanmak için izin verdiğiniz bir rolde olduğunu onaylamak için olabilir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-146">An application of this example might be to confirm that the current user is in a role you allow for using your application.</span></span>  
  
 [!code-cpp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CPP/source.cpp#1)]
 [!code-csharp[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/CS/source.cs#1)]
 [!code-vb[System.Security.Principal.WindowsBuiltInRole Example#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Principal.WindowsBuiltInRole Example/VB/source.vb#1)]  
  
## <a name="authorization"></a><span data-ttu-id="fe1d0-147">Yetkilendirme</span><span class="sxs-lookup"><span data-stu-id="fe1d0-147">Authorization</span></span>  
 <span data-ttu-id="fe1d0-148">Yetkilendirme, bir asıl'un istenen bir eylemi gerçekleştirmesine izin verilip verilmediğini belirleme işlemidir.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-148">Authorization is the process of determining whether a principal is allowed to perform a requested action.</span></span> <span data-ttu-id="fe1d0-149">Yetkilendirme kimlik doğrulamadan sonra gerçekleşir ve müdürün hangi kaynaklara erişebileceğini belirlemek için müdürün kimliği ve rolleri hakkındaki bilgileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-149">Authorization occurs after authentication and uses information about the principal's identity and roles to determine what resources the principal can access.</span></span> <span data-ttu-id="fe1d0-150">Yetkilendirmeyi uygulamak için .NET Framework rol tabanlı güvenliği kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fe1d0-150">You can use .NET Framework role-based security to implement authorization.</span></span>
