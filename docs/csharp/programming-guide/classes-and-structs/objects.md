---
title: Nesneler - C# Programlama Kılavuzu
ms.date: 07/20/2015
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: 09b290713f3bc2a7a7824bb19c98138943ad5b2c
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "77673387"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="76e27-102">Nesneler (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="76e27-102">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="76e27-103">Sınıf veya yapı tanımı, türün neler yapabileceğini belirten bir plan gibidir.</span><span class="sxs-lookup"><span data-stu-id="76e27-103">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="76e27-104">Bir nesne temelde plana göre ayrılmış ve yapılandırılan bir bellek bloğudur.</span><span class="sxs-lookup"><span data-stu-id="76e27-104">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="76e27-105">Bir program aynı sınıftan birçok nesne oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="76e27-105">A program may create many objects of the same class.</span></span> <span data-ttu-id="76e27-106">Nesnelere örnek olarak da adlandırılır ve adlandırılmış bir değişkende veya bir dizi veya koleksiyonda depolanabilirler.</span><span class="sxs-lookup"><span data-stu-id="76e27-106">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="76e27-107">İstemci kodu, yöntemleri çağırmak ve nesnenin ortak özelliklerine erişmek için bu değişkenleri kullanan koddur.</span><span class="sxs-lookup"><span data-stu-id="76e27-107">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="76e27-108">C# gibi nesne yönelimli bir dilde, tipik bir program dinamik olarak etkileşimedebilen birden çok nesneden oluşur.</span><span class="sxs-lookup"><span data-stu-id="76e27-108">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="76e27-109">Statik türleri burada açıklanandan farklı davranın.</span><span class="sxs-lookup"><span data-stu-id="76e27-109">Static types behave differently than what is described here.</span></span> <span data-ttu-id="76e27-110">Daha fazla bilgi için Statik [Sınıflar ve Statik Sınıf Üyeleri'ne](./static-classes-and-static-class-members.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="76e27-110">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="76e27-111">Struct Örnekleri ve Sınıf Örnekleri</span><span class="sxs-lookup"><span data-stu-id="76e27-111">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="76e27-112">Sınıflar başvuru türleri olduğundan, sınıf nesnesinin değişkeni yönetilen yığındaki nesnenin adresine başvuruda bulundu.</span><span class="sxs-lookup"><span data-stu-id="76e27-112">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="76e27-113">İlk nesneye aynı türden ikinci bir nesne atanmışsa, her iki değişken de bu adresteki nesneye başvurur.</span><span class="sxs-lookup"><span data-stu-id="76e27-113">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="76e27-114">Bu nokta daha sonra bu konuda daha ayrıntılı olarak ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="76e27-114">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="76e27-115">Sınıf örnekleri [yeni işleç](../../language-reference/operators/new-operator.md)kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="76e27-115">Instances of classes are created by using the [new operator](../../language-reference/operators/new-operator.md).</span></span> <span data-ttu-id="76e27-116">Aşağıdaki örnekte, `Person` türü ve `person1` `person 2` örnekleri veya nesneleri, bu tür.</span><span class="sxs-lookup"><span data-stu-id="76e27-116">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 <span data-ttu-id="76e27-117">Yapı türleri değer türleri olduğundan, bir yapı nesnesinin değişkeni tüm nesnenin bir kopyasını tutar.</span><span class="sxs-lookup"><span data-stu-id="76e27-117">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="76e27-118">`new` İşleç kullanılarak da yapı örnekleri oluşturulabilir, ancak aşağıdaki örnekte gösterildiği gibi bu gerekli değildir:</span><span class="sxs-lookup"><span data-stu-id="76e27-118">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 <span data-ttu-id="76e27-119">Her ikisi `p1` için `p2` bellek ve iş parçacığı yığını üzerinde ayrılır.</span><span class="sxs-lookup"><span data-stu-id="76e27-119">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="76e27-120">Bu bellek, beyan edildiği tür veya yöntemle birlikte geri alınır.</span><span class="sxs-lookup"><span data-stu-id="76e27-120">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="76e27-121">Bu, yapıların atamada kopyalanmasının nedenlerinden biridir.</span><span class="sxs-lookup"><span data-stu-id="76e27-121">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="76e27-122">Bunun aksine, bir sınıf örneği için ayrılan bellek, nesneye yapılan tüm başvurular kapsam dışına çıktığında ortak dil çalışma süresi tarafından otomatik olarak geri alınır (çöp toplanır).</span><span class="sxs-lookup"><span data-stu-id="76e27-122">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="76e27-123">C++'da yaptığınız gibi bir sınıf nesnesini deterministically yok etmek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="76e27-123">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="76e27-124">.NET Framework'de çöp toplama hakkında daha fazla bilgi için [Çöp Toplama'ya](../../../standard/garbage-collection/index.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="76e27-124">For more information about garbage collection in the .NET Framework, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="76e27-125">Yönetilen yığındaki belleğin tahsisi ve deallocation'ı ortak dil çalışma zamanında son derece iyi leştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="76e27-125">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="76e27-126">Çoğu durumda yığında bir sınıf örneğini ayırmanın performans maliyetinde, yığına bir yapı örneği ayırmanın karşı sıcağı sıcağısı önemli bir fark yoktur.</span><span class="sxs-lookup"><span data-stu-id="76e27-126">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="76e27-127">Nesne Kimliği ve Değer Eşitliği</span><span class="sxs-lookup"><span data-stu-id="76e27-127">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="76e27-128">Eşitlik için iki nesneyi karşılaştırdığınızda, öncelikle iki değişkenin bellekte aynı nesneyi temsil edip etmediğini veya bir veya daha fazla alanının değerlerinin eşdeğer olup olmadığını ayırt etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="76e27-128">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="76e27-129">Değerleri karşılaştırmak istiyorsanız, nesnelerin değer türleri (yapı türleri) veya başvuru türleri (sınıflar, temsilciler, diziler) örnekleri olup olmadığını göz önünde bulundurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="76e27-129">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
- <span data-ttu-id="76e27-130">İki sınıf örneğinin bellekte aynı konuma başvurup başvurmadığını (yani aynı *kimliğe*sahip olduklarını) belirlemek için statik <xref:System.Object.Equals%2A> yöntemi kullanın.</span><span class="sxs-lookup"><span data-stu-id="76e27-130">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="76e27-131">(<xref:System.Object?displayProperty=nameWithType> kullanıcı tanımlı yapı ve sınıflar da dahil olmak üzere tüm değer türleri ve başvuru türleri için örtük taban sınıftır.)</span><span class="sxs-lookup"><span data-stu-id="76e27-131">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
- <span data-ttu-id="76e27-132">İki yapı örneğindeki örnek alanlarının aynı değerlere sahip olup <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> olmadığını belirlemek için yöntemi kullanın.</span><span class="sxs-lookup"><span data-stu-id="76e27-132">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="76e27-133">Tüm yapılardan dolaylı olarak devraldığı <xref:System.ValueType?displayProperty=nameWithType>için, yöntemi aşağıdaki örnekte gösterildiği gibi doğrudan nesnenize çağırırsınız:</span><span class="sxs-lookup"><span data-stu-id="76e27-133">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 <span data-ttu-id="76e27-134">Herhangi <xref:System.ValueType?displayProperty=nameWithType> bir `Equals` yapıda alanların ne olduğunu belirleyebilmesi gerektiğinden yansımanın uygulanması.</span><span class="sxs-lookup"><span data-stu-id="76e27-134">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="76e27-135">Kendi yapılarınızı oluştururken, türünüze `Equals` özgü verimli bir eşitlik algoritması sağlamak için yöntemi geçersiz kılın.</span><span class="sxs-lookup"><span data-stu-id="76e27-135">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
- <span data-ttu-id="76e27-136">İki sınıf örneğindeki alanların değerlerinin eşit olup olmadığını belirlemek için <xref:System.Object.Equals%2A> yöntemi veya [== işlecik'i](../../language-reference/operators/equality-operators.md#equality-operator-)kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="76e27-136">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../language-reference/operators/equality-operators.md#equality-operator-).</span></span> <span data-ttu-id="76e27-137">Ancak, yalnızca sınıf bunları geçersiz kılmış veya aşırı yüklemişse, "eşitlik"in bu tür nesneler için ne anlama geldiğinin özel bir tanımını sağlamak için kullanın.</span><span class="sxs-lookup"><span data-stu-id="76e27-137">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="76e27-138">Sınıf, <xref:System.IEquatable%601> arabirimi veya <xref:System.Collections.Generic.IEqualityComparer%601> arabirimi de uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="76e27-138">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="76e27-139">Her iki arabirim de değer eşitliğini sınamak için kullanılabilecek yöntemler sağlar.</span><span class="sxs-lookup"><span data-stu-id="76e27-139">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="76e27-140">Geçersiz kılınan `Equals`kendi sınıflarınızı tasarlarken, bir tür ve <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>değer [eşitliğini nasıl tanımlarsınız'da](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) belirtilen yönergelere uyduğunuzdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="76e27-140">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to define value equality for a type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>
  
## <a name="related-sections"></a><span data-ttu-id="76e27-141">İlgili Bölümler</span><span class="sxs-lookup"><span data-stu-id="76e27-141">Related Sections</span></span>  
 <span data-ttu-id="76e27-142">Daha fazla bilgi için:</span><span class="sxs-lookup"><span data-stu-id="76e27-142">For more information:</span></span>  
  
- [<span data-ttu-id="76e27-143">Sınıflar</span><span class="sxs-lookup"><span data-stu-id="76e27-143">Classes</span></span>](./classes.md)  
  
- [<span data-ttu-id="76e27-144">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="76e27-144">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="76e27-145">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="76e27-145">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="76e27-146">Olaylar</span><span class="sxs-lookup"><span data-stu-id="76e27-146">Events</span></span>](../events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="76e27-147">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="76e27-147">See also</span></span>

- [<span data-ttu-id="76e27-148">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="76e27-148">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="76e27-149">Nesne</span><span class="sxs-lookup"><span data-stu-id="76e27-149">object</span></span>](../../language-reference/builtin-types/reference-types.md)
- [<span data-ttu-id="76e27-150">Devralma</span><span class="sxs-lookup"><span data-stu-id="76e27-150">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="76e27-151">Sınıfı</span><span class="sxs-lookup"><span data-stu-id="76e27-151">class</span></span>](../../language-reference/keywords/class.md)
- [<span data-ttu-id="76e27-152">Yapı türleri</span><span class="sxs-lookup"><span data-stu-id="76e27-152">Structure types</span></span>](../../language-reference/builtin-types/struct.md)
- [<span data-ttu-id="76e27-153">new İşleci</span><span class="sxs-lookup"><span data-stu-id="76e27-153">new Operator</span></span>](../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="76e27-154">Ortak Tür Sistemi</span><span class="sxs-lookup"><span data-stu-id="76e27-154">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
