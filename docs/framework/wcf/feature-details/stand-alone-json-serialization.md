---
title: DataContractJsonSerializer kullanarak Tek Başına JSON Serileştirme
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: 614776a905ec319624f76876762c25bfca15a357
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249454"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="d774a-102">DataContractJsonSerializer kullanarak Tek Başına JSON Serileştirme</span><span class="sxs-lookup"><span data-stu-id="d774a-102">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="d774a-103">Bu makale <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>hakkında .</span><span class="sxs-lookup"><span data-stu-id="d774a-103">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="d774a-104">JSON'u serihale ve deserializing içeren çoğu senaryo için [System.Text.Json ad alanında](../../../standard/serialization/system-text-json-overview.md)API'leri öneririz.</span><span class="sxs-lookup"><span data-stu-id="d774a-104">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="d774a-105">JSON (JavaScript Object Notation), tarayıcının içindeki Web sayfalarında çalışan JavaScript kodu tarafından kullanılmak üzere özel olarak tasarlanmış bir veri biçimidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-105">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="d774a-106">Windows Communication Foundation (WCF) ASP.NET AJAX hizmetleri tarafından kullanılan varsayılan veri biçimidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-106">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="d774a-107">Bu biçim, ASP.NET ile tümleştirme den AJAX hizmetleri oluştururken de kullanılabilir - bu durumda, XML varsayılandır ancak JSON seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-107">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="d774a-108">Son olarak, JSON desteğine ihtiyaç duyuyorsanız ancak <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> bir AJAX hizmeti oluşturmuyorsanız, .NET nesnelerini doğrudan JSON verilerine seri hale getirmek ve bu tür verileri .NET türleri örneklerine yeniden dizileştirebilmek mümkün olur.</span><span class="sxs-lookup"><span data-stu-id="d774a-108">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="d774a-109">Bunun nasıl yapılacağının açıklaması için [bkz: Serialize ve Deserialize JSON Verileri.](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md)</span><span class="sxs-lookup"><span data-stu-id="d774a-109">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](../../../../docs/framework/wcf/feature-details/how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="d774a-110">JSON ile çalışırken, aynı .NET türleri, birkaç istisna dışında, <xref:System.Runtime.Serialization.DataContractSerializer>tarafından desteklenen .</span><span class="sxs-lookup"><span data-stu-id="d774a-110">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="d774a-111">Desteklenen türlerin listesi için [bkz.](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md)</span><span class="sxs-lookup"><span data-stu-id="d774a-111">For a list of the types supported, see [Types Supported by the Data Contract Serializer](../../../../docs/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="d774a-112">Bu en ilkel türleri, en dizi ve koleksiyon türleri yanı <xref:System.Runtime.Serialization.DataContractAttribute> <xref:System.Runtime.Serialization.DataMemberAttribute>sıra ve kullanan karmaşık türleri içerir.</span><span class="sxs-lookup"><span data-stu-id="d774a-112">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="d774a-113">JSON Türlerine .NET türlerini eşleme</span><span class="sxs-lookup"><span data-stu-id="d774a-113">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="d774a-114">Aşağıdaki tabloda serileştirme ve deserialization yordamları ile eşlendiğinde .NET türleri ile JSON/JavaScript türleri arasındaki yazışmalar gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="d774a-114">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="d774a-115">.NET Türleri</span><span class="sxs-lookup"><span data-stu-id="d774a-115">.NET Types</span></span>|<span data-ttu-id="d774a-116">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="d774a-116">JSON/JavaScript</span></span>|<span data-ttu-id="d774a-117">Notlar</span><span class="sxs-lookup"><span data-stu-id="d774a-117">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="d774a-118">Tüm sayısal türleri, örneğin <xref:System.Int32> <xref:System.Decimal> , veya<xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="d774a-118">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="d774a-119">Sayı</span><span class="sxs-lookup"><span data-stu-id="d774a-119">Number</span></span>|<span data-ttu-id="d774a-120">' `Double.NaN` `Double.PositiveInfinity` ve desteklenmez ve `Double.NegativeInfinity` geçersiz JSON ile sonuçlanır gibi özel değerler.</span><span class="sxs-lookup"><span data-stu-id="d774a-120">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="d774a-121">Sayı</span><span class="sxs-lookup"><span data-stu-id="d774a-121">Number</span></span>|<span data-ttu-id="d774a-122">Bu konunun ilerleyen saatlerinde "Sonlandırma ve JSON" konusuna bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-122">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="d774a-123">Boole</span><span class="sxs-lookup"><span data-stu-id="d774a-123">Boolean</span></span>|--|
|<span data-ttu-id="d774a-124"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="d774a-124"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="d774a-125">Dize</span><span class="sxs-lookup"><span data-stu-id="d774a-125">String</span></span>|--|
|<span data-ttu-id="d774a-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="d774a-126"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="d774a-127">Dize</span><span class="sxs-lookup"><span data-stu-id="d774a-127">String</span></span>|<span data-ttu-id="d774a-128">JSON bu tür biçimi XML (aslında, ISO 8601 Süre biçiminde TimeSpan, "12345678-ABCD-ABCD-ABCD-1234567890AB" biçiminde GUID ve " "http://www.example.comgibi doğal dize şeklinde URI) aynıdır.</span><span class="sxs-lookup"><span data-stu-id="d774a-128">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="d774a-129">Kesin bilgi için Bkz. [Veri Sözleşmesi Şeması Referansı.](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md)</span><span class="sxs-lookup"><span data-stu-id="d774a-129">For precise information, see [Data Contract Schema Reference](../../../../docs/framework/wcf/feature-details/data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="d774a-130">Dize</span><span class="sxs-lookup"><span data-stu-id="d774a-130">String</span></span>|<span data-ttu-id="d774a-131">Biçim "name:namespace" (ilk üst üste önce bir şey addır).</span><span class="sxs-lookup"><span data-stu-id="d774a-131">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="d774a-132">Ad veya ad alanı eksik olabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-132">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="d774a-133">Ad alanı yoksa, iki nokta üst üste de atlanabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-133">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="d774a-134"><xref:System.Array>türü<xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="d774a-134"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="d774a-135">Sayı dizisi</span><span class="sxs-lookup"><span data-stu-id="d774a-135">Array of numbers</span></span>|<span data-ttu-id="d774a-136">Her sayı bir bayt değerini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d774a-136">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="d774a-137">DateTime veya String</span><span class="sxs-lookup"><span data-stu-id="d774a-137">DateTime or String</span></span>|<span data-ttu-id="d774a-138">Bu konunun ilerleyen dönemlerinde Tarihler/Saatler ve JSON'a bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-138">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="d774a-139">Karmaşık tür</span><span class="sxs-lookup"><span data-stu-id="d774a-139">Complex type</span></span>|<span data-ttu-id="d774a-140">Bu konunun ilerleyen dönemlerinde Tarihler/Saatler ve JSON'a bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-140">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="d774a-141">XML ve ADO.NET<xref:System.Xml.XmlElement>tipleri ( ,</span><span class="sxs-lookup"><span data-stu-id="d774a-141">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="d774a-142"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="d774a-142"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="d774a-143">Diziler <xref:System.Xml.XmlNode>,</span><span class="sxs-lookup"><span data-stu-id="d774a-143">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="d774a-144"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="d774a-144"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="d774a-145"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="d774a-145"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="d774a-146">Dize</span><span class="sxs-lookup"><span data-stu-id="d774a-146">String</span></span>|<span data-ttu-id="d774a-147">Bu konunun XML Türleri ve JSON bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-147">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="d774a-148">Boş karmaşık türü</span><span class="sxs-lookup"><span data-stu-id="d774a-148">Empty complex type</span></span>|--|
|<span data-ttu-id="d774a-149">Koleksiyonlar, sözlükler ve diziler</span><span class="sxs-lookup"><span data-stu-id="d774a-149">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="d774a-150">Dizi</span><span class="sxs-lookup"><span data-stu-id="d774a-150">Array</span></span>|<span data-ttu-id="d774a-151">Bu konunun Koleksiyonlar, Sözlükler ve Diziler bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-151">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="d774a-152">Karmaşık türleri <xref:System.Runtime.Serialization.DataContractAttribute> (veya <xref:System.SerializableAttribute> uygulanan ile)</span><span class="sxs-lookup"><span data-stu-id="d774a-152">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="d774a-153">Karmaşık tür</span><span class="sxs-lookup"><span data-stu-id="d774a-153">Complex type</span></span>|<span data-ttu-id="d774a-154">Veri üyeleri JavaScript karmaşık türüne üye olur.</span><span class="sxs-lookup"><span data-stu-id="d774a-154">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="d774a-155"><xref:System.Runtime.Serialization.ISerializable> Arabirimi uygulayan karmaşık türler)</span><span class="sxs-lookup"><span data-stu-id="d774a-155">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="d774a-156">Karmaşık tür</span><span class="sxs-lookup"><span data-stu-id="d774a-156">Complex type</span></span>|<span data-ttu-id="d774a-157">Diğer karmaşık türleri ile <xref:System.Runtime.Serialization.ISerializable> aynı ancak bazı türleri desteklenmez – bu konunun Gelişmiş Bilgiler bölümünün ISerializable Destek bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-157">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="d774a-158">`Null`herhangi bir tür için değer</span><span class="sxs-lookup"><span data-stu-id="d774a-158">`Null` value for any type</span></span>|<span data-ttu-id="d774a-159">Null</span><span class="sxs-lookup"><span data-stu-id="d774a-159">Null</span></span>|<span data-ttu-id="d774a-160">Nullable değer türleri de desteklenir ve boşolmayan değer türleri ile aynı şekilde JSON eşlenir.</span><span class="sxs-lookup"><span data-stu-id="d774a-160">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="d774a-161">Sayısallaştırmalar ve JSON</span><span class="sxs-lookup"><span data-stu-id="d774a-161">Enumerations and JSON</span></span>

<span data-ttu-id="d774a-162">Numaralandırma üye değerleri JSON'da sayı olarak değerlendirilir, bu da veri sözleşmelerinde nasıl ele alındıklarından farklıdır ve üye adolarak dahil edilirler.</span><span class="sxs-lookup"><span data-stu-id="d774a-162">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="d774a-163">Veri sözleşmesi tedavisi hakkında daha fazla bilgi için, [Veri Sözleşmelerinde Numaralandırma Türleri'ne](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-163">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](../../../../docs/framework/wcf/feature-details/enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="d774a-164">Örneğin, varsa, `public enum Color {red, green, blue, yellow, pink}`serileştirme `yellow` "sarı" dizedeğil, 3 sayısını üretir.</span><span class="sxs-lookup"><span data-stu-id="d774a-164">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="d774a-165">Tüm `enum` üyeler serileştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-165">All `enum` members are serializable.</span></span> <span data-ttu-id="d774a-166">Ve <xref:System.Runtime.Serialization.EnumMemberAttribute> <xref:System.NonSerializedAttribute> öznitelikleri kullanılırsa yoksayılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-166">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="d774a-167">Var olmayan bir `enum` değeri deserialize etmek mümkündür - örneğin, değer 87 tanımlanan karşılık gelen renk adı olmamasına rağmen önceki Renk enum içine deserialized olabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-167">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="d774a-168">Bayraklar `enum` özel değildir ve diğer `enum`bayraklar gibi aynı muamele yitirmektir.</span><span class="sxs-lookup"><span data-stu-id="d774a-168">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="d774a-169">Tarihler/Saatler ve JSON</span><span class="sxs-lookup"><span data-stu-id="d774a-169">Dates/Times and JSON</span></span>

<span data-ttu-id="d774a-170">JSON biçimi doğrudan tarihleri ve saatleri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="d774a-170">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="d774a-171">Ancak, çok yaygın olarak kullanılan ve ASP.NET AJAX bu tür için özel destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="d774a-171">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="d774a-172">ASP.NET AJAX yakınlıklarını kullanırken, .NET'teki <xref:System.DateTime> tür `DateTime` JavaScript'teki türe tam olarak karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="d774a-172">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="d774a-173">ASP.NET kullanmadığınızda, <xref:System.DateTime> json'da bir tür, bu konunun Gelişmiş Bilgiler bölümünde açıklanan özel bir biçime sahip bir dize olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-173">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="d774a-174"><xref:System.DateTimeOffset>karmaşık bir tür olarak JSON temsil edilir: {"DateTime":dateTime,"OfsetMinutes":offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="d774a-174"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="d774a-175">Üye, `offsetMinutes` greenwich ortalama saatinden (GMT) gelen yerel saat mahsupedilir ve şimdi de eşgüdümlü Evrensel Zaman (UTC) olarak da adlandırılır ve olayın ilgi çekici yeri ile ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-175">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="d774a-176">Üye, `dateTime` ilgi olayının meydana geldiği zamandaki örneği temsil eder `DateTime` (yine, ASP.NET AJAX kullanımda olduğunda JavaScript'te bir olur ve olmadığında bir dize olur).</span><span class="sxs-lookup"><span data-stu-id="d774a-176">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="d774a-177">Serileştirme `dateTime` de, üye her zaman GMT serihale edilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-177">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="d774a-178">Yani, 03:00 New York `dateTime` saati açıklayan, 8:00 `offsetMinutes` AM bir zaman bileşeni vardır ve 300 (eksi 300 dakika veya GMT 5 saat).</span><span class="sxs-lookup"><span data-stu-id="d774a-178">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="d774a-179"><xref:System.DateTime>ve <xref:System.DateTimeOffset> nesneler, JSON'a serileştirildiğinde, bilgileri yalnızca milisaniye hassasiyete kadar korur.</span><span class="sxs-lookup"><span data-stu-id="d774a-179"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="d774a-180">Alt milisaniye değerleri (mikro/nanosaniye) serileştirme sırasında kaybolur.</span><span class="sxs-lookup"><span data-stu-id="d774a-180">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="d774a-181">XML Türleri ve JSON</span><span class="sxs-lookup"><span data-stu-id="d774a-181">XML Types and JSON</span></span>

<span data-ttu-id="d774a-182">XML türleri JSON dizeleri olur.</span><span class="sxs-lookup"><span data-stu-id="d774a-182">XML types become JSON strings.</span></span>

- <span data-ttu-id="d774a-183">Örneğin, XElement türünden bir veri üyesi \<"q" abc/> içeriyorsa,\<JSON {"q":" abc/>"}olur.</span><span class="sxs-lookup"><span data-stu-id="d774a-183">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="d774a-184">XML'in nasıl paketlediğini belirten bazı özel kurallar vardır - daha fazla bilgi için bu konunun ilerleyen bölümlerinde Gelişmiş Bilgiler bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-184">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="d774a-185">ASP.NET AJAX kullanıyorsanız ve JavaScript dizeleri kullanmak istemiyorsanız, ancak XML DOM yerine <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> istiyorsanız, XML <xref:System.ServiceModel.Web.WebGetAttribute> <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> veya XML için <xref:System.ServiceModel.Web.WebInvokeAttribute>özelliği ayarlayın .</span><span class="sxs-lookup"><span data-stu-id="d774a-185">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="d774a-186">Koleksiyonlar, Sözlükler ve Diziler</span><span class="sxs-lookup"><span data-stu-id="d774a-186">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="d774a-187">Tüm koleksiyonlar, sözlükler ve diziler JSON'da dizi olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-187">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="d774a-188">Kullanan <xref:System.Runtime.Serialization.CollectionDataContractAttribute> herhangi bir özelleştirme JSON gösteriminde yoksayılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-188">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="d774a-189">Sözlükler doğrudan JSON ile çalışmak için bir yol değildir.</span><span class="sxs-lookup"><span data-stu-id="d774a-189">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="d774a-190">Sözlük\<dizesi, nesne> wcf diğer JSON teknolojileri ile çalışan beklendiği gibi aynı şekilde desteklenmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-190">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="d774a-191">Örneğin, "abc" "xyz" ve "def" sözlükte 42 olarak eşlenirse, JSON gösterimi {"abc":"xyz","def":42} değil, [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] yerine.</span><span class="sxs-lookup"><span data-stu-id="d774a-191">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="d774a-192">JSON ile doğrudan çalışmak istiyorsanız (katı bir sözleşmeyi önceden tanımlamadan tuşlara ve değerlere dinamik olarak erişme), birkaç seçeneğiniz var:</span><span class="sxs-lookup"><span data-stu-id="d774a-192">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="d774a-193">[Zayıf yazılanmış JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) örneğini kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="d774a-193">Consider using the [Weakly-typed JSON Serialization (AJAX)](../../../../docs/framework/wcf/samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="d774a-194"><xref:System.Runtime.Serialization.ISerializable> Arabirimi ve deserialization oluşturucuları kullanmayı düşünün - bu iki mekanizma, sırasıyla serileştirme ve deserialization JSON anahtar/değer çiftleri erişmenize olanak sağlar, ancak kısmi güven senaryolarında çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="d774a-194">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="d774a-195">Bir serializer kullanmak yerine [JSON ve XML arasındaki Haritalama](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) ile çalışmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="d774a-195">Consider working with the [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="d774a-196">Serileştirme bağlamında *çok biçimlilik,* türemiş bir türü, taban türünün beklendiği yerde serileştirme yeteneğini ifade eder.</span><span class="sxs-lookup"><span data-stu-id="d774a-196">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="d774a-197">Koleksiyonları çok biçimli olarak kullanırken, örneğin bir koleksiyona bir <xref:System.Object>koleksiyon atarken, JSON'a özgü özel kurallar vardır.</span><span class="sxs-lookup"><span data-stu-id="d774a-197">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="d774a-198">Bu konu daha sonra bu konuda İleri Bilgiler bölümünde daha tam olarak ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="d774a-198">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="d774a-199">Ek Ayrıntılar</span><span class="sxs-lookup"><span data-stu-id="d774a-199">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="d774a-200">Veri Üyeleri Sırası</span><span class="sxs-lookup"><span data-stu-id="d774a-200">Order of Data Members</span></span>

<span data-ttu-id="d774a-201">JSON kullanırken veri üyelerinin sırası önemli değildir.</span><span class="sxs-lookup"><span data-stu-id="d774a-201">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="d774a-202">Özellikle, ayarlanmış olsa <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> bile, JSON verileri yine de herhangi bir sırada deserialized olabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-202">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="d774a-203">JSON Türleri</span><span class="sxs-lookup"><span data-stu-id="d774a-203">JSON Types</span></span>

<span data-ttu-id="d774a-204">JSON türü deserialization önceki tablo eşleşmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="d774a-204">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="d774a-205">Örneğin, normalde `Int` bir JSON numarasıyla eşleşir, ancak bu dize geçerli bir sayı içerdiği sürece JSON dizesinden başarıyla deserialed edilebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-205">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="d774a-206">Diğer bir nokta, "q" adlı bir `Int` veri üyesi varsa hem {"q":42} hem de {"q":"42"} geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-206">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="d774a-207">Çok biçimlilik</span><span class="sxs-lookup"><span data-stu-id="d774a-207">Polymorphism</span></span>

<span data-ttu-id="d774a-208">Polimorfik serileştirme, türemiş bir türü, taban türünün beklendiği yerde serileştirme yeteneğinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="d774a-208">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="d774a-209">Bu, XML serileştirmenin desteklenme şekliyle karşılaştırılabilir WCF tarafından JSON serileştirmesi için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d774a-209">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="d774a-210">`MyDerivedType` Örneğin, beklendiği yeri `MyBaseType` serihale getirebilir veya `Int` beklendiği `Object` yeri serihale edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d774a-210">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="d774a-211">Karmaşık bir türü deserializing sürece, taban türü bekleniyorsa türemiş bir tür deserializing kaybolabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-211">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="d774a-212">Örneğin, beklenen <xref:System.Uri> yerde <xref:System.Object> seri hale getirilirse, json dizesi ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="d774a-212">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="d774a-213">Bu dize daha sonra tekrar <xref:System.Object>deserialized <xref:System.String> ise , bir .NET döndürülür.</span><span class="sxs-lookup"><span data-stu-id="d774a-213">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="d774a-214">Deserializer dize türü başlangıçta olduğunu <xref:System.Uri>bilmiyor.</span><span class="sxs-lookup"><span data-stu-id="d774a-214">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="d774a-215">Genellikle, beklerken, <xref:System.Object>tüm JSON dizeleri .NET dizeleri olarak deserialized ve tüm JSON dizileri serialize .NET koleksiyonları, sözlükler ve <xref:System.Array> diziler , ne olursa olsun gerçek orijinal türü ne olursa olsun <xref:System.Object>.NET olarak deserialized.</span><span class="sxs-lookup"><span data-stu-id="d774a-215">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="d774a-216">Bir JSON boolean haritaları <xref:System.Boolean>bir .NET .</span><span class="sxs-lookup"><span data-stu-id="d774a-216">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="d774a-217"><xref:System.Object>Ancak, json numaraları <xref:System.Int32>,.NET olarak <xref:System.Decimal> <xref:System.Double>deserialized veya , en uygun türü otomatik olarak seçilir bekliyor.</span><span class="sxs-lookup"><span data-stu-id="d774a-217">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="d774a-218">Arabirim türüne deserializing, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> bildirilen türü nesne gibi deserialize.</span><span class="sxs-lookup"><span data-stu-id="d774a-218">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="d774a-219">Kendi tabanınız ve türetilmiş türleriile <xref:System.ServiceModel.ServiceKnownTypeAttribute> çalışırken, normalde eşdeğer bir mekanizma yı kullanmak <xref:System.Runtime.Serialization.KnownTypeAttribute>gerekir.</span><span class="sxs-lookup"><span data-stu-id="d774a-219">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="d774a-220">Örneğin, iade değeri olan bir `Animal` işleminz varsa ve bu `Cat` işlem gerçekten `Animal`bir örneğini <xref:System.Runtime.Serialization.KnownTypeAttribute>döndürürse (türetilmiş), ya , `Animal` türe veya <xref:System.ServiceModel.ServiceKnownTypeAttribute> operasyona uygulamalı ve bu özniteliklerdeki `Cat` türü belirtmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="d774a-220">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="d774a-221">Daha fazla bilgi için [bkz.](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md)</span><span class="sxs-lookup"><span data-stu-id="d774a-221">For more information, see [Data Contract Known Types](../../../../docs/framework/wcf/feature-details/data-contract-known-types.md).</span></span>

<span data-ttu-id="d774a-222">Polimorfik serileştirmenin nasıl çalıştığına ilişkin ayrıntılar ve kullanırken uyulması gereken bazı sınırlamaların tartışılması için, bu konunun ilerleyen bölümlerinde Gelişmiş Bilgiler bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-222">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="d774a-223">Sürüm Oluşturma</span><span class="sxs-lookup"><span data-stu-id="d774a-223">Versioning</span></span>

<span data-ttu-id="d774a-224"><xref:System.Runtime.Serialization.IExtensibleDataObject> Arayüz de dahil olmak üzere veri sözleşmesi sürüm özellikleri, JSON'da tam olarak desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d774a-224">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="d774a-225">Ayrıca, çoğu durumda bir tür bir biçimde (örneğin, XML) deserialize ve sonra başka bir biçimde serileştirmek mümkündür (örneğin, JSON) ve hala verileri korumak <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span><span class="sxs-lookup"><span data-stu-id="d774a-225">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="d774a-226">Daha fazla bilgi için, [İleri-Uyumlu Veri Sözleşmeleri'ne](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-226">For more information, see [Forward-Compatible Data Contracts](../../../../docs/framework/wcf/feature-details/forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="d774a-227">JSON'Un siparişsiz olduğunu unutmayın, böylece herhangi bir sipariş bilgisi kaybolur.</span><span class="sxs-lookup"><span data-stu-id="d774a-227">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="d774a-228">Ayrıca, JSON aynı anahtar adı ile birden çok anahtar/değer çiftini desteklemez.</span><span class="sxs-lookup"><span data-stu-id="d774a-228">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="d774a-229">Son olarak, <xref:System.Runtime.Serialization.IExtensibleDataObject> tüm işlemler doğal olarak polimorfik - bu <xref:System.Object>onların türetilmiş türü , tüm türleri için temel türüa atanır.</span><span class="sxs-lookup"><span data-stu-id="d774a-229">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="d774a-230">URL'lerde JSON</span><span class="sxs-lookup"><span data-stu-id="d774a-230">JSON in URLs</span></span>

<span data-ttu-id="d774a-231">HTTP GET fiili (öznitelik kullanarak) <xref:System.ServiceModel.Web.WebGetAttribute> ile ASP.NET AJAX uç noktalarını kullanırken, gelen parametreler ileti gövdesi yerine istek URL'sinde görünür.</span><span class="sxs-lookup"><span data-stu-id="d774a-231">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="d774a-232">JSON istek URL'sinde bile desteklenir, bu nedenle "sayı" adı verilen `Person` ve "p" adı verilen karmaşık bir tür içeren bir `Int` işleminiz varsa, URL aşağıdaki URL'ye benzeyebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-232">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="d774a-233">Hizmeti aramak için ASP.NET bir AJAX Script Manager denetimi ve proxy kullanıyorsanız, bu URL proxy tarafından otomatik olarak oluşturulur ve görülmez.</span><span class="sxs-lookup"><span data-stu-id="d774a-233">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="d774a-234">JSON, NON-ASP.NET AJAX uç noktalarında URL'lerde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="d774a-234">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="d774a-235">Gelişmiş bilgiler</span><span class="sxs-lookup"><span data-stu-id="d774a-235">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="d774a-236">ISerializable Destek</span><span class="sxs-lookup"><span data-stu-id="d774a-236">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="d774a-237">Desteklenen ve Desteklenmeyen ISerializable Türleri</span><span class="sxs-lookup"><span data-stu-id="d774a-237">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="d774a-238">Genel olarak, <xref:System.Runtime.Serialization.ISerializable> arabirimi uygulayan türler JSON'u seri hale/deserializing'de tam olarak desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d774a-238">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="d774a-239">Ancak, bu türlerden bazıları (bazı .NET Framework türleri de dahil olmak üzere) JSON'a özgü serileştirme yönlerinin doğru şekilde deserialize edilmemelerine neden olacak şekilde uygulanır:</span><span class="sxs-lookup"><span data-stu-id="d774a-239">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="d774a-240">Bununla <xref:System.Runtime.Serialization.ISerializable>birlikte, tek tek veri üyelerinin türü önceden bilinmez.</span><span class="sxs-lookup"><span data-stu-id="d774a-240">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="d774a-241">Bu, türleri bir nesneye deserializing benzer bir polimorfik duruma yol açar.</span><span class="sxs-lookup"><span data-stu-id="d774a-241">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="d774a-242">Daha önce de belirtildiği gibi, bu JSON türü bilgilerinin kaybına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-242">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="d774a-243">Örneğin, `enum` bir uygulamayı seri hale getiren <xref:System.Runtime.Serialization.ISerializable> ve json ve JSON `enum` numaralarındaki sayılar kullanılarak seri hale `enum` getirilmiş olduğundan, bir tür doğrudan bir (uygun dökümler olmadan) yeniden seriselleştirmeye çalışır, yerleşik .NET sayısal türlerine (Int32, Ondalık veya Çift) ayrılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-243">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="d774a-244">Yani eskiden bir `enum` değer olan sayının kaybolması.</span><span class="sxs-lookup"><span data-stu-id="d774a-244">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="d774a-245">Deserialization oluşturucusundaki belirli bir deserialization sırasına bağlı olan bir <xref:System.Runtime.Serialization.ISerializable> tür, bazı JSON verilerini deserialize etmekte başarısız olabilir, çünkü çoğu JSON serileştiricisi belirli bir siparişi garanti etmez.</span><span class="sxs-lookup"><span data-stu-id="d774a-245">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="d774a-246">Fabrika Tipleri</span><span class="sxs-lookup"><span data-stu-id="d774a-246">Factory Types</span></span>

<span data-ttu-id="d774a-247"><xref:System.Runtime.Serialization.IObjectReference> Arabirim genel olarak JSON'da desteklenirken, "fabrika türü" özelliğini gerektiren (arabirimi <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> uygulayan türden farklı bir türe örnek döndürme) herhangi bir tür desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="d774a-247">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="d774a-248">DateTime Tel Biçimi</span><span class="sxs-lookup"><span data-stu-id="d774a-248">DateTime Wire Format</span></span>

<span data-ttu-id="d774a-249"><xref:System.DateTime>değerler JSON dizeleri olarak "/Date(700000+0500)/", burada ilk sayı (7000000 verilen örnekte) GMT saat diliminde milisaniye sayısı, gece yarısından bu yana düzenli (gün ışığı dışı) zaman, 1 Ocak 1970 şeklinde görünür.</span><span class="sxs-lookup"><span data-stu-id="d774a-249"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="d774a-250">Sayı daha önceki kez temsil etmek için negatif olabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-250">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="d774a-251">Örnekte "+0500"den oluşan bölüm isteğe bağlıdır ve zamanın <xref:System.DateTimeKind.Local> türünün aynı olduğunu gösterir - yani, deserialization yerel saat dilimine dönüştürülmelidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-251">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="d774a-252">Yoksa, zaman <xref:System.DateTimeKind.Utc>.</span><span class="sxs-lookup"><span data-stu-id="d774a-252">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="d774a-253">Bu örnekteki gerçek sayı ("0500" ve işareti (+ veya -) yoksayılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-253">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="d774a-254">Serileştirme <xref:System.DateTime>ve <xref:System.DateTimeKind.Local> <xref:System.DateTimeKind.Unspecified> saatler ofset ile yazıldığında ve <xref:System.DateTimeKind.Utc> olmadan yazılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-254">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="d774a-255">ASP.NET AJAX istemcijavascript kodu otomatik olarak JavaScript `DateTime` örnekleri ne tür dizeleri dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="d774a-255">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="d774a-256">.NET'te türü <xref:System.DateTime> olmayan benzer bir forma sahip başka dizeleri varsa, bunlar da dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="d774a-256">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="d774a-257">Dönüştürme yalnızca "/" karakterleri kaçarsa (diğer bir şekilde JSON\\" /Date(700000+0500)\\/") gibi görünürse) gerçekleşir ve bu <xref:System.ServiceModel.WebHttpBinding>nedenle WCF'nin JSON kodlayıcısı (etkin) her zaman "/" karakterinden kaçar.</span><span class="sxs-lookup"><span data-stu-id="d774a-257">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="d774a-258">XML Içinde JSON Dizeleri</span><span class="sxs-lookup"><span data-stu-id="d774a-258">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="d774a-259">Xmlelement</span><span class="sxs-lookup"><span data-stu-id="d774a-259">XmlElement</span></span>

<span data-ttu-id="d774a-260"><xref:System.Xml.XmlElement>olduğu gibi seri hale getirilir, sarma yoktur.</span><span class="sxs-lookup"><span data-stu-id="d774a-260"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="d774a-261">Örneğin, abc/> içeren <xref:System.Xml.XmlElement> \<türdeki veri üyesi "x" aşağıdaki gibi temsil edilir:</span><span class="sxs-lookup"><span data-stu-id="d774a-261">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="d774a-262">XmlNode dizileri</span><span class="sxs-lookup"><span data-stu-id="d774a-262">Arrays of XmlNode</span></span>

<span data-ttu-id="d774a-263"><xref:System.Array>tür <xref:System.Xml.XmlNode> nesneleri türü için standart veri sözleşme ad alanında ArrayOfXmlNode adlı bir öğeye sarılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-263"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="d774a-264">"x" ad alanı "ns" öznitelik düğümü "değer" ve boş bir eleman düğümü "M" içeren bir dizi ise, gösterimi aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-264">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="d774a-265">XmlNode dizilerinin başındaki boş ad alanındaki öznitelikler (diğer öğelerden önce) desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="d774a-265">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="d774a-266">XElement ve DataSet dahil IXmlSerializable Türleri</span><span class="sxs-lookup"><span data-stu-id="d774a-266">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="d774a-267"><xref:System.Runtime.Serialization.ISerializable>türleri "içerik türleri", "DataSet türleri" ve "öğe türleri" olarak ikiye ayrılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-267"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="d774a-268">Bu tür tanımlar [için, Veri Sözleşmelerinde XML ve ADO.NET Türleri'ne](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-268">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](../../../../docs/framework/wcf/feature-details/xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="d774a-269">"İçerik" ve "DataSet" türleri, <xref:System.Array> önceki bölümde <xref:System.Xml.XmlNode> tartışılan nesnelere benzer seri hale getirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="d774a-269">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="d774a-270">Bunlar, adı ve ad alanı söz konusu türdeki veri sözleşme adı ve ad alanına karşılık gelen bir öğeye sarılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-270">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="d774a-271">"Öğe" türleri <xref:System.Xml.Linq.XElement> gibi serileştirilmiş, daha <xref:System.Xml.XmlElement> önce bu konuda tartışılan benzer.</span><span class="sxs-lookup"><span data-stu-id="d774a-271">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="d774a-272">Çok biçimlilik</span><span class="sxs-lookup"><span data-stu-id="d774a-272">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="d774a-273">Tür Bilgilerinin Korunması</span><span class="sxs-lookup"><span data-stu-id="d774a-273">Preserving Type Information</span></span>

<span data-ttu-id="d774a-274">Daha önce de belirtildiği gibi, polimorfizm JSON bazı sınırlamalar ile desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d774a-274">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="d774a-275">JavaScript zayıf yazılmış bir dildir ve tür kimliği normalde bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="d774a-275">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="d774a-276">Ancak, güçlü bir şekilde yazılmış bir sistem (.NET) ve zayıf yazılmış bir sistem (JavaScript) arasında iletişim kurmak için JSON kullanırken, tür kimliğini korumak yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="d774a-276">However, when using JSON to communicate between a strongly-typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="d774a-277">Örneğin, veri sözleşmesi adları "Kare" ve "Daire" olan türler, "Şekil" veri sözleşme adı olan bir türden türetilmiştir.</span><span class="sxs-lookup"><span data-stu-id="d774a-277">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="d774a-278">"Circle" .NET'ten JavaScript'e gönderilir ve daha sonra "Şekil" bekleyen bir .NET yöntemine döndürülürse, .NET tarafının söz konusu nesnenin başlangıçta bir "Daire" olduğunu bilmesi yararlıdır - aksi takdirde türemiş türe özgü herhangi bir bilgi (örneğin , "Circle" veri üyesi kaybolabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-278">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="d774a-279">Tür kimliğini korumak için, karmaşık türleri JSON'a seri hale getirmek için bir "tür ipucu" eklenebilir ve deserializer ipucunu tanır ve uygun şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="d774a-279">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="d774a-280">"Tür ipucu" "\_\_türü" anahtar adı ile bir JSON anahtar / değer çifti (iki underscores kelime "türü") takip eder.</span><span class="sxs-lookup"><span data-stu-id="d774a-280">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="d774a-281">Değer formu "DataContractName:DataContractNamespace" (ilk üst üste kadar bir şey adıdır) bir JSON dizesidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-281">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="d774a-282">Önceki örnek kullanılarak, "Circle" aşağıdaki gibi seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-282">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="d774a-283">Tür ipucu, XML `xsi:type` Şema Örneği standardı tarafından tanımlanan ve XML'i serihale/deserialize ederken kullanılan özniteliğe çok benzer.</span><span class="sxs-lookup"><span data-stu-id="d774a-283">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="d774a-284">İpucu ile\_\_olası çakışma nedeniyle "tür" adı verilen veri üyeleri yasaktır.</span><span class="sxs-lookup"><span data-stu-id="d774a-284">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="d774a-285">Tür İpuçlarının Boyutunu Küçültme</span><span class="sxs-lookup"><span data-stu-id="d774a-285">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="d774a-286">JSON iletilerinin boyutunu küçültmek için varsayılan veri sözleşme`http://schemas.datacontract.org/2004/07/`ad alanı öneki ( ) "#" karakteriyle değiştirilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-286">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="d774a-287">(Bu değişikliği geri döndürülebilir hale getirmek için bir kaçış kuralı kullanılır: ad alanı\\"#" veya " " karakterlerle\\başlarsa, bunlar aki " " " karakteriyle eklenir).</span><span class="sxs-lookup"><span data-stu-id="d774a-287">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="d774a-288">Bu nedenle, "Circle" .NET ad alanında "MyApp.Shapes" bir tür ise, `http://schemas.datacontract.org/2004/07/MyApp`varsayılan veri sözleşmesi namespace .</span><span class="sxs-lookup"><span data-stu-id="d774a-288">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="d774a-289">Şekiller ve JSON gösterimi aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-289">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="d774a-290">Hem kesilen (#MyApp.Şekiller) hem dehttp://schemas.datacontract.org/2004/07/MyApp.Shapes) tam (adlar deserialization üzerinde anlaşılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="d774a-290">Both the truncated (#MyApp.Shapes) and the full (http://schemas.datacontract.org/2004/07/MyApp.Shapes) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="d774a-291">JSON Nesnelerinde İpucu Konumu Yazın</span><span class="sxs-lookup"><span data-stu-id="d774a-291">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="d774a-292">Tür ipucunun önce JSON gösteriminde görünmesi gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="d774a-292">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="d774a-293">Bu, JSON işleminde anahtar/değer çiftleri sırasının önemli olduğu tek durumdur.</span><span class="sxs-lookup"><span data-stu-id="d774a-293">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="d774a-294">Örneğin, aşağıdaki tür ipucu belirtmek için geçerli bir yol değildir.</span><span class="sxs-lookup"><span data-stu-id="d774a-294">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="d774a-295">Hem <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> WCF ve ASP.NET AJAX istemci sayfaları tarafından kullanılan her zaman ilk tür ipucu yontun.</span><span class="sxs-lookup"><span data-stu-id="d774a-295">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="d774a-296">Tür İpuçları Yalnızca Karmaşık Türlere Uygulanır</span><span class="sxs-lookup"><span data-stu-id="d774a-296">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="d774a-297">Karmaşık olmayan türler için bir tür ipucu yontmak için bir yol yoktur.</span><span class="sxs-lookup"><span data-stu-id="d774a-297">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="d774a-298">Örneğin, bir işlemin <xref:System.Object> bir iade türü varsa ancak bir Daire döndürürse, JSON gösterimi daha önce gösterildiği gibi olabilir ve tür bilgileri korunur.</span><span class="sxs-lookup"><span data-stu-id="d774a-298">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="d774a-299">Ancak, Uri döndürülürse, JSON gösterimi bir dizedir ve Uri'yi temsil etmek için kullanılan dize kaybolur.</span><span class="sxs-lookup"><span data-stu-id="d774a-299">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="d774a-300">Bu yalnızca ilkel türler için değil, koleksiyonlar ve diziler için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="d774a-300">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="d774a-301">Tür İpuçları Ne Zaman Yayılır</span><span class="sxs-lookup"><span data-stu-id="d774a-301">When Are Type Hints Emitted</span></span>

<span data-ttu-id="d774a-302">Tür ipuçları ileti boyutunu önemli ölçüde artırabilir (bunu azaltmanın bir yolu, mümkünse daha kısa veri sözleşmesi ad alanları kullanmaktır).</span><span class="sxs-lookup"><span data-stu-id="d774a-302">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="d774a-303">Bu nedenle, tür ipuçlarının yayılıp yayılmayacağı aşağıdaki kuralları yönetir:</span><span class="sxs-lookup"><span data-stu-id="d774a-303">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="d774a-304">ASP.NET AJAX kullanırken, tür ipuçları her zaman mümkün olduğunda, hiçbir temel / türetilmiş atama olsa bile - örneğin, bir Daire bir Daire atanmış olsa bile yayılan.</span><span class="sxs-lookup"><span data-stu-id="d774a-304">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="d774a-305">(Bu, zayıf yazılan JSON ortamından şaşırtıcı bir bilgi kaybı olmadan güçlü bir şekilde yazılan .NET ortamına arama işlemini tam olarak etkinleştirmek için gereklidir.)</span><span class="sxs-lookup"><span data-stu-id="d774a-305">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly-typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="d774a-306">ASP.NET tümleştirmesi olmayan AJAX hizmetlerini kullanırken, tür ipuçları yalnızca bir temel/türetilmiş atama olduğunda yayılır - <xref:System.Object> yani Circle Şekil'e atandığında veya Circle'a atandığında değil, yayımlandığında.</span><span class="sxs-lookup"><span data-stu-id="d774a-306">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="d774a-307">Bu, bir JavaScript istemcisini doğru bir şekilde uygulamak için gereken minimum bilgileri sağlar, böylece performansı artırır, ancak yanlış tasarlanmış istemcilerde tür bilgi kaybına karşı koruma sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="d774a-307">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="d774a-308">İstemci de bu sorunla uğraşmaktan kaçınmak istiyorsanız, sunucuda temel/türetilmiş atamaları tamamen kaçının.</span><span class="sxs-lookup"><span data-stu-id="d774a-308">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="d774a-309"><xref:System.Runtime.Serialization.DataContractSerializer> Türü kullanırken, `alwaysEmitTypeInformation` oluşturucu parametresi varsayılan " (yalnızca`false`gerektiğinde tür ipuçları yontarak) ile, önceki iki mod arasında seçim yapmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="d774a-309">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="d774a-310">Yinelenen Veri Üye Adları</span><span class="sxs-lookup"><span data-stu-id="d774a-310">Duplicate Data Member Names</span></span>

<span data-ttu-id="d774a-311">Türetilen tür bilgileri, temel tür bilgileriyle birlikte aynı JSON nesnesinde bulunur ve herhangi bir sırada oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-311">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="d774a-312">Örneğin, `Shape` aşağıdaki gibi temsil edilebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-312">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="d774a-313">Oysa Circle aşağıdaki gibi temsil edilebilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-313">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="d774a-314">Temel `Shape` türde " "`radius`" adlı bir veri üyesi de içeriyorsa, bu hem serileştirmede (JSON nesnelerinin anahtar adlarını yineleyemediği `Shape.radius` için) hem de deserialization 'da çakışmaya yol açar (çünkü "yarıçap"ın başvurup başvurulmadığı veya ifade edilip edilmediği `Circle.radius`belirsizdir).</span><span class="sxs-lookup"><span data-stu-id="d774a-314">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="d774a-315">Bu nedenle, "özellik gizleme" kavramı (temelve türetilmiş sınıflara göre aynı adı taşıyan veri üyeleri) genellikle veri sözleşmesi sınıflarında önerilmez, aslında JSON durumunda yasaktır.</span><span class="sxs-lookup"><span data-stu-id="d774a-315">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="d774a-316">Polimorfizm ve IXmlSerializable Türleri</span><span class="sxs-lookup"><span data-stu-id="d774a-316">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="d774a-317"><xref:System.Xml.Serialization.IXmlSerializable>türleri, bilinen tür gereksinimleri, olağan veri sözleşmesi kurallarına göre karşılandığı sürece, her zamanki gibi birbirlerine polimorfik olarak atanabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-317"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="d774a-318">Ancak, sonuç <xref:System.Xml.Serialization.IXmlSerializable> olarak tür <xref:System.Object> bilgilerinin kaybı sonuçları yerine bir tür serileştirme bir JSON dizesi.</span><span class="sxs-lookup"><span data-stu-id="d774a-318">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="d774a-319">Polimorfizm ve Belirli Arayüz Türleri</span><span class="sxs-lookup"><span data-stu-id="d774a-319">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="d774a-320">Bir koleksiyon türünü veya (hariç) <xref:System.Xml.Serialization.IXmlSerializable> <xref:System.Xml.Serialization.IXmlSerializable> <xref:System.Object>olmayan bir koleksiyon türü beklenen bir tür uygulayan bir türü seri hale getirmek yasaktır.</span><span class="sxs-lookup"><span data-stu-id="d774a-320">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="d774a-321">Örneğin, özel bir `IMyInterface` arabirim `MyType` adlı ve <xref:System.Collections.Generic.IEnumerable%601> hem `int` `IMyInterface`tür ve .</span><span class="sxs-lookup"><span data-stu-id="d774a-321">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="d774a-322">İade türü olan `MyType` bir işlemden dönmek `IMyInterface`yasaktır.</span><span class="sxs-lookup"><span data-stu-id="d774a-322">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="d774a-323">Bunun nedeni, `MyType` JSON dizisi olarak serihale edilmesi ve bir tür ipucu gerektirmesi ve daha önce belirtildiği gibi dizili bir tür ipucunu yalnızca karmaşık türleri ile içeremeyeceğinizdir.</span><span class="sxs-lookup"><span data-stu-id="d774a-323">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="d774a-324">Bilinen Türleri ve Yapılandırma</span><span class="sxs-lookup"><span data-stu-id="d774a-324">Known Types and Configuration</span></span>

<span data-ttu-id="d774a-325">Kullanılan bilinen tip mekanizmaların <xref:System.Runtime.Serialization.DataContractSerializer> tümü de aynı şekilde <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>desteklenir.</span><span class="sxs-lookup"><span data-stu-id="d774a-325">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="d774a-326">Her iki serializers aynı yapılandırma öğesi okumak, [ \<dataContractSerializer](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) [ \<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md)>, bilinen türleri keşfetmek için bir yapılandırma dosyası üzerinden eklendi.</span><span class="sxs-lookup"><span data-stu-id="d774a-326">Both serializers read the same configuration element, [\<dataContractSerializer>](../../../../docs/framework/configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../../../docs/framework/configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="d774a-327">Nesneye Atanan Koleksiyonlar</span><span class="sxs-lookup"><span data-stu-id="d774a-327">Collections Assigned to Object</span></span>

<span data-ttu-id="d774a-328">Object'e atanan koleksiyonlar, sanki uygulayan <xref:System.Collections.Generic.IEnumerable%601>koleksiyonlarmış gibi seri hale getirilmiştir: karmaşık bir türse, her girişi olan bir JSON dizisi.</span><span class="sxs-lookup"><span data-stu-id="d774a-328">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="d774a-329">Örneğin, atanan <xref:System.Collections.Generic.List%601> bir `Shape` tür <xref:System.Object> aşağıdaki gibi görünür.</span><span class="sxs-lookup"><span data-stu-id="d774a-329">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="d774a-330">Tekrar deserialized <xref:System.Object>zaman:</span><span class="sxs-lookup"><span data-stu-id="d774a-330">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="d774a-331">`Shape`Bilinen Türler listesinde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d774a-331">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="d774a-332">Bilinen <xref:System.Collections.Generic.List%601> türlerde tür `Shape` olmasının hiçbir etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="d774a-332">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="d774a-333">Bu durumda serileştirme de `Shape` bilinen türleri eklemek zorunda olmadığını unutmayın - bu otomatik olarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-333">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="d774a-334">Koleksiyon örnekleri içeren <xref:System.Array> <xref:System.Object> `Shape` bir tür olarak deserialized.</span><span class="sxs-lookup"><span data-stu-id="d774a-334">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="d774a-335">Temel Koleksiyonlara Atanan Türemiş Koleksiyonlar</span><span class="sxs-lookup"><span data-stu-id="d774a-335">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="d774a-336">Türetilmiş bir koleksiyon bir temel koleksiyona atandığında, koleksiyon genellikle temel türün bir koleksiyonuymuş gibi seri hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-336">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="d774a-337">Ancak, türemiş koleksiyonun madde türü temel koleksiyonun madde türüne atanamıyorsa, bir özel durum atılır.</span><span class="sxs-lookup"><span data-stu-id="d774a-337">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="d774a-338">Tip İpuçları ve Sözlükler</span><span class="sxs-lookup"><span data-stu-id="d774a-338">Type Hints and Dictionaries</span></span>

<span data-ttu-id="d774a-339">Bir sözlük, <xref:System.Object>sözlükteki her Anahtar ve Değer girişine atandığında, atanmış <xref:System.Object> gibi değerlendirilir ve bir tür ipucu alır.</span><span class="sxs-lookup"><span data-stu-id="d774a-339">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="d774a-340">Sözlük türlerini seri hale alırken, "Anahtar" ve "Değer" üyelerini içeren `alwaysEmitTypeInformation` JSON nesnesi ayardan etkilenmez ve yalnızca önceki koleksiyon kuralları gerektirdiğinde bir tür ipucu içerir.</span><span class="sxs-lookup"><span data-stu-id="d774a-340">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="d774a-341">Geçerli JSON Anahtar Adları</span><span class="sxs-lookup"><span data-stu-id="d774a-341">Valid JSON Key Names</span></span>

<span data-ttu-id="d774a-342">Serileştirici XML, geçerli XML adları olmayan anahtar adlarını kodlar.</span><span class="sxs-lookup"><span data-stu-id="d774a-342">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="d774a-343">Örneğin, "123" adında bir veri üyesinin kodlanmış adı "\_x0031\_\_x0032\_\_x0033\_" gibi kodlanmış bir adı vardır, çünkü "123" geçersiz bir XML öğesi adıdır (basamakla başlar).</span><span class="sxs-lookup"><span data-stu-id="d774a-343">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="d774a-344">Benzer bir durum, XML adlarında geçerli olmayan bazı uluslararası karakter kümeleri ile ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="d774a-344">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="d774a-345">XML'in JSON işleme üzerindeki bu etkisinin açıklaması için [JSON ve XML arasındaki haritalama](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md)bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="d774a-345">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](../../../../docs/framework/wcf/feature-details/mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="d774a-346">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="d774a-346">See also</span></span>

- [<span data-ttu-id="d774a-347">JSON ve Diğer Veri Aktarma Biçimleri için Destek</span><span class="sxs-lookup"><span data-stu-id="d774a-347">Support for JSON and Other Data Transfer Formats</span></span>](../../../../docs/framework/wcf/feature-details/support-for-json-and-other-data-transfer-formats.md)
