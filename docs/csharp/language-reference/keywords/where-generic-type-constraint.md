---
description: WHERE (genel tür kısıtlaması)-C# başvurusu
title: WHERE (genel tür kısıtlaması)-C# başvurusu
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
- classconstraint_CSharpKeyword
- structconstraint_CSharpKeyword
- enumconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 83fb5b562d9e1e4caaef179ca2911adb60fc01fa
ms.sourcegitcommit: c7f0beaa2bd66ebca86362ca17d673f7e8256ca6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/23/2021
ms.locfileid: "104872632"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="f1753-103">where (genel tür kısıtlaması) (C# Başvurusu)</span><span class="sxs-lookup"><span data-stu-id="f1753-103">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="f1753-104">`where`Genel tanımda yer alan yan tümce, genel bir tür, metot, temsilci veya yerel işlevde tür parametreleri için bağımsız değişken olarak kullanılan türlerde kısıtlamalar belirtir.</span><span class="sxs-lookup"><span data-stu-id="f1753-104">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="f1753-105">Kısıtlamalar, arabirimler, temel sınıflar veya bir genel türün bir başvuru, değer veya yönetilmeyen tür olmasını gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="f1753-105">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="f1753-106">Tür bağımsız değişkeninin sahip olması gereken özellikleri bildirir.</span><span class="sxs-lookup"><span data-stu-id="f1753-106">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="f1753-107">Örneğin, `AGenericClass` tür parametresi arabirimini uygulayan genel bir sınıf bildirebilirsiniz `T` <xref:System.IComparable%601> :</span><span class="sxs-lookup"><span data-stu-id="f1753-107">For example, you can declare a generic class, `AGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="f1753-108">Bir sorgu ifadesindeki WHERE yan tümcesi hakkında daha fazla bilgi için bkz. [WHERE yan tümcesi](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="f1753-108">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="f1753-109">`where`Yan tümce bir temel sınıf kısıtlaması de içerebilir.</span><span class="sxs-lookup"><span data-stu-id="f1753-109">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="f1753-110">Temel sınıf kısıtlaması, bu genel türün tür bağımsız değişkeni olarak kullanılacak bir türün, temel sınıf olarak belirtilen sınıfa sahip olduğunu veya temel sınıf olduğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="f1753-110">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="f1753-111">Temel sınıf kısıtlaması kullanılırsa, bu tür parametresindeki diğer kısıtlamaların önüne gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="f1753-111">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="f1753-112">Bir temel sınıf kısıtlaması olarak bazı türlere izin verilmez: <xref:System.Object> , <xref:System.Array> ve <xref:System.ValueType> .</span><span class="sxs-lookup"><span data-stu-id="f1753-112">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="f1753-113">C# 7,3,, ve ' den önce <xref:System.Enum> <xref:System.Delegate> <xref:System.MulticastDelegate> temel sınıf kısıtlamaları olarak da izin verilmedi.</span><span class="sxs-lookup"><span data-stu-id="f1753-113">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="f1753-114">Aşağıdaki örnek, artık temel sınıf olarak belirtime türleri göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="f1753-114">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="f1753-115">C# 8,0 ve sonraki sürümlerde null yapılabilir bir bağlamda, temel sınıf türünün null değer alabilme değeri zorlanır.</span><span class="sxs-lookup"><span data-stu-id="f1753-115">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="f1753-116">Temel sınıf null atanamaz ise (örneğin `Base` ), tür bağımsız değişkeni null atanamaz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f1753-116">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="f1753-117">Temel sınıf null yapılabilir ise (örneğin `Base?` ), tür bağımsız değişkeni null yapılabilir veya null atanamaz bir başvuru türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="f1753-117">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="f1753-118">Temel sınıf null olamayan bir başvuru türünde ise derleyici bir uyarı verir.</span><span class="sxs-lookup"><span data-stu-id="f1753-118">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="f1753-119">`where`Yan tümce türün bir `class` veya bir olduğunu belirtebilir `struct` .</span><span class="sxs-lookup"><span data-stu-id="f1753-119">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="f1753-120">`struct`Kısıtlama, öğesinin temel sınıf kısıtlamasını belirtme gereksinimini ortadan kaldırır `System.ValueType` .</span><span class="sxs-lookup"><span data-stu-id="f1753-120">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="f1753-121">`System.ValueType`Tür, temel sınıf kısıtlaması olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="f1753-121">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="f1753-122">Aşağıdaki örnek, `class` ve `struct` kısıtlamalarını göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="f1753-122">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="f1753-123">C# 8,0 ve sonraki sürümlerde null yapılabilir bir bağlamda kısıtlama, `class` bir türün null yapılamayan bir başvuru türü olmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f1753-123">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="f1753-124">Null yapılabilir başvuru türlerine izin vermek için, `class?` hem null yapılabilir hem de null olamayan başvuru türlerine izin veren kısıtlamayı kullanın.</span><span class="sxs-lookup"><span data-stu-id="f1753-124">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="f1753-125">`where`Yan tümce `notnull` kısıtlaması içerebilir.</span><span class="sxs-lookup"><span data-stu-id="f1753-125">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="f1753-126">`notnull`Kısıtlama, tür parametresini null yapılamayan türler ile sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f1753-126">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="f1753-127">Bu tür bir [değer türü](../builtin-types/value-types.md) veya null yapılamayan bir başvuru türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="f1753-127">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="f1753-128">`notnull`Kısıtlama, bir [ `nullable enable` bağlamda](../../nullable-references.md#nullable-contexts)derlenen kod için C# 8,0 ' den başlayarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f1753-128">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="f1753-129">Diğer kısıtlamaların aksine, bir tür bağımsız değişkeni kısıtlamayı ihlal ederse `notnull` , derleyici hata yerine bir uyarı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f1753-129">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="f1753-130">Uyarılar yalnızca bir `nullable enable` bağlamda oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f1753-130">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f1753-131">Kısıtlamayı içeren genel bildirimler, `notnull` null yapılabilir bir zorunluluvou bağlamında kullanılabilir, ancak derleyici kısıtlamayı zorlamaz.</span><span class="sxs-lookup"><span data-stu-id="f1753-131">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="f1753-132">`where`Yan tümce de bir kısıtlama içerebilir `unmanaged` .</span><span class="sxs-lookup"><span data-stu-id="f1753-132">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="f1753-133">`unmanaged`Kısıtlama, tür parametresini [yönetilmeyen türler](../builtin-types/unmanaged-types.md)olarak bilinen türlerle sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f1753-133">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="f1753-134">`unmanaged`Kısıtlama, C# dilinde alt düzey birlikte çalışma kodu yazmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="f1753-134">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="f1753-135">Bu kısıtlama, tüm yönetilmeyen türler arasında yeniden kullanılabilir yordamlar sunar.</span><span class="sxs-lookup"><span data-stu-id="f1753-135">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="f1753-136">`unmanaged`Kısıtlama, `class` veya kısıtlaması ile birleştirilemez `struct` .</span><span class="sxs-lookup"><span data-stu-id="f1753-136">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="f1753-137">`unmanaged`Kısıtlama, türün bir olması için şunu uygular `struct` :</span><span class="sxs-lookup"><span data-stu-id="f1753-137">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="f1753-138">`where`Yan tümce bir Oluşturucu kısıtlaması de içerebilir `new()` .</span><span class="sxs-lookup"><span data-stu-id="f1753-138">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="f1753-139">Bu kısıtlama işleci kullanarak bir tür parametresinin örneğini oluşturmayı mümkün kılar `new` .</span><span class="sxs-lookup"><span data-stu-id="f1753-139">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="f1753-140">[New () kısıtlaması](new-constraint.md) , derleyicinin sağlanan herhangi bir tür bağımsız değişkeninin erişilebilir parametresiz bir oluşturucuya sahip olması gerektiğini bilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="f1753-140">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="f1753-141">Örnek:</span><span class="sxs-lookup"><span data-stu-id="f1753-141">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="f1753-142">`new()`Kısıtlama yan tümcesinde en son görünür `where` .</span><span class="sxs-lookup"><span data-stu-id="f1753-142">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="f1753-143">`new()`Kısıtlama `struct` veya `unmanaged` kısıtlamalarıyla birleştirilemez.</span><span class="sxs-lookup"><span data-stu-id="f1753-143">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="f1753-144">Bu kısıtlamaların karşılankarşılayan tüm türlerin erişilebilir bir parametresiz oluşturucusu olması gerekir ve `new()` kısıtlama gereksiz hale getirir.</span><span class="sxs-lookup"><span data-stu-id="f1753-144">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="f1753-145">Birden çok tür `where` parametresiyle, her tür parametresi için bir yan tümce kullanın, örneğin:</span><span class="sxs-lookup"><span data-stu-id="f1753-145">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="f1753-146">Ayrıca, aşağıdaki örnekte gösterildiği gibi genel yöntemlerin tür parametrelerine kısıtlamalar ekleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f1753-146">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="f1753-147">Temsilcilerle ilgili tür parametresi kısıtlamalarını betimleyen sözdiziminin, metodların türüyle aynı olduğunu unutmayın:</span><span class="sxs-lookup"><span data-stu-id="f1753-147">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="f1753-148">Genel Temsilciler hakkında daha fazla bilgi için bkz. [Genel Temsilciler](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="f1753-148">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="f1753-149">Kısıtlamaların sözdizimi ve kullanımı hakkında ayrıntılı bilgi için bkz. [tür parametrelerindeki kısıtlamalar](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="f1753-149">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="f1753-150">C# dili belirtimi</span><span class="sxs-lookup"><span data-stu-id="f1753-150">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="f1753-151">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="f1753-151">See also</span></span>

- [<span data-ttu-id="f1753-152">C# başvurusu</span><span class="sxs-lookup"><span data-stu-id="f1753-152">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="f1753-153">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="f1753-153">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="f1753-154">Genel Türlere Giriş</span><span class="sxs-lookup"><span data-stu-id="f1753-154">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="f1753-155">Yeni kısıtlama</span><span class="sxs-lookup"><span data-stu-id="f1753-155">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="f1753-156">Tür Parametrelerindeki Kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="f1753-156">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
