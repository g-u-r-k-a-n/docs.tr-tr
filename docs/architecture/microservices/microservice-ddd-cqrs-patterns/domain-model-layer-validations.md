---
title: Etki alanı model katmanında doğrulamaları tasarlama
description: .NET Microservices Mimari Containerized .NET Uygulamaları için | Etki alanı modeli doğrulamalarının temel kavramlarını anlayın.
ms.date: 10/08/2018
ms.openlocfilehash: 98ccc5df84c9f6f402ecbee83b077c806d6a76fc
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "75899675"
---
# <a name="design-validations-in-the-domain-model-layer"></a><span data-ttu-id="2dc9d-103">Etki alanı modeli katmanında tasarım doğrulamaları</span><span class="sxs-lookup"><span data-stu-id="2dc9d-103">Design validations in the domain model layer</span></span>

<span data-ttu-id="2dc9d-104">DDD'de doğrulama kuralları değişmez olarak düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-104">In DDD, validation rules can be thought as invariants.</span></span> <span data-ttu-id="2dc9d-105">Bir agreganın temel sorumluluğu, bu toplamdaki tüm varlıklar için durum değişiklikleri arasında değişmezlikleri uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-105">The main responsibility of an aggregate is to enforce invariants across state changes for all the entities within that aggregate.</span></span>

<span data-ttu-id="2dc9d-106">Etki alanı varlıkları her zaman geçerli varlıklar olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-106">Domain entities should always be valid entities.</span></span> <span data-ttu-id="2dc9d-107">Her zaman doğru olması gereken bir nesne için belirli sayıda değişmez vardır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-107">There are a certain number of invariants for an object that should always be true.</span></span> <span data-ttu-id="2dc9d-108">Örneğin, bir sipariş öğesi nesnesi her zaman pozitif tamsayı olması gereken bir miktar, artı bir makale adı ve fiyat olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-108">For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price.</span></span> <span data-ttu-id="2dc9d-109">Bu nedenle, değişmezlerin uygulanması etki alanı varlıklarının (özellikle toplam kök) sorumluluğundadır ve bir varlık nesnesi geçerli olmadan var olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-109">Therefore, invariants enforcement is the responsibility of the domain entities (especially of the aggregate root) and an entity object should not be able to exist without being valid.</span></span> <span data-ttu-id="2dc9d-110">Değişmez kurallar yalnızca sözleşme olarak ifade edilir ve ihlal edildiklerinde özel durumlar veya bildirimler yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-110">Invariant rules are simply expressed as contracts, and exceptions or notifications are raised when they are violated.</span></span>

<span data-ttu-id="2dc9d-111">Bunun arkasındaki mantık, nesnelerin asla içinde olmaması gereken bir durumda olması nedeniyle birçok hatanın oluşmasıdır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-111">The reasoning behind this is that many bugs occur because objects are in a state they should never have been in.</span></span> <span data-ttu-id="2dc9d-112">Aşağıdaki greg Young bir [online tartışma](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/)iyi bir açıklama:</span><span class="sxs-lookup"><span data-stu-id="2dc9d-112">The following is a good explanation from Greg Young in an [online discussion](https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/):</span></span>

<span data-ttu-id="2dc9d-113">Şimdi bir UserProfile alır SendUserCreationEmailService var önerelim ... Adın null olmadığını bu hizmette nasıl rasyonalize edebiliriz?</span><span class="sxs-lookup"><span data-stu-id="2dc9d-113">Let's propose we now have a SendUserCreationEmailService that takes a UserProfile ... how can we rationalize in that service that Name is not null?</span></span> <span data-ttu-id="2dc9d-114">Tekrar kontrol ediyor muyum?</span><span class="sxs-lookup"><span data-stu-id="2dc9d-114">Do we check it again?</span></span> <span data-ttu-id="2dc9d-115">Ya da daha büyük olasılıkla ... sadece kontrol etmek için rahatsız etmeyin ve "en iyi" için umut-birinin size göndermeden önce doğrulamak için rahatsız umuyoruz.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-115">Or more likely ... you just don't bother to check and "hope for the best"—you hope that someone bothered to validate it before sending it to you.</span></span> <span data-ttu-id="2dc9d-116">Tabii ki, TDD kullanarak biz yazmalı gereken ilk testlerden biri eğer bir hata yükseltmek gerektiğini bir null adı ile bir müşteri göndermek olduğunu.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-116">Of course, using TDD one of the first tests we should be writing is that if I send a customer with a null name that it should raise an error.</span></span> <span data-ttu-id="2dc9d-117">Ama bir kez tekrar tekrar bu tür testler yazmaya başlamak biz fark ... "Eğer ismin geçersiz olmasına izin vermeseydik, bu testlerin hepsine sahip olamazdık"</span><span class="sxs-lookup"><span data-stu-id="2dc9d-117">But once we start writing these kinds of tests over and over again we realize ... "wait if we never allowed name to become null we wouldn't have all of these tests"</span></span>

## <a name="implement-validations-in-the-domain-model-layer"></a><span data-ttu-id="2dc9d-118">Etki alanı modeli katmanında doğrulamaları uygulama</span><span class="sxs-lookup"><span data-stu-id="2dc9d-118">Implement validations in the domain model layer</span></span>

<span data-ttu-id="2dc9d-119">Doğrulamalar genellikle etki alanı varlık oluşturucuları veya varlığı güncelleştirebilecek yöntemlerde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-119">Validations are usually implemented in domain entity constructors or in methods that can update the entity.</span></span> <span data-ttu-id="2dc9d-120">Doğrulama başarısız olursa, verileri doğrulama ve özel durumları artırma gibi doğrulamaları uygulamanın birden çok yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-120">There are multiple ways to implement validations, such as verifying data and raising exceptions if the validation fails.</span></span> <span data-ttu-id="2dc9d-121">Ayrıca, doğrulamalar için Belirtim deseni ve bildirim deseni, oluştukça her doğrulama için bir özel durum döndürmek yerine bir hata koleksiyonunu döndürmek gibi daha gelişmiş desenler de vardır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-121">There are also more advanced patterns such as using the Specification pattern for validations, and the Notification pattern to return a collection of errors instead of returning an exception for each validation as it occurs.</span></span>

### <a name="validate-conditions-and-throw-exceptions"></a><span data-ttu-id="2dc9d-122">Koşulları doğrulayın ve özel durumlar atın</span><span class="sxs-lookup"><span data-stu-id="2dc9d-122">Validate conditions and throw exceptions</span></span>

<span data-ttu-id="2dc9d-123">Aşağıdaki kod örneği, bir özel durum oluşturarak bir etki alanı varlığında doğrulamaya en basit yaklaşımı gösterir.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-123">The following code example shows the simplest approach to validation in a domain entity by raising an exception.</span></span> <span data-ttu-id="2dc9d-124">Bu bölümün sonundaki başvurular tablosunda, daha önce tartıştığımız desenlere dayalı olarak daha gelişmiş uygulamalara bağlantılar görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-124">In the references table at the end of this section you can see links to more advanced implementations based on the patterns we have discussed previously.</span></span>

```csharp
public void SetAddress(Address address)
{
    _shippingAddress = address?? throw new ArgumentNullException(nameof(address));
}
```

<span data-ttu-id="2dc9d-125">Daha iyi bir örnek, iç durumunun değişmediğinden veya bir yöntemiçin tüm mutasyonların meydana geldiğini sağlama gereğini ortaya koymaktadır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-125">A better example would demonstrate the need to ensure that either the internal state did not change, or that all the mutations for a method occurred.</span></span> <span data-ttu-id="2dc9d-126">Örneğin, aşağıdaki uygulama nesneyi geçersiz bir durumda bırakır:</span><span class="sxs-lookup"><span data-stu-id="2dc9d-126">For example, the following implementation would leave the object in an invalid state:</span></span>

```csharp
public void SetAddress(string line1, string line2,
    string city, string state, int zip)
{
    _shippingAddress.line1 = line1 ?? throw new ...
    _shippingAddress.line2 = line2;
    _shippingAddress.city = city ?? throw new ...
    _shippingAddress.state = (IsValid(state) ? state : throw new …);
}
```

<span data-ttu-id="2dc9d-127">Devletin değeri geçersizse, ilk adres satırı ve şehir zaten değiştirildi.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-127">If the value of the state is invalid, the first address line and the city have already been changed.</span></span> <span data-ttu-id="2dc9d-128">Bu adresi geçersiz kılabilecek.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-128">That might make the address invalid.</span></span>

<span data-ttu-id="2dc9d-129">Benzer bir yaklaşım varlığın oluşturucusunda da kullanılabilir ve oluşturulduktan sonra varlığın geçerli olduğundan emin olmak için bir özel durum oluşturur.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-129">A similar approach can be used in the entity’s constructor, raising an exception to make sure that the entity is valid once it is created.</span></span>

### <a name="use-validation-attributes-in-the-model-based-on-data-annotations"></a><span data-ttu-id="2dc9d-130">Veri ek açıklamalarını temel alan modelde doğrulama öznitelikleri kullanma</span><span class="sxs-lookup"><span data-stu-id="2dc9d-130">Use validation attributes in the model based on data annotations</span></span>

<span data-ttu-id="2dc9d-131">Gerekli veya MaxLength öznitelikleri gibi veri ek açıklamaları, [Tablo eşleme](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping) bölümünde ayrıntılı olarak açıklandığı gibi EF Core veritabanı alanı özelliklerini yapılandırmak için kullanılabilir, <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> ancak artık EF [Core'da varlık doğrulaması için çalışmaz](https://github.com/dotnet/efcore/issues/3680) (yöntem de yok), .NET Framework'deki EF 4.x'ten beri yaptıkları gibi.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-131">Data annotations, like the Required or MaxLength attributes, can be used to configure EF Core database field properties, as explained in detail in the [Table mapping](infrastructure-persistence-layer-implemenation-entity-framework-core.md#table-mapping) section, but [they no longer work for entity validation in EF Core](https://github.com/dotnet/efcore/issues/3680) (neither does the <xref:System.ComponentModel.DataAnnotations.IValidatableObject.Validate%2A?displayProperty=nameWithType> method), as they have done since EF 4.x in .NET Framework.</span></span>

<span data-ttu-id="2dc9d-132">Veri ek açıklamaları <xref:System.ComponentModel.DataAnnotations.IValidatableObject> ve arabirim hala model bağlama sırasında model doğrulama için kullanılabilir, her zamanki gibi denetleyicinin eylemleri çağırma önce, ama bu model bir ViewModel veya DTO olması gerekiyordu ve bir MVC veya API endişe değil bir etki alanı modeli endişe.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-132">Data annotations and the <xref:System.ComponentModel.DataAnnotations.IValidatableObject> interface can still be used for model validation during model binding, prior to the controller’s actions invocation as usual, but that model is meant to be a ViewModel or DTO and that’s an MVC or API concern not a domain model concern.</span></span>

<span data-ttu-id="2dc9d-133">Kavramsal farkı net hale getirdikten sonra, eylemleriniz `IValidatableObject` önerilmeyen bir varlık sınıfı nesnesi parametresi alıyorsa, veri ek açıklamalarını ve varlık sınıfında doğrulama için kullanmaya devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-133">Having made the conceptual difference clear, you can still use data annotations and `IValidatableObject` in the entity class for validation, if your actions receive an entity class object parameter, which is not recommended.</span></span> <span data-ttu-id="2dc9d-134">Bu durumda, doğrulama modeli bağlama üzerine, hemen eylem çağıran önce oluşur ve sonucu kontrol etmek için denetleyicinin ModelState.IsValid özelliğini kontrol edebilirsiniz, ama sonra tekrar, denetleyici olur, varlık nesnesi devam etmeden önce değil DbContext, EF 4.x'ten beri yaptığı gibi.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-134">In that case, validation will occur upon model binding, just before invoking the action and you can check the controller’s ModelState.IsValid property to check the result, but then again, it happens in the controller, not before persisting the entity object in the DbContext, as it had done since EF 4.x.</span></span>

<span data-ttu-id="2dc9d-135">DbContext'ın SaveChanges yöntemini geçersiz kılarak, `IValidatableObject.Validate` veri ek açıklamalarını ve yöntemi kullanarak varlık sınıfında özel doğrulama yı yine de uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-135">You can still implement custom validation in the entity class using data annotations and the `IValidatableObject.Validate` method, by overriding the DbContext’s SaveChanges method.</span></span>

<span data-ttu-id="2dc9d-136">`IValidatableObject` [GitHub'daki bu yorumda](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539)varlıkları doğrulamak için örnek bir uygulama görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-136">You can see a sample implementation for validating `IValidatableObject` entities in [this comment on GitHub](https://github.com/dotnet/efcore/issues/3680#issuecomment-155502539).</span></span> <span data-ttu-id="2dc9d-137">Bu örnek öznitelik tabanlı doğrulamalar yapmaz, ancak aynı geçersiz kılma yansıması kullanarak uygulamak kolay olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-137">That sample doesn't do attribute-based validations, but they should be easy to implement using reflection in the same override.</span></span>

<span data-ttu-id="2dc9d-138">Ancak, DDD bakış açısından, etki alanı modeli en iyi varlık davranış yöntemleri özel durumlar kullanımı ile yalın tutulur veya doğrulama kuralları zorlamak için Belirtim ve Bildirim desenleri uygulanarak.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-138">However, from a DDD point of view, the domain model is best kept lean with the use of exceptions in your entity’s behavior methods, or by implementing the Specification and Notification patterns to enforce validation rules.</span></span>

<span data-ttu-id="2dc9d-139">Kullanıcı Arabirimi katmanında model doğrulamasına izin vermek için girişi kabul edecek ViewModel sınıflarında (etki alanı varlıkları yerine) uygulama katmanında veri ek açıklamaları kullanmak mantıklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-139">It can make sense to use data annotations at the application layer in ViewModel classes (instead of domain entities) that will accept input, to allow for model validation within the UI layer.</span></span> <span data-ttu-id="2dc9d-140">Ancak, bu etki alanı modeli içinde doğrulama hariç yapılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-140">However, this should not be done at the exclusion of validation within the domain model.</span></span>

### <a name="validate-entities-by-implementing-the-specification-pattern-and-the-notification-pattern"></a><span data-ttu-id="2dc9d-141">Belirtim deseni ve Bildirim deseni uygulayarak varlıkları doğrulayın</span><span class="sxs-lookup"><span data-stu-id="2dc9d-141">Validate entities by implementing the Specification pattern and the Notification pattern</span></span>

<span data-ttu-id="2dc9d-142">Son olarak, etki alanı modelinde doğrulamaları uygulamak için daha ayrıntılı bir yaklaşım, daha sonra listelenen ek kaynakların bazılarında açıklandığı gibi, Bildirim deseni ile birlikte Belirtim deseni uygulayarak olur.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-142">Finally, a more elaborate approach to implementing validations in the domain model is by implementing the Specification pattern in conjunction with the Notification pattern, as explained in some of the additional resources listed later.</span></span>

<span data-ttu-id="2dc9d-143">Bu desenlerden yalnızca birini de kullanabileceğinizi belirtmekte yarar vardır(örneğin, denetim deyimleriyle el ile doğrulama, ancak doğrulama hatalarının listesini yığını ve döndürebilir için Bildirim deseni kullanılır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-143">It is worth mentioning that you can also use just one of those patterns—for example, validating manually with control statements, but using the Notification pattern to stack and return a list of validation errors.</span></span>

### <a name="use-deferred-validation-in-the-domain"></a><span data-ttu-id="2dc9d-144">Etki alanında ertelenmiş doğrulama kullanma</span><span class="sxs-lookup"><span data-stu-id="2dc9d-144">Use deferred validation in the domain</span></span>

<span data-ttu-id="2dc9d-145">Etki alanında ertelenmiş doğrulamaları ele almak için çeşitli yaklaşımlar vardır.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-145">There are various approaches to deal with deferred validations in the domain.</span></span> <span data-ttu-id="2dc9d-146">[Kitabında Etki Alanı Odaklı Tasarım Uygulama](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon doğrulama bölümünde bu tartışıyor.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-146">In his book [Implementing Domain-Driven Design](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577), Vaughn Vernon discusses these in the section on validation.</span></span>

### <a name="two-step-validation"></a><span data-ttu-id="2dc9d-147">İki adımlı doğrulama</span><span class="sxs-lookup"><span data-stu-id="2dc9d-147">Two-step validation</span></span>

<span data-ttu-id="2dc9d-148">Ayrıca iki adımlı doğrulama düşünün.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-148">Also consider two-step validation.</span></span> <span data-ttu-id="2dc9d-149">Komutveri aktarım nesnelerinde (DTO'lar) alan düzeyinde doğrulama yı ve varlıklarınız içinde etki alanı düzeyinde doğrulamayı kullanın.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-149">Use field-level validation on your command Data Transfer Objects (DTOs) and domain-level validation inside your entities.</span></span> <span data-ttu-id="2dc9d-150">Doğrulama hatalarıyla başa çıkmanın daha kolay olabilmesi için bunu özel durumlar yerine bir sonuç nesnesi döndürerek yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-150">You can do this by returning a result object instead of exceptions in order to make it easier to deal with the validation errors.</span></span>

<span data-ttu-id="2dc9d-151">Örneğin, veri ek açıklamalarıyla alan doğrulaması kullanarak doğrulama tanımını yinelemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-151">Using field validation with data annotations, for example, you do not duplicate the validation definition.</span></span> <span data-ttu-id="2dc9d-152">Ancak yürütme, DT'ler (örneğin komutlar ve Görünüm Modelleri) durumunda hem sunucu tarafı hem de istemci tarafı olabilir.</span><span class="sxs-lookup"><span data-stu-id="2dc9d-152">The execution, though, can be both server-side and client-side in the case of DTOs (commands and ViewModels, for instance).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="2dc9d-153">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="2dc9d-153">Additional resources</span></span>

- <span data-ttu-id="2dc9d-154">**Rachel Appel. Core MVC'de model doğrulamaya giriş ASP.NET** </span><span class="sxs-lookup"><span data-stu-id="2dc9d-154">**Rachel Appel. Introduction to model validation in ASP.NET Core MVC** </span></span>\
  <https://docs.microsoft.com/aspnet/core/mvc/models/validation>

- <span data-ttu-id="2dc9d-155">**Rick Anderson' ı. Doğrulama ekleme** </span><span class="sxs-lookup"><span data-stu-id="2dc9d-155">**Rick Anderson. Adding validation** </span></span>\
  <https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation>

- <span data-ttu-id="2dc9d-156">**Martin Fowler' ı. Doğrulamalarda Bildirimle Özel Durumlar Atma nın Değiştirilmesi** </span><span class="sxs-lookup"><span data-stu-id="2dc9d-156">**Martin Fowler. Replacing Throwing Exceptions with Notification in Validations** </span></span>\
  <https://martinfowler.com/articles/replaceThrowWithNotification.html>

- <span data-ttu-id="2dc9d-157">**Şartname ve Bildirim Desenleri** </span><span class="sxs-lookup"><span data-stu-id="2dc9d-157">**Specification and Notification Patterns** </span></span>\
  <https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns>

- <span data-ttu-id="2dc9d-158">**Lev Gorodinski. Etki Alanı Odaklı Tasarımda Doğrulama (DDD)** </span><span class="sxs-lookup"><span data-stu-id="2dc9d-158">**Lev Gorodinski. Validation in Domain-Driven Design (DDD)** </span></span>\
  <http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/>

- <span data-ttu-id="2dc9d-159">**Colin Jack' i. Etki Alanı Modeli Doğrulama** </span><span class="sxs-lookup"><span data-stu-id="2dc9d-159">**Colin Jack. Domain Model Validation** </span></span>\
  <https://colinjack.blogspot.com/2008/03/domain-model-validation.html>

- <span data-ttu-id="2dc9d-160">**Jimmy Bogard' ı. DDD dünyasında doğrulama** </span><span class="sxs-lookup"><span data-stu-id="2dc9d-160">**Jimmy Bogard. Validation in a DDD world** </span></span>\
  <https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/>

> [!div class="step-by-step"]
> <span data-ttu-id="2dc9d-161">[Önceki](enumeration-classes-over-enum-types.md)
> [Sonraki](client-side-validation.md)</span><span class="sxs-lookup"><span data-stu-id="2dc9d-161">[Previous](enumeration-classes-over-enum-types.md)
[Next](client-side-validation.md)</span></span>
