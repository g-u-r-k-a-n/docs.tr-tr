---
title: CLR Profil Oluşturucular ve Microsoft Store Uygulamaları
ms.date: 03/30/2017
dev_langs:
- csharp
applies_to:
- Windows 10
- Windows 8
helpviewer_keywords:
- profiling API
- profiling API [.NET Framework]
- profiling managed code
- profiling managed code [Windows Store Apps]
ms.assetid: 1c8eb2e7-f20a-42f9-a795-71503486a0f5
ms.openlocfilehash: da5942f9a2138a536d158f75a6977d20bf31b41c
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73140391"
---
# <a name="clr-profilers-and-windows-store-apps"></a><span data-ttu-id="1f5e9-102">CLR Profil Oluşturucular ve Microsoft Store Uygulamaları</span><span class="sxs-lookup"><span data-stu-id="1f5e9-102">CLR Profilers and Windows Store Apps</span></span>

<span data-ttu-id="1f5e9-103">Bu konuda, bir Windows Mağazası uygulamasında çalışan yönetilen kodu çözümleyen tanılama araçlarını yazarken göz önünde bulundurmak için gerekenler açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-103">This topic discusses what you need to think about when writing diagnostic tools that analyze managed code running inside a Windows Store app.</span></span> <span data-ttu-id="1f5e9-104">Ayrıca, Windows Mağazası uygulamalarına karşı çalıştırdığınızda çalışmaya devam edebilmek için mevcut geliştirme araçlarınızı değiştirme yönergeleri de sağlar.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-104">It also provides guidelines to modify your existing development tools so they continue to work when you run them against Windows Store apps.</span></span> <span data-ttu-id="1f5e9-105">Bu bilgileri anlamak için, ortak dil çalışma zamanı profili oluşturma API 'sine alışkın olmanız en iyisidir, bu API 'yi Windows masaüstü uygulamalarında doğru şekilde çalışan bir Tanılama aracında zaten kullanmışsanız ve artık aracı değiştirme ile ilgileniyor olabilirsiniz Windows Mağazası uygulamalarına karşı doğru şekilde çalıştırmak için.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-105">To understand this information, it’s best if you're  familiar with the Common Language Runtime Profiling API, you’ve already used this API in a diagnostic tool that runs correctly against Windows desktop applications, and you’re now interested in modifying the tool to run correctly against Windows Store apps.</span></span>

## <a name="introduction"></a><span data-ttu-id="1f5e9-106">Giriş</span><span class="sxs-lookup"><span data-stu-id="1f5e9-106">Introduction</span></span>

<span data-ttu-id="1f5e9-107">Bunu, giriş paragrafından daha fazla yaptıysanız, CLR profil oluşturma API 'sini öğreniyorsunuz demektir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-107">If you made it past the introductory paragraph, then you’re familiar with the CLR Profiling API.</span></span> <span data-ttu-id="1f5e9-108">Yönetilen masaüstü uygulamalarında iyi bir şekilde çalışacak bir tanılama aracı zaten yazmış oldunuz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-108">You’ve already written a diagnostic tool that works well against managed desktop applications.</span></span> <span data-ttu-id="1f5e9-109">Artık, aracınızdaki yönetilen bir Windows Mağazası uygulamasıyla çalışması için ne yapılacağını merak ediyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-109">Now you’re curious what to do so that your tool works with a managed Windows Store app.</span></span> <span data-ttu-id="1f5e9-110">Belki de bu işi yapmayı denediniz ve bu uygulamayı basit bir görev olmadığını keşfetti.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-110">Perhaps you’ve already tried to make this work, and have discovered that it’s not a straightforward task.</span></span> <span data-ttu-id="1f5e9-111">Aslında, tüm araç geliştiricileri için belirgin olmayan bazı önemli noktalar vardır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-111">Indeed, there are a number of considerations that might not be obvious to all tools developers.</span></span> <span data-ttu-id="1f5e9-112">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-112">For example:</span></span>

- <span data-ttu-id="1f5e9-113">Windows Mağazası uygulamaları, önemli ölçüde azaltılan izinlerle çalışır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-113">Windows Store apps run in a context with severely reduced permissions.</span></span>

- <span data-ttu-id="1f5e9-114">Windows meta veri dosyalarının geleneksel yönetilen modüllerle karşılaştırıldığında benzersiz özellikleri vardır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-114">Windows Metadata files have unique characteristics when compared to traditional managed modules.</span></span>

- <span data-ttu-id="1f5e9-115">Windows Mağazası uygulamaları, etkileşim azaldığında kendini askıya alma alışkanlığıyla sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-115">Windows Store apps have a habit of suspending themselves when interactivity goes down.</span></span>

- <span data-ttu-id="1f5e9-116">İşlemler arası iletişim mekanizmalarda artık çeşitli nedenlerle çalışmamaya çalışmayabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-116">Your inter-process communication mechanisms may no longer work for various reasons.</span></span>

<span data-ttu-id="1f5e9-117">Bu konu, bilmeniz gereken şeyleri ve bunlarla nasıl doğru şekilde ilgilenmekte olduğunu listeler.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-117">This topic lists the things you need to be aware of and how to deal with them properly.</span></span>

<span data-ttu-id="1f5e9-118">CLR profil oluşturma API 'SI için yeni başladıysanız daha iyi tanıtım bilgileri bulmak için bu konunun sonundaki kaynaklara atlayın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-118">If you’re new to the CLR Profiling API, skip down to the Resources at the end of this topic to find better introductory information.</span></span>

<span data-ttu-id="1f5e9-119">Belirli Windows API 'Leri ve bunların nasıl kullanılması gerektiği hakkında ayrıntı sağlamak, bu konunun kapsamı dışındadır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-119">Providing detail about specific Windows APIs and how they should be used is also outside the scope of this topic.</span></span> <span data-ttu-id="1f5e9-120">Bu konuyu bir başlangıç noktası olarak değerlendirin ve burada başvurulan herhangi bir Windows API 'si hakkında daha fazla bilgi edinmek için MSDN 'ye başvurun.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-120">Consider this topic a starting point, and refer to MSDN to learn more about any Windows APIs referenced here.</span></span>

## <a name="architecture-and-terminology"></a><span data-ttu-id="1f5e9-121">Mimari ve terminoloji</span><span class="sxs-lookup"><span data-stu-id="1f5e9-121">Architecture and terminology</span></span>

<span data-ttu-id="1f5e9-122">Genellikle, bir tanılama aracı aşağıdaki çizimde gösterildiği gibi bir mimariye sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-122">Typically, a diagnostic tool has an architecture like the one shown in the following illustration.</span></span> <span data-ttu-id="1f5e9-123">"Profil Oluşturucu" terimini kullanır, ancak bu birçok araç, tipik performans veya bellek profili oluşturma işleminin kod kapsamı, sahte nesne çerçeveleri, zaman gezme hata ayıklama, uygulama izleme vb. gibi alanlara göre daha iyi bir şekilde geçer.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-123">It uses the term "profiler," but many such tools go well beyond typical performance or memory profiling into areas such as code coverage, mock object frameworks, time-travel debugging, application monitoring, and so on.</span></span> <span data-ttu-id="1f5e9-124">Kolaylık olması için bu konu, profil oluşturucular olarak tüm bu araçlara başvuralmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-124">For simplicity, this topic will continue to refer to all these tools as profilers.</span></span>

<span data-ttu-id="1f5e9-125">Bu konu başlığı altında aşağıdaki terminoloji kullanılır:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-125">The following terminology is used throughout this topic:</span></span>

<span data-ttu-id="1f5e9-126">**Uygulama**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-126">**Application**</span></span>

<span data-ttu-id="1f5e9-127">Bu, profil oluşturucunun analiz olduğu uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-127">This is the application that the profiler is analyzing.</span></span> <span data-ttu-id="1f5e9-128">Genellikle, bu uygulamanın geliştiricisi uygulamayla ilgili sorunları tanılamaya yardımcı olması için profil oluşturucuyu kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-128">Typically, the developer of this application is now using the profiler to help diagnose issues with the application.</span></span> <span data-ttu-id="1f5e9-129">Geleneksel olarak, bu uygulama bir Windows masaüstü uygulaması olacaktır, ancak bu konu başlığında Windows Mağazası uygulamaları ' na bakıyoruz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-129">Traditionally, this application would be a Windows desktop application, but in this topic, we’re looking at Windows Store apps.</span></span>

<span data-ttu-id="1f5e9-130">**Profil oluşturucu DLL 'SI**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-130">**Profiler DLL**</span></span>

<span data-ttu-id="1f5e9-131">Bu, çözümlenmekte olan uygulamanın işlem alanına yüklenen bileşendir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-131">This is the component that loads into the process space of the application being analyzed.</span></span> <span data-ttu-id="1f5e9-132">Profiler "Agent" olarak da bilinen bu bileşen [ICorProfilerCallback](icorprofilercallback-interface.md)[ICorProfilerCallback arabirimi](icorprofilercallback-interface.md)(2, 3, vb.) arabirimlerini uygular ve ile Ilgili verileri toplamak Için [ICorProfilerInfo](icorprofilerinfo-interface.md)(2, 3, vb.) arabirimlerini kullanır. analiz edilen uygulama ve potansiyel olarak uygulamanın davranışının özellikleri.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-132">This component, also known as the profiler "agent," implements the [ICorProfilerCallback](icorprofilercallback-interface.md)[ICorProfilerCallback Interface](icorprofilercallback-interface.md)(2,3,etc.) interfaces and consumes the [ICorProfilerInfo](icorprofilerinfo-interface.md)(2,3,etc.) interfaces to collect data about the analyzed application and potentially modify aspects of the application’s behavior.</span></span>

<span data-ttu-id="1f5e9-133">**Profiler kullanıcı arabirimi**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-133">**Profiler UI**</span></span>

<span data-ttu-id="1f5e9-134">Bu, profil oluşturucu kullanıcısının etkileşimde bulunduğu bir masaüstü uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-134">This is a desktop application that the profiler user interacts with.</span></span> <span data-ttu-id="1f5e9-135">Uygulama durumunun kullanıcıya gösterilmesi ve kullanıcıya analiz edilen uygulamanın davranışını denetleme olanağı verilmesi sorumludur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-135">It’s responsible for displaying application status to the user and giving the user the means to control the behavior of the analyzed application.</span></span> <span data-ttu-id="1f5e9-136">Bu bileşen, profili oluşturulan uygulamanın işlem alanından ayrı olarak kendi işlem alanında çalışır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-136">This component always runs in its own process space, separate from the process space of the application being profiled.</span></span> <span data-ttu-id="1f5e9-137">Profil Oluşturucu kullanıcı arabirimi, analiz edilen uygulamanın profil oluşturucu DLL 'nin başlangıçta yüklenmediği durumlarda profil oluşturucu DLL 'sini yüklemesine yol açmak için [ıclrprofile:: AttachProfiler](iclrprofiling-attachprofiler-method.md) yöntemini çağıran işlem olan "Ekle tetikleyicisi" olarak da davranabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-137">The Profiler UI can also act as the "attach trigger," which is the process that calls the [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md) method, to cause the analyzed application to load the Profiler DLL in those cases where the profiler DLL did not load on startup.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="1f5e9-138">Profil Oluşturucu kullanıcı arabiriminize bir Windows Mağazası uygulamasını denetlemek ve rapor etmek için kullanıldığında bile bir Windows masaüstü uygulaması kalmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-138">Your Profiler UI should remain a Windows desktop application, even when it is used to control and report on a Windows Store app.</span></span> <span data-ttu-id="1f5e9-139">Tanılama aracınızı Windows Mağazası 'nda paketleyebilve sunamayacak kadar beklememeniz beklenmemektedir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-139">Don’t expect to be able to package and ship your diagnostics tool in the Windows Store.</span></span> <span data-ttu-id="1f5e9-140">Araclarınızın Windows Mağazası uygulamalarının yapamadığını ve bu nesnelerin birçoğu Profiler Kullanıcı arabiriminizdeki gibi şeyler yapması gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-140">Your tool needs to do things that Windows Store apps cannot do, and many of those things reside inside your Profiler UI.</span></span>

<span data-ttu-id="1f5e9-141">Bu belge boyunca örnek kod şunları varsayar:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-141">Throughout this document, the sample code assumes that:</span></span>

- <span data-ttu-id="1f5e9-142">Profil oluşturucu DLL 'niz, CLR C++PROFIL oluşturma API 'sinin gereksinimlerine göre yerel bir dll olması gerektiğinden ' de yazılır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-142">Your Profiler DLL is written in C++, because it must be a native DLL, as per the requirements of the CLR Profiling API.</span></span>

- <span data-ttu-id="1f5e9-143">Profil Oluşturucu kullanıcı arabiriminize yazılır C#.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-143">Your Profiler UI is written in C#.</span></span> <span data-ttu-id="1f5e9-144">Bu gerekli değildir, ancak bu gerekli değildir, ancak profil Oluşturucu kullanıcı arabirimine yönelik dilde bir gereksinim olmadığından, neden kısa ve basit bir dil seçmemelidir?</span><span class="sxs-lookup"><span data-stu-id="1f5e9-144">This isn’t necessary, but because there are no requirements on the language for your Profiler UI’s process, why not pick a language that’s concise and simple?</span></span>

### <a name="windows-rt-devices"></a><span data-ttu-id="1f5e9-145">Windows RT cihazları</span><span class="sxs-lookup"><span data-stu-id="1f5e9-145">Windows RT devices</span></span>

<span data-ttu-id="1f5e9-146">Windows RT cihazları oldukça kilitlidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-146">Windows RT devices are quite locked down.</span></span> <span data-ttu-id="1f5e9-147">Üçüncü taraf profil oluşturucular yalnızca bu cihazlara yüklenemez.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-147">Third-party profilers simply cannot be loaded on such devices.</span></span> <span data-ttu-id="1f5e9-148">Bu belge Windows 8 bilgisayarlara odaklanır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-148">This document focuses on Windows 8 PCs.</span></span>

## <a name="consuming-windows-runtime-apis"></a><span data-ttu-id="1f5e9-149">Windows Çalışma Zamanı API 'Leri kullanma</span><span class="sxs-lookup"><span data-stu-id="1f5e9-149">Consuming Windows Runtime APIs</span></span>

<span data-ttu-id="1f5e9-150">Aşağıdaki bölümlerde ele alınan çeşitli senaryolarda, Profil Oluşturucu kullanıcı arabirimi masaüstü uygulamanızın bazı yeni Windows Çalışma Zamanı API 'Leri kullanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-150">In a number of scenarios discussed in the following sections, your Profiler UI desktop application needs to consume some new Windows Runtime APIs.</span></span> <span data-ttu-id="1f5e9-151">Masaüstü uygulamalarından hangi Windows Çalışma Zamanı API 'Lerinin kullanılabileceğini ve bunların Masaüstü uygulamalarından ve Windows Mağazası uygulamalarından çağrıldığında farklı olup olmadığını anlamak için belgelere danışmak isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-151">You’ll want to consult the documentation to understand which Windows Runtime APIs can be used from desktop applications, and whether their behavior is different when called from desktop applications and Windows Store apps.</span></span>

<span data-ttu-id="1f5e9-152">Profil Oluşturucu kullanıcı arabiriminizi yönetilen kodda yazılmışsa, bu Windows Çalışma Zamanı API 'Leri kullanmayı kolaylaştırmak için yapmanız gereken birkaç adım olacaktır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-152">If your Profiler UI is written in managed code, there will be a few steps you’ll need to do to make consuming those Windows Runtime APIs easy.</span></span> <span data-ttu-id="1f5e9-153">Daha fazla bilgi için bkz. [yönetilen masaüstü uygulamaları ve Windows çalışma zamanı](https://go.microsoft.com/fwlink/?LinkID=271858) makalesi.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-153">See the [Managed desktop apps and Windows Runtime](https://go.microsoft.com/fwlink/?LinkID=271858) article for more information.</span></span>

## <a name="loading-the-profiler-dll"></a><span data-ttu-id="1f5e9-154">Profil oluşturucu DLL yükleniyor</span><span class="sxs-lookup"><span data-stu-id="1f5e9-154">Loading the Profiler DLL</span></span>

<span data-ttu-id="1f5e9-155">Bu bölümde, Profil Oluşturucu kullanıcı arabiriminin Windows Mağazası uygulamasının profil oluşturucu DLL 'nizi yüklemesine neden olduğu açıklanır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-155">This section describes how your Profiler UI causes the Windows Store app to load your Profiler DLL.</span></span> <span data-ttu-id="1f5e9-156">Bu bölümde açıklanan kod Profiler kullanıcı arabirimi masaüstü uygulamanıza aittir ve bu nedenle, masaüstü uygulamaları için güvenli olan ancak Windows Mağazası uygulamaları için güvenli olan Windows API 'Lerini kullanmayı içerir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-156">The code discussed in this section belongs in your Profiler UI desktop app, and therefore involves using Windows APIs that are safe for desktop apps but not necessarily safe for Windows Store apps.</span></span>

<span data-ttu-id="1f5e9-157">Profil Oluşturucu kullanıcı arabiriminizi, profil oluşturucu DLL 'nizin uygulamanın işlem alanına iki şekilde yüklenmesine neden olabilir:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-157">Your Profiler UI can cause your Profiler DLL to be loaded into the application’s process space in two ways:</span></span>

- <span data-ttu-id="1f5e9-158">Uygulama başlangıcında, ortam değişkenleri tarafından denetlenen şekilde.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-158">At application startup, as controlled by environment variables.</span></span>

- <span data-ttu-id="1f5e9-159">Başlangıç tamamlandıktan sonra, [ıclrprofile:: AttachProfiler](iclrprofiling-attachprofiler-method.md) yöntemini çağırarak uygulamaya ekleme.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-159">By attaching to the application after startup is complete by calling the [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md) method.</span></span>

<span data-ttu-id="1f5e9-160">İlk yol bloklarınızdan biri, Windows Mağazası uygulamalarıyla düzgün şekilde çalışması için profil oluşturucu DLL 'nizin başlangıç yükleme ve iliştirme yüküne sahip olur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-160">One of your first roadblocks will be getting startup-load and attach-load of your Profiler DLL to work properly with Windows Store apps.</span></span> <span data-ttu-id="1f5e9-161">Her iki yükleme biçimi de ortak olarak bazı özel konuları paylaşır, bu nedenle bunlarla başlayalım.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-161">Both forms of loading share some special considerations in common, so let’s start with them.</span></span>

### <a name="common-considerations-for-startup-and-attach-loads"></a><span data-ttu-id="1f5e9-162">Başlangıç ve iliştirme yükleri için genel hususlar</span><span class="sxs-lookup"><span data-stu-id="1f5e9-162">Common considerations for startup and attach loads</span></span>

<span data-ttu-id="1f5e9-163">**Profil oluşturucu DLL 'nizi imzalama**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-163">**Signing your Profiler DLL**</span></span>

<span data-ttu-id="1f5e9-164">Windows profil oluşturucu DLL 'nizi yüklemeyi denediğinde, profil oluşturucu DLL 'nizin düzgün şekilde imzalandığını doğrular.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-164">When Windows attempts to load your Profiler DLL, it verifies that your Profiler DLL is properly signed.</span></span> <span data-ttu-id="1f5e9-165">Aksi takdirde, yükleme varsayılan olarak başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-165">If not, the load fails by default.</span></span> <span data-ttu-id="1f5e9-166">Bunu yapmak için iki yol vardır:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-166">There are two ways to do this:</span></span>

- <span data-ttu-id="1f5e9-167">Profil oluşturucu DLL 'nizin imzalandığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-167">Ensure that your Profiler DLL is signed.</span></span>

- <span data-ttu-id="1f5e9-168">Aracınızı kullanmadan önce, Windows 8 makinesine bir geliştirici lisansı yüklemeleri gerektiğini kullanıcıya söyleyin.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-168">Tell your user that they must install a developer license on their Windows 8 machine before using your tool.</span></span> <span data-ttu-id="1f5e9-169">Bu, otomatik olarak Visual Studio 'dan veya bir komut isteminden el ile yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-169">This can be done automatically from Visual Studio or manually from a command prompt.</span></span> <span data-ttu-id="1f5e9-170">Daha fazla bilgi için bkz. [Geliştirici lisansı edinme](https://docs.microsoft.com/previous-versions/windows/apps/hh974578(v=win.10)).</span><span class="sxs-lookup"><span data-stu-id="1f5e9-170">For more information, see [Get a developer license](https://docs.microsoft.com/previous-versions/windows/apps/hh974578(v=win.10)).</span></span>

<span data-ttu-id="1f5e9-171">**Dosya sistemi izinleri**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-171">**File system permissions**</span></span>

<span data-ttu-id="1f5e9-172">Windows Mağazası uygulamasının profil oluşturucu DLL 'nizi, varsayılan olarak yer aldığı dosya sistemindeki konumdan yükleme ve yürütme izni olması gerekir. Windows Mağazası uygulaması, çoğu dizinde bu izne sahip değildir ve profil oluşturucu DLL 'nizi yükleme girişimi başarısız olur Windows uygulaması olay günlüğünde şuna benzer bir giriş oluşturacak:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-172">The Windows Store app must have permission to load and execute your Profiler DLL from the location on the file system in which it residesBy default, the Windows Store app doesn’t have such permission on most directories, and any failed attempt to load your Profiler DLL will produce an entry in the Windows Application event log that looks something like this:</span></span>

```output
NET Runtime version 4.0.30319.17929 - Loading profiler failed during CoCreateInstance.  Profiler CLSID: '{xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}'.  HRESULT: 0x80070005.  Process ID (decimal): 4688.  Message ID: [0x2504].
```

<span data-ttu-id="1f5e9-173">Genellikle, Windows Mağazası uygulamalarının diskte yalnızca sınırlı bir konum kümesine erişmesine izin verilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-173">Generally, Windows Store apps are only allowed to access a limited set of locations on the disk.</span></span> <span data-ttu-id="1f5e9-174">Her Windows Mağazası uygulaması, kendi uygulama veri klasörlerine ve dosya sisteminde tüm Windows Mağazası uygulamalarına erişim izni verilen diğer diğer alanlara erişebilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-174">Each Windows Store app can access its own application data folders, as well as a few other areas in the file system for which all Windows Store apps are granted access.</span></span> <span data-ttu-id="1f5e9-175">Tüm Windows Mağazası uygulamalarının varsayılan olarak burada okuma ve yürütme izinlerine sahip olduğu için profil oluşturucu DLL 'nizi ve bağımlılıklarını Program Files veya Program Files (x86) altında bir yere yüklemek en iyisidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-175">It's best to install your Profiler DLL and its dependencies somewhere under Program Files or Program Files (x86), because all Windows Store apps have read and execute permissions there by default.</span></span>

### <a name="startup-load"></a><span data-ttu-id="1f5e9-176">Başlangıç yükü</span><span class="sxs-lookup"><span data-stu-id="1f5e9-176">Startup load</span></span>

<span data-ttu-id="1f5e9-177">Genellikle, bir masaüstü uygulamasında, profil oluşturucu UI, gerekli CLR profil oluşturma API 'SI ortam değişkenlerini (örneğin, `COR_PROFILER`, `COR_ENABLE_PROFILING`ve `COR_PROFILER_PATH`) içeren bir ortam bloğu başlatarak profil oluşturucu DLL 'nizin başlangıç yüküne sorar ve sonra yeni bir Bu ortam bloğuyla işleme.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-177">Typically, in a desktop app, your Profiler UI prompts a startup load of your Profiler DLL by initializing an environment block that contains the required CLR Profiling API environment variables (i.e., `COR_PROFILER`, `COR_ENABLE_PROFILING`, and `COR_PROFILER_PATH`), and then creating a new process with that environment block.</span></span> <span data-ttu-id="1f5e9-178">Aynı durum Windows Mağazası uygulamaları için de geçerlidir, ancak mekanizmalar farklıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-178">The same holds true for Windows Store apps, but the mechanisms are different.</span></span>

<span data-ttu-id="1f5e9-179">**Yükseltilmiş ayrıcalıklarla çalıştırma**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-179">**Don’t run elevated**</span></span>

<span data-ttu-id="1f5e9-180">Windows Mağazası uygulama Işlemi B 'yi oluşturma girişimlerini işsek, A Işleminin yüksek bütünlük düzeyinde (yükseltilmiş olmayan) değil, Orta bütünlük düzeyinde çalıştırılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-180">If Process A attempts to spawn Windows Store app Process B, Process A should be run at medium integrity level, not at high integrity level (that is, not elevated).</span></span> <span data-ttu-id="1f5e9-181">Yani, profil oluşturucu Kullanıcı arabiriminiz Orta bütünlük düzeyinde çalışıyor olmalıdır veya Windows Mağazası uygulamasını başlatmak için orta düzeyde bütünlük düzeyinde başka bir masaüstü işlemi oluşturulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-181">This means that either your Profiler UI should be running at medium integrity level, or it must spawn another desktop process at medium integrity level to take care of launching the Windows Store app.</span></span>

<span data-ttu-id="1f5e9-182">**Profil için bir Windows Mağazası uygulaması seçme**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-182">**Choosing a Windows Store App to profile**</span></span>

<span data-ttu-id="1f5e9-183">İlk olarak, Profil Oluşturucu kullanıcı tarafından hangi Windows Mağazası uygulamasının başlatılmasını istemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-183">First, you’ll want to ask your profiler user which Windows Store app to launch.</span></span> <span data-ttu-id="1f5e9-184">Masaüstü uygulamaları için, belki de bir dosya tarama iletişim kutusu gösterebilirsiniz ve Kullanıcı bir. exe dosyası bulup seçer.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-184">For desktop apps, perhaps you’d show a file Browse dialog, and the user would find and select an .exe file.</span></span> <span data-ttu-id="1f5e9-185">Ancak Windows Mağazası uygulamaları farklıdır ve bir tarama iletişim kutusu kullanmak anlamlı değildir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-185">But Windows Store apps are different, and using a Browse dialog doesn’t make sense.</span></span> <span data-ttu-id="1f5e9-186">Bunun yerine, kullanıcıya, bu kullanıcı tarafından seçilecek Windows Mağazası uygulamalarının bir listesini göstermek daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-186">Instead, it’s better to show the user a list of Windows Store apps installed for that user to select from.</span></span>

<span data-ttu-id="1f5e9-187">Bu listeyi oluşturmak için <xref:Windows.Management.Deployment.PackageManager> sınıfını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-187">You can use the <xref:Windows.Management.Deployment.PackageManager> class to generate this list.</span></span> <span data-ttu-id="1f5e9-188">`PackageManager`, masaüstü uygulamaları tarafından kullanılabilen bir Windows Çalışma Zamanı sınıftır ve aslında *yalnızca* masaüstü uygulamalarında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-188">`PackageManager` is a Windows Runtime class that is available to desktop apps, and in fact it is *only* available to desktop apps.</span></span>

<span data-ttu-id="1f5e9-189">İçinde C# bir masaüstü uygulaması olarak yazılmış bir kuramsal profil Oluşturucu kullanıcı arabiriminden aşağıdaki kod örneği, Windows uygulamalarının bir listesini oluşturmak için `PackageManager` kullanır:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-189">The following code example from a hypothetical Profiler UI written as a desktop app in C# uses the `PackageManager` to generate a list of Windows apps:</span></span>

```csharp
string currentUserSID = WindowsIdentity.GetCurrent().User.ToString();
IAppxFactory appxFactory = (IAppxFactory) new AppxFactory();
PackageManager packageManager = new PackageManager();
IEnumerable<Package> packages = packageManager.FindPackagesForUser(currentUserSID);
```

<span data-ttu-id="1f5e9-190">**Özel ortam bloğunu belirtme**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-190">**Specifying the custom environment block**</span></span>

<span data-ttu-id="1f5e9-191">Yeni bir COM arabirimi olan [ıpackagedebugsettings](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings), bazı tanılama biçimlerinin daha kolay olması Için bir Windows Mağazası uygulamasının yürütme davranışını özelleştirmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-191">A new COM interface, [IPackageDebugSettings](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings), allows you to customize the execution behavior of a Windows Store app to make some forms of diagnostics easier.</span></span> <span data-ttu-id="1f5e9-192">Yöntemlerinden biri olan [Enabledebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging), bir ortam bloğunu başlatıldığında Windows Mağazası uygulamasına, otomatik işlem askıya alma devre dışı bırakma gibi diğer yararlı etkilerle geçişlerinizi yapmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-192">One of its methods, [EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging), lets you pass an environment block to the Windows Store app when it’s launched, along with other useful effects like disabling automatic process suspension.</span></span> <span data-ttu-id="1f5e9-193">Ortam bloğu, profil oluşturucu DLL 'nizi yüklemek için CLR tarafından kullanılan ortam değişkenlerini (`COR_PROFILER`, `COR_ENABLE_PROFILING`ve `COR_PROFILER_PATH)`) belirtmeniz gerektiği için önemlidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-193">The environment block is important because that’s where you need to specify the environment variables (`COR_PROFILER`, `COR_ENABLE_PROFILING`, and `COR_PROFILER_PATH)`) used by the CLR to load your Profiler DLL .</span></span>

<span data-ttu-id="1f5e9-194">Aşağıdaki kod parçacığını göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-194">Consider the following code snippet:</span></span>

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packageFullName, debuggerCommandLine,
                                                                 (IntPtr)fixedEnvironmentPzz);
```

<span data-ttu-id="1f5e9-195">Sağ almanız gereken birkaç öğe vardır:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-195">There are a couple of items you'll need to get right:</span></span>

- <span data-ttu-id="1f5e9-196">`packageFullName`, paketler üzerinde yineleirken ve yakalayıp `package.Id.FullName` olarak belirlenebilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-196">`packageFullName` can be determined while iterating over the packages and grabbing `package.Id.FullName`.</span></span>

- <span data-ttu-id="1f5e9-197">`debuggerCommandLine` biraz daha ilginç.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-197">`debuggerCommandLine` is a bit more interesting.</span></span> <span data-ttu-id="1f5e9-198">Özel ortam bloğunu Windows Mağazası uygulamasına geçirmek için, kendi uyarlaması kukla hata ayıklayıcıyı yazmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-198">In order to pass the custom environment block to the Windows Store app, you need to write your own, simplistic dummy debugger.</span></span> <span data-ttu-id="1f5e9-199">Windows Mağazası uygulaması askıya alındı ve bu örnekte olduğu gibi bir komut satırı ile hata ayıklayıcıyı başlatarak hata ayıklayıcıyı iliştirir:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-199">Windows spawns the Windows Store app suspended and then attaches your debugger by launching your debugger with a command line like in this example:</span></span>

    ```console
    MyDummyDebugger.exe -p 1336 -tid 1424
    ```

     <span data-ttu-id="1f5e9-200">`-p 1336`, Windows Mağazası uygulamasının 1336 Işlem KIMLIĞI olduğu ve `-tid 1424` olduğu anlamına gelir. Iş parçacığı KIMLIĞI 1424, askıya alınan iş parçacığıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-200">where `-p 1336` means the Windows Store app has Process ID 1336, and `-tid 1424` means Thread ID 1424 is the thread that is suspended.</span></span> <span data-ttu-id="1f5e9-201">Kukla hata ayıklayıcı, komut satırından ThreadID öğesini ayrıştırır, bu iş parçacığını sürdürür ve sonra çıkın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-201">Your dummy debugger would parse the ThreadID from the command-line, resume that thread, and then exit.</span></span>

     <span data-ttu-id="1f5e9-202">Bunu yapmak için örnek C++ kod aşağıda verilmiştir (hata denetimi eklediğinizden emin olun!):</span><span class="sxs-lookup"><span data-stu-id="1f5e9-202">Here’s some example C++ code to do this (be sure to add error checking!):</span></span>

    ```cpp
    int wmain(int argc, wchar_t* argv[])
    {
        // …
        // Parse command line here
        // …

        HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME,
                                                                  FALSE /* bInheritHandle */, nThreadID);
        ResumeThread(hThread);
        CloseHandle(hThread);
        return 0;
    }
    ```

     <span data-ttu-id="1f5e9-203">Bu kukla hata ayıklayıcıyı Tanılama Aracı yüklemenizin bir parçası olarak dağıtmanız ve ardından `debuggerCommandLine` parametresinde bu hata ayıklayıcının yolunu belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-203">You’ll need to deploy this dummy debugger as part of your diagnostics tool installation, and then specify the path to this debugger in the `debuggerCommandLine` parameter.</span></span>

<span data-ttu-id="1f5e9-204">**Windows Mağazası uygulamasını başlatma**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-204">**Launching the Windows Store app**</span></span>

<span data-ttu-id="1f5e9-205">Windows Mağazası uygulamasını başlatma sırasında son olarak geldi.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-205">The moment to launch the Windows Store app has finally arrived.</span></span> <span data-ttu-id="1f5e9-206">Bunu kendiniz yapmadıysanız, [CreateProcess](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) 'In bir Windows Mağazası uygulama işlemi oluşturma işleminin nasıl yapıldığını fark etmiş olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-206">If you’ve already tried doing this yourself, you may have noticed that [CreateProcess](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) is not how you create a Windows Store app process.</span></span> <span data-ttu-id="1f5e9-207">Bunun yerine, [ıapplicationactivationmanager:: ActivateApplication](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iapplicationactivationmanager-activateapplication) metodunu kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-207">Instead, you’ll need to use the [IApplicationActivationManager::ActivateApplication](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iapplicationactivationmanager-activateapplication) method.</span></span> <span data-ttu-id="1f5e9-208">Bunu yapmak için, başladığınızı Windows Mağazası uygulamasının uygulama kullanıcı modeli KIMLIĞINI almanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-208">To do that, you’ll need to get the App User Model ID of the Windows Store app that you’re launching.</span></span> <span data-ttu-id="1f5e9-209">Diğer bir deyişle, bildirim aracılığıyla biraz fikir yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-209">And that means you’ll need to do a little digging through the manifest.</span></span>

<span data-ttu-id="1f5e9-210">Paketleriniz üzerinden yineleme yaparken (önceki [başlangıç yükleme](#startup-load) bölümünde yer alan "profile Için bir Windows Mağazası uygulaması seçme" bölümüne bakın), geçerli paketin bildiriminde bulunan uygulamalar kümesini almak isteyeceksiniz:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-210">While iterating over your packages (see "Choosing a Windows Store App to Profile" in the [Startup load](#startup-load) section earlier), you’ll want to grab the set of applications contained in the current package’s manifest:</span></span>

```csharp
string manifestPath = package.InstalledLocation.Path + "\\AppxManifest.xml";

AppxPackaging.IStream manifestStream;
SHCreateStreamOnFileEx(
                    manifestPath,
                    0x00000040,     // STGM_READ | STGM_SHARE_DENY_NONE
                    0,              // file creation attributes
                    false,          // fCreate
                    null,           // reserved
                    out manifestStream);

IAppxManifestReader manifestReader = appxFactory.CreateManifestReader(manifestStream);

IAppxManifestApplicationsEnumerator appsEnum = manifestReader.GetApplications();
```

<span data-ttu-id="1f5e9-211">Evet, bir pakette birden fazla uygulama olabilir ve her uygulamanın kendi uygulama kullanıcı modeli KIMLIĞI vardır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-211">Yes, one package can have multiple applications, and each application has its own Application User Model ID.</span></span> <span data-ttu-id="1f5e9-212">Bu nedenle, kullanıcıdan hangi uygulamanın profilini oluşturmasını ve bu uygulamadan uygulama kullanıcı modeli KIMLIĞINI elde etmesini istemeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-212">So you’ll want to ask your user which application to profile, and grab the Application User Model ID from that particular application:</span></span>

```csharp
while (appsEnum.GetHasCurrent() != 0)
{
    IAppxManifestApplication app = appsEnum.GetCurrent();
    string appUserModelId = app.GetAppUserModelId();
    //...
}
```

<span data-ttu-id="1f5e9-213">Son olarak, artık Windows Mağazası uygulamasını başlatmanız gerekenler vardır:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-213">Finally, you now have what you need to launch the Windows Store app:</span></span>

```csharp
IApplicationActivationManager appActivationMgr = new ApplicationActivationManager();
appActivationMgr.ActivateApplication(appUserModelId, appArgs, ACTIVATEOPTIONS.AO_NONE, out pid);
```

<span data-ttu-id="1f5e9-214">**DisableDebugging öğesini çağırmayı unutmayın**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-214">**Remember to call DisableDebugging**</span></span>

<span data-ttu-id="1f5e9-215">[Ipackagedebugsettings:: EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging)öğesini çağırdığınızda, [ıpackagedebugsettings::D isabledebug](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) metodunu çağırarak, sizin tarafınızdan daha sonra temizleyebilmenizi sağlayacak bir Promise yaptınız. bu nedenle, profil oluşturma oturumu üzerindeyken bunu yaptığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-215">When you called [IPackageDebugSettings::EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging), you made a promise that you would clean up after yourself by calling the [IPackageDebugSettings::DisableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) method, so be sure to do that when the profiling session is over.</span></span>

### <a name="attach-load"></a><span data-ttu-id="1f5e9-216">Yük Ekle</span><span class="sxs-lookup"><span data-stu-id="1f5e9-216">Attach load</span></span>

<span data-ttu-id="1f5e9-217">Profil Oluşturucu kullanıcı arabirimi, profil oluşturucu DLL 'sini zaten çalışmaya başlamış olan bir uygulamaya iliştirmek istediğinde, [ıclrprofile:: AttachProfiler](iclrprofiling-attachprofiler-method.md)kullanır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-217">When your Profiler UI wants to attach its Profiler DLL to an application that has already started running, it uses [ICLRProfiling::AttachProfiler](iclrprofiling-attachprofiler-method.md).</span></span> <span data-ttu-id="1f5e9-218">Aynı durum Windows Mağazası uygulamalarıyla doğru bir şekilde geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-218">The same holds true with Windows Store apps.</span></span> <span data-ttu-id="1f5e9-219">Ancak daha önce listelenen yaygın noktalara ek olarak, hedef Windows Mağazası uygulamasının askıya alınmadığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-219">But in addition to the common considerations listed earlier, make sure the that the target Windows Store app is not suspended.</span></span>

<span data-ttu-id="1f5e9-220">**EnableDebugging**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-220">**EnableDebugging**</span></span>

<span data-ttu-id="1f5e9-221">Başlangıç yüklerinde olduğu gibi, [ıpackagedebugsettings:: EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging) metodunu çağırın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-221">As with startup load, call the [IPackageDebugSettings::EnableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-enabledebugging) method.</span></span> <span data-ttu-id="1f5e9-222">Ortam bloğunu geçirmek için ihtiyacınız yoktur, ancak diğer özelliklerinden birine ihtiyacınız vardır: otomatik işlem askıya alma devre dışı bırakılıyor.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-222">You don’t need it for passing an environment block, but you need one of its other features: disabling automatic process suspension.</span></span> <span data-ttu-id="1f5e9-223">Aksi takdirde, Profil Oluşturucu kullanıcı arabiriminizi [AttachProfiler](iclrprofiling-attachprofiler-method.md)' ı çağırdığında, hedef Windows Mağazası uygulaması askıya alınabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-223">Otherwise, when your Profiler UI calls [AttachProfiler](iclrprofiling-attachprofiler-method.md), the target Windows Store app may be suspended.</span></span> <span data-ttu-id="1f5e9-224">Aslında, bu durum büyük olasılıkla Kullanıcı Profil Oluşturucu kullanıcı ARABIRIMINIZE etkileşim kurmasından ve Windows Mağazası uygulamasının Kullanıcı ekranlarından hiçbirinde etkin olmaması olasıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-224">In fact, this is likely if the user is now interacting with your Profiler UI, and the Windows Store app is not active on any of the user’s screens.</span></span> <span data-ttu-id="1f5e9-225">Windows Mağazası uygulaması askıya alınırsa, bu, CLR 'nin profil oluşturucu DLL 'nizi eklemek için gönderdiği hiçbir sinyaline yanıt veremeyecektir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-225">And if the Windows Store app is suspended, it won’t be able to respond to any signal that the CLR sends to it to attach your Profiler DLL.</span></span>

<span data-ttu-id="1f5e9-226">Bu nedenle, şöyle bir şey yapmak isteyeceksiniz:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-226">So you’ll want to do something like this:</span></span>

```csharp
IPackageDebugSettings pkgDebugSettings = new PackageDebugSettings();
pkgDebugSettings.EnableDebugging(packageFullName, null /* debuggerCommandLine */,
                                                                 IntPtr.Zero /* environment */);
```

<span data-ttu-id="1f5e9-227">Bu, bir hata ayıklayıcı komut satırı veya ortam bloğu belirtmemenizi hariç, başlangıç yükü durumu için yaptığınız çağrıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-227">This is the same call you’d make for the startup load case, except you don’t specify a debugger command line or an environment block.</span></span>

<span data-ttu-id="1f5e9-228">**DisableDebugging**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-228">**DisableDebugging**</span></span>

<span data-ttu-id="1f5e9-229">Her zaman olduğu gibi, profil oluşturma oturumunuz tamamlandığında [ıpackagedebugsettings::D isableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) ' i çağırmayı unutmayın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-229">As always, don’t forget to call [IPackageDebugSettings::DisableDebugging](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ipackagedebugsettings-disabledebugging) when your profiling session is completed.</span></span>

## <a name="running-inside-the-windows-store-app"></a><span data-ttu-id="1f5e9-230">Windows Mağazası uygulaması içinde çalışıyor</span><span class="sxs-lookup"><span data-stu-id="1f5e9-230">Running inside the Windows Store app</span></span>

<span data-ttu-id="1f5e9-231">Bu nedenle, Windows Mağazası uygulaması son olarak profil oluşturucu DLL 'nizi yükledi.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-231">So the Windows Store app has finally loaded your Profiler DLL.</span></span> <span data-ttu-id="1f5e9-232">Artık profil oluşturucu DLL 'niz, hangi API 'Lerin izin verilebileceği ve daha düşük izinlerle çalıştırılması dahil olmak üzere Windows Mağazası uygulamaları için gereken farklı kurallara göre nasıl oynatılacağını taöğretmelidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-232">Now your Profiler DLL must be taught how to play by the different rules required by Windows Store apps, including which APIs are allowable and how to run with reduced permissions.</span></span>

### <a name="stick-to-the-windows-store-app-apis"></a><span data-ttu-id="1f5e9-233">Windows Mağazası uygulaması API 'Lerine çubuk</span><span class="sxs-lookup"><span data-stu-id="1f5e9-233">Stick to the Windows Store app APIs</span></span>

<span data-ttu-id="1f5e9-234">Windows API 'sine göz atarken, her API 'nin masaüstü uygulamaları, Windows Mağazası uygulamaları veya her ikisi için de geçerli olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-234">As you browse the Windows API, you’ll notice that every API is documented as being applicable to desktop apps, Windows Store apps, or both.</span></span> <span data-ttu-id="1f5e9-235">Örneğin, [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) Işlevi belgelerinin **gereksinimler** bölümü, işlevin yalnızca masaüstü uygulamaları için geçerli olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-235">For example, the **Requirements** section of the documentation for the [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) function indicates that the function applies to desktop apps only.</span></span> <span data-ttu-id="1f5e9-236">Buna karşılık, [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex) işlevi hem masaüstü uygulamaları hem de Windows Mağazası uygulamaları için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-236">In contrast, the [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex) function is available for both desktop apps and Windows Store apps.</span></span>

<span data-ttu-id="1f5e9-237">Profil oluşturucu DLL 'nizi geliştirirken, bunu bir Windows Mağazası uygulaması gibi değerlendirin ve yalnızca Windows Mağazası uygulamaları için kullanılabilir olarak belgelenen API 'Leri kullanın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-237">When developing your Profiler DLL, treat it as if it’s a Windows Store app and only use APIs that are documented as available to Windows Store apps.</span></span> <span data-ttu-id="1f5e9-238">Bağımlılıklarınızı çözümleyin (örneğin, profil oluşturucu DLL 'niz denetlemek için `link /dump /imports` ' ı çalıştırabilir) ve sonra bağımlılıklarınızın hangilerinin tamam olduğunu ve ne olmadığını görmek için docs ' ı arayın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-238">Analyze your dependencies (for example, you can run `link /dump /imports` against your Profiler DLL to audit), and then search the docs to see which of your dependencies are ok and which aren’t.</span></span> <span data-ttu-id="1f5e9-239">Çoğu durumda, ihlal, güvenli olarak belgelenen API 'nin daha yeni bir biçimiyle değiştirilerek (örneğin, [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) , [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex)ile değiştiriliyor) düzeltilebilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-239">In most cases, your violations can be fixed by simply replacing them with a newer form of the API that is documented as safe (for example, replacing [InitializeCriticalSectionAndSpinCount](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) with [InitializeCriticalSectionEx](/windows/desktop/api/synchapi/nf-synchapi-initializecriticalsectionex)).</span></span>

<span data-ttu-id="1f5e9-240">Profil oluşturucu DLL 'nizin yalnızca masaüstü uygulamaları için uygulanan bazı API 'Leri çağırırsa ve profil oluşturucu DLL 'niz bir Windows Mağazası uygulaması içine yüklendiğinde bile çalışmaya çalışabileceğini fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-240">You might notice that your Profiler DLL calls some APIs that apply to desktop apps only, and yet they seem to work even when your Profiler DLL is loaded inside a Windows Store app.</span></span> <span data-ttu-id="1f5e9-241">Bir Windows Mağazası uygulama işlemine yüklendiğinde profil oluşturucu DLL 'inizdeki Windows Mağazası uygulamalarıyla birlikte kullanılmak üzere belgelenmemiş API kullanmanın riskli olduğunu unutmayın:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-241">Be aware that it’s risky to use any API not documented for use with Windows Store apps in your Profiler DLL when loaded into a Windows Store app process:</span></span>

- <span data-ttu-id="1f5e9-242">Bu tür API 'Ler, Windows Mağazası uygulamalarının çalıştığı benzersiz bağlamda çağrıldığında çalışır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-242">Such APIs are not guaranteed to work when called in the unique context that Windows Store apps run in.</span></span>

- <span data-ttu-id="1f5e9-243">Bu tür API 'Ler, farklı Windows Mağazası uygulama işlemlerinin içinden çağrıldığında tutarlı bir şekilde çalışmayabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-243">Such APIs might not work consistently when called from within different Windows Store app processes.</span></span>

- <span data-ttu-id="1f5e9-244">Bu tür API 'Ler Windows Mağazası uygulamalarından geçerli Windows sürümündeki bir şekilde çalışıyor olabilir, ancak sonraki Windows sürümlerinde kesilebilir veya devre dışı bırakılabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-244">Such APIs might seem to work fine from Windows Store apps in the current version of Windows, but may break or be disabled in future releases of Windows.</span></span>

<span data-ttu-id="1f5e9-245">En iyi öneri, tüm ihlallerinizi düzeltemedi ve riskten kaçınmaktır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-245">The best advice is to fix all your violations and avoid the risk.</span></span>

<span data-ttu-id="1f5e9-246">Belirli bir API olmadan kesinlikle yapamayacağına ve Windows Mağazası uygulamaları için uygun bir değiştirme bulamamaya yönelik olduğunu fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-246">You might find that you absolutely cannot do without a particular API and cannot find a replacement suitable for Windows Store apps.</span></span> <span data-ttu-id="1f5e9-247">Böyle bir durumda, en az:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-247">In such a case, at a minimum:</span></span>

- <span data-ttu-id="1f5e9-248">Test, test edin, bu API kullanımınızın kullanımını test edin ve test edin.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-248">Test, test, test the living daylights out of your usage of that API.</span></span>

- <span data-ttu-id="1f5e9-249">Windows 'un gelecek sürümlerinde Windows Mağazası uygulamaları içinden çağrılırsa, API 'nin aniden kesilebilir veya kaybolabileceğini anlayın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-249">Understand that the API might suddenly break or disappear if called from inside Windows Store apps in future releases of Windows.</span></span> <span data-ttu-id="1f5e9-250">Bu, Microsoft tarafından uyumluluk sorunu olarak kabul edilmez ve kullanımınızı desteklemek bir öncelik vermez.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-250">This won’t be considered a compatibility concern by Microsoft, and supporting your usage of it will not be a priority.</span></span>

### <a name="reduced-permissions"></a><span data-ttu-id="1f5e9-251">Azaltılan izinler</span><span class="sxs-lookup"><span data-stu-id="1f5e9-251">Reduced permissions</span></span>

<span data-ttu-id="1f5e9-252">Windows Mağazası uygulama izinlerinin Masaüstü uygulamalarından farklı olduğu tüm yolları listelemek için bu konunun kapsamı dışındadır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-252">It’s outside the scope of this topic to list all the ways that Windows Store app permissions differ from desktop apps.</span></span> <span data-ttu-id="1f5e9-253">Ancak, profil oluşturucu DLL 'niz (bir masaüstü uygulamasına kıyasla bir Windows Mağazası uygulamasına yüklendiğinde) her türlü kaynağa erişmeye çalıştığında, kesinlikle davranış farklı olur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-253">But certainly the behavior will be different every time your Profiler DLL (when loaded into a Windows Store app as compared to a desktop app) tries to access any resources.</span></span> <span data-ttu-id="1f5e9-254">Dosya sistemi en yaygın örnektir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-254">The file system is the most common example.</span></span> <span data-ttu-id="1f5e9-255">Diskte belirli bir Windows Mağazası uygulamasının erişmesine izin verilen birkaç yer vardır (bkz. [dosya erişimi ve izinleri (Windows çalışma zamanı uygulamalar](https://docs.microsoft.com/previous-versions/windows/apps/hh967755(v=win.10))) ve PROFIL Oluşturucu dll 'niz aynı kısıtlamalar altında olacaktır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-255">There are but a few places on disk that a given Windows Store app is allowed to access (see [File access and permissions (Windows Runtime apps](https://docs.microsoft.com/previous-versions/windows/apps/hh967755(v=win.10))), and your Profiler DLL will be under the same restrictions.</span></span> <span data-ttu-id="1f5e9-256">Kodunuzu iyice test edin.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-256">Test your code thoroughly.</span></span>

### <a name="inter-process-communication"></a><span data-ttu-id="1f5e9-257">İşlem arası iletişim</span><span class="sxs-lookup"><span data-stu-id="1f5e9-257">Inter-process communication</span></span>

<span data-ttu-id="1f5e9-258">Bu kağıdın başındaki diyagramda gösterildiği gibi, profil oluşturucu DLL 'nizin (Windows Mağazası uygulaması işlem alanına yüklenir), kendi özel işlem sürecinize göre profil oluşturucu Kullanıcı arabiriminize (ayrı bir masaüstü uygulaması işlem alanında çalışan) iletişim kurması gerekir iletişim (IPC) kanalı.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-258">As shown in the diagram at the beginning of this paper, your Profiler DLL (loaded into the Windows Store app process space) will likely need to communicate with your Profiler UI (running in a separate desktop app process space) through your own custom inter-process communication (IPC) channel.</span></span> <span data-ttu-id="1f5e9-259">Profiler kullanıcı ARABIRIMI davranışını değiştirmek için, profil oluşturucu DLL 'sine sinyal gönderir ve profil oluşturucu DLL, çözümlenmiş Windows Mağazası uygulamasından verileri, işleme sonrası ve profil oluşturucu kullanıcısına görüntüleme için Profil Oluşturucu kullanıcı ARABIRIMINE geri gönderir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-259">The Profiler UI sends signals to the Profiler DLL to modify its behavior, and the Profiler DLL sends data from the analyzed Windows Store app back to the Profiler UI for post-processing and displaying to the profiler user.</span></span>

<span data-ttu-id="1f5e9-260">Çoğu profil oluşturucular bu şekilde çalışması gerekir, ancak profil oluşturucu DLL 'niz bir Windows Mağazası uygulamasına yüklendiğinde IPC mekanizmalarına yönelik seçimleriniz daha sınırlı olur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-260">Most profilers need to work this way, but your choices for IPC mechanisms are more limited when your Profiler DLL is loaded into a Windows Store app.</span></span> <span data-ttu-id="1f5e9-261">Örneğin, adlandırılmış kanallar Windows Mağazası uygulama SDK 'sının bir parçası değildir, bu nedenle bunları kullanamazsınız.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-261">For example, named pipes are not part of the Windows Store app SDK, so you cannot use them.</span></span>

<span data-ttu-id="1f5e9-262">Ancak, dosyalar hala yerinde, daha sınırlı bir biçimde albederdir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-262">But of course, files are still in, albeit in a more limited fashion.</span></span> <span data-ttu-id="1f5e9-263">Olaylar da kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-263">Events are also available.</span></span>

<span data-ttu-id="1f5e9-264">**Dosyalar üzerinden iletişim kurma**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-264">**Communicating via files**</span></span>

<span data-ttu-id="1f5e9-265">Verilerinizin büyük olasılıkla profil oluşturucu DLL ve Profil Oluşturucu kullanıcı arabirimi arasında dosyalar aracılığıyla geçiş yapılır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-265">Most of your data will likely pass between the Profiler DLL and Profiler UI via files.</span></span> <span data-ttu-id="1f5e9-266">Anahtar profil oluşturucu DLL 'nizin (bir Windows Mağazası uygulaması bağlamında) ve Profil Oluşturucu kullanıcı arabiriminin okuma ve yazma erişimine sahip olduğu bir dosya konumu seçmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-266">The key is to pick a file location that both your Profiler DLL (in the context of a Windows Store app) and Profiler UI have read and write access to.</span></span> <span data-ttu-id="1f5e9-267">Örneğin, geçici klasör yolu, hem profil oluşturucu DLL 'SI hem de profil oluşturucu Kullanıcı arabirimlerinizin erişebileceği, ancak başka bir Windows Mağazası uygulama paketinin erişebileceği bir konumdur (Bu nedenle, diğer Windows Mağazası uygulama paketlerinden oturum açmak için tüm bilgileri koruma).</span><span class="sxs-lookup"><span data-stu-id="1f5e9-267">For example, the Temporary Folder path is a location that both your Profiler DLL and Profiler UI can access, but no other Windows Store app package can access (thus shielding any information you log from other Windows Store app packages).</span></span>

<span data-ttu-id="1f5e9-268">Profil Oluşturucu UI ve Profiler DLL 'niz bu yolu bağımsız olarak belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-268">Both your Profiler UI and Profiler DLL can determine this path independently.</span></span> <span data-ttu-id="1f5e9-269">Profil Oluşturucu kullanıcı arabiriminize, geçerli kullanıcı için yüklenen tüm paketler arasında yineleme yapıldığında (daha önce örnek koda bakın), geçici klasör yolunun bu kod parçacığına benzer kodla türetilebilecek `PackageId` sınıfına erişimi alır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-269">Your Profiler UI, when it iterates through all packages installed for the current user (see the sample code earlier), gets access to the `PackageId` class, from which the Temporary Folder path can be derived with code similar to this snippet.</span></span> <span data-ttu-id="1f5e9-270">(Her zaman olduğu gibi, kısaltma için hata denetimi atlanır.)</span><span class="sxs-lookup"><span data-stu-id="1f5e9-270">(As always, error checking is omitted for brevity.)</span></span>

```csharp
// C# code for the Profiler UI.
ApplicationData appData =
    ApplicationDataManager.CreateForPackageFamily(
        packageId.FamilyName);

tempDir = appData.TemporaryFolder.Path;
```

<span data-ttu-id="1f5e9-271">Bu arada, profil oluşturucu DLL 'niz temelde aynı şeyi yapabilir, ancak [ApplicationData. Current](xref:Windows.Storage.ApplicationData.Current%2A) özelliğini kullanarak <xref:Windows.Storage.ApplicationData> sınıfına daha kolay bir şekilde erişebilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-271">Meanwhile, your Profiler DLL can do basically the same thing, though it can more easily get to the <xref:Windows.Storage.ApplicationData> class by using the [ApplicationData.Current](xref:Windows.Storage.ApplicationData.Current%2A) property.</span></span>

<span data-ttu-id="1f5e9-272">**Olaylar üzerinden iletişim kurma**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-272">**Communicating via events**</span></span>

<span data-ttu-id="1f5e9-273">Profil Oluşturucu UI ve profil oluşturucu DLL arasında basit sinyal semantiğini istiyorsanız, Windows Mağazası uygulamalarının içindeki olayları ve masaüstü uygulamalarını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-273">If you want simple signaling semantics between your Profiler UI and Profiler DLL, you can use events inside Windows Store apps as well as desktop apps.</span></span>

<span data-ttu-id="1f5e9-274">Profil oluşturucu DLL 'nizden, istediğiniz adla adlandırılmış bir olay oluşturmak için [Createeventex](/windows/desktop/api/synchapi/nf-synchapi-createeventexa) işlevini çağırmanız yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-274">From your Profiler DLL, you can simply call the [CreateEventEx](/windows/desktop/api/synchapi/nf-synchapi-createeventexa) function to create a named event with any name you like.</span></span> <span data-ttu-id="1f5e9-275">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-275">For example:</span></span>

```cpp
// Profiler DLL in Windows Store app (C++).
CreateEventEx(
    NULL,  // Not inherited
    "MyNamedEvent"
    CREATE_EVENT_MANUAL_RESET, /* explicit ResetEvent() required; leave initial state unsignaled */
    EVENT_ALL_ACCESS);
```

<span data-ttu-id="1f5e9-276">Profil Oluşturucu kullanıcı arabiriminizdeki bu adlandırılmış olayı Windows Mağazası uygulamasının ad alanı altında bulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-276">Your Profiler UI then needs to find that named event under the Windows Store app’s namespace.</span></span> <span data-ttu-id="1f5e9-277">Örneğin, Profil Oluşturucu kullanıcı arabiriminizi [Createeventex](/windows/desktop/api/synchapi/nf-synchapi-createeventexa)ile çağırabilir ve olay adını şöyle belirterek</span><span class="sxs-lookup"><span data-stu-id="1f5e9-277">For example, your Profiler UI could call [CreateEventEx](/windows/desktop/api/synchapi/nf-synchapi-createeventexa), specifying the event name as</span></span>

`AppContainerNamedObjects\<acSid>\MyNamedEvent`

<span data-ttu-id="1f5e9-278">`<acSid>`, Windows Mağazası uygulamasının AppContainer SID 'sidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-278">`<acSid>` is the Windows Store app’s AppContainer SID.</span></span> <span data-ttu-id="1f5e9-279">Bu konunun önceki bir bölümünde, geçerli kullanıcı için yüklenmiş paketlerin nasıl yineleneceği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-279">An earlier section of this topic showed how to iterate over the packages installed for the current user.</span></span> <span data-ttu-id="1f5e9-280">Bu örnek koddan PackageID ' yi elde edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-280">From that sample code, you can obtain the packageId.</span></span> <span data-ttu-id="1f5e9-281">PackageID 'den, `<acSid>` ' ı aşağıdakine benzer kodla elde edebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="1f5e9-281">And from the packageId, you can obtain the `<acSid>` with code similar to the following:</span></span>

```csharp
IntPtr acPSID;
DeriveAppContainerSidFromAppContainerName(packageId.FamilyName, out acPSID);

string acSid;
ConvertSidToStringSid(acPSID, out acSid);

string acDir;
GetAppContainerFolderPath(acSid, out acDir);
```

### <a name="no-shutdown-notifications"></a><span data-ttu-id="1f5e9-282">Kapanmaya yönelik bildirim yok</span><span class="sxs-lookup"><span data-stu-id="1f5e9-282">No shutdown notifications</span></span>

<span data-ttu-id="1f5e9-283">Bir Windows Mağazası uygulamasında çalışırken, profil oluşturucu DLL 'niz, Windows Mağazası uygulamasının çıkış yaptığını Profiler DLL 'nize bildirmek için [ICorProfilerCallback:: kapatılmasını](icorprofilercallback-shutdown-method.md) veya hatta [DllMain](/windows/desktop/Dlls/dllmain) (`DLL_PROCESS_DETACH`ile) ' i kullanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-283">When running inside a Windows Store app, your Profiler DLL should not rely on either [ICorProfilerCallback::Shutdown](icorprofilercallback-shutdown-method.md) or even [DllMain](/windows/desktop/Dlls/dllmain) (with `DLL_PROCESS_DETACH`) being called to notify your Profiler DLL that the Windows Store app is exiting.</span></span> <span data-ttu-id="1f5e9-284">Aslında, bunların hiçbir şekilde çağrılmayacağını beklemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-284">In fact, you should expect they will never be called.</span></span> <span data-ttu-id="1f5e9-285">Tarihsel olarak, birçok profil oluşturucu DLL bu bildirimleri diske boşaltma, dosyaları kapatma, Profil Oluşturucu kullanıcı arabirimine geri bildirim gönderme gibi uygun şekilde kullandı. Ancak artık profil oluşturucu DLL 'nizin biraz farklı şekilde organize olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-285">Historically, many Profiler DLLs have used those notifications as convenient places to flush caches to disk, close files, send notifications back to the Profiler UI, etc. But now your Profiler DLL needs to be organized a little differently.</span></span>

<span data-ttu-id="1f5e9-286">Profil oluşturucu DLL 'niz, devam eden bilgileri günlüğe kaydetmeye devam etmelidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-286">Your Profiler DLL should be logging information as it goes.</span></span> <span data-ttu-id="1f5e9-287">Performans nedenleriyle, toplu iş bilgilerini bellekte toplu olarak, bir eşiğin geçmiş olduğu sürece diskte da diske boşaltmayı tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-287">For performance reasons, you may want to batch information in memory and flush it to disk as the batch grows in size past some threshold.</span></span> <span data-ttu-id="1f5e9-288">Ancak diske henüz boşaltılmayan bilgilerin kaybolameyeceğini varsayın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-288">But assume that any information not yet flushed to disk can be lost.</span></span> <span data-ttu-id="1f5e9-289">Bu, eşiği daha seyrek olarak seçmek ve Profiler 'ın Profiler 'ın, profil oluşturucu DLL tarafından yazılmış tamamlanmamış bilgilerle başa çıkmak için sağlamlaştırması gerektiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-289">This means you’ll want to pick your threshold wisely, and that your Profiler UI needs to be hardened to deal with incomplete information written by the Profiler DLL.</span></span>

## <a name="windows-runtime-metadata-files"></a><span data-ttu-id="1f5e9-290">Windows Çalışma Zamanı meta veri dosyaları</span><span class="sxs-lookup"><span data-stu-id="1f5e9-290">Windows Runtime metadata files</span></span>

<span data-ttu-id="1f5e9-291">Windows Çalışma Zamanı meta veri (WinMD) dosyalarının ne olduğu hakkında ayrıntılı bilgi almak için bu belgenin kapsamı dışındadır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-291">It is outside the scope of this document to go into detail on what Windows Runtime metadata (WinMD) files are.</span></span> <span data-ttu-id="1f5e9-292">Bu bölüm CLR profil oluşturma API 'sinin, WinMD dosyaları Windows Mağazası uygulaması tarafından, profil oluşturucu DLL 'nizin analiz edilirken yeniden nasıl davranması ile sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-292">This section is limited to how the CLR Profiling API reacts when WinMD files are loaded by the Windows Store app your Profiler DLL is analyzing.</span></span>

### <a name="managed-and-non-managed-winmds"></a><span data-ttu-id="1f5e9-293">Yönetilen ve yönetilmeyen Wınmds</span><span class="sxs-lookup"><span data-stu-id="1f5e9-293">Managed and non-managed WinMDs</span></span>

<span data-ttu-id="1f5e9-294">Bir geliştirici yeni bir Windows Çalışma Zamanı bileşen projesi oluşturmak için Visual Studio kullanıyorsa, bu projenin bir derlemesi, geliştirici tarafından yazılan meta verileri (sınıfların tür açıklamaları, arabirimler vb.) açıklayan bir WinMD dosyası üretir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-294">If a developer uses Visual Studio to create a new Windows Runtime Component project, a build of that project produces a WinMD file that describes the metadata (the type descriptions of classes, interfaces, etc.) authored by the developer.</span></span> <span data-ttu-id="1f5e9-295">Bu proje, C# veya vb dilinde yazılmış bir yönetilen dil projem Ise aynı winmd dosyası bu türlerin uygulamasını da içerir (yani, geliştiricinin kaynak kodundan derlenen tüm Il 'yi içerir).</span><span class="sxs-lookup"><span data-stu-id="1f5e9-295">If this project is a managed language project written in C# or VB, that same WinMD file also contains the implementation of those types (meaning that it contains all the IL compiled from the developer’s source code).</span></span> <span data-ttu-id="1f5e9-296">Bu tür dosyalar yönetilen WinMD dosyaları olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-296">Such files are known as managed WinMD files.</span></span> <span data-ttu-id="1f5e9-297">Windows Çalışma Zamanı meta verileri ve temel alınan uygulamayı içerdikleri her ikisi de ilginç hale getiriyoruz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-297">They're interesting in that they contain both Windows Runtime metadata and the underlying implementation.</span></span>

<span data-ttu-id="1f5e9-298">Buna karşılık, bir geliştirici için C++Windows çalışma zamanı bileşen projesi oluşturursa, söz konusu projenin derlemesi yalnızca meta verileri Içeren bir WinMD dosyası üretir ve uygulama ayrı bır yerel dll 'de derlenir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-298">In contrast, if a developer creates a Windows Runtime Component project for C++, a build of that project produces a WinMD file that contains only metadata, and the implementation is compiled into a separate native DLL.</span></span> <span data-ttu-id="1f5e9-299">Benzer şekilde, Windows SDK teslim eden WinMD dosyaları, Windows 'un bir parçası olarak gelen ayrı yerel dll 'Lere derlenen uygulamayla yalnızca meta veriler içerir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-299">Similarly, the WinMD files that ship in the Windows SDK contain only metadata, with the implementation compiled into separate native DLLs that ship as part of Windows.</span></span>

<span data-ttu-id="1f5e9-300">Aşağıdaki bilgiler, meta veri ve uygulama içeren hem yönetilen WinMDs için hem de yalnızca meta verileri içeren yönetilmeyen Wınmds için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-300">The information below applies to both managed WinMDs, which contain metadata and implementation, and to non-managed WinMDs, which contain only metadata.</span></span>

### <a name="winmd-files-look-like-clr-modules"></a><span data-ttu-id="1f5e9-301">WinMD dosyaları CLR modülleri gibi görünüyor</span><span class="sxs-lookup"><span data-stu-id="1f5e9-301">WinMD files look like CLR modules</span></span>

<span data-ttu-id="1f5e9-302">CLR 'nin düşünüldüğünde, tüm WinMD dosyaları modüllerdir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-302">As far as the CLR is concerned, all WinMD files are modules.</span></span> <span data-ttu-id="1f5e9-303">Bu nedenle, CLR profil oluşturma API 'si, WinMD dosyaları yüklenirken profil oluşturucu DLL 'nize ve moduleIds oldukları diğer yönetilen modüllerle aynı şekilde bildirir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-303">The CLR Profiling API therefore tells your Profiler DLL when WinMD files load and what their ModuleIDs are, in the same way as for other managed modules.</span></span>

<span data-ttu-id="1f5e9-304">Profil oluşturucu DLL 'niz, [ICorProfilerInfo3:: GetModuleInfo2](icorprofilerinfo3-getmoduleinfo2-method.md) yöntemini çağırarak ve [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) bayrağı için `pdwModuleFlags` output parametresini inceleyerek winmd dosyalarını diğer modüllerden ayırt edebilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-304">Your Profiler DLL can distinguish WinMD files from other modules by calling the [ICorProfilerInfo3::GetModuleInfo2](icorprofilerinfo3-getmoduleinfo2-method.md) method and inspecting the `pdwModuleFlags` output parameter for the [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) flag.</span></span> <span data-ttu-id="1f5e9-305">(Ve yalnızca ModuleID bir WinMD temsil ediyorsa ayarlanır.)</span><span class="sxs-lookup"><span data-stu-id="1f5e9-305">(It’s set if and only if the ModuleID represents a WinMD.)</span></span>

### <a name="reading-metadata-from-winmds"></a><span data-ttu-id="1f5e9-306">Wınmds 'den meta veriler okunuyor</span><span class="sxs-lookup"><span data-stu-id="1f5e9-306">Reading metadata from WinMDs</span></span>

<span data-ttu-id="1f5e9-307">Normal modüller gibi WinMD dosyaları, [meta veri API 'leri](../../../../docs/framework/unmanaged-api/metadata/index.md)aracılığıyla okunabilecek meta veriler içerir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-307">WinMD files, like regular modules, contain metadata that can be read via the [Metadata APIs](../../../../docs/framework/unmanaged-api/metadata/index.md).</span></span> <span data-ttu-id="1f5e9-308">Ancak, CLR dosyalarını okurken, yönetilen kodda programlayan ve WinMD dosyasını kullanan geliştiricilerin daha doğal bir programlama deneyimine sahip olması için CLR dosyalarını okurken Windows Çalışma Zamanı türleri .NET Framework türlerine eşler.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-308">However, the CLR maps Windows Runtime types to .NET Framework types when it reads WinMD files so that developers who program in managed code and consume the WinMD file can have a more natural programming experience.</span></span> <span data-ttu-id="1f5e9-309">Bu eşlemelerin bazı örnekleri için bkz. [Windows Mağazası uygulamaları için .NET Framework desteği ve Windows çalışma zamanı](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="1f5e9-309">For some examples of these mappings, see [.NET Framework Support for Windows Store Apps and Windows Runtime](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md).</span></span>

<span data-ttu-id="1f5e9-310">Bu nedenle, Profil oluşturucunuz, meta veri API 'Lerini kullandığında hangi görünümde alınır: ham Windows Çalışma Zamanı görünümü veya eşlenmiş .NET Framework görünümü?</span><span class="sxs-lookup"><span data-stu-id="1f5e9-310">So which view will your profiler get when it uses the metadata APIs: the raw Windows Runtime view, or the mapped .NET Framework view?</span></span>  <span data-ttu-id="1f5e9-311">Yanıt: size ait.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-311">The answer: it’s up to you.</span></span>

<span data-ttu-id="1f5e9-312">Bir WinMD üzerinde [ICorProfilerInfo:: GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) yöntemini [çağırdığınızda, bu](../../../../docs/framework/unmanaged-api/metadata/imetadataimport-interface.md)eşlemeyi kapatmak için `dwOpenFlags` parametresinde [ofnotransform](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) ' ı ayarlamayı tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-312">When you call the [ICorProfilerInfo::GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) method on a WinMD to obtain a metadata interface, such as [IMetaDataImport](../../../../docs/framework/unmanaged-api/metadata/imetadataimport-interface.md),  you can choose to set [ofNoTransform](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) in the `dwOpenFlags` parameter to turn off this mapping.</span></span> <span data-ttu-id="1f5e9-313">Aksi takdirde, varsayılan olarak eşleme etkin olur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-313">Otherwise, by default, the mapping will be enabled.</span></span> <span data-ttu-id="1f5e9-314">Genellikle, profil oluşturucu DLL 'nin WinMD meta verilerinden elde ettiği dizelerin (örneğin, türlerin adları), profil oluşturucu kullanıcısına tanıdık ve doğal olarak görünmesi için bir profil oluşturucu eşlemeyi etkin tutacaktır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-314">Typically, a profiler will keep the mapping enabled, so that the strings that the Profiler DLL obtains from the WinMD metadata (for example, names of types) will look familiar and natural to the profiler user.</span></span>

### <a name="modifying-metadata-from-winmds"></a><span data-ttu-id="1f5e9-315">Wınmds 'den meta verileri değiştirme</span><span class="sxs-lookup"><span data-stu-id="1f5e9-315">Modifying metadata from WinMDs</span></span>

<span data-ttu-id="1f5e9-316">WinMDs 'de meta verileri değiştirme desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-316">Modifying metadata in WinMDs is not supported.</span></span> <span data-ttu-id="1f5e9-317">Bir WinMD dosyası için [ICorProfilerInfo:: GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) metodunu çağırıp `dwOpenFlags` parametresinde [ofWrite](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) belirtirseniz veya [ımetadatayay](../../../../docs/framework/unmanaged-api/metadata/imetadataemit-interface.md)gibi yazılabilir bir meta veri arabirimine sorun yaparsanız [GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-317">If you call the [ICorProfilerInfo::GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) method for a WinMD file and specify [ofWrite](../../../../docs/framework/unmanaged-api/metadata/coropenflags-enumeration.md) in the `dwOpenFlags` parameter or ask for a writeable metadata interface such as [IMetaDataEmit](../../../../docs/framework/unmanaged-api/metadata/imetadataemit-interface.md), [GetModuleMetaData](icorprofilerinfo-getmodulemetadata-method.md) will fail.</span></span> <span data-ttu-id="1f5e9-318">Bu, kendi araçlarını destekleyecek meta verileri (örneğin, AssemblyRefs veya yeni yöntemler eklemek için) değiştirmesi gereken, Il yeniden yazma profil oluşturucular önemli bir öneme sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-318">This is of particular importance to IL-rewriting profilers, which need to modify metadata to support their instrumentation (for example, to add AssemblyRefs or new methods).</span></span> <span data-ttu-id="1f5e9-319">Bu nedenle, [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) for First (önceki bölümde anlatıldığı gibi) öğesini denetlemeniz ve bu tür modüller üzerinde yazılabilir meta veri arabirimleri isteyip istemediğinizi sormaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-319">So you should check for [COR_PRF_MODULE_WINDOWS_RUNTIME](cor-prf-module-flags-enumeration.md) first (as discussed in the previous section) and refrain from asking for writeable metadata interfaces on such modules.</span></span>

### <a name="resolving-assembly-references-with-winmds"></a><span data-ttu-id="1f5e9-320">WinMDs ile derleme başvurularını çözme</span><span class="sxs-lookup"><span data-stu-id="1f5e9-320">Resolving assembly references with WinMDs</span></span>

<span data-ttu-id="1f5e9-321">İzleme veya tür denetimine yardımcı olmak için meta veri başvurularını el ile çözmek için birçok profil oluşturucular gerekir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-321">Many profilers need to resolve metadata references manually to aid with instrumentation or type inspection.</span></span> <span data-ttu-id="1f5e9-322">Bu tür profil oluşturucular, CLR 'nin Wınmds 'ye işaret eden derleme başvurularını nasıl çözümlediği farkında olmalıdır, çünkü bu başvurular standart derleme başvurularından tamamen farklı bir şekilde çözümlenir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-322">Such profilers need to be aware of how the CLR resolves assembly references that point to WinMDs, because those references are resolved in a completely different way than standard assembly references.</span></span>

## <a name="memory-profilers"></a><span data-ttu-id="1f5e9-323">Bellek Profil oluşturucular</span><span class="sxs-lookup"><span data-stu-id="1f5e9-323">Memory profilers</span></span>

<span data-ttu-id="1f5e9-324">Çöp toplayıcı ve yönetilen yığın, bir Windows Mağazası uygulamasında ve masaüstü uygulamasında temel olarak farklı değildir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-324">The garbage collector and managed heap are not fundamentally different in a Windows Store app and a desktop app.</span></span> <span data-ttu-id="1f5e9-325">Ancak, profil oluşturucu yazarlarının farkında olması gereken bazı hafif farklılıklar vardır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-325">However, there are some subtle differences that profiler authors need to be aware of.</span></span>

### <a name="forcegc-creates-a-managed-thread"></a><span data-ttu-id="1f5e9-326">ForceGC yönetilen bir iş parçacığı oluşturur</span><span class="sxs-lookup"><span data-stu-id="1f5e9-326">ForceGC creates a managed thread</span></span>

<span data-ttu-id="1f5e9-327">Bellek profili oluşturma sırasında, profil oluşturucu DLL 'niz genellikle [ForceGC yöntemi](icorprofilerinfo-forcegc-method.md) yönteminin çağrılabileceği ayrı bir iş parçacığı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-327">When doing memory profiling, your Profiler DLL typically creates a separate thread from which to call the [ForceGC Method](icorprofilerinfo-forcegc-method.md) method.</span></span> <span data-ttu-id="1f5e9-328">Bu yeni bir şey değildir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-328">This is nothing new.</span></span> <span data-ttu-id="1f5e9-329">Ancak, bir Windows Mağazası uygulamasının içinde çöp toplama işlemi yapma işleminin iş parçacığını yönetilen bir iş parçacığına dönüştürebileceği (örneğin, bu iş parçacığı için bir profil oluşturma API 'SI tehdit oluşturulacak).</span><span class="sxs-lookup"><span data-stu-id="1f5e9-329">But what might be surprising is that the act of doing a garbage collection inside a Windows Store app may transform your thread into a managed thread (for example, a Profiling API ThreadID will be created for that thread).</span></span>

<span data-ttu-id="1f5e9-330">Bunun sonuçlarını anlamak için, CLR profil oluşturma API 'SI tarafından tanımlanan, zaman uyumlu ve zaman uyumsuz çağrılar arasındaki farklılıkları anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-330">To understand the consequences of this, it’s important to understand the differences between synchronous and asynchronous calls as defined by the CLR Profiling API.</span></span> <span data-ttu-id="1f5e9-331">Bu, Windows Mağazası uygulamalarındaki zaman uyumsuz çağrılar kavramından çok farklı olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-331">Note that this is very different from the concept of asynchronous calls in Windows Store apps.</span></span> <span data-ttu-id="1f5e9-332">Daha fazla bilgi için [corprof_e_unsupported_call_sequence sahip olduğumuz](https://blogs.msdn.microsoft.com/davbr/2008/12/23/why-we-have-corprof_e_unsupported_call_sequence/) blog gönderisine bakın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-332">See the blog post [Why we have CORPROF_E_UNSUPPORTED_CALL_SEQUENCE](https://blogs.msdn.microsoft.com/davbr/2008/12/23/why-we-have-corprof_e_unsupported_call_sequence/) for more information.</span></span>

<span data-ttu-id="1f5e9-333">İlgili nokta, Profil oluşturucunuz tarafından oluşturulan iş parçacıklarında yapılan çağrıların, profil oluşturucu DLL 'inin [ICorProfilerCallback](icorprofilercallback-interface.md) metotlarından birinin bir uygulamasının dışından yapılsa bile her zaman zaman uyumlu olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-333">The relevant point is that calls made on threads created by your profiler are always considered synchronous, even if those calls are made from outside an implementation of one of your Profiler DLL’s [ICorProfilerCallback](icorprofilercallback-interface.md) methods.</span></span> <span data-ttu-id="1f5e9-334">En azından, bu durum olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-334">At least, that used to be the case.</span></span> <span data-ttu-id="1f5e9-335">[ForceGC yöntemine](icorprofilerinfo-forcegc-method.md)yapılan ÇAĞRıLARıNıZ nedeniyle CLR 'nin Profiler iş parçacığını yönetilen bir iş parçacığına kapatmış olduğuna göre, bu iş parçacığı artık profil oluşturucunun iş parçacığını kabul edilmiyor.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-335">Now that the CLR has turned your profiler’s thread into a managed thread because of your call to [ForceGC Method](icorprofilerinfo-forcegc-method.md), that thread is no longer considered your profiler’s thread.</span></span> <span data-ttu-id="1f5e9-336">Bu nedenle, CLR, bu iş parçacığı için zaman uyumlu olarak niteleyen nelerin daha sıkı bir tanımını uygular — yani bir çağrı, zaman uyumlu olarak nitelendirmek için profil oluşturucu DLL 'inin [ICorProfilerCallback](icorprofilercallback-interface.md) yöntemlerinden birinin içinden kaynaklanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-336">As such, the CLR enforces a more stringent definition of what qualifies as synchronous for that thread—namely that a call must originate from inside one of your Profiler DLL’s [ICorProfilerCallback](icorprofilercallback-interface.md) methods to qualify as synchronous.</span></span>

<span data-ttu-id="1f5e9-337">Bu uygulamada ne anlama geliyor?</span><span class="sxs-lookup"><span data-stu-id="1f5e9-337">What does this mean in practice?</span></span> <span data-ttu-id="1f5e9-338">Çoğu [ICorProfilerInfo](icorprofilerinfo-interface.md) yöntemlerinin yalnızca zaman uyumlu olarak çağrılması güvenlidir ve aksi halde, daha sonra başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-338">Most [ICorProfilerInfo](icorprofilerinfo-interface.md) methods are only safe to be called synchronously, and will immediately fail otherwise.</span></span> <span data-ttu-id="1f5e9-339">Profil oluşturucu DLL 'niz, genellikle profil oluşturucu tarafından oluşturulan iş parçacıklarında (örneğin, [RequestProfilerDetach](icorprofilerinfo3-requestprofilerdetach-method.md), [RequestReJIT](icorprofilerinfo4-requestrejit-method.md)veya [requestdönmesi](icorprofilerinfo4-requestrevert-method.md)Için) gerçekleştirilen diğer çağrılar için [ForceGC yöntemi](icorprofilerinfo-forcegc-method.md) iş parçacığını yeniden kullanıyorsa, sorun yaşayacağız .</span><span class="sxs-lookup"><span data-stu-id="1f5e9-339">So if your Profiler DLL reuses your [ForceGC Method](icorprofilerinfo-forcegc-method.md) thread for other calls typically made on profiler-created threads (for example, to [RequestProfilerDetach](icorprofilerinfo3-requestprofilerdetach-method.md), [RequestReJIT](icorprofilerinfo4-requestrejit-method.md), or [RequestRevert](icorprofilerinfo4-requestrevert-method.md)), you’re going to have trouble.</span></span> <span data-ttu-id="1f5e9-340">[DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) gibi zaman uyumsuz güvenli bir işlev, yönetilen iş parçacıklarında çağrıldığında özel kurallara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-340">Even an asynchronous-safe function such as [DoStackSnapshot](icorprofilerinfo2-dostacksnapshot-method.md) has special rules when called from managed threads.</span></span> <span data-ttu-id="1f5e9-341">(Daha fazla bilgi için bkz. Profiler Stack for the blog gönderisi [: temel bilgiler ve](https://blogs.msdn.microsoft.com/davbr/2005/10/06/profiler-stack-walking-basics-and-beyond/) daha fazlası.)</span><span class="sxs-lookup"><span data-stu-id="1f5e9-341">(See the blog post [Profiler stack walking: Basics and beyond](https://blogs.msdn.microsoft.com/davbr/2005/10/06/profiler-stack-walking-basics-and-beyond/) for more information.)</span></span>

<span data-ttu-id="1f5e9-342">Bu nedenle, profil oluşturucu DLL 'nizin [ForceGC yöntemini](icorprofilerinfo-forcegc-method.md) çağırmak için oluşturduğu tüm iş parçacıklarının *yalnızca* GCS 'yi TETIKLEMENIN ve sonra GC geri çağırmaları için kullanılması önerilir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-342">Therefore, we recommend that any thread your Profiler DLL creates to call [ForceGC Method](icorprofilerinfo-forcegc-method.md) should be used *only* for the purpose of triggering GCs and then responding to the GC callbacks.</span></span> <span data-ttu-id="1f5e9-343">Yığın örnekleme veya ayırma gibi diğer görevleri gerçekleştirmek için profil oluşturma API 'sine çağrı gerçekleştirmemelidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-343">It should not call into the Profiling API to perform other tasks like stack sampling or detaching.</span></span>

### <a name="conditionalweaktablereferences"></a><span data-ttu-id="1f5e9-344">ConditionalWeakTableReferences</span><span class="sxs-lookup"><span data-stu-id="1f5e9-344">ConditionalWeakTableReferences</span></span>

<span data-ttu-id="1f5e9-345">.NET Framework 4,5 ' den başlayarak, profil oluşturucunun *bağımlı tanıtıcılarla*ilgili daha fazla bilgi veren yenı bir GC geri çağırması olan [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md)vardır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-345">Starting with the .NET Framework 4.5, there is a new GC callback, [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md), which gives the profiler more complete information about *dependent handles*.</span></span> <span data-ttu-id="1f5e9-346">Bu tutamaçlar, GC yaşam süresi yönetimi amacıyla bir kaynak nesnesinden bir hedef nesneye bir başvuru ekler.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-346">These handles effectively add a reference from a source object to a target object for the purpose of GC lifetime management.</span></span> <span data-ttu-id="1f5e9-347">Bağımlı tutamaçlar hiçbir şey değildir ve yönetilen kodda çalışan geliştiriciler, Windows 8 ' den ve .NET Framework 4,5 ' den önce bile <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602?displayProperty=nameWithType> sınıfını kullanarak kendi bağımlı tutamaçlarını oluşturamayacak.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-347">Dependent handles are nothing new, and developers who program in managed code have been able to create their own dependent handles by using the <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602?displayProperty=nameWithType> class even before Windows 8 and the .NET Framework 4.5.</span></span>

<span data-ttu-id="1f5e9-348">Ancak, yönetilen XAML Windows Mağazası uygulamaları artık bağımlı tanıtıcıların yoğun bir şekilde kullanılmasını kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-348">However, managed XAML Windows Store apps now make heavy use of dependent handles.</span></span> <span data-ttu-id="1f5e9-349">Özellikle, CLR, yönetilen nesneler ve yönetilmeyen Windows Çalışma Zamanı nesneleri arasındaki başvuru döngülerini yönetmeye yardımcı olmak için bunları kullanır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-349">In particular, the CLR uses them to aid with managing reference cycles between managed objects and unmanaged Windows Runtime objects.</span></span> <span data-ttu-id="1f5e9-350">Bu, artık bellek profil oluşturucular ' nin, yığın grafiğindeki diğer kenarlarla birlikte görselleştirilmesi için bu bağımlı tutamaçların bilgilendirilmesi için her zamankinden daha önemli olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-350">This means that it’s more important now than ever for memory profilers to be informed of these dependent handles so that they can be visualized along with the rest of the edges in the heap graph.</span></span> <span data-ttu-id="1f5e9-351">Profiler DLL 'niz, yığın grafiğinin tamamen görünümünü oluşturmak için [RootReferences2](icorprofilercallback2-rootreferences2-method.md), [ObjectReferences](icorprofilercallback-objectreferences-method.md)ve [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md) öğelerini birlikte kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-351">Your Profiler DLL should use [RootReferences2](icorprofilercallback2-rootreferences2-method.md), [ObjectReferences](icorprofilercallback-objectreferences-method.md), and [ConditionalWeakTableElementReferences](icorprofilercallback5-conditionalweaktableelementreferences-method.md) together to form a complete view of the heap graph.</span></span>

## <a name="conclusion"></a><span data-ttu-id="1f5e9-352">Sonuç</span><span class="sxs-lookup"><span data-stu-id="1f5e9-352">Conclusion</span></span>

<span data-ttu-id="1f5e9-353">Windows Mağazası uygulamaları içinde çalışan yönetilen kodu çözümlemek için CLR profil oluşturma API 'sini kullanmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-353">It is possible to use the CLR Profiling API to analyze managed code running inside Windows Store apps.</span></span> <span data-ttu-id="1f5e9-354">Aslında, geliştirmekte olduğunuz bir profil oluşturucuyu alabilir ve Windows Mağazası uygulamalarını hedefleyecek şekilde belirli değişiklikler yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-354">In fact, you can take an existing profiler that you’re developing and make some specific changes so that it can target Windows Store apps.</span></span> <span data-ttu-id="1f5e9-355">Profiler Kullanıcı arabiriminize, Windows Mağazası uygulamasını hata ayıklama modunda etkinleştirmek için yeni API 'Ler kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-355">Your Profiler UI should use the new APIs for activating the Windows Store app in debugging mode.</span></span> <span data-ttu-id="1f5e9-356">Profil oluşturucu DLL 'nizin yalnızca Windows Mağazası uygulamaları için geçerli olan API 'Leri tükettiğini doğrulayın.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-356">Make sure that your Profiler DLL consumes only those APIs applicable for Windows Store apps.</span></span> <span data-ttu-id="1f5e9-357">Profil oluşturucu DLL ve Profil Oluşturucu kullanıcı arabiriminizin arasındaki iletişim mekanizması, Windows Mağazası uygulaması API 'SI kısıtlamalarına göz önünde bulundurularak ve Windows Mağazası uygulamaları için yerinde kısıtlı izinlerin farkında olmadan yazılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-357">The communication mechanism between your Profiler DLL and Profiler UI should be written with the Windows Store app API restrictions in mind and with awareness of the restricted permissions in place for Windows Store apps.</span></span> <span data-ttu-id="1f5e9-358">Profil oluşturucu DLL 'niz, CLR 'nin Wınmds 'nin nasıl davrandığını ve çöp toplayıcının yönetilen iş parçacıklarıyla karşılaştırıldığında nasıl farklı olduğunu bilmelidir.</span><span class="sxs-lookup"><span data-stu-id="1f5e9-358">Your Profiler DLL should be aware of how the CLR treats WinMDs, and how the Garbage Collector’s behavior is different with respect to managed threads.</span></span>

## <a name="resources"></a><span data-ttu-id="1f5e9-359">Kaynaklar</span><span class="sxs-lookup"><span data-stu-id="1f5e9-359">Resources</span></span>

<span data-ttu-id="1f5e9-360">**Ortak dil çalışma zamanı**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-360">**The Common Language Runtime**</span></span>

- [<span data-ttu-id="1f5e9-361">Profil oluşturma (yönetilmeyen API Başvurusu)</span><span class="sxs-lookup"><span data-stu-id="1f5e9-361">Profiling (Unmanaged API Reference)</span></span>](index.md)

- [<span data-ttu-id="1f5e9-362">Meta veriler (yönetilmeyen API Başvurusu)</span><span class="sxs-lookup"><span data-stu-id="1f5e9-362">Metadata (Unmanaged API Reference)</span></span>](../metadata/index.md)

<span data-ttu-id="1f5e9-363">**CLR 'nin Windows Çalışma Zamanı etkileşimi**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-363">**The CLR's interaction with the Windows Runtime**</span></span>

- [<span data-ttu-id="1f5e9-364">Windows Mağazası Uygulamaları ve Windows Çalışma Zamanı için .NET Framework Desteği</span><span class="sxs-lookup"><span data-stu-id="1f5e9-364">.NET Framework Support for Windows Store Apps and Windows Runtime</span></span>](../../../standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)

<span data-ttu-id="1f5e9-365">**Windows Mağazası uygulamaları**</span><span class="sxs-lookup"><span data-stu-id="1f5e9-365">**Windows Store apps**</span></span>

- [<span data-ttu-id="1f5e9-366">Dosya erişimi ve izinleri (Windows Çalışma Zamanı uygulamalar</span><span class="sxs-lookup"><span data-stu-id="1f5e9-366">File access and permissions (Windows Runtime apps</span></span>](https://docs.microsoft.com/previous-versions/windows/apps/hh967755%28v=win.10%29)

- [<span data-ttu-id="1f5e9-367">Geliştirici Lisansı alın</span><span class="sxs-lookup"><span data-stu-id="1f5e9-367">Get a developer license</span></span>](https://docs.microsoft.com/previous-versions/windows/apps/hh974578%28v=win.10%29)

- [<span data-ttu-id="1f5e9-368">Ipackagedebugsettings arabirimi</span><span class="sxs-lookup"><span data-stu-id="1f5e9-368">IPackageDebugSettings Interface</span></span>](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ipackagedebugsettings)
