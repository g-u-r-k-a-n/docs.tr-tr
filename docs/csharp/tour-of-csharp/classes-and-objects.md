---
title: İçindeki C# sınıflar ve nesneler- C# dilin turu
description: Yeni C#misiniz? Sınıflar, nesneler ve devralmayla bu genel bakışı okuyun
ms.date: 02/27/2020
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: c178e11b5667905f75538555c8a309e2fdb4a9ef
ms.sourcegitcommit: 00aa62e2f469c2272a457b04e66b4cc3c97a800b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/28/2020
ms.locfileid: "78159188"
---
# <a name="classes-and-objects"></a><span data-ttu-id="5d365-104">Sınıflar ve nesneler</span><span class="sxs-lookup"><span data-stu-id="5d365-104">Classes and objects</span></span>

<span data-ttu-id="5d365-105">*Sınıflar* , türlerin en temel C#larıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-105">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="5d365-106">Bir sınıf, durumu (alanları) ve eylemleri (Yöntemler ve diğer işlev üyelerini) tek bir birimde birleştiren bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-106">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="5d365-107">Sınıf, *nesne*olarak da bilinen, sınıfının dinamik olarak oluşturulan *örnekleri* için bir tanım sağlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-107">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="5d365-108">Sınıflar, *Devralma* ve çok *biçimlilik*desteği, *türetilmiş sınıfların* *temel sınıfları*genişletebileceği ve özelleştirilebilecek mekanizmalar.</span><span class="sxs-lookup"><span data-stu-id="5d365-108">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="5d365-109">Yeni sınıflar sınıf bildirimleri kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5d365-109">New classes are created using class declarations.</span></span> <span data-ttu-id="5d365-110">Sınıf bildirimi, sınıfın özniteliklerini ve değiştiricilerini, sınıfın adını, Taban sınıfını (belirtilmişse) ve sınıf tarafından uygulanan arabirimleri belirten bir üstbilgiyle başlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-110">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="5d365-111">Üst bilgi, `{` ve `}`sınırlayıcılarının yazıldığı üye bildirimlerinin bir listesinden oluşan sınıf gövdesinden gelir.</span><span class="sxs-lookup"><span data-stu-id="5d365-111">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="5d365-112">Aşağıdaki kod, `Point`adlı basit bir sınıfın bir bildirimini gösterir:</span><span class="sxs-lookup"><span data-stu-id="5d365-112">The following code shows a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="5d365-113">Sınıf örnekleri, yeni bir örnek için bellek ayıran `new` işleci kullanılarak oluşturulur, örneği başlatmak için bir oluşturucu çağırır ve örneğe bir başvuru döndürür.</span><span class="sxs-lookup"><span data-stu-id="5d365-113">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="5d365-114">Aşağıdaki deyimler iki nokta nesnesi oluşturur ve bu nesnelere başvuruları iki değişken halinde depolar:</span><span class="sxs-lookup"><span data-stu-id="5d365-114">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="5d365-115">Nesne artık erişilebilir olmadığında bir nesnenin kapladığı bellek otomatik olarak geri kazanılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-115">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="5d365-116">İçindeki C#nesneleri açıkça serbest bırakmak gerekli değildir veya mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="5d365-116">It's neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="5d365-117">Üyeler</span><span class="sxs-lookup"><span data-stu-id="5d365-117">Members</span></span>

<span data-ttu-id="5d365-118">Bir sınıfın üyeleri statik üyeler veya örnek üyeleridir.</span><span class="sxs-lookup"><span data-stu-id="5d365-118">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="5d365-119">Statik Üyeler sınıflara aittir ve örnek üyeleri nesnelere aittir (sınıf örnekleri).</span><span class="sxs-lookup"><span data-stu-id="5d365-119">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="5d365-120">Aşağıdaki liste, bir sınıfın içerebileceği üye türlerine genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-120">The following list provides an overview of the kinds of members a class can contain.</span></span>

- <span data-ttu-id="5d365-121">Sabitler</span><span class="sxs-lookup"><span data-stu-id="5d365-121">Constants</span></span>
  - <span data-ttu-id="5d365-122">Sınıfla ilişkili sabit değerler</span><span class="sxs-lookup"><span data-stu-id="5d365-122">Constant values associated with the class</span></span>
- <span data-ttu-id="5d365-123">Alanlar</span><span class="sxs-lookup"><span data-stu-id="5d365-123">Fields</span></span>
  - <span data-ttu-id="5d365-124">Sınıfın değişkenleri</span><span class="sxs-lookup"><span data-stu-id="5d365-124">Variables of the class</span></span>
- <span data-ttu-id="5d365-125">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="5d365-125">Methods</span></span>
  - <span data-ttu-id="5d365-126">Sınıfı tarafından gerçekleştirilebilecek hesaplamalar ve eylemler</span><span class="sxs-lookup"><span data-stu-id="5d365-126">Computations and actions that can be performed by the class</span></span>
- <span data-ttu-id="5d365-127">Özellikler</span><span class="sxs-lookup"><span data-stu-id="5d365-127">Properties</span></span>
  - <span data-ttu-id="5d365-128">Sınıfın adlandırılmış özelliklerini okuma ve yazma ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="5d365-128">Actions associated with reading and writing named properties of the class</span></span>
- <span data-ttu-id="5d365-129">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5d365-129">Indexers</span></span>
  - <span data-ttu-id="5d365-130">Bir dizi gibi sınıfın dizin oluşturma örnekleri ile ilişkili eylemler</span><span class="sxs-lookup"><span data-stu-id="5d365-130">Actions associated with indexing instances of the class like an array</span></span>
- <span data-ttu-id="5d365-131">Olaylar</span><span class="sxs-lookup"><span data-stu-id="5d365-131">Events</span></span>
  - <span data-ttu-id="5d365-132">Sınıfı tarafından oluşturulabilecek bildirimler</span><span class="sxs-lookup"><span data-stu-id="5d365-132">Notifications that can be generated by the class</span></span>
- <span data-ttu-id="5d365-133">İşleçler</span><span class="sxs-lookup"><span data-stu-id="5d365-133">Operators</span></span>
  - <span data-ttu-id="5d365-134">Sınıf tarafından desteklenen dönüşümler ve ifade işleçleri</span><span class="sxs-lookup"><span data-stu-id="5d365-134">Conversions and expression operators supported by the class</span></span>
- <span data-ttu-id="5d365-135">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5d365-135">Constructors</span></span>
  - <span data-ttu-id="5d365-136">Sınıfın veya sınıfın örneklerinin örneğini başlatmak için gereken eylemler</span><span class="sxs-lookup"><span data-stu-id="5d365-136">Actions required to initialize instances of the class or the class itself</span></span>
- <span data-ttu-id="5d365-137">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="5d365-137">Finalizers</span></span>
  - <span data-ttu-id="5d365-138">Sınıfın örneklerinden önce gerçekleştirilecek eylemler kalıcı olarak atılır</span><span class="sxs-lookup"><span data-stu-id="5d365-138">Actions to perform before instances of the class are permanently discarded</span></span>
- <span data-ttu-id="5d365-139">Türler</span><span class="sxs-lookup"><span data-stu-id="5d365-139">Types</span></span>
  - <span data-ttu-id="5d365-140">Sınıf tarafından tanımlanan iç içe türler</span><span class="sxs-lookup"><span data-stu-id="5d365-140">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="5d365-141">Erişilebilirlik</span><span class="sxs-lookup"><span data-stu-id="5d365-141">Accessibility</span></span>

<span data-ttu-id="5d365-142">Bir sınıfın her üyesinin ilişkili bir erişilebilirliği vardır ve bu, üyeye erişebilen program metni bölgelerini denetler.</span><span class="sxs-lookup"><span data-stu-id="5d365-142">Each member of a class has an associated accessibility, which controls the regions of program text that can access the member.</span></span> <span data-ttu-id="5d365-143">Olası altı erişilebilirlik biçimi vardır.</span><span class="sxs-lookup"><span data-stu-id="5d365-143">There are six possible forms of accessibility.</span></span> <span data-ttu-id="5d365-144">Erişim değiştiriciler aşağıda özetlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-144">The access modifiers are summarized below.</span></span>

- `public`
  - <span data-ttu-id="5d365-145">Erişim sınırlı değil.</span><span class="sxs-lookup"><span data-stu-id="5d365-145">Access isn't limited.</span></span>
- `protected`
  - <span data-ttu-id="5d365-146">Erişim bu sınıftan türetilmiş bu sınıfla veya sınıflarla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-146">Access is limited to this class or classes derived from this class.</span></span>
- `internal`
  - <span data-ttu-id="5d365-147">Erişim geçerli derleme (. exe,. dll vb.) ile sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-147">Access is limited to the current assembly (.exe, .dll, and so on.).</span></span>
- `protected internal`
  - <span data-ttu-id="5d365-148">Erişim, kapsayan sınıf, kapsayan sınıftan türetilmiş sınıflar veya aynı derleme içindeki sınıflar ile sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-148">Access is limited to the containing class, classes derived from the containing class, or classes within the same assembly.</span></span>
- `private`
  - <span data-ttu-id="5d365-149">Erişim bu sınıfla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-149">Access is limited to this class.</span></span>
- `private protected`
  - <span data-ttu-id="5d365-150">Erişim, aynı derleme içindeki kapsayan türden türetilmiş sınıf veya sınıflarla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-150">Access is limited to the containing class or classes derived from the containing type within the same assembly.</span></span>

## <a name="type-parameters"></a><span data-ttu-id="5d365-151">Tür parametreleri</span><span class="sxs-lookup"><span data-stu-id="5d365-151">Type parameters</span></span>

<span data-ttu-id="5d365-152">Sınıf tanımı, tür parametre adlarının bir listesini kapsayan açılı ayraçları olan sınıf adını izleyerek bir tür parametreleri kümesi belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-152">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="5d365-153">Daha sonra tür parametreleri sınıfının üyelerini tanımlamak için sınıf bildirimlerinin gövdesinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-153">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="5d365-154">Aşağıdaki örnekte, `Pair` türü parametreleri `TFirst` ve `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="5d365-154">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](~/samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="5d365-155">Tür parametrelerini almak için belirtilen bir sınıf türüne *Genel sınıf türü*denir.</span><span class="sxs-lookup"><span data-stu-id="5d365-155">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="5d365-156">Yapı, arabirim ve temsilci türleri de genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-156">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="5d365-157">Genel sınıf kullanıldığında, tür parametrelerinin her biri için tür bağımsız değişkenlerinin sağlanması gerekir:</span><span class="sxs-lookup"><span data-stu-id="5d365-157">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="5d365-158">Yukarıda `Pair<int,string>` gibi sunulan tür bağımsız değişkenlerine sahip genel bir tür, *oluşturulmuş bir tür*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-158">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="5d365-159">Temel sınıflar</span><span class="sxs-lookup"><span data-stu-id="5d365-159">Base classes</span></span>

<span data-ttu-id="5d365-160">Sınıf bildirimi, sınıf adı ve tür parametreleri iki nokta ve temel sınıfın adı ile birlikte bir temel sınıf belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-160">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="5d365-161">Temel sınıf belirtiminin atlanması `object`türünden türeterek aynıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-161">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="5d365-162">Aşağıdaki örnekte, `Point3D` temel sınıfı `Point`ve `Point` taban sınıfı `object`:</span><span class="sxs-lookup"><span data-stu-id="5d365-162">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](~/samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="5d365-163">Bir sınıf, temel sınıfının üyelerini devralır.</span><span class="sxs-lookup"><span data-stu-id="5d365-163">A class inherits the members of its base class.</span></span> <span data-ttu-id="5d365-164">Devralma, bir sınıfın örnek ve statik oluşturucular ve temel sınıfın sonlandırıcıları dışında, temel sınıfının tüm üyelerini örtük olarak içerdiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="5d365-164">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="5d365-165">Türetilmiş bir sınıf, devraldığı üyelere yeni üyeler ekleyebilir, ancak devralınan bir üyenin tanımını kaldıramıyorum.</span><span class="sxs-lookup"><span data-stu-id="5d365-165">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="5d365-166">Önceki örnekte, `Point3D` `x` ve `y` alanları `Point`devralır ve her `Point3D` örnek, `x`, `y`ve `z`üç alan içerir.</span><span class="sxs-lookup"><span data-stu-id="5d365-166">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="5d365-167">Bir sınıf türünden, temel sınıf türlerinden herhangi birine örtük bir dönüştürme vardır.</span><span class="sxs-lookup"><span data-stu-id="5d365-167">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="5d365-168">Bir sınıf türünün değişkeni, bu sınıfın bir örneğine veya türetilmiş herhangi bir sınıfın örneğine başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-168">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="5d365-169">Örneğin, önceki sınıf bildirimleri verildiğinde `Point` türünde bir değişken `Point` veya `Point3D`başvurabilir:</span><span class="sxs-lookup"><span data-stu-id="5d365-169">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="5d365-170">Alanlar</span><span class="sxs-lookup"><span data-stu-id="5d365-170">Fields</span></span>

<span data-ttu-id="5d365-171">*Alan* , bir sınıf ile veya bir sınıf örneğiyle ilişkili bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="5d365-171">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="5d365-172">Statik değiştiriciyle belirtilen bir alan statik bir alan tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-172">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="5d365-173">Statik alan tam olarak bir depolama konumunu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-173">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="5d365-174">Bir sınıfın kaç örneğinin oluşturulduğuna bakılmaksızın, bir statik alanın yalnızca bir kopyası vardır.</span><span class="sxs-lookup"><span data-stu-id="5d365-174">No matter how many instances of a class are created, there's only ever one copy of a static field.</span></span>

<span data-ttu-id="5d365-175">Statik değiştirici olmadan belirtilen bir alan bir örnek alanını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-175">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="5d365-176">Bir sınıfın her örneği, bu sınıfın tüm örnek alanlarının ayrı bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="5d365-176">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="5d365-177">Aşağıdaki örnekte, `Color` sınıfının her örneği `r`, `g`ve `b` örneği alanlarının ayrı bir kopyasına sahiptir ancak `Black`, `White`, `Red`, `Green`ve `Blue` statik alanlarının yalnızca bir kopyası vardır:</span><span class="sxs-lookup"><span data-stu-id="5d365-177">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there's only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](~/samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="5d365-178">Önceki örnekte gösterildiği gibi, *salt okuma alanları* `readonly` değiştiricisi ile bildirilebilecek.</span><span class="sxs-lookup"><span data-stu-id="5d365-178">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="5d365-179">Bir `readonly` alana atama yalnızca alanın bildiriminin veya aynı sınıftaki bir oluşturucunun parçası olarak gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-179">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="5d365-180">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="5d365-180">Methods</span></span>

<span data-ttu-id="5d365-181">Bir *Yöntem* , bir nesne veya sınıf tarafından gerçekleştirilebilecek bir hesaplama veya eylem uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5d365-181">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="5d365-182">*Statik yöntemlere* sınıfı aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-182">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="5d365-183">*Örnek yöntemlerine* , sınıfının örnekleri aracılığıyla erişilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-183">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="5d365-184">Yöntemler, yönteme geçirilen değerleri veya değişken başvurularını temsil eden bir *parametre*listesine ve hesaplanan ve yöntem tarafından döndürülen değer türünü belirten bir *dönüş türüne*sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-184">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="5d365-185">Bir yöntemin dönüş türü bir değer döndürmezse `void`.</span><span class="sxs-lookup"><span data-stu-id="5d365-185">A method’s return type is `void` if it doesn't return a value.</span></span>

<span data-ttu-id="5d365-186">Türler gibi yöntemler de bir tür parametreleri kümesine sahip olabilir, bu da yöntem çağrıldığında tür bağımsız değişkenlerinin belirtilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="5d365-186">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="5d365-187">Türlerin aksine, tür bağımsız değişkenleri genellikle yöntem çağrısının bağımsız değişkenlerinden çıkarsanamıyor ve açıkça verilmemelidir.</span><span class="sxs-lookup"><span data-stu-id="5d365-187">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="5d365-188">Yöntemin *imzası* , yöntemin bildirildiği sınıfta benzersiz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-188">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="5d365-189">Bir yöntemin imzası yöntemin adından, tür parametrelerinin sayısına ve parametrelerinin sayısına, değiştiricilerine ve türlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5d365-189">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="5d365-190">Bir yöntemin imzası, dönüş türünü içermez.</span><span class="sxs-lookup"><span data-stu-id="5d365-190">The signature of a method doesn't include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="5d365-191">Parametreler</span><span class="sxs-lookup"><span data-stu-id="5d365-191">Parameters</span></span>

<span data-ttu-id="5d365-192">Parametreler, değerlere veya değişken başvurularını yöntemlere geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-192">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="5d365-193">Bir yöntemin parametreleri, yöntemi çağrıldığında belirtilen *bağımsız değişkenlerden* gerçek değerlerini alır.</span><span class="sxs-lookup"><span data-stu-id="5d365-193">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="5d365-194">Dört tür parametre vardır: değer parametreleri, başvuru parametreleri, çıkış parametreleri ve parametre dizileri.</span><span class="sxs-lookup"><span data-stu-id="5d365-194">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="5d365-195">Giriş bağımsız değişkenlerini geçirmek için bir *değer parametresi* kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-195">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="5d365-196">Değer parametresi, parametresi için geçirilen bağımsız değişkenden ilk değerini alan yerel bir değişkene karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="5d365-196">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="5d365-197">Değer parametresindeki değişiklikler, parametresi için geçirilen bağımsız değişkeni etkilemez.</span><span class="sxs-lookup"><span data-stu-id="5d365-197">Modifications to a value parameter don't affect the argument that was passed for the parameter.</span></span>

<span data-ttu-id="5d365-198">Değer parametreleri, ilgili bağımsız değişkenlerin atlanabilmesi için varsayılan bir değer belirtilerek isteğe bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-198">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="5d365-199">*Başvuru parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-199">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="5d365-200">Başvuru parametresi için geçirilen bağımsız değişken, kesin bir değere sahip bir değişken olmalıdır ve yöntemin yürütülmesi sırasında başvuru parametresi, bağımsız değişken değişkeniyle aynı depolama konumunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="5d365-200">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="5d365-201">Bir başvuru parametresi `ref` değiştiricisiyle birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-201">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="5d365-202">Aşağıdaki örnek `ref` parametrelerinin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5d365-202">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](~/samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="5d365-203">Bir *output parametresi* , bağımsız değişkenleri başvuruya göre geçirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-203">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="5d365-204">Bir başvuru parametresine benzer, ancak çağıran tarafından belirtilen bağımsız değişkene açıkça bir değer atamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="5d365-204">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="5d365-205">Bir çıkış parametresi `out` değiştiricisiyle birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-205">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="5d365-206">Aşağıdaki örnek, 7 ' de C# tanıtılan sözdizimi kullanılarak `out` parametrelerinin kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5d365-206">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](~/samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="5d365-207">Bir *parametre dizisi* , bir metoda değişken sayıda bağımsız değişken geçirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="5d365-207">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="5d365-208">Bir parametre dizisi `params` değiştiricisiyle birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-208">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="5d365-209">Bir yöntemin yalnızca son parametresi bir parametre dizisi olabilir ve bir parametre dizisinin türü tek boyutlu bir dizi türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-209">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="5d365-210"><xref:System.Console?displayProperty=nameWithType> sınıfının Write ve WriteLine yöntemleri, parametre dizisi kullanımının iyi örnekleridir.</span><span class="sxs-lookup"><span data-stu-id="5d365-210">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="5d365-211">Bunlar aşağıdaki şekilde bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-211">They're declared as follows.</span></span>

[!code-csharp[ConsoleExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="5d365-212">Bir parametre dizisi kullanan bir yöntem içinde, parametre dizisi tam olarak bir dizi türünün normal parametresine benzer şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="5d365-212">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="5d365-213">Ancak, bir parametre dizisi olan bir yöntem çağrısında, parametre dizisi türünün tek bir bağımsız değişkenini veya parametre dizisinin öğe türünün herhangi bir sayıda bağımsız değişkenini geçirmek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="5d365-213">However, in an invocation of a method with a parameter array, it's possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="5d365-214">İkinci durumda, bir dizi örneği otomatik olarak oluşturulur ve verilen bağımsız değişkenlerle başlatılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-214">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="5d365-215">Bu örnek</span><span class="sxs-lookup"><span data-stu-id="5d365-215">This example</span></span>

[!code-csharp[StringFormat](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="5d365-216">, aşağıdaki yazma ile eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="5d365-216">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="5d365-217">Yöntem gövdesi ve yerel değişkenler</span><span class="sxs-lookup"><span data-stu-id="5d365-217">Method body and local variables</span></span>

<span data-ttu-id="5d365-218">Yöntemin gövdesi, yöntemi çağrıldığında yürütülecek deyimleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="5d365-218">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="5d365-219">Yöntem gövdesi, yöntemi çağrısına özgü değişkenleri bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-219">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="5d365-220">Bu tür değişkenlere *yerel değişkenler*denir.</span><span class="sxs-lookup"><span data-stu-id="5d365-220">Such variables are called *local variables*.</span></span> <span data-ttu-id="5d365-221">Yerel bir değişken bildirimi bir tür adı, değişken adı ve muhtemelen bir başlangıç değeri belirtir.</span><span class="sxs-lookup"><span data-stu-id="5d365-221">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="5d365-222">Aşağıdaki örnek, başlangıç değeri sıfır olan `i` yerel bir değişken ve ilk değeri olmayan `j` bir yerel değişken bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-222">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](~/samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="5d365-223">C#değeri alınabilmesi için önce bir yerel değişkenin *kesinlikle atanmasını* gerektirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-223">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="5d365-224">Örneğin, önceki `i` bildirimi bir başlangıç değeri içermiyorsa, `i`, programda bu noktalarda kesinlikle atanamadığı için, derleyici `i` sonraki kullanımları için bir hata bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-224">For example, if the declaration of the previous `i` didn't include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` wouldn't be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="5d365-225">Bir yöntem, `return` deyimlerini kullanarak çağıranına denetim döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-225">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="5d365-226">`void`döndüren bir yöntemde `return` deyimler bir ifade belirtemez.</span><span class="sxs-lookup"><span data-stu-id="5d365-226">In a method returning `void`, `return` statements can't specify an expression.</span></span> <span data-ttu-id="5d365-227">Void olmayan `return` deyimlerini döndüren bir yöntemde, dönüş değerini hesaplayan bir ifade içermelidir.</span><span class="sxs-lookup"><span data-stu-id="5d365-227">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="5d365-228">Statik ve örnek yöntemleri</span><span class="sxs-lookup"><span data-stu-id="5d365-228">Static and instance methods</span></span>

<span data-ttu-id="5d365-229">Statik değiştirici ile belirtilen bir yöntem *statik bir yöntemdir*.</span><span class="sxs-lookup"><span data-stu-id="5d365-229">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="5d365-230">Statik bir yöntem, belirli bir örnek üzerinde çalışmaz ve yalnızca statik üyelere doğrudan erişebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-230">A static method doesn't operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="5d365-231">Statik değiştirici olmadan belirtilen bir yöntem bir *örnek yöntemidir*.</span><span class="sxs-lookup"><span data-stu-id="5d365-231">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="5d365-232">Örnek yöntemi, belirli bir örnek üzerinde çalışır ve hem statik hem de örnek üyelerine erişebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-232">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="5d365-233">Örnek yönteminin çağrıldığı örnek, `this`olarak açıkça erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-233">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="5d365-234">Statik bir yöntemde `this` başvurmak hatadır.</span><span class="sxs-lookup"><span data-stu-id="5d365-234">It's an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="5d365-235">Aşağıdaki `Entity` sınıfı hem statik hem de örnek üyelere sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5d365-235">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="5d365-236">Her bir `Entity` örneği bir seri numarası içerir (ve burada görünmeyen bazı diğer bilgileri kabul edilir).</span><span class="sxs-lookup"><span data-stu-id="5d365-236">Each `Entity` instance contains a serial number (and presumably some other information that isn't shown here).</span></span> <span data-ttu-id="5d365-237">`Entity` Oluşturucusu (bir örnek yöntemi gibi) yeni örneği bir sonraki kullanılabilir seri numarası ile başlatır.</span><span class="sxs-lookup"><span data-stu-id="5d365-237">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="5d365-238">Oluşturucu bir örnek üyesi olduğundan, hem `serialNo` örnek alanına hem de `nextSerialNo` statik alanına erişme izni verilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-238">Because the constructor is an instance member, it's permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="5d365-239">`GetNextSerialNo` ve `SetNextSerialNo` statik yöntemleri `nextSerialNo` statik alana erişebilir, ancak `serialNo` örnek alanına doğrudan erişmesi için bir hata olabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-239">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="5d365-240">Aşağıdaki örnek, Entity sınıfının kullanımını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5d365-240">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](~/samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="5d365-241">`SetNextSerialNo` ve `GetNextSerialNo` static yöntemler sınıfında çağrılır, ancak `GetSerialNo` örnek yöntemi sınıfının örneklerinde çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-241">The `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="5d365-242">Sanal, geçersiz kılma ve soyut yöntemler</span><span class="sxs-lookup"><span data-stu-id="5d365-242">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="5d365-243">Bir örnek yöntemi bildirimi `virtual` değiştirici içerdiğinde, yöntem *sanal bir yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-243">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="5d365-244">Bir sanal değiştirici yoksa, yöntem *sanal olmayan bir yöntem*olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-244">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="5d365-245">Bir sanal yöntem çağrıldığında, çağrının gerçekleştiği örneğin *çalışma zamanı türü* , çağrılacak gerçek Yöntem uygulamasını belirler.</span><span class="sxs-lookup"><span data-stu-id="5d365-245">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="5d365-246">Sanal olmayan bir yöntem çağrısında, örneğin *derleme zamanı türü* belirleme faktörü olur.</span><span class="sxs-lookup"><span data-stu-id="5d365-246">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="5d365-247">Bir sanal yöntem, türetilmiş bir sınıfta *geçersiz kılınabilir* .</span><span class="sxs-lookup"><span data-stu-id="5d365-247">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="5d365-248">Bir örnek yöntemi bildirimi bir geçersiz kılma değiştiricisi içerdiğinde, yöntemi aynı imzaya sahip devralınmış bir sanal yöntemi geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="5d365-248">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="5d365-249">Sanal bir yöntem bildiriminde yeni bir yöntem tanıtıldığı halde, bir geçersiz kılma yöntemi bildirimi, bu yöntemin yeni bir uygulamasını sağlayarak, var olan bir devralınmış sanal yöntemi uzmanlık eder.</span><span class="sxs-lookup"><span data-stu-id="5d365-249">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="5d365-250">*Soyut bir yöntem* , uygulama içermeyen bir sanal yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="5d365-250">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="5d365-251">Soyut bir yöntem soyut değiştiriciyle birlikte bildirilmiştir ve yalnızca soyut olarak da tanımlanmış bir sınıfta izin verilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-251">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="5d365-252">Soyut olmayan her türetilmiş sınıfta bir soyut yöntem geçersiz kılınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-252">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="5d365-253">Aşağıdaki örnek, bir soyut sınıfı, bir ifade ağaç düğümünü temsil eden `Expression`, üç türetilmiş sınıf, `Constant`, `VariableReference`ve `Operation`sabitler, değişken başvuruları ve aritmetik işlemler için ifade ağacı düğümleri uygulayan bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-253">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="5d365-254">(Bu örnek ile benzerdir ancak ifade ağacı türleriyle karıştırılmamalıdır).</span><span class="sxs-lookup"><span data-stu-id="5d365-254">(This example is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="5d365-255">Önceki dört sınıf aritmetik ifadeleri modellemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-255">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="5d365-256">Örneğin, bu sınıfların örneklerini kullanarak ifade `x + 3` aşağıdaki gibi gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-256">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](~/samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="5d365-257">Bir `Expression` örneğinin `Evaluate` Yöntemi verilen ifadeyi değerlendirmek ve bir `double` değeri üretmek için çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-257">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="5d365-258">Yöntemi, değişken adlarını (girdilerin anahtarları olarak) ve değerlerini (girdilerin değerleri olarak) içeren `Dictionary` bir bağımsız değişken alır.</span><span class="sxs-lookup"><span data-stu-id="5d365-258">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="5d365-259">`Evaluate` soyut bir yöntem olduğundan, `Expression` türetilmiş soyut olmayan sınıfların `Evaluate`geçersiz kılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5d365-259">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="5d365-260">`Constant``Evaluate` uygulanması yalnızca depolanan sabiti döndürür.</span><span class="sxs-lookup"><span data-stu-id="5d365-260">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="5d365-261">`VariableReference`uygulama, sözlükte değişken adını arar ve elde edilen değeri döndürür.</span><span class="sxs-lookup"><span data-stu-id="5d365-261">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="5d365-262">`Operation`uygulamasının ilk önce sol ve sağ işlenenleri değerlendirir (`Evaluate` yöntemlerini yinelemeli olarak çağırarak) ve ardından verilen aritmetik işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-262">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="5d365-263">Aşağıdaki program, `x` ve `y`farklı değerleri için ifade `x * (y + 2)` değerlendirmek üzere `Expression` sınıflarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="5d365-263">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](~/samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="5d365-264">Yöntem aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="5d365-264">Method overloading</span></span>

<span data-ttu-id="5d365-265">Yöntem *aşırı yüklemesi* , aynı sınıftaki birden çok metodun benzersiz imzalara sahip oldukları sürece aynı ada sahip olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-265">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="5d365-266">Aşırı yüklenmiş bir yöntemin çağrılması derlenirken, derleyici çağrılacak özel yöntemi belirlemekte *aşırı yükleme çözümü* kullanır.</span><span class="sxs-lookup"><span data-stu-id="5d365-266">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="5d365-267">Aşırı yükleme çözümlemesi, bağımsız değişkenlerle en iyi eşleşen bir yöntemi bulur veya tek bir en iyi eşleşme bulunamazsa hata bildiriyor.</span><span class="sxs-lookup"><span data-stu-id="5d365-267">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="5d365-268">Aşağıdaki örnekte, etkin olan aşırı yükleme çözümü gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="5d365-268">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="5d365-269">`UsageExample` yöntemi içindeki her çağrının yorumu hangi yöntemin çağrılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="5d365-269">The comment for each invocation in the `UsageExample` method shows which method is invoked.</span></span>

[!code-csharp[OverloadUsage](~/samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="5d365-270">Örnekte gösterildiği gibi belirli bir yöntem her zaman bağımsız değişkenleri tam parametre türlerine açıkça atayarak ve/veya açıkça tür bağımsız değişkenleri sunarak seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-270">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="5d365-271">Diğer işlev üyeleri</span><span class="sxs-lookup"><span data-stu-id="5d365-271">Other function members</span></span>

<span data-ttu-id="5d365-272">Yürütülebilir kod içeren Üyeler topluca bir sınıfın *işlev üyeleri* olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="5d365-272">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="5d365-273">Yukarıdaki bölümde, işlev üyelerinin birincil türleri olan yöntemler açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="5d365-273">The preceding section describes methods, which are the primary types of function members.</span></span> <span data-ttu-id="5d365-274">Bu bölümde, tarafından C#desteklenen diğer işlev üyesi türleri açıklanmaktadır: oluşturucular, özellikler, Dizin oluşturucular, olaylar, işleçler ve sonlandırıcılar.</span><span class="sxs-lookup"><span data-stu-id="5d365-274">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="5d365-275">Aşağıdaki örnek, bir nesne growable listesi uygulayan `MyList<T>`adlı genel bir sınıfı gösterir.</span><span class="sxs-lookup"><span data-stu-id="5d365-275">The following example shows a generic class called `MyList<T>`, which implements a growable list of objects.</span></span> <span data-ttu-id="5d365-276">Sınıfı, en yaygın işlev üyesi türlerine birkaç örnek içerir.</span><span class="sxs-lookup"><span data-stu-id="5d365-276">The class contains several examples of the most common kinds of function members.</span></span>

> [!NOTE]
> <span data-ttu-id="5d365-277">Bu örnekte, .NET Standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>ile aynı olmayan bir `MyList` sınıfı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="5d365-277">This example creates a `MyList` class, which is not the same as the .NET standard <xref:System.Collections.Generic.List%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5d365-278">Bu, bu tur için gereken kavramları gösterir, ancak bu sınıfın yerini almaz.</span><span class="sxs-lookup"><span data-stu-id="5d365-278">It does illustrate the concepts needed for this tour, but is not a replacement for that class.</span></span>

[!code-csharp[ListClass](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="5d365-279">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5d365-279">Constructors</span></span>

<span data-ttu-id="5d365-280">C#hem örnek hem de statik oluşturucuları destekler.</span><span class="sxs-lookup"><span data-stu-id="5d365-280">C# supports both instance and static constructors.</span></span> <span data-ttu-id="5d365-281">*Örnek Oluşturucu* , bir sınıfın örneğini başlatmak için gereken eylemleri uygulayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="5d365-281">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="5d365-282">*Statik Oluşturucu* , ilk yüklendiği zaman bir sınıfın kendisini başlatmak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5d365-282">A *static constructor* is a member that implements the actions required to initialize a class itself when it's first loaded.</span></span>

<span data-ttu-id="5d365-283">Bir Oluşturucu, dönüş türü olmayan bir yöntem ve kapsayan sınıfla aynı adı ile birlikte bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-283">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="5d365-284">Bir Oluşturucu bildirimi statik değiştirici içeriyorsa, statik bir Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-284">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="5d365-285">Aksi takdirde, bir örnek Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-285">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="5d365-286">Örnek oluşturucular aşırı yüklenebilir ve isteğe bağlı parametrelere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-286">Instance constructors can be overloaded and can have optional parameters.</span></span> <span data-ttu-id="5d365-287">Örneğin `MyList<T>` sınıfı, tek bir isteğe bağlı `int` parametresine sahip bir örnek Oluşturucu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-287">For example, the `MyList<T>` class declares one instance constructor with a single optional `int` parameter.</span></span> <span data-ttu-id="5d365-288">Örnek oluşturucular `new` işleci kullanılarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-288">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="5d365-289">Aşağıdaki deyimler, ve isteğe bağlı bağımsız değişken olmadan `MyList` sınıfının yapıcısını kullanarak iki `MyList<string>` örneği ayırır.</span><span class="sxs-lookup"><span data-stu-id="5d365-289">The following statements allocate two `MyList<string>` instances using the constructor of the `MyList` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="5d365-290">Diğer üyelerin aksine, örnek oluşturucular devralınmaz ve bir sınıfta, aslında sınıfta belirtilen oluşturuculardan başka örnek oluşturucuları yoktur.</span><span class="sxs-lookup"><span data-stu-id="5d365-290">Unlike other members, instance constructors aren't inherited, and a class has no instance constructors other than those constructors actually declared in the class.</span></span> <span data-ttu-id="5d365-291">Bir sınıf için örnek Oluşturucu sağlanmazsa, parametresi olmayan boş bir değer otomatik olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="5d365-291">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="5d365-292">Özellikler</span><span class="sxs-lookup"><span data-stu-id="5d365-292">Properties</span></span>

<span data-ttu-id="5d365-293">*Özellikler* , alanlar için doğal bir uzantıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-293">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="5d365-294">Her ikisi de ilişkili türlerin bulunduğu isimlerdir ve alanlara ve özelliklere erişim için sözdizimi aynıdır.</span><span class="sxs-lookup"><span data-stu-id="5d365-294">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="5d365-295">Ancak, alanların aksine, Özellikler depolama konumlarını göstermiyor.</span><span class="sxs-lookup"><span data-stu-id="5d365-295">However, unlike fields, properties don't denote storage locations.</span></span> <span data-ttu-id="5d365-296">Bunun yerine, özellikler, değerleri okunmak veya yazıldığında yürütülecek deyimleri belirten *erişimcileri* vardır.</span><span class="sxs-lookup"><span data-stu-id="5d365-296">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="5d365-297">Bir özellik, bir alan gibi, bildirim bir get erişimcisi ve/veya sınırlayıcılar arasında yazılmış bir set erişimcisi ve/veya virgülle sona ermek yerine `}` `{`</span><span class="sxs-lookup"><span data-stu-id="5d365-297">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="5d365-298">Hem get erişimcisine hem de bir set erişimcisine sahip olan bir özellik *okuma-yazma özelliğidir*, yalnızca bir get erişimcisine sahip olan bir özellik *salt okunurdur*ve yalnızca bir set erişimcisi olan bir özellik yalnızca bir salt *yazılır özelliktir*.</span><span class="sxs-lookup"><span data-stu-id="5d365-298">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="5d365-299">Get erişimcisi, özellik türünün dönüş değeri olan parametresiz bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="5d365-299">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="5d365-300">Atama hedefi haricinde, bir ifadede bir özelliğe başvurulduğunda, özelliğin değerini hesaplamak için özelliğin get erişimcisi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-300">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="5d365-301">Bir set erişimcisi, value adlı tek parametreli ve dönüş türü olmayan bir yönteme karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="5d365-301">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="5d365-302">Bir atamaya bir atama hedefi olarak veya + + veya--, işleneni olarak başvurulduğunda, yeni değer sağlayan bir bağımsız değişkenle çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-302">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="5d365-303">`MyList<T>` sınıfı, sırasıyla salt okuma ve okuma-yazma olan iki özellik `Count` ve `Capacity`bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-303">The `MyList<T>` class declares two properties, `Count` and `Capacity`, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="5d365-304">Aşağıdaki kod, bu özelliklerin kullanım örneğidir:</span><span class="sxs-lookup"><span data-stu-id="5d365-304">The following code is an example of use of these properties:</span></span>

[!code-csharp[ListExample2](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="5d365-305">Alanlar ve yöntemlere benzer şekilde hem C# örnek özelliklerini hem de statik özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="5d365-305">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="5d365-306">Statik özellikler statik değiştirici ile tanımlanır ve örnek özellikleri bu olmadan tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5d365-306">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="5d365-307">Bir özelliğin erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-307">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="5d365-308">Bir özellik bildirimi `virtual`, `abstract`veya `override` değiştiricisini içerdiğinde, özelliğin erişimcilerle geçerli olur.</span><span class="sxs-lookup"><span data-stu-id="5d365-308">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="5d365-309">Dizin Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="5d365-309">Indexers</span></span>

<span data-ttu-id="5d365-310">*Dizin Oluşturucu* , nesnelerin diziyle aynı şekilde dizinlenmesini sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="5d365-310">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="5d365-311">Bir Dizin Oluşturucu, üye adının `this` ve ardından sınırlayıcı `[` ve `]`arasında yazılmış bir parametre listesi olması dışında bir özellik gibi bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-311">An indexer is declared like a property except that the name of the member is `this` followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="5d365-312">Parametreler, dizin oluşturucunun erişimcisinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-312">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="5d365-313">Özelliklere benzer şekilde, Dizin oluşturucular okunabilir-yazılır, salt okunurdur ve salt yazılır olabilir ve bir dizin oluşturucunun erişimcisi sanal olabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-313">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="5d365-314">`MyList<T>` sınıfı, bir `int` parametresi alan tek bir okuma-yazma Dizin oluşturucuyu bildirir.</span><span class="sxs-lookup"><span data-stu-id="5d365-314">The `MyList<T>` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="5d365-315">Dizin Oluşturucu, `MyList<T>` örneklerinin `int` değerlerle dizinini oluşturmanızı mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="5d365-315">The indexer makes it possible to index `MyList<T>` instances with `int` values.</span></span> <span data-ttu-id="5d365-316">Örnek:</span><span class="sxs-lookup"><span data-stu-id="5d365-316">For example:</span></span>

[!code-csharp[ListExample3](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="5d365-317">Dizin oluşturucular aşırı yüklenebilir, yani parametrelerinin sayısı veya türleri farklı olduğu sürece bir sınıfın birden çok dizin kümesini bildirebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="5d365-317">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="5d365-318">Olaylar</span><span class="sxs-lookup"><span data-stu-id="5d365-318">Events</span></span>

<span data-ttu-id="5d365-319">Bir *olay* , bir sınıf veya nesnenin bildirimler sağlamasını sağlayan bir üyedir.</span><span class="sxs-lookup"><span data-stu-id="5d365-319">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="5d365-320">Bir olay, bildirim bir event anahtar sözcüğü içermesi ve türün bir temsilci türü olması dışında, bir alan gibi bildirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="5d365-320">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="5d365-321">Olay üyesini bildiren bir sınıf içinde, olay bir temsilci türünün alanı gibi davranır (olay soyut değildir ve erişimcileri bildirmez).</span><span class="sxs-lookup"><span data-stu-id="5d365-321">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event isn't abstract and doesn't declare accessors).</span></span> <span data-ttu-id="5d365-322">Bu alan, olaya eklenmiş olan olay işleyicilerini temsil eden bir temsilciye bir başvuru depolar.</span><span class="sxs-lookup"><span data-stu-id="5d365-322">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="5d365-323">Hiçbir olay işleyicisi yoksa, alan `null`.</span><span class="sxs-lookup"><span data-stu-id="5d365-323">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="5d365-324">`MyList<T>` sınıfı, `Changed`adlı tek bir olay üyesini bildirir ve bu, listeye yeni bir öğe eklendiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="5d365-324">The `MyList<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="5d365-325">Değiştirilen olay `OnChanged` sanal yöntemi tarafından tetiklenir ve bu, önce olayın `null` olup olmadığını denetler (hiçbir işleyici yok anlamına gelir).</span><span class="sxs-lookup"><span data-stu-id="5d365-325">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="5d365-326">Bir olayı oluşturma kavramı, olayın gösterdiği temsilciyi çağırmak için tam olarak eşdeğerdir. bu nedenle, olayları yükseltmek için özel dil yapıları yoktur.</span><span class="sxs-lookup"><span data-stu-id="5d365-326">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="5d365-327">İstemciler *olay işleyicileri*aracılığıyla olaylara tepki verir.</span><span class="sxs-lookup"><span data-stu-id="5d365-327">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="5d365-328">Olay işleyicileri `+=` işleci kullanılarak iliştirilir ve `-=` işleci kullanılarak kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-328">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="5d365-329">Aşağıdaki örnek, bir `MyList<string>``Changed` olayına bir olay işleyicisi ekler.</span><span class="sxs-lookup"><span data-stu-id="5d365-329">The following example attaches an event handler to the `Changed` event of a `MyList<string>`.</span></span>

[!code-csharp[EventExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="5d365-330">Bir olayın temeldeki depolamanın denetiminin istendiği Gelişmiş senaryolarda, bir olay bildirimi açıkça bir özelliğin `set` erişimcisine benzer olan `add` ve `remove` erişimcileri sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-330">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="5d365-331">İşleçler</span><span class="sxs-lookup"><span data-stu-id="5d365-331">Operators</span></span>

<span data-ttu-id="5d365-332">*İşleci* , bir sınıfın örneklerine belirli bir ifade işlecini uygulamanın anlamını tanımlayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5d365-332">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="5d365-333">Üç tür işleç tanımlanabilir: Birli İşleçler, ikili işleçler ve dönüştürme işleçleri.</span><span class="sxs-lookup"><span data-stu-id="5d365-333">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="5d365-334">Tüm işleçler `public` ve `static`olarak bildirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="5d365-334">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="5d365-335">`MyList<T>` sınıfı iki işleç bildirir `operator ==` ve `operator !=`ve bu işleçleri `MyList` örneklerine uygulayan deyimlere yeni anlam verir.</span><span class="sxs-lookup"><span data-stu-id="5d365-335">The `MyList<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `MyList` instances.</span></span> <span data-ttu-id="5d365-336">Özel olarak, işleçler iki `MyList<T>` örneğinin eşitliğini tanımlar ve bu nesnelerin her birini eşittir yöntemlerini kullanarak karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="5d365-336">Specifically, the operators define equality of two `MyList<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="5d365-337">Aşağıdaki örnek, iki `MyList<int>` örneğini karşılaştırmak için `==` işlecini kullanır.</span><span class="sxs-lookup"><span data-stu-id="5d365-337">The following example uses the `==` operator to compare two `MyList<int>` instances.</span></span>

[!code-csharp[OperatorExample](~/samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="5d365-338">İki liste aynı sırada aynı değerlerle aynı sayıda nesne içerdiğinden, ilk `Console.WriteLine` `True` çıkışı oluşur.</span><span class="sxs-lookup"><span data-stu-id="5d365-338">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="5d365-339">`operator ==`tanımlanmayan `MyList<T>`, `a` ve `b` farklı `MyList<int>` örneklerine başvurduğundan ilk `Console.WriteLine` çıkış `False` sahip olur.</span><span class="sxs-lookup"><span data-stu-id="5d365-339">Had `MyList<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `MyList<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="5d365-340">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="5d365-340">Finalizers</span></span>

<span data-ttu-id="5d365-341">*Sonlandırıcı* , bir sınıfın örneğini tamamlamak için gereken eylemleri uygulayan bir üyesidir.</span><span class="sxs-lookup"><span data-stu-id="5d365-341">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="5d365-342">Sonlandırıcılar parametrelere sahip olamaz, erişilebilirlik değiştiricilerine sahip olamaz ve açıkça çağrılamaz.</span><span class="sxs-lookup"><span data-stu-id="5d365-342">Finalizers can't have parameters, they can't have accessibility modifiers, and they can't be invoked explicitly.</span></span> <span data-ttu-id="5d365-343">Örnek için Sonlandırıcı çöp toplama sırasında otomatik olarak çağrılır.</span><span class="sxs-lookup"><span data-stu-id="5d365-343">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="5d365-344">Çöp toplayıcısına, nesnelerin toplanması ve Sonlandırıcıların ne zaman toplanacağına karar verirken geniş bir enlem vardır.</span><span class="sxs-lookup"><span data-stu-id="5d365-344">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="5d365-345">Özellikle, Sonlandırıcı çağırma zamanlaması belirleyici değildir ve herhangi bir iş parçacığında sonlandırıcılar çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="5d365-345">Specifically, the timing of finalizer invocations isn't deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="5d365-346">Bu ve diğer nedenlerden dolayı sınıfların yalnızca başka hiçbir çözüm uygulanabilir olmadığında sonlandırıcılar uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="5d365-346">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="5d365-347">`using` ifade, nesne yok etme için daha iyi bir yaklaşım sağlar.</span><span class="sxs-lookup"><span data-stu-id="5d365-347">The `using` statement provides a better approach to object destruction.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="5d365-348">[Önceki](statements.md)
> [İleri](arrays.md)</span><span class="sxs-lookup"><span data-stu-id="5d365-348">[Previous](statements.md)
[Next](arrays.md)</span></span>
