---
title: Kapsayıcılardan ve düzenleyicilerden yararlanma
description: Azure 'da Docker kapsayıcılarını ve Kubernetes düzenleyicilerinden yararlanın
ms.date: 06/30/2019
ms.openlocfilehash: 62aaa68b2ada0725f33df62e97f1ca3216b91ccf
ms.sourcegitcommit: 628e8147ca10187488e6407dab4c4e6ebe0cac47
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/15/2019
ms.locfileid: "72315884"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="746bf-103">Kapsayıcılardan ve düzenleyicilerden yararlanma</span><span class="sxs-lookup"><span data-stu-id="746bf-103">Leveraging containers and orchestrators</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="746bf-104">Kapsayıcılar ve düzenleyiciler, tek parçalı dağıtım yaklaşımları için ortak olan sorunları çözmeye yönelik olarak tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="746bf-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="746bf-105">Tek parçalı dağıtımlar ile ilgili sorunlar</span><span class="sxs-lookup"><span data-stu-id="746bf-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="746bf-106">Geleneksel olarak, çoğu uygulama tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="746bf-107">Bu tür uygulamalar tek bir olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="746bf-108">Bu genel yaklaşım, birden çok modülden oluşsa bile veya derlemeler şekil 3-1 ' de gösterildiği gibi tek parçalı mimari olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="746bf-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![Tek parçalı mimari.](./media/monolithic-architecture.png)

<span data-ttu-id="746bf-110">**Şekil 3-1**.</span><span class="sxs-lookup"><span data-stu-id="746bf-110">**Figure 3-1**.</span></span> <span data-ttu-id="746bf-111">Tek parçalı mimari.</span><span class="sxs-lookup"><span data-stu-id="746bf-111">Monolithic architecture.</span></span>

<span data-ttu-id="746bf-112">Basitlik avantajlarına sahip olsalar da tek parçalı mimarilerin bir dizi zorluk yüzü vardır:</span><span class="sxs-lookup"><span data-stu-id="746bf-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployments"></a><span data-ttu-id="746bf-113">Dağıtımlar</span><span class="sxs-lookup"><span data-stu-id="746bf-113">Deployments</span></span>

<span data-ttu-id="746bf-114">Tek parçalı uygulamalara dağıtım, genellikle yalnızca bir küçük modül değiştirilse bile tüm uygulamanın yeniden başlatılmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="746bf-114">Deploying to monolithic applications typically requires restarting the entire application, even if only one small module is being replaced.</span></span> <span data-ttu-id="746bf-115">Uygulamayı barındıran makinelerin sayısına bağlı olarak, bu, dağıtımlar sırasında kapalı kalma süresine yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-115">Depending on the number of machines hosting the application, this can result in downtime during deployments.</span></span>

### <a name="hosting"></a><span data-ttu-id="746bf-116">Barındırma</span><span class="sxs-lookup"><span data-stu-id="746bf-116">Hosting</span></span>

<span data-ttu-id="746bf-117">Tek parçalı uygulamalar tamamen tek bir makine örneğinde barındırılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-117">Monolithic applications are hosted entirely on a single machine instance.</span></span> <span data-ttu-id="746bf-118">Bu, dağıtılmış bir uygulamadaki herhangi bir modülün gerek duyduğu daha yüksek yetenek donanımlar gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-118">This may require higher-capability hardware than any module in a distributed application would need.</span></span> <span data-ttu-id="746bf-119">Ayrıca, uygulamanın herhangi bir bölümü bir performans sorunu haline gelirse, genişletmek için tüm uygulamanın ek makine düğümlerine dağıtılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="746bf-119">Also, if any part of the app becomes a bottleneck, the entire application must be deployed to additional machine nodes in order to scale out.</span></span>

### <a name="environment"></a><span data-ttu-id="746bf-120">Ortam</span><span class="sxs-lookup"><span data-stu-id="746bf-120">Environment</span></span>

<span data-ttu-id="746bf-121">Tek parçalı uygulamalar, genellikle mevcut bir barındırma ortamına (işletim sistemi, yüklü çerçeveler vb.) dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-121">Monolithic applications are typically deployed into an existing hosting environment (operating system, installed frameworks, etc.).</span></span> <span data-ttu-id="746bf-122">Bu ortam, uygulamanın geliştirildiği veya test ettiği ortamla eşleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-122">This environment may not match the environment in which the application was developed or tested.</span></span> <span data-ttu-id="746bf-123">Uygulamanın ortamındaki tutarsızlıklar, tek parçalı dağıtımlar için ortak bir sorun kaynağıdır.</span><span class="sxs-lookup"><span data-stu-id="746bf-123">Inconsistencies in the application's environment are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="746bf-124">Bağlantısı</span><span class="sxs-lookup"><span data-stu-id="746bf-124">Coupling</span></span>

<span data-ttu-id="746bf-125">Tek parçalı uygulamalar, uygulamanın farklı parçaları arasında ve uygulama ile ortamı arasında çok büyük bir çışa sahiptir.</span><span class="sxs-lookup"><span data-stu-id="746bf-125">Monolithic applications are likely to have a great deal of coupling between different parts of the application, and between the application and its environment.</span></span> <span data-ttu-id="746bf-126">Bu, belirli bir hizmeti daha sonra veya daha sonra bir diğer uygulamada ölçeklenebilirlik veya takas etmek için bir veya daha fazla sorun yaşamamayı zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="746bf-126">This can make it difficult to factor out a particular service or concern later, in order to increase its scalability or swap in an alternative implementation.</span></span> <span data-ttu-id="746bf-127">Bu, aynı zamanda sistemde yapılan değişiklikler için büyük olasılıkla büyük uygulamalarda çok daha büyük etkileri olmasına yol açar.</span><span class="sxs-lookup"><span data-stu-id="746bf-127">This coupling also leads to much larger potential impacts for changes to the system, requiring extensive testing in larger applications.</span></span>

### <a name="technology-choice"></a><span data-ttu-id="746bf-128">Teknoloji seçimi</span><span class="sxs-lookup"><span data-stu-id="746bf-128">Technology choice</span></span>

<span data-ttu-id="746bf-129">Tek parçalı uygulamalar, birim olarak oluşturulup dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-129">Monolithic applications are built and deployed as a unit.</span></span> <span data-ttu-id="746bf-130">Bu, basitlik ve uygunluk olanakları sunar, ancak yenilik için bir engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-130">This offers simplicity and uniformity but can be a barrier to innovation.</span></span> <span data-ttu-id="746bf-131">Sistemdeki yeni bir özellik veya modül daha modern bir platforma veya çerçeveye daha iyi uygun olsa da, uygulamanın tutarlılığının yanı sıra geliştirme ve dağıtım kolaylığı için uygulamanın geçerli yaklaşımı kullanılarak oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="746bf-131">Although a new feature or module in the system might be better-suited to a more modern platform or framework, it's likely to be built using the application's current approach for the sake of consistency as well as ease of development and deployment.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="746bf-132">Kapsayıcıların ve düzenleyicilerinin avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="746bf-132">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="746bf-133">Docker, en popüler kapsayıcı yönetimi ve görüntüleme platformudur ve Linux ve Windows üzerinde kapsayıcılarla hızlı bir şekilde çalışmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-133">Docker is the most popular container management and imaging platform and allows you to quickly work with containers on Linux and Windows.</span></span> <span data-ttu-id="746bf-134">Kapsayıcılar, her sistemde aynı şekilde çalışan ayrı ancak tekrarlanabilir uygulama ortamları sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-134">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="746bf-135">Bu, bulut Yerel uygulamalarında uygulamalar ve uygulama bileşenleri geliştirmek ve barındırmak için idealdir.</span><span class="sxs-lookup"><span data-stu-id="746bf-135">This makes them perfect for developing and hosting applications and app components in cloud-native applications.</span></span> <span data-ttu-id="746bf-136">Kapsayıcılar birbirinden yalıtılmıştır, bu nedenle aynı konak donanımında iki kapsayıcı, çakışmaya neden olan bağımlılıklar olmadan farklı yazılım sürümlerine ve hatta işletim sistemine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-136">Containers are isolated from one another, so two containers on the same host hardware can have different versions of software and even operating system installed, without the dependencies causing conflicts.</span></span>

<span data-ttu-id="746bf-137">Diğer özellikler, kapsayıcılar kaynak denetimine denetlenebilecekleri basit dosyalar tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="746bf-137">What’s more, containers are defined by simple files that can be checked into source control.</span></span> <span data-ttu-id="746bf-138">Tam sunuculardan farklı olarak, güncelleştirmeleri uygulamak veya ek hizmetleri yüklemek için sık olarak çalışan sanal makineler olsa bile kapsayıcı altyapısı kolayca sürüm denetimli olabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-138">Unlike full servers, even virtual machines, which frequently require manual work to apply updates or install additional services, container infrastructure can easily be version-controlled.</span></span> <span data-ttu-id="746bf-139">Bu nedenle, kapsayıcılarda çalışmak üzere oluşturulan uygulamalar, derleme işlem hattının bir parçası olarak otomatikleştirilmiş araçlar kullanılarak geliştirilebilir, test edilebilir ve dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-139">Thus, apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="746bf-140">Kapsayıcılar sabittir.</span><span class="sxs-lookup"><span data-stu-id="746bf-140">Containers are immutable.</span></span> <span data-ttu-id="746bf-141">Bir kapsayıcının tanımına sahip olduktan sonra, bu kapsayıcıyı yeniden oluşturabilirsiniz ve tam olarak aynı şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="746bf-141">Once you have the definition of a container, you can recreate that container and it will run exactly the same way.</span></span> <span data-ttu-id="746bf-142">Bu, bu şekilde bileşen tabanlı tasarıma yönelik olarak kullanılabilirlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-142">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="746bf-143">Bir uygulamanın bazı bölümleri başkaları kadar sık değişmemekle karşılaşmıyorsanız, en sık değiştiren parçaları yalnızca dağıtırken uygulamanın tamamını yeniden dağıtmanız gerekir mi?</span><span class="sxs-lookup"><span data-stu-id="746bf-143">If some parts of an application don’t change as often as others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="746bf-144">Bir uygulamanın farklı özellikleri ve çapraz kesme sorunları ayrı birimlere ayrılabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-144">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="746bf-145">Şekil 3-2, tek parçalı bir uygulamanın belirli özellikler veya işlevler için kapsayıcılardan ve mikro hizmetlerden nasıl yararlanabileceğiz gösterir.</span><span class="sxs-lookup"><span data-stu-id="746bf-145">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="746bf-146">Uygulamanın kendisindeki diğer işlevsellik de Kapsayıcılı hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-146">The remaining functionality in the app itself has also been containerized.</span></span>

<span data-ttu-id="746bf-147">arka uçta mikro hizmetleri kullanmak için tek parçalı bir uygulamayı @no__t. ](./media/breaking-up-monolith-with-backend-microservices.png)
**şekil 3-2**.</span><span class="sxs-lookup"><span data-stu-id="746bf-147">![Breaking up a monolithic app to use microservices in the back end.](./media/breaking-up-monolith-with-backend-microservices.png)
**Figure 3-2**.</span></span> <span data-ttu-id="746bf-148">Arka uçta mikro hizmetleri kullanmak için tek parçalı bir uygulamayı bölmek.</span><span class="sxs-lookup"><span data-stu-id="746bf-148">Breaking up a monolithic app to use microservices in the back end.</span></span>

<span data-ttu-id="746bf-149">Ayrı kapsayıcılar kullanılarak oluşturulan bulutta yerel uygulamalar, bir uygulamanın gerektirdiği kadar çok veya büyük bir şekilde dağıtılması özelliğinden yararlanır.</span><span class="sxs-lookup"><span data-stu-id="746bf-149">Cloud-native apps built using separate containers benefit from the ability to deploy as much or as little of an application as needed.</span></span> <span data-ttu-id="746bf-150">Her hizmet için uygun kaynakları olan düğümlerde tek tek hizmetler barındırılabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-150">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="746bf-151">Her hizmetin çalıştığı ortam sabittir, geliştirme, test ve üretim arasında paylaşılabilir ve kolayca sürümlenebilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-151">The environment each service runs in is immutable, can be shared between dev, test, and production, and can easily be versioned.</span></span> <span data-ttu-id="746bf-152">Uygulamanın farklı alanlarında, tek başına derleme zamanı bağımlılıkları değil, hizmetler arasında doğrudan çağrı veya ileti olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-152">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="746bf-153">Uygulamanın geri kalanında değişiklik gerektirmeden bu özellik veya beceri için en mantıklı bir teknoloji sunan teknolojiyi seçebilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-153">And any given part of the overall app can choose the technology that makes the most sense for that feature or capability without requiring changes to the rest of the app.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="746bf-154">Ölçeklendirme avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="746bf-154">What are the scaling benefits?</span></span>

<span data-ttu-id="746bf-155">Kapsayıcılarda oluşturulan hizmetler, Kubernetes gibi Orchestration araçları tarafından sunulan ölçeklendirme avantajlarından yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-155">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="746bf-156">Tasarım kapsayıcıları tarafından yalnızca kendileri hakkında bilgi sahibi.</span><span class="sxs-lookup"><span data-stu-id="746bf-156">By design containers only know about themselves.</span></span> <span data-ttu-id="746bf-157">Birlikte çalışması gereken birden çok kapsayıcıyla çalışmaya başladıktan sonra, bunları daha yüksek bir düzeyde düzenlemek biraz zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-157">Once you start to have multiple containers that need to work together, it can be worthwhile to organize them at a higher level.</span></span> <span data-ttu-id="746bf-158">Çok sayıda kapsayıcıyı ve ağ yapılandırması gibi paylaşılan bağımlılıklarını organize etmek, düzenleme araçlarının günü kaydetmek için nereden geldiği yerdir!</span><span class="sxs-lookup"><span data-stu-id="746bf-158">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="746bf-159">Kubernetes, Kapsayıcılı uygulamaların dağıtımını, ölçeklendirilmesini ve yönetimini otomatikleştirmek için tasarlanan bir kapsayıcı düzenleme platformudur.</span><span class="sxs-lookup"><span data-stu-id="746bf-159">Kubernetes is a container orchestration platform designed to automate deployment, scaling, and management of containerized applications.</span></span> <span data-ttu-id="746bf-160">Kapsayıcı gruplarının üstünde bir soyutlama katmanı oluşturur ve bunları *Pod*olarak düzenler.</span><span class="sxs-lookup"><span data-stu-id="746bf-160">It creates an abstraction layer on top of groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="746bf-161">*Düğüm*olarak adlandırılan çalışan makinelerdeki pods çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-161">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="746bf-162">Tüm düzenlenmiş Grup, *küme*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-162">The whole organized group is referred to as a *cluster*.</span></span> <span data-ttu-id="746bf-163">Şekil 3-3, bir Kubernetes kümesinin farklı bileşenlerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="746bf-163">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="746bf-164">![Kubernetes küme bileşenleri. ](./media/kubernetes-cluster-components.png)
**şekil 3-3**.</span><span class="sxs-lookup"><span data-stu-id="746bf-164">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="746bf-165">Kubernetes kümesi bileşenleri.</span><span class="sxs-lookup"><span data-stu-id="746bf-165">Kubernetes cluster components.</span></span>

<span data-ttu-id="746bf-166">Kubernetes, talepleri karşılamak için kümeleri ölçeklendirmeye yönelik yerleşik destek içerir.</span><span class="sxs-lookup"><span data-stu-id="746bf-166">Kubernetes has built-in support for scaling clusters to meet demand.</span></span> <span data-ttu-id="746bf-167">Kapsayıcılı mikro hizmetlerle birleştirilmiş bu, bulutta yerel uygulamalar sağlar ve gerektiğinde ek kaynaklarla isteğe bağlı ani artışlar hızla ve verimli bir şekilde yanıtlayabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-167">Combined with containerized micro-services, this provides cloud-native applications with the ability to quickly and efficiently respond to spikes in demand with additional resources when and where they're needed.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="746bf-168">Bildirime dayalı ve kesinlik</span><span class="sxs-lookup"><span data-stu-id="746bf-168">Declarative versus imperative</span></span>

<span data-ttu-id="746bf-169">Kubernetes hem bildirime dayalı hem de kesinlik temelli nesne yapılandırmasını destekler.</span><span class="sxs-lookup"><span data-stu-id="746bf-169">Kubernetes supports both declarative and imperative object configuration.</span></span> <span data-ttu-id="746bf-170">Zorunlu yaklaşım, Kubernetes 'in her adımın nasıl yapılacağını söyleyen çeşitli komutları çalıştırmayı içerir.</span><span class="sxs-lookup"><span data-stu-id="746bf-170">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="746bf-171">Bu görüntüyü *çalıştırın* .</span><span class="sxs-lookup"><span data-stu-id="746bf-171">*Run* this image.</span></span> <span data-ttu-id="746bf-172">Bu Pod öğesini *silin* .</span><span class="sxs-lookup"><span data-stu-id="746bf-172">*Delete* this pod.</span></span> <span data-ttu-id="746bf-173">Bu bağlantı noktasını *kullanıma sunun* .</span><span class="sxs-lookup"><span data-stu-id="746bf-173">*Expose* this port.</span></span> <span data-ttu-id="746bf-174">Bildirim temelli yaklaşımla, *ne yapmak* yerine *istediğinizi* açıklayan bir yapılandırma dosyası kullanırsınız ve Kubernetes istenen bitiş durumuna ulaşmak için ne yapılacağını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-174">With the declarative approach, you use a configuration file that describes *what you want* instead of *what to do* and Kubernetes figures out what to do to achieve the desired end state.</span></span> <span data-ttu-id="746bf-175">Kümenizi zaten zorunlu komutları kullanarak yapılandırdıysanız, `kubectl get svc SERVICENAME -o yaml > service.yaml` ' ı kullanarak bir bildirime dayalı bildirimi dışarı aktarabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-175">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="746bf-176">Bu, şunun gibi bir bildirim dosyası oluşturur:</span><span class="sxs-lookup"><span data-stu-id="746bf-176">This will produce a manifest file like this one:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="746bf-177">Bildirim temelli yapılandırma kullanırken, yapılandırma dosyalarınızın bulunduğu klasöre karşı `kubectl diff -f FOLDERNAME` kullanarak kaydedilmeden önce yapılacak değişikliklerin önizlemesini yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-177">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="746bf-178">Değişiklikleri uygulamak istediğdiğinizden emin olduktan sonra `kubectl apply -f FOLDERNAME` ' ı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="746bf-178">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="746bf-179">Bir klasör hiyerarşisini yinelemeli olarak işlemek için `-R` ekleyin.</span><span class="sxs-lookup"><span data-stu-id="746bf-179">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="746bf-180">Hizmetlere ek olarak, *dağıtımlar*gibi diğer Kubernetes özellikleri için bildirim temelli yapılandırma kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-180">In addition to services, you can use declarative configuration for other Kubernetes features, such as *deployments*.</span></span> <span data-ttu-id="746bf-181">Bildirim temelli dağıtımlar, dağıtım denetleyicileri tarafından küme kaynaklarını güncelleştirmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-181">Declarative deployments are used by deployment controllers to update cluster resources.</span></span> <span data-ttu-id="746bf-182">Dağıtımlar yeni değişiklikleri almak, daha fazla yük desteklemek üzere ölçeği genişletmek veya önceki bir düzeltmeye geri dönmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-182">Deployments are used to roll out new changes, scale up to support more load, or roll back to a previous revision.</span></span> <span data-ttu-id="746bf-183">Bir küme kararsız durumdaysa, bildirim temelli dağıtımlar otomatik olarak kümeyi istenen bir duruma getirmek için bir mekanizma sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-183">If a cluster is unstable, declarative deployments provide a mechanism for automatically bringing the cluster back to a desired state.</span></span>

<span data-ttu-id="746bf-184">Bildirim temelli yapılandırma kullanmak, altyapının uygulama kodu ile birlikte denetlenebilen ve sürümü oluşturulmuş bir kod olarak temsil etmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="746bf-184">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="746bf-185">Bu, geliştirilmiş değişiklik denetimi ve kaynak denetim değişikliklerine bağlı bir yapı ve dağıtım işlem hattı kullanarak sürekli dağıtım için daha iyi destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-185">This provides improved change control and better support for continuous deployment using a build and deploy pipeline tied to source control changes.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="746bf-186">Kapsayıcılar ve düzenleyiciler için hangi senaryolar idealdir?</span><span class="sxs-lookup"><span data-stu-id="746bf-186">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="746bf-187">Aşağıdaki senaryolar kapsayıcıları ve düzenlemeleri kullanmak için idealdir.</span><span class="sxs-lookup"><span data-stu-id="746bf-187">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="746bf-188">Yüksek çalışma süresi ve ölçeklenebilirlik gerektiren uygulamalar</span><span class="sxs-lookup"><span data-stu-id="746bf-188">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="746bf-189">Yüksek çalışma süresi ve ölçeklenebilirlik gereksinimleri olan bireysel uygulamalar, mikro hizmetler, kapsayıcılar ve düzenleyicilerin kullanıldığı bulutta yerel mimariler için ideal adaylardır.</span><span class="sxs-lookup"><span data-stu-id="746bf-189">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="746bf-190">Bu uygulamalar, sürümlü ortamlar kullanılarak kapsayıcılarda geliştirilebilir, üretime geçmeden önce kapsamlı bir şekilde test edilebilir ve sıfır kapalı kalma süresiyle üretime dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-190">These applications can be developed in containers using versioned environments, can be extensively tested before going to production, and can be deployed to production with zero downtime.</span></span> <span data-ttu-id="746bf-191">Kubernetes kümelerinin kullanımı, bu tür uygulamaların talep üzerine ölçeklenmesini ve düğüm hatalarından otomatik olarak kurtarılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-191">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="746bf-192">Çok sayıda uygulama</span><span class="sxs-lookup"><span data-stu-id="746bf-192">Large numbers of applications</span></span>

<span data-ttu-id="746bf-193">Ve daha sonra kapsayıcılardan ve düzenleyicilerinden çok sayıda uygulama avantajı olması gereken kuruluşlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-193">Organizations that deploy and must subsequently maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="746bf-194">Kapsayıcılı ortamları ve Kubernetes kümelerini ayarlamanın en ön çabası, birincil olarak sabit bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="746bf-194">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="746bf-195">Bireysel uygulamaların dağıtımı, bakımını yapma ve güncelleştirme, sürdürülmesi gereken uygulama sayısına göre farklılık gösteren bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="746bf-195">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications that must be maintained.</span></span> <span data-ttu-id="746bf-196">Belirli bir oldukça az sayıda uygulamanın ötesinde, özel uygulamaların korunmasının karmaşıklığı kapsayıcıları ve düzenlemeleri kullanarak bir çözüm uygulama masrafını aşmaktadır.</span><span class="sxs-lookup"><span data-stu-id="746bf-196">Beyond a certain fairly small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="746bf-197">Kapsayıcıları ve düzenlemeleri kullanmaktan ne zaman kaçınmalısınız?</span><span class="sxs-lookup"><span data-stu-id="746bf-197">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="746bf-198">Uygulamanızı, on Iki öğeli uygulama prensipini takip etmek veya derlemenize izin vermenizdir, büyük olasılıkla kapsayıcılardan ve düzenleyicilerinden Kaçınmaktan daha iyi bir şekilde başlayacaksınız.</span><span class="sxs-lookup"><span data-stu-id="746bf-198">If you're unwilling or unable to build your application following Twelve-Factor App principles, you'll probably be better off avoiding containers and orchestrators.</span></span> <span data-ttu-id="746bf-199">Bu gibi durumlarda, belirli işlevsellik parçalarını ayrı kapsayıcılara veya hatta sunucusuz işlevlere taşıyabilmeniz için bir VM tabanlı barındırma platformu veya belki de büyük olasılıkla bir karma sistemle ilerlemek en iyi hale gelebilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-199">In these cases, it may be best to move forward with a VM-based hosting platform, or possibly some hybrid system in which you can spin off certain pieces of functionality into separate containers or even serverless functions.</span></span> 

## <a name="development-resources"></a><span data-ttu-id="746bf-200">Geliştirme kaynakları</span><span class="sxs-lookup"><span data-stu-id="746bf-200">Development resources</span></span>

<span data-ttu-id="746bf-201">Bu bölümde, bir sonraki uygulamanız için kapsayıcıları ve düzenlemeleri kullanmaya başlamanıza yardımcı olabilecek geliştirme kaynaklarının kısa bir listesi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="746bf-201">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="746bf-202">Bulut Yerel mikro hizmetleri mimari uygulamanızı nasıl tasarlayacağımızı öğrenmek istiyorsanız bu kitabın yardımcı, [.net mikro hizmetleri: Kapsayıcılı .NET uygulamaları Için mimari](https://aka.ms/microservicesebook)makalesini okuyun.</span><span class="sxs-lookup"><span data-stu-id="746bf-202">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://aka.ms/microservicesebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="746bf-203">Yerel Kubernetes geliştirme</span><span class="sxs-lookup"><span data-stu-id="746bf-203">Local Kubernetes Development</span></span>

<span data-ttu-id="746bf-204">Kubernetes dağıtımları üretim ortamlarında harika bir değer sağlar, ancak bunları yerel olarak da çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-204">Kubernetes deployments provide great value in production environments, but you can also run them locally.</span></span> <span data-ttu-id="746bf-205">Çoğu zaman ayrı uygulamalarda veya mikro hizmetlerde bağımsız olarak çalışabilmeniz için oldukça iyi olabiliyor olsa da, bazen üretime dağıtıldığında çalıştırılacak şekilde tüm sistemi yerel olarak çalıştırabilmenizde yarar vardır.</span><span class="sxs-lookup"><span data-stu-id="746bf-205">Although much of the time it's good to be able to work on individual apps or microservices independently, sometimes it's good to be able to run the whole system locally just as it will run when deployed to production.</span></span> <span data-ttu-id="746bf-206">Bunu yapmanın birkaç yolu vardır, ikisi de Minikube ve Docker Desktop.</span><span class="sxs-lookup"><span data-stu-id="746bf-206">There are several ways to achieve this, two of which are Minikube and Docker Desktop.</span></span> <span data-ttu-id="746bf-207">Visual Studio, Docker geliştirmesi için de araç sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-207">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="746bf-208">Minikube</span><span class="sxs-lookup"><span data-stu-id="746bf-208">Minikube</span></span>

<span data-ttu-id="746bf-209">Minikube nedir?</span><span class="sxs-lookup"><span data-stu-id="746bf-209">What is Minikube?</span></span> <span data-ttu-id="746bf-210">Minikube projesi, "Minikube macOS, Linux ve Windows üzerinde yerel bir Kubernetes kümesi uygular" diyor.</span><span class="sxs-lookup"><span data-stu-id="746bf-210">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="746bf-211">Birincil hedefleri, "yerel Kubernetes uygulama geliştirmesi için en iyi araç olacak ve sığan Kubernetes özelliklerini desteklemeye yöneliktir."</span><span class="sxs-lookup"><span data-stu-id="746bf-211">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="746bf-212">Minikube yükleme Docker 'dan ayrıdır, ancak Minikube, Docker Desktop 'ın desteklediğinden farklı hiper yöneticileri destekler.</span><span class="sxs-lookup"><span data-stu-id="746bf-212">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="746bf-213">Aşağıdaki Kubernetes özellikleri şu anda Minikube tarafından desteklenmektedir:</span><span class="sxs-lookup"><span data-stu-id="746bf-213">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="746bf-214">DNS</span><span class="sxs-lookup"><span data-stu-id="746bf-214">DNS</span></span>
- <span data-ttu-id="746bf-215">NodePorts</span><span class="sxs-lookup"><span data-stu-id="746bf-215">NodePorts</span></span>
- <span data-ttu-id="746bf-216">ConfigMaps ve gizlilikler</span><span class="sxs-lookup"><span data-stu-id="746bf-216">ConfigMaps and secrets</span></span>
- <span data-ttu-id="746bf-217">Panolar</span><span class="sxs-lookup"><span data-stu-id="746bf-217">Dashboards</span></span>
- <span data-ttu-id="746bf-218">Kapsayıcı çalışma zamanları: Docker, RKT, CRı-O ve containerd</span><span class="sxs-lookup"><span data-stu-id="746bf-218">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="746bf-219">Kapsayıcı ağ arabirimini etkinleştirme (CNı)</span><span class="sxs-lookup"><span data-stu-id="746bf-219">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="746bf-220">Giriş</span><span class="sxs-lookup"><span data-stu-id="746bf-220">Ingress</span></span>

<span data-ttu-id="746bf-221">Minikube yükledikten sonra, bir görüntüyü indiren ve yerel Kubernetes kümesini Başlatan `minikube start` komutunu çalıştırarak hızlı bir şekilde kullanmaya başlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-221">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="746bf-222">Küme başlatıldıktan sonra, standart Kubernetes `kubectl` komutlarını kullanarak onunla etkileşime geçin.</span><span class="sxs-lookup"><span data-stu-id="746bf-222">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="746bf-223">Docker Masaüstü</span><span class="sxs-lookup"><span data-stu-id="746bf-223">Docker Desktop</span></span>

<span data-ttu-id="746bf-224">Ayrıca, Kubernetes ile doğrudan Windows 'daki Docker Desktop 'tan da çalışabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-224">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="746bf-225">Windows kapsayıcıları kullanıyorsanız bu tek seçenektir ve Windows olmayan kapsayıcılar için harika bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="746bf-225">This is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="746bf-226">Docker Desktop 'tan çalışan Kubernetes 'i yapılandırmak için standart Docker Desktop yapılandırma uygulaması kullanılır.</span><span class="sxs-lookup"><span data-stu-id="746bf-226">The standard Docker Desktop configuration app is used to configure Kubernetes running from Docker Desktop.</span></span>

![Docker Desktop 'ta Kubernetes 'i yapılandırma](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="746bf-228">**Şekil 3-4**.</span><span class="sxs-lookup"><span data-stu-id="746bf-228">**Figure 3-4**.</span></span> <span data-ttu-id="746bf-229">Docker Desktop 'ta Kubernetes 'i yapılandırma.</span><span class="sxs-lookup"><span data-stu-id="746bf-229">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="746bf-230">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak yapılandırmak ve çalıştırmak için en popüler araç olan bir araçtır.</span><span class="sxs-lookup"><span data-stu-id="746bf-230">Docker Desktop is already the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="746bf-231">Docker Desktop ile çalışırken, üretime dağıtacağınız Docker kapsayıcı görüntüleri kümesine göre yerel olarak geliştirme yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-231">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="746bf-232">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak derlemek, test etmek ve teslim etmek üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="746bf-232">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="746bf-233">Görüntüler Azure Container Registry veya Docker Hub gibi bir görüntü kayıt defterine gönderildikten sonra Azure Kubernetes hizmeti (AKS) gibi hizmetler üretimde uygulamayı yönetir.</span><span class="sxs-lookup"><span data-stu-id="746bf-233">Once the images have been shipped to an image registry like Azure Container Registry or Docker Hub, then services like Azure Kubernetes Service (AKS) manage the application in production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="746bf-234">Visual Studio Docker Araçları</span><span class="sxs-lookup"><span data-stu-id="746bf-234">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="746bf-235">Visual Studio, Web uygulamaları için Docker geliştirmeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="746bf-235">Visual Studio supports Docker development for web applications.</span></span> <span data-ttu-id="746bf-236">Yeni bir ASP.NET Core uygulaması oluşturduğunuzda, Şekil 3-5 ' de gösterildiği gibi, proje oluşturma işleminin bir parçası olarak onu Docker desteğiyle yapılandırma seçeneği sunulur.</span><span class="sxs-lookup"><span data-stu-id="746bf-236">When you create a new ASP.NET Core application, you're given the option to configure it with Docker support as part of the project creation process, as shown in Figure 3-5.</span></span>

![Visual Studio Docker desteğini etkinleştir](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="746bf-238">**Şekil 3-5**.</span><span class="sxs-lookup"><span data-stu-id="746bf-238">**Figure 3-5**.</span></span> <span data-ttu-id="746bf-239">Visual Studio Docker desteğini etkinleştir</span><span class="sxs-lookup"><span data-stu-id="746bf-239">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="746bf-240">Bu seçenek belirlendiğinde, proje kökünde bir `Dockerfile` ile oluşturulur ve bu, uygulamayı bir Docker kapsayıcısında derlemek ve barındırmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="746bf-240">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="746bf-241">Şekil 3-6 ' de örnek Dockerfile gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="746bf-241">An example Dockerfile is shown in Figure 3-6.</span></span>

```docker
FROM mcr.microsoft.com/dotnet/core/aspnet:3.0-stretch-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.0-stretch AS build
WORKDIR /src
COPY ["WebApplication3/WebApplication3.csproj", "WebApplication3/"]
RUN dotnet restore "WebApplication3/WebApplication3.csproj"
COPY . .
WORKDIR "/src/WebApplication3"
RUN dotnet build "WebApplication3.csproj" -c Release -o /app

FROM build AS publish
RUN dotnet publish "WebApplication3.csproj" -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT ["dotnet", "WebApplication3.dll"]
```

<span data-ttu-id="746bf-242">**Şekil 3-6**.</span><span class="sxs-lookup"><span data-stu-id="746bf-242">**Figure 3-6**.</span></span> <span data-ttu-id="746bf-243">Visual Studio tarafından oluşturulan Dockerfile</span><span class="sxs-lookup"><span data-stu-id="746bf-243">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="746bf-244">Uygulamanın çalışması için varsayılan davranış, Docker 'ı kullanmak üzere yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="746bf-244">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="746bf-245">Şekil 3-7, Docker desteği eklenmiş şekilde oluşturulan yeni bir ASP.NET Core projesinden kullanılabilir farklı çalıştırma seçeneklerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="746bf-245">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker çalıştırma seçenekleri](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="746bf-247">**Şekil 3-7**.</span><span class="sxs-lookup"><span data-stu-id="746bf-247">**Figure 3-7**.</span></span> <span data-ttu-id="746bf-248">Visual Studio Docker çalıştırma seçenekleri</span><span class="sxs-lookup"><span data-stu-id="746bf-248">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="746bf-249">[Azure dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) , yerel geliştirmeye ek olarak, birden çok geliştiricinin Azure 'Da kendi Kubernetes yapılandırmalarına göre çalışması için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="746bf-249">In addition to local development, [Azure Dev Spaces](https://docs.microsoft.com/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="746bf-250">Şekil 3-7 ' de görebileceğiniz gibi, uygulamayı Azure Dev Spaces de çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-250">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="746bf-251">ASP.NET Core uygulamanıza Docker desteği eklememeniz durumunda, daha sonra her zaman ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-251">If you don't add Docker support to your ASP.NET Core application when you create it, you can always add it later.</span></span> <span data-ttu-id="746bf-252">Visual Studio Çözüm Gezgini, Şekil 3-8 ' de gösterildiği gibi projeye sağ tıklayın ve  > **Docker desteği** **Ekle**' yi seçin.</span><span class="sxs-lookup"><span data-stu-id="746bf-252">From the Visual Studio Solution Explorer, right click on the project and select **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio Docker desteği ekle](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="746bf-254">**Şekil 3-8**.</span><span class="sxs-lookup"><span data-stu-id="746bf-254">**Figure 3-8**.</span></span> <span data-ttu-id="746bf-255">Visual Studio Docker desteği ekle</span><span class="sxs-lookup"><span data-stu-id="746bf-255">Visual Studio Add Docker Support</span></span>

<span data-ttu-id="746bf-256">Docker desteğinin yanı sıra, Şekil 3-8 ' de de gösterilen kapsayıcı düzenleme desteğini de ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="746bf-256">In addition to Docker support, you can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="746bf-257">Varsayılan olarak Orchestrator, Kubernetes ve Held kullanır.</span><span class="sxs-lookup"><span data-stu-id="746bf-257">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="746bf-258">Orchestrator 'ı seçtikten sonra proje köküne bir `azds.yaml` dosyası eklenir ve uygulamayı yapılandırmak ve Kubernetes 'e dağıtmak için kullanılan Held grafiklerini içeren bir `charts` klasörü eklenir.</span><span class="sxs-lookup"><span data-stu-id="746bf-258">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="746bf-259">Şekil 3-9 yeni bir projedeki sonuç dosyalarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="746bf-259">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio Orchestrator desteği ekle](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="746bf-261">**Şekil 3-9**.</span><span class="sxs-lookup"><span data-stu-id="746bf-261">**Figure 3-9**.</span></span> <span data-ttu-id="746bf-262">Visual Studio Orchestrator desteği ekle</span><span class="sxs-lookup"><span data-stu-id="746bf-262">Visual Studio Add Orchestrator Support</span></span>

## <a name="references"></a><span data-ttu-id="746bf-263">Referanslar</span><span class="sxs-lookup"><span data-stu-id="746bf-263">References</span></span>

- [<span data-ttu-id="746bf-264">Kubernetes nedir?</span><span class="sxs-lookup"><span data-stu-id="746bf-264">What is Kubernetes?</span></span>](https://blog.newrelic.com/engineering/what-is-kubernetes/)
- [<span data-ttu-id="746bf-265">Minikube ile Kubernetes yükleme</span><span class="sxs-lookup"><span data-stu-id="746bf-265">Installing Kubernetes with Minikube</span></span>](https://kubernetes.io/docs/setup/learning-environment/minikube/)
- [<span data-ttu-id="746bf-266">MiniKube vs Docker Masaüstü</span><span class="sxs-lookup"><span data-stu-id="746bf-266">MiniKube vs Docker Desktop</span></span>](https://medium.com/containers-101/local-kubernetes-for-windows-minikube-vs-docker-desktop-25a1c6d3b766)
- [<span data-ttu-id="746bf-267">Docker için Visual Studio Araçları</span><span class="sxs-lookup"><span data-stu-id="746bf-267">Visual Studio Tools for Docker</span></span>](https://docs.microsoft.com/dotnet/standard/containerized-lifecycle-architecture/design-develop-containerized-apps/visual-studio-tools-for-docker)

>[!div class="step-by-step"]
><span data-ttu-id="746bf-268">[Önceki](scale-applications.md)
>[İleri](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="746bf-268">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
