---
title: Dizin ağacı yla nasıl yinelene - C# Programlama Kılavuzu
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: be3931a23e7a88affcf4d0abf617ec00bd35297a
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "75712266"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="218d0-102">Dizin ağacı (C# Programlama Kılavuzu) aracılığıyla nasıl yineler</span><span class="sxs-lookup"><span data-stu-id="218d0-102">How to iterate through a directory tree (C# Programming Guide)</span></span>
<span data-ttu-id="218d0-103">"Bir dizin ağacını yinele" deyimi, iç içe geçen her alt dizindeki her dosyaya, belirli bir kök klasörü altında herhangi bir derinliğe erişmek anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="218d0-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="218d0-104">Her dosyayı mutlaka açmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="218d0-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="218d0-105">Dosyanın veya alt dizinin `string`adını alabilir veya bir <xref:System.IO.FileInfo?displayProperty=nameWithType> veya <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> nesne biçiminde ek bilgiler alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="218d0-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="218d0-106">Windows'da "dizin" ve "klasör" terimleri birbirinin yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="218d0-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="218d0-107">Çoğu belge ve kullanıcı arabirimi metni "klasör" terimini kullanır, ancak .NET Framework sınıf kitaplığı "dizin" terimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="218d0-107">Most documentation and user interface text uses the term "folder," but the .NET Framework class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="218d0-108">Belirtilen kök altında tüm dizinler için erişim izinlerine sahip olduğunuzu kesin olarak bildiğiniz en `System.IO.SearchOption.AllDirectories` basit durumda, bayrağı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="218d0-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="218d0-109">Bu bayrak, belirtilen desenle eşleşen iç içe geçen tüm alt dizinleri döndürür.</span><span class="sxs-lookup"><span data-stu-id="218d0-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="218d0-110">Aşağıdaki örnekte, bu bayrağın nasıl kullanılacağı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="218d0-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="218d0-111">Bu yaklaşımdaki zayıflık, belirtilen kök altındaki alt dizinlerden herhangi <xref:System.IO.DirectoryNotFoundException> <xref:System.UnauthorizedAccessException>birinin bir veya , tüm yöntembaşarısız olur ve hiçbir dizin döndürür neden olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="218d0-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="218d0-112">Yöntemi kullandığınızda <xref:System.IO.DirectoryInfo.GetFiles%2A> aynı durum geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="218d0-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="218d0-113">Belirli alt klasörlerde bu özel durumları işlemek zorundaysanız, aşağıdaki örneklerde gösterildiği gibi dizin ağacını el ile yürümeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="218d0-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="218d0-114">Bir dizin ağacında el ile yürüdüğünüzde, önce alt dizinleri *(ön sipariş geçişi)* veya önce dosyaları *(sipariş sonrası geçiş)* işleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="218d0-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="218d0-115">Ön sipariş geçişi gerçekleştirirseniz, doğrudan o klasörün kendisinde bulunan dosyaları gerçekleştirmeden önce geçerli klasörün altındaki tüm ağacı yürütür.</span><span class="sxs-lookup"><span data-stu-id="218d0-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="218d0-116">Bu belgenin sonraki örnekleri sipariş sonrası geçiş gerçekleştirir, ancak bunları ön sipariş geçiş gerçekleştirmek için kolayca değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="218d0-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="218d0-117">Başka bir seçenek özyineleme veya yığın tabanlı geçiş kullanmak olup olmadığıdır.</span><span class="sxs-lookup"><span data-stu-id="218d0-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="218d0-118">Bu belgenin sonraki örnekleri her iki yaklaşımı da göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="218d0-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="218d0-119">Dosya ve klasörlerde çeşitli işlemler gerçekleştirmeniz gerekiyorsa, işlemi tek bir temsilci kullanarak çağırabileceğiniz ayrı işlevlere dönüştürerek bu örnekleri modüle edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="218d0-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="218d0-120">NTFS dosya sistemleri *kavşak noktaları,* *sembolik bağlantılar*ve sabit *bağlantılar*şeklinde *reparse noktaları* içerebilir.</span><span class="sxs-lookup"><span data-stu-id="218d0-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="218d0-121">.NET Framework gibi <xref:System.IO.DirectoryInfo.GetFiles%2A> yöntemler <xref:System.IO.DirectoryInfo.GetDirectories%2A> ve bir reparse noktası altında herhangi bir alt dizinleri döndürmez.</span><span class="sxs-lookup"><span data-stu-id="218d0-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="218d0-122">Bu davranış, iki reparse noktası birbirine atıfta bulunduğunda sonsuz bir döngüye girme riskine karşı koruma sağlar.</span><span class="sxs-lookup"><span data-stu-id="218d0-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="218d0-123">Genel olarak, dosyaları istemeden değiştirmediğinizden veya silmediğinizden emin olmak için telafi noktalarıyla uğraşırken çok dikkatli olmalısınız.</span><span class="sxs-lookup"><span data-stu-id="218d0-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="218d0-124">Reparse noktaları üzerinde hassas denetime ihtiyacınız varsa, uygun Win32 dosya sistemi yöntemlerini doğrudan çağırmak için platform çağrısı veya yerel kodu kullanın.</span><span class="sxs-lookup"><span data-stu-id="218d0-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="218d0-125">Örnek</span><span class="sxs-lookup"><span data-stu-id="218d0-125">Example</span></span>  
 <span data-ttu-id="218d0-126">Aşağıdaki örnek, özyineleme kullanarak dizin ağacının nasıl yürüydüğünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="218d0-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="218d0-127">Özyinelemeli yaklaşım zariftir, ancak dizin ağacı büyük ve derin iç içe yse yığın taşma özel durumu neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="218d0-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="218d0-128">İşlenen belirli özel durumlar ve her dosya veya klasörde gerçekleştirilen belirli eylemler yalnızca örnek olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="218d0-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="218d0-129">Bu kodu, özel gereksinimlerinizi karşılamak üzere değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="218d0-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="218d0-130">Daha fazla bilgi için koddaki yorumlara bakın.</span><span class="sxs-lookup"><span data-stu-id="218d0-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  
  
## <a name="example"></a><span data-ttu-id="218d0-131">Örnek</span><span class="sxs-lookup"><span data-stu-id="218d0-131">Example</span></span>  
 <span data-ttu-id="218d0-132">Aşağıdaki örnek, özyineleme kullanmadan dizin ağacındaki dosya ve klasörler aracılığıyla nasıl yinelenebildiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="218d0-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="218d0-133">Bu teknik, <xref:System.Collections.Generic.Stack%601> ilk çıkış (LIFO) yığınının sonuncusu olan genel toplama türünü kullanır.</span><span class="sxs-lookup"><span data-stu-id="218d0-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="218d0-134">İşlenen belirli özel durumlar ve her dosya veya klasörde gerçekleştirilen belirli eylemler yalnızca örnek olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="218d0-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="218d0-135">Bu kodu, özel gereksinimlerinizi karşılamak üzere değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="218d0-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="218d0-136">Daha fazla bilgi için koddaki yorumlara bakın.</span><span class="sxs-lookup"><span data-stu-id="218d0-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  
  
 <span data-ttu-id="218d0-137">Uygulamanızın açma izni olup olmadığını belirlemek için her klasörü sınamak genellikle çok zaman alır.</span><span class="sxs-lookup"><span data-stu-id="218d0-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="218d0-138">Bu nedenle, kod örneği işlemin o bölümünü bir `try/catch` blokta kapsar.</span><span class="sxs-lookup"><span data-stu-id="218d0-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="218d0-139">Bir klasöre `catch` erişiminiz engellendiğinde, izinlerinizi yükseltmeye ve ardından yeniden erişmeye çalışacak şekilde bloğu değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="218d0-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="218d0-140">Kural olarak, yalnızca uygulamanızı bilinmeyen bir durumda bırakmadan işleyeceğiniz özel durumları yakalayın.</span><span class="sxs-lookup"><span data-stu-id="218d0-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="218d0-141">Bir dizin ağacının içeriğini bellekte veya diskte depolamanız gerekiyorsa, en iyi <xref:System.IO.FileSystemInfo.FullName%2A> seçenek her `string`dosya için yalnızca özelliği (tür) depolamaktır.</span><span class="sxs-lookup"><span data-stu-id="218d0-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="218d0-142">Daha sonra gerektiğinde yeni <xref:System.IO.FileInfo> veya nesne <xref:System.IO.DirectoryInfo> oluşturmak veya ek işleme gerektiren herhangi bir dosyayı açmak için bu dizeyi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="218d0-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="218d0-143">Güçlü Programlama</span><span class="sxs-lookup"><span data-stu-id="218d0-143">Robust Programming</span></span>  
 <span data-ttu-id="218d0-144">Sağlam dosya yineleme kodu, dosya sisteminin birçok karmaşıklığını dikkate almalıdır.</span><span class="sxs-lookup"><span data-stu-id="218d0-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="218d0-145">Windows dosya sistemi hakkında daha fazla bilgi için [NTFS genel bakış](/windows-server/storage/file-server/ntfs-overview)bakın.</span><span class="sxs-lookup"><span data-stu-id="218d0-145">For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="218d0-146">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="218d0-146">See also</span></span>

- <xref:System.IO>
- [<span data-ttu-id="218d0-147">LINQ ve Dosya Dizinleri</span><span class="sxs-lookup"><span data-stu-id="218d0-147">LINQ and File Directories</span></span>](../concepts/linq/linq-and-file-directories.md)
- [<span data-ttu-id="218d0-148">Dosya Sistemi ve Kayıt Defteri (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="218d0-148">File System and the Registry (C# Programming Guide)</span></span>](./index.md)
