---
title: Elevation of Privilege (Ayrıcalık Yükseltme)
ms.date: 03/30/2017
helpviewer_keywords:
- elevation of privilege [WCF]
- security [WCF], elevation of privilege
ms.assetid: 146e1c66-2a76-4ed3-98a5-fd77851a06d9
ms.openlocfilehash: 9c62e11eedaa3fa194522695a33bccf210d390df
ms.sourcegitcommit: bc293b14af795e0e999e3304dd40c0222cf2ffe4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/26/2020
ms.locfileid: "96254226"
---
# <a name="elevation-of-privilege"></a><span data-ttu-id="37d6d-102">Elevation of Privilege (Ayrıcalık Yükseltme)</span><span class="sxs-lookup"><span data-stu-id="37d6d-102">Elevation of Privilege</span></span>

<span data-ttu-id="37d6d-103">*Ayrıcalık yükselmesi,* başlangıçta verilen bir saldırgan yetkilendirme izinleri vermesinden kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="37d6d-103">*Elevation of privilege* results from giving an attacker authorization permissions beyond those initially granted.</span></span> <span data-ttu-id="37d6d-104">Örneğin, ayrıcalık "salt okuma" olan bir saldırgan, "okuma ve yazma" iznini dahil etmek için bu ayarı bir şekilde yükseltir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-104">For example, an attacker with a privilege set of "read only" permissions somehow elevates the set to include "read and write."</span></span>  
  
## <a name="trusted-sts-should-sign-saml-token-claims"></a><span data-ttu-id="37d6d-105">Güvenilen STS, SAML belirteci taleplerini Imzamalıdır</span><span class="sxs-lookup"><span data-stu-id="37d6d-105">Trusted STS Should Sign SAML Token Claims</span></span>  

 <span data-ttu-id="37d6d-106">Güvenlik onaylama işlemi biçimlendirme dili (SAML) belirteci, verilen belirteçler için varsayılan tür olan genel bir XML belirtecidir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-106">A Security Assertions Markup Language (SAML) token is a generic XML token that is the default type for issued tokens.</span></span> <span data-ttu-id="37d6d-107">Bir SAML belirteci, son Web hizmetinin tipik bir alışverişte güvendiği bir güvenlik belirteci hizmeti (STS) tarafından oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-107">A SAML token can be constructed by a Security Token Service (STS) that the end Web service trusts in a typical exchange.</span></span> <span data-ttu-id="37d6d-108">SAML belirteçleri deyimlerde talepler içerir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-108">SAML tokens contain claims in statements.</span></span> <span data-ttu-id="37d6d-109">Bir saldırgan, talepleri geçerli bir belirteçle kopyalayabilir, yeni bir SAML belirteci oluşturabilir ve farklı bir veren ile imzalayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="37d6d-109">An attacker may copy the claims from a valid token, create a new SAML token, and sign it with a different issuer.</span></span> <span data-ttu-id="37d6d-110">Amaç, sunucunun verenler doğrulama yapıp yapmadığını belirlemektir ve yoksa, güvenilir bir STS tarafından sağlananlar dışında ayrıcalıklara izin veren SAML belirteçleri oluşturmak için zayıf kullanımı kullanır.</span><span class="sxs-lookup"><span data-stu-id="37d6d-110">The intent is to determine whether the server is validating issuers and, if not, utilize the weakness to construct SAML tokens that allow privileges beyond those intended by a trusted STS.</span></span>  
  
 <span data-ttu-id="37d6d-111"><xref:System.IdentityModel.Tokens.SamlAssertion>Sınıfı, BIR SAML belirteci içinde bulunan dijital imzayı doğrular ve varsayılan değer, <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> SAML belirteçlerinin, sınıfının, <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> olarak ayarlandığı zaman geçerli olan bir X. 509.440 sertifikası tarafından imzalanmasını gerektirir <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust> .</span><span class="sxs-lookup"><span data-stu-id="37d6d-111">The <xref:System.IdentityModel.Tokens.SamlAssertion> class verifies the digital signature contained within a SAML token, and the default <xref:System.IdentityModel.Selectors.SamlSecurityTokenAuthenticator> requires that SAML tokens be signed by an X.509 certificate that is valid when the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential.CertificateValidationMode%2A> of the <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> class is set to <xref:System.ServiceModel.Security.X509CertificateValidationMode.ChainTrust>.</span></span> <span data-ttu-id="37d6d-112">`ChainTrust` SAML belirtecinin vereni güvenilir olup olmadığını anlamak için tek başına modu yetersiz.</span><span class="sxs-lookup"><span data-stu-id="37d6d-112">`ChainTrust` mode alone is insufficient to determine whether the issuer of the SAML token is trusted.</span></span> <span data-ttu-id="37d6d-113">Daha ayrıntılı bir güven modeli gerektiren hizmetler, verilen belirteç kimlik doğrulaması tarafından üretilen talep kümelerinin vereni denetlemek için yetkilendirme ve zorlama ilkelerini kullanabilir ya da <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> izin verilen imzalama sertifikaları kümesini kısıtlamak için üzerindeki X. 509.952 doğrulama ayarlarını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37d6d-113">Services that require a more granular trust model can either use authorization and enforcement policies to check the issuer of the claim sets produced by issued token authentication or use the X.509 validation settings on <xref:System.ServiceModel.Security.IssuedTokenServiceCredential> to restrict the set of allowed signing certificates.</span></span> <span data-ttu-id="37d6d-114">Daha fazla bilgi için bkz. kimlik modeli ve [Federasyon ve verilen belirteçlerle](federation-and-issued-tokens.md) [talepleri yönetme ve yetkilendirme](managing-claims-and-authorization-with-the-identity-model.md) .</span><span class="sxs-lookup"><span data-stu-id="37d6d-114">For more information, see [Managing Claims and Authorization with the Identity Model](managing-claims-and-authorization-with-the-identity-model.md) and [Federation and Issued Tokens](federation-and-issued-tokens.md).</span></span>  
  
## <a name="switching-identity-without-a-security-context"></a><span data-ttu-id="37d6d-115">Kimliği güvenlik bağlamı olmadan değiştirme</span><span class="sxs-lookup"><span data-stu-id="37d6d-115">Switching Identity Without a Security Context</span></span>  

 <span data-ttu-id="37d6d-116">Aşağıdakiler yalnızca WinFX için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-116">The following applies only to WinFX.</span></span>  
  
 <span data-ttu-id="37d6d-117">İstemci ve sunucu arasında bağlantı kurulduktan sonra, bir durum dışında istemcinin kimliği değişmez: aşağıdaki koşulların tümü doğruysa WCF istemcisi açıldıktan sonra:</span><span class="sxs-lookup"><span data-stu-id="37d6d-117">When a connection is established between a client and server, the identity of the client does not change, except in one situation: after the WCF client is opened, if all of the following conditions are true:</span></span>  
  
- <span data-ttu-id="37d6d-118">Bir güvenlik bağlamı oluşturma yordamları (bir taşıma güvenlik oturumu veya ileti güvenlik oturumu kullanarak) kapalı olur ( <xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> `false` ileti güvenliği veya aktarım, aktarım güvenliği durumunda güvenlik oturumları oluşturma yeteneğine sahip olmayan bir durumda olarak ayarlanır).</span><span class="sxs-lookup"><span data-stu-id="37d6d-118">The procedures to establish a security context (using a transport security session or message security session) is switched off (<xref:System.ServiceModel.NonDualMessageSecurityOverHttp.EstablishSecurityContext%2A> property is set to `false` in case of message security or transport not capable of establishing security sessions is used in transport security case.</span></span> <span data-ttu-id="37d6d-119">HTTPS, söz konusu taşımanın bir örneğidir).</span><span class="sxs-lookup"><span data-stu-id="37d6d-119">HTTPS is one example of such transport).</span></span>  
  
- <span data-ttu-id="37d6d-120">Windows kimlik doğrulaması kullanıyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="37d6d-120">You are using Windows authentication.</span></span>  
  
- <span data-ttu-id="37d6d-121">Kimlik bilgisini açıkça ayarlamayın.</span><span class="sxs-lookup"><span data-stu-id="37d6d-121">You do not explicitly set the credential.</span></span>  
  
- <span data-ttu-id="37d6d-122">Hizmeti kimliğe bürünme güvenlik bağlamı altında arıyoruz.</span><span class="sxs-lookup"><span data-stu-id="37d6d-122">You are calling the service under the impersonated security context.</span></span>  
  
 <span data-ttu-id="37d6d-123">Bu koşullar doğru ise, istemcinin kimliğini doğrulamak için kullanılan kimlik, WCF istemcisi açıldıktan sonra değişebilir (Bunun yerine kimliğe bürünülmüş kimlik ancak işlem kimliği olmayabilir).</span><span class="sxs-lookup"><span data-stu-id="37d6d-123">If these conditions are true, the identity used to authenticate the client to the service might change (it might not be the impersonated identity but the process identity instead) after the WCF client is opened.</span></span> <span data-ttu-id="37d6d-124">Bu durum, istemcinin kimliğini doğrulamak için kullanılan Windows kimlik bilgisinin her iletiyle iletilmesi ve kimlik doğrulaması için kullanılan kimlik bilgilerinin geçerli iş parçacığının Windows kimliğinden elde edilmesinden kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="37d6d-124">This occurs because the Windows credential used to authenticate the client to the service is transmitted with every message, and the credential used for authentication is obtained from the current thread's Windows identity.</span></span> <span data-ttu-id="37d6d-125">Geçerli iş parçacığının Windows kimliği değişirse (örneğin, farklı bir çağıranın kimliğine bürünerek), iletiye eklenen ve istemcinin kimlik doğrulaması için kullanılan kimlik bilgileri de değişebilir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-125">If the Windows identity of the current thread changes (for example, by impersonating a different caller), the credential that is attached to the message and used to authenticate the client to the service might also change.</span></span>  
  
 <span data-ttu-id="37d6d-126">Windows kimlik doğrulamasını kimliğe bürünme ile birlikte kullanırken belirleyici davranışa sahip olmak istiyorsanız, Windows kimlik bilgilerini açıkça ayarlamanız veya hizmetle bir güvenlik bağlamı oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-126">If you want to have deterministic behavior when using Windows authentication together with impersonation you need to explicitly set the Windows credential or you need to establish a security context with the service.</span></span> <span data-ttu-id="37d6d-127">Bunu yapmak için bir ileti güvenlik oturumu veya bir taşıma güvenlik oturumu kullanın.</span><span class="sxs-lookup"><span data-stu-id="37d6d-127">To do this, use a message security session or a transport security session.</span></span> <span data-ttu-id="37d6d-128">Örneğin, net. TCP taşıması bir taşıma güvenlik oturumu sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-128">For example, the net.tcp transport can provide a transport security session.</span></span> <span data-ttu-id="37d6d-129">Ayrıca, hizmeti çağırırken yalnızca zaman uyumlu bir istemci işlemleri sürümü kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-129">Additionally, you must use only a synchronous version of client operations when calling the service.</span></span> <span data-ttu-id="37d6d-130">İleti güvenlik bağlamı oluşturursanız, kimlik, oturum yenileme işlemi sırasında da değiştirebildiğinden, hizmet bağlantısını yapılandırılan oturum yenileme süresinden daha uzun süre açık tutmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-130">If you establish a message security context, you should not keep the connection to the service open longer than the configured session renewal period, because the identity can also change during the session renewal process.</span></span>  
  
### <a name="credentials-capture"></a><span data-ttu-id="37d6d-131">Kimlik bilgileri yakalama</span><span class="sxs-lookup"><span data-stu-id="37d6d-131">Credentials Capture</span></span>  

 <span data-ttu-id="37d6d-132">Aşağıdakiler .NET Framework 3,5 ve sonraki sürümler için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-132">The following applies to .NET Framework 3.5, and subsequent versions.</span></span>  
  
 <span data-ttu-id="37d6d-133">İstemci veya hizmet tarafından kullanılan kimlik bilgileri, geçerli bağlam iş parçacığını temel alır.</span><span class="sxs-lookup"><span data-stu-id="37d6d-133">Credentials used by the client or the service are based on the current context thread.</span></span> <span data-ttu-id="37d6d-134">`Open` `BeginOpen` İstemci veya hizmetin yöntemi (ya da zaman uyumsuz çağrılar) çağrıldığında kimlik bilgileri alınır.</span><span class="sxs-lookup"><span data-stu-id="37d6d-134">The credentials are obtained when the `Open` method (or `BeginOpen`, for asynchronous calls) of the client or service is called.</span></span> <span data-ttu-id="37d6d-135">Hem hem de <xref:System.ServiceModel.ServiceHost> sınıfları için, <xref:System.ServiceModel.ClientBase%601> `Open` ve yöntemleri, `BeginOpen` <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> sınıfının ve yöntemlerinden devralınır <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> <xref:System.ServiceModel.Channels.CommunicationObject> .</span><span class="sxs-lookup"><span data-stu-id="37d6d-135">For both the <xref:System.ServiceModel.ServiceHost> and <xref:System.ServiceModel.ClientBase%601> classes, the `Open` and `BeginOpen` methods inherit from the <xref:System.ServiceModel.Channels.CommunicationObject.Open%2A> and <xref:System.ServiceModel.Channels.CommunicationObject.BeginOpen%2A> methods of the <xref:System.ServiceModel.Channels.CommunicationObject> class.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="37d6d-136">`BeginOpen`Yöntemi kullanılırken, yakalanan kimlik bilgilerinin yöntemini çağıran işlemin kimlik bilgileri olması garanti edilemez.</span><span class="sxs-lookup"><span data-stu-id="37d6d-136">When using the `BeginOpen` method, the credentials captured cannot be guaranteed to be the credentials of the process that calls the method.</span></span>  
  
## <a name="token-caches-allow-replay-using-obsolete-data"></a><span data-ttu-id="37d6d-137">Belirteç önbellekleri eski verileri kullanarak yeniden yürütmeye Izin verir</span><span class="sxs-lookup"><span data-stu-id="37d6d-137">Token Caches Allow Replay Using Obsolete Data</span></span>  

 <span data-ttu-id="37d6d-138">WCF, `LogonUser` Kullanıcı adı ve parola ile kullanıcıların kimliğini doğrulamak için yerel güvenlik yetkilisi (LSA) işlevini kullanır.</span><span class="sxs-lookup"><span data-stu-id="37d6d-138">WCF uses the local security authority (LSA) `LogonUser` function to authenticate users by user name and password.</span></span> <span data-ttu-id="37d6d-139">Oturum açma işlevi maliyetli bir işlem olduğundan, WCF, performansı artırmak için kimliği doğrulanmış kullanıcıları temsil eden belirteçleri önbelleğe almanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="37d6d-139">Because the logon function is a costly operation, WCF allows you to cache tokens that represent authenticated users to increase performance.</span></span> <span data-ttu-id="37d6d-140">Önbelleğe alma mekanizması, `LogonUser` sonraki kullanımlar için sonuçlarını kaydeder.</span><span class="sxs-lookup"><span data-stu-id="37d6d-140">The caching mechanism saves the results from `LogonUser` for subsequent uses.</span></span> <span data-ttu-id="37d6d-141">Bu mekanizma varsayılan olarak devre dışıdır; etkinleştirmek için <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> özelliğini olarak ayarlayın `true` veya `cacheLogonTokens` özniteliğini kullanın [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md) .</span><span class="sxs-lookup"><span data-stu-id="37d6d-141">This mechanism is disabled by default; to enable it, set the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CacheLogonTokens%2A> property to `true`, or use the `cacheLogonTokens` attribute of the [\<userNameAuthentication>](../../configure-apps/file-schema/wcf/usernameauthentication.md).</span></span>  
  
 <span data-ttu-id="37d6d-142">Özelliği bir olarak ayarlayarak önbelleğe alınmış belirteçler için yaşam süresi (TTL) ayarlayabilir <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> <xref:System.TimeSpan> veya `cachedLogonTokenLifetime` öğenin özniteliğini kullanabilirsiniz `userNameAuthentication` ; varsayılan değer 15 dakikadır.</span><span class="sxs-lookup"><span data-stu-id="37d6d-142">You can set a Time to Live (TTL) for the cached tokens by setting the <xref:System.ServiceModel.Security.UserNamePasswordServiceCredential.CachedLogonTokenLifetime%2A> property to a <xref:System.TimeSpan>, or use the `cachedLogonTokenLifetime` attribute of the `userNameAuthentication` element; the default is 15 minutes.</span></span> <span data-ttu-id="37d6d-143">Bir belirteç önbelleğe alındığında, Kullanıcı hesabı Windows 'tan silinse veya parolası değiştirilmişse bile, aynı kullanıcı adını ve parolayı sunan tüm istemciler belirteci kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-143">Note that while a token is cached, any client that presents the same user name and password can use the token, even if the user account is deleted from Windows or if its password has been changed.</span></span> <span data-ttu-id="37d6d-144">TTL süresi dolana ve belirteç önbellekten kaldırılana kadar, WCF (muhtemelen kötü amaçlı) kullanıcının kimliğini doğrulamasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-144">Until the TTL expires and the token is removed from the cache, WCF allows the (possibly malicious) user to authenticate.</span></span>  
  
 <span data-ttu-id="37d6d-145">Bunu azaltmak için: `cachedLogonTokenLifetime` değeri kullanıcılarınızın ihtiyaç duyduğu en kısa zaman aralığına ayarlayarak saldırı penceresini azaltın.</span><span class="sxs-lookup"><span data-stu-id="37d6d-145">To mitigate this: Decrease the attack window by setting the `cachedLogonTokenLifetime` value to the shortest time span your users need.</span></span>  
  
## <a name="issued-token-authorization-expiration-reset-to-large-value"></a><span data-ttu-id="37d6d-146">Verilen belirteç yetkilendirmesi: zaman aşımı değeri büyük değere sıfırlandı</span><span class="sxs-lookup"><span data-stu-id="37d6d-146">Issued Token Authorization: Expiration Reset to Large Value</span></span>  

 <span data-ttu-id="37d6d-147">Belirli koşullar altında, <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> öğesinin özelliği <xref:System.IdentityModel.Policy.AuthorizationContext> beklenmedik bir şekilde büyük bir değere ayarlanabilir ( <xref:System.DateTime.MaxValue> alan değeri eksi bir gün veya 20 Aralık 9999).</span><span class="sxs-lookup"><span data-stu-id="37d6d-147">Under certain conditions, the <xref:System.IdentityModel.Policy.AuthorizationContext.ExpirationTime%2A> property of the <xref:System.IdentityModel.Policy.AuthorizationContext> may be set to an unexpectedly larger value (the <xref:System.DateTime.MaxValue> field value minus one day, or December 20, 9999).</span></span>  
  
 <span data-ttu-id="37d6d-148">Bu durum, <xref:System.ServiceModel.WSFederationHttpBinding> istemci kimlik bilgisi türü olarak verilen belirteci olan sistem tarafından belirtilen bağlamalardan herhangi birini kullanırken oluşur.</span><span class="sxs-lookup"><span data-stu-id="37d6d-148">This occurs when using the <xref:System.ServiceModel.WSFederationHttpBinding> and any of the system-provided bindings that have an issued token as the client credential type.</span></span>  
  
 <span data-ttu-id="37d6d-149">Bu durum, aşağıdaki yöntemlerden birini kullanarak özel bağlamalar oluşturduğunuzda da oluşur:</span><span class="sxs-lookup"><span data-stu-id="37d6d-149">This also occurs when you create custom bindings by using one of the following methods:</span></span>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForCertificateBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenForSslBindingElement%2A>  
  
- <xref:System.ServiceModel.Channels.SecurityBindingElement.CreateIssuedTokenOverTransportBindingElement%2A>  
  
 <span data-ttu-id="37d6d-150">Bunu azaltmak için, yetkilendirme ilkesi, her yetkilendirme ilkesinin eylemini ve sona erme tarihini denetmelidir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-150">To mitigate this, the authorization policy must check the action and the expiration time of each authorization policy.</span></span>  
  
## <a name="the-service-uses-a-different-certificate-than-the-client-intended"></a><span data-ttu-id="37d6d-151">Hizmet, Istemcinin hedefinden farklı bir sertifika kullanıyor</span><span class="sxs-lookup"><span data-stu-id="37d6d-151">The Service Uses a Different Certificate Than the Client Intended</span></span>  

 <span data-ttu-id="37d6d-152">Belirli koşullar altında, bir istemci bir X. 509.952 sertifikasıyla bir iletiyi dijital olarak imzalayabilir ve hizmetin amaçlanan olandan farklı bir sertifika almasına sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-152">Under certain conditions, a client can digitally sign a message with an X.509 certificate and have the service retrieve a different certificate than the intended one.</span></span>  
  
 <span data-ttu-id="37d6d-153">Bu durum aşağıdaki koşullarda oluşabilir:</span><span class="sxs-lookup"><span data-stu-id="37d6d-153">This can occur under the following circumstances:</span></span>  
  
- <span data-ttu-id="37d6d-154">İstemci bir X. 509.440 sertifikası kullanarak bir iletiyi dijital olarak imzalar ve X. 509.952 sertifikasını iletiye eklemez, bunun yerine yalnızca konu anahtarı tanımlayıcısı kullanılarak sertifikaya başvurur.</span><span class="sxs-lookup"><span data-stu-id="37d6d-154">The client digitally signs a message using an X.509 certificate and does not attach the X.509 certificate to the message, but rather just references the certificate using its subject key identifier.</span></span>  
  
- <span data-ttu-id="37d6d-155">Hizmetin bilgisayarında aynı ortak anahtara sahip iki veya daha fazla sertifika var, ancak bunlar farklı bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-155">The service's computer contains two or more certificates with the same public key, but they contain different information.</span></span>  
  
- <span data-ttu-id="37d6d-156">Hizmet, konu anahtarı tanımlayıcısı ile eşleşen bir sertifika alır, ancak istemcinin kullanması amaçlanan bir sertifika değildir.</span><span class="sxs-lookup"><span data-stu-id="37d6d-156">The service retrieves a certificate that matches the subject key identifier, but it is not the one the client intended to use.</span></span> <span data-ttu-id="37d6d-157">WCF iletiyi alıp imzayı doğruladığında, WCF, istenmeyen X. 509.952 sertifikasındaki bilgileri, istemcinin beklenen şekilde farklı ve potansiyel olarak yükseltilmiş bir talepler kümesiyle eşler.</span><span class="sxs-lookup"><span data-stu-id="37d6d-157">When WCF receives the message and verifies the signature, WCF maps the information in the unintended X.509 certificate to a set of claims that are different and potentially elevated from what the client expected.</span></span>  
  
 <span data-ttu-id="37d6d-158">Bunu azaltmak için, X. 509.440 sertifikasına, using gibi başka bir şekilde başvurun <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial> .</span><span class="sxs-lookup"><span data-stu-id="37d6d-158">To mitigate this, reference the X.509 certificate another way, such as using <xref:System.ServiceModel.Security.Tokens.X509KeyIdentifierClauseType.IssuerSerial>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="37d6d-159">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="37d6d-159">See also</span></span>

- [<span data-ttu-id="37d6d-160">Güvenlik konuları</span><span class="sxs-lookup"><span data-stu-id="37d6d-160">Security Considerations</span></span>](security-considerations-in-wcf.md)
- [<span data-ttu-id="37d6d-161">Bilgilerin Açığa Çıkması</span><span class="sxs-lookup"><span data-stu-id="37d6d-161">Information Disclosure</span></span>](information-disclosure.md)
- [<span data-ttu-id="37d6d-162">Hizmet Reddi</span><span class="sxs-lookup"><span data-stu-id="37d6d-162">Denial of Service</span></span>](denial-of-service.md)
- [<span data-ttu-id="37d6d-163">Yeniden Yürütme Saldırıları</span><span class="sxs-lookup"><span data-stu-id="37d6d-163">Replay Attacks</span></span>](replay-attacks.md)
- [<span data-ttu-id="37d6d-164">Kurcalama</span><span class="sxs-lookup"><span data-stu-id="37d6d-164">Tampering</span></span>](tampering.md)
- [<span data-ttu-id="37d6d-165">Desteklenmeyen Senaryolar</span><span class="sxs-lookup"><span data-stu-id="37d6d-165">Unsupported Scenarios</span></span>](unsupported-scenarios.md)
