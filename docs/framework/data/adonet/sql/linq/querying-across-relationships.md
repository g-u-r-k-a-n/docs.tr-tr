---
description: 'Hakkında daha fazla bilgi edinin: Ilişkiler arasında sorgulama'
title: İlişkilerde Sorgulama
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 297878d0-685b-4c01-b2e0-9d731b7322bc
ms.openlocfilehash: a29a24b21cc486f59ae7535db0e5f97831249ee0
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99695261"
---
# <a name="querying-across-relationships"></a><span data-ttu-id="29b0f-103">İlişkilerde Sorgulama</span><span class="sxs-lookup"><span data-stu-id="29b0f-103">Querying Across Relationships</span></span>

<span data-ttu-id="29b0f-104">Sınıf tanımlarınızdaki diğer nesne veya diğer nesne koleksiyonları için başvurular doğrudan veritabanındaki yabancı anahtar ilişkilerine karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="29b0f-104">References to other objects or collections of other objects in your class definitions directly correspond to foreign-key relationships in the database.</span></span> <span data-ttu-id="29b0f-105">Bu ilişkileri kullanarak sorgulama özelliklerine erişin ve bir nesneden diğerine gidebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-105">You can use these relationships when you query by using dot notation to access the relationship properties and navigate from one object to another.</span></span> <span data-ttu-id="29b0f-106">Bu erişim işlemleri, eşdeğer SQL 'de daha karmaşık birleştirmeler veya bağıntılı alt sorgular için çeviri yapar.</span><span class="sxs-lookup"><span data-stu-id="29b0f-106">These access operations translate to more complex joins or correlated subqueries in the equivalent SQL.</span></span>  
  
 <span data-ttu-id="29b0f-107">Örneğin, aşağıdaki sorgu, sonuçları yalnızca Londra 'da bulunan müşterilere yönelik siparişlerle sınırlamak için siparişlerden müşterilere gider.</span><span class="sxs-lookup"><span data-stu-id="29b0f-107">For example, the following query navigates from orders to customers as a way to restrict the results to only those orders for customers located in London.</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#3](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#3)]
 [!code-vb[DLinqQueryConcepts#3](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#3)]  
  
 <span data-ttu-id="29b0f-108">İlişki özellikleri yoksa, aşağıdaki kodda olduğu gibi bunları SQL sorgusunda yaptığınız gibi, *birleşim* olarak el ile yazmanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="29b0f-108">If relationship properties did not exist you would have to write them manually as *joins*, just as you would do in a SQL query, as in the following code:</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#4](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#4)]
 [!code-vb[DLinqQueryConcepts#4](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#4)]  
  
 <span data-ttu-id="29b0f-109">*İlişki* özelliğini, bu belirli ilişkiyi bir kez tanımlamak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-109">You can use the *relationship* property to define this particular relationship one time.</span></span> <span data-ttu-id="29b0f-110">Daha sonra daha kullanışlı bir nokta söz dizimini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-110">You can then use the more convenient dot syntax.</span></span> <span data-ttu-id="29b0f-111">Ancak, etki alanına özgü nesne modelleri genellikle hiyerarşiler veya grafikler olarak tanımlandığından ilişki özellikleri daha önemlisi vardır.</span><span class="sxs-lookup"><span data-stu-id="29b0f-111">But relationship properties exist more importantly because domain-specific object models are typically defined as hierarchies or graphs.</span></span> <span data-ttu-id="29b0f-112">Programdığı nesneler diğer nesnelere başvurmuş.</span><span class="sxs-lookup"><span data-stu-id="29b0f-112">The objects that you program against have references to other objects.</span></span> <span data-ttu-id="29b0f-113">Nesne-nesne ilişkilerinin, veritabanlarındaki yabancı anahtar stilli ilişkilerine karşılık geldiği bir rastlantı yalnızca bir gününüz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-113">It is only a happy coincidence that object-to-object relationships correspond to foreign-key-styled relationships in databases.</span></span> <span data-ttu-id="29b0f-114">Özellik erişimi daha sonra birleştirmeleri yazmak için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="29b0f-114">Property access then provides a convenient way to write joins.</span></span>  
  
 <span data-ttu-id="29b0f-115">Bu konuda açıklandığı gibi, ilişki özellikleri sorgunun bir parçası olarak bir sorgunun sonuçlar tarafında daha önemlidir.</span><span class="sxs-lookup"><span data-stu-id="29b0f-115">With regard to this, relationship properties are more important on the results side of a query than as part of the query itself.</span></span> <span data-ttu-id="29b0f-116">Sorgu belirli bir müşteri hakkında veri aldıktan sonra, sınıf tanımı müşterilerin siparişlerinin olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="29b0f-116">After the query has retrieved data about a particular customer, the class definition indicates that customers have orders.</span></span> <span data-ttu-id="29b0f-117">Diğer bir deyişle, `Orders` belirli bir müşterinin özelliğinin bu müşterinin tüm siparişleriyle doldurulmuş bir koleksiyon olmasını bekler.</span><span class="sxs-lookup"><span data-stu-id="29b0f-117">In other words, you expect the `Orders` property of a particular customer to be a collection that is populated with all the orders from that customer.</span></span> <span data-ttu-id="29b0f-118">Bu şekilde, bu şekilde sınıfları tanımlayarak bildirdiğiniz sözleşmenin olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="29b0f-118">That is in fact the contract you declared by defining the classes in this manner.</span></span> <span data-ttu-id="29b0f-119">Sorgu sipariş istemese de, bu sipariþlerinizi görmeyi düşünüyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-119">You expect to see the orders there even if the query did not request orders.</span></span> <span data-ttu-id="29b0f-120">Nesne modelinizi, ilgili nesneleri hemen kullanılabilir olan veritabanının bellek içi uzantısı olduğunu bir Yanıan koruyacak şekilde bekleolursunuz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-120">You expect your object model to maintain an illusion that it is an in-memory extension of the database with related objects immediately available.</span></span>  
  
 <span data-ttu-id="29b0f-121">Artık ilişkilerimize sahip olduğunuza göre, sınıflarınızda tanımlanan ilişki özelliklerine başvurarak sorgu yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-121">Now that you have relationships, you can write queries by referring to the relationship properties defined in your classes.</span></span> <span data-ttu-id="29b0f-122">Bu ilişki başvuruları, veritabanındaki yabancı anahtar ilişkilerine karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="29b0f-122">These relationship references correspond to foreign-key relationships in the database.</span></span> <span data-ttu-id="29b0f-123">Bu ilişkileri kullanan işlemler, eşdeğer SQL 'de daha karmaşık birleştirmeler için çeviri yapar.</span><span class="sxs-lookup"><span data-stu-id="29b0f-123">Operations that use these relationships translate to more complex joins in the equivalent SQL.</span></span> <span data-ttu-id="29b0f-124">Bir ilişki tanımladığınız sürece ( <xref:System.Data.Linq.Mapping.AssociationAttribute> özniteliğini kullanarak), içinde açık bir katılmayı kodlamamalısınız [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] .</span><span class="sxs-lookup"><span data-stu-id="29b0f-124">As long as you have defined a relationship (using the <xref:System.Data.Linq.Mapping.AssociationAttribute> attribute), you do not have to code an explicit join in [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span>  
  
 <span data-ttu-id="29b0f-125">Bu yanılsaın korunmasını sağlamak için [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] *ertelenmiş yükleme* adlı bir teknik uygular.</span><span class="sxs-lookup"><span data-stu-id="29b0f-125">To help maintain this illusion, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] implements a technique called *deferred loading*.</span></span> <span data-ttu-id="29b0f-126">Daha fazla bilgi için bkz. [ertelenmiş ve hemen yükleme](deferred-versus-immediate-loading.md).</span><span class="sxs-lookup"><span data-stu-id="29b0f-126">For more information, see [Deferred versus Immediate Loading](deferred-versus-immediate-loading.md).</span></span>  
  
 <span data-ttu-id="29b0f-127">Çiftler listesini proje için aşağıdaki SQL sorgusunu göz önünde bulundurun `CustomerID` - `OrderID` :</span><span class="sxs-lookup"><span data-stu-id="29b0f-127">Consider the following SQL query to project a list of `CustomerID`-`OrderID` pairs:</span></span>  
  
```sql
SELECT t0.CustomerID, t1.OrderID  
FROM   Customers AS t0 INNER JOIN  
          Orders AS t1 ON t0.CustomerID = t1.CustomerID  
WHERE  (t0.City = @p0)  
```  
  
 <span data-ttu-id="29b0f-128">Kullanarak aynı sonuçları elde etmek için [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] , `Orders` sınıfında zaten var olan özellik başvurusunu kullanırsınız `Customer` .</span><span class="sxs-lookup"><span data-stu-id="29b0f-128">To obtain the same results by using [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)], you use the `Orders` property reference already existing in the `Customer` class.</span></span> <span data-ttu-id="29b0f-129">`Orders`Başvuru, `CustomerID` - `OrderID` aşağıdaki kodda olduğu gibi sorguyu yürütmek ve çiftleri proje için gerekli bilgileri sağlar:</span><span class="sxs-lookup"><span data-stu-id="29b0f-129">The `Orders` reference provides the necessary information to execute the query and project the `CustomerID`-`OrderID` pairs, as in the following code:</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#5](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#5)]
 [!code-vb[DLinqQueryConcepts#5](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#5)]  
  
 <span data-ttu-id="29b0f-130">Ayrıca, tersten de yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-130">You can also do the reverse.</span></span> <span data-ttu-id="29b0f-131">Diğer bir deyişle, `Orders` `Customer` ilişkili nesneyle ilgili bilgilere erişmek için ilişki başvurusunu sorgulayabilir ve kullanabilirsiniz `Customer` .</span><span class="sxs-lookup"><span data-stu-id="29b0f-131">That is, you can query `Orders` and use its `Customer` relationship reference to access information about the associated `Customer` object.</span></span> <span data-ttu-id="29b0f-132">Aşağıdaki kod, `CustomerID` - `OrderID` önceki ile aynı çiftleri, ancak bunun yerine sorgulanarak bu süreyi sorgular `Orders` `Customers` .</span><span class="sxs-lookup"><span data-stu-id="29b0f-132">The following code projects the same `CustomerID`-`OrderID` pairs as before, but this time by querying `Orders` instead of `Customers`.</span></span>  
  
 [!code-csharp[DLinqQueryConcepts#6](../../../../../../samples/snippets/csharp/VS_Snippets_Data/DLinqQueryConcepts/cs/Program.cs#6)]
 [!code-vb[DLinqQueryConcepts#6](../../../../../../samples/snippets/visualbasic/VS_Snippets_Data/DLinqQueryConcepts/vb/Module1.vb#6)]  
  
## <a name="see-also"></a><span data-ttu-id="29b0f-133">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="29b0f-133">See also</span></span>

- [<span data-ttu-id="29b0f-134">Sorgu Kavramları</span><span class="sxs-lookup"><span data-stu-id="29b0f-134">Query Concepts</span></span>](query-concepts.md)
