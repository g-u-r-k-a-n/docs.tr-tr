---
title: Windows sistemlerinde dosya yolu biçimleri
description: Bu makalede geleneksel DOS yolları, DOS cihaz yolları ve evrensel adlandırma kuralı (UNC) yolları gibi Windows sistemlerinde dosya yolu biçimleri hakkında bilgi edinin.
ms.date: 06/06/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- I/O, long paths
- long paths
- path formats, Windows
ms.openlocfilehash: 8cbb687b0c7cfb69d3f3807c083f1c25e9d39594
ms.sourcegitcommit: e0803b8975d3eb12e735a5d07637020dd6dac5ef
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/01/2020
ms.locfileid: "89271795"
---
# <a name="file-path-formats-on-windows-systems"></a><span data-ttu-id="2ee54-103">Windows sistemlerinde dosya yolu biçimleri</span><span class="sxs-lookup"><span data-stu-id="2ee54-103">File path formats on Windows systems</span></span>

<span data-ttu-id="2ee54-104">Ad alanındaki türlerin birçok üyesi, <xref:System.IO> `path` bir dosya sistemi kaynağına mutlak veya göreli bir yol belirtmenize imkan tanıyan bir parametre içerir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-104">Members of many of the types in the <xref:System.IO> namespace include a `path` parameter that lets you specify an absolute or relative path to a file system resource.</span></span> <span data-ttu-id="2ee54-105">Bu yol daha sonra [Windows dosya sistemi API 'lerine](/windows/desktop/fileio/file-systems)geçirilir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-105">This path is then passed to [Windows file system APIs](/windows/desktop/fileio/file-systems).</span></span> <span data-ttu-id="2ee54-106">Bu konuda, Windows sistemlerinde kullanabileceğiniz dosya yollarının biçimleri ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-106">This topic discusses the formats for file paths that you can use on Windows systems.</span></span>

## <a name="traditional-dos-paths"></a><span data-ttu-id="2ee54-107">Geleneksel DOS yolları</span><span class="sxs-lookup"><span data-stu-id="2ee54-107">Traditional DOS paths</span></span>

<span data-ttu-id="2ee54-108">Standart bir DOS yolu üç bileşenden oluşabilir:</span><span class="sxs-lookup"><span data-stu-id="2ee54-108">A standard DOS path can consist of three components:</span></span>

- <span data-ttu-id="2ee54-109">Birim veya sürücü harfi, ardından birim ayırıcısı ( `:` ).</span><span class="sxs-lookup"><span data-stu-id="2ee54-109">A volume or drive letter followed by the volume separator (`:`).</span></span>
- <span data-ttu-id="2ee54-110">Bir dizin adı.</span><span class="sxs-lookup"><span data-stu-id="2ee54-110">A directory name.</span></span> <span data-ttu-id="2ee54-111">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) , iç içe geçmiş Dizin hiyerarşisindeki alt dizinleri ayırır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-111">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="2ee54-112">İsteğe bağlı bir dosya adı.</span><span class="sxs-lookup"><span data-stu-id="2ee54-112">An optional filename.</span></span> <span data-ttu-id="2ee54-113">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) dosya yolunu ve dosya adını ayırır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-113">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="2ee54-114">Üç bileşen varsa, yol mutlak olur.</span><span class="sxs-lookup"><span data-stu-id="2ee54-114">If all three components are present, the path is absolute.</span></span> <span data-ttu-id="2ee54-115">Birim veya sürücü harfi belirtilmemişse ve dizin adı [dizin ayırıcı karakteriyle](<xref:System.IO.Path.DirectorySeparatorChar>)başlıyorsa, yol geçerli sürücünün kökünden görelidir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-115">If no volume or drive letter is specified and the directory name begins with the [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>), the path is relative from the root of the current drive.</span></span> <span data-ttu-id="2ee54-116">Aksi takdirde, yol geçerli dizine göre değişir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-116">Otherwise, the path is relative to the current directory.</span></span> <span data-ttu-id="2ee54-117">Aşağıdaki tabloda bazı olası dizin ve dosya yolları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-117">The following table shows some possible directory and file paths.</span></span>

|<span data-ttu-id="2ee54-118">Yol</span><span class="sxs-lookup"><span data-stu-id="2ee54-118">Path</span></span>  |<span data-ttu-id="2ee54-119">Açıklama</span><span class="sxs-lookup"><span data-stu-id="2ee54-119">Description</span></span>  |
| -- | -- |
| `C:\Documents\Newsletters\Summer2018.pdf` | <span data-ttu-id="2ee54-120">Sürücü kökünden mutlak bir dosya yolu `C:` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-120">An absolute file path from the root of drive `C:`.</span></span> |
| `\Program Files\Custom Utilities\StringFinder.exe` | <span data-ttu-id="2ee54-121">Geçerli sürücünün kökünden mutlak bir yol.</span><span class="sxs-lookup"><span data-stu-id="2ee54-121">An absolute path from the root of the current drive.</span></span> |
| `2018\January.xlsx` | <span data-ttu-id="2ee54-122">Geçerli dizinin bir alt dizinindeki bir dosyanın göreli yolu.</span><span class="sxs-lookup"><span data-stu-id="2ee54-122">A relative path to a file in a subdirectory of the current directory.</span></span> |
| `..\Publications\TravelBrochure.pdf` | <span data-ttu-id="2ee54-123">Geçerli dizinin eşi olan dizindeki dosyanın göreli yolu.</span><span class="sxs-lookup"><span data-stu-id="2ee54-123">A relative path to file in a directory that is a peer of the current directory.</span></span> |
| `C:\Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="2ee54-124">Sürücünün kökünden bir dosyanın mutlak yolu `C:` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-124">An absolute path to a file from the root of drive `C:`.</span></span> |
| `C:Projects\apilibrary\apilibrary.sln` | <span data-ttu-id="2ee54-125">Sürücünün geçerli dizininden göreli bir yol `C:` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-125">A relative path from the current directory of the `C:` drive.</span></span> |

> [!IMPORTANT]
> <span data-ttu-id="2ee54-126">Son iki yol arasındaki farkı dikkate alın.</span><span class="sxs-lookup"><span data-stu-id="2ee54-126">Note the difference between the last two paths.</span></span> <span data-ttu-id="2ee54-127">Her ikisi de isteğe bağlı birim tanımlayıcısını ( `C:` her iki durumda) belirtir, ancak ilki belirtilen birimin köküyle başlar, ikincisi ise.</span><span class="sxs-lookup"><span data-stu-id="2ee54-127">Both specify the optional volume specifier (`C:` in both cases), but the first begins with the root of the specified volume, whereas the second does not.</span></span> <span data-ttu-id="2ee54-128">Sonuç olarak, ilki sürücünün kök dizinindeki mutlak bir yoldur `C:` , ikincisi ise geçerli sürücü dizininden göreli bir yoldur `C:` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-128">As result, the first is an absolute path from the root directory of drive `C:`, whereas the second is a relative path from the current directory of drive `C:`.</span></span> <span data-ttu-id="2ee54-129">İlki Windows dosya yollarını içeren yaygın bir hata kaynağı olduğunda ikinci formun kullanılması.</span><span class="sxs-lookup"><span data-stu-id="2ee54-129">Use of the second form when the first is intended is a common source of bugs that involve Windows file paths.</span></span>

<span data-ttu-id="2ee54-130">Yöntemi çağırarak bir dosya yolunun tam nitelikli olup olmadığını (yani yol geçerli dizinden bağımsız olduğunu ve geçerli dizin değiştiğinde değiştirmediğini) belirleyebilirsiniz <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> .</span><span class="sxs-lookup"><span data-stu-id="2ee54-130">You can determine whether a file path is fully qualified (that is, it the path is independent of the current directory and does not change when the current directory changes) by calling the <xref:System.IO.Path.IsPathFullyQualified%2A?displayProperty=nameWthType> method.</span></span> <span data-ttu-id="2ee54-131">Bu tür bir yolun göreli Dizin kesimleri ( `.` ve) içerebildiğini `..` ve çözümlenen yol her zaman aynı konuma işaret ediyorsa tam nitelikli olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="2ee54-131">Note that such a path can include relative directory segments (`.` and `..`) and still be fully qualified if the resolved path always points to the same location.</span></span>

<span data-ttu-id="2ee54-132">Aşağıdaki örnek mutlak ve göreli yollar arasındaki farkı gösterir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-132">The following example illustrates the difference between absolute and relative paths.</span></span> <span data-ttu-id="2ee54-133">Dizinin `D:\FY2018\` var olduğunu ve `D:\` örneği çalıştırmadan önce komut isteminden geçerli bir dizin belirlemediğinizi varsayar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-133">It assumes that the directory `D:\FY2018\` exists, and that you haven't set any current directory for `D:\` from the command prompt before running the example.</span></span>

[!code-csharp[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/cs/paths.cs)]
[!code-vb[absolute-and-relative-paths](~/samples/snippets/standard/io/file-names/vb/paths.vb)]

[!INCLUDE [localized code comments](../../../includes/code-comments-loc.md)]

## <a name="unc-paths"></a><span data-ttu-id="2ee54-134">UNC yolları</span><span class="sxs-lookup"><span data-stu-id="2ee54-134">UNC paths</span></span>

<span data-ttu-id="2ee54-135">Ağ kaynaklarına erişmek için kullanılan evrensel adlandırma kuralı (UNC) yolları aşağıdaki biçimdedir:</span><span class="sxs-lookup"><span data-stu-id="2ee54-135">Universal naming convention (UNC) paths, which are used to access network resources, have the following format:</span></span>

- <span data-ttu-id="2ee54-136">Tarafından önceden ortaya çıkacak sunucu veya ana bilgisayar adı `\\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-136">A server or host name, which is prefaced by `\\`.</span></span> <span data-ttu-id="2ee54-137">Sunucu adı bir NetBIOS makine adı veya IP/FQDN adresi (IPv4 ve V6 desteklenir) olabilir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-137">The server name can be a NetBIOS machine name or an IP/FQDN address (IPv4 as well as v6 are supported).</span></span>
- <span data-ttu-id="2ee54-138">Tarafından ana bilgisayar adından ayrılan bir paylaşma adı `\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-138">A share name, which is separated from the host name by `\`.</span></span> <span data-ttu-id="2ee54-139">Birlikte, sunucu ve paylaşımın adı birimi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="2ee54-139">Together, the server and share name make up the volume.</span></span>
- <span data-ttu-id="2ee54-140">Bir dizin adı.</span><span class="sxs-lookup"><span data-stu-id="2ee54-140">A directory name.</span></span> <span data-ttu-id="2ee54-141">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) , iç içe geçmiş Dizin hiyerarşisindeki alt dizinleri ayırır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-141">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates subdirectories within the nested directory hierarchy.</span></span>
- <span data-ttu-id="2ee54-142">İsteğe bağlı bir dosya adı.</span><span class="sxs-lookup"><span data-stu-id="2ee54-142">An optional filename.</span></span> <span data-ttu-id="2ee54-143">[Dizin ayırıcı karakteri](<xref:System.IO.Path.DirectorySeparatorChar>) dosya yolunu ve dosya adını ayırır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-143">The [directory separator character](<xref:System.IO.Path.DirectorySeparatorChar>) separates the file path and the filename.</span></span>

<span data-ttu-id="2ee54-144">Aşağıda, UNC yollarının bazı örnekleri verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="2ee54-144">The following are some examples of UNC paths:</span></span>

|<span data-ttu-id="2ee54-145">Yol</span><span class="sxs-lookup"><span data-stu-id="2ee54-145">Path</span></span>  |<span data-ttu-id="2ee54-146">Açıklama</span><span class="sxs-lookup"><span data-stu-id="2ee54-146">Description</span></span>  |
| -- | -- |
| `\\system07\C$\` | <span data-ttu-id="2ee54-147">`C:`Üzerindeki sürücünün kök dizini `system07` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-147">The root directory of the `C:` drive on `system07`.</span></span> |
| `\\Server2\Share\Test\Foo.txt` | <span data-ttu-id="2ee54-148">`Foo.txt`Birimin test dizinindeki dosya `\\Server2\Share` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-148">The `Foo.txt` file in the Test directory of the `\\Server2\Share` volume.</span></span>|

<span data-ttu-id="2ee54-149">UNC yollarının her zaman tam olarak nitelenmiş olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-149">UNC paths must always be fully qualified.</span></span> <span data-ttu-id="2ee54-150">Bunlara göreli Dizin kesimleri ( `.` ve) dahil edebilirler `..` , ancak bunların tam nitelikli bir yolun parçası olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-150">They can include relative directory segments (`.` and `..`), but these must be part of a fully qualified path.</span></span> <span data-ttu-id="2ee54-151">Yalnızca bir UNC yolunu bir sürücü harfine eşleyerek göreli yolları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2ee54-151">You can use relative paths only by mapping a UNC path to a drive letter.</span></span>

## <a name="dos-device-paths"></a><span data-ttu-id="2ee54-152">DOS cihaz yolları</span><span class="sxs-lookup"><span data-stu-id="2ee54-152">DOS device paths</span></span>

<span data-ttu-id="2ee54-153">Windows işletim sistemi, dosyalar dahil olmak üzere tüm kaynaklara işaret eden birleştirilmiş bir nesne modeline sahiptir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-153">The Windows operating system has a unified object model that points to all resources, including files.</span></span> <span data-ttu-id="2ee54-154">Bu nesne yollarına konsol penceresinden erişilebilir ve eski DOS ve UNC yollarının eşlendiği özel bir sembolik bağlantı klasörü aracılığıyla Win32 katmanına açıktır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-154">These object paths are accessible from the console window and are exposed to the Win32 layer through a special folder of symbolic links that legacy DOS and UNC paths are mapped to.</span></span> <span data-ttu-id="2ee54-155">Bu özel klasöre, aşağıdakilerden biri olan DOS cihaz yolu sözdizimi kullanılarak erişilir:</span><span class="sxs-lookup"><span data-stu-id="2ee54-155">This special folder is accessed via the DOS device path syntax, which is one of:</span></span>

`\\.\C:\Test\Foo.txt`
`\\?\C:\Test\Foo.txt`

<span data-ttu-id="2ee54-156">Bir sürücüyü sürücü harfine göre tanımlamaya ek olarak, birim GUID 'sini kullanarak bir birimi belirleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2ee54-156">In addition to identifying a drive by its drive letter, you can identify a volume by using its volume GUID.</span></span> <span data-ttu-id="2ee54-157">Bu formu alır:</span><span class="sxs-lookup"><span data-stu-id="2ee54-157">This takes the form:</span></span>

`\\.\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`
`\\?\Volume{b75e2c83-0000-0000-0000-602f00000000}\Test\Foo.txt`

> [!NOTE]
> <span data-ttu-id="2ee54-158">DOS cihaz yolu sözdizimi, .NET Core 1,1 ve .NET Framework 4.6.2 ile başlayan Windows üzerinde çalışan .NET uygulamalarında desteklenir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-158">DOS device path syntax is supported on .NET implementations running on Windows starting with .NET Core 1.1 and .NET Framework 4.6.2.</span></span>

<span data-ttu-id="2ee54-159">DOS cihaz yolu aşağıdaki bileşenlerden oluşur:</span><span class="sxs-lookup"><span data-stu-id="2ee54-159">The DOS device path consists of the following components:</span></span>

- <span data-ttu-id="2ee54-160">`\\.\` `\\?\` Yolu bir DOS cihaz yolu olarak tanımlayan cihaz yolu Belirleyicisi (veya).</span><span class="sxs-lookup"><span data-stu-id="2ee54-160">The device path specifier (`\\.\` or `\\?\`), which identifies the path as a DOS device path.</span></span>

   > [!NOTE]
   > <span data-ttu-id="2ee54-161">, `\\?\` .NET Core 'un tüm sürümlerinde ve sürümü 4.6.2 ile başlayarak .NET Framework desteklenir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-161">The `\\?\` is supported in all versions of .NET Core and in the .NET Framework starting with version 4.6.2.</span></span>

- <span data-ttu-id="2ee54-162">"Gerçek" cihaz nesnesine (bir sürücü adı veya birim GUID 'SI olması durumunda {b75e2c83-0000-0000-0000-602f00000000} birimi) sembolik bir bağlantı.</span><span class="sxs-lookup"><span data-stu-id="2ee54-162">A symbolic link to the "real" device object (C: in the case of a drive name, or Volume{b75e2c83-0000-0000-0000-602f00000000} in the case of a volume GUID).</span></span>

   <span data-ttu-id="2ee54-163">Cihaz yolu belirticisinden sonra DOS cihaz yolunun ilk segmenti birimi veya sürücüyü tanımlar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-163">The first segment of the DOS device path after the device path specifier identifies the volume or drive.</span></span> <span data-ttu-id="2ee54-164">(Örneğin, `\\?\C:\` ve `\\.\BootPartition\` .)</span><span class="sxs-lookup"><span data-stu-id="2ee54-164">(For example, `\\?\C:\` and `\\.\BootPartition\`.)</span></span>

   <span data-ttu-id="2ee54-165">Bilinen UNCs 'Ler için belirli bir bağlantı vardır, ancak bu alınmaz `UNC` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-165">There is a specific link for UNCs that is called, not surprisingly, `UNC`.</span></span> <span data-ttu-id="2ee54-166">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="2ee54-166">For example:</span></span>

  `\\.\UNC\Server\Share\Test\Foo.txt`
  `\\?\UNC\Server\Share\Test\Foo.txt`

    <span data-ttu-id="2ee54-167">Cihaz UNCs için, sunucu/paylaşma bölümü birimi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="2ee54-167">For device UNCs, the server/share portion forms the volume.</span></span> <span data-ttu-id="2ee54-168">Örneğin, ' de, `\\?\server1\e:\utilities\\filecomparer\` sunucu/paylaşma bölümü `server1\utilities` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-168">For example, in `\\?\server1\e:\utilities\\filecomparer\`, the server/share portion is `server1\utilities`.</span></span> <span data-ttu-id="2ee54-169">Bu, göreli Dizin kesimlerinde olduğu gibi bir yöntemi çağırırken önemli bir yöntemdir <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> ; birim geçmiş bir zaman içinde gezinmek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-169">This is significant when calling a method such as <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> with relative directory segments; it is never possible to navigate past the volume.</span></span>

<span data-ttu-id="2ee54-170">DOS cihaz yolları tanımına göre tam olarak nitelenir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-170">DOS device paths are fully qualified by definition.</span></span> <span data-ttu-id="2ee54-171">Göreli Dizin kesimlerine ( `.` ve `..` ) izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="2ee54-171">Relative directory segments (`.` and `..`) are not allowed.</span></span> <span data-ttu-id="2ee54-172">Geçerli dizinler, kullanımlarına hiçbir şekilde girmez.</span><span class="sxs-lookup"><span data-stu-id="2ee54-172">Current directories never enter into their usage.</span></span>

## <a name="example-ways-to-refer-to-the-same-file"></a><span data-ttu-id="2ee54-173">Örnek: aynı dosyaya başvurmanın yolları</span><span class="sxs-lookup"><span data-stu-id="2ee54-173">Example: Ways to refer to the same file</span></span>

<span data-ttu-id="2ee54-174">Aşağıdaki örnekte, ad alanındaki API 'Leri kullanırken bir dosyaya başvurabileceğiniz bazı yollar gösterilmektedir <xref:System.IO> .</span><span class="sxs-lookup"><span data-stu-id="2ee54-174">The following example illustrates some of the ways in which you can refer to a file when using the APIs in the <xref:System.IO> namespace.</span></span> <span data-ttu-id="2ee54-175">Örnek, bir nesneyi örnekleyen <xref:System.IO.FileInfo> ve <xref:System.IO.FileInfo.Name> <xref:System.IO.FileInfo.Length> dosya adını ve dosyanın uzunluğunu göstermek için ve özelliklerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-175">The example instantiates a <xref:System.IO.FileInfo> object and uses its <xref:System.IO.FileInfo.Name> and <xref:System.IO.FileInfo.Length> properties to display the filename and the length of the file.</span></span>

[!code-csharp[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/cs/file-refs.cs)]
[!code-vb[referring-to-the-same-file](~/samples/snippets/standard/io/file-names/vb/file-refs.vb)]

## <a name="path-normalization"></a><span data-ttu-id="2ee54-176">Yol normalleştirme</span><span class="sxs-lookup"><span data-stu-id="2ee54-176">Path normalization</span></span>

<span data-ttu-id="2ee54-177">Windows API 'Lerine geçirilen neredeyse tüm yollar normalleştirilir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-177">Almost all paths passed to Windows APIs are normalized.</span></span> <span data-ttu-id="2ee54-178">Normalleştirme sırasında, Windows aşağıdaki adımları gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="2ee54-178">During normalization, Windows performs the following steps:</span></span>

- <span data-ttu-id="2ee54-179">Yolu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-179">Identifies the path.</span></span>
- <span data-ttu-id="2ee54-180">Geçerli dizini kısmen nitelenmiş (göreli) yollara uygular.</span><span class="sxs-lookup"><span data-stu-id="2ee54-180">Applies the current directory to partially qualified (relative) paths.</span></span>
- <span data-ttu-id="2ee54-181">Canonicalizes bileşeni ve Dizin ayırıcıları.</span><span class="sxs-lookup"><span data-stu-id="2ee54-181">Canonicalizes component and directory separators.</span></span>
- <span data-ttu-id="2ee54-182">Göreli Dizin bileşenlerini değerlendirir ( `.` geçerli dizin ve `..` üst dizin için).</span><span class="sxs-lookup"><span data-stu-id="2ee54-182">Evaluates relative directory components (`.` for the current directory and `..` for the parent directory).</span></span>
- <span data-ttu-id="2ee54-183">Belirli karakterleri kırpar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-183">Trims certain characters.</span></span>

<span data-ttu-id="2ee54-184">Bu normalleştirme örtük bir şekilde gerçekleşir, ancak <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType>  [GetFullPathName () işlevine](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)yapılan çağrıyı sarmalayan yöntemini çağırarak açıkça yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2ee54-184">This normalization happens implicitly, but you can do it explicitly by calling the <xref:System.IO.Path.GetFullPath%2A?displayProperty=nameWithType> method, which wraps a call to the  [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span> <span data-ttu-id="2ee54-185">Ayrıca, P/Invoke kullanarak doğrudan Windows [GetFullPathName () işlevini](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2ee54-185">You can also call the Windows [GetFullPathName() function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) directly using P/Invoke.</span></span>

### <a name="identify-the-path"></a><span data-ttu-id="2ee54-186">Yolu tanımla</span><span class="sxs-lookup"><span data-stu-id="2ee54-186">Identify the path</span></span>

<span data-ttu-id="2ee54-187">Yol normalleştirmede ilk adım yolun türünü tanımlar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-187">The first step in path normalization is identifying the type of path.</span></span> <span data-ttu-id="2ee54-188">Yollar birkaç kategoriden birinde yer almalıdır:</span><span class="sxs-lookup"><span data-stu-id="2ee54-188">Paths fall into one of a few categories:</span></span>

- <span data-ttu-id="2ee54-189">Bunlar cihaz yollardır; diğer bir deyişle, iki ayırıcıya da bir soru işareti ya da nokta ( `\\?` veya) ile başlarlar `\\.` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-189">They are device paths; that is, they begin with two separators and a question mark or period (`\\?` or `\\.`).</span></span>
- <span data-ttu-id="2ee54-190">Bunlar UNC yollardır; diğer bir deyişle, bir soru işareti veya dönem olmadan iki ayırıcıya başlarlar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-190">They are UNC paths; that is, they begin with two separators without a question mark or period.</span></span>
- <span data-ttu-id="2ee54-191">Bunlar tamamen nitelikli DOS yollarıdır; diğer bir deyişle, bir sürücü harfi, bir birim ayırıcısı ve bir bileşen ayırıcısı () ile başlar `C:\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-191">They are fully qualified DOS paths; that is, they begin with a drive letter, a volume separator, and a component separator (`C:\`).</span></span>
- <span data-ttu-id="2ee54-192">Eski bir cihaz ( `CON` ,) tasarlarlar `LPT1` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-192">They designate a legacy device (`CON`, `LPT1`).</span></span>
- <span data-ttu-id="2ee54-193">Bunlar geçerli sürücünün köküne görelidir; diğer bir deyişle, tek bir bileşen ayırıcısı () ile başlar `\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-193">They are relative to the root of the current drive; that is, they begin with a single component separator (`\`).</span></span>
- <span data-ttu-id="2ee54-194">Bunlar, belirtilen sürücünün geçerli dizinine göre belirlenir; diğer bir deyişle, bir sürücü harfi, bir birim ayırıcısı ve bileşen ayırıcısı () ile başlar `C:` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-194">They are relative to the current directory of a specified drive; that is, they begin with a drive letter, a volume separator, and no component separator (`C:`).</span></span>
- <span data-ttu-id="2ee54-195">Bunlar geçerli dizine göre değişir; diğer bir deyişle, başka bir şeyle ( `temp\testfile.txt` ) başlar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-195">They are relative to the current directory; that is, they begin with anything else (`temp\testfile.txt`).</span></span>

<span data-ttu-id="2ee54-196">Yolun türü, geçerli bir dizinin bir biçimde uygulanıp uygulanmadığı belirler.</span><span class="sxs-lookup"><span data-stu-id="2ee54-196">The type of the path determines whether or not a current directory is applied in some way.</span></span> <span data-ttu-id="2ee54-197">Ayrıca, yolun "kökünün" ne olduğunu da belirler.</span><span class="sxs-lookup"><span data-stu-id="2ee54-197">It also determines what the "root" of the path is.</span></span>

### <a name="handle-legacy-devices"></a><span data-ttu-id="2ee54-198">Eski cihazları işle</span><span class="sxs-lookup"><span data-stu-id="2ee54-198">Handle legacy devices</span></span>

<span data-ttu-id="2ee54-199">Yol, veya gibi eski bir DOS cihazından, `CON` `COM1` `LPT1` ön bekleyen ve döndürülen bir cihaz yoluna dönüştürülür `\\.\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-199">If the path is a legacy DOS device such as `CON`, `COM1`, or `LPT1`, it is converted into a device path by prepending `\\.\` and returned.</span></span>

<span data-ttu-id="2ee54-200">Eski cihaz adı ile başlayan bir yol, her zaman yöntemi tarafından eski bir cihaz olarak yorumlanır <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="2ee54-200">A path that begins with a legacy device name is always interpreted as a legacy device by the <xref:System.IO.Path.GetFullPath(System.String)?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2ee54-201">Örneğin, için DOS cihaz yolu `CON.TXT` `\\.\CON` ve için DOS cihaz yolu `COM1.TXT\file1.txt` `\\.\COM1` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-201">For example, the DOS device path for `CON.TXT` is `\\.\CON`, and the DOS device path for `COM1.TXT\file1.txt` is `\\.\COM1`.</span></span>

### <a name="apply-the-current-directory"></a><span data-ttu-id="2ee54-202">Geçerli dizini Uygula</span><span class="sxs-lookup"><span data-stu-id="2ee54-202">Apply the current directory</span></span>

<span data-ttu-id="2ee54-203">Bir yol tam nitelikli değilse, Windows geçerli dizini bu dizine uygular.</span><span class="sxs-lookup"><span data-stu-id="2ee54-203">If a path isn't fully qualified, Windows applies the current directory to it.</span></span> <span data-ttu-id="2ee54-204">UNCs ve cihaz yollarına geçerli dizin uygulanmaz.</span><span class="sxs-lookup"><span data-stu-id="2ee54-204">UNCs and device paths do not have the current directory applied.</span></span> <span data-ttu-id="2ee54-205">Ayırıcı ile tam bir sürücü yapmaz `C:\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-205">Neither does a full drive with separator `C:\`.</span></span>

<span data-ttu-id="2ee54-206">Yol tek bir bileşen ayırıcısıyla başlıyorsa, geçerli dizindeki sürücü uygulanır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-206">If the path starts with a single component separator, the drive from the current directory is applied.</span></span> <span data-ttu-id="2ee54-207">Örneğin, dosya yolu `\utilities` ve geçerli dizin ise, `C:\temp\` normalleştirme üretir `C:\utilities` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-207">For example, if the file path is `\utilities` and the current directory is `C:\temp\`, normalization produces `C:\utilities`.</span></span>

<span data-ttu-id="2ee54-208">Yol bir sürücü harfi, birim ayırıcısı ve bileşen ayırıcısı ile başlıyorsa, belirtilen sürücü için komut kabuğundan ayarlanan son geçerli dizin uygulanır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-208">If the path starts with a drive letter, volume separator, and no component separator, the last current directory set from the command shell for the specified drive is applied.</span></span> <span data-ttu-id="2ee54-209">Son geçerli dizin ayarlanmamışsa, tek başına sürücü uygulanır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-209">If the last current directory was not set, the drive alone is applied.</span></span> <span data-ttu-id="2ee54-210">Örneğin, dosya yolu, `D:sources` geçerli dizin `C:\Documents\` ve D: sürücüsündeki son geçerli dizin ise, `D:\sources\` sonuç olur `D:\sources\sources` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-210">For example, if the file path is `D:sources`, the current directory is `C:\Documents\`, and the last current directory on drive D: was `D:\sources\`, the result is `D:\sources\sources`.</span></span> <span data-ttu-id="2ee54-211">Bu "sürücü göreli" yolları, yaygın olarak kullanılan bir program ve betik mantığı hataları kaynağıdır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-211">These "drive relative" paths are a common source of program and script logic errors.</span></span> <span data-ttu-id="2ee54-212">Bir harf ile başlayan bir yolun ve iki nokta üst üste doğru olmadığını varsayarsak</span><span class="sxs-lookup"><span data-stu-id="2ee54-212">Assuming that a path beginning with a letter and a colon isn't relative is obviously not correct.</span></span>

<span data-ttu-id="2ee54-213">Yol, ayırıcı dışında bir şeyle başlıyorsa, geçerli sürücü ve geçerli dizin uygulanır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-213">If the path starts with something other than a separator, the current drive and current directory are applied.</span></span> <span data-ttu-id="2ee54-214">Örneğin, yol `filecompare` ve geçerli dizin ise, `C:\utilities\` sonuç olur `C:\utilities\filecompare\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-214">For example, if the path is `filecompare` and the current directory is `C:\utilities\`, the result is `C:\utilities\filecompare\`.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2ee54-215">Geçerli dizin işlem başına bir ayar olduğundan, göreli yollar çok iş parçacıklı uygulamalarda (yani, çoğu uygulama) tehlikelidir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-215">Relative paths are dangerous in multithreaded applications (that is, most applications) because the current directory is a per-process setting.</span></span> <span data-ttu-id="2ee54-216">Herhangi bir iş parçacığı herhangi bir zamanda geçerli dizini değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-216">Any thread can change the current directory at any time.</span></span> <span data-ttu-id="2ee54-217">.NET Core 2,1 ' den itibaren, <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> bir göreli yol ve kendisine karşı çözümlemek istediğiniz temel yol (geçerli dizin) için mutlak bir yol almak üzere yöntemini çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2ee54-217">Starting with .NET Core 2.1, you can call the <xref:System.IO.Path.GetFullPath(System.String,System.String)?displayProperty=nameWithType> method to get an absolute path from a relative path and the base path (the current directory) that you want to resolve it against.</span></span>

### <a name="canonicalize-separators"></a><span data-ttu-id="2ee54-218">Canonicalize ayırıcılar</span><span class="sxs-lookup"><span data-stu-id="2ee54-218">Canonicalize separators</span></span>

<span data-ttu-id="2ee54-219">Tüm eğik çizgiler ( `/` ), ters eğik çizgi () ile standart Windows ayırıcısına dönüştürülür `\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-219">All forward slashes (`/`) are converted into the standard Windows separator, the back slash (`\`).</span></span> <span data-ttu-id="2ee54-220">Varsa, ilk iki eğik çizgiyi izleyen eğik çizgi serileri tek eğik çizgi olarak daraltılır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-220">If they are present, a series of slashes that follow the first two slashes are collapsed into a single slash.</span></span>

### <a name="evaluate-relative-components"></a><span data-ttu-id="2ee54-221">Göreli bileşenleri değerlendir</span><span class="sxs-lookup"><span data-stu-id="2ee54-221">Evaluate relative components</span></span>

<span data-ttu-id="2ee54-222">Yol işlendiğinde, tek veya çift nokta (veya) tarafından oluşturulan bileşenler veya segmentler `.` `..` değerlendirilir:</span><span class="sxs-lookup"><span data-stu-id="2ee54-222">As the path is processed, any components or segments that are composed of a single or a double period (`.` or `..`) are evaluated:</span></span>

- <span data-ttu-id="2ee54-223">Tek bir dönem için geçerli kesim, geçerli dizine başvurduğundan kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-223">For a single period, the current segment is removed, since it refers to the current directory.</span></span>

- <span data-ttu-id="2ee54-224">Çift dönem için, çift nokta üst dizine başvurduğundan, geçerli segment ve üst kesim kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-224">For a double period, the current segment and the parent segment are removed, since the double period refers to the parent directory.</span></span>

   <span data-ttu-id="2ee54-225">Üst dizinler yalnızca yolun kökünü geçmemişse kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-225">Parent directories are only removed if they aren't past the root of the path.</span></span> <span data-ttu-id="2ee54-226">Yolun kökü, yol türüne bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-226">The root of the path depends on the type of path.</span></span> <span data-ttu-id="2ee54-227">DOS yolları için sürücü ( `C:\` ), UNCs için sunucu/paylaşma ( `\\Server\Share` ) ve cihaz yolları için cihaz yolu ön eki ( `\\?\` veya `\\.\` ).</span><span class="sxs-lookup"><span data-stu-id="2ee54-227">It is the drive (`C:\`) for DOS paths, the server/share for UNCs (`\\Server\Share`), and the device path prefix for device paths (`\\?\` or `\\.\`).</span></span>

### <a name="trim-characters"></a><span data-ttu-id="2ee54-228">Kırpma karakterleri</span><span class="sxs-lookup"><span data-stu-id="2ee54-228">Trim characters</span></span>

<span data-ttu-id="2ee54-229">Daha önce kaldırılan ayırıcıların ve göreli parçaların çalıştırılmalarının yanı sıra, normalleştirme sırasında bazı ek karakterler kaldırılır:</span><span class="sxs-lookup"><span data-stu-id="2ee54-229">Along with the runs of separators and relative segments removed earlier, some additional characters are removed during normalization:</span></span>

- <span data-ttu-id="2ee54-230">Bir segment tek bir dönemde sona ererse bu süre kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-230">If a segment ends in a single period, that period is removed.</span></span> <span data-ttu-id="2ee54-231">(Tek veya çift dönemin bir segmenti, önceki adımda normalleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-231">(A segment of a single or double period is normalized in the previous step.</span></span> <span data-ttu-id="2ee54-232">Üç veya daha fazla dönemin bir segmenti normalleştirilmez ve aslında geçerli bir dosya/dizin adıdır.)</span><span class="sxs-lookup"><span data-stu-id="2ee54-232">A segment of three or more periods is not normalized and is actually a valid file/directory name.)</span></span>

- <span data-ttu-id="2ee54-233">Yol bir ayırıcıda sonlanmazsa, tüm sondaki noktalar ve boşluklar (U + 0020) kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-233">If the path doesn't end in a separator, all trailing periods and spaces (U+0020) are removed.</span></span> <span data-ttu-id="2ee54-234">Son segment yalnızca tek veya çift bir nokta ise, yukarıdaki ilgili bileşenler kuralının altına girer.</span><span class="sxs-lookup"><span data-stu-id="2ee54-234">If the last segment is simply a single or double period, it falls under the relative components rule above.</span></span>

   <span data-ttu-id="2ee54-235">Bu kural, boşluktan sonra sondaki bir ayırıcı ekleyerek sonunda boşluk olan bir dizin adı oluşturabileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-235">This rule means that you can create a directory name with a trailing space by adding a trailing separator after the space.</span></span>

   > [!IMPORTANT]
   > <span data-ttu-id="2ee54-236">Sonunda boşluk olan bir dizin veya dosya **adı oluşturmanız gerekir** .</span><span class="sxs-lookup"><span data-stu-id="2ee54-236">You should **never** create a directory or filename with a trailing space.</span></span> <span data-ttu-id="2ee54-237">Sondaki boşluklar, bir dizine erişmek zor veya olanaksız hale gelir ve uygulamalar genellikle boşluklar içeren dizinleri veya dosyaları işlemeye çalışırken başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="2ee54-237">Trailing spaces can make it difficult or impossible to access a directory, and applications commonly fail when attempting to handle directories or files whose names include trailing spaces.</span></span>

## <a name="skip-normalization"></a><span data-ttu-id="2ee54-238">Normalleştirme atlayın</span><span class="sxs-lookup"><span data-stu-id="2ee54-238">Skip normalization</span></span>

<span data-ttu-id="2ee54-239">Normalde, bir Windows API 'sine geçirilen tüm yol, [GetFullPathName işlevine](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) ve normalleştirilmesine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-239">Normally, any path passed to a Windows API is (effectively) passed to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) and normalized.</span></span> <span data-ttu-id="2ee54-240">Önemli bir özel durum vardır: bir dönem yerine soru işaretiyle başlayan bir cihaz yolu.</span><span class="sxs-lookup"><span data-stu-id="2ee54-240">There is one important exception: a device path that begins with a question mark instead of a period.</span></span> <span data-ttu-id="2ee54-241">Yol tam olarak ile başlatılmadığı takdirde `\\?\` (kurallı ters eğik çizginin kullanımını aklınızda), normalleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-241">Unless the path starts exactly with `\\?\` (note the use of the canonical backslash), it is normalized.</span></span>

<span data-ttu-id="2ee54-242">Neden normalleştirmeyi atlamak istiyorsunuz?</span><span class="sxs-lookup"><span data-stu-id="2ee54-242">Why would you want to skip normalization?</span></span> <span data-ttu-id="2ee54-243">Üç önemli neden vardır:</span><span class="sxs-lookup"><span data-stu-id="2ee54-243">There are three major reasons:</span></span>

1. <span data-ttu-id="2ee54-244">Normalde kullanılamayan ancak geçerli olan yollara erişim sağlamak için.</span><span class="sxs-lookup"><span data-stu-id="2ee54-244">To get access to paths that are normally unavailable but are legal.</span></span> <span data-ttu-id="2ee54-245">Örneğin, adlı bir dosya veya dizin, `hidden.` başka bir şekilde erişim imkansızdır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-245">A file or directory called `hidden.`, for example, is impossible to access in any other way.</span></span>

1. <span data-ttu-id="2ee54-246">Zaten normalleştirdiyseniz normalleştirmeyi atlayarak performansı artırmak için.</span><span class="sxs-lookup"><span data-stu-id="2ee54-246">To improve performance by skipping normalization if you've already normalized.</span></span>

1. <span data-ttu-id="2ee54-247">Yalnızca .NET Framework, `MAX_PATH` 259 karakterden daha büyük yollara izin vermek için yol uzunluğu denetimini atlamak için.</span><span class="sxs-lookup"><span data-stu-id="2ee54-247">On the .NET Framework only, to skip the `MAX_PATH` check for path length to allow for paths that are greater than 259 characters.</span></span> <span data-ttu-id="2ee54-248">Çoğu API, bazı özel durumlarla birlikte buna izin verir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-248">Most APIs allow this, with some exceptions.</span></span>

> [!NOTE]
> <span data-ttu-id="2ee54-249">.NET Core, uzun yolları örtülü olarak işler ve bir `MAX_PATH` denetim gerçekleştirmez.</span><span class="sxs-lookup"><span data-stu-id="2ee54-249">.NET Core handles long paths implicitly and does not perform a `MAX_PATH` check.</span></span> <span data-ttu-id="2ee54-250">`MAX_PATH`Onay yalnızca .NET Framework için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-250">The `MAX_PATH` check applies only to the .NET Framework.</span></span>

<span data-ttu-id="2ee54-251">Normalleştirme atlama ve en yüksek yol denetimleri, iki cihaz yolu sözdizimleri arasındaki tek farktır; Aksi halde özdeş.</span><span class="sxs-lookup"><span data-stu-id="2ee54-251">Skipping normalization and max path checks is the only difference between the two device path syntaxes; they are otherwise identical.</span></span> <span data-ttu-id="2ee54-252">"Normal" uygulamalar için zor olan yolları kolayca oluşturabildiklerinden, normalleştirmeyi atlama konusunda dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="2ee54-252">Be careful with skipping normalization, since you can easily create paths that are difficult for "normal" applications to deal with.</span></span>

<span data-ttu-id="2ee54-253">Öğesini `\\?\` [GetFullPathName işlevine](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea)açıkça geçirirseniz, ile başlayan yollar yine de normalleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-253">Paths that start with `\\?\` are still normalized if you explicitly pass them to the [GetFullPathName function](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea).</span></span>

<span data-ttu-id="2ee54-254">Karakterden daha fazla karakter yolunu, `MAX_PATH` olmadan [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) 'e geçirebilirsiniz `\\?\` .</span><span class="sxs-lookup"><span data-stu-id="2ee54-254">You can pass paths of more than `MAX_PATH` characters to [GetFullPathName](/windows/desktop/api/fileapi/nf-fileapi-getfullpathnamea) without `\\?\`.</span></span> <span data-ttu-id="2ee54-255">Windows 'un işleyebileceği en büyük dize boyutuna kadar rastgele uzunluk yollarını destekler.</span><span class="sxs-lookup"><span data-stu-id="2ee54-255">It supports arbitrary length paths up to the maximum string size that Windows can handle.</span></span>

## <a name="case-and-the-windows-file-system"></a><span data-ttu-id="2ee54-256">Büyük/küçük harf ve Windows dosya sistemi</span><span class="sxs-lookup"><span data-stu-id="2ee54-256">Case and the Windows file system</span></span>

<span data-ttu-id="2ee54-257">Windows dosya sisteminin, Windows olmayan kullanıcılar ve geliştiricilerin kafa karıştırıcı olduğunu fark eden, yol ve dizin adlarının büyük/küçük harfe duyarlı olduğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-257">A peculiarity of the Windows file system that non-Windows users and developers find confusing is that path and directory names are case-insensitive.</span></span> <span data-ttu-id="2ee54-258">Diğer bir deyişle, dizin ve dosya adları, oluşturulduklarında kullanılan dizelerin büyük küçük harflerini yansıtır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-258">That is, directory and file names reflect the casing of the strings used when they are created.</span></span> <span data-ttu-id="2ee54-259">Örneğin, yöntem çağrısı</span><span class="sxs-lookup"><span data-stu-id="2ee54-259">For example, the method call</span></span>

```csharp
Directory.Create("TeStDiReCtOrY");
```

```vb
Directory.Create("TeStDiReCtOrY")
```

<span data-ttu-id="2ee54-260">TeStDiReCtOrY adlı bir dizin oluşturur.</span><span class="sxs-lookup"><span data-stu-id="2ee54-260">creates a directory named TeStDiReCtOrY.</span></span> <span data-ttu-id="2ee54-261">Bir dizini veya dosyayı durumunu değiştirmek için yeniden adlandırırsanız, dizin veya dosya adı, yeniden adlandırdığınızda kullanılan dize durumunu yansıtır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-261">If you rename a directory or file to change its case, the directory or file name reflects the case of the string used when you rename it.</span></span> <span data-ttu-id="2ee54-262">Örneğin, aşağıdaki kod, Test.txt test.txt adlı bir dosyayı yeniden adlandırır:</span><span class="sxs-lookup"><span data-stu-id="2ee54-262">For example, the following code renames a file named test.txt to Test.txt:</span></span>

[!code-csharp[case-and-renaming](~/samples/snippets/standard/io/file-names/cs/rename.cs)]
[!code-vb[case-and-renaming](~/samples/snippets/standard/io/file-names/vb/rename.vb)]

<span data-ttu-id="2ee54-263">Bununla birlikte, dizin ve dosya adı karşılaştırmaları büyük/küçük harfe duyarlıdır.</span><span class="sxs-lookup"><span data-stu-id="2ee54-263">However, directory and file name comparisons are case-insensitive.</span></span> <span data-ttu-id="2ee54-264">"test.txt" adlı bir dosyayı arıyorsanız, .NET dosya sistemi API 'Leri karşılaştırmayla ilgili büyük/küçük harf durumunu yoksayar.</span><span class="sxs-lookup"><span data-stu-id="2ee54-264">If you search for a file named "test.txt", .NET file system APIs ignore case in the comparison.</span></span> <span data-ttu-id="2ee54-265">"Test.txt", "TEST.TXT", "test.TXT" ve büyük ve küçük harflerin diğer birleşimi "test.txt" ile eşleşir.</span><span class="sxs-lookup"><span data-stu-id="2ee54-265">"Test.txt", "TEST.TXT", "test.TXT", and any other combination of uppercase and lowercase letters will match "test.txt".</span></span>
