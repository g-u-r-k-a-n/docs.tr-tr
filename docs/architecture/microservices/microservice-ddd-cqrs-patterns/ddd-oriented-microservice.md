---
title: DDD odaklı bir mikro hizmet tasarlama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmetleri mimarisi | DDD-odaklı sıralama mikro hizmetinin ve uygulama katmanlarının tasarımını anlayın.
ms.date: 01/13/2021
ms.openlocfilehash: 1d17f0842bb371ce65e96f33d25b2d6e94493396
ms.sourcegitcommit: a4cecb7389f02c27e412b743f9189bd2a6dea4d6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/14/2021
ms.locfileid: "98188341"
---
# <a name="design-a-ddd-oriented-microservice"></a><span data-ttu-id="b36b7-103">DDD-odaklı mikro hizmet tasarlama</span><span class="sxs-lookup"><span data-stu-id="b36b7-103">Design a DDD-oriented microservice</span></span>

<span data-ttu-id="b36b7-104">Etki alanı odaklı tasarım (DDD) kullanım durumlarınızla ilgili olarak iş gerçekliği temelinde modelleme.</span><span class="sxs-lookup"><span data-stu-id="b36b7-104">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="b36b7-105">Uygulama oluşturma bağlamında, DDD, etki alanları olarak sorunlar hakkında konuşur.</span><span class="sxs-lookup"><span data-stu-id="b36b7-105">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="b36b7-106">Bağımsız sorun bölgelerini sınırlanmış bağlamlar (her bir mikro hizmetle ilişkili olan her sınırlı bağlam) ile açıklar ve bu sorunlar hakkında konuşmak için ortak bir dili vurgular.</span><span class="sxs-lookup"><span data-stu-id="b36b7-106">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="b36b7-107">Ayrıca, iç uygulamayı desteklemek için zengin modeller ( [anemik-Domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), değer nesneleri, Toplamalar ve toplam kök (veya kök varlık) kuralları olan etki alanı varlıkları gibi birçok teknik kavram ve desen de önerir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-107">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates, and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="b36b7-108">Bu bölüm, bu iç desenlerin tasarımını ve uygulanmasını tanıtır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-108">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="b36b7-109">Bazen bu ddd teknik kuralları ve desenleri, ddd yaklaşımının uygulanması için bir içerse öğrenme eğrisi olan belirlenen engelleri aşmak olarak algılanır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-109">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="b36b7-110">Ancak önemli bir bölüm desenlerin kendileri değildir, ancak kod, iş sorunlarına göre hizalanmak ve aynı iş koşulları (ubititous dili) kullanılarak düzenlenmez.</span><span class="sxs-lookup"><span data-stu-id="b36b7-110">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="b36b7-111">Ayrıca, DDD yaklaşımları yalnızca önemli iş kurallarıyla karmaşık mikro hizmetler uyguladığınızda uygulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-111">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="b36b7-112">CRUD hizmeti gibi daha basit sorumluluklar daha basit yaklaşımlar ile yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-112">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="b36b7-113">Sınırları nerede çizeceğiniz, mikro hizmet tasarlarken ve tanımlarken anahtar görevdir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-113">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="b36b7-114">DDD desenleri, etki alanındaki karmaşıklığı anlamanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="b36b7-114">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="b36b7-115">Her sınırlanmış bağlam için etki alanı modelinde, etki alanınızı modellemeye yönelik varlıkları, değer nesnelerini ve toplamaları tanımlar ve tanımlarsınız.</span><span class="sxs-lookup"><span data-stu-id="b36b7-115">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="b36b7-116">Bağlamını tanımlayan bir sınır içinde bulunan bir etki alanı modeli oluşturur ve daraltın.</span><span class="sxs-lookup"><span data-stu-id="b36b7-116">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="b36b7-117">Bu, bir mikro hizmet biçiminde açıktır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-117">And that is explicit in the form of a microservice.</span></span> <span data-ttu-id="b36b7-118">Bu sınırların içindeki bileşenler mikro hizmetlerinize göre sona erdir, ancak bazı durumlarda bir BC veya iş mikro hizmetleri çeşitli fiziksel hizmetlerden bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-118">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="b36b7-119">DDD, sınırlardır ve mikro hizmetlerdir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-119">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="b36b7-120">Mikro hizmet bağlamı sınırlarını nispeten küçük tutun</span><span class="sxs-lookup"><span data-stu-id="b36b7-120">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="b36b7-121">Sınırlanmış bağlamlar arasında sınırların nereye yerleştirileceğini belirlemek iki rekabet hedefini dengeler.</span><span class="sxs-lookup"><span data-stu-id="b36b7-121">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="b36b7-122">İlk olarak, mümkün olan en küçük mikro hizmetleri oluşturmak, ancak ana sürücü olmamalıdır; birlikte kullanılması gereken nesnelerin etrafında bir sınır oluşturmalısınız.</span><span class="sxs-lookup"><span data-stu-id="b36b7-122">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="b36b7-123">İkincisi, mikro hizmetler arasındaki geveze iletişimlerine engel olmak istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="b36b7-123">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="b36b7-124">Bu hedefler birbiriyle çelişme edebilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-124">These goals can contradict one another.</span></span> <span data-ttu-id="b36b7-125">Yeni bir sınırlanmış bağlamı ayırma ile ilgili her bir ek deneyle, iletişim sınırlarını hızlı bir şekilde büyüene kadar birçok küçük mikro hizmet olarak bunları dengeleyerek dengeleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b36b7-125">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="b36b7-126">Cohema, tek bir sınırlanmış bağlam içindeki anahtardır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-126">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="b36b7-127">Sınıfları uygularken [uygunsuz kullanım kodu kokusu](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) ile benzerdir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-127">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="b36b7-128">İki mikro hizmetin birbirleriyle çok fazla işbirliği yapması gerekiyorsa, büyük olasılıkla aynı mikro hizmet olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-128">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="b36b7-129">Bu en boy bölümüne baktığın bir başka yolu ise bağımsız çalışma sınırı.</span><span class="sxs-lookup"><span data-stu-id="b36b7-129">Another way to look at this aspect is autonomy.</span></span> <span data-ttu-id="b36b7-130">Bir mikro hizmetin bir isteğe doğrudan hizmet vermek için başka bir hizmete bağlı olması gerekiyorsa, gerçekten otonom değildir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-130">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="b36b7-131">DDD mikro hizmetlerindeki Katmanlar</span><span class="sxs-lookup"><span data-stu-id="b36b7-131">Layers in DDD microservices</span></span>

<span data-ttu-id="b36b7-132">Önemli iş ve teknik karmaşıklık düzeyine sahip kurumsal uygulamaların çoğu birden fazla katman tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-132">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="b36b7-133">Katmanlar bir mantıksal yapıtıdır ve hizmetin dağıtımıyla ilgili değildir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-133">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="b36b7-134">Bunlar, geliştiricilerin koddaki karmaşıklığı yönetmesine yardımcı olmaları için mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="b36b7-134">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="b36b7-135">Farklı katmanlar (örneğin, etki alanı modeli katmanı, sunum katmanı, vb.) farklı türlerde olabilir ve bu türler arasındaki çevirileri zorunlu kılabilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-135">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandate translations between those types.</span></span>

<span data-ttu-id="b36b7-136">Örneğin, veritabanından bir varlık yüklenebilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-136">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="b36b7-137">Daha sonra bu bilgilerin bir kısmı veya diğer varlıklardan ek veriler dahil bir bilgi toplama, istemci kullanıcı arabirimine bir REST Web API 'SI aracılığıyla gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-137">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="b36b7-138">Buradaki nokta, etki alanı varlığının etki alanı model katmanında yer aldığı ve sunum katmanı gibi, ait olmadığı diğer alanlara yayılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-138">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="b36b7-139">Ayrıca, toplam köklerle (kök varlıklar) denetlenen her zaman geçerli varlıklara ( [etki alanı model katmanı bölümünde doğrulamaları tasarlama](domain-model-layer-validations.md) bölümüne bakın) sahip olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-139">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](domain-model-layer-validations.md) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="b36b7-140">Bu nedenle, Kullanıcı arabirimi düzeyinde bazı veriler hala doğrulanmamış olabileceğinden, varlıkların istemci görünümlerine bağlanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-140">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="b36b7-141">Bu nedenle, ViewModel için olduğu şeydir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-141">This reason is what the ViewModel is for.</span></span> <span data-ttu-id="b36b7-142">ViewModel yalnızca sunum katmanı ihtiyaçlarına yönelik bir veri modelidir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-142">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="b36b7-143">Etki alanı varlıkları doğrudan ViewModel 'e ait değildir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-143">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="b36b7-144">Bunun yerine, Viewmodeller ve etki alanı varlıkları arasında çeviri yapmanız ve tam tersi de yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-144">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="b36b7-145">Bu karmaşıklıktan dolayı, bu varlık grubuyla ilgili (toplama) tüm ınvaryantlar ve kuralların toplam bir giriş noktası veya kapısı aracılığıyla gerçekleştirildiğinden emin olmak için toplam köklere göre denetlenen bir etki alanı modeli olması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-145">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</span></span>

<span data-ttu-id="b36b7-146">Şekil 7-5 ' de, bir katmanlı tasarımın eShopOnContainers uygulamasında nasıl uygulandığı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-146">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![Etki alanı odaklı tasarım mikro hizmetindeki katmanların gösterildiği diyagram.](./media/ddd-oriented-microservice/domain-driven-design-microservice.png)

<span data-ttu-id="b36b7-148">**Şekil 7-5**.</span><span class="sxs-lookup"><span data-stu-id="b36b7-148">**Figure 7-5**.</span></span> <span data-ttu-id="b36b7-149">EShopOnContainers 'da sıralama mikro hizmetindeki DDD katmanları</span><span class="sxs-lookup"><span data-stu-id="b36b7-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="b36b7-150">Bir DDD mikro hizmetindeki sıralama gibi üç katman.</span><span class="sxs-lookup"><span data-stu-id="b36b7-150">The three layers in a DDD microservice like Ordering.</span></span> <span data-ttu-id="b36b7-151">Her katman bir VS projem: uygulama katmanı sıralama. API, etki alanı katmanı sıralama. etki alanı ve altyapı katmanı sıralama. altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-151">Each layer is a VS project: Application layer is Ordering.API, Domain layer is Ordering.Domain and the Infrastructure layer is Ordering.Infrastructure.</span></span> <span data-ttu-id="b36b7-152">Her katmanın yalnızca belirli diğer katmanlarla iletişim kurduğu şekilde sistemi tasarlamak istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="b36b7-152">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="b36b7-153">Bu yaklaşım, kitaplıklar arasında hangi bağımlılıkların ayarlandığını açıkça belirleyebildiğinden, Katmanlar farklı sınıf kitaplıkları olarak uygulanırsa, bu yaklaşıma zorlamak daha kolay olabilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-153">That approach may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="b36b7-154">Örneğin, etki alanı model katmanı başka bir katmana bağımlılık alamaz (etki alanı model sınıfları, düz eski CLR nesneleri veya [poco](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), sınıflar olmalıdır).</span><span class="sxs-lookup"><span data-stu-id="b36b7-154">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="b36b7-155">Şekil 7-6 ' de gösterildiği gibi, **sıralama. Domain** katman kitaplığı yalnızca .NET kitaplıkları veya NuGet paketlerinde bağımlılıklara sahiptir, ancak veri kitaplığı veya kalıcılık kitaplığı gibi özel bir kitaplıkta değildir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-155">As shown in Figure 7-6, the **Ordering.Domain** layer library has dependencies only on the .NET libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></span>

![Sıralama. etki alanı bağımlılıklarını ekran görüntüsü.](./media/ddd-oriented-microservice/ordering-domain-dependencies.png)

<span data-ttu-id="b36b7-157">**Şekil 7-6**.</span><span class="sxs-lookup"><span data-stu-id="b36b7-157">**Figure 7-6**.</span></span> <span data-ttu-id="b36b7-158">Kitaplıklar olarak uygulanan katmanlar Katmanlar arasındaki bağımlılıklara daha iyi denetim sağlar</span><span class="sxs-lookup"><span data-stu-id="b36b7-158">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="b36b7-159">Etki alanı model katmanı</span><span class="sxs-lookup"><span data-stu-id="b36b7-159">The domain model layer</span></span>

<span data-ttu-id="b36b7-160">Eric Evans 'ın mükemmel kitap [etki alanı odaklı tasarımı](https://domainlanguage.com/ddd/) , etki alanı modeli katmanı ve uygulama katmanı hakkında aşağıdakileri söyler.</span><span class="sxs-lookup"><span data-stu-id="b36b7-160">Eric Evans's excellent book [Domain Driven Design](https://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="b36b7-161">**Etki alanı modeli katmanı**: işletmenin kavramlarını, iş durumu hakkında bilgileri ve iş kurallarını temsil eden sorumludur.</span><span class="sxs-lookup"><span data-stu-id="b36b7-161">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="b36b7-162">İş durumunu yansıtan eyalet, bu altyapıyı depolamanın teknik ayrıntıları altyapıya atanmış olsa bile burada kontrol edilir ve burada kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-162">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="b36b7-163">Bu katman, iş yazılımının kalbidir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-163">This layer is the heart of business software.</span></span>

<span data-ttu-id="b36b7-164">Etki alanı modeli katmanı, işletmenin ifade edildiği yerdir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-164">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="b36b7-165">.NET ' te bir mikro hizmet etki alanı model katmanı uyguladığınızda, bu katman veri ve davranışı (Logic ile Yöntemler) yakalayan etki alanı varlıklarını içeren bir sınıf kitaplığı olarak kodlanır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-165">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="b36b7-166">[Kalıcılık Ignorance](https://deviq.com/persistence-ignorance/) ve [altyapı Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) ilkelerine göre, bu katmanın veri kalıcılığı ayrıntılarını tamamen yoksayması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-166">Following the [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="b36b7-167">Bu Kalıcılık görevleri altyapı katmanı tarafından gerçekleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-167">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="b36b7-168">Bu nedenle, bu katmanın altyapı üzerinde doğrudan bağımlılıkları olmaması gerekir. Bu, önemli bir kuralın, etki alanı modeli varlık sınıflarınızın [poco](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)'lar olması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-168">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="b36b7-169">Etki alanı varlıklarının, Entity Framework veya Nhazırda bekleme gibi herhangi bir veri erişim altyapısı çerçevesinde doğrudan bağımlılığı (taban sınıftan türeme gibi) olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-169">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="b36b7-170">İdeal olarak, etki alanı varlıklarınız herhangi bir altyapı çerçevesinde tanımlı herhangi bir türden türetilmemelidir veya uygulamamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-170">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="b36b7-171">Entity Framework Core benzer modern ORM çerçeveleri bu yaklaşıma izin veriyor, böylece etki alanı model sınıflarınız altyapıyla birlikte kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="b36b7-171">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="b36b7-172">Ancak, Azure Service Fabric aktörler ve güvenilir Koleksiyonlar gibi belirli NoSQL veritabanları ve çerçeveleri kullanılırken POCO varlıklarının bulunması her zaman mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-172">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="b36b7-173">Etki alanı modelinize yönelik kalıcılık Ignorance ilkesini izlemek önemli olduğunda bile, kalıcılık sorunlarını yoksaymamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-173">Even when it is important to follow the Persistence Ignorance principle for your Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="b36b7-174">Fiziksel veri modelini ve varlık nesne modelinize nasıl eşlendiğini anlamak hala önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-174">It is still important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="b36b7-175">Aksi takdirde, imkansız tasarımlar oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b36b7-175">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="b36b7-176">Ayrıca, bu boyut, ilişkisel bir veritabanı için tasarlanmış bir modeli alıp bir NoSQL veya belge odaklı veritabanına doğrudan taşıyabilmeniz anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="b36b7-176">Also, this aspect does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="b36b7-177">Bazı varlık modellerinde model uygun olabilir, ancak genellikle bu değildir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-177">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="b36b7-178">Varlık modelinizin, her ikisi de depolama teknolojisine ve ORM teknolojisine bağlı olarak uyması gereken kısıtlamalar vardır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-178">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="b36b7-179">Uygulama katmanı</span><span class="sxs-lookup"><span data-stu-id="b36b7-179">The application layer</span></span>

<span data-ttu-id="b36b7-180">Uygulama katmanına geçiş yaparken, Eric Evans 'ın [etki alanı odaklı tasarımını](https://domainlanguage.com/ddd/)daha iyi bir şekilde ayırıyoruz:</span><span class="sxs-lookup"><span data-stu-id="b36b7-180">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](https://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="b36b7-181">**Uygulama katmanı:** Yazılımın yapması beklenen işleri tanımlar ve ifade eden etki alanı nesnelerini, sorunları gidermek için yönlendirir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-181">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="b36b7-182">Bu katmanın sorumlu olduğu görevler işletmeye göre anlamlıdır veya diğer sistemlerin uygulama katmanlarıyla etkileşim için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-182">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="b36b7-183">Bu katman ince tutulur.</span><span class="sxs-lookup"><span data-stu-id="b36b7-183">This layer is kept thin.</span></span> <span data-ttu-id="b36b7-184">İş kuralları veya bilgi içermez, ancak yalnızca sonraki katmandaki etki alanı nesnelerinin işbirliği yaptığı görevleri ve temsilcileri koordine eder.</span><span class="sxs-lookup"><span data-stu-id="b36b7-184">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="b36b7-185">İş durumunu yansıtan bir durumu yoktur, ancak kullanıcı veya program için bir görevin ilerlemesini yansıtan bir durum olabilir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-185">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="b36b7-186">.NET 'teki bir mikro hizmetin uygulama katmanı genellikle ASP.NET Core Web API projesi olarak kodlanır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-186">A microservice's application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="b36b7-187">Proje, mikro hizmetin etkileşimini, uzak ağ erişimini ve kullanıcı arabiriminden veya istemci uygulamalarından kullanılan dış Web API 'Lerini uygular.</span><span class="sxs-lookup"><span data-stu-id="b36b7-187">The project implements the microservice's interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="b36b7-188">CQRS yaklaşımını, mikro hizmet tarafından kabul edilen komutları ve hatta mikro hizmetler arasındaki olay odaklı iletişimi (Tümleştirme olayları) kullanarak sorgular içerir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-188">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="b36b7-189">Uygulama katmanını temsil eden ASP.NET Core Web API 'SI, iş kuralları veya etki alanı bilgisi içermemelidir (özellikle işlemler veya güncelleştirmeler için etki alanı kuralları); Bunlar, etki alanı modeli sınıf kitaplığına ait olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-189">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="b36b7-190">Uygulama katmanının yalnızca görevleri koordine ve herhangi bir etki alanı durumu (etki alanı modeli) tutmamalıdır veya tanımlamamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-190">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="b36b7-191">İş kurallarının yürütülmesini, etki alanı modeli sınıflarının kendilerine (Toplam kökler ve etki alanı varlıkları) yürütmesini devreder ve bu da bu etki alanı varlıklarındaki verileri son olarak güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-191">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="b36b7-192">Temel olarak uygulama mantığı, belirli bir ön uca bağlı olan tüm kullanım durumlarını uyguladığınız yerdir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-192">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="b36b7-193">Örneğin, bir Web API hizmeti ile ilgili uygulama.</span><span class="sxs-lookup"><span data-stu-id="b36b7-193">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="b36b7-194">Amaç, etki alanı modeli katmanındaki etki alanı mantığının, ınvaryantlar, veri modeli ve ilgili iş kurallarının, sunum ve uygulama katmanlarından tamamen bağımsız olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-194">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="b36b7-195">Çoğu, etki alanı modeli katmanının herhangi bir altyapı çerçevesine doğrudan bağlı olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-195">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="b36b7-196">Altyapı katmanı</span><span class="sxs-lookup"><span data-stu-id="b36b7-196">The infrastructure layer</span></span>

<span data-ttu-id="b36b7-197">Altyapı katmanı, ilk olarak etki alanı varlıklarında (bellekte) tutulan verilerin veritabanlarında veya başka bir kalıcı depoda kalıcı olarak nasıl sürdürümğidir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-197">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="b36b7-198">Bir örnek, verileri ilişkisel bir veritabanında kalıcı hale getirmek için DBContext kullanan depo model sınıflarını uygulamak üzere Entity Framework Core kodu kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-198">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="b36b7-199">Daha önce bahsedilen [Kalıcılık](https://deviq.com/persistence-ignorance/) kaldırma ve [altyapı](https://ayende.com/blog/3137/infrastructure-ignorance) kaldırma ilkelerine uygun olarak, altyapı katmanının etki alanı modeli katmanını "kirmini" olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-199">In accordance with the previously mentioned [Persistence Ignorance](https://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not "contaminate" the domain model layer.</span></span> <span data-ttu-id="b36b7-200">Çerçeveler üzerinde sabit bağımlılıklar olmaksızın, verileri (EF veya diğer herhangi bir çerçeve) sürdürmek için kullandığınız altyapıdan, etki alanı modeli varlık sınıflarını agntik tutmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-200">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="b36b7-201">Etki alanı modeli katman sınıfı kitaplığınızın yalnızca etki alanı kodunuz olmalıdır, yalnızca yazılımınızın temelini oluşturan ve altyapı teknolojisinden tamamen ayrılmış bir [poco](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) varlık sınıfları olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-201">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="b36b7-202">Bu nedenle, Şekil 7-7 ' de gösterildiği gibi, katmanlarınızın veya sınıf kitaplıklarınızın ve projelerinizin sonunda etki alanı model katmanına (kitaplık) bağlı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-202">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</span></span>

![DDD hizmet katmanları arasında var olan bağımlılıkları gösteren diyagram.](./media/ddd-oriented-microservice/ddd-service-layer-dependencies.png)

<span data-ttu-id="b36b7-204">**Şekil 7-7**.</span><span class="sxs-lookup"><span data-stu-id="b36b7-204">**Figure 7-7**.</span></span> <span data-ttu-id="b36b7-205">DDD içindeki Katmanlar arasındaki bağımlılıklar</span><span class="sxs-lookup"><span data-stu-id="b36b7-205">Dependencies between layers in DDD</span></span>

<span data-ttu-id="b36b7-206">Bir DDD hizmetindeki bağımlılıklar, uygulama katmanı etki alanı ve altyapıya bağlıdır ve altyapı etki alanına bağlıdır, ancak etki alanı herhangi bir katmana bağlı değildir.</span><span class="sxs-lookup"><span data-stu-id="b36b7-206">Dependencies in a DDD Service, the Application layer depends on Domain and Infrastructure, and Infrastructure depends on Domain, but Domain doesn't depend on any layer.</span></span> <span data-ttu-id="b36b7-207">Bu katman tasarımı her mikro hizmet için bağımsız olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b36b7-207">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="b36b7-208">Daha önce belirtildiği gibi, daha basit bir şekilde veri odaklı mikro hizmetleri (tek bir katmanda basit CRUD) daha kolay bir şekilde uygularken, DDD desenlerini izleyen en karmaşık mikro hizmetleri de uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b36b7-208">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b36b7-209">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b36b7-209">Additional resources</span></span>

- <span data-ttu-id="b36b7-210">**Sapq. Kalıcılık Ignorance ilkesi** </span><span class="sxs-lookup"><span data-stu-id="b36b7-210">**DevIQ. Persistence Ignorance principle** </span></span>\
  <https://deviq.com/persistence-ignorance/>

- <span data-ttu-id="b36b7-211">**Oren Eini. Altyapı Ignorance** </span><span class="sxs-lookup"><span data-stu-id="b36b7-211">**Oren Eini. Infrastructure Ignorance** </span></span>\
  <https://ayende.com/blog/3137/infrastructure-ignorance>

- <span data-ttu-id="b36b7-212">**Anlek Lopez. Domain-Driven tasarımında katmanlı mimari** </span><span class="sxs-lookup"><span data-stu-id="b36b7-212">**Angel Lopez. Layered Architecture In Domain-Driven Design** </span></span>\
  <https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/>

>[!div class="step-by-step"]
><span data-ttu-id="b36b7-213">[Önceki](cqrs-microservice-reads.md) 
> [Sonraki](microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="b36b7-213">[Previous](cqrs-microservice-reads.md)
[Next](microservice-domain-model.md)</span></span>
