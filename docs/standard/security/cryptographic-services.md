---
title: Şifreleme Hizmetleri
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- cryptography [.NET Framework]
- pattern of derived class inheritance
- digital signatures
- asymmetric cryptographic algorithms
- digital signatures, public-key systems
- public keys
- decryption [.NET Framework]
- private keys
- MAC algorithms
- cryptographic algorithms
- private keys, overview
- encryption [.NET Framework]
- security [.NET Framework], encryption
- cryptographic services
- symmetric cryptographic algorithms
- hash
- message authentication codes
- derived class inheritance
- cryptography [.NET Framework], about
- random number generation
ms.assetid: f96284bc-7b73-44b5-ac59-fac613ad09f8
ms.openlocfilehash: c1783a578d0b55b0b62a1ffb870802faca97623f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187005"
---
# <a name="cryptographic-services"></a><span data-ttu-id="0af7f-102">Şifreleme Hizmetleri</span><span class="sxs-lookup"><span data-stu-id="0af7f-102">Cryptographic Services</span></span>

<span data-ttu-id="0af7f-103">Internet gibi genel ağlar, varlıklar arasında güvenli bir iletişim aracı sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-103">Public networks such as the Internet do not provide a means of secure communication between entities.</span></span> <span data-ttu-id="0af7f-104">Bu tür ağlar üzerinden iletişim, yetkisiz üçüncü şahıslar tarafından okunmaya ve hatta değiştirilmeye açıktır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-104">Communication over such networks is susceptible to being read or even modified by unauthorized third parties.</span></span> <span data-ttu-id="0af7f-105">Şifreleme, verilerin görüntülenmesini korumaya yardımcı olur, verilerin değiştirilip değiştirilmediğini algılamanın yollarını sağlar ve aksi takdirde güvenli olmayan kanallar üzerinden güvenli bir iletişim aracı sağlamaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-105">Cryptography helps protect data from being viewed, provides ways to detect whether data has been modified, and helps provide a secure means of communication over otherwise nonsecure channels.</span></span> <span data-ttu-id="0af7f-106">Örneğin, veriler bir şifreleme algoritması kullanılarak şifrelenebilir, şifreli bir durumda iletilebilir ve daha sonra amaçlanan taraf tarafından şifresi çözülebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-106">For example, data can be encrypted by using a cryptographic algorithm, transmitted in an encrypted state, and later decrypted by the intended party.</span></span> <span data-ttu-id="0af7f-107">Üçüncü bir taraf şifrelenmiş verileri ele gevelürse, şifreyi çözmek zor olacaktır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-107">If a third party intercepts the encrypted data, it will be difficult to decipher.</span></span>

<span data-ttu-id="0af7f-108">.NET Framework'de, <xref:System.Security.Cryptography?displayProperty=nameWithType> ad alanındaki sınıflar sizin için şifrelemenin birçok ayrıntısını yönetir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-108">In the .NET Framework, the classes in the <xref:System.Security.Cryptography?displayProperty=nameWithType> namespace manage many details of cryptography for you.</span></span> <span data-ttu-id="0af7f-109">Bazıları yönetilmeyen Microsoft Şifreleme API'si (CryptoAPI) için paketleyiciler, diğerleri ise tamamen yönetilen uygulamalardır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-109">Some are wrappers for the unmanaged Microsoft Cryptography API (CryptoAPI), while others are purely managed implementations.</span></span> <span data-ttu-id="0af7f-110">Bu sınıfları kullanmak için şifreleme uzmanı olmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="0af7f-110">You do not need to be an expert in cryptography to use these classes.</span></span> <span data-ttu-id="0af7f-111">Şifreleme algoritması sınıflarından birinin yeni bir örneğini oluşturduğunuzda, anahtarlar kullanım kolaylığı için otomatik olarak oluşturulur ve varsayılan özellikler olabildiğince güvenli ve emniyetli olur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-111">When you create a new instance of one of the encryption algorithm classes, keys are autogenerated for ease of use, and default properties are as safe and secure as possible.</span></span>

<span data-ttu-id="0af7f-112">Bu genel bakış, .NET Framework 3.5'te tanıtılan ClickOnce bildirimleri, Suite B ve Şifreleme Yeni Nesil (CNG) desteği de dahil olmak üzere .NET Framework tarafından desteklenen şifreleme yöntemlerinin ve uygulamalarının bir özetini sağlar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-112">This overview provides a synopsis of the encryption methods and practices supported by the .NET Framework, including the ClickOnce manifests, Suite B, and Cryptography Next Generation (CNG) support introduced in the .NET Framework 3.5.</span></span>

<span data-ttu-id="0af7f-113">Şifreleme ve Microsoft hizmetleri, bileşenleri ve uygulamalarınız için şifreleme güvenliği eklemenize olanak tanıyan araçlar hakkında daha fazla bilgi için bu belgelerin Win32 ve COM Geliştirme, Güvenlik bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="0af7f-113">For additional information about cryptography and about Microsoft services, components, and tools that enable you to add cryptographic security to your applications, see the Win32 and COM Development, Security section of this documentation.</span></span>

## <a name="cryptographic-primitives"></a><span data-ttu-id="0af7f-114">Kriptografik İlkeller</span><span class="sxs-lookup"><span data-stu-id="0af7f-114">Cryptographic Primitives</span></span>

<span data-ttu-id="0af7f-115">Şifrelemenin kullanıldığı tipik bir durumda, iki taraf (Gamze ve Kemal) güvenli olmayan bir kanal üzerinden iletişim kurar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-115">In a typical situation where cryptography is used, two parties (Alice and Bob) communicate over a nonsecure channel.</span></span> <span data-ttu-id="0af7f-116">Alice ve Bob, dinleyen herkes tarafından iletişimlerinin anlaşılmaz kalmasını istiyor.</span><span class="sxs-lookup"><span data-stu-id="0af7f-116">Alice and Bob want to ensure that their communication remains incomprehensible by anyone who might be listening.</span></span> <span data-ttu-id="0af7f-117">Ayrıca, Gamze ve Bob uzak konumlarda olduğundan, Gamze'nin Bob'dan aldığı bilgilerin iletim sırasında kimse tarafından değiştirilmediğinden emin olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-117">Furthermore, because Alice and Bob are in remote locations, Alice must make sure that the information she receives from Bob has not been modified by anyone during transmission.</span></span> <span data-ttu-id="0af7f-118">Buna ek olarak, bilgilerin gerçekten Bob'u taklit eden birinden değil, Bob'dan kaynaklandığından emin olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-118">In addition, she must make sure that the information really does originate from Bob and not from someone who is impersonating Bob.</span></span>

<span data-ttu-id="0af7f-119">Şifreleme aşağıdaki hedeflere ulaşmak için kullanılır:</span><span class="sxs-lookup"><span data-stu-id="0af7f-119">Cryptography is used to achieve the following goals:</span></span>

- <span data-ttu-id="0af7f-120">Gizlilik: Kullanıcının kimliğinin veya verilerinin okunmasını korumaya yardımcı olmak için.</span><span class="sxs-lookup"><span data-stu-id="0af7f-120">Confidentiality: To help protect a user's identity or data from being read.</span></span>

- <span data-ttu-id="0af7f-121">Veri bütünlüğü: Verilerin değiştirilmesini korumaya yardımcı olmak için.</span><span class="sxs-lookup"><span data-stu-id="0af7f-121">Data integrity: To help protect data from being changed.</span></span>

- <span data-ttu-id="0af7f-122">Kimlik doğrulama: Verilerin belirli bir partiden kaynaklandığından emin olmak için.</span><span class="sxs-lookup"><span data-stu-id="0af7f-122">Authentication: To ensure that data originates from a particular party.</span></span>

- <span data-ttu-id="0af7f-123">İnkar etmeme: Belirli bir tarafın bir ileti gönderdiğini reddetmesini engellemek için.</span><span class="sxs-lookup"><span data-stu-id="0af7f-123">Non-repudiation: To prevent a particular party from denying that they sent a message.</span></span>

<span data-ttu-id="0af7f-124">Bu hedeflere ulaşmak için, şifreleme düzeni oluşturmak için şifreleme ilkelolarak bilinen algoritmalar ve uygulamaların bir birleşimini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-124">To achieve these goals, you can use a combination of algorithms and practices known as cryptographic primitives to create a cryptographic scheme.</span></span> <span data-ttu-id="0af7f-125">Aşağıdaki tabloda şifreleme ilkelleri ve kullanımları listelenebilmelidir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-125">The following table lists the cryptographic primitives and their uses.</span></span>

|<span data-ttu-id="0af7f-126">Kriptografik ilkel</span><span class="sxs-lookup"><span data-stu-id="0af7f-126">Cryptographic primitive</span></span>|<span data-ttu-id="0af7f-127">Kullanım</span><span class="sxs-lookup"><span data-stu-id="0af7f-127">Use</span></span>|
|-----------------------------|---------|
|<span data-ttu-id="0af7f-128">Gizli anahtar şifrelemesi (simetrik şifreleme)</span><span class="sxs-lookup"><span data-stu-id="0af7f-128">Secret-key encryption (symmetric cryptography)</span></span>|<span data-ttu-id="0af7f-129">Üçüncü şahıslar tarafından okunmasını engellemek için veriler üzerinde bir dönüşüm gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-129">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="0af7f-130">Bu tür şifreleme, verileri şifrelemek ve şifresini çözmek için tek bir paylaşılan gizli anahtar kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-130">This type of encryption uses a single shared, secret key to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="0af7f-131">Ortak anahtar şifrelemesi (asimetrik şifreleme)</span><span class="sxs-lookup"><span data-stu-id="0af7f-131">Public-key encryption (asymmetric cryptography)</span></span>|<span data-ttu-id="0af7f-132">Üçüncü şahıslar tarafından okunmasını engellemek için veriler üzerinde bir dönüşüm gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-132">Performs a transformation on data to keep it from being read by third parties.</span></span> <span data-ttu-id="0af7f-133">Bu tür şifreleme, verileri şifrelemek ve şifresini çözmek için ortak/özel anahtar çiftini kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-133">This type of encryption uses a public/private key pair to encrypt and decrypt data.</span></span>|
|<span data-ttu-id="0af7f-134">Şifreleme imzalama</span><span class="sxs-lookup"><span data-stu-id="0af7f-134">Cryptographic signing</span></span>|<span data-ttu-id="0af7f-135">Bu tarafa özgü bir dijital imza oluşturarak verilerin belirli bir partiden kaynaklandığını doğrulamaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-135">Helps verify that data originates from a specific party by creating a digital signature that is unique to that party.</span></span> <span data-ttu-id="0af7f-136">Bu işlem karma işlevleri de kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-136">This process also uses hash functions.</span></span>|
|<span data-ttu-id="0af7f-137">Şifreleme karmaları</span><span class="sxs-lookup"><span data-stu-id="0af7f-137">Cryptographic hashes</span></span>|<span data-ttu-id="0af7f-138">Verileri herhangi bir uzunluktan sabit uzunlukta bayt sırasına göre eşler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-138">Maps data from any length to a fixed-length byte sequence.</span></span> <span data-ttu-id="0af7f-139">Haşiyeler istatistiksel olarak benzersizdir; farklı bir iki bayt dizisi aynı değere karma olmaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-139">Hashes are statistically unique; a different two-byte sequence will not hash to the same value.</span></span>|

## <a name="secret-key-encryption"></a><span data-ttu-id="0af7f-140">Gizli Anahtar Şifrelemesi</span><span class="sxs-lookup"><span data-stu-id="0af7f-140">Secret-Key Encryption</span></span>

<span data-ttu-id="0af7f-141">Gizli anahtar şifreleme algoritmaları, verileri şifrelemek ve çözmek için tek bir gizli anahtar kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-141">Secret-key encryption algorithms use a single secret key to encrypt and decrypt data.</span></span> <span data-ttu-id="0af7f-142">Anahtarıyetkisiz aracılar tarafından erişimden korumanız gerekir, çünkü anahtara sahip olan herhangi bir taraf, verilerinizi şifrelemek veya kendi verilerini şifrelemek için kullanabilir ve bu anahtarın sizden kaynaklandığını iddia edebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-142">You must secure the key from access by unauthorized agents, because any party that has the key can use it to decrypt your data or encrypt their own data, claiming it originated from you.</span></span>

<span data-ttu-id="0af7f-143">Aynı anahtar şifreleme ve şifre çözme için kullanıldığından, gizli anahtar şifrelemesi de simetrik şifreleme olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-143">Secret-key encryption is also referred to as symmetric encryption because the same key is used for encryption and decryption.</span></span> <span data-ttu-id="0af7f-144">Gizli anahtar şifreleme algoritmaları çok hızlıdır (ortak anahtar algoritmalarıyla karşılaştırıldığında) ve büyük veri akışları üzerinde şifreleme dönüşümleri gerçekleştirmek için uygundur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-144">Secret-key encryption algorithms are very fast (compared with public-key algorithms) and are well suited for performing cryptographic transformations on large streams of data.</span></span> <span data-ttu-id="0af7f-145">RSA gibi asimetrik şifreleme algoritmaları matematiksel olarak ne kadar veriyi şifreleyebilirler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-145">Asymmetric encryption algorithms such as RSA are limited mathematically in how much data they can encrypt.</span></span> <span data-ttu-id="0af7f-146">Simetrik şifreleme algoritmaları genellikle bu sorunları yok.</span><span class="sxs-lookup"><span data-stu-id="0af7f-146">Symmetric encryption algorithms do not generally have those problems.</span></span>

<span data-ttu-id="0af7f-147">Bir anda bir veri bloğunu şifrelemek için blok şifresi adı verilen bir gizli anahtar algoritması türü kullanılır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-147">A type of secret-key algorithm called a block cipher is used to encrypt one block of data at a time.</span></span> <span data-ttu-id="0af7f-148">Veri Şifreleme Standardı (DES), TripleDES ve Advanced Encryption Standard (AES) gibi blok şifreleri, *n* bayt giriş bloğunu şifreli baytlardan oluşan bir çıkış bloğuna dönüştürün.</span><span class="sxs-lookup"><span data-stu-id="0af7f-148">Block ciphers such as Data Encryption Standard (DES), TripleDES, and Advanced Encryption Standard (AES) cryptographically transform an input block of *n* bytes into an output block of encrypted bytes.</span></span> <span data-ttu-id="0af7f-149">Bir bayt dizisini şifrelemek veya şifresini çözmek istiyorsanız, bunu engelleme yle yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-149">If you want to encrypt or decrypt a sequence of bytes, you have to do it block by block.</span></span> <span data-ttu-id="0af7f-150">*n* küçük olduğundan (DES ve TripleDES için 8 bayt; 16 bayt [varsayılan], 24 bayt veya AES için 32 bayt), *n'den* büyük veri değerlerinin bir defada bir blok şifrelenilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-150">Because *n* is small (8 bytes for DES and TripleDES; 16 bytes [the default], 24 bytes, or 32 bytes for AES), data values that are larger than *n* have to be encrypted one block at a time.</span></span> <span data-ttu-id="0af7f-151">*N'den* küçük olan veri değerlerinin işlenmesi için *n'ye* genişletilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-151">Data values that are smaller than *n* have to be expanded to *n* in order to be processed.</span></span>

<span data-ttu-id="0af7f-152">Blok şifresinin basit bir biçimine elektronik kod kitabı (ECB) modu denir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-152">One simple form of block cipher is called the electronic codebook (ECB) mode.</span></span> <span data-ttu-id="0af7f-153">Ecb modu güvenli olarak kabul edilmez, çünkü ilk düz metin bloğunu başlatmak için bir başlatma vektörü kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-153">ECB mode is not considered secure, because it does not use an initialization vector to initialize the first plaintext block.</span></span> <span data-ttu-id="0af7f-154">Belirli bir gizli anahtar *k*için, bir başlatma vektörü kullanmayan basit bir blok şifresi, aynı giriş bloğunu düz metin bloğunu şifrelemek için aynı çıkış bloğunu şifreler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-154">For a given secret key *k*, a simple block cipher that does not use an initialization vector will encrypt the same input block of plaintext into the same output block of ciphertext.</span></span> <span data-ttu-id="0af7f-155">Bu nedenle, giriş düz metin akışınızda yinelenen bloklar varsa, çıktı şifreleme metni akışınızda yinelenen bloklar olacaktır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-155">Therefore, if you have duplicate blocks in your input plaintext stream, you will have duplicate blocks in your output ciphertext stream.</span></span> <span data-ttu-id="0af7f-156">Bu yinelenen çıktı blokları, yetkisiz kullanıcıları, kullanılmış olabilecek algoritmaları ve olası saldırı modlarını kullanan zayıf şifrelemeye karşı uyarır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-156">These duplicate output blocks alert unauthorized users to the weak encryption used the algorithms that might have been employed, and the possible modes of attack.</span></span> <span data-ttu-id="0af7f-157">Bu nedenle ECB şifreleme modu analize ve nihayetinde önemli keşiflere karşı oldukça savunmasızdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-157">The ECB cipher mode is therefore quite vulnerable to analysis, and ultimately, key discovery.</span></span>

<span data-ttu-id="0af7f-158">Taban sınıf kitaplığında sağlanan blok şifreleme sınıfları, isterseniz bu varsayılanı değiştirebilirsiniz, ancak şifreleme bloğu zincirleme (CBC) adı verilen varsayılan zincirleme modu kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-158">The block cipher classes that are provided in the base class library use a default chaining mode called cipher-block chaining (CBC), although you can change this default if you want.</span></span>

<span data-ttu-id="0af7f-159">CBC şifreleri, ilk düz metin bloğunu şifrelemek için bir başlatma vektörü (IV) kullanarak ECB şifreleriyle ilişkili sorunların üstesinden gelir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-159">CBC ciphers overcome the problems associated with ECB ciphers by using an initialization vector (IV) to encrypt the first block of plaintext.</span></span> <span data-ttu-id="0af7f-160">Sonraki her düz metin bloğu, şifrelenmeden`XOR`önce önceki şifreleme bloğuyla bitwise özel OR ( ) işleminden geçer.</span><span class="sxs-lookup"><span data-stu-id="0af7f-160">Each subsequent block of plaintext undergoes a bitwise exclusive OR (`XOR`) operation with the previous ciphertext block before it is encrypted.</span></span> <span data-ttu-id="0af7f-161">Bu nedenle, her şifreleme metni bloğu önceki tüm bloklar bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-161">Each ciphertext block is therefore dependent on all previous blocks.</span></span> <span data-ttu-id="0af7f-162">Bu sistem kullanıldığında, yetkisiz bir kullanıcı tarafından bilinen ortak ileti üstbilgisi, bir anahtarı tersine mühendislikle tasarlamak için kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-162">When this system is used, common message headers that might be known to an unauthorized user cannot be used to reverse-engineer a key.</span></span>

<span data-ttu-id="0af7f-163">CBC şifresi ile şifrelenmiş verileri tehlikeye atmanın bir yolu, mümkün olan her anahtarda kapsamlı bir arama yapmaktır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-163">One way to compromise data that is encrypted with a CBC cipher is to perform an exhaustive search of every possible key.</span></span> <span data-ttu-id="0af7f-164">Şifreleme gerçekleştirmek için kullanılan anahtarın boyutuna bağlı olarak, bu tür bir arama en hızlı bilgisayarları bile kullanarak çok zaman alır ve bu nedenle olanaksızdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-164">Depending on the size of the key that is used to perform encryption, this kind of search is very time-consuming using even the fastest computers and is therefore infeasible.</span></span> <span data-ttu-id="0af7f-165">Daha büyük anahtar boyutlarını çözmek daha zordur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-165">Larger key sizes are more difficult to decipher.</span></span> <span data-ttu-id="0af7f-166">Şifreleme, bir düşmanın şifrelenmiş verileri almayı teorik olarak imkansız hale getirmese de, bunu yapmanın maliyetini yükseltir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-166">Although encryption does not make it theoretically impossible for an adversary to retrieve the encrypted data, it does raise the cost of doing this.</span></span> <span data-ttu-id="0af7f-167">Yalnızca birkaç gün için anlamlı olan verileri almak için kapsamlı bir arama yapmak üç ay sürerse, kapsamlı arama yöntemi pratik değildir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-167">If it takes three months to perform an exhaustive search to retrieve data that is meaningful only for a few days, the exhaustive search method is impractical.</span></span>

<span data-ttu-id="0af7f-168">Gizli anahtar şifrelemesinin dezavantajı, iki tarafın bir anahtar ve IV üzerinde anlaştığını ve değerlerini ilettiğini varsayıyor olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-168">The disadvantage of secret-key encryption is that it presumes two parties have agreed on a key and IV, and communicated their values.</span></span> <span data-ttu-id="0af7f-169">IV bir sır olarak kabul edilmez ve mesaj ile düz metin olarak iletilebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-169">The IV is not considered a secret and can be transmitted in plaintext with the message.</span></span> <span data-ttu-id="0af7f-170">Ancak, anahtar yetkisiz kullanıcılardan gizli tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-170">However, the key must be kept secret from unauthorized users.</span></span> <span data-ttu-id="0af7f-171">Bu sorunlar nedeniyle, gizli anahtar şifrelemegenellikle anahtar ve IV değerlerini özel olarak iletmek için ortak anahtar şifrelemesi ile birlikte kullanılır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-171">Because of these problems, secret-key encryption is often used together with public-key encryption to privately communicate the values of the key and IV.</span></span>

<span data-ttu-id="0af7f-172">Gamze ve Bob'un güvenli olmayan bir kanal üzerinden iletişim kurmak isteyen iki taraf olduğunu varsayarsak, gizli anahtar şifrelemesini aşağıdaki gibi kullanabilirler: Gamze ve Bob belirli bir algoritmayı (örneğin AES, örneğin) belirli bir anahtar ve IV ile kullanmayı kabul ederler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-172">Assuming that Alice and Bob are two parties who want to communicate over a nonsecure channel, they might use secret-key encryption as follows: Alice and Bob agree to use one particular algorithm (AES, for example) with a particular key and IV.</span></span> <span data-ttu-id="0af7f-173">Alice bir ileti oluşturur ve iletiyi göndermek için bir ağ akışı (belki de adlandırılmış bir kanal veya ağ e-postası) oluşturur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-173">Alice composes a message and creates a network stream (perhaps a named pipe or network email) on which to send the message.</span></span> <span data-ttu-id="0af7f-174">Sonra, anahtarı ve IV'u kullanarak metni şifreler ve intranet üzerinden Bob'a şifrelenmiş mesajı ve IV'u gönderir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-174">Next, she encrypts the text using the key and IV, and sends the encrypted message and IV to Bob over the intranet.</span></span> <span data-ttu-id="0af7f-175">Bob şifrelenmiş metni alır ve IV kullanarak şifresini çözer ve daha önce anahtar üzerinde anlaşmış.</span><span class="sxs-lookup"><span data-stu-id="0af7f-175">Bob receives the encrypted text and decrypts it by using the IV and previously agreed upon key.</span></span> <span data-ttu-id="0af7f-176">İleti ele geçirilirse, anahtardan anlamadıkları için ele geçirici orijinal iletiyi kurtaramaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-176">If the transmission is intercepted, the interceptor cannot recover the original message, because they do not know the key.</span></span> <span data-ttu-id="0af7f-177">Bu senaryoda, yalnızca anahtar gizli kalmalıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-177">In this scenario, only the key must remain secret.</span></span> <span data-ttu-id="0af7f-178">Gerçek bir dünya senaryosunda, Gamze veya Bob gizli bir anahtar oluşturur ve gizli (simetrik) anahtarı diğer tarafa aktarmak için ortak anahtar (asimetrik) şifreleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-178">In a real world scenario, either Alice or Bob generates a secret key and uses public-key (asymmetric) encryption to transfer the secret (symmetric) key to the other party.</span></span> <span data-ttu-id="0af7f-179">Ortak anahtar şifrelemesi hakkında daha fazla bilgi için bir sonraki bölüme bakın.</span><span class="sxs-lookup"><span data-stu-id="0af7f-179">For more information about public-key encryption, see the next section.</span></span>

<span data-ttu-id="0af7f-180">.NET Framework, gizli anahtar şifreleme algoritmalarını uygulayan aşağıdaki sınıfları sağlar:</span><span class="sxs-lookup"><span data-stu-id="0af7f-180">The .NET Framework provides the following classes that implement secret-key encryption algorithms:</span></span>

- <span data-ttu-id="0af7f-181"><xref:System.Security.Cryptography.AesManaged>(.NET Framework 3.5'te sunulmuştur).</span><span class="sxs-lookup"><span data-stu-id="0af7f-181"><xref:System.Security.Cryptography.AesManaged> (introduced in the .NET Framework 3.5).</span></span>

- <span data-ttu-id="0af7f-182"><xref:System.Security.Cryptography.DESCryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-182"><xref:System.Security.Cryptography.DESCryptoServiceProvider>.</span></span>

- <span data-ttu-id="0af7f-183"><xref:System.Security.Cryptography.HMACSHA1>(Bu teknik olarak gizli anahtar algoritmasıdır, çünkü gizli bir anahtarla birlikte bir şifreleme karma işlevi kullanılarak hesaplanan ileti kimlik doğrulama kodunu temsil eder.</span><span class="sxs-lookup"><span data-stu-id="0af7f-183"><xref:System.Security.Cryptography.HMACSHA1> (This is technically a secret-key algorithm because it represents message authentication code that is calculated by using a cryptographic hash function combined with a secret key.</span></span> <span data-ttu-id="0af7f-184">Bu konunun ilerleyen saatlerinde [Karma Değerler'e](#hash-values)bakın.)</span><span class="sxs-lookup"><span data-stu-id="0af7f-184">See [Hash Values](#hash-values), later in this topic.)</span></span>

- <span data-ttu-id="0af7f-185"><xref:System.Security.Cryptography.RC2CryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-185"><xref:System.Security.Cryptography.RC2CryptoServiceProvider>.</span></span>

- <span data-ttu-id="0af7f-186"><xref:System.Security.Cryptography.RijndaelManaged>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-186"><xref:System.Security.Cryptography.RijndaelManaged>.</span></span>

- <span data-ttu-id="0af7f-187"><xref:System.Security.Cryptography.TripleDESCryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-187"><xref:System.Security.Cryptography.TripleDESCryptoServiceProvider>.</span></span>

## <a name="public-key-encryption"></a><span data-ttu-id="0af7f-188">Ortak Anahtar Şifreleme</span><span class="sxs-lookup"><span data-stu-id="0af7f-188">Public-Key Encryption</span></span>

<span data-ttu-id="0af7f-189">Ortak anahtar şifrelemesi, yetkisiz kullanıcılardan gizli tutulması gereken özel bir anahtar ve herkese açık hale getirilebilen bir ortak anahtar kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-189">Public-key encryption uses a private key that must be kept secret from unauthorized users and a public key that can be made public to anyone.</span></span> <span data-ttu-id="0af7f-190">Ortak anahtar ve özel anahtar matematiksel olarak birbirine bağlıdır; ortak anahtarla şifrelenen veriler yalnızca özel anahtarla çözülebilir ve özel anahtarla imzalanan veriler yalnızca ortak anahtarla doğrulanabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-190">The public key and the private key are mathematically linked; data that is encrypted with the public key can be decrypted only with the private key, and data that is signed with the private key can be verified only with the public key.</span></span> <span data-ttu-id="0af7f-191">Ortak anahtar herkes tarafından kullanılabilir hale getirilebilir; özel anahtarın koruyucuya gönderilmek üzere verileri şifrelemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-191">The public key can be made available to anyone; it is used for encrypting data to be sent to the keeper of the private key.</span></span> <span data-ttu-id="0af7f-192">Verileri şifrelemek için bir anahtar gerektiğinden, verilerin şifresini çözmek için başka bir anahtar gerektiğinden, genel anahtar şifreleme algoritmaları asimetrik algoritmalar olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-192">Public-key cryptographic algorithms are also known as asymmetric algorithms because one key is required to encrypt data, and another key is required to decrypt data.</span></span> <span data-ttu-id="0af7f-193">Temel bir şifreleme kuralı anahtarın yeniden kullanılmasını yasaklar ve her iki anahtar da her iletişim oturumu için benzersiz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-193">A basic cryptographic rule prohibits key reuse, and both keys should be unique for each communication session.</span></span> <span data-ttu-id="0af7f-194">Ancak, uygulamada, asimetrik tuşları genellikle uzun ömürlüdür.</span><span class="sxs-lookup"><span data-stu-id="0af7f-194">However, in practice, asymmetric keys are generally long-lived.</span></span>

<span data-ttu-id="0af7f-195">İki taraf (Gamze ve Gamze) ortak anahtar şifrelemesini aşağıdaki gibi kullanabilir: İlk olarak, Gamze ortak/özel anahtar çifti oluşturur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-195">Two parties (Alice and Bob) might use public-key encryption as follows: First, Alice generates a public/private key pair.</span></span> <span data-ttu-id="0af7f-196">Bob, Alice'e şifreli bir mesaj göndermek isterse, ondan ortak anahtarını ister.</span><span class="sxs-lookup"><span data-stu-id="0af7f-196">If Bob wants to send Alice an encrypted message, he asks her for her public key.</span></span> <span data-ttu-id="0af7f-197">Gamze, Genel Anahtarını güvenli olmayan bir ağ üzerinden Bob'a gönderir ve Bob bu anahtarı bir iletiyi şifrelemek için kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-197">Alice sends Bob her public key over a nonsecure network, and Bob uses this key to encrypt a message.</span></span> <span data-ttu-id="0af7f-198">Bob şifrelenmiş iletiyi Alice'e gönderir ve özel anahtarını kullanarak şifresini çözer.</span><span class="sxs-lookup"><span data-stu-id="0af7f-198">Bob sends the encrypted message to Alice, and she decrypts it by using her private key.</span></span> <span data-ttu-id="0af7f-199">Bob, Genel Ağ gibi güvenli olmayan bir kanal üzerinden Gamze'nin anahtarını aldıysa, Bob ortadaki adam saldırısına açıktır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-199">If Bob received Alice's key over a nonsecure channel, such as a public network, Bob is open to a man-in-the-middle attack.</span></span> <span data-ttu-id="0af7f-200">Bu nedenle, Bob'un Gamze ile ortak anahtarının doğru bir kopyasına sahip olduğunu doğrulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-200">Therefore, Bob must verify with Alice that he has a correct copy of her public key.</span></span>

<span data-ttu-id="0af7f-201">Alice'in ortak anahtarının iletimi sırasında yetkisiz bir ajan anahtarı yakalamış olabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-201">During the transmission of Alice's public key, an unauthorized agent might intercept the key.</span></span> <span data-ttu-id="0af7f-202">Ayrıca, aynı aracı Bob'dan gelen şifreli iletiyi ele geçirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-202">Furthermore, the same agent might intercept the encrypted message from Bob.</span></span> <span data-ttu-id="0af7f-203">Ancak, aracı ortak anahtarla iletiyi çözemez.</span><span class="sxs-lookup"><span data-stu-id="0af7f-203">However, the agent cannot decrypt the message with the public key.</span></span> <span data-ttu-id="0af7f-204">İletinin şifresi yalnızca Alice'in aktarılmayan özel anahtarıyla çözülebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-204">The message can be decrypted only with Alice's private key, which has not been transmitted.</span></span> <span data-ttu-id="0af7f-205">Gamze, ortak anahtarı olan herkes iletiyi şifreleyebileceğinden, Gamze'ye gelen bir yanıt iletisini şifrelemek için özel anahtarını kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-205">Alice does not use her private key to encrypt a reply message to Bob, because anyone with the public key could decrypt the message.</span></span> <span data-ttu-id="0af7f-206">Gamze, Bob'a bir ileti göndermek isterse, Bob'dan ortak anahtarını ister ve bu ortak anahtarı kullanarak iletisini şifreler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-206">If Alice wants to send a message back to Bob, she asks Bob for his public key and encrypts her message using that public key.</span></span> <span data-ttu-id="0af7f-207">Bob daha sonra ilişkili özel anahtarını kullanarak iletinin şifresini çözer.</span><span class="sxs-lookup"><span data-stu-id="0af7f-207">Bob then decrypts the message using his associated private key.</span></span>

<span data-ttu-id="0af7f-208">Bu senaryoda, Gamze ve Bob gizli (simetrik) bir anahtar aktarmak ve oturumlarının geri kalanı için gizli anahtar şifrelemesi kullanmak için ortak anahtar (asimetrik) şifreleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-208">In this scenario, Alice and Bob use public-key (asymmetric) encryption to transfer a secret (symmetric) key and use secret-key encryption for the remainder of their session.</span></span>

<span data-ttu-id="0af7f-209">Aşağıdaki liste, ortak anahtar ve gizli anahtar şifreleme algoritmaları arasında karşılaştırmalar sunar:</span><span class="sxs-lookup"><span data-stu-id="0af7f-209">The following list offers comparisons between public-key and secret-key cryptographic algorithms:</span></span>

- <span data-ttu-id="0af7f-210">Ortak anahtar şifreleme algoritmaları sabit arabellek boyutu kullanırken, gizli anahtar şifreleme algoritmaları değişken uzunlukta arabellek kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-210">Public-key cryptographic algorithms use a fixed buffer size, whereas secret-key cryptographic algorithms use a variable-length buffer.</span></span>

- <span data-ttu-id="0af7f-211">Yalnızca küçük miktarda veri şifrelenebileceğinden, ortak anahtar algoritmaları verileri gizli anahtar algoritmalarının çözebileceği şekilde akışlara zincirlemek için kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-211">Public-key algorithms cannot be used to chain data together into streams the way secret-key algorithms can, because only small amounts of data can be encrypted.</span></span> <span data-ttu-id="0af7f-212">Bu nedenle, asimetrik işlemler simetrik işlemlerle aynı akış modelini kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-212">Therefore, asymmetric operations do not use the same streaming model as symmetric operations.</span></span>

- <span data-ttu-id="0af7f-213">Ortak anahtar şifrelemesi, gizli anahtar şifrelemesinden çok daha büyük bir anahtar alanına (anahtar için olası değerler aralığına) sahiptir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-213">Public-key encryption has a much larger keyspace (range of possible values for the key) than secret-key encryption.</span></span> <span data-ttu-id="0af7f-214">Bu nedenle, public-key şifreleme mümkün olan her anahtarı denemek kapsamlı saldırılara daha az duyarlıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-214">Therefore, public-key encryption is less susceptible to exhaustive attacks that try every possible key.</span></span>

- <span data-ttu-id="0af7f-215">Gönderenin kimliğini doğrulamak için bir yol olması koşuluyla, güvenli olması gerekmedığından, ortak anahtarların dağıtılması kolaydır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-215">Public keys are easy to distribute because they do not have to be secured, provided that some way exists to verify the identity of the sender.</span></span>

- <span data-ttu-id="0af7f-216">Bazı ortak anahtar algoritmaları (RSA ve DSA gibi, ancak Diffie-Hellman değil) veri gönderenin kimliğini doğrulamak için dijital imzalar oluşturmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-216">Some public-key algorithms (such as RSA and DSA, but not Diffie-Hellman) can be used to create digital signatures to verify the identity of the sender of data.</span></span>

- <span data-ttu-id="0af7f-217">Ortak anahtar algoritmaları gizli anahtar algoritmalarıyla karşılaştırıldığında çok yavaşdır ve büyük miktarda veriyi şifrelemek için tasarlanmaz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-217">Public-key algorithms are very slow compared with secret-key algorithms, and are not designed to encrypt large amounts of data.</span></span> <span data-ttu-id="0af7f-218">Ortak anahtar algoritmaları yalnızca çok küçük miktarda veri aktarmak için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-218">Public-key algorithms are useful only for transferring very small amounts of data.</span></span> <span data-ttu-id="0af7f-219">Genellikle, ortak anahtar şifreleme bir anahtar ve IV gizli anahtar algoritması tarafından kullanılmak üzere şifrelemek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-219">Typically, public-key encryption is used to encrypt a key and IV to be used by a secret-key algorithm.</span></span> <span data-ttu-id="0af7f-220">Anahtar ve IV aktarıldıktan sonra, oturumun geri kalanı için gizli anahtar şifrelemesi kullanılır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-220">After the key and IV are transferred, secret-key encryption is used for the remainder of the session.</span></span>

<span data-ttu-id="0af7f-221">.NET Framework, ortak anahtar şifreleme algoritmalarını uygulayan aşağıdaki sınıfları sağlar:</span><span class="sxs-lookup"><span data-stu-id="0af7f-221">The .NET Framework provides the following classes that implement public-key encryption algorithms:</span></span>

- <xref:System.Security.Cryptography.DSACryptoServiceProvider>

- <xref:System.Security.Cryptography.RSACryptoServiceProvider>

- <span data-ttu-id="0af7f-222"><xref:System.Security.Cryptography.ECDiffieHellman>(taban sınıf)</span><span class="sxs-lookup"><span data-stu-id="0af7f-222"><xref:System.Security.Cryptography.ECDiffieHellman> (base class)</span></span>

- <xref:System.Security.Cryptography.ECDiffieHellmanCng>

- <span data-ttu-id="0af7f-223"><xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey>(taban sınıf)</span><span class="sxs-lookup"><span data-stu-id="0af7f-223"><xref:System.Security.Cryptography.ECDiffieHellmanCngPublicKey> (base class)</span></span>

- <span data-ttu-id="0af7f-224"><xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction>(taban sınıf)</span><span class="sxs-lookup"><span data-stu-id="0af7f-224"><xref:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction> (base class)</span></span>

- <xref:System.Security.Cryptography.ECDsaCng>

<span data-ttu-id="0af7f-225">RSA hem şifreleme hem de imzalamaya izin verir, ancak DSA yalnızca imzalama için kullanılabilir ve Diffie-Hellman yalnızca anahtar oluşturma için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-225">RSA allows both encryption and signing, but DSA can be used only for signing, and Diffie-Hellman can be used only for key generation.</span></span> <span data-ttu-id="0af7f-226">Genel olarak, ortak anahtar algoritmaları özel anahtar algoritmalarına göre kullanımlarında daha sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-226">In general, public-key algorithms are more limited in their uses than private-key algorithms.</span></span>

## <a name="digital-signatures"></a><span data-ttu-id="0af7f-227">Dijital İmzalar</span><span class="sxs-lookup"><span data-stu-id="0af7f-227">Digital Signatures</span></span>

<span data-ttu-id="0af7f-228">Ortak anahtar algoritmaları dijital imzaoluşturmak için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-228">Public-key algorithms can also be used to form digital signatures.</span></span> <span data-ttu-id="0af7f-229">Dijital imzalar gönderenin kimliğini doğrular (gönderenin ortak anahtarına güveniyorsanız) ve verilerin bütünlüğünükorumaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-229">Digital signatures authenticate the identity of a sender (if you trust the sender's public key) and help protect the integrity of data.</span></span> <span data-ttu-id="0af7f-230">Alice tarafından oluşturulan ortak bir anahtarı kullanarak, Alice'in verilerinin alıcısı, dijital imzayı Alice'in verileriyle ve Alice'in ortak anahtarıyla karşılaştırarak Alice'in gönderdiğini doğrulayabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-230">Using a public key generated by Alice, the recipient of Alice's data can verify that Alice sent it by comparing the digital signature to Alice's data and Alice's public key.</span></span>

<span data-ttu-id="0af7f-231">Bir iletiyi dijital olarak imzalamak için ortak anahtar şifrelemesini kullanmak için, Gamze önce ileti özeti oluşturmak için iletiye karma algoritma uygular.</span><span class="sxs-lookup"><span data-stu-id="0af7f-231">To use public-key cryptography to digitally sign a message, Alice first applies a hash algorithm to the message to create a message digest.</span></span> <span data-ttu-id="0af7f-232">İleti özeti, verilerin kompakt ve benzersiz bir temsilidir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-232">The message digest is a compact and unique representation of data.</span></span> <span data-ttu-id="0af7f-233">Alice daha sonra kişisel imzasını oluşturmak için ileti özetini özel anahtarıyla şifreler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-233">Alice then encrypts the message digest with her private key to create her personal signature.</span></span> <span data-ttu-id="0af7f-234">İletiyi ve imzayı aldıktan sonra, Bob ileti özetini kurtarmak için Gamze'nin ortak anahtarını kullanarak imzanın şifresini çözer ve Alice'in kullandığı karma algoritmayı kullanarak iletiyi karma olarak ele verir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-234">Upon receiving the message and signature, Bob decrypts the signature using Alice's public key to recover the message digest and hashes the message using the same hash algorithm that Alice used.</span></span> <span data-ttu-id="0af7f-235">Bob'un hesaplamasını sağlayan ileti, Gamze'den alınan ileti özetiyle tam olarak eşleşirse, Bob iletinin özel anahtarın sahibinden geldiğine ve verilerin değiştirilmediğinden emin olur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-235">If the message digest that Bob computes exactly matches the message digest received from Alice, Bob is assured that the message came from the possessor of the private key and that the data has not been modified.</span></span> <span data-ttu-id="0af7f-236">Bob, Alice'in özel anahtarın sahibi olduğuna güvenirse mesajın Alice'ten geldiğini bilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-236">If Bob trusts that Alice is the possessor of the private key, he knows that the message came from Alice.</span></span>

> [!NOTE]
> <span data-ttu-id="0af7f-237">Gönderenin ortak anahtarı yaygın bir bilgi olduğundan ve genellikle dijital imza biçimine dahil olduğundan, imza herkes tarafından doğrulanabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-237">A signature can be verified by anyone because the sender's public key is common knowledge and is typically included in the digital signature format.</span></span> <span data-ttu-id="0af7f-238">Bu yöntem iletinin gizliliğini korumaz; İletinin gizli olması için, iletinin de şifrelenmiş olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-238">This method does not retain the secrecy of the message; for the message to be secret, it must also be encrypted.</span></span>

<span data-ttu-id="0af7f-239">.NET Framework, dijital imza algoritmalarını uygulayan aşağıdaki sınıfları sağlar:</span><span class="sxs-lookup"><span data-stu-id="0af7f-239">The .NET Framework provides the following classes that implement digital signature algorithms:</span></span>

- <xref:System.Security.Cryptography.DSACryptoServiceProvider>

- <xref:System.Security.Cryptography.RSACryptoServiceProvider>

- <span data-ttu-id="0af7f-240"><xref:System.Security.Cryptography.ECDsa>(taban sınıf)</span><span class="sxs-lookup"><span data-stu-id="0af7f-240"><xref:System.Security.Cryptography.ECDsa> (base class)</span></span>

- <xref:System.Security.Cryptography.ECDsaCng>

## <a name="hash-values"></a><span data-ttu-id="0af7f-241">Karma Değerler</span><span class="sxs-lookup"><span data-stu-id="0af7f-241">Hash Values</span></span>

<span data-ttu-id="0af7f-242">Karma algoritmalar, rasgele bir uzunluğun ikili değerlerini, karma değerler olarak bilinen sabit uzunluktaki daha küçük ikili değerlerle eşler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-242">Hash algorithms map binary values of an arbitrary length to smaller binary values of a fixed length, known as hash values.</span></span> <span data-ttu-id="0af7f-243">Karma değer, bir veri parçasının sayısal gösterimidir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-243">A hash value is a numerical representation of a piece of data.</span></span> <span data-ttu-id="0af7f-244">Düz metin bir paragraf karma ve paragrafın bile bir harfi değiştirirseniz, sonraki bir karma farklı bir değer üretecektir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-244">If you hash a paragraph of plaintext and change even one letter of the paragraph, a subsequent hash will produce a different value.</span></span> <span data-ttu-id="0af7f-245">Karma şifreleme olarak güçlüyse, değeri önemli ölçüde değişecektir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-245">If the hash is cryptographically strong, its value will change significantly.</span></span> <span data-ttu-id="0af7f-246">Örneğin, bir iletinin tek bir biti değiştirilirse, güçlü bir karma işlev yüzde 50'ye göre farklı bir çıktı üretebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-246">For example, if a single bit of a message is changed, a strong hash function may produce an output that differs by 50 percent.</span></span> <span data-ttu-id="0af7f-247">Birçok giriş değeri aynı çıktı değerine karma olabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-247">Many input values may hash to the same output value.</span></span> <span data-ttu-id="0af7f-248">Ancak, aynı değere karma iki farklı giriş bulmak hesaplama açısından olanaksızdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-248">However, it is computationally infeasible to find two distinct inputs that hash to the same value.</span></span>

<span data-ttu-id="0af7f-249">İki taraf (Gamze ve Gamze) ileti bütünlüğünü sağlamak için karma işlevi kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-249">Two parties (Alice and Bob) could use a hash function to ensure message integrity.</span></span> <span data-ttu-id="0af7f-250">İletilerini imzalamak için bir karma algoritma seçerler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-250">They would select a hash algorithm to sign their messages.</span></span> <span data-ttu-id="0af7f-251">Alice bir ileti yazar ve sonra seçili algoritmayı kullanarak bu iletinin bir karma oluşturur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-251">Alice would write a message, and then create a hash of that message by using the selected algorithm.</span></span> <span data-ttu-id="0af7f-252">Daha sonra aşağıdaki yöntemlerden birini izleyeceklerdi:</span><span class="sxs-lookup"><span data-stu-id="0af7f-252">They would then follow one of the following methods:</span></span>

- <span data-ttu-id="0af7f-253">Gamze düz metin iletisini ve hashed iletiyi (dijital imza) Bob'a gönderir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-253">Alice sends the plaintext message and the hashed message (digital signature) to Bob.</span></span> <span data-ttu-id="0af7f-254">Bob iletiyi alır ve haşlar ve karma değerini Alice'ten aldığı karma değerle karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-254">Bob receives and hashes the message and compares his hash value to the hash value that he received from Alice.</span></span> <span data-ttu-id="0af7f-255">Karma değerler aynıysa, ileti değiştirilmemiştir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-255">If the hash values are identical, the message was not altered.</span></span> <span data-ttu-id="0af7f-256">Değerler aynı değilse, ileti Alice yazdıktan sonra değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-256">If the values are not identical, the message was altered after Alice wrote it.</span></span>

  <span data-ttu-id="0af7f-257">Ne yazık ki, bu yöntem gönderenin orijinalliğini belirlemez.</span><span class="sxs-lookup"><span data-stu-id="0af7f-257">Unfortunately, this method does not establish the authenticity of the sender.</span></span> <span data-ttu-id="0af7f-258">Herkes Alice'in kimliğine bürünebilir ve Bob'a mesaj gönderebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-258">Anyone can impersonate Alice and send a message to Bob.</span></span> <span data-ttu-id="0af7f-259">İletilerini imzalamak için aynı karma algoritmayı kullanabilirler ve Bob'un belirleyebileceği tek şey iletinin imzasıyla eşleştiğini belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-259">They can use the same hash algorithm to sign their message, and all Bob can determine is that the message matches its signature.</span></span> <span data-ttu-id="0af7f-260">Bu, ortadaki adam saldırısının bir şekli.</span><span class="sxs-lookup"><span data-stu-id="0af7f-260">This is one form of a man-in-the-middle attack.</span></span> <span data-ttu-id="0af7f-261">Daha fazla bilgi için bkz: [Şifreleme Yeni Nesil (CNG) Güvenli İletişim Örneği.](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="0af7f-261">For more information, see [Cryptography Next Generation (CNG) Secure Communication Example](https://docs.microsoft.com/previous-versions/cc488018(v=vs.100)).</span></span>

- <span data-ttu-id="0af7f-262">Gamze, güvenli olmayan bir genel kanal üzerinden Bob'a düz metin iletisi gönderir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-262">Alice sends the plaintext message to Bob over a nonsecure public channel.</span></span> <span data-ttu-id="0af7f-263">O güvenli bir özel kanal üzerinden Bob için hashed mesajı gönderir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-263">She sends the hashed message to Bob over a secure private channel.</span></span> <span data-ttu-id="0af7f-264">Bob düz metin iletisini alır, karma yı karşeyilaştırır ve karma ile özel olarak değiştirilen karma ile karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-264">Bob receives the plaintext message, hashes it, and compares the hash to the privately exchanged hash.</span></span> <span data-ttu-id="0af7f-265">Eğer haşiyeler eşleşirse, Bob iki şey bilir:</span><span class="sxs-lookup"><span data-stu-id="0af7f-265">If the hashes match, Bob knows two things:</span></span>

  - <span data-ttu-id="0af7f-266">İleti değiştirilmemiş.</span><span class="sxs-lookup"><span data-stu-id="0af7f-266">The message was not altered.</span></span>

  - <span data-ttu-id="0af7f-267">İletiyi gönderen (Gamze) gerçektir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-267">The sender of the message (Alice) is authentic.</span></span>

  <span data-ttu-id="0af7f-268">Bu sistemin çalışması için Alice'in orijinal karma değerini Bob dışındaki tüm taraflardan saklaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-268">For this system to work, Alice must hide her original hash value from all parties except Bob.</span></span>

- <span data-ttu-id="0af7f-269">Gamze, güvenli olmayan bir genel kanal üzerinden Bob'a düz metin iletisi gönderir ve hashed iletiyi genel olarak görüntülenebilir Web sitesine yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-269">Alice sends the plaintext message to Bob over a nonsecure public channel and places the hashed message on her publicly viewable Web site.</span></span>

  <span data-ttu-id="0af7f-270">Bu yöntem, herkesin karma değerini değiştirmesini engelleyerek iletinin kurcalanmasını önler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-270">This method prevents message tampering by preventing anyone from modifying the hash value.</span></span> <span data-ttu-id="0af7f-271">İleti ve karma herkes tarafından okunabilir olsa da, karma değeri yalnızca Alice tarafından değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-271">Although the message and its hash can be read by anyone, the hash value can be changed only by Alice.</span></span> <span data-ttu-id="0af7f-272">Alice'i taklit etmek isteyen bir saldırgan, Alice'in Web sitesine erişim gerektirir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-272">An attacker who wants to impersonate Alice would require access to Alice's Web site.</span></span>

<span data-ttu-id="0af7f-273">Önceki yöntemlerin hiçbiri, birinin Alice'in iletilerini okumasını engellemez, çünkü bunlar düz metin olarak iletilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-273">None of the previous methods will prevent someone from reading Alice's messages, because they are transmitted in plaintext.</span></span> <span data-ttu-id="0af7f-274">Tam güvenlik genellikle dijital imza (ileti imzalama) ve şifreleme gerektirir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-274">Full security typically requires digital signatures (message signing) and encryption.</span></span>

<span data-ttu-id="0af7f-275">.NET Framework karma algoritmaları uygulayan aşağıdaki sınıfları sağlar:</span><span class="sxs-lookup"><span data-stu-id="0af7f-275">The .NET Framework provides the following classes that implement hashing algorithms:</span></span>

- <span data-ttu-id="0af7f-276"><xref:System.Security.Cryptography.HMACSHA1>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-276"><xref:System.Security.Cryptography.HMACSHA1>.</span></span>

- <span data-ttu-id="0af7f-277"><xref:System.Security.Cryptography.MACTripleDES>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-277"><xref:System.Security.Cryptography.MACTripleDES>.</span></span>

- <span data-ttu-id="0af7f-278"><xref:System.Security.Cryptography.MD5CryptoServiceProvider>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-278"><xref:System.Security.Cryptography.MD5CryptoServiceProvider>.</span></span>

- <span data-ttu-id="0af7f-279"><xref:System.Security.Cryptography.RIPEMD160>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-279"><xref:System.Security.Cryptography.RIPEMD160>.</span></span>

- <span data-ttu-id="0af7f-280"><xref:System.Security.Cryptography.SHA1Managed>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-280"><xref:System.Security.Cryptography.SHA1Managed>.</span></span>

- <span data-ttu-id="0af7f-281"><xref:System.Security.Cryptography.SHA256Managed>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-281"><xref:System.Security.Cryptography.SHA256Managed>.</span></span>

- <span data-ttu-id="0af7f-282"><xref:System.Security.Cryptography.SHA384Managed>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-282"><xref:System.Security.Cryptography.SHA384Managed>.</span></span>

- <span data-ttu-id="0af7f-283"><xref:System.Security.Cryptography.SHA512Managed>.</span><span class="sxs-lookup"><span data-stu-id="0af7f-283"><xref:System.Security.Cryptography.SHA512Managed>.</span></span>

- <span data-ttu-id="0af7f-284">Tüm Güvenli Karma Algoritması (SHA), Message Digest 5 (MD5) ve RIPEMD-160 algoritmalarının HMAC varyantları.</span><span class="sxs-lookup"><span data-stu-id="0af7f-284">HMAC variants of all of the Secure Hash Algorithm (SHA), Message Digest 5 (MD5), and RIPEMD-160 algorithms.</span></span>

- <span data-ttu-id="0af7f-285">Tüm SHA algoritmalarının CryptoServiceProvider uygulamaları (yönetilen kod paketleyicileri).</span><span class="sxs-lookup"><span data-stu-id="0af7f-285">CryptoServiceProvider implementations (managed code wrappers) of all the SHA algorithms.</span></span>

- <span data-ttu-id="0af7f-286">Tüm MD5 ve SHA algoritmalarının Şifreleme Yeni Nesil (CNG) uygulamaları.</span><span class="sxs-lookup"><span data-stu-id="0af7f-286">Cryptography Next Generation (CNG) implementations of all the MD5 and SHA algorithms.</span></span>

> [!NOTE]
> <span data-ttu-id="0af7f-287">MD5 tasarım kusurları 1996 yılında keşfedildi ve bunun yerine SHA-1 önerildi.</span><span class="sxs-lookup"><span data-stu-id="0af7f-287">MD5 design flaws were discovered in 1996, and SHA-1 was recommended instead.</span></span> <span data-ttu-id="0af7f-288">2004 yılında ek kusurlar keşfedildi ve MD5 algoritması artık güvenli olarak kabul edilmiştir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-288">In 2004, additional flaws were discovered, and the MD5 algorithm is no longer considered secure.</span></span> <span data-ttu-id="0af7f-289">SHA-1 algoritması da güvensiz olduğu tespit edilmiştir ve SHA-2 şimdi bunun yerine tavsiye edilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-289">The SHA-1 algorithm has also been found to be insecure, and SHA-2 is now recommended instead.</span></span>

## <a name="random-number-generation"></a><span data-ttu-id="0af7f-290">Rastgele Sayı Oluşturma</span><span class="sxs-lookup"><span data-stu-id="0af7f-290">Random Number Generation</span></span>

<span data-ttu-id="0af7f-291">Rasgele sayı oluşturma birçok şifreleme işleminin ayrılmaz bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-291">Random number generation is integral to many cryptographic operations.</span></span> <span data-ttu-id="0af7f-292">Örneğin, şifreleme anahtarlarının çoğaltılabilmesi mümkün olmayan şekilde mümkün olduğunca rasgele olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-292">For example, cryptographic keys need to be as random as possible so that it is infeasible to reproduce them.</span></span> <span data-ttu-id="0af7f-293">Kriptografik rasgele sayı üreteçleri hesaplamaaçısından mümkün olmayan bir olasılık ile tahmin etmek için bir yarısından daha iyi bir çıkış üretmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-293">Cryptographic random number generators must generate output that is computationally infeasible to predict with a probability that is better than one half.</span></span> <span data-ttu-id="0af7f-294">Bu nedenle, bir sonraki çıktı bitini tahmin etme yöntemi rasgele tahminden daha iyi performans göstermemelidir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-294">Therefore, any method of predicting the next output bit must not perform better than random guessing.</span></span> <span data-ttu-id="0af7f-295">.NET Framework'deki sınıflar şifreleme anahtarları oluşturmak için rasgele sayı üreteçleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-295">The classes in the .NET Framework use random number generators to generate cryptographic keys.</span></span>

<span data-ttu-id="0af7f-296">Sınıf <xref:System.Security.Cryptography.RNGCryptoServiceProvider> rasgele bir sayı üreteç algoritması bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-296">The <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class is an implementation of a random number generator algorithm.</span></span>

## <a name="clickonce-manifests"></a><span data-ttu-id="0af7f-297">ClickOnce Manifestoları</span><span class="sxs-lookup"><span data-stu-id="0af7f-297">ClickOnce Manifests</span></span>

<span data-ttu-id="0af7f-298">.NET Framework 3.5'te, aşağıdaki şifreleme sınıfları [ClickOnce teknolojisini](/visualstudio/deployment/clickonce-security-and-deployment)kullanarak dağıtılan uygulamalar için bildirim imzaları hakkında bilgi edinmenizi ve doğrulamanızı sağlar:</span><span class="sxs-lookup"><span data-stu-id="0af7f-298">In the .NET Framework 3.5, the following cryptography classes let you obtain and verify information about manifest signatures for applications that are deployed using [ClickOnce technology](/visualstudio/deployment/clickonce-security-and-deployment):</span></span>

- <span data-ttu-id="0af7f-299">Sınıf, <xref:System.Security.Cryptography.ManifestSignatureInformation> yöntemini <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> aşırı yüklemeler kullandığınızda bir bildirim imzası hakkında bilgi alır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-299">The <xref:System.Security.Cryptography.ManifestSignatureInformation> class obtains information about a manifest signature when you use its <xref:System.Security.Cryptography.ManifestSignatureInformation.VerifySignature%2A> method overloads.</span></span>

- <span data-ttu-id="0af7f-300">Doğrulamaiçin <xref:System.Security.ManifestKinds> hangi bildirimleri belirtecek numaralandırmayı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="0af7f-300">You can use the <xref:System.Security.ManifestKinds> enumeration to specify which manifests to verify.</span></span> <span data-ttu-id="0af7f-301">Doğrulamanın sonucu numaralandırma değerlerinden <xref:System.Security.Cryptography.SignatureVerificationResult> biridir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-301">The result of the verification is one of the <xref:System.Security.Cryptography.SignatureVerificationResult> enumeration values.</span></span>

- <span data-ttu-id="0af7f-302">Sınıf, <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> doğrulanmış imzaların <xref:System.Security.Cryptography.ManifestSignatureInformation> nesnelerinin salt okunur koleksiyonunu sağlar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-302">The <xref:System.Security.Cryptography.ManifestSignatureInformationCollection> class provides a read-only collection of <xref:System.Security.Cryptography.ManifestSignatureInformation> objects of the verified signatures.</span></span>

 <span data-ttu-id="0af7f-303">Buna ek olarak, aşağıdaki sınıflar belirli imza bilgileri sağlar:</span><span class="sxs-lookup"><span data-stu-id="0af7f-303">In addition, the following classes provide specific signature information:</span></span>

- <span data-ttu-id="0af7f-304"><xref:System.Security.Cryptography.StrongNameSignatureInformation>bir bildirim için güçlü ad imza bilgilerini tutar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-304"><xref:System.Security.Cryptography.StrongNameSignatureInformation> holds the strong name signature information for a manifest.</span></span>

- <span data-ttu-id="0af7f-305"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation>bir bildirim için Authenticode imza bilgilerini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="0af7f-305"><xref:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation> represents the Authenticode signature information for a manifest.</span></span>

- <span data-ttu-id="0af7f-306"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation>Authenticode imzasıüzerindeki zaman damgası hakkında bilgi içerir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-306"><xref:System.Security.Cryptography.X509Certificates.TimestampInformation> contains information about the time stamp on an Authenticode signature.</span></span>

- <span data-ttu-id="0af7f-307"><xref:System.Security.Cryptography.X509Certificates.TrustStatus>Authenticode imzasının güvenilir olup olmadığını denetlemenin basit bir yolunu sağlar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-307"><xref:System.Security.Cryptography.X509Certificates.TrustStatus> provides a simple way to check whether an Authenticode signature is trusted.</span></span>

## <a name="suite-b-support"></a><span data-ttu-id="0af7f-308">Suite B Desteği</span><span class="sxs-lookup"><span data-stu-id="0af7f-308">Suite B Support</span></span>

<span data-ttu-id="0af7f-309">.NET Framework 3.5, Ulusal Güvenlik Ajansı (NSA) tarafından yayınlanan Suite B şifreleme algoritmaları kümesini destekler.</span><span class="sxs-lookup"><span data-stu-id="0af7f-309">The .NET Framework 3.5 supports the Suite B set of cryptographic algorithms published by the National Security Agency (NSA).</span></span> <span data-ttu-id="0af7f-310">Suite B hakkında daha fazla bilgi için [NSA Suite B Şifreleme Bilgi Formu'na](https://www.nsa.gov/what-we-do/information-assurance/)bakın.</span><span class="sxs-lookup"><span data-stu-id="0af7f-310">For more information about Suite B, see the [NSA Suite B Cryptography Fact Sheet](https://www.nsa.gov/what-we-do/information-assurance/).</span></span>

<span data-ttu-id="0af7f-311">Aşağıdaki algoritmalar dahildir:</span><span class="sxs-lookup"><span data-stu-id="0af7f-311">The following algorithms are included:</span></span>

- <span data-ttu-id="0af7f-312">Şifreleme için 128, 192 ve 256 bit anahtar boyutlarına sahip Gelişmiş Şifreleme Standardı (AES) algoritması.</span><span class="sxs-lookup"><span data-stu-id="0af7f-312">Advanced Encryption Standard (AES) algorithm with key sizes of 128, 192, , and 256 bits for encryption.</span></span>

- <span data-ttu-id="0af7f-313">Güvenli Hash Algoritmaları SHA-1, SHA-256, SHA-384 ve SHA-512 karma için.</span><span class="sxs-lookup"><span data-stu-id="0af7f-313">Secure Hash Algorithms SHA-1, SHA-256, SHA-384, and SHA-512 for hashing.</span></span> <span data-ttu-id="0af7f-314">(Son üç genellikle birlikte gruplanır ve SHA-2 olarak adlandırılır.)</span><span class="sxs-lookup"><span data-stu-id="0af7f-314">(The last three are generally grouped together and referred to as SHA-2.)</span></span>

- <span data-ttu-id="0af7f-315">Eliptik Eğri Dijital İmza Algoritması (ECDSA), 256-bit, 384-bit ve 521-bit prime moduli eğrileri kullanarak imzalama.</span><span class="sxs-lookup"><span data-stu-id="0af7f-315">Elliptic Curve Digital Signature Algorithm (ECDSA), using curves of 256-bit, 384-bit, and 521-bit prime moduli for signing.</span></span> <span data-ttu-id="0af7f-316">NSA belgeleri özellikle bu eğrileri tanımlar ve bunlara P-256, P-384 ve P-521 adını veririm.</span><span class="sxs-lookup"><span data-stu-id="0af7f-316">The NSA documentation specifically defines these curves, and calls them P-256, P-384, and P-521.</span></span> <span data-ttu-id="0af7f-317">Bu algoritma <xref:System.Security.Cryptography.ECDsaCng> sınıf tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-317">This algorithm is provided by the <xref:System.Security.Cryptography.ECDsaCng> class.</span></span> <span data-ttu-id="0af7f-318">Özel bir anahtarla imzalamanızı ve imzayı ortak bir anahtarla doğrulamanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-318">It enables you to sign with a private key and verify the signature with a public key.</span></span>

- <span data-ttu-id="0af7f-319">Eliptik Eğri Diffie-Hellman (ECDH) algoritması, anahtar değişimi ve gizli anlaşma için 256-bit, 384-bit ve 521-bit prime moduli eğrileri kullanarak.</span><span class="sxs-lookup"><span data-stu-id="0af7f-319">Elliptic Curve Diffie-Hellman (ECDH) algorithm, using curves of 256-bit, 384-bit, and 521-bit prime moduli for the key exchange and secret agreement.</span></span> <span data-ttu-id="0af7f-320">Bu algoritma <xref:System.Security.Cryptography.ECDiffieHellmanCng> sınıf tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-320">This algorithm is provided by the <xref:System.Security.Cryptography.ECDiffieHellmanCng> class.</span></span>

<span data-ttu-id="0af7f-321">Federal Bilgi İşlem Standardı (FIPS) AES, SHA-256, SHA-384 ve SHA-512 uygulamalarının onaylı uygulamaları için yönetilen <xref:System.Security.Cryptography.AesCryptoServiceProvider> <xref:System.Security.Cryptography.SHA256CryptoServiceProvider>kod <xref:System.Security.Cryptography.SHA384CryptoServiceProvider>ambalajları yeni , , ve <xref:System.Security.Cryptography.SHA512CryptoServiceProvider> sınıflarmevcuttur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-321">Managed code wrappers for the Federal Information Processing Standard (FIPS) certified implementations of the AES, SHA-256, SHA-384, and SHA-512 implementations are available in the new <xref:System.Security.Cryptography.AesCryptoServiceProvider>, <xref:System.Security.Cryptography.SHA256CryptoServiceProvider>, <xref:System.Security.Cryptography.SHA384CryptoServiceProvider>, and <xref:System.Security.Cryptography.SHA512CryptoServiceProvider> classes.</span></span>

## <a name="cryptography-next-generation-cng-classes"></a><span data-ttu-id="0af7f-322">Kriptografi Yeni Nesil (CNG) Sınıfları</span><span class="sxs-lookup"><span data-stu-id="0af7f-322">Cryptography Next Generation (CNG) Classes</span></span>

<span data-ttu-id="0af7f-323">Şifreleme Yeni Nesil (CNG) sınıfları, yerel CNG işlevleri etrafında yönetilen bir sarıcı sağlar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-323">The Cryptography Next Generation (CNG) classes provide a managed wrapper around the native CNG functions.</span></span> <span data-ttu-id="0af7f-324">(CNG CryptoAPI'nin yerini aldı.) Bu sınıfların isimlerinin bir parçası olarak "Cng" vardır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-324">(CNG is the replacement for CryptoAPI.) These classes have "Cng" as part of their names.</span></span> <span data-ttu-id="0af7f-325">CNG sarıcı sınıflarının merkezinde, CNG tuşlarının depolanması ve kullanımı özetleyen <xref:System.Security.Cryptography.CngKey> anahtar kapsayıcı sınıfı yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-325">Central to the CNG wrapper classes is the <xref:System.Security.Cryptography.CngKey> key container class, which abstracts the storage and use of CNG keys.</span></span> <span data-ttu-id="0af7f-326">Bu sınıf, bir anahtar çiftini veya ortak anahtarı güvenli bir şekilde saklamanızı ve basit bir dize adı kullanarak ona başvurmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-326">This class lets you store a key pair or a public key securely and refer to it by using a simple string name.</span></span> <span data-ttu-id="0af7f-327">Eliptik eğri tabanlı <xref:System.Security.Cryptography.ECDsaCng> imza sınıfı <xref:System.Security.Cryptography.ECDiffieHellmanCng> ve şifreleme <xref:System.Security.Cryptography.CngKey> sınıfı nesneleri kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-327">The elliptic curve-based <xref:System.Security.Cryptography.ECDsaCng> signature class and the <xref:System.Security.Cryptography.ECDiffieHellmanCng> encryption class can use <xref:System.Security.Cryptography.CngKey> objects.</span></span>

<span data-ttu-id="0af7f-328">Sınıf, <xref:System.Security.Cryptography.CngKey> anahtarları açma, oluşturma, silme ve dışa aktarma dahil olmak üzere çeşitli ek işlemler için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="0af7f-328">The <xref:System.Security.Cryptography.CngKey> class is used for a variety of additional operations, including opening, creating, deleting, and exporting keys.</span></span> <span data-ttu-id="0af7f-329">Ayrıca, yerel işlevleri doğrudan ararken kullanılacak temel anahtar koluna erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-329">It also provides access to the underlying key handle to use when calling native functions directly.</span></span>

<span data-ttu-id="0af7f-330">.NET Framework 3.5, aşağıdakiler gibi çeşitli destekleyici CNG sınıflarını da içerir:</span><span class="sxs-lookup"><span data-stu-id="0af7f-330">The .NET Framework 3.5 also includes a variety of supporting CNG classes, such as the following:</span></span>

- <span data-ttu-id="0af7f-331"><xref:System.Security.Cryptography.CngProvider>önemli bir depolama sağlayıcısı tutar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-331"><xref:System.Security.Cryptography.CngProvider> maintains a key storage provider.</span></span>

- <span data-ttu-id="0af7f-332"><xref:System.Security.Cryptography.CngAlgorithm>cng algoritması tutar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-332"><xref:System.Security.Cryptography.CngAlgorithm> maintains a CNG algorithm.</span></span>

- <span data-ttu-id="0af7f-333"><xref:System.Security.Cryptography.CngProperty>sık kullanılan anahtar özelliklerini korur.</span><span class="sxs-lookup"><span data-stu-id="0af7f-333"><xref:System.Security.Cryptography.CngProperty> maintains frequently used key properties.</span></span>

## <a name="related-topics"></a><span data-ttu-id="0af7f-334">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="0af7f-334">Related Topics</span></span>

|<span data-ttu-id="0af7f-335">Başlık</span><span class="sxs-lookup"><span data-stu-id="0af7f-335">Title</span></span>|<span data-ttu-id="0af7f-336">Açıklama</span><span class="sxs-lookup"><span data-stu-id="0af7f-336">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="0af7f-337">Şifreleme Modeli</span><span class="sxs-lookup"><span data-stu-id="0af7f-337">Cryptography Model</span></span>](../../../docs/standard/security/cryptography-model.md)|<span data-ttu-id="0af7f-338">Temel sınıf kitaplığında şifrelemenin nasıl uygulandığını açıklar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-338">Describes how cryptography is implemented in the base class library.</span></span>|
|[<span data-ttu-id="0af7f-339">İzlenecek Yol: Şifreleme Uygulaması Oluşturma</span><span class="sxs-lookup"><span data-stu-id="0af7f-339">Walkthrough: Creating a Cryptographic Application</span></span>](../../../docs/standard/security/walkthrough-creating-a-cryptographic-application.md)|<span data-ttu-id="0af7f-340">Temel şifreleme ve şifre çözme görevlerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="0af7f-340">Demonstrates basic encryption and decryption tasks.</span></span>|
|[<span data-ttu-id="0af7f-341">Şifreleme Sınıflarını Yapılandırma</span><span class="sxs-lookup"><span data-stu-id="0af7f-341">Configuring Cryptography Classes</span></span>](../../../docs/framework/configure-apps/configure-cryptography-classes.md)|<span data-ttu-id="0af7f-342">Algoritma adlarının şifreleme sınıflarıyla nasıl eşlenebildiğini ve nesne tanımlayıcılarını şifreleme algoritmasıyla nasıl eşlenineceğimi açıklar.</span><span class="sxs-lookup"><span data-stu-id="0af7f-342">Describes how to map algorithm names to cryptographic classes and map object identifiers to a cryptographic algorithm.</span></span>|
