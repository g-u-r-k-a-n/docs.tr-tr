---
title: Async akışları oluşturma ve tüket
description: Bu gelişmiş öğretici, async akışları oluşturma ve tüketen eşitbir şekilde oluşturulabilir veri dizileri ile çalışmak için daha doğal bir yol sağlar senaryoları göstermektedir.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: de090eb9cc1e8b511956313ab5169ee4d07a492f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79156746"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="d8308-103">Öğretici: C# 8.0 ve .NET Core 3.0 kullanarak async akışları oluşturun ve tüketin</span><span class="sxs-lookup"><span data-stu-id="d8308-103">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="d8308-104">C# 8.0, veri akışındaki öğeler alınadığında veya eşzamanlı olarak oluşturulabilirken bir veri akışı kaynağını modelleyen **async akışlarını**sunar.</span><span class="sxs-lookup"><span data-stu-id="d8308-104">C# 8.0 introduces **async streams**, which model a streaming source of data when the elements in the data stream may be retrieved or generated asynchronously.</span></span> <span data-ttu-id="d8308-105">Async akışları, asynchronous akış veri kaynakları için doğal bir programlama modeli sağlamak için .NET Standard 2.1'de tanıtılan ve .NET Core 3.0'da uygulanan yeni arabirimlere dayanır.</span><span class="sxs-lookup"><span data-stu-id="d8308-105">Async streams rely on new interfaces introduced in .NET Standard 2.1 and implemented in .NET Core 3.0 to provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="d8308-106">Bu öğreticide şunların nasıl yapıldığını öğreneceksiniz:</span><span class="sxs-lookup"><span data-stu-id="d8308-106">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="d8308-107">Eşit bir şekilde bir veri öğesi dizisi oluşturan bir veri kaynağı oluşturun.</span><span class="sxs-lookup"><span data-stu-id="d8308-107">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="d8308-108">Bu veri kaynağını eşzamanlı olarak tüketin.</span><span class="sxs-lookup"><span data-stu-id="d8308-108">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="d8308-109">Yeni arabirimin ve veri kaynağının önceki senkron veri dizilerine ne zaman tercih edilecek olduğunu tanıyın.</span><span class="sxs-lookup"><span data-stu-id="d8308-109">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="d8308-110">Önkoşullar</span><span class="sxs-lookup"><span data-stu-id="d8308-110">Prerequisites</span></span>

<span data-ttu-id="d8308-111">C# 8.0 derleyicisi de dahil olmak üzere .NET Core'u çalıştıracak şekilde makinenizi ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="d8308-111">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="d8308-112">C# 8 derleyicisi [Visual Studio 2019 sürüm 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) veya [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download)ile başlayarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d8308-112">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="d8308-113">GitHub GraphQL bitiş noktasına erişebilmeniz için bir [GitHub erişim belirteci](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="d8308-113">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="d8308-114">GitHub Erişim Jetonu'nuz için aşağıdaki izinleri seçin:</span><span class="sxs-lookup"><span data-stu-id="d8308-114">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="d8308-115">repo:durum</span><span class="sxs-lookup"><span data-stu-id="d8308-115">repo:status</span></span>
- <span data-ttu-id="d8308-116">public_repo</span><span class="sxs-lookup"><span data-stu-id="d8308-116">public_repo</span></span>

<span data-ttu-id="d8308-117">Erişim belirtecikaydet, böylece GitHub API bitiş noktasına erişmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-117">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="d8308-118">Kişisel erişim belirtecinizi güvende tutun.</span><span class="sxs-lookup"><span data-stu-id="d8308-118">Keep your personal access token secure.</span></span> <span data-ttu-id="d8308-119">Kişisel erişim belirtecinize sahip herhangi bir yazılım, erişim haklarınızı kullanarak GitHub API aramaları yapabilir.</span><span class="sxs-lookup"><span data-stu-id="d8308-119">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="d8308-120">Bu öğretici, Visual Studio veya .NET Core CLI dahil olmak üzere C# ve .NET'e aşina olduğunuzu varsayar.</span><span class="sxs-lookup"><span data-stu-id="d8308-120">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="d8308-121">Başlatıcı uygulamasını çalıştırın</span><span class="sxs-lookup"><span data-stu-id="d8308-121">Run the starter application</span></span>

<span data-ttu-id="d8308-122">Bu öğreticide kullanılan başlangıç uygulamasının kodunu [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) klasöründeki [dotnet/samples](https://github.com/dotnet/samples) depomuzdan alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-122">You can get the code for the starter application used in this tutorial from our [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/start) folder.</span></span>

<span data-ttu-id="d8308-123">Başlatıcı uygulaması, [dotnet/docs](https://github.com/dotnet/docs) deposunda yazılan son sorunları almak için [GitHub GraphQL](https://developer.github.com/v4/) arabirimini kullanan bir konsol uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="d8308-123">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="d8308-124">Başlangıç uygulaması `Main` yöntemi için aşağıdaki koda bakarak başlayın:</span><span class="sxs-lookup"><span data-stu-id="d8308-124">Start by looking at the following code for the starter app `Main` method:</span></span>

[!code-csharp[StarterAppMain](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#StarterAppMain)]

<span data-ttu-id="d8308-125">Kişisel erişim belirtecinize bir `GitHubKey` ortam değişkeni ayarlayabilir veya aramadaki `GenEnvVariable` son bağımsız değişkeni kişisel erişim belirtecinize değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-125">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="d8308-126">Kaynağı başkalarıyla birlikte kaydedecekseniz veya paylaşılan bir kaynak deposuna koyacaksanız, erişim kodunuzu kaynak koduna koymayın.</span><span class="sxs-lookup"><span data-stu-id="d8308-126">Don't put your access code in source code if you'll be saving the source with others, or putting it in a shared source repository.</span></span>

<span data-ttu-id="d8308-127">GitHub istemcisini oluşturduktan sonra, kod `Main` bir ilerleme raporlama nesnesi ve bir iptal belirteci oluşturur.</span><span class="sxs-lookup"><span data-stu-id="d8308-127">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="d8308-128">Bu nesneler oluşturulduktan `Main` sonra, en son oluşturulan 250 sorunları almak için çağrılar. `runPagedQueryAsync`</span><span class="sxs-lookup"><span data-stu-id="d8308-128">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="d8308-129">Bu görev tamamlandıktan sonra sonuçlar görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="d8308-129">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="d8308-130">Başlangıç uygulamasını çalıştırdığınızda, bu uygulamanın nasıl çalıştığı hakkında bazı önemli gözlemler yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-130">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="d8308-131">GitHub'dan döndürülen her sayfa için bildirilen ilerlemeyi görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="d8308-131">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="d8308-132">GitHub her yeni sorun sayfasını döndürmeden önce fark edilir bir duraklama gözlemleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-132">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="d8308-133">Son olarak, sorunlar yalnızca 10 sayfanın tümü GitHub'dan alındıktan sonra görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="d8308-133">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="d8308-134">Uygulamayı inceleyin</span><span class="sxs-lookup"><span data-stu-id="d8308-134">Examine the implementation</span></span>

<span data-ttu-id="d8308-135">Uygulama, önceki bölümde tartışılan davranışı neden gözlemlediğinizi ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="d8308-135">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="d8308-136">Aşağıdakilerin kodunu `runPagedQueryAsync`inceleyin:</span><span class="sxs-lookup"><span data-stu-id="d8308-136">Examine the code for `runPagedQueryAsync`:</span></span>

[!code-csharp[RunPagedQueryStarter](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#RunPagedQuery)]

<span data-ttu-id="d8308-137">Sayfalama algoritmasına ve önceki kodun async yapısına odaklanalım.</span><span class="sxs-lookup"><span data-stu-id="d8308-137">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="d8308-138">(GitHub GraphQL API ayrıntıları için [GitHub GraphQL belgelerine](https://developer.github.com/v4/guides/) danışabilirsiniz.) Yöntem, `runPagedQueryAsync` sorunları en sondan en eskiye doğru günceller.</span><span class="sxs-lookup"><span data-stu-id="d8308-138">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="d8308-139">Sayfa başına 25 sayı ister `pageInfo` ve önceki sayfayla devam etmek için yanıtın yapısını inceler.</span><span class="sxs-lookup"><span data-stu-id="d8308-139">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="d8308-140">Bu, GraphQL'nin çok sayfalı yanıtlar için standart sayfalama desteğini izler.</span><span class="sxs-lookup"><span data-stu-id="d8308-140">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="d8308-141">Yanıt, bir `pageInfo` `hasPreviousPages` değer ve önceki `startCursor` sayfayı istemek için kullanılan bir değer içeren bir nesne içerir.</span><span class="sxs-lookup"><span data-stu-id="d8308-141">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="d8308-142">Sorunlar dizide. `nodes`</span><span class="sxs-lookup"><span data-stu-id="d8308-142">The issues are in the `nodes` array.</span></span> <span data-ttu-id="d8308-143">Yöntem, `runPagedQueryAsync` bu düğümleri tüm sayfaların tüm sonuçlarını içeren bir diziye ekler.</span><span class="sxs-lookup"><span data-stu-id="d8308-143">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="d8308-144">Bir sayfa sonuç alınıp geri aldıktan sonra, `runPagedQueryAsync` ilerleme yi raporlar ve iptal için denetimler.</span><span class="sxs-lookup"><span data-stu-id="d8308-144">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="d8308-145">İptal talep edildiyse, `runPagedQueryAsync` bir <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="d8308-145">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="d8308-146">Bu kodda geliştirilebilen birkaç öğe vardır.</span><span class="sxs-lookup"><span data-stu-id="d8308-146">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="d8308-147">En önemlisi, `runPagedQueryAsync` döndürülen tüm sorunlar için depolama ayırması gerekir.</span><span class="sxs-lookup"><span data-stu-id="d8308-147">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="d8308-148">Tüm açık sorunları almak, alınan tüm sorunları depolamak için çok daha fazla bellek gerektirdiğinden, bu örnek 250 konuda durur.</span><span class="sxs-lookup"><span data-stu-id="d8308-148">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="d8308-149">Buna ek olarak, ilerlemeyi ve iptali destekleme protokolleri algoritmayı ilk okumasında daha iyi anlamayı zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="d8308-149">In addition, the protocols for supporting progress and supporting cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="d8308-150">İlerlemenin raporlandığı yeri bulmak için ilerleme sınıfını aramalısınız.</span><span class="sxs-lookup"><span data-stu-id="d8308-150">You must look for the progress class to find where progress is reported.</span></span> <span data-ttu-id="d8308-151">İptalin nerede istendiğini <xref:System.Threading.CancellationTokenSource> ve nerede verildiğini <xref:System.Threading.CancellationToken> anlamak için iletişimleri ve ilgili iletişimleri izlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="d8308-151">You also have to trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="d8308-152">Async akışları daha iyi bir yol sağlar</span><span class="sxs-lookup"><span data-stu-id="d8308-152">Async streams provide a better way</span></span>

<span data-ttu-id="d8308-153">Async akışları ve ilişkili dil desteği tüm bu endişeleri giderir.</span><span class="sxs-lookup"><span data-stu-id="d8308-153">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="d8308-154">Sırayı oluşturan kod artık `yield return` `async` değiştirici ile bildirilen bir yöntemdeki öğeleri döndürmek için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-154">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="d8308-155">Bir `foreach` döngü kullanarak herhangi bir `await foreach` dizi tüketmek gibi bir döngü kullanarak bir async akışı tüketebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-155">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="d8308-156">Bu yeni dil özellikleri ,NET Standart 2.1'e eklenen ve .NET Core 3.0'da uygulanan üç yeni arabirime bağlıdır:</span><span class="sxs-lookup"><span data-stu-id="d8308-156">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

```csharp
namespace System.Collections.Generic
{
    public interface IAsyncEnumerable<out T>
    {
        IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default);
    }

    public interface IAsyncEnumerator<out T> : IAsyncDisposable
    {
        T Current { get; }

        ValueTask<bool> MoveNextAsync();
    }
}

namespace System
{
    public interface IAsyncDisposable
    {
        ValueTask DisposeAsync();
    }
}
```

<span data-ttu-id="d8308-157">Bu üç arabirim çoğu C# geliştiricisine aşina olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="d8308-157">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="d8308-158">Senkron benzerlerine benzer bir şekilde davranıyorlar:</span><span class="sxs-lookup"><span data-stu-id="d8308-158">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="d8308-159">Yabancı olabilecek bir tür. <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d8308-159">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d8308-160"><xref:System.Threading.Tasks.Task?displayProperty=nameWithType> Yapı, `ValueTask` sınıfa benzer bir API sağlar.</span><span class="sxs-lookup"><span data-stu-id="d8308-160">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="d8308-161">`ValueTask`performans nedenleriyle bu arabirimlerde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d8308-161">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="d8308-162">Async akışlarına dönüştürme</span><span class="sxs-lookup"><span data-stu-id="d8308-162">Convert to async streams</span></span>

<span data-ttu-id="d8308-163">Ardından, bir `runPagedQueryAsync` async akışı oluşturmak için yöntemi dönüştürün.</span><span class="sxs-lookup"><span data-stu-id="d8308-163">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="d8308-164">İlk olarak, bir `runPagedQueryAsync` `IAsyncEnumerable<JToken>`, ' döndürmek için imzasını değiştirin ve aşağıdaki kodda gösterildiği gibi parametre listesinden iptal belirteci ve ilerleme nesneleri kaldırın:</span><span class="sxs-lookup"><span data-stu-id="d8308-164">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

[!code-csharp[FinishedSignature](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#UpdateSignature)]

<span data-ttu-id="d8308-165">Başlangıç kodu, aşağıdaki kodda gösterildiği gibi, sayfa alınırken her sayfayı işler:</span><span class="sxs-lookup"><span data-stu-id="d8308-165">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

[!code-csharp[StarterPaging](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#ProcessPage)]

<span data-ttu-id="d8308-166">Bu üç satırı aşağıdaki kodla değiştirin:</span><span class="sxs-lookup"><span data-stu-id="d8308-166">Replace those three lines with the following code:</span></span>

[!code-csharp[FinishedPaging](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#YieldReturnPage)]

<span data-ttu-id="d8308-167">Ayrıca, bu yöntemde `finalResults` önceki bildirimi ve `return` değiştirdiğiniz döngüyü izleyen bildirimi de kaldırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-167">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="d8308-168">Bir async akışı oluşturmak için değişiklikleri tamamladınız.</span><span class="sxs-lookup"><span data-stu-id="d8308-168">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="d8308-169">Bitmiş yöntem aşağıdaki koda benzemelidir:</span><span class="sxs-lookup"><span data-stu-id="d8308-169">The finished method should resemble the code below:</span></span>

[!code-csharp[FinishedGenerate](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#GenerateAsyncStream)]

<span data-ttu-id="d8308-170">Ardından, async akışını tüketmek için koleksiyonu tüketen kodu değiştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-170">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="d8308-171">Sorunların toplanmasını `Main` işleyen aşağıdaki kodu bulun:</span><span class="sxs-lookup"><span data-stu-id="d8308-171">Find the following code in `Main` that processes the collection of issues:</span></span>

[!code-csharp[EnumerateOldStyle](~/samples/snippets/csharp/tutorials/AsyncStreams/start/IssuePRreport/IssuePRreport/Program.cs#EnumerateOldStyle)]

<span data-ttu-id="d8308-172">Bu kodu aşağıdaki `await foreach` döngüyle değiştirin:</span><span class="sxs-lookup"><span data-stu-id="d8308-172">Replace that code with the following `await foreach` loop:</span></span>

[!code-csharp[FinishedEnumerateAsyncStream](~/samples/snippets/csharp/tutorials/AsyncStreams/finished/IssuePRreport/IssuePRreport/Program.cs#EnumerateAsyncStream)]

<span data-ttu-id="d8308-173">Varsayılan olarak, akış öğeleri yakalanan bağlamında işlenir.</span><span class="sxs-lookup"><span data-stu-id="d8308-173">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="d8308-174">Bağlamın ele geçirilmesini devre dışı kılmış <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> olmak istiyorsanız, uzantı yöntemini kullanın.</span><span class="sxs-lookup"><span data-stu-id="d8308-174">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="d8308-175">Eşitleme bağlamları ve geçerli bağlamı yakalama hakkında daha fazla bilgi [için, Görev tabanlı eşzamanlı deseni tüketme makalesine](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="d8308-175">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="d8308-176">Bitmiş öğreticinin kodunu [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) klasöründeki [dotnet/samples](https://github.com/dotnet/samples) deposundan alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-176">You can get the code for the finished tutorial from the [dotnet/samples](https://github.com/dotnet/samples) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/samples/tree/master/csharp/tutorials/AsyncStreams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="d8308-177">Bitmiş uygulamayı çalıştırma</span><span class="sxs-lookup"><span data-stu-id="d8308-177">Run the finished application</span></span>

<span data-ttu-id="d8308-178">Uygulamayı yeniden çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="d8308-178">Run the application again.</span></span> <span data-ttu-id="d8308-179">Davranışını başlatıcı uygulamasının davranışıyla karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="d8308-179">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="d8308-180">Sonuçların ilk sayfası kullanılabilir olur olmaz numaralandırılır.</span><span class="sxs-lookup"><span data-stu-id="d8308-180">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="d8308-181">Her yeni sayfa istendiğinde ve alındığı için gözlemlenebilir bir duraklama olur, ardından bir sonraki sayfanın sonuçları hızla numaralandırılır.</span><span class="sxs-lookup"><span data-stu-id="d8308-181">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="d8308-182">Engellemenin `try`  /  `catch` iptal işlemlerini işlemek için gerekli değildir: arayan koleksiyona sayısal olarak son verebilir.</span><span class="sxs-lookup"><span data-stu-id="d8308-182">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="d8308-183">Async akışı her sayfa indirilirken sonuç ürettiğinden ilerleme açıkça bildirilir.</span><span class="sxs-lookup"><span data-stu-id="d8308-183">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="d8308-184">Döndürülen her sorunun durumu döngüye `await foreach` sorunsuz bir şekilde dahil edilir.</span><span class="sxs-lookup"><span data-stu-id="d8308-184">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="d8308-185">İlerlemeyi izlemek için geri arama nesnesine gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="d8308-185">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="d8308-186">Kodu inceleyerek bellek kullanımındaki gelişmeleri görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-186">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="d8308-187">Artık numaralandırılmadan önce tüm sonuçları depolamak için bir koleksiyon ayırmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="d8308-187">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="d8308-188">Arayan, sonuçların nasıl tüketilen ve bir depolama koleksiyonu gerekip gerekip gerekip gerekip gerekmeden belirlenebileceğini belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="d8308-188">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="d8308-189">Hem başlangıç hem de bitmiş uygulamaları çalıştırın ve uygulamalar arasındaki farkları kendiniz görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-189">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="d8308-190">Bu öğreticiyi bitirdikten sonra başlattığınızda oluşturduğunuz GitHub erişim jetonunu silebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d8308-190">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="d8308-191">Bir saldırgan bu belirteç erişimigeldiyse, kimlik bilgilerinizi kullanarak GitHub API'lerine erişebilir.</span><span class="sxs-lookup"><span data-stu-id="d8308-191">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
