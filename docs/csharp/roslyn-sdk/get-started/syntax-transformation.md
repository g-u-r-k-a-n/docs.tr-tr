---
title: Sözdizimi dönüşümü ile çalışmaya başlama (Roslyn API 'Leri)
description: Sözdizimi ağaçlarını geçme, sorgulama ve yürüyen bir giriş.
ms.date: 06/01/2018
ms.custom: mvc
ms.openlocfilehash: 5045dca839daba1070b34720e72cc9c4f7b94828
ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/03/2020
ms.locfileid: "78240616"
---
# <a name="get-started-with-syntax-transformation"></a><span data-ttu-id="acf7e-103">Sözdizimi dönüşümü ile çalışmaya başlama</span><span class="sxs-lookup"><span data-stu-id="acf7e-103">Get started with syntax transformation</span></span>

<span data-ttu-id="acf7e-104">Bu öğretici, [sözdizimi analizi ile çalışmaya başlama](syntax-analysis.md) bölümünde keşfolan kavram ve tekniklerin yanı sıra [anlam Analizi](semantic-analysis.md) hızlı başlangıçlarını kullanmaya başlamanızı de oluşturur.</span><span class="sxs-lookup"><span data-stu-id="acf7e-104">This tutorial builds on concepts and techniques explored in the [Get started with syntax analysis](syntax-analysis.md) and [Get started with semantic analysis](semantic-analysis.md) quickstarts.</span></span> <span data-ttu-id="acf7e-105">Henüz yapmadıysanız, bu hızlı başlangıçlara başlamadan önce bunu tamamlamalısınız.</span><span class="sxs-lookup"><span data-stu-id="acf7e-105">If you haven't already, you should complete those quickstarts before beginning this one.</span></span>

<span data-ttu-id="acf7e-106">Bu hızlı başlangıçta, sözdizimi ağaçları oluşturma ve dönüştürme tekniklerini keşfedebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-106">In this quickstart, you explore techniques for creating and transforming syntax trees.</span></span> <span data-ttu-id="acf7e-107">Önceki hızlı başlangıçlarda öğrendiğiniz tekniklerle birlikte ilk komut satırı yeniden düzenleme bilgilerinizi oluşturursunuz!</span><span class="sxs-lookup"><span data-stu-id="acf7e-107">In combination with the techniques you learned in previous quickstarts, you create your first command-line refactoring!</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="immutability-and-the-net-compiler-platform"></a><span data-ttu-id="acf7e-108">İmlebilirlik ve .NET derleyici platformu</span><span class="sxs-lookup"><span data-stu-id="acf7e-108">Immutability and the .NET compiler platform</span></span>

<span data-ttu-id="acf7e-109">**İmlebilirlik kullanılabilirliği** , .NET derleyicisi platformunun temel bir temel ' dir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-109">**Immutability** is a fundamental tenet of the .NET compiler platform.</span></span> <span data-ttu-id="acf7e-110">Sabit veri yapıları oluşturulduktan sonra değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="acf7e-110">Immutable data structures can't be changed after they're created.</span></span> <span data-ttu-id="acf7e-111">Değişmez veri yapıları, aynı anda birden çok tüketici tarafından güvenli bir şekilde paylaşılabilir ve çözümlenebilir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-111">Immutable data structures can be safely shared and analyzed by multiple consumers simultaneously.</span></span> <span data-ttu-id="acf7e-112">Bir tüketicinin, bir tüketiciyi öngörülemeyen yollarla etkilediğine ilişkin tehlike yoktur.</span><span class="sxs-lookup"><span data-stu-id="acf7e-112">There's no danger that one consumer affects another in unpredictable ways.</span></span> <span data-ttu-id="acf7e-113">Çözümleyici 'nizin kilitleri veya diğer eşzamanlılık ölçüleri gerekmez.</span><span class="sxs-lookup"><span data-stu-id="acf7e-113">Your analyzer doesn't need locks or other concurrency measures.</span></span> <span data-ttu-id="acf7e-114">Bu kural, söz konusu sözdizimi ağaçları, derlemeler, semboller, anlam modelleri ve karşılaştığınız tüm diğer veri yapılarına yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-114">This rule applies to syntax trees, compilations, symbols, semantic models, and every other data structure you encounter.</span></span> <span data-ttu-id="acf7e-115">API 'Ler, var olan yapıları değiştirmek yerine, eski farklılıklara göre belirtilen farklılıkları temel alarak yeni nesneler oluşturur.</span><span class="sxs-lookup"><span data-stu-id="acf7e-115">Instead of modifying existing structures, APIs create new objects based on specified differences to the old ones.</span></span> <span data-ttu-id="acf7e-116">Dönüşümleri kullanarak yeni ağaçlar oluşturmak için bu kavramı sözdizimi ağaçlarına uygularsınız.</span><span class="sxs-lookup"><span data-stu-id="acf7e-116">You apply this concept to syntax trees to create new trees using transformations.</span></span>

## <a name="create-and-transform-trees"></a><span data-ttu-id="acf7e-117">Ağaçlar oluşturma ve dönüştürme</span><span class="sxs-lookup"><span data-stu-id="acf7e-117">Create and transform trees</span></span>

<span data-ttu-id="acf7e-118">Söz dizimi dönüştürmeleri için iki stratejiden birini seçersiniz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-118">You choose one of two strategies for syntax transformations.</span></span> <span data-ttu-id="acf7e-119">**Fabrika yöntemleri** , değiştirilecek belirli düğümleri veya yeni kod eklemek istediğiniz belirli konumları ararken en iyi şekilde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-119">**Factory methods** are best used when you're searching for specific nodes to replace, or specific locations where you want to insert new code.</span></span> <span data-ttu-id="acf7e-120">**Yeniden yazarlar** , değiştirmek istediğiniz kod desenleri için bir projenin tamamını taramak istediğinizde en iyi seçenektir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-120">**Rewriters** are best when you want to scan an entire project for code patterns that you want to replace.</span></span>

### <a name="create-nodes-with-factory-methods"></a><span data-ttu-id="acf7e-121">Fabrika yöntemleriyle düğüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="acf7e-121">Create nodes with factory methods</span></span>

<span data-ttu-id="acf7e-122">İlk sözdizimi dönüştürmesi, Fabrika yöntemlerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-122">The first syntax transformation demonstrates the factory methods.</span></span> <span data-ttu-id="acf7e-123">Bir `using System.Collections;` ifadesini `using System.Collections.Generic;` ifadesiyle değiştirecek.</span><span class="sxs-lookup"><span data-stu-id="acf7e-123">You're going to replace a `using System.Collections;` statement with a `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="acf7e-124">Bu örnek, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> Factory yöntemlerini kullanarak <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> nesneleri nasıl oluşturacağınızı gösterir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-124">This example demonstrates how you create <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode?displayProperty=nameWithType> objects using the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> factory methods.</span></span> <span data-ttu-id="acf7e-125">Her **düğüm**, **belirteç**veya **üç** tür için, bu türün bir örneğini oluşturan bir fabrika yöntemi vardır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-125">For each kind of **node**, **token**, or **trivia** there's a factory method that creates an instance of that type.</span></span> <span data-ttu-id="acf7e-126">Düğümleri aşağıdan yukarıya doğru oluşturarak sözdizimi ağaçları oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-126">You create syntax trees by composing nodes hierarchically in a bottom-up fashion.</span></span> <span data-ttu-id="acf7e-127">Ardından, var olan programı, oluşturduğunuz yeni ağaç ile varolan düğümleri değiştirmektir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-127">Then, you'll transform the existing program be replacing existing nodes with the new tree you've created.</span></span>

<span data-ttu-id="acf7e-128">Visual Studio 'yu başlatın ve yeni C# bir **tek başına kod analizi araç** projesi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="acf7e-128">Start Visual Studio, and create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="acf7e-129">Visual Studio 'da yeni proje iletişim kutusunu göstermek için **dosya** > **Yeni** > **projesi** öğesini seçin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-129">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span> <span data-ttu-id="acf7e-130">**Görsel C#**  > **genişletilebilirlik** altında **tek başına bir kod Analizi Aracı**seçin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-130">Under **Visual C#** > **Extensibility** choose a **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="acf7e-131">Bu hızlı başlangıçta iki örnek proje bulunur, bu nedenle çözümü **SyntaxTransformationQuickStart**olarak adlandırın ve projeyi **constructioncs**olarak adlandırın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-131">This quickstart has two example projects, so name the solution **SyntaxTransformationQuickStart**, and name the project **ConstructionCS**.</span></span> <span data-ttu-id="acf7e-132">**Tamam**’a tıklayın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-132">Click **OK**.</span></span>

<span data-ttu-id="acf7e-133">Bu proje `System.Collections.Generic` ad alanını temsil eden bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> oluşturmak için <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> Sınıfı yöntemlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-133">This project uses the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory?displayProperty=nameWithType> class methods to construct a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType> representing the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="acf7e-134">Aşağıdaki using direktifini `Program.cs` dosyasının en üstüne ekleyerek <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> sınıfının Fabrika yöntemlerini ve <xref:System.Console> yöntemlerini içeri aktarın ve bunları daha sonra nitelemeden kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="acf7e-134">Add the following using directive to the top of the `Program.cs` file to import the factory methods of the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory> class and the methods of <xref:System.Console> so that you can use them later without qualifying them:</span></span>

[!code-csharp[import the SyntaxFactory class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#StaticUsings "import the Syntax Factory class and the System.Console class")]

<span data-ttu-id="acf7e-135">`using System.Collections.Generic;` ifadesini temsil eden ağacı oluşturmak için **ad sözdizimi düğümleri** oluşturacaksınız.</span><span class="sxs-lookup"><span data-stu-id="acf7e-135">You'll create **name syntax nodes** to build the tree that represents the `using System.Collections.Generic;` statement.</span></span> <span data-ttu-id="acf7e-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, içinde C#görüntülenen dört tür ad için temel sınıftır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-136"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> is the base class for four types of names that appear in C#.</span></span> <span data-ttu-id="acf7e-137">C# Dilde görünebilen herhangi bir ad oluşturmak için bu dört tür adı birlikte oluşturursunuz:</span><span class="sxs-lookup"><span data-stu-id="acf7e-137">You compose these four types of names together to create any name that can appear in the C# language:</span></span>

* <span data-ttu-id="acf7e-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, `System` ve `Microsoft`gibi basit tek tanımlayıcı adlarını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="acf7e-138"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>, which represents simple single identifier names like `System` and `Microsoft`.</span></span>
* <span data-ttu-id="acf7e-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, `List<int>`gibi genel bir tür veya yöntem adını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="acf7e-139"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax?displayProperty=nameWithType>, which represents a generic type or method name such as `List<int>`.</span></span>
* <span data-ttu-id="acf7e-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, `System.IO`gibi biçim `<left-name>.<right-identifier-or-generic-name>` tam adını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="acf7e-140"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax?displayProperty=nameWithType>, which represents a qualified name of the form `<left-name>.<right-identifier-or-generic-name>` such as `System.IO`.</span></span>
* <span data-ttu-id="acf7e-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, bir `LibraryV2::Foo`derleme extern diğer adını kullanarak bir adı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="acf7e-141"><xref:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax?displayProperty=nameWithType>, which represents a name using an assembly extern alias such a `LibraryV2::Foo`.</span></span>

<span data-ttu-id="acf7e-142">Bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> düğümü oluşturmak için <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> yöntemini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="acf7e-142">You use the <xref:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)> method to create a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax> node.</span></span> <span data-ttu-id="acf7e-143">Aşağıdaki kodu `Program.cs``Main` yöntemine ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-143">Add the following code in your `Main` method in `Program.cs`:</span></span>

[!code-csharp[create the system identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateIdentifierName "Create and display the system name identifier")]

<span data-ttu-id="acf7e-144">Yukarıdaki kod bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> nesnesi oluşturur ve `name`değişkenine atar.</span><span class="sxs-lookup"><span data-stu-id="acf7e-144">The preceding code creates an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> object and assigns it to the variable `name`.</span></span> <span data-ttu-id="acf7e-145">Roslyn API 'Lerinin birçoğu, ilgili türlerle çalışmayı kolaylaştırmak için temel sınıflar döndürür.</span><span class="sxs-lookup"><span data-stu-id="acf7e-145">Many of the Roslyn APIs return base classes to make it easier to work with related types.</span></span> <span data-ttu-id="acf7e-146">`name`değişken <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>oluştururken yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-146">The variable `name`, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax>, can be reused as you build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="acf7e-147">Örneği oluştururken tür çıkarımı kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-147">Don't use type inference as you build the sample.</span></span> <span data-ttu-id="acf7e-148">Bu adımı bu projede otomatikleştirin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-148">You'll automate that step in this project.</span></span>

<span data-ttu-id="acf7e-149">Adı oluşturdunuz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-149">You've created the name.</span></span> <span data-ttu-id="acf7e-150">Şimdi, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>oluşturarak ağaçta daha fazla düğüm oluşturmaya zaman atalım.</span><span class="sxs-lookup"><span data-stu-id="acf7e-150">Now, it's time to build more nodes into the tree by building a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="acf7e-151">Yeni ağaç, adının solunda `name` ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>sağ tarafında `Collections` ad alanı için yeni bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> kullanır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-151">The new tree uses `name` as the left of the name, and a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax> for the `Collections` namespace as the right side of the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax>.</span></span> <span data-ttu-id="acf7e-152">Aşağıdaki kodu `program.cs`ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-152">Add the following code to `program.cs`:</span></span>

[!code-csharp[create the collections identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateQualifiedIdentifierName "Build the System.Collections identifier")]

<span data-ttu-id="acf7e-153">Kodu yeniden çalıştırın ve sonuçları görün.</span><span class="sxs-lookup"><span data-stu-id="acf7e-153">Run the code again, and see the results.</span></span> <span data-ttu-id="acf7e-154">Kodu temsil eden bir düğüm ağacı yarayorsunuz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-154">You're building a tree of nodes that represents code.</span></span> <span data-ttu-id="acf7e-155">`System.Collections.Generic`ad alanı için <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> oluşturmak üzere bu düzene devam edersiniz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-155">You'll continue this pattern to build the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax> for the namespace `System.Collections.Generic`.</span></span> <span data-ttu-id="acf7e-156">Aşağıdaki kodu `Program.cs`ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-156">Add the following code to `Program.cs`:</span></span>

[!code-csharp[create the full identifier](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateFullNamespace "Build the System.Collections.Generic identifier")]

<span data-ttu-id="acf7e-157">Eklenecek kodun ağacını oluşturmayı oluşturduğunuzdan emin olmak için programı yeniden çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-157">Run the program again to see that you've build the tree for the code to add.</span></span>

### <a name="create-a-modified-tree"></a><span data-ttu-id="acf7e-158">Değiştirilmiş ağaç oluşturma</span><span class="sxs-lookup"><span data-stu-id="acf7e-158">Create a modified tree</span></span>

<span data-ttu-id="acf7e-159">Tek bir ifade içeren küçük bir sözdizimi ağacı oluşturdunuz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-159">You've built a small syntax tree that contains one statement.</span></span> <span data-ttu-id="acf7e-160">Yeni düğümler oluşturmak için API 'Ler, tek deyimler veya diğer küçük kod blokları oluşturmak için doğru seçimdir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-160">The APIs to create new nodes are the right choice to create single statements or other small code blocks.</span></span> <span data-ttu-id="acf7e-161">Ancak, daha büyük kod blokları oluşturmak için, düğümleri değiştirecek veya düğümleri varolan bir ağaca ekleyecek yöntemleri kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-161">However, to build larger blocks of code, you should use methods that replace nodes or insert nodes into an existing tree.</span></span> <span data-ttu-id="acf7e-162">Söz dizimi ağaçlarının sabit olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-162">Remember that syntax trees are immutable.</span></span> <span data-ttu-id="acf7e-163">**Sözdizimi API 'si** , oluşturulduktan sonra var olan bir sözdizimi ağacını değiştirmek için herhangi bir mekanizma sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-163">The **Syntax API** doesn't provide any mechanism for modifying an existing syntax tree after construction.</span></span> <span data-ttu-id="acf7e-164">Bunun yerine, var olan değişikliklere göre yeni ağaçlar üreten yöntemler sağlar.</span><span class="sxs-lookup"><span data-stu-id="acf7e-164">Instead, it provides methods that produce new trees based on changes to existing ones.</span></span> <span data-ttu-id="acf7e-165">`With*` Yöntemler, <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> sınıfında belirtilen <xref:Microsoft.CodeAnalysis.SyntaxNode> veya genişletme yöntemlerinden türetilen somut sınıflarda tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-165">`With*` methods are defined in concrete classes that derive from <xref:Microsoft.CodeAnalysis.SyntaxNode> or in extension methods declared in the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions> class.</span></span> <span data-ttu-id="acf7e-166">Bu yöntemler, var olan bir düğümün alt özelliklerine değişiklikler uygulayarak yeni bir düğüm oluşturur.</span><span class="sxs-lookup"><span data-stu-id="acf7e-166">These methods create a new node by applying changes to an existing node's child properties.</span></span> <span data-ttu-id="acf7e-167">Ek olarak, <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> uzantısı yöntemi bir alt ağaçtaki bir alt düğümü değiştirmek için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-167">Additionally, the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method can be used to replace a descendent node in a subtree.</span></span> <span data-ttu-id="acf7e-168">Bu yöntem aynı zamanda yeni oluşturulan alt öğeye işaret eden üst öğeyi güncelleştirir ve bu işlemi, ağacı _yeniden dönme_ olarak bilinen bir işlem olan ağacın tamamına yineler.</span><span class="sxs-lookup"><span data-stu-id="acf7e-168">This method also updates the parent to point to the newly created child and repeats this process up the entire tree - a process known as _re-spinning_ the tree.</span></span>

<span data-ttu-id="acf7e-169">Bir sonraki adım, (küçük) bir programın tamamını temsil eden bir ağaç oluşturmak ve ardından onu değiştirmektir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-169">The next step is to create a tree that represents an entire (small) program and then modify it.</span></span> <span data-ttu-id="acf7e-170">`Program` sınıfının başlangıcına aşağıdaki kodu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-170">Add the following code to the beginning of the `Program` class:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#DeclareSampleCode "Create a tree that represents a small program")]

> [!NOTE]
> <span data-ttu-id="acf7e-171">Örnek kod, `System.Collections.Generic` ad alanını değil `System.Collections` ad alanını kullanır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-171">The example code uses the `System.Collections` namespace and not the `System.Collections.Generic` namespace.</span></span>

<span data-ttu-id="acf7e-172">Sonra, metni ayrıştırmak ve bir ağaç oluşturmak için `Main` yönteminin sonuna aşağıdaki kodu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-172">Next, add the following code to the bottom of the `Main` method to parse the text and create a tree:</span></span>

[!code-csharp[create a parse tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#CreateParseTree "Create a tree that represents a small program")]

<span data-ttu-id="acf7e-173">Bu örnek, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> düğümündeki adı önceki kodda oluşturulmuş bir ile değiştirmek için <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> yöntemini kullanır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-173">This example uses the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)?displayProperty=NameWithType> method to replace the name in a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node with the one constructed in the preceding code.</span></span>

<span data-ttu-id="acf7e-174">`System.Collections` adını önceki kodda oluşturduğunuz adla güncelleştirmek için <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> yöntemini kullanarak yeni bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> düğümü oluşturun.</span><span class="sxs-lookup"><span data-stu-id="acf7e-174">Create a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> node using the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.WithName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)> method to update the `System.Collections` name with the name you created in the preceding code.</span></span> <span data-ttu-id="acf7e-175">Aşağıdaki kodu `Main` yönteminin altına ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-175">Add the following code to the bottom of the `Main` method:</span></span>

[!code-csharp[create a new subtree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#BuildNewUsing "Create the subtree with the replaced namespace")]

<span data-ttu-id="acf7e-176">Programı çalıştırın ve çıkışa dikkatle göz atın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-176">Run the program and look carefully at the output.</span></span> <span data-ttu-id="acf7e-177">`newusing` kök ağaca yerleştirilmemiştir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-177">The `newusing` hasn't been placed in the root tree.</span></span> <span data-ttu-id="acf7e-178">Özgün ağaç değiştirilmedi.</span><span class="sxs-lookup"><span data-stu-id="acf7e-178">The original tree hasn't been changed.</span></span>

<span data-ttu-id="acf7e-179">Yeni bir ağaç oluşturmak için <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> uzantısı yöntemini kullanarak aşağıdaki kodu ekleyin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-179">Add the following code using the <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> extension method to create a new tree.</span></span> <span data-ttu-id="acf7e-180">Yeni ağaç, varolan içeri aktarmanın güncelleştirilmiş `newUsing` düğümü ile değiştirilmesi sonucudur.</span><span class="sxs-lookup"><span data-stu-id="acf7e-180">The new tree is the result of replacing the existing import with the updated `newUsing` node.</span></span> <span data-ttu-id="acf7e-181">Bu yeni ağacı varolan `root` değişkenine atarsınız:</span><span class="sxs-lookup"><span data-stu-id="acf7e-181">You assign this new tree to the existing `root` variable:</span></span>

[!code-csharp[create a new root tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/ConstructionCS/Program.cs#TransformTree "Create the transformed root tree with the replaced namespace")]

<span data-ttu-id="acf7e-182">Programı yeniden çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-182">Run the program again.</span></span> <span data-ttu-id="acf7e-183">Bu kez, ağaç artık `System.Collections.Generic` ad alanını doğru bir şekilde içeri aktarır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-183">This time the tree now correctly imports the `System.Collections.Generic` namespace.</span></span>

### <a name="transform-trees-using-syntaxrewriters"></a><span data-ttu-id="acf7e-184">`SyntaxRewriters` kullanarak ağaçları dönüştürme</span><span class="sxs-lookup"><span data-stu-id="acf7e-184">Transform trees using `SyntaxRewriters`</span></span>

<span data-ttu-id="acf7e-185">`With*` ve <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> yöntemleri, bir sözdizimi ağacının tek tek dallarını dönüştürmek için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="acf7e-185">The `With*` and <xref:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode%2A> methods provide convenient means to transform individual branches of a syntax tree.</span></span> <span data-ttu-id="acf7e-186"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> sınıfı, bir sözdizimi ağacında birden çok dönüştürme gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-186">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class performs multiple transformations on a syntax tree.</span></span> <span data-ttu-id="acf7e-187"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> sınıfı, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>bir alt sınıfıdır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-187">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter?displayProperty=nameWithType> class is a subclass of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="acf7e-188"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter>, belirli bir <xref:Microsoft.CodeAnalysis.SyntaxNode>türüne dönüşüm uygular.</span><span class="sxs-lookup"><span data-stu-id="acf7e-188">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> applies a transformation to a specific type of <xref:Microsoft.CodeAnalysis.SyntaxNode>.</span></span> <span data-ttu-id="acf7e-189">Bir sözdizimi ağacında göründükleri yerde, birden çok <xref:Microsoft.CodeAnalysis.SyntaxNode> nesne türüne dönüşümler uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-189">You can apply transformations to multiple types of <xref:Microsoft.CodeAnalysis.SyntaxNode> objects wherever they appear in a syntax tree.</span></span> <span data-ttu-id="acf7e-190">Bu hızlı başlangıçtaki ikinci proje, tür çıkarımı kullanılabilir her yerde yerel değişken bildirimlerinde açık türleri kaldıran bir komut satırı yeniden düzenlemesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="acf7e-190">The second project in this quickstart creates a command-line refactoring that removes explicit types in local variable declarations anywhere that type inference could be used.</span></span>

<span data-ttu-id="acf7e-191">Yeni C# bir **tek başına kod analizi araç** projesi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="acf7e-191">Create a new C# **Stand-Alone Code Analysis Tool** project.</span></span> <span data-ttu-id="acf7e-192">Visual Studio 'da `SyntaxTransformationQuickStart` çözüm düğümüne sağ tıklayın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-192">In Visual Studio, right-click the `SyntaxTransformationQuickStart` solution node.</span></span> <span data-ttu-id="acf7e-193">**Yeni proje iletişim kutusunu**göstermek Için > **Yeni proje** **Ekle** ' yi seçin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-193">Choose **Add** > **New Project** to display the **New Project dialog**.</span></span> <span data-ttu-id="acf7e-194">**Görsel C#**  > **genişletilebilirliği**altında **tek başına Kod Analizi Aracı**' nı seçin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-194">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span> <span data-ttu-id="acf7e-195">Projenizin `TransformationCS` adlandırın ve Tamam ' a tıklayın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-195">Name your project `TransformationCS` and click OK.</span></span>

<span data-ttu-id="acf7e-196">İlk adım, dönüştürmelerinizi gerçekleştirmek için <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> türeten bir sınıf oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-196">The first step is to create a class that derives from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> to perform your transformations.</span></span> <span data-ttu-id="acf7e-197">Projeye yeni bir sınıf dosyası ekleyin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-197">Add a new class file to the project.</span></span> <span data-ttu-id="acf7e-198">Visual Studio 'da, **proje** > **Sınıf Ekle...** öğesini seçin. **Yeni öğe Ekle** iletişim kutusunda `TypeInferenceRewriter.cs` dosya adı olarak yazın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-198">In Visual Studio, choose **Project** > **Add Class...**. In the **Add New Item** dialog type `TypeInferenceRewriter.cs` as the filename.</span></span>

<span data-ttu-id="acf7e-199">Aşağıdaki using yönergelerini `TypeInferenceRewriter.cs` dosyasına ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-199">Add the following using directives to the `TypeInferenceRewriter.cs` file:</span></span>

[!code-csharp[add necessary usings](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#AddUsings "Add required usings")]

<span data-ttu-id="acf7e-200">Sonra, `TypeInferenceRewriter` sınıfının <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> sınıfını genişletmesine dikkat edin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-200">Next, make the `TypeInferenceRewriter` class extend the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter> class:</span></span>

[!code-csharp[add base class](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BaseClass "Add base class")]

<span data-ttu-id="acf7e-201">Bir <xref:Microsoft.CodeAnalysis.SemanticModel> tutmak ve oluşturucuda başlatmak için özel bir salt okuma alanı bildirmek üzere aşağıdaki kodu ekleyin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-201">Add the following code to declare a private read-only field to hold a <xref:Microsoft.CodeAnalysis.SemanticModel> and initialize it in the constructor.</span></span> <span data-ttu-id="acf7e-202">Tür çıkarımını nerede kullanılabileceğini öğrenmek için bu alana daha sonra ihtiyacınız olacak:</span><span class="sxs-lookup"><span data-stu-id="acf7e-202">You will need this field later on to determine where type inference can be used:</span></span>

[!code-csharp[initialize members](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Construction "Declare and initialize member variables")]

<span data-ttu-id="acf7e-203"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> yöntemini geçersiz kılın:</span><span class="sxs-lookup"><span data-stu-id="acf7e-203">Override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method:</span></span>

```csharp
public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
{

}
```

> [!NOTE]
> <span data-ttu-id="acf7e-204">Roslyn API 'lerinin birçoğu, döndürülen gerçek çalışma zamanı türlerinin temel sınıfları olan dönüş türlerini bildirir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-204">Many of the Roslyn APIs declare return types that are base classes of the actual runtime types returned.</span></span> <span data-ttu-id="acf7e-205">Birçok senaryoda, bir tür düğüm tamamen veya hatta kaldırılmış başka bir düğüm türüyle değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-205">In many scenarios, one kind of node may be replaced by another kind of node entirely - or even removed.</span></span> <span data-ttu-id="acf7e-206">Bu örnekte <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> yöntemi, türetilmiş <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>türü yerine bir <xref:Microsoft.CodeAnalysis.SyntaxNode>döndürür.</span><span class="sxs-lookup"><span data-stu-id="acf7e-206">In this example, the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)> method returns a <xref:Microsoft.CodeAnalysis.SyntaxNode>, instead of the derived type of   <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax>.</span></span> <span data-ttu-id="acf7e-207">Bu yeniden yazıcı, mevcut bir düğüme göre yeni bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> düğümü döndürüyor.</span><span class="sxs-lookup"><span data-stu-id="acf7e-207">This rewriter returns a new <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> node based on the existing one.</span></span>

<span data-ttu-id="acf7e-208">Bu hızlı başlangıçta yerel değişken bildirimleri ele alır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-208">This quickstart handles local variable declarations.</span></span> <span data-ttu-id="acf7e-209">`foreach` döngüleri, `for` döngüleri, LINQ ifadeleri ve lambda ifadeleri gibi diğer bildirimlere genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-209">You could extend it to other declarations such as `foreach` loops, `for` loops, LINQ expressions, and lambda expressions.</span></span> <span data-ttu-id="acf7e-210">Ayrıca, bu yeniden yazıcı yalnızca en basit formun bildirimlerini dönüştürür:</span><span class="sxs-lookup"><span data-stu-id="acf7e-210">Furthermore this rewriter will only transform declarations of the simplest form:</span></span>

```csharp
Type variable = expression;
```

<span data-ttu-id="acf7e-211">Kendi kendinize araştırmak isterseniz, bu tür bildirimler için tamamlanan örneği genişletmeyi göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="acf7e-211">If you want to explore on your own, consider extending the finished sample for these types of variable declarations:</span></span>

```csharp
// Multiple variables in a single declaration.
Type variable1 = expression1,
     variable2 = expression2;
// No initializer.
Type variable;
```

<span data-ttu-id="acf7e-212">Aşağıdaki kodu, bu bildirim biçimlerini yeniden yazmayı atlamak için `VisitLocalDeclarationStatement` yönteminin gövdesine ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-212">Add the following code to the body of the `VisitLocalDeclarationStatement` method to skip rewriting these forms of declarations:</span></span>

[!code-csharp[exclude other declarations](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#Exclusions "Exclude variables declarations not processed by this sample")]

<span data-ttu-id="acf7e-213">Yöntemi, `node` parametresi değiştirilmemiş olarak dönerek yeniden yazma gerçekleşmeden emin olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-213">The method indicates that no rewriting takes place by returning the `node` parameter unmodified.</span></span> <span data-ttu-id="acf7e-214">Bu `if` ifadelerden hiçbiri true ise, düğüm başlatma ile olası bir bildirimi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="acf7e-214">If neither of those `if` expressions are true, the node represents a possible declaration with initialization.</span></span> <span data-ttu-id="acf7e-215">Bildirimde belirtilen tür adını ayıklamak ve bir tür simgesi almak için <xref:Microsoft.CodeAnalysis.SemanticModel> alanını kullanarak bağlamak için bu deyimleri ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-215">Add these statements to extract the type name specified in the declaration and bind it using the <xref:Microsoft.CodeAnalysis.SemanticModel> field to obtain a type symbol:</span></span>

[!code-csharp[extract type name](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ExtractTypeSymbol "Extract the type name specified by the declaration")]

<span data-ttu-id="acf7e-216">Şimdi Başlatıcı ifadesini bağlamak için bu deyimi ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-216">Now, add this statement to bind the initializer expression:</span></span>

[!code-csharp[bind initializer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#BindInitializer "Bind the initializer expressions")]

<span data-ttu-id="acf7e-217">Son olarak, başlatıcı ifadesinin türü belirtilen türle eşleşiyorsa, varolan tür adını `var` anahtar sözcüğüyle değiştirmek için aşağıdaki `if` deyimini ekleyin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-217">Finally, add the following `if` statement to replace the existing type name with the `var` keyword if the type of the initializer expression matches the type specified:</span></span>

[!code-csharp[ReplaceNode](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/TypeInferenceRewriter.cs#ReplaceNode "Replace the initializer node")]

<span data-ttu-id="acf7e-218">Bildirim, başlatıcı ifadesini temel bir sınıfa veya arabirime atabileceğinden koşullu gereklidir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-218">The conditional is required because the declaration may cast the initializer expression to a base class or interface.</span></span> <span data-ttu-id="acf7e-219">Bu istenirse, atamanın sol ve sağ tarafındaki türler eşleşmez.</span><span class="sxs-lookup"><span data-stu-id="acf7e-219">If that's desired, the types on the left and right-hand side of the assignment don't match.</span></span> <span data-ttu-id="acf7e-220">Bu durumlarda açık türün kaldırılması bir programın semantiğini değiştirir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-220">Removing the explicit type in these cases would change the semantics of a program.</span></span> <span data-ttu-id="acf7e-221">`var` bağlamsal bir anahtar sözcük olduğundan `var` bir anahtar sözcük yerine tanımlayıcı olarak belirtilir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-221">`var` is specified as an identifier rather than a keyword because `var` is a contextual keyword.</span></span> <span data-ttu-id="acf7e-222">Baştaki ve sondaki üç nokta (beyaz boşluk), dikey boşluk ve girintilenmesini sağlamak için eski tür adından `var` anahtar sözcüğüne aktarılır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-222">The leading and trailing trivia (white space) are transferred from the old type name to the `var` keyword to maintain vertical white space and indentation.</span></span> <span data-ttu-id="acf7e-223">Tür adı, bildirim bildiriminin gerçekten alt öğesi olduğundan, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> dönüştürmek için `With*` yerine `ReplaceNode` kullanmak daha basittir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-223">It's simpler to use `ReplaceNode` rather than `With*` to transform the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax> because the type name is actually the grandchild of the declaration statement.</span></span>

<span data-ttu-id="acf7e-224">`TypeInferenceRewriter`tamamladınız.</span><span class="sxs-lookup"><span data-stu-id="acf7e-224">You've finished the `TypeInferenceRewriter`.</span></span> <span data-ttu-id="acf7e-225">Şimdi, örneği tamamlayacak `Program.cs` dosyanıza geri dönün.</span><span class="sxs-lookup"><span data-stu-id="acf7e-225">Now return to your `Program.cs` file to finish the example.</span></span> <span data-ttu-id="acf7e-226">Bir test <xref:Microsoft.CodeAnalysis.Compilation> oluşturun ve bundan <xref:Microsoft.CodeAnalysis.SemanticModel> alın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-226">Create a test <xref:Microsoft.CodeAnalysis.Compilation> and obtain the <xref:Microsoft.CodeAnalysis.SemanticModel> from it.</span></span> <span data-ttu-id="acf7e-227">`TypeInferenceRewriter`denemek için bu <xref:Microsoft.CodeAnalysis.SemanticModel> kullanın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-227">Use that <xref:Microsoft.CodeAnalysis.SemanticModel> to try your `TypeInferenceRewriter`.</span></span> <span data-ttu-id="acf7e-228">Bu adımı son yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-228">You'll do this step last.</span></span> <span data-ttu-id="acf7e-229">Bu arada, test derlenmesini temsil eden bir yer tutucu değişkeni bildirin:</span><span class="sxs-lookup"><span data-stu-id="acf7e-229">In the meantime declare a placeholder variable representing your test compilation:</span></span>

[!code-csharp[DeclareCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#DeclareTestCompilation "Declare the test compilation")]

<span data-ttu-id="acf7e-230">Bir süre durakladıktan sonra, `CreateTestCompilation` bir yöntemin bulunmadığını bildiren bir hata ortaya çıktıktan sonra hata görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-230">After pausing a moment, you should see an error squiggle appear reporting that no `CreateTestCompilation` method exists.</span></span> <span data-ttu-id="acf7e-231">Açık ampul ' i açmak için **CTRL + nokta** tuşlarına basın ve sonra **Yöntem oluşturma saplama** komutunu çağırmak için ENTER tuşuna basın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-231">Press **Ctrl+Period** to open the light-bulb and then press Enter to invoke the **Generate Method Stub** command.</span></span> <span data-ttu-id="acf7e-232">Bu komut, `Program` sınıfında `CreateTestCompilation` yöntemi için bir yöntem saplaması oluşturacaktır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-232">This command will generate a method stub for the `CreateTestCompilation` method in the `Program` class.</span></span> <span data-ttu-id="acf7e-233">Daha sonra bu yöntemi dolduracak şekilde geri döneceksiniz:</span><span class="sxs-lookup"><span data-stu-id="acf7e-233">You'll come back to fill in this method later:</span></span>

![C#Kullanımdan bir yöntem oluştur](./media/syntax-transformation/generate-from-usage.png)

<span data-ttu-id="acf7e-235">Test <xref:Microsoft.CodeAnalysis.Compilation>her <xref:Microsoft.CodeAnalysis.SyntaxTree> yinelemek için aşağıdaki kodu yazın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-235">Write the following code to iterate over each <xref:Microsoft.CodeAnalysis.SyntaxTree> in the test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="acf7e-236">Her biri için, bu ağaç <xref:Microsoft.CodeAnalysis.SemanticModel> yeni bir `TypeInferenceRewriter` başlatın:</span><span class="sxs-lookup"><span data-stu-id="acf7e-236">For each one, initialize a new `TypeInferenceRewriter` with the <xref:Microsoft.CodeAnalysis.SemanticModel> for that tree:</span></span>

[!code-csharp[IterateTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#IterateTrees "Iterate all the source trees in the test compilation")]

<span data-ttu-id="acf7e-237">Oluşturduğunuz `foreach` deyimin içinde, her kaynak ağacında dönüştürmeyi gerçekleştirmek için aşağıdaki kodu ekleyin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-237">Inside the `foreach` statement you created, add the following code to perform the transformation on each source tree.</span></span> <span data-ttu-id="acf7e-238">Bu kod, herhangi bir düzenleme yapılıyorsa, yeni dönüştürülmüş ağacı koşullu olarak yazar.</span><span class="sxs-lookup"><span data-stu-id="acf7e-238">This code conditionally writes out the new transformed tree if any edits were made.</span></span> <span data-ttu-id="acf7e-239">Yeniden yazıcı, tür çıkarımı kullanılarak Basitleştirilen bir veya daha fazla yerel değişken bildirimi ile karşılaştığında yalnızca bir ağacı değiştirmeli:</span><span class="sxs-lookup"><span data-stu-id="acf7e-239">Your rewriter should only modify a tree if it encounters one or more local variable declarations that could be simplified using type inference:</span></span>

[!code-csharp[TransformTrees](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#TransformTrees "Transform and save any trees that are modified by the rewriter")]

<span data-ttu-id="acf7e-240">`File.WriteAllText` kodu altında dalgalı çizgiler görmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-240">You should see squiggles under the `File.WriteAllText` code.</span></span> <span data-ttu-id="acf7e-241">Ampul ' i seçin ve gerekli `using System.IO;` ifadesini ekleyin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-241">Select the light bulb, and add the necessary `using System.IO;` statement.</span></span>

<span data-ttu-id="acf7e-242">Neredeyse tamamladınız!</span><span class="sxs-lookup"><span data-stu-id="acf7e-242">You're almost done!</span></span> <span data-ttu-id="acf7e-243">Bir adım kaldı: test <xref:Microsoft.CodeAnalysis.Compilation>oluşturma.</span><span class="sxs-lookup"><span data-stu-id="acf7e-243">There's once step left: creating a test <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="acf7e-244">Bu hızlı başlangıçta tür çıkarımı kullanmadığınız için, tam bir test çalışması yapmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="acf7e-244">Since you haven't been using type inference at all during this quickstart, it would have made a perfect test case.</span></span> <span data-ttu-id="acf7e-245">Ne yazık ki, bir C# proje dosyasından derleme oluşturmak Bu izlenecek yolun kapsamının dışındadır.</span><span class="sxs-lookup"><span data-stu-id="acf7e-245">Unfortunately, creating a Compilation from a C# project file is beyond the scope of this walkthrough.</span></span> <span data-ttu-id="acf7e-246">Ancak, yönergeleri dikkatle takip ediyorsanız, umuyoruz.</span><span class="sxs-lookup"><span data-stu-id="acf7e-246">But fortunately, if you've been following instructions carefully, there's hope.</span></span> <span data-ttu-id="acf7e-247">`CreateTestCompilation` yönteminin içeriğini aşağıdaki kodla değiştirin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-247">Replace the contents of the `CreateTestCompilation` method with the following code.</span></span> <span data-ttu-id="acf7e-248">Tesadüfen bu hızlı başlangıçta açıklanan projeyle eşleşen bir test derlemesi oluşturur:</span><span class="sxs-lookup"><span data-stu-id="acf7e-248">It creates a test compilation that coincidentally matches the project described in this quickstart:</span></span>

[!code-csharp[CreateTestCompilation](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxTransformationQuickStart/TransformationCS/Program.cs#CreateTestCompilation "Create a test compilation using the code written for this quickstart.")]

<span data-ttu-id="acf7e-249">Parmaklarınızın çapraz yanı sıra projeyi çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-249">Cross your fingers and run the project.</span></span> <span data-ttu-id="acf7e-250">Visual Studio 'da hata **ayıklamayı başlat** > **Hata Ayıkla** ' yı seçin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-250">In Visual Studio, choose **Debug** > **Start Debugging**.</span></span> <span data-ttu-id="acf7e-251">Visual Studio 'Nun projenizdeki dosyaların değiştiği sorulur.</span><span class="sxs-lookup"><span data-stu-id="acf7e-251">You should be prompted by Visual Studio that the files in your project have changed.</span></span> <span data-ttu-id="acf7e-252">Değiştirilen dosyaları yeniden yüklemek için "**Tümüne Evet**" e tıklayın.</span><span class="sxs-lookup"><span data-stu-id="acf7e-252">Click "**Yes to All**" to reload the modified files.</span></span> <span data-ttu-id="acf7e-253">Awesomeninizi gözlemlemek için bunları inceleyin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-253">Examine them to observe your awesomeness.</span></span> <span data-ttu-id="acf7e-254">Kodun tüm açık ve gereksiz tür belirticileri olmadan ne kadar temizleyici göründüğünü göz önünde edin.</span><span class="sxs-lookup"><span data-stu-id="acf7e-254">Note how much cleaner the code looks without all those explicit and redundant type specifiers.</span></span>

<span data-ttu-id="acf7e-255">Tebrikler!</span><span class="sxs-lookup"><span data-stu-id="acf7e-255">Congratulations!</span></span> <span data-ttu-id="acf7e-256">**Derleyici API 'lerini** , belirli sözdizimsel desenler için bir C# projedeki tüm dosyaları arayan kendi yeniden düzenleme, bu desenlerle eşleşen kaynak kodun semantiğini analiz eden ve onu dönüştüren kendi yeniden düzenlemenizi yazmak için kullandınız.</span><span class="sxs-lookup"><span data-stu-id="acf7e-256">You've used the **Compiler APIs** to write your own refactoring that searches all files in a C# project for certain syntactic patterns, analyzes the semantics of source code that matches those patterns, and transforms it.</span></span> <span data-ttu-id="acf7e-257">Artık resmi olarak yeniden düzenleme yapmanız gerekir!</span><span class="sxs-lookup"><span data-stu-id="acf7e-257">You're now officially refactoring author!</span></span>
