---
title: Internet Information Services Barındırma En İyi Uygulamaları
ms.date: 03/30/2017
ms.assetid: 0834768e-9665-46bf-86eb-d4b09ab91af5
ms.openlocfilehash: 3be9d4c81f891ad898099ba9041a09b16388b7e4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79184711"
---
# <a name="internet-information-services-hosting-best-practices"></a><span data-ttu-id="1c97f-102">Internet Information Services Barındırma En İyi Uygulamaları</span><span class="sxs-lookup"><span data-stu-id="1c97f-102">Internet Information Services Hosting Best Practices</span></span>
<span data-ttu-id="1c97f-103">Bu konu, Windows Communication Foundation (WCF) hizmetlerini barındırmak için en iyi uygulamaları özetlemektedir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-103">This topic outlines some best practices for hosting Windows Communication Foundation (WCF) services.</span></span>  
  
## <a name="implementing-wcf-services-as-dlls"></a><span data-ttu-id="1c97f-104">WCF Hizmetlerinin DL olarak uygulanması</span><span class="sxs-lookup"><span data-stu-id="1c97f-104">Implementing WCF Services as DLLs</span></span>  
 <span data-ttu-id="1c97f-105">Bir WCF hizmetini, bir Web uygulamasının \bin dizinine dağıtılan bir DLL olarak uygulamak, hizmeti Web uygulama modelinin dışında( örneğin, Internet Information Services (IIS) dağıtılmayan bir test ortamında yeniden kullanmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-105">Implementing a WCF service as a DLL that is deployed to the \bin directory of a Web application allows you reuse the service outside of the Web application model, for example, in a test environment that may not have Internet Information Services (IIS) deployed.</span></span>  
  
## <a name="service-hosts-in-iis-hosted-applications"></a><span data-ttu-id="1c97f-106">IIS Tarafından Barındırılan Uygulamalarda Hizmet Barındıran Sunucular</span><span class="sxs-lookup"><span data-stu-id="1c97f-106">Service Hosts in IIS-Hosted Applications</span></span>  
 <span data-ttu-id="1c97f-107">Zorunlu kendi barındırma API'lerini, IIS barındırma ortamı tarafından yerel olarak desteklenmeyen ağ aktarımlarında dinleyen yeni hizmet barındıran ları oluşturmak için kullanmayın (Örneğin, TCP iletişimi IIS 6.0'da yerel olarak desteklenmediği için IIS 6.0 TCP hizmetlerini barındırmak için).</span><span class="sxs-lookup"><span data-stu-id="1c97f-107">Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, IIS 6.0 to host TCP services, because TCP communication is not natively supported on IIS 6.0).</span></span> <span data-ttu-id="1c97f-108">Bu yaklaşım önerilmez.</span><span class="sxs-lookup"><span data-stu-id="1c97f-108">This approach is not recommended.</span></span> <span data-ttu-id="1c97f-109">Zorunlu olarak oluşturulan hizmet ana bilgisayarları IIS barındırma ortamında bilinmemektedir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-109">Service hosts created imperatively are not known within the IIS hosting environment.</span></span> <span data-ttu-id="1c97f-110">Kritik nokta, barındırma uygulama havuzunun boşta olup olmadığını belirlerken zorunlu olarak oluşturulan hizmetler tarafından yapılan işlemlerin IIS tarafından muhasebelemediğidir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-110">The critical point is that processing done by imperatively created services is not accounted for by IIS when it determines whether the hosting application pool is idle.</span></span> <span data-ttu-id="1c97f-111">Sonuç olarak, bu tür zorunlu olarak oluşturulan hizmet ana bilgisayarları olan uygulamaların, IIS ana bilgisayar süreçlerini agresif bir şekilde bertaraf eden bir IIS barındırma ortamına sahip olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-111">The result is that applications that have such imperatively created service hosts have an IIS hosting environment that aggressively disposes of IIS host processes.</span></span>  
  
## <a name="uris-and-iis-hosted-endpoints"></a><span data-ttu-id="1c97f-112">URI'ler ve IIS Tarafından Barındırılan Uç Noktalar</span><span class="sxs-lookup"><span data-stu-id="1c97f-112">URIs and IIS-Hosted Endpoints</span></span>  
 <span data-ttu-id="1c97f-113">IIS tarafından barındırılan bir hizmetin bitiş noktaları, mutlak adresler kullanılarak değil, göreli Tekdüzen Kaynak Tanımlayıcıları (URI'ler) kullanılarak yapılandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-113">Endpoints for an IIS-hosted service should be configured using relative Uniform Resource Identifiers (URIs), not absolute addresses.</span></span> <span data-ttu-id="1c97f-114">Bu, bitiş noktası adresinin barındırma uygulamasına ait URI adresleri kümesine düştüğünü garanti eder ve ileti tabanlı etkinleştirmenin beklendiği gibi gerçekleşmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="1c97f-114">This guarantees that the endpoint address falls within the set of URI addresses that belong to the hosting application and ensures that message-based activation happens as expected.</span></span>  
  
## <a name="state-management-and-process-recycling"></a><span data-ttu-id="1c97f-115">Devlet Yönetimi ve Süreç Geri Dönüşümü</span><span class="sxs-lookup"><span data-stu-id="1c97f-115">State Management and Process Recycling</span></span>  
 <span data-ttu-id="1c97f-116">IIS barındırma ortamı, bellekte yerel durumu korumayan hizmetler için optimize edilebiyi raydır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-116">The IIS hosting environment is optimized for services that do not maintain local state in memory.</span></span> <span data-ttu-id="1c97f-117">IIS, çeşitli dış ve iç olaylara yanıt olarak ana bilgisayar işlemini geri dönüştürür ve yalnızca bellekte depolanan geçici durumların kaybolmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="1c97f-117">IIS recycles the host process in response to a variety of external and internal events, causing any volatile state stored exclusively in memory to be lost.</span></span> <span data-ttu-id="1c97f-118">IIS'de barındırılan hizmetler, durumlarını işlemin dışında (örneğin, bir veritabanında) veya bir uygulama geri dönüştürme olayı oluşursa kolayca yeniden oluşturulabilecek bir bellek önbelleğinde depolamalıdır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-118">Services hosted in IIS should store their state external to the process (for example, in a database) or in an in-memory cache that can easily be re-created if an application recycle event occurs.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="1c97f-119">WCF'nin ileti katmanı güvenilirliği ve güvenliği için kullandığı protokoller, geçici bellek içi durumu kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-119">The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state.</span></span> <span data-ttu-id="1c97f-120">WCF güvenilir oturumları ve güvenlik oturumları, uygulama geri dönüşümleri nedeniyle beklenmedik bir şekilde sona erebilir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-120">WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles.</span></span> <span data-ttu-id="1c97f-121">Bu protokollerden yararlanan IIS barındırılan uygulamalar, uygulama katmanı durumunu ilişkilendirme (örneğin, uygulama katmanı yapısı veya özel korelasyon üstbilgisi) için WCF tarafından sağlanan oturum anahtarından başka bir şeye bağlı olmalı veya devre dışı Barındırılan uygulama için IIS proses geri dönüşümü.</span><span class="sxs-lookup"><span data-stu-id="1c97f-121">IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.</span></span>  
  
## <a name="optimizing-performance-in-middle-tier-scenarios"></a><span data-ttu-id="1c97f-122">Orta Katman Senaryolarda Performansı Optimize Etme</span><span class="sxs-lookup"><span data-stu-id="1c97f-122">Optimizing Performance in Middle-Tier Scenarios</span></span>  
 <span data-ttu-id="1c97f-123">Gelen iletilere yanıt olarak diğer hizmetlere sesilen bir hizmet olan *orta katman senaryosunda*en iyi performans için, WCF hizmet istemcisini bir kez uzak hizmete anında iletin ve birden çok gelen istekarasında yeniden kullanın.</span><span class="sxs-lookup"><span data-stu-id="1c97f-123">For optimal performance in a *middle-tier scenario*—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests.</span></span> <span data-ttu-id="1c97f-124">WCF hizmet istemcilerini anında algılamak, önceden varolan bir istemci örneğinde bir hizmet çağrısı yapmaya göre pahalı bir işlemdir ve orta katman senaryoları istekler arasında uzak istemcileri önbelleğe alarak farklı performans kazançları üretir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-124">Instantiating WCF service clients is an expensive operation relative to making a service call on a pre-existing client instance, and middle-tier scenarios produce distinct performance gains by caching remote clients across requests.</span></span> <span data-ttu-id="1c97f-125">WCF hizmet istemcileri iş parçacığı için güvenlidir, bu nedenle birden çok iş parçacığı arasında bir istemciye erişimi eşitlemek gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-125">WCF service clients are thread-safe, so it is not necessary to synchronize access to a client across multiple threads.</span></span>  
  
 <span data-ttu-id="1c97f-126">Orta katman senaryoları da `svcutil /a` seçenek tarafından oluşturulan eşzamanlı API'ler kullanarak performans kazançları üretir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-126">Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the `svcutil /a` option.</span></span> <span data-ttu-id="1c97f-127">Bu `/a` seçenek, [ServiceModel Metadata Utility Tool'un (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) her hizmet işlemi için yöntemler oluşturmasına `BeginXXX/EndXXX` neden olur ve bu da uzak hizmetlere uzun süreli aramaların arka plan iş parçacıkları üzerinde yapılmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-127">The `/a` option causes the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate `BeginXXX/EndXXX` methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads.</span></span>  
  
## <a name="wcf-in-multi-homed-or-multi-named-scenarios"></a><span data-ttu-id="1c97f-128">Çok Homed veya Çok adlı senaryolarda WCF</span><span class="sxs-lookup"><span data-stu-id="1c97f-128">WCF in Multi-Homed or Multi-named scenarios</span></span>  
 <span data-ttu-id="1c97f-129">WCF hizmetlerini, bir bilgisayar kümesinin ortak bir dış adı paylaştığı `http://www.contoso.com`(örneğin) ancak farklı ana bilgisayar adlarıyla tek tek `http://www.contoso.com` ele alınan bir IIS `http://machine1.internal.contoso.com` Web çiftliğinin içinde dağıtabilirsiniz (örneğin, trafiği iki farklı makineye yönlendirebilir ve). `http://machine2.internal.contoso.com`</span><span class="sxs-lookup"><span data-stu-id="1c97f-129">You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as `http://www.contoso.com`) but are individually addressed by different hostnames (for example, `http://www.contoso.com` might direct traffic to two different machines named `http://machine1.internal.contoso.com` and `http://machine2.internal.contoso.com`).</span></span> <span data-ttu-id="1c97f-130">Bu dağıtım senaryosu tamamen WCF tarafından desteklenir, ancak hizmetin meta verilerinde (Web Hizmetleri Açıklama Dili) doğru (harici) ana bilgisayar adını görüntülemek için WCF hizmetlerini barındıran IIS Web sitesinin özel yapılandırmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-130">This deployment scenario is fully supported by WCF, but requires special configuration of the IIS Web site hosting WCF services to display the correct (external) hostname in the service's metadata (Web Services Description Language).</span></span>  
  
 <span data-ttu-id="1c97f-131">WCF'nin oluşturduğu hizmet meta verilerinde doğru ana bilgisayar adının görünmesini sağlamak için, WCF hizmetlerini barındıran IIS Web sitesinin varsayılan kimliğini açık bir ana bilgisayar adı kullanacak şekilde yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="1c97f-131">To ensure that the correct hostname appears in the service metadata WCF generates, configure the default identity for the IIS Web site that hosts WCF services to use an explicit hostname.</span></span> <span data-ttu-id="1c97f-132">Örneğin, çiftliğin `www.contoso.com` içinde ikamet eden bilgisayarlar HTTP için \*:80:www.contoso.com ve \*HTTPS için :443:www.contoso.com ciltleme iIS sitesi kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-132">For example, computers that reside inside of the `www.contoso.com` farm should use an IIS site binding of \*:80:www.contoso.com for HTTP and \*:443:www.contoso.com for HTTPS.</span></span>  
  
 <span data-ttu-id="1c97f-133">IIS Microsoft Yönetim Konsolu (MMC) snap-in'i kullanarak IIS Web sitesi bağlamalarını yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c97f-133">You can configure IIS Web site bindings by using the IIS Microsoft Management Console (MMC) snap-in.</span></span>  
  
## <a name="application-pools-running-in-different-user-contexts-overwrite-assemblies-from-other-accounts-in-the-temporary-folder"></a><span data-ttu-id="1c97f-134">Farklı Kullanıcı Bağlamlarında Çalışan Uygulama Havuzları Geçici Klasördeki Diğer Hesaplardan Derlemeleri Üzerine Yazar</span><span class="sxs-lookup"><span data-stu-id="1c97f-134">Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder</span></span>  
 <span data-ttu-id="1c97f-135">Farklı kullanıcı bağlamlarında çalışan uygulama havuzlarının geçici ASP.NET dosyaları klasöründeki diğer hesaplardan derlemelerin üzerine yazamamasını sağlamak için, farklı uygulamalar için farklı kimlikler ve geçici klasörler kullanın.</span><span class="sxs-lookup"><span data-stu-id="1c97f-135">To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary ASP.NET files folder, use different identities and temporary folders for different applications.</span></span> <span data-ttu-id="1c97f-136">Örneğin, iki sanal uygulamanız varsa /Application1 ve / Application2, iki farklı kimlikle A ve B olmak üzere iki Uygulama havuzu oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c97f-136">For example, if you have two virtual applications /Application1 and / Application2, you can create two Application pools, A and B, with two different identities.</span></span> <span data-ttu-id="1c97f-137">Uygulama havuzu A bir kullanıcı kimliği (user1) altında çalışırken, B uygulama havuzu başka bir kullanıcı kimliği (user2) altında çalıştırılabilir ve /Application1'i B kullanmak için A ve /Application2'yi kullanacak şekilde yapılandırabilir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-137">Application pool A can run under one user identity (user1) while application pool B can run under another user identity (user2), and configure /Application1 to use A and /Application2 to use B.</span></span>  
  
 <span data-ttu-id="1c97f-138">Web.config'de, geçici klasörü> \< system.web/compilation/@tempFolder kullanarak yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c97f-138">In Web.config, you can configure the temporary folder using \<system.web/compilation/@tempFolder>.</span></span> <span data-ttu-id="1c97f-139">/Application1 için "c:\tempForUser1" ve uygulama2 için "c:\tempForUser2" olabilir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-139">For /Application1, it can be "c:\tempForUser1" and for application2 it can be "c:\tempForUser2".</span></span> <span data-ttu-id="1c97f-140">İki kimlik için bu klasörlere karşılık gelen yazma izni verir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-140">Grant corresponding write permission to these folders for the two identities.</span></span>  
  
 <span data-ttu-id="1c97f-141">Sonra user2 /application2 için kod oluşturma klasörünü değiştiremez (c:\tempForUser1 altında).</span><span class="sxs-lookup"><span data-stu-id="1c97f-141">Then user2 cannot change the code-generation folder for /application2 (under c:\tempForUser1).</span></span>  
  
## <a name="enabling-asynchronous-processing"></a><span data-ttu-id="1c97f-142">Eşzamanlı işlemeyi etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="1c97f-142">Enabling asynchronous processing</span></span>  
 <span data-ttu-id="1c97f-143">Varsayılan olarak, IIS 6.0 ve daha önce barındırılan bir WCF hizmetine gönderilen iletiler eşzamanlı bir şekilde işlenir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-143">By default messages sent to a WCF service hosted under IIS 6.0 and earlier are processed in a synchronous manner.</span></span> <span data-ttu-id="1c97f-144">ASP.NET wcf içine kendi iş parçacığı (ASP.NET alt iş parçacığı) aramaları ve WCF isteği işlemek için başka bir iş parçacığı kullanır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-144">ASP.NET calls into WCF on its own thread (the ASP.NET worker thread) and WCF uses another thread to process the request.</span></span> <span data-ttu-id="1c97f-145">WCF, işleme işlemini tamamlayana kadar ASP.NET alt iş parçacığına tutunrabilir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-145">WCF holds onto the ASP.NET worker thread until it completes its processing.</span></span> <span data-ttu-id="1c97f-146">Bu, isteklerin eşzamanlı olarak işlenmesine yol açar.</span><span class="sxs-lookup"><span data-stu-id="1c97f-146">This leads to synchronous processing of requests.</span></span> <span data-ttu-id="1c97f-147">İstekleri işleme, isteği işlemek için gereken iş parçacığı sayısını azalttığı için daha fazla ölçeklenebilirlik sağlar –WCF isteği işlerken ASP.NET iş parçacığına tutunmaz.</span><span class="sxs-lookup"><span data-stu-id="1c97f-147">Processing requests asynchronously enables greater scalability because it reduces the number of threads required to process a request –WCF does not hold on to the ASP.NET thread while processing the request.</span></span> <span data-ttu-id="1c97f-148">Sunucuyu *Hizmet Reddi* (DOS) saldırılarına açan gelen istekleri azaltmanın bir yolu olmadığından, IIS 6.0 çalıştıran makineler için eşsenkronize davranış kullanılması önerilmez.</span><span class="sxs-lookup"><span data-stu-id="1c97f-148">Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to *Denial Of Service* (DOS) attacks.</span></span> <span data-ttu-id="1c97f-149">IIS 7.0 ile başlayarak, eşzamanlı bir istek azaltma `[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`tanıtıldı: .</span><span class="sxs-lookup"><span data-stu-id="1c97f-149">Starting with IIS 7.0, a concurrent request throttle has been introduced: `[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`.</span></span> <span data-ttu-id="1c97f-150">Bu yeni gaz ile asynchronous işleme kullanmak güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-150">With this new throttle it is safe to use the asynchronous processing.</span></span>  <span data-ttu-id="1c97f-151">Varsayılan olarak IIS 7.0'da, eşzamanlı işleyici ve modül kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="1c97f-151">By default in IIS 7.0, the asynchronous handler and module are registered.</span></span> <span data-ttu-id="1c97f-152">Bu kapatılmışsa, uygulamanızın Web.config dosyasındaki isteklerin eşsenkronize olarak işlenmesini el ile etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="1c97f-152">If this has been turned off, you can manually enable asynchronous processing of requests in your application's Web.config file.</span></span> <span data-ttu-id="1c97f-153">Kullandığınız ayarlar ayarınıza `aspNetCompatibilityEnabled` bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="1c97f-153">The settings you use depend on your `aspNetCompatibilityEnabled` setting.</span></span> <span data-ttu-id="1c97f-154">`aspNetCompatibilityEnabled` Ayarladıysanız, aşağıdaki yapılandırma snippet'inde gösterildiği `System.ServiceModel.Activation.ServiceHttpModule` gibi yapılandırın. `false`</span><span class="sxs-lookup"><span data-stu-id="1c97f-154">If you have `aspNetCompatibilityEnabled` set to `false`, configure the `System.ServiceModel.Activation.ServiceHttpModule` as shown in the following configuration snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="false" />
  </system.serviceModel>  
  <system.webServer>  
    <modules>  
      <remove name="ServiceModel"/>  
      <add name="ServiceModel"
           preCondition="integratedMode,runtimeVersionv2.0"
           type="System.ServiceModel.Activation.ServiceHttpModule, System.ServiceModel,Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
    </system.webServer>  
```  
  
 <span data-ttu-id="1c97f-155">`aspNetCompatibilityEnabled` Eğer `true`ayarladıysanız, aşağıdaki config snippet gösterildiği `System.ServiceModel.Activation.ServiceHttpHandlerFactory` gibi yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="1c97f-155">If you have `aspNetCompatibilityEnabled` set to `true`, configure the `System.ServiceModel.Activation.ServiceHttpHandlerFactory` as shown in the following config snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="true" />
  </system.serviceModel>  
  <system.webServer>  
    <handlers>  
          <clear/>  
          <add name="TestAsyncHttpHandler"
               path="*.svc"
               verb="*"
               type="System.ServiceModel.Activation.ServiceHttpHandlerFactory, System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
               />  
    </handlers>
  </system.webServer>  
```  
  
## <a name="see-also"></a><span data-ttu-id="1c97f-156">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="1c97f-156">See also</span></span>

- [<span data-ttu-id="1c97f-157">Hizmet Barındırma Örnekleri</span><span class="sxs-lookup"><span data-stu-id="1c97f-157">Service Hosting Samples</span></span>](../samples/hosting.md)
- <span data-ttu-id="1c97f-158">[Windows Server App Kumaş Barındırma Özellikleri](https://docs.microsoft.com/previous-versions/appfabric/ee677189(v=azure.10))</span><span class="sxs-lookup"><span data-stu-id="1c97f-158">[Windows Server App Fabric Hosting Features](https://docs.microsoft.com/previous-versions/appfabric/ee677189(v=azure.10))</span></span>
