---
title: Normal İfade Seçenekleri
description: Büyük/küçük harfe duyarsız eşleştirme, çok satırlı mod ve sağdan sola mod gibi normal ifade seçeneklerini .NET 'te nasıl kullanacağınızı öğrenin.
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, options
- constructs, options
- .NET regular expressions, options
- inline option constructs
- options parameter
ms.assetid: c82dc689-7e82-4767-a18d-cd24ce5f05e9
ms.openlocfilehash: 5687d1e5a11e69cc9ecf2bd34067329cc52955d2
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/28/2020
ms.locfileid: "92889003"
---
# <a name="regular-expression-options"></a><span data-ttu-id="970a1-103">Normal İfade Seçenekleri</span><span class="sxs-lookup"><span data-stu-id="970a1-103">Regular Expression Options</span></span>

<span data-ttu-id="970a1-104">Varsayılan olarak, bir giriş dizesinin normal ifade deseninin herhangi bir sabit karakter ile karşılaştırılması büyük/küçük harfe duyarlıdır, bir normal ifade deseninin boşluk değeri değişmez boşluk karakterleri olarak yorumlanır ve normal bir ifadede yakalama grupları örtük olarak ve açıkça adlandırılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="970a1-104">By default, the comparison of an input string with any literal characters in a regular expression pattern is case sensitive, white space in a regular expression pattern is interpreted as literal white-space characters, and capturing groups in a regular expression are named implicitly as well as explicitly.</span></span> <span data-ttu-id="970a1-105">Normal ifade seçeneklerini belirterek, varsayılan normal ifade davranışının bu ve diğer birçok yönlerini değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="970a1-105">You can modify these and several other aspects of default regular expression behavior by specifying regular expression options.</span></span> <span data-ttu-id="970a1-106">Aşağıdaki tabloda listelenen bu seçenekler, normal ifade deseninin bir parçası olarak satır içi olarak dahil edilebilir veya bir <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> sınıf oluşturucusuna veya statik model eşleştirme yöntemine bir <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> numaralandırma değeri olarak sağlanabilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-106">These options, which are listed in the following table, can be included inline as part of the regular expression pattern, or they can be supplied to a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static pattern matching method as a <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumeration value.</span></span>

|<span data-ttu-id="970a1-107">RegexOptions üyesi</span><span class="sxs-lookup"><span data-stu-id="970a1-107">RegexOptions member</span></span>|<span data-ttu-id="970a1-108">Satır içi karakter</span><span class="sxs-lookup"><span data-stu-id="970a1-108">Inline character</span></span>|<span data-ttu-id="970a1-109">Etki</span><span class="sxs-lookup"><span data-stu-id="970a1-109">Effect</span></span>|
|-------------------------|----------------------|------------|
|<xref:System.Text.RegularExpressions.RegexOptions.None>|<span data-ttu-id="970a1-110">Kullanılamaz</span><span class="sxs-lookup"><span data-stu-id="970a1-110">Not available</span></span>|<span data-ttu-id="970a1-111">Varsayılan davranışı kullanın.</span><span class="sxs-lookup"><span data-stu-id="970a1-111">Use default behavior.</span></span> <span data-ttu-id="970a1-112">Daha fazla bilgi için bkz. [varsayılan seçenekler](#default-options).</span><span class="sxs-lookup"><span data-stu-id="970a1-112">For more information, see [Default Options](#default-options).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>|`i`|<span data-ttu-id="970a1-113">Büyük küçük harf duyarlı eşleme kullanın.</span><span class="sxs-lookup"><span data-stu-id="970a1-113">Use case-insensitive matching.</span></span> <span data-ttu-id="970a1-114">Daha fazla bilgi için bkz. [büyük/küçük harfe duyarsız eşleşme](#case-insensitive-matching).</span><span class="sxs-lookup"><span data-stu-id="970a1-114">For more information, see [Case-Insensitive Matching](#case-insensitive-matching).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Multiline>|`m`|<span data-ttu-id="970a1-115">Her satırın başlangıcını ve bitişini `^` `$` (giriş dizesinin başı ve sonu yerine) ve sonuna kadar çok satırlı modunu kullanın.</span><span class="sxs-lookup"><span data-stu-id="970a1-115">Use multiline mode, where `^` and `$` match the beginning and end of each line (instead of the beginning and end of the input string).</span></span> <span data-ttu-id="970a1-116">Daha fazla bilgi için bkz. [çok satırlı mod](#multiline-mode).</span><span class="sxs-lookup"><span data-stu-id="970a1-116">For more information, see [Multiline Mode](#multiline-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Singleline>|`s`|<span data-ttu-id="970a1-117">Tek satır modunu kullanın; burada nokta (.) her karakterle eşleşir (hariç her karakter yerine `\n` ).</span><span class="sxs-lookup"><span data-stu-id="970a1-117">Use single-line mode, where the period (.) matches every character (instead of every character except `\n`).</span></span> <span data-ttu-id="970a1-118">Daha fazla bilgi için bkz. [tek satırlık mod](#single-line-mode).</span><span class="sxs-lookup"><span data-stu-id="970a1-118">For more information, see [Single-line Mode](#single-line-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture>|`n`|<span data-ttu-id="970a1-119">Adsız grupları yakalamayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-119">Do not capture unnamed groups.</span></span> <span data-ttu-id="970a1-120">Yalnızca geçerli yakalamalar, form adı alt ifadesinin açıkça adlandırılmış veya numaralandırılmış gruplarıdır `(?<` *name* `>` *subexpression* `)` .</span><span class="sxs-lookup"><span data-stu-id="970a1-120">The only valid captures are explicitly named or numbered groups of the form `(?<`*name*`>` *subexpression*`)`.</span></span> <span data-ttu-id="970a1-121">Daha fazla bilgi için [yalnızca açık yakalamalar](#explicit-captures-only)bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="970a1-121">For more information, see [Explicit Captures Only](#explicit-captures-only).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.Compiled>|<span data-ttu-id="970a1-122">Kullanılamaz</span><span class="sxs-lookup"><span data-stu-id="970a1-122">Not available</span></span>|<span data-ttu-id="970a1-123">Normal ifadeyi bir derleme için derleyin.</span><span class="sxs-lookup"><span data-stu-id="970a1-123">Compile the regular expression to an assembly.</span></span> <span data-ttu-id="970a1-124">Daha fazla bilgi için bkz. [derlenmiş normal ifadeler](#compiled-regular-expressions).</span><span class="sxs-lookup"><span data-stu-id="970a1-124">For more information, see [Compiled Regular Expressions](#compiled-regular-expressions).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace>|`x`|<span data-ttu-id="970a1-125">Kaçışsız boşluğu düzeninden hariç tutun ve bir sayı işaretinden () sonra açıklamaları etkinleştirin `#` .</span><span class="sxs-lookup"><span data-stu-id="970a1-125">Exclude unescaped white space from the pattern, and enable comments after a number sign (`#`).</span></span> <span data-ttu-id="970a1-126">Daha fazla bilgi için bkz. boşluğu [Yoksay](#ignore-white-space).</span><span class="sxs-lookup"><span data-stu-id="970a1-126">For more information, see [Ignore White Space](#ignore-white-space).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.RightToLeft>|<span data-ttu-id="970a1-127">Kullanılamaz</span><span class="sxs-lookup"><span data-stu-id="970a1-127">Not available</span></span>|<span data-ttu-id="970a1-128">Arama yönünü değiştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-128">Change the search direction.</span></span> <span data-ttu-id="970a1-129">Arama, soldan sağa yerine sağdan sola gider.</span><span class="sxs-lookup"><span data-stu-id="970a1-129">Search moves from right to left instead of from left to right.</span></span> <span data-ttu-id="970a1-130">Daha fazla bilgi için bkz. [sağdan sola mod](#right-to-left-mode).</span><span class="sxs-lookup"><span data-stu-id="970a1-130">For more information, see [Right-to-Left Mode](#right-to-left-mode).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.ECMAScript>|<span data-ttu-id="970a1-131">Kullanılamaz</span><span class="sxs-lookup"><span data-stu-id="970a1-131">Not available</span></span>|<span data-ttu-id="970a1-132">İfade için ECMAScript uyumlu davranışı etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-132">Enable ECMAScript-compliant behavior for the expression.</span></span> <span data-ttu-id="970a1-133">Daha fazla bilgi için bkz. [ECMAScript eşleştirme davranışı](#ecmascript-matching-behavior).</span><span class="sxs-lookup"><span data-stu-id="970a1-133">For more information, see [ECMAScript Matching Behavior](#ecmascript-matching-behavior).</span></span>|
|<xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant>|<span data-ttu-id="970a1-134">Kullanılamaz</span><span class="sxs-lookup"><span data-stu-id="970a1-134">Not available</span></span>|<span data-ttu-id="970a1-135">Dildeki kültürel farklarını yoksayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-135">Ignore cultural differences in language.</span></span> <span data-ttu-id="970a1-136">Daha fazla bilgi için bkz. [sabit kültür kullanılarak karşılaştırma](#comparison-using-the-invariant-culture).</span><span class="sxs-lookup"><span data-stu-id="970a1-136">For more information, see [Comparison Using the Invariant Culture](#comparison-using-the-invariant-culture).</span></span>|

## <a name="specifying-the-options"></a><span data-ttu-id="970a1-137">Seçenekleri belirtme</span><span class="sxs-lookup"><span data-stu-id="970a1-137">Specifying the Options</span></span>

<span data-ttu-id="970a1-138">Normal ifadeler için seçenekleri üç şekilde belirtebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="970a1-138">You can specify options for regular expressions in one of three ways:</span></span>

- <span data-ttu-id="970a1-139">`options`Bir sınıf oluşturucusunun parametresinde veya bir <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> statik ( `Shared` Visual Basic), veya gibi bir model eşleme yöntemi <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-139">In the `options` parameter of a <xref:System.Text.RegularExpressions.Regex?displayProperty=nameWithType> class constructor or static (`Shared` in Visual Basic) pattern-matching method, such as <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%29> or <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="970a1-140">`options`Parametresi, numaralandırılmış değerlerin bit SEVIYESINDE veya birleşimidir <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-140">The `options` parameter is a bitwise OR combination of <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> enumerated values.</span></span>

  <span data-ttu-id="970a1-141">Bir <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusunun parametresi kullanılarak bir örneğe seçenekler sağlandığında `options` , Seçenekler <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> özelliğine atanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-141">When options are supplied to a <xref:System.Text.RegularExpressions.Regex> instance by using the `options` parameter of a class constructor, the options are assigned to the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="970a1-142">Ancak, <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> özelliği normal ifade deseninin kendi satır içi seçeneklerini yansıtmaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-142">However, the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property does not reflect inline options in the regular expression pattern itself.</span></span>

  <span data-ttu-id="970a1-143">Aşağıdaki örnek, bir gösterim sağlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-143">The following example provides an illustration.</span></span> <span data-ttu-id="970a1-144">`options` <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Büyük/küçük harfe duyarsız eşleştirmeyi etkinleştirmek için yönteminin parametresini kullanır ve "d" harfiyle başlayan sözcükleri tanımlarken kalıp uzayını yok saymaya dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="970a1-144">It uses the `options` parameter of the <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#6)]
  [!code-vb[Conceptual.Regex.Language.Options#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#6)]

- <span data-ttu-id="970a1-145">Bir normal ifade deseninin sözdizimi ile satır içi seçenekler uygulayarak `(?imnsx-imnsx)` .</span><span class="sxs-lookup"><span data-stu-id="970a1-145">By applying inline options in a regular expression pattern with the syntax `(?imnsx-imnsx)`.</span></span> <span data-ttu-id="970a1-146">Seçeneği, seçeneğinin düzenin sonuna kadar veya başka bir satır içi seçenek tarafından tanımsız olan nokta için geçerli olan nokta için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="970a1-146">The option applies to the pattern from the point that the option is defined to either the end of the pattern or to the point at which the option is undefined by another inline option.</span></span> <span data-ttu-id="970a1-147"><xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex> Örneğin özelliğinin bu satır içi seçenekleri yansıtmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-147">Note that the <xref:System.Text.RegularExpressions.RegexOptions?displayProperty=nameWithType> property of a <xref:System.Text.RegularExpressions.Regex> instance does not reflect these inline options.</span></span> <span data-ttu-id="970a1-148">Daha fazla bilgi için bkz. [çeşitli yapılar](miscellaneous-constructs-in-regular-expressions.md) konusu.</span><span class="sxs-lookup"><span data-stu-id="970a1-148">For more information, see the [Miscellaneous Constructs](miscellaneous-constructs-in-regular-expressions.md) topic.</span></span>

  <span data-ttu-id="970a1-149">Aşağıdaki örnek, bir gösterim sağlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-149">The following example provides an illustration.</span></span> <span data-ttu-id="970a1-150">Büyük/küçük harfe duyarsız eşleştirmeyi etkinleştirmek ve "d" harfiyle başlayan sözcükleri tanımlarken kalıp boşluk yoksaymak için satır içi seçenekleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-150">It uses inline options to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#7)]
  [!code-vb[Conceptual.Regex.Language.Options#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#7)]

- <span data-ttu-id="970a1-151">Belirli bir gruplama yapısına, sözdizimi alt ifadesi ile bir normal ifade düzeninde satır içi seçenekler uygulayarak `(?imnsx-imnsx:` *subexpression* `)` .</span><span class="sxs-lookup"><span data-stu-id="970a1-151">By applying inline options in a particular grouping construct in a regular expression pattern with the syntax `(?imnsx-imnsx:`*subexpression*`)`.</span></span> <span data-ttu-id="970a1-152">Bir seçenek kümesinden önce hiçbir işaret, kümeyi açmadan önce hiçbir işaret yoktur; bir seçenek kümesinden önceki bir eksi işareti, kümeyi devre dışı bırakır.</span><span class="sxs-lookup"><span data-stu-id="970a1-152">No sign before a set of options turns the set on; a minus sign before a set of options turns the set off.</span></span> <span data-ttu-id="970a1-153">( `?` seçeneklerin etkin veya devre dışı bırakılmış olması gereken dil yapısı sözdiziminin sabit bir parçasıdır.) Seçeneği yalnızca bu grup için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="970a1-153">(`?` is a fixed part of the language construct's syntax that is required whether options are enabled or disabled.) The option applies only to that group.</span></span> <span data-ttu-id="970a1-154">Daha fazla bilgi için bkz. [yapıları gruplandırma](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="970a1-154">For more information, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

  <span data-ttu-id="970a1-155">Aşağıdaki örnek, bir gösterim sağlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-155">The following example provides an illustration.</span></span> <span data-ttu-id="970a1-156">Büyük/küçük harfe duyarsız eşleştirmeyi etkinleştirmek ve "d" harfiyle başlayan sözcükleri tanımlarken kalıp boşluk yoksaymak için bir gruplama yapısında satır içi seçenekleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-156">It uses inline options in a grouping construct to enable case-insensitive matching and to ignore pattern white space when identifying words that begin with the letter "d".</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/example1.cs#8)]
  [!code-vb[Conceptual.Regex.Language.Options#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/example1.vb#8)]

<span data-ttu-id="970a1-157">Seçenekler satır içi belirtilirse, `-` bir seçenek veya seçenek kümesinden önce bir eksi işareti (), bu seçenekleri devre dışı bırakır.</span><span class="sxs-lookup"><span data-stu-id="970a1-157">If options are specified inline, a minus sign (`-`) before an option or set of options turns off those options.</span></span> <span data-ttu-id="970a1-158">Örneğin, satır içi yapı `(?ix-ms)` ve seçeneklerini etkinleştirir ve <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> ve seçeneklerini devre dışı bırakır <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-158">For example, the inline construct `(?ix-ms)` turns on the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> options and turns off the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="970a1-159">Tüm normal ifade seçenekleri varsayılan olarak kapalıdır.</span><span class="sxs-lookup"><span data-stu-id="970a1-159">All regular expression options are turned off by default.</span></span>

> [!NOTE]
> <span data-ttu-id="970a1-160">`options`Bir oluşturucunun veya yöntem çağrısının parametresinde belirtilen normal ifade seçenekleri bir normal ifade düzeninde satır içi belirtilen seçeneklerle çakışırsa, satır içi seçenekler kullanılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-160">If the regular expression options specified in the `options` parameter of a constructor or method call conflict with the options specified inline in a regular expression pattern, the inline options are used.</span></span>

<span data-ttu-id="970a1-161">Aşağıdaki beş normal ifade seçeneği, hem Options parametresiyle hem de satır içi olarak ayarlanabilir:</span><span class="sxs-lookup"><span data-stu-id="970a1-161">The following five regular expression options can be set both with the options parameter and inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>

<span data-ttu-id="970a1-162">Aşağıdaki beş normal ifade seçeneği parametresi kullanılarak ayarlanabilir, `options` ancak satır içi ayarlanamaz:</span><span class="sxs-lookup"><span data-stu-id="970a1-162">The following five regular expression options can be set using the `options` parameter but cannot be set inline:</span></span>

- <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>

- <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>

## <a name="determining-the-options"></a><span data-ttu-id="970a1-163">Seçenekleri belirleme</span><span class="sxs-lookup"><span data-stu-id="970a1-163">Determining the Options</span></span>

<span data-ttu-id="970a1-164"><xref:System.Text.RegularExpressions.Regex>Salt okunurdur özelliğinin değeri alınırken, bir nesneye hangi seçeneklerin sağlandığını belirleyebilirsiniz <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-164">You can determine which options were provided to a <xref:System.Text.RegularExpressions.Regex> object when it was instantiated by retrieving the value of the read-only <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="970a1-165">Bu özellik özellikle yöntemi tarafından oluşturulan derlenmiş bir normal ifade için tanımlanan seçenekleri belirlemek için yararlıdır <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-165">This property is particularly useful for determining the options that are defined for a compiled regular expression created by the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="970a1-166">Dışında herhangi bir seçeneğin varlığını test etmek için <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> , <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> özelliğinin değeri ve ilgilendiğiniz değer Ile bir ve işlemi gerçekleştirin <xref:System.Text.RegularExpressions.RegexOptions> .</span><span class="sxs-lookup"><span data-stu-id="970a1-166">To test for the presence of any option except <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, perform an AND operation with the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property and the <xref:System.Text.RegularExpressions.RegexOptions> value in which you are interested.</span></span> <span data-ttu-id="970a1-167">Sonra sonucun bu değere eşit olup olmadığını test edin <xref:System.Text.RegularExpressions.RegexOptions> .</span><span class="sxs-lookup"><span data-stu-id="970a1-167">Then test whether the result equals that <xref:System.Text.RegularExpressions.RegexOptions> value.</span></span> <span data-ttu-id="970a1-168">Aşağıdaki örnek, seçeneğinin ayarlanmış olup olmadığını sınar <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-168">The following example tests whether the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option has been set.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#19](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#19)]
[!code-vb[Conceptual.Regex.Language.Options#19](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#19)]

<span data-ttu-id="970a1-169">Test etmek için, <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> Aşağıdaki örnekte gösterildiği gibi, özelliğin değerinin değerine eşit olup olmadığını saptayın <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-169">To test for <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, determine whether the value of the <xref:System.Text.RegularExpressions.Regex.Options%2A?displayProperty=nameWithType> property is equal to <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>, as the following example illustrates.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#20](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/determine1.cs#20)]
[!code-vb[Conceptual.Regex.Language.Options#20](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/determine1.vb#20)]

<span data-ttu-id="970a1-170">Aşağıdaki bölümlerde, .NET içindeki normal ifade tarafından desteklenen seçenekler listelenmektedir.</span><span class="sxs-lookup"><span data-stu-id="970a1-170">The following sections list the options supported by regular expression in .NET.</span></span>

## <a name="default-options"></a><span data-ttu-id="970a1-171">Varsayılan Seçenekler</span><span class="sxs-lookup"><span data-stu-id="970a1-171">Default Options</span></span>

<span data-ttu-id="970a1-172"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>Seçeneği hiçbir seçeneğin belirtilmediğini ve normal ifade altyapısının varsayılan davranışını kullandığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="970a1-172">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option indicates that no options have been specified, and the regular expression engine uses its default behavior.</span></span> <span data-ttu-id="970a1-173">Bu, aşağıdakileri içerir:</span><span class="sxs-lookup"><span data-stu-id="970a1-173">This includes the following:</span></span>

- <span data-ttu-id="970a1-174">Desenler, ECMAScript normal ifadesi yerine kurallı olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-174">The pattern is interpreted as a canonical rather than an ECMAScript regular expression.</span></span>

- <span data-ttu-id="970a1-175">Normal ifade deseninin giriş dizesinde soldan sağa eşleşmesi vardır.</span><span class="sxs-lookup"><span data-stu-id="970a1-175">The regular expression pattern is matched in the input string from left to right.</span></span>

- <span data-ttu-id="970a1-176">Karşılaştırmalar büyük/küçük harfe duyarlıdır.</span><span class="sxs-lookup"><span data-stu-id="970a1-176">Comparisons are case-sensitive.</span></span>

- <span data-ttu-id="970a1-177">`^`Ve `$` Language öğeleri giriş dizesinin başlangıcı ve sonu ile eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-177">The `^` and `$` language elements match the beginning and end of the input string.</span></span>

- <span data-ttu-id="970a1-178">`.`Language öğesi, hariç her karakterle eşleşir `\n` .</span><span class="sxs-lookup"><span data-stu-id="970a1-178">The `.` language element matches every character except `\n`.</span></span>

- <span data-ttu-id="970a1-179">Normal ifade düzenindeki herhangi bir boşluk, sabit bir boşluk karakteri olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-179">Any white space in a regular expression pattern is interpreted as a literal space character.</span></span>

- <span data-ttu-id="970a1-180">Geçerli kültürün kuralları, model giriş dizesiyle karşılaştırılırken kullanılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-180">The conventions of the current culture are used when comparing the pattern to the input string.</span></span>

- <span data-ttu-id="970a1-181">Normal ifade düzeninde yakalama grupları örtük ve açık olarak açıktır.</span><span class="sxs-lookup"><span data-stu-id="970a1-181">Capturing groups in the regular expression pattern are implicit as well as explicit.</span></span>

> [!NOTE]
> <span data-ttu-id="970a1-182"><xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType>Seçeneğin satır içi eşdeğeri yoktur.</span><span class="sxs-lookup"><span data-stu-id="970a1-182">The <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option has no inline equivalent.</span></span> <span data-ttu-id="970a1-183">Normal ifade seçenekleri satır içi uygulandığında, özel bir seçenek devre dışı bırakarak varsayılan davranış bir seçenek temelinde geri yüklenir.</span><span class="sxs-lookup"><span data-stu-id="970a1-183">When regular expression options are applied inline, the default behavior is restored on an option-by-option basis, by turning a particular option off.</span></span> <span data-ttu-id="970a1-184">Örneğin, `(?i)` büyük/küçük harfe duyarsız karşılaştırmayı açar ve `(?-i)` varsayılan büyük/küçük harfe duyarlı karşılaştırmayı geri yükler.</span><span class="sxs-lookup"><span data-stu-id="970a1-184">For example, `(?i)` turns on case-insensitive comparison, and `(?-i)` restores the default case-sensitive comparison.</span></span>

<span data-ttu-id="970a1-185">Seçeneği, <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> normal ifade altyapısının varsayılan davranışını temsil ettiğinden, yöntem çağrısında nadiren açıkça belirtilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-185">Because the <xref:System.Text.RegularExpressions.RegexOptions.None?displayProperty=nameWithType> option represents the default behavior of the regular expression engine, it is rarely explicitly specified in a method call.</span></span> <span data-ttu-id="970a1-186">Yerine parametresi olmayan bir Oluşturucu veya statik bir model eşleştirme yöntemi `options` çağırılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-186">A constructor or static pattern-matching method without an `options` parameter is called instead.</span></span>

## <a name="case-insensitive-matching"></a><span data-ttu-id="970a1-187">Case-Insensitive eşleşen</span><span class="sxs-lookup"><span data-stu-id="970a1-187">Case-Insensitive Matching</span></span>

<span data-ttu-id="970a1-188"><xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>Seçeneği veya `i` satır içi seçeneği, büyük/küçük harfe duyarsız eşleşme sağlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-188">The <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> option, or the `i` inline option, provides case-insensitive matching.</span></span> <span data-ttu-id="970a1-189">Varsayılan olarak, geçerli kültürün büyük/küçük harf kuralları kullanılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-189">By default, the casing conventions of the current culture are used.</span></span>

<span data-ttu-id="970a1-190">Aşağıdaki örnek, `\bthe\w*\b` "The" ile başlayan tüm sözcüklerle eşleşen bir normal ifade deseninin tanımlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-190">The following example defines a regular expression pattern, `\bthe\w*\b`, that matches all words starting with "the".</span></span> <span data-ttu-id="970a1-191">Yönteme ilk çağrı <xref:System.Text.RegularExpressions.Regex.Match%2A> varsayılan büyük/küçük harfe duyarlı karşılaştırmayı kullandığından, çıkış, tümceyi Başlatan "The" dizesinin eşleştirilmediğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="970a1-191">Because the first call to the <xref:System.Text.RegularExpressions.Regex.Match%2A> method uses the default case-sensitive comparison, the output indicates that the string "The" that begins the sentence is not matched.</span></span> <span data-ttu-id="970a1-192"><xref:System.Text.RegularExpressions.Regex.Match%2A>Yöntemi, olarak ayarlanan seçenekler ile çağrıldığında eşleşir <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase> .</span><span class="sxs-lookup"><span data-stu-id="970a1-192">It is matched when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with options set to <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase>.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case1.cs#1)]
[!code-vb[Conceptual.Regex.Language.Options#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case1.vb#1)]

<span data-ttu-id="970a1-193">Aşağıdaki örnek, önceki örnekteki normal ifade deseninin, `options` büyük/küçük harfe duyarsız karşılaştırma sağlamak için parametresi yerine satır içi seçenekler kullanması için değiştirir.</span><span class="sxs-lookup"><span data-stu-id="970a1-193">The following example modifies the regular expression pattern from the previous example to use inline options instead of the `options` parameter to provide case-insensitive comparison.</span></span> <span data-ttu-id="970a1-194">İlk model, yalnızca "The" dizesinde "t" harfine uygulanan bir gruplama yapısında büyük/küçük harf duyarsız seçeneğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-194">The first pattern defines the case-insensitive option in a grouping construct that applies only to the letter "t" in the string "the".</span></span> <span data-ttu-id="970a1-195">Seçenek yapısı deseninin başlangıcında gerçekleştiğinden, ikinci model büyük/küçük harf duyarsız seçeneğini normal ifadeye uygular.</span><span class="sxs-lookup"><span data-stu-id="970a1-195">Because the option construct occurs at the beginning of the pattern, the second pattern applies the case-insensitive option to the entire regular expression.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/case2.cs#2)]
[!code-vb[Conceptual.Regex.Language.Options#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/case2.vb#2)]

## <a name="multiline-mode"></a><span data-ttu-id="970a1-196">Çok satırlı mod</span><span class="sxs-lookup"><span data-stu-id="970a1-196">Multiline Mode</span></span>

<span data-ttu-id="970a1-197"><xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>Seçeneği veya `m` satır içi seçeneği, normal ifade altyapısının birden çok satırdan oluşan bir giriş dizesini işlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-197">The <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, or the `m` inline option, enables the regular expression engine to handle an input string that consists of multiple lines.</span></span> <span data-ttu-id="970a1-198">`^`Ve `$` dili öğelerinin yorumu, giriş dizesinin başı ve sonu yerine bir satırın başlangıcıyla ve sonuyla eşleşecek şekilde değişir.</span><span class="sxs-lookup"><span data-stu-id="970a1-198">It changes the interpretation of the `^` and `$` language elements so that they match the beginning and end of a line, instead of the beginning and end of the input string.</span></span>

<span data-ttu-id="970a1-199">Varsayılan olarak, `$` yalnızca giriş dizesinin sonu ile eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-199">By default, `$` matches only the end of the input string.</span></span> <span data-ttu-id="970a1-200"><xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>Seçeneğini belirtirseniz, bu, yeni satır karakteriyle ( `\n` ) veya giriş dizesinin sonuyla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-200">If you specify the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, it matches either the newline character (`\n`) or the end of the input string.</span></span> <span data-ttu-id="970a1-201">Ancak, satır başı/satır besleme karakteri bileşimiyle eşleşmez.</span><span class="sxs-lookup"><span data-stu-id="970a1-201">It does not, however, match the carriage return/line feed character combination.</span></span> <span data-ttu-id="970a1-202">Bunları başarıyla eşleştirmek için, yalnızca yerine alt ifadeyi kullanın `\r?$` `$` .</span><span class="sxs-lookup"><span data-stu-id="970a1-202">To successfully match them, use the subexpression `\r?$` instead of just `$`.</span></span>

<span data-ttu-id="970a1-203">Aşağıdaki örnek Bowler adlarını ve puanlarını ayıklar ve bunları <xref:System.Collections.Generic.SortedList%602> azalan sırada sıralayan bir koleksiyona ekler.</span><span class="sxs-lookup"><span data-stu-id="970a1-203">The following example extracts bowlers' names and scores and adds them to a <xref:System.Collections.Generic.SortedList%602> collection that sorts them in descending order.</span></span> <span data-ttu-id="970a1-204"><xref:System.Text.RegularExpressions.Regex.Matches%2A>Yöntemi iki kez çağrılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-204">The <xref:System.Text.RegularExpressions.Regex.Matches%2A> method is called twice.</span></span> <span data-ttu-id="970a1-205">İlk yöntem çağrısında, normal ifade değildir `^(\w+)\s(\d+)$` ve hiçbir seçenek ayarlanmadı.</span><span class="sxs-lookup"><span data-stu-id="970a1-205">In the first method call, the regular expression is `^(\w+)\s(\d+)$` and no options are set.</span></span> <span data-ttu-id="970a1-206">Çıktının gösterdiği gibi, normal ifade altyapısı giriş deseninin yanı sıra giriş dizesinin başlangıcı ve sonuyla eşleşeceğinden, hiçbir eşleşme bulunamamıştır.</span><span class="sxs-lookup"><span data-stu-id="970a1-206">As the output shows, because the regular expression engine cannot match the input pattern along with the beginning and end of the input string, no matches are found.</span></span> <span data-ttu-id="970a1-207">İkinci yöntem çağrısında, normal ifade olarak değiştirilir `^(\w+)\s(\d+)\r?$` ve seçenekler olarak ayarlanır <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-207">In the second method call, the regular expression is changed to `^(\w+)\s(\d+)\r?$` and the options are set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>.</span></span> <span data-ttu-id="970a1-208">Çıktıda gösterildiği gibi, adlar ve puanlar başarıyla eşleştirilir ve puanlar azalan sırada görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="970a1-208">As the output shows, the names and scores are successfully matched, and the scores are displayed in descending order.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline1.cs#3)]
[!code-vb[Conceptual.Regex.Language.Options#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline1.vb#3)]

<span data-ttu-id="970a1-209">Normal ifade deseninin, `^(\w+)\s(\d+)\r*$` Aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="970a1-209">The regular expression pattern `^(\w+)\s(\d+)\r*$` is defined as shown in the following table.</span></span>

|<span data-ttu-id="970a1-210">Desen</span><span class="sxs-lookup"><span data-stu-id="970a1-210">Pattern</span></span>|<span data-ttu-id="970a1-211">Açıklama</span><span class="sxs-lookup"><span data-stu-id="970a1-211">Description</span></span>|
|-------------|-----------------|
|`^`|<span data-ttu-id="970a1-212">Satırın başlangıcında başlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-212">Begin at the start of the line.</span></span>|
|`(\w+)`|<span data-ttu-id="970a1-213">Bir veya daha fazla sözcük karakteri eşleştir.</span><span class="sxs-lookup"><span data-stu-id="970a1-213">Match one or more word characters.</span></span> <span data-ttu-id="970a1-214">Bu ilk yakalama grubudur.</span><span class="sxs-lookup"><span data-stu-id="970a1-214">This is the first capturing group.</span></span>|
|`\s`|<span data-ttu-id="970a1-215">Bir boşluk karakteri ile eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-215">Match a white-space character.</span></span>|
|`(\d+)`|<span data-ttu-id="970a1-216">Bir veya daha fazla ondalık basamağı eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-216">Match one or more decimal digits.</span></span> <span data-ttu-id="970a1-217">Bu ikinci yakalama grubudur.</span><span class="sxs-lookup"><span data-stu-id="970a1-217">This is the second capturing group.</span></span>|
|`\r?`|<span data-ttu-id="970a1-218">Sıfır veya bir satır başı karakteri eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-218">Match zero or one carriage return character.</span></span>|
|`$`|<span data-ttu-id="970a1-219">Satırın sonunda biter.</span><span class="sxs-lookup"><span data-stu-id="970a1-219">End at the end of the line.</span></span>|

<span data-ttu-id="970a1-220">Aşağıdaki örnek, tek `(?m)` satırlı seçeneğini ayarlamak için satır içi seçeneğini kullanması dışında, öncekiyle eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="970a1-220">The following example is equivalent to the previous one, except that it uses the inline option `(?m)` to set the multiline option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/multiline2.cs#4)]
[!code-vb[Conceptual.Regex.Language.Options#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/multiline2.vb#4)]

## <a name="single-line-mode"></a><span data-ttu-id="970a1-221">Tek satırlık mod</span><span class="sxs-lookup"><span data-stu-id="970a1-221">Single-line Mode</span></span>

<span data-ttu-id="970a1-222"><xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>Seçeneği veya `s` satır içi seçeneği, normal ifade altyapısının giriş dizesini tek bir satırdan oluşan gibi işleme almasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="970a1-222">The <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option, or the `s` inline option, causes the regular expression engine to treat the input string as if it consists of a single line.</span></span> <span data-ttu-id="970a1-223">Bu, nokta ( `.` ) dil öğesinin davranışını, yeni satır karakteri `\n` veya \u000ahariç her karakteri eşleştirmek yerine her karakterle eşleşecek şekilde değiştirerek yapar.</span><span class="sxs-lookup"><span data-stu-id="970a1-223">It does this by changing the behavior of the period (`.`) language element so that it matches every character, instead of matching every character except for the newline character `\n` or \u000A.</span></span>

<span data-ttu-id="970a1-224">Aşağıdaki örnek, `.` seçeneğini kullandığınızda Language öğesi davranışının nasıl değiştiği gösterilmektedir <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-224">The following example illustrates how the behavior of the `.` language element changes when you use the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="970a1-225">Normal ifade `^.+` dizenin başlangıcında başlar ve her karakterle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-225">The regular expression `^.+` starts at the beginning of the string and matches every character.</span></span> <span data-ttu-id="970a1-226">Varsayılan olarak eşleştirme, ilk satırın sonunda biter; normal ifade deseninin satır dönüş karakteriyle `\r` veya \u000D ile eşleşmesi, ancak eşleşmez `\n` .</span><span class="sxs-lookup"><span data-stu-id="970a1-226">By default, the match ends at the end of the first line; the regular expression pattern matches the carriage return character, `\r` or \u000D, but it does not match `\n`.</span></span> <span data-ttu-id="970a1-227"><xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType>Seçeneği giriş dizesinin tamamını tek bir satır olarak yorumladığından, dahil olmak üzere giriş dizesindeki her karakterle eşleşir `\n` .</span><span class="sxs-lookup"><span data-stu-id="970a1-227">Because the <xref:System.Text.RegularExpressions.RegexOptions.Singleline?displayProperty=nameWithType> option interprets the entire input string as a single line, it matches every character in the input string, including `\n`.</span></span>

[!code-csharp[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.characterclasses/cs/any2.cs#5)]
[!code-vb[Conceptual.Regex.Language.CharacterClasses#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.characterclasses/vb/any2.vb#5)]

<span data-ttu-id="970a1-228">Aşağıdaki örnek, `(?s)` tek satır modunu etkinleştirmek için satır içi seçeneğini kullanması dışında, önceki bir ile eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="970a1-228">The following example is equivalent to the previous one, except that it uses the inline option `(?s)` to enable single-line mode.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/singleline1.cs#5)]
[!code-vb[Conceptual.Regex.Language.Options#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/singleline1.vb#5)]

## <a name="explicit-captures-only"></a><span data-ttu-id="970a1-229">Yalnızca açık yakalamalar</span><span class="sxs-lookup"><span data-stu-id="970a1-229">Explicit Captures Only</span></span>

<span data-ttu-id="970a1-230">Varsayılan olarak, yakalama grupları, normal ifade deseninin parantez kullanılarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-230">By default, capturing groups are defined by the use of parentheses in the regular expression pattern.</span></span> <span data-ttu-id="970a1-231">Adlandırılmış gruplara ad alt ifade dili seçeneği tarafından ad veya sayı atanır `(?<` *name* `>` *subexpression* `)` , ancak adlandırılmamış gruplar dizin tarafından erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-231">Named groups are assigned a name or number by the `(?<`*name*`>`*subexpression*`)` language option, whereas unnamed groups are accessible by index.</span></span> <span data-ttu-id="970a1-232"><xref:System.Text.RegularExpressions.GroupCollection>Nesnede, adlandırılmamış gruplar adlandırılmış gruplardan önce gelmeli.</span><span class="sxs-lookup"><span data-stu-id="970a1-232">In the <xref:System.Text.RegularExpressions.GroupCollection> object, unnamed groups precede named groups.</span></span>

<span data-ttu-id="970a1-233">Gruplandırma yapıları genellikle yalnızca birden çok dil öğesine nicelik belirteçleri uygulamak için kullanılır ve yakalanan alt dizeler hiçbir ilgi değildir.</span><span class="sxs-lookup"><span data-stu-id="970a1-233">Grouping constructs are often used only to apply quantifiers to multiple language elements, and the captured substrings are of no interest.</span></span> <span data-ttu-id="970a1-234">Örneğin, aşağıdaki normal ifade varsa:</span><span class="sxs-lookup"><span data-stu-id="970a1-234">For example, if the following regular expression:</span></span>

`\b\(?((\w+),?\s?)+[\.!?]\)?`

<span data-ttu-id="970a1-235">yalnızca bir nokta, ünlem işareti veya soru işaretiyle biten cümleleri bir belgeden ayıklamaya yöneliktir, yalnızca elde edilen cümle (nesne tarafından temsil edilir <xref:System.Text.RegularExpressions.Match> ) ilgilenir.</span><span class="sxs-lookup"><span data-stu-id="970a1-235">is intended only to extract sentences that end with a period, exclamation point, or question mark from a document, only the resulting sentence (which is represented by the <xref:System.Text.RegularExpressions.Match> object) is of interest.</span></span> <span data-ttu-id="970a1-236">Koleksiyondaki tek sözcükler değildir.</span><span class="sxs-lookup"><span data-stu-id="970a1-236">The individual words in the collection are not.</span></span>

<span data-ttu-id="970a1-237">Normal ifade altyapısının hem hem de koleksiyon nesnelerini doldurması gerektiğinden, daha sonra kullanılmayan grupları yakalama maliyetli olabilir <xref:System.Text.RegularExpressions.GroupCollection> <xref:System.Text.RegularExpressions.CaptureCollection> .</span><span class="sxs-lookup"><span data-stu-id="970a1-237">Capturing groups that are not subsequently used can be expensive, because the regular expression engine must populate both the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects.</span></span> <span data-ttu-id="970a1-238">Alternatif olarak, <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> `n` yalnızca geçerli yakalamalar açıkça adlandırılmış veya alt `(?<` *name* `>` *ifade* yapısı tarafından atanan numaralandırılmış grupları belirtmek için seçeneğini veya satır içi seçeneğini kullanabilirsiniz `)` .</span><span class="sxs-lookup"><span data-stu-id="970a1-238">As an alternative, you can use either the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option or the `n` inline option to specify that the only valid captures are explicitly named or numbered groups that are designated by the `(?<`*name*`>` *subexpression*`)` construct.</span></span>

<span data-ttu-id="970a1-239">Aşağıdaki örnek, `\b\(?((\w+),?\s?)+[\.!?]\)?` <xref:System.Text.RegularExpressions.Regex.Match%2A> yöntemi ile ve seçeneği olmadan çağrıldığında, normal ifade deseninin döndürdüğü eşleşmeler hakkındaki bilgileri görüntüler <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-239">The following example displays information about the matches returned by the `\b\(?((\w+),?\s?)+[\.!?]\)?` regular expression pattern when the <xref:System.Text.RegularExpressions.Regex.Match%2A> method is called with and without the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="970a1-240">İlk yöntem çağrısının çıktısı gösterdiği gibi, normal ifade altyapısı, <xref:System.Text.RegularExpressions.GroupCollection> ve <xref:System.Text.RegularExpressions.CaptureCollection> koleksiyon nesnelerini yakalanan alt dizeler hakkındaki bilgilerle tamamen doldurur.</span><span class="sxs-lookup"><span data-stu-id="970a1-240">As the output from the first method call shows, the regular expression engine fully populates the <xref:System.Text.RegularExpressions.GroupCollection> and <xref:System.Text.RegularExpressions.CaptureCollection> collection objects with information about captured substrings.</span></span> <span data-ttu-id="970a1-241">İkinci yöntem `options` olarak ayarlandığı ile çağrıldığı için <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> , gruplar üzerinde bilgi yakalamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-241">Because the second method is called with `options` set to <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType>, it does not capture information on groups.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit1.cs#9)]
[!code-vb[Conceptual.Regex.Language.Options#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit1.vb#9)]

<span data-ttu-id="970a1-242">Normal ifade deseninin, `\b\(?((?>\w+),?\s?)+[\.!?]\)?` Aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="970a1-242">The regular expression pattern`\b\(?((?>\w+),?\s?)+[\.!?]\)?` is defined as shown in the following table.</span></span>

|<span data-ttu-id="970a1-243">Desen</span><span class="sxs-lookup"><span data-stu-id="970a1-243">Pattern</span></span>|<span data-ttu-id="970a1-244">Açıklama</span><span class="sxs-lookup"><span data-stu-id="970a1-244">Description</span></span>|
|-------------|-----------------|
|`\b`|<span data-ttu-id="970a1-245">Bir sözcük sınırında başlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-245">Begin at a word boundary.</span></span>|
|`\(?`|<span data-ttu-id="970a1-246">Açma parantezinin ("(") sıfır veya bir tekrarından birini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-246">Match zero or one occurrences of the opening parenthesis ("(").</span></span>|
|`(?>\w+),?`|<span data-ttu-id="970a1-247">Bir veya daha fazla sözcük karakterini, ardından sıfır veya bir virgül ile eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-247">Match one or more word characters, followed by zero or one commas.</span></span> <span data-ttu-id="970a1-248">Sözcük karakterlerini eşleştirirken geri izlememeyin.</span><span class="sxs-lookup"><span data-stu-id="970a1-248">Do not backtrack when matching word characters.</span></span>|
|`\s?`|<span data-ttu-id="970a1-249">Sıfır veya bir beyaz boşluk karakterini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-249">Match zero or one white-space characters.</span></span>|
|`((\w+),?\s?)+`|<span data-ttu-id="970a1-250">Bir ya da daha fazla sözcük karakterinin, sıfır veya bir virgül, sıfır veya bir boşluk karakteri ile bir veya daha fazla kez birleşimini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-250">Match the combination of one or more word characters, zero or one commas, and zero or one white-space characters one or more times.</span></span>|
|`[\.!?]\)?`|<span data-ttu-id="970a1-251">Üç noktalama sembolünden birini, ardından sıfır veya bir kapanış parantezleri (")") ile eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-251">Match any of the three punctuation symbols, followed by zero or one closing parentheses (")").</span></span>|

<span data-ttu-id="970a1-252">Ayrıca, `(?n)` otomatik yakalamaları bastırmak için satır içi öğesini de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="970a1-252">You can also use the `(?n)` inline element to suppress automatic captures.</span></span> <span data-ttu-id="970a1-253">Aşağıdaki örnek, önceki normal ifade deseninin, `(?n)` seçeneği yerine satır içi öğeyi kullanmasını sağlar <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-253">The following example modifies the previous regular expression pattern to use the `(?n)` inline element instead of the <xref:System.Text.RegularExpressions.RegexOptions.ExplicitCapture?displayProperty=nameWithType> option.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit2.cs#10)]
[!code-vb[Conceptual.Regex.Language.Options#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit2.vb#10)]

<span data-ttu-id="970a1-254">Son olarak, `(?n:)` bir grup grubuna göre otomatik yakalamaları bastırmak için satır içi grup öğesini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="970a1-254">Finally, you can use the inline group element `(?n:)` to suppress automatic captures on a group-by-group basis.</span></span> <span data-ttu-id="970a1-255">Aşağıdaki örnek, dış gruptaki adlandırılmamış yakalamaları bastırmak için önceki stili değiştirir `((?>\w+),?\s?)` .</span><span class="sxs-lookup"><span data-stu-id="970a1-255">The following example modifies the previous pattern to suppress unnamed captures in the outer group, `((?>\w+),?\s?)`.</span></span> <span data-ttu-id="970a1-256">Bunun, iç gruptaki adlandırılmamış yakalamaları da bastırdığına unutmayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-256">Note that this suppresses unnamed captures in the inner group as well.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#11](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/explicit3.cs#11)]
[!code-vb[Conceptual.Regex.Language.Options#11](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/explicit3.vb#11)]

## <a name="compiled-regular-expressions"></a><span data-ttu-id="970a1-257">Derlenmiş normal Ifadeler</span><span class="sxs-lookup"><span data-stu-id="970a1-257">Compiled Regular Expressions</span></span>

<span data-ttu-id="970a1-258">Varsayılan olarak, .NET 'teki normal ifadeler yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-258">By default, regular expressions in .NET are interpreted.</span></span> <span data-ttu-id="970a1-259">Bir <xref:System.Text.RegularExpressions.Regex> nesne örneği oluşturulduğunda veya bir statik <xref:System.Text.RegularExpressions.Regex> Yöntem çağrıldığında, normal ifade deseninin özel bir işlem kodları kümesi olarak ayrıştırılıp bir yorumlayıcı, normal ifadeyi çalıştırmak için bu işlem kodları kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-259">When a <xref:System.Text.RegularExpressions.Regex> object is instantiated or a static <xref:System.Text.RegularExpressions.Regex> method is called, the regular expression pattern is parsed into a set of custom opcodes, and an interpreter uses these opcodes to run the regular expression.</span></span> <span data-ttu-id="970a1-260">Bu bir zorunluluğunu getirir içerir: normal ifade altyapısını başlatma maliyeti, çalışma zamanı performansının masrafına göre küçültülebilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-260">This involves a tradeoff: The cost of initializing the regular expression engine is minimized at the expense of run-time performance.</span></span>

<span data-ttu-id="970a1-261">Seçeneğini kullanarak yorumlanan normal ifadeler yerine derlenmiş ' i kullanabilirsiniz <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-261">You can use compiled instead of interpreted regular expressions by using the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="970a1-262">Bu durumda, bir model normal ifade altyapısına geçirildiğinde, bir dizi opkodlara ayrıştırılır ve ardından doğrudan ortak dil çalışma zamanına geçirilebilen Microsoft ara diline (MSIL) dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="970a1-262">In this case, when a pattern is passed to the regular expression engine, it is parsed into a set of opcodes and then converted to Microsoft intermediate language (MSIL), which can be passed directly to the common language runtime.</span></span> <span data-ttu-id="970a1-263">Derlenmiş normal ifadeler, başlatma zamanının masrafına göre çalışma zamanı performansını en üst düzeye çıkarır.</span><span class="sxs-lookup"><span data-stu-id="970a1-263">Compiled regular expressions maximize run-time performance at the expense of initialization time.</span></span>

> [!NOTE]
> <span data-ttu-id="970a1-264">Normal bir ifade yalnızca <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> `options` bir <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusunun parametresine veya statik bir kalıp eşleme yöntemine değer sağlanarak derlenebilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-264">A regular expression can be compiled only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or a static pattern-matching method.</span></span> <span data-ttu-id="970a1-265">Satır içi seçeneği olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-265">It is not available as an inline option.</span></span>

<span data-ttu-id="970a1-266">Statik ve örnek normal ifadelerine yapılan çağrılardan derlenmiş normal ifadeler kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="970a1-266">You can use compiled regular expressions in calls to both static and instance regular expressions.</span></span> <span data-ttu-id="970a1-267">Statik normal ifadelerde, <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> seçeneği `options` normal ifade deseninin eşleme yönteminin parametresine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-267">In static regular expressions, the <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is passed to the `options` parameter of the regular expression pattern-matching method.</span></span> <span data-ttu-id="970a1-268">Örnek normal ifadelerinde, `options` <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusunun parametresine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-268">In instance regular expressions, it is passed to the `options` parameter of the <xref:System.Text.RegularExpressions.Regex> class constructor.</span></span> <span data-ttu-id="970a1-269">Her iki durumda da gelişmiş performansa neden olur.</span><span class="sxs-lookup"><span data-stu-id="970a1-269">In both cases, it results in enhanced performance.</span></span>

<span data-ttu-id="970a1-270">Ancak, bu performans geliştirmesi yalnızca aşağıdaki koşullarda oluşur:</span><span class="sxs-lookup"><span data-stu-id="970a1-270">However, this improvement in performance occurs only under the following conditions:</span></span>

- <span data-ttu-id="970a1-271"><xref:System.Text.RegularExpressions.Regex>Belirli bir normal ifadeyi temsil eden nesne, normal ifade desenli eşleştirme yöntemlerine yapılan birden çok çağrıda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-271">A <xref:System.Text.RegularExpressions.Regex> object that represents a particular regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span>

- <span data-ttu-id="970a1-272"><xref:System.Text.RegularExpressions.Regex>Nesnenin kapsam dışına geçmesine izin verilmiyor, bu nedenle yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-272">The <xref:System.Text.RegularExpressions.Regex> object is not allowed to go out of scope, so it can be reused.</span></span>

- <span data-ttu-id="970a1-273">Statik bir normal ifade, normal ifade desenli eşleştirme yöntemlerine yapılan birden çok çağrıda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-273">A static regular expression is used in multiple calls to regular expression pattern-matching methods.</span></span> <span data-ttu-id="970a1-274">(Statik yöntem çağrılarında kullanılan normal ifadeler normal ifade altyapısı tarafından önbelleğe alındığından, performans iyileştirmesi mümkündür.)</span><span class="sxs-lookup"><span data-stu-id="970a1-274">(The performance improvement is possible because regular expressions used in static method calls are cached by the regular expression engine.)</span></span>

> [!NOTE]
> <span data-ttu-id="970a1-275"><xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType>Seçeneği, <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> önceden tanımlanmış derlenmiş normal ifadeler içeren bir özel amaçlı derleme oluşturan yöntemiyle ilişkili değildir.</span><span class="sxs-lookup"><span data-stu-id="970a1-275">The <xref:System.Text.RegularExpressions.RegexOptions.Compiled?displayProperty=nameWithType> option is unrelated to the <xref:System.Text.RegularExpressions.Regex.CompileToAssembly%2A?displayProperty=nameWithType> method, which creates a special-purpose assembly that contains predefined compiled regular expressions.</span></span>

## <a name="ignore-white-space"></a><span data-ttu-id="970a1-276">Boşluğu yoksay</span><span class="sxs-lookup"><span data-stu-id="970a1-276">Ignore White Space</span></span>

<span data-ttu-id="970a1-277">Varsayılan olarak, normal ifade düzeninde boşluk önemlidir; normal ifade altyapısını giriş dizesindeki bir boşluk karakteriyle eşleşecek şekilde zorlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-277">By default, white space in a regular expression pattern is significant; it forces the regular expression engine to match a white-space character in the input string.</span></span> <span data-ttu-id="970a1-278">Bu nedenle, normal " `\b\w+\s` " ve " `\b\w+` " ifadesi kabaca eşdeğer normal ifadelerdir.</span><span class="sxs-lookup"><span data-stu-id="970a1-278">Because of this, the regular expression "`\b\w+\s`" and "`\b\w+` " are roughly equivalent regular expressions.</span></span> <span data-ttu-id="970a1-279">Ayrıca, bir normal ifade düzeninde sayı işaretiyle (#) karşılaşıldığında, eşleştirilecek bir sabit karakter olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-279">In addition, when the number sign (#) is encountered in a regular expression pattern, it is interpreted as a literal character to be matched.</span></span>

<span data-ttu-id="970a1-280"><xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType>Seçeneği veya `x` satır içi seçeneği, bu varsayılan davranışı aşağıdaki gibi değiştirir:</span><span class="sxs-lookup"><span data-stu-id="970a1-280">The <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option, or the `x` inline option, changes this default behavior as follows:</span></span>

- <span data-ttu-id="970a1-281">Normal ifade deseninin kaçışsız boşluk yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="970a1-281">Unescaped white space in the regular expression pattern is ignored.</span></span> <span data-ttu-id="970a1-282">Normal ifade deseninin bir parçası olmak için, boşluk karakterlerinin kaçış olması gerekir (örneğin, `\s` veya " `\` ").</span><span class="sxs-lookup"><span data-stu-id="970a1-282">To be part of a regular expression pattern, white-space characters must be escaped (for example, as `\s` or "`\` ").</span></span>

- <span data-ttu-id="970a1-283">Numara işareti (#), bir açıklamanın başlangıcı olarak yorumlanır, örneğin bir sabit karakter yerine.</span><span class="sxs-lookup"><span data-stu-id="970a1-283">The number sign (#) is interpreted as the beginning of a comment, rather than as a literal character.</span></span> <span data-ttu-id="970a1-284"># Karakterden dizenin sonuna kadar olan normal ifade deseninin tüm metni bir açıklama olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-284">All text in the regular expression pattern from the # character to the end of the string is interpreted as a comment.</span></span>

<span data-ttu-id="970a1-285">Ancak, aşağıdaki durumlarda, seçeneğini kullansanız bile normal bir ifadede boşluk karakterleri yok sayılır <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> :</span><span class="sxs-lookup"><span data-stu-id="970a1-285">However, in the following cases, white-space characters in a regular expression aren't ignored, even if you use the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option:</span></span>

- <span data-ttu-id="970a1-286">Bir karakter sınıfı içindeki boşluk, her zaman tam olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-286">White space within a character class is always interpreted literally.</span></span> <span data-ttu-id="970a1-287">Örneğin, normal ifade deseninin `[ .,;:]` her biri tek boşluk karakteri, nokta, virgül, noktalı virgül veya iki nokta üst üste eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-287">For example, the regular expression pattern `[ .,;:]` matches any single white-space character, period, comma, semicolon, or colon.</span></span>

- <span data-ttu-id="970a1-288">Köşeli ayraç içinde `{` *n* `}` , `{` *n* `,}` ve `{` *n* `,` *e* `}` gibi bir nicelik süresi içinde boşluk bulunamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-288">White space isn't allowed within a bracketed quantifier, such as `{`*n*`}`, `{`*n*`,}`, and `{`*n*`,`*m*`}`.</span></span> <span data-ttu-id="970a1-289">Örneğin, normal ifade deseninin bir boşluk `\d{1, 3}` karakteri içerdiği için, bir veya daha fazla basamaklı bir sayı dizisi ile üç basamağa eşleşmesi başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="970a1-289">For example, the regular expression pattern `\d{1, 3}` fails to match any sequences of digits from one to three digits because it contains a white-space character.</span></span>

- <span data-ttu-id="970a1-290">Dil öğesi tanıtan bir karakter dizisi içinde boşluk kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-290">White space isn't allowed within a character sequence that introduces a language element.</span></span> <span data-ttu-id="970a1-291">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="970a1-291">For example:</span></span>

  - <span data-ttu-id="970a1-292">Language öğesi alt `(?:` *ifadesi* `)` yakalama olmayan bir grubu temsil eder ve `(?:` öğenin bölümünde gömülü boşluk bulunamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-292">The language element `(?:`*subexpression*`)` represents a noncapturing group, and the `(?:` portion of the element can't have embedded spaces.</span></span> <span data-ttu-id="970a1-293">`(? :` *subexpression* `)` <xref:System.ArgumentException> Normal ifade altyapısı, stili ayrıştıramadığından ve alt ifadesi alt `( ?:` *subexpression* `)` *ifade* ile eşleşmediğinden, bu, bir çalışma zamanı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="970a1-293">The pattern `(? :`*subexpression*`)` throws an <xref:System.ArgumentException> at run time because the regular expression engine can't parse the pattern, and the pattern `( ?:`*subexpression*`)` fails to match *subexpression* .</span></span>

  - <span data-ttu-id="970a1-294">`\p{` *name* `}` Bir Unicode kategorisini veya adlandırılmış bloğu temsil eden dil öğesi adı, öğenin bölümüne gömülü boşluklar içeremez `\p{` .</span><span class="sxs-lookup"><span data-stu-id="970a1-294">The language element `\p{`*name*`}`, which represents a Unicode category or named block, can't include embedded spaces in the `\p{` portion of the element.</span></span> <span data-ttu-id="970a1-295">Bir boşluk eklerseniz, öğe bir <xref:System.ArgumentException> çalışma zamanı atar.</span><span class="sxs-lookup"><span data-stu-id="970a1-295">If you do include a white space, the element throws an <xref:System.ArgumentException> at run time.</span></span>

<span data-ttu-id="970a1-296">Bu seçeneğin etkinleştirilmesi, genellikle ayrıştırılması ve anlaşılması zor olan normal ifadelerin basitleştirilmesine yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="970a1-296">Enabling this option helps simplify regular expressions that are often difficult to parse and to understand.</span></span> <span data-ttu-id="970a1-297">Okunabilirliği artırır ve normal bir ifadeyi belgelemek mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="970a1-297">It improves readability, and makes it possible to document a regular expression.</span></span>

<span data-ttu-id="970a1-298">Aşağıdaki örnek, aşağıdaki normal ifade düzenlerini tanımlar:</span><span class="sxs-lookup"><span data-stu-id="970a1-298">The following example defines the following regular expression pattern:</span></span>

`\b \(? ( (?>\w+) ,?\s? )+  [\.!?] \)? # Matches an entire sentence.`

<span data-ttu-id="970a1-299">Bu model, [yalnızca açık yakalamalar](#explicit-captures-only) bölümünde tanımlanan düzene benzer, ancak <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> model boşluk boşluğu yok sayma seçeneğini kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-299">This pattern is similar to the pattern defined in the [Explicit Captures Only](#explicit-captures-only) section, except that it uses the <xref:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace?displayProperty=nameWithType> option to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#12](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace1.cs#12)]
[!code-vb[Conceptual.Regex.Language.Options#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace1.vb#12)]

<span data-ttu-id="970a1-300">Aşağıdaki örnek, `(?x)` kalıp boşluk alanını yoksaymak için satır içi seçeneğini kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-300">The following example uses the inline option `(?x)` to ignore pattern white space.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#13](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/whitespace2.cs#13)]
[!code-vb[Conceptual.Regex.Language.Options#13](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/whitespace2.vb#13)]

## <a name="right-to-left-mode"></a><span data-ttu-id="970a1-301">Sağdan sola mod</span><span class="sxs-lookup"><span data-stu-id="970a1-301">Right-to-Left Mode</span></span>

<span data-ttu-id="970a1-302">Varsayılan olarak, normal ifade motoru soldan sağa doğru arar.</span><span class="sxs-lookup"><span data-stu-id="970a1-302">By default, the regular expression engine searches from left to right.</span></span> <span data-ttu-id="970a1-303">Seçeneğini kullanarak arama yönünü ters çevirebilirsiniz <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-303">You can reverse the search direction by using the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="970a1-304">Arama, dizenin son karakter konumunda otomatik olarak başlar.</span><span class="sxs-lookup"><span data-stu-id="970a1-304">The search automatically begins at the last character position of the string.</span></span> <span data-ttu-id="970a1-305">Bir başlangıç konumu parametresi içeren, örneğin <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> , başlangıç konumu, aramanın başlayacağı en sağdaki karakter konumunun dizinidir.</span><span class="sxs-lookup"><span data-stu-id="970a1-305">For pattern-matching methods that include a starting position parameter, such as <xref:System.Text.RegularExpressions.Regex.Match%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>, the starting position is the index of the rightmost character position at which the search is to begin.</span></span>

> [!NOTE]
> <span data-ttu-id="970a1-306">Sağdan sola düzendeki desenler yalnızca <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> `options` bir <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusunun veya statik kalıp eşleştirme yönteminin parametresine değer sağlanarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-306">Right-to-left pattern mode is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="970a1-307">Satır içi seçeneği olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-307">It is not available as an inline option.</span></span>

<span data-ttu-id="970a1-308"><xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType>Seçeneği yalnızca arama yönünü değiştirir; normal ifade modelini sağdan sola yorumlamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-308">The <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option changes the search direction only; it does not interpret the regular expression pattern from right to left.</span></span> <span data-ttu-id="970a1-309">Örneğin, normal ifade `\bb\w+\s` "b" harfiyle başlayan ve ardından bir boşluk karakteri gelen sözcüklerle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-309">For example, the regular expression `\bb\w+\s` matches words that begin with the letter "b" and are followed by a white-space character.</span></span> <span data-ttu-id="970a1-310">Aşağıdaki örnekte, giriş dizesi bir veya daha fazla "b" karakteri içeren üç sözcükten oluşur.</span><span class="sxs-lookup"><span data-stu-id="970a1-310">In the following example, the input string consists of three words that include one or more "b" characters.</span></span> <span data-ttu-id="970a1-311">İlk sözcük "b" ile başlar, ikincisi "b" ile biter ve üçüncüsü sözcüğün ortasında iki "b" karakteri içerir.</span><span class="sxs-lookup"><span data-stu-id="970a1-311">The first word begins with "b", the second ends with "b", and the third includes two "b" characters in the middle of the word.</span></span> <span data-ttu-id="970a1-312">Örnekteki Çıktının gösterdiği gibi, yalnızca ilk sözcük normal ifade düzeniyle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-312">As the output from the example shows, only the first word matches the regular expression pattern.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#17](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft1.cs#17)]
[!code-vb[Conceptual.Regex.Language.Options#17](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft1.vb#17)]

<span data-ttu-id="970a1-313">Ayrıca, ileriye doğru onaylama (alt `(?=` *ifade* `)` dili öğesi) ve geriye doğru onaylama onay (alt `(?<=` *ifade* `)` dili öğesi) yönünün değişmediğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-313">Also note that the lookahead assertion (the `(?=`*subexpression*`)` language element) and the lookbehind assertion (the `(?<=`*subexpression*`)` language element) do not change direction.</span></span> <span data-ttu-id="970a1-314">İleri yönlü onaylar doğru görünür; geriye doğru arama onayları sola bakar.</span><span class="sxs-lookup"><span data-stu-id="970a1-314">The lookahead assertions look to the right; the lookbehind assertions look to the left.</span></span> <span data-ttu-id="970a1-315">Örneğin, normal ifade, `(?<=\d{1,2}\s)\w+,?\s\d{4}` bir ay adından önce gelen bir tarihi sınamak için geriye yönelik onaylama onayını kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-315">For example, the regular expression `(?<=\d{1,2}\s)\w+,?\s\d{4}` uses the lookbehind assertion to test for a date that precedes a month name.</span></span> <span data-ttu-id="970a1-316">Normal ifade daha sonra month ve Year ile eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-316">The regular expression then matches the month and the year.</span></span> <span data-ttu-id="970a1-317">İleri ve geriye yönelik onaylar hakkında daha fazla bilgi için bkz. [gruplandırma yapıları](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="970a1-317">For information on lookahead and lookbehind assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#18](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/righttoleft2.cs#18)]
[!code-vb[Conceptual.Regex.Language.Options#18](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/righttoleft2.vb#18)]

<span data-ttu-id="970a1-318">Normal ifade deseninin, aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="970a1-318">The regular expression pattern is defined as shown in the following table.</span></span>

|<span data-ttu-id="970a1-319">Desen</span><span class="sxs-lookup"><span data-stu-id="970a1-319">Pattern</span></span>|<span data-ttu-id="970a1-320">Açıklama</span><span class="sxs-lookup"><span data-stu-id="970a1-320">Description</span></span>|
|-------------|-----------------|
|`(?<=\d{1,2}\s)`|<span data-ttu-id="970a1-321">Eşleşmenin başlangıcında bir veya iki ondalık basamak gelmeli ve ardından bir boşluk gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="970a1-321">The beginning of the match must be preceded by one or two decimal digits followed by a space.</span></span>|
|`\w+`|<span data-ttu-id="970a1-322">Bir veya daha fazla sözcük karakteri eşleştir.</span><span class="sxs-lookup"><span data-stu-id="970a1-322">Match one or more word characters.</span></span>|
|`,?`|<span data-ttu-id="970a1-323">Sıfır veya bir virgül karakteri eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-323">Match zero or one comma characters.</span></span>|
|`\s`|<span data-ttu-id="970a1-324">Bir boşluk karakteri ile eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-324">Match a white-space character.</span></span>|
|`\d{4}`|<span data-ttu-id="970a1-325">Dört ondalık basamağı eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-325">Match four decimal digits.</span></span>|

## <a name="ecmascript-matching-behavior"></a><span data-ttu-id="970a1-326">ECMAScript eşleştirme davranışı</span><span class="sxs-lookup"><span data-stu-id="970a1-326">ECMAScript Matching Behavior</span></span>

<span data-ttu-id="970a1-327">Varsayılan olarak, normal ifade altyapısı bir normal ifade örüntüsünün giriş metnine eşleştirilirken kurallı davranışı kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-327">By default, the regular expression engine uses canonical behavior when matching a regular expression pattern to input text.</span></span> <span data-ttu-id="970a1-328">Ancak, normal ifade altyapısından, seçeneğini belirterek ECMAScript eşleştirme davranışı kullanmasını söyleyebilirsiniz <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-328">However, you can instruct the regular expression engine to use ECMAScript matching behavior by specifying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option.</span></span>

> [!NOTE]
> <span data-ttu-id="970a1-329">ECMAScript uyumlu davranış yalnızca <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> `options` bir <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusunun veya statik kalıp eşleştirme yönteminin parametresine değeri sağlanarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-329">ECMAScript-compliant behavior is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="970a1-330">Satır içi seçeneği olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-330">It is not available as an inline option.</span></span>

<span data-ttu-id="970a1-331"><xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType>Seçeneği yalnızca <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> ve <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> seçenekleriyle birleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-331">The <xref:System.Text.RegularExpressions.RegexOptions.ECMAScript?displayProperty=nameWithType> option can be combined only with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> and <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> options.</span></span> <span data-ttu-id="970a1-332">Normal ifadede herhangi bir diğer seçeneğin kullanılması bir ile sonuçlanır <xref:System.ArgumentOutOfRangeException> .</span><span class="sxs-lookup"><span data-stu-id="970a1-332">The use of any other option in a regular expression results in an <xref:System.ArgumentOutOfRangeException>.</span></span>

<span data-ttu-id="970a1-333">ECMAScript ve kurallı normal ifadelerin davranışı üç alanda farklılık gösterir: karakter sınıfı sözdizimi, kendine başvuran yakalama grupları ve sekizlik ve geri başvuru yorumu.</span><span class="sxs-lookup"><span data-stu-id="970a1-333">The behavior of ECMAScript and canonical regular expressions differs in three areas: character class syntax, self-referencing capturing groups, and octal versus backreference interpretation.</span></span>

- <span data-ttu-id="970a1-334">Karakter sınıfı sözdizimi.</span><span class="sxs-lookup"><span data-stu-id="970a1-334">Character class syntax.</span></span> <span data-ttu-id="970a1-335">Geleneksel normal ifadeler Unicode desteklediği için ECMAScript, ECMAScript 'teki karakter sınıfları daha sınırlı sözdizimine sahiptir ve bazı karakter sınıfı dil öğeleri farklı anlamdadır.</span><span class="sxs-lookup"><span data-stu-id="970a1-335">Because canonical regular expressions support Unicode whereas ECMAScript does not, character classes in ECMAScript have a more limited syntax, and some character class language elements have a different meaning.</span></span> <span data-ttu-id="970a1-336">Örneğin, ECMAScript, Unicode kategorisi veya blok öğeleri ve gibi dil öğelerini desteklemez `\p` `\P` .</span><span class="sxs-lookup"><span data-stu-id="970a1-336">For example, ECMAScript does not support language elements such as the Unicode category or block elements `\p` and `\P`.</span></span> <span data-ttu-id="970a1-337">Benzer şekilde, `\w` bir sözcük karakteriyle eşleşen öğe, `[a-zA-Z_0-9]` ECMAScript kullanılırken ve kurallı davranış kullanılırken karakter sınıfına eşdeğerdir `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` .</span><span class="sxs-lookup"><span data-stu-id="970a1-337">Similarly, the `\w` element, which matches a word character, is equivalent to the `[a-zA-Z_0-9]` character class when using ECMAScript and `[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}\p{Pc}\p{Lm}]` when using canonical behavior.</span></span> <span data-ttu-id="970a1-338">Daha fazla bilgi için bkz. [karakter sınıfları](character-classes-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="970a1-338">For more information, see [Character Classes](character-classes-in-regular-expressions.md).</span></span>

  <span data-ttu-id="970a1-339">Aşağıdaki örnek kurallı ve ECMAScript desenli eşleştirme arasındaki farkı gösterir.</span><span class="sxs-lookup"><span data-stu-id="970a1-339">The following example illustrates the difference between canonical and ECMAScript pattern matching.</span></span> <span data-ttu-id="970a1-340">Bir normal ifade tanımlar, ve `\b(\w+\s*)+` ardından boşluk karakterleri gelen kelimelerle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-340">It defines a regular expression, `\b(\w+\s*)+`, that matches words followed by white-space characters.</span></span> <span data-ttu-id="970a1-341">Giriş, biri Latin karakter kümesini ve diğeri ise Kiril karakter kümesini kullanan iki dizeden oluşur.</span><span class="sxs-lookup"><span data-stu-id="970a1-341">The input consists of two strings, one that uses the Latin character set and the other that uses the Cyrillic character set.</span></span> <span data-ttu-id="970a1-342">Çıktıda gösterildiği gibi, <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> ECMAScript eşleştirmeyi kullanan yönteme yapılan çağrı, Kiril kelimeleri ile eşleşemez, ancak kurallı eşleştirme kullanan yöntem çağrısı bu sözcüklerle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="970a1-342">As the output shows, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method that uses ECMAScript matching fails to match the Cyrillic words, whereas the method call that uses canonical matching does match these words.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#16](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript1.cs#16)]
  [!code-vb[Conceptual.Regex.Language.Options#16](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript1.vb#16)]

- <span data-ttu-id="970a1-343">Kendine başvuran yakalama grupları.</span><span class="sxs-lookup"><span data-stu-id="970a1-343">Self-referencing capturing groups.</span></span> <span data-ttu-id="970a1-344">Kendisi için geri başvuru içeren bir normal ifade yakalama sınıfı, her yakalama yinelemesi ile güncelleştirilmeleri gerekir.</span><span class="sxs-lookup"><span data-stu-id="970a1-344">A regular expression capture class with a backreference to itself must be updated with each capture iteration.</span></span> <span data-ttu-id="970a1-345">Aşağıdaki örnekte gösterildiği gibi, bu özellik, normal ifadenin `((a+)(\1) ?)+` ECMAScript kullanılırken "aa aaaa aaaaaa" giriş dizesiyle eşleşmesini sağlar, ancak kurallı eşleştirme kullanılırken değildir.</span><span class="sxs-lookup"><span data-stu-id="970a1-345">As the following example shows, this feature enables the regular expression `((a+)(\1) ?)+` to match the input string " aa aaaa aaaaaa " when using ECMAScript, but not when using canonical matching.</span></span>

  [!code-csharp[Conceptual.Regex.Language.Options#21](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/ecmascript2.cs#21)]
  [!code-vb[Conceptual.Regex.Language.Options#21](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/ecmascript2.vb#21)]

  <span data-ttu-id="970a1-346">Normal ifade aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="970a1-346">The regular expression is defined as shown in the following table.</span></span>

  |<span data-ttu-id="970a1-347">Desen</span><span class="sxs-lookup"><span data-stu-id="970a1-347">Pattern</span></span>|<span data-ttu-id="970a1-348">Açıklama</span><span class="sxs-lookup"><span data-stu-id="970a1-348">Description</span></span>|
  |-------------|-----------------|
  |<span data-ttu-id="970a1-349">(+)</span><span class="sxs-lookup"><span data-stu-id="970a1-349">(a+)</span></span>|<span data-ttu-id="970a1-350">"A" harfini bir veya daha fazla kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-350">Match the letter "a" one or more times.</span></span> <span data-ttu-id="970a1-351">Bu ikinci yakalama grubudur.</span><span class="sxs-lookup"><span data-stu-id="970a1-351">This is the second capturing group.</span></span>|
  |<span data-ttu-id="970a1-352">(\ 1)</span><span class="sxs-lookup"><span data-stu-id="970a1-352">(\1)</span></span>|<span data-ttu-id="970a1-353">İlk yakalama grubu tarafından yakalanan alt dizeyle eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-353">Match the substring captured by the first capturing group.</span></span> <span data-ttu-id="970a1-354">Bu, üçüncü yakalama grubudur.</span><span class="sxs-lookup"><span data-stu-id="970a1-354">This is the third capturing group.</span></span>|
  |<span data-ttu-id="970a1-355">?</span><span class="sxs-lookup"><span data-stu-id="970a1-355">?</span></span>|<span data-ttu-id="970a1-356">Sıfır veya bir boşluk karakterini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="970a1-356">Match zero or one space characters.</span></span>|
  |<span data-ttu-id="970a1-357">((a +) (\ 1)?) +</span><span class="sxs-lookup"><span data-stu-id="970a1-357">((a+)(\1) ?)+</span></span>|<span data-ttu-id="970a1-358">Bir veya daha fazla "a" karakterinin örüntüsünün ardından ilk yakalama grubuyla eşleşen bir dize ve ardından sıfır veya bir boşluk karakteri bir veya daha fazla kez olacak şekilde eşleşen bir karakter.</span><span class="sxs-lookup"><span data-stu-id="970a1-358">Match the pattern of one or more "a" characters followed by a string that matches the first capturing group followed by zero or one space characters one or more times.</span></span> <span data-ttu-id="970a1-359">Bu ilk yakalama grubudur.</span><span class="sxs-lookup"><span data-stu-id="970a1-359">This is the first capturing group.</span></span>|

- <span data-ttu-id="970a1-360">Sekizlik kaçış ve geri başvurular arasında belirsizlikleri çözümlemesi.</span><span class="sxs-lookup"><span data-stu-id="970a1-360">Resolution of ambiguities between octal escapes and backreferences.</span></span> <span data-ttu-id="970a1-361">Aşağıdaki tabloda, kurallı ve ECMAScript normal ifadelerine karşılık gelen sekizlik ve geribaşvuru yorumlamasının farkları özetlenmektedir.</span><span class="sxs-lookup"><span data-stu-id="970a1-361">The following table summarizes the differences in octal versus backreference interpretation by canonical and ECMAScript regular expressions.</span></span>

  |<span data-ttu-id="970a1-362">Normal ifade</span><span class="sxs-lookup"><span data-stu-id="970a1-362">Regular expression</span></span>|<span data-ttu-id="970a1-363">Kurallı davranış</span><span class="sxs-lookup"><span data-stu-id="970a1-363">Canonical behavior</span></span>|<span data-ttu-id="970a1-364">ECMAScript davranışı</span><span class="sxs-lookup"><span data-stu-id="970a1-364">ECMAScript behavior</span></span>|
  |------------------------|------------------------|-------------------------|
  |<span data-ttu-id="970a1-365">`\0` ardından 0 ile 2 sekizlik basamak</span><span class="sxs-lookup"><span data-stu-id="970a1-365">`\0` followed by 0 to 2 octal digits</span></span>|<span data-ttu-id="970a1-366">Sekizlik olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-366">Interpret as an octal.</span></span> <span data-ttu-id="970a1-367">Örneğin, `\044` her zaman sekizlik bir değer olarak yorumlanır ve "$" anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="970a1-367">For example, `\044` is always interpreted as an octal value and means "$".</span></span>|<span data-ttu-id="970a1-368">Aynı davranış.</span><span class="sxs-lookup"><span data-stu-id="970a1-368">Same behavior.</span></span>|
  |<span data-ttu-id="970a1-369">`\` ardından 1 ile 9 arasında bir basamak, ardından ek ondalık basamak yok,</span><span class="sxs-lookup"><span data-stu-id="970a1-369">`\` followed by a digit from 1 to 9, followed by no additional decimal digits,</span></span>|<span data-ttu-id="970a1-370">Bir geri başvuru olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-370">Interpret as a backreference.</span></span> <span data-ttu-id="970a1-371">Örneğin, `\9` bir dokuzuncu yakalama grubu mevcut olmasa bile her zaman geri başvuru 9 anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="970a1-371">For example, `\9` always means backreference 9, even if a ninth capturing group does not exist.</span></span> <span data-ttu-id="970a1-372">Yakalama grubu yoksa, normal ifade ayrıştırıcısı bir oluşturur <xref:System.ArgumentException> .</span><span class="sxs-lookup"><span data-stu-id="970a1-372">If the capturing group does not exist, the regular expression parser throws an <xref:System.ArgumentException>.</span></span>|<span data-ttu-id="970a1-373">Tek bir ondalık basamak yakalama grubu varsa, bu basamağa geri başvuru.</span><span class="sxs-lookup"><span data-stu-id="970a1-373">If a single decimal digit capturing group exists, backreference to that digit.</span></span> <span data-ttu-id="970a1-374">Aksi takdirde, değeri değişmez değer olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-374">Otherwise, interpret the value as a literal.</span></span>|
  |<span data-ttu-id="970a1-375">`\` ardından, 1 ile 9 arasında bir rakam ve ardından ek ondalık basamaklar</span><span class="sxs-lookup"><span data-stu-id="970a1-375">`\` followed by a digit from 1 to 9, followed by additional decimal digits</span></span>|<span data-ttu-id="970a1-376">Basamakları ondalık değer olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-376">Interpret the digits as a decimal value.</span></span> <span data-ttu-id="970a1-377">Bu yakalama grubu varsa, ifadeyi bir geri başvuru olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-377">If that capturing group exists, interpret the expression as a backreference.</span></span><br /><br /> <span data-ttu-id="970a1-378">Aksi takdirde, önde gelen sekizlik basamakları sekizlik 377 ' e kadar yorumlayın; diğer bir deyişle, yalnızca değerin düşük 8 bitini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="970a1-378">Otherwise, interpret the leading octal digits up to octal 377; that is, consider only the low 8 bits of the value.</span></span> <span data-ttu-id="970a1-379">Kalan basamakları değişmez değer olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-379">Interpret the remaining digits as literals.</span></span> <span data-ttu-id="970a1-380">Örneğin ifadesinde, `\3000` grup 300 yakalama varsa, geri başvuru 300 olarak yorumlayın; grup 300 yakalama yoksa, sekizlik 300 olarak, ardından 0 olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-380">For example, in the expression `\3000`, if capturing group 300 exists, interpret as backreference 300; if capturing group 300 does not exist, interpret as octal 300 followed by 0.</span></span>|<span data-ttu-id="970a1-381">Bir yakalamaya başvurabilen ondalık bir değere mümkün olduğunca çok basamak dönüştürerek bir geri başvuru olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-381">Interpret as a backreference by converting as many digits as possible to a decimal value that can refer to a capture.</span></span> <span data-ttu-id="970a1-382">Herhangi bir basamak dönüştürülemiyorsa, sekizlik basamağı 377 ' e kadar olan önde gelen sekizlik basamakları kullanarak sekizlik olarak yorumlayın; kalan basamakları değişmez değer olarak yorumlayın.</span><span class="sxs-lookup"><span data-stu-id="970a1-382">If no digits can be converted, interpret as an octal by using the leading octal digits up to octal 377; interpret the remaining digits as literals.</span></span>|

## <a name="comparison-using-the-invariant-culture"></a><span data-ttu-id="970a1-383">Sabit kültür kullanılarak karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="970a1-383">Comparison Using the Invariant Culture</span></span>

<span data-ttu-id="970a1-384">Varsayılan olarak, normal ifade altyapısı büyük küçük harfe duyarsız karşılaştırmalar gerçekleştirdiğinde, eşdeğer büyük ve küçük harfli karakterleri anlamak için geçerli kültürün büyük/küçük harf kurallarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="970a1-384">By default, when the regular expression engine performs case-insensitive comparisons, it uses the casing conventions of the current culture to determine equivalent uppercase and lowercase characters.</span></span>

<span data-ttu-id="970a1-385">Ancak, özellikle Kullanıcı girişini parolalar, dosyalar veya URL 'Ler gibi sistem kaynaklarının adlarıyla karşılaştırırken, bu davranış bazı karşılaştırmalar türleri için istenmeyen bir durum değildir.</span><span class="sxs-lookup"><span data-stu-id="970a1-385">However, this behavior is undesirable for some types of comparisons, particularly when comparing user input to the names of system resources, such as passwords, files, or URLs.</span></span> <span data-ttu-id="970a1-386">Aşağıdaki örnek senaryo gibi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="970a1-386">The following example illustrates such as scenario.</span></span> <span data-ttu-id="970a1-387">Kod, URL 'SI **FILE://** ile kullanıma hazır olan herhangi bir kaynağa erişimi engellemeye yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="970a1-387">The code is intended to block access to any resource whose URL is prefaced with **FILE://** .</span></span> <span data-ttu-id="970a1-388">Normal ifade, normal ifade kullanarak dizeyle büyük/küçük harfe duyarsız bir eşleştirme girişiminde bulunur `$FILE://` .</span><span class="sxs-lookup"><span data-stu-id="970a1-388">The regular expression attempts a case-insensitive match with the string by using the regular expression `$FILE://`.</span></span> <span data-ttu-id="970a1-389">Ancak, geçerli sistem kültürü tr-TR (Türkçe-Türkiye) olduğunda "I", "i" öğesinin büyük harfli eşdeğeri değildir.</span><span class="sxs-lookup"><span data-stu-id="970a1-389">However, when the current system culture is tr-TR (Turkish-Turkey), "I" is not the uppercase equivalent of "i".</span></span> <span data-ttu-id="970a1-390">Sonuç olarak, yöntemine yapılan çağrı <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> döner `false` ve dosyaya erişime izin verilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-390">As a result, the call to the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method returns `false`, and access to the file is allowed.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#14](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#14)]
[!code-vb[Conceptual.Regex.Language.Options#14](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#14)]

> [!NOTE]
> <span data-ttu-id="970a1-391">Büyük/küçük harfe duyarlı ve sabit kültür kullanan dize karşılaştırmaları hakkında daha fazla bilgi için bkz. [dizeleri kullanmak Için En Iyi uygulamalar](best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="970a1-391">For more information about string comparisons that are case-sensitive and that use the invariant culture, see [Best Practices for Using Strings](best-practices-strings.md).</span></span>

<span data-ttu-id="970a1-392">Geçerli kültürün büyük/küçük harf duyarsız karşılaştırmalarını kullanmak yerine, <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> dildeki kültürel farklılıklarını yok sayma ve sabit kültürün kurallarını kullanma seçeneğini belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="970a1-392">Instead of using the case-insensitive comparisons of the current culture, you can specify the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> option to ignore cultural differences in language and to use the conventions of the invariant culture.</span></span>

> [!NOTE]
> <span data-ttu-id="970a1-393">Sabit kültür kullanılarak karşılaştırma yalnızca <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> `options` bir <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusunun veya statik kalıp eşleştirme yönteminin parametresine değeri sağlanarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-393">Comparison using the invariant culture is available only by supplying the <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> value to the `options` parameter of a <xref:System.Text.RegularExpressions.Regex> class constructor or static pattern-matching method.</span></span> <span data-ttu-id="970a1-394">Satır içi seçeneği olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="970a1-394">It is not available as an inline option.</span></span>

<span data-ttu-id="970a1-395">Aşağıdaki örnek, bir önceki örnekle aynıdır, ancak statik <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> Yöntem dahil olan seçeneklerle çağırılır <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970a1-395">The following example is identical to the previous example, except that the static <xref:System.Text.RegularExpressions.Regex.IsMatch%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with options that include <xref:System.Text.RegularExpressions.RegexOptions.CultureInvariant?displayProperty=nameWithType>.</span></span> <span data-ttu-id="970a1-396">Geçerli kültür Türkçe (Türkiye) olarak ayarlandığında bile, normal ifade altyapısı "dosya" ve "dosya" ile başarılı bir şekilde eşleştirebilir ve dosya kaynağına erişimi engelleyebilir.</span><span class="sxs-lookup"><span data-stu-id="970a1-396">Even when the current culture is set to Turkish (Turkey), the regular expression engine is able to successfully match "FILE" and "file" and block access to the file resource.</span></span>

[!code-csharp[Conceptual.Regex.Language.Options#15](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.options/cs/culture1.cs#15)]
[!code-vb[Conceptual.Regex.Language.Options#15](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.options/vb/culture1.vb#15)]

## <a name="see-also"></a><span data-ttu-id="970a1-397">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="970a1-397">See also</span></span>

- [<span data-ttu-id="970a1-398">Normal İfade Dili - Hızlı Başvuru</span><span class="sxs-lookup"><span data-stu-id="970a1-398">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)
