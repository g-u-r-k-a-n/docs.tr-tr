---
title: .NET XAML Hizmetlerinde Kullanılacak Özel Türleri Tanımlama
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "82071859"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="74ad7-102">.NET XAML Hizmetleri ile kullanılmak üzere özel türleri tanımlayın</span><span class="sxs-lookup"><span data-stu-id="74ad7-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="74ad7-103">İş nesneleri olan veya belirli çerçevelere bağımlı olmayan türler olan özel türleri tanımladığınızda, XAML için izleyebileceğiniz belirli en iyi uygulamalar vardır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="74ad7-104">Bu uygulamaları izlerseniz, .NET XAML Hizmetleri ve XAML okuyucuları ve XAML yazarları türün XAML özelliklerini keşfedebilir ve XAML türü sistemini kullanarak bir XAML düğüm akışında uygun gösterim sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="74ad7-105">Bu konu, tür tanımları, üye tanımları ve CLR türleri veya üyelerin atflanması için en iyi uygulamaları açıklar.</span><span class="sxs-lookup"><span data-stu-id="74ad7-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="74ad7-106">XAML için Yapıcı Desenler ve Tip Tanımları</span><span class="sxs-lookup"><span data-stu-id="74ad7-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="74ad7-107">XAML'de bir nesne öğesi olarak anlık olarak atılabilmesi için, özel bir sınıfın aşağıdaki gereksinimleri karşılaması gerekir:</span><span class="sxs-lookup"><span data-stu-id="74ad7-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="74ad7-108">Özel sınıf ortak olmalı ve parametresiz bir ortak oluşturucu ortaya çıkarmalıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="74ad7-109">(Yapılarla ilgili notlar için aşağıdaki bölüme bakın.)</span><span class="sxs-lookup"><span data-stu-id="74ad7-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="74ad7-110">Özel sınıf iç içe sınıf olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="74ad7-111">Tam ad yolundaki ekstra "nokta" sınıf ad alanı bölümünü belirsiz hale getirir ve ekli özellikler gibi diğer XAML özelliklerini bozar.</span><span class="sxs-lookup"><span data-stu-id="74ad7-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="74ad7-112">Bir nesne nesne öğesi olarak anında oluşturulabilirse, oluşturulan nesne, nesneyi alttaki türü olarak alan tüm özelliklerin özellik öğesi formunu doldurabilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="74ad7-113">Bir değer dönüştürücü etkinleştiriyorsanız, bu ölçütleri karşılamayan türler için nesne değerleri sağlamaya devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74ad7-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="74ad7-114">Daha fazla bilgi için [XAML için Tür Dönüştürücüler ve Biçimlendirme Uzantıları'na](type-converters-and-markup-extensions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="74ad7-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="74ad7-115">Yapılar</span><span class="sxs-lookup"><span data-stu-id="74ad7-115">Structures</span></span>

<span data-ttu-id="74ad7-116">Yapılar her zaman ClR tanımı ile XAML inşa edilebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="74ad7-117">Bunun nedeni, CLR derleyicinin örtülü olarak bir yapı için parametresiz bir oluşturucu oluşturmasıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="74ad7-118">Bu oluşturucu, tüm özellik değerlerini varsayılanlarına göre başlar.</span><span class="sxs-lookup"><span data-stu-id="74ad7-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="74ad7-119">Bazı durumlarda, bir yapı için varsayılan yapı davranışı istenmez.</span><span class="sxs-lookup"><span data-stu-id="74ad7-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="74ad7-120">Bunun nedeni, yapının değerleri doldurmak ve kavramsal olarak birleşim olarak işlev görmek için tasarlanmış olması olabilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="74ad7-121">Bir birlik olarak, içerdiği değerler birbirini dışlayan yorumlara sahip olabilir ve bu nedenle, özelliklerinin hiçbiri ayarlanabilir değildir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="74ad7-122">WPF sözlüğünde böyle bir yapıya <xref:System.Windows.GridLength>örnek olarak .</span><span class="sxs-lookup"><span data-stu-id="74ad7-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="74ad7-123">Bu tür yapılar, yapıların farklı yorumlarını veya modlarını oluşturan dize kuralları nı kullanarak, değerlerin öznitelik formunda ifade edilebilmeleri için bir tür dönüştürücü uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="74ad7-124">Yapı da parametresiz olmayan bir oluşturucu aracılığıyla kod oluşturma için benzer davranış ortaya çıkarmalıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="74ad7-125">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="74ad7-125">Interfaces</span></span>

<span data-ttu-id="74ad7-126">Arabirimler, altta yatan üye türleri olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="74ad7-127">XAML türü sistemi devredilebilir listeyi denetler ve değer olarak sağlanan nesnenin arabirime atanmasını bekler.</span><span class="sxs-lookup"><span data-stu-id="74ad7-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="74ad7-128">İlgili bir devratlanabilir tür XAML yapı gereksinimlerini desteklediği sürece arabirimin XAML türü olarak nasıl sunulması gerektiği ne anlama geliyor?</span><span class="sxs-lookup"><span data-stu-id="74ad7-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="74ad7-129">Fabrika Yöntemleri</span><span class="sxs-lookup"><span data-stu-id="74ad7-129">Factory Methods</span></span>

<span data-ttu-id="74ad7-130">Fabrika yöntemleri bir XAML 2009 özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="74ad7-131">Nesnelerin parametresiz oluşturucuları olması gerektiği XAML ilkesini değiştirirler.</span><span class="sxs-lookup"><span data-stu-id="74ad7-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="74ad7-132">Fabrika yöntemleri bu makalede belgelenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="74ad7-133">Bkz. [x:FactoryMethod Direktifi](xfactorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="74ad7-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="74ad7-134">Numaralandırmalar</span><span class="sxs-lookup"><span data-stu-id="74ad7-134">Enumerations</span></span>

<span data-ttu-id="74ad7-135">Tümumerations XAML yerel türü dönüştürme davranışı vardır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="74ad7-136">XAML'de belirtilen numaralandırma sabit adları, temel numaralandırma türüne göre çözülür ve numaralandırma değerini bir XAML nesne yazarına döndürür.</span><span class="sxs-lookup"><span data-stu-id="74ad7-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="74ad7-137">XAML <xref:System.FlagsAttribute> uygulanan sayısallaştırmalar için bayrak stili kullanımını destekler.</span><span class="sxs-lookup"><span data-stu-id="74ad7-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="74ad7-138">Daha fazla bilgi için Bkz. [Ayrıntılı Olarak XAML Sözdizimi.](../../framework/wpf/advanced/xaml-syntax-in-detail.md)</span><span class="sxs-lookup"><span data-stu-id="74ad7-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="74ad7-139">([XAML Sözdizimi Ayrıntılı](../../framework/wpf/advanced/xaml-syntax-in-detail.md) olarak WPF hedef kitlesi için yazılmıştır, ancak bu konudaki bilgilerin çoğu belirli bir uygulama çerçevesine özgü olmayan XAML için önemlidir.)</span><span class="sxs-lookup"><span data-stu-id="74ad7-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="74ad7-140">Üye Tanımları</span><span class="sxs-lookup"><span data-stu-id="74ad7-140">Member Definitions</span></span>

<span data-ttu-id="74ad7-141">Türleri XAML kullanımı için üye tanımlayabilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="74ad7-142">Bu tür XAML-kullanılabilir olmasa bile XAML kullanılabilir üyeleri tanımlamak için türleri mümkündür.</span><span class="sxs-lookup"><span data-stu-id="74ad7-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="74ad7-143">Bu CLR kalıtım nedeniyle mümkündür.</span><span class="sxs-lookup"><span data-stu-id="74ad7-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="74ad7-144">Üyeyi devralan bazı tür, XAML kullanımını bir tür olarak desteklediği ve üyenin xaml kullanımını temel türü için desteklediği veya yerel bir XAML sözdizimi bulunduğu sürece, bu üye XAML tarafından kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="74ad7-145">Özellikler</span><span class="sxs-lookup"><span data-stu-id="74ad7-145">Properties</span></span>

<span data-ttu-id="74ad7-146">`get` Özellikleri, tipik CLR ve erişimci desenleri `set` ve dile uygun anahtar kelime kullanarak ortak bir CLR özelliği olarak tanımlarsanız, XAML türü sistemi, özellikleri için <xref:System.Xaml.XamlMember> sağlanan uygun bilgilere sahip bir üye olarak özelliği <xref:System.Xaml.XamlMember.IsReadPublic%2A> bildirebilir. <xref:System.Xaml.XamlMember.IsWritePublic%2A></span><span class="sxs-lookup"><span data-stu-id="74ad7-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="74ad7-147">Belirli özellikler uygulayarak <xref:System.ComponentModel.TypeConverterAttribute>bir metin sözdizimini etkinleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="74ad7-148">Daha fazla bilgi için [XAML için Tür Dönüştürücüler ve Biçimlendirme Uzantıları'na](type-converters-and-markup-extensions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="74ad7-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="74ad7-149">Metin sözdizimi veya yerel XAML dönüştürme yokluğunda ve biçimlendirme uzantısı kullanımı gibi daha fazla yönlendirme yokluğunda,<xref:System.Xaml.XamlMember.TargetType%2A> bir özellik türü (XAML türü sisteminde) bir xaml nesne spesiiiyacıiçin bir CLR türü olarak ele alarak bir örnek döndürmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="74ad7-150">XAML 2009 kullanıyorsanız, [x:Reference Markup Extension](xreference-markup-extension.md) önceki hususlar karşılanmazsa değerleri sağlamak için kullanılabilir; ancak, bu bir tür tanımı sorunu daha bir kullanım sorunu daha fazladır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="74ad7-151">Olaylar</span><span class="sxs-lookup"><span data-stu-id="74ad7-151">Events</span></span>

<span data-ttu-id="74ad7-152">Olayları herkese açık bir CLR olayı olarak tanımlarsanız, XAML türü <xref:System.Xaml.XamlMember.IsEvent%2A> sistemi `true`olayı üye olarak bildirebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="74ad7-153">Olay işleyicilerinin kablolama .NET XAML Hizmetleri yetenekleri kapsamında değildir; kablolama belirli çerçevelere ve uygulamalara bırakılır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="74ad7-154">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="74ad7-154">Methods</span></span>

<span data-ttu-id="74ad7-155">Yöntemler için satır kodu varsayılan bir XAML özelliği değildir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="74ad7-156">Çoğu durumda, xaml doğrudan yöntem üyeleri başvuru yok ve XAML yöntemlerin rolü sadece belirli XAML desenleri için destek sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="74ad7-157">[x:FactoryMethod Direktifi](xfactorymethod-directive.md) bir istisnadır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="74ad7-158">Alanlar</span><span class="sxs-lookup"><span data-stu-id="74ad7-158">Fields</span></span>

<span data-ttu-id="74ad7-159">CLR tasarım yönergeleri statik olmayan alanların cesaretini kırar.</span><span class="sxs-lookup"><span data-stu-id="74ad7-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="74ad7-160">Statik alanlar için statik alan değerlerine yalnızca [x:Static Markup Extension](xstatic-markup-extension.md)üzerinden erişebilirsiniz; bu durumda [x:Static](xstatic-markup-extension.md) kullanımları için bir alanı ortaya çıkarmak için CLR tanımında özel bir şey yapmıyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="74ad7-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="74ad7-161">Eklenebilir Üyeler</span><span class="sxs-lookup"><span data-stu-id="74ad7-161">Attachable Members</span></span>

<span data-ttu-id="74ad7-162">Takılabilir üyeler tanımlayıcı bir tür üzerinde bir erişimci yöntemi deseni aracılığıyla XAML maruz kalırlar.</span><span class="sxs-lookup"><span data-stu-id="74ad7-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="74ad7-163">Tanımlayıcı türün kendisi bir nesne olarak XAML kullanılabilir olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="74ad7-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="74ad7-164">Aslında, ortak bir desen olan rolü takılabilir üye sahibi ve ilgili davranışları uygulamak için bir hizmet sınıfı bildirmek, ancak bir UI gösterimi gibi başka bir işlev hizmet etmektir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="74ad7-165">Aşağıdaki bölümlerde yer tutucu *PropertyName,* eklenebilir üyenizin adını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="74ad7-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="74ad7-166">Bu ad [XamlName Dilbilgisi](xamlname-grammar.md)geçerli olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="74ad7-167">Bu desenler ve bir türün diğer yöntemleri arasındaki ad çakışmalarına karşı dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="74ad7-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="74ad7-168">Desenlerden biriyle eşleşen bir üye varsa, niyetiniz bu olmasa bile xaml işlemci tarafından takılabilir bir üye kullanım yolu olarak yorumlanabilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="74ad7-169">GetPropertyName Erişimcisi</span><span class="sxs-lookup"><span data-stu-id="74ad7-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="74ad7-170">Erişime erişimin `GetPropertyName` imzası aşağıdaki olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="74ad7-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="74ad7-171">Nesne, `target` uygulamanızda daha özel bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="74ad7-172">Bunu, eklenebilir üyenizin kullanımını kapsamak için kullanabilirsiniz; amaçlanan kapsam dışındaki kullanımlar, xaml ayrıştırım hatasıyla su yüzüne çıkan geçersiz döküm özel durumları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="74ad7-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="74ad7-173">Parametre adı `target` bir gereklilik değildir, `target` ancak çoğu uygulamada kural olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="74ad7-174">İade değeri, uygulamanızda daha özel bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="74ad7-175">Eklenebilir <xref:System.ComponentModel.TypeConverter> üyenin öznitelik kullanımı için etkin leştirilmiş bir <xref:System.ComponentModel.TypeConverterAttribute> metin `GetPropertyName` sözdizimini desteklemek için, erişime başvurana uygulayın.</span><span class="sxs-lookup"><span data-stu-id="74ad7-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="74ad7-176">`get` Yerine `set` uygulamak sezgisel olmayabilir; ancak, bu kural, tasarımcı senaryolarında yararlı olan, serileştirilebilir salt okunur eklenebilir üyeler kavramını destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="74ad7-177">SetPropertyName Erişimcisi</span><span class="sxs-lookup"><span data-stu-id="74ad7-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="74ad7-178">Erişime erişimin `SetPropertyName` imzası aşağıdaki olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="74ad7-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="74ad7-179">Nesne, `target` önceki bölümde açıklandığı gibi aynı mantık ve sonuçlarla, uygulamanızda daha özel bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="74ad7-180">Nesne, `value` uygulamanızda daha özel bir tür olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="74ad7-181">Bu yöntemin değerinin genellikle öznitelik formunda olan XAML kullanımından gelen giriş olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="74ad7-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="74ad7-182">Öznitelik formundan bir metin sözdizimi için değer dönüştürücü desteği `GetPropertyName`olmalıdır ve siz de s erişimedayalıda öznitelik verirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74ad7-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="74ad7-183">Takılabilir Üye Mağazaları</span><span class="sxs-lookup"><span data-stu-id="74ad7-183">Attachable Member Stores</span></span>

<span data-ttu-id="74ad7-184">Erişimci yöntemler genellikle eklenebilir üye değerleri nesne grafiğine yerleştirmek veya nesneleri nesne grafiğinden alıp düzgün bir şekilde seri hale getirmek için yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="74ad7-185">Bu işlevselliği sağlamak `target` için, önceki erişimci imzadaki nesnelerin değerleri depolama yeteneğine sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="74ad7-186">Depolama mekanizması, üyenin üye listesinde olmayan hedeflere eklenebilir olduğu ilkesiyle tutarlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="74ad7-187">.NET XAML Hizmetleri, API'ler <xref:System.Xaml.IAttachedPropertyStore> aracılığıyla eklenebilir <xref:System.Xaml.AttachablePropertyServices>üye mağazalar için bir uygulama tekniği sağlar ve.</span><span class="sxs-lookup"><span data-stu-id="74ad7-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="74ad7-188"><xref:System.Xaml.IAttachedPropertyStore>xaml yazarlar tarafından mağaza uygulamasını keşfetmek için kullanılır ve erişenlerin türü `target` üzerinde uygulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="74ad7-189">Statik <xref:System.Xaml.AttachablePropertyServices> API'ler, eriştirenlerin gövdesi içinde kullanılır ve takılabilir <xref:System.Xaml.AttachableMemberIdentifier>üyeye .</span><span class="sxs-lookup"><span data-stu-id="74ad7-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="74ad7-190">XAML ile ilgili CLR Öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="74ad7-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="74ad7-191">XAML türü sistem bilgilerini .NET XAML Hizmetleri'ne bildirmek için türlerinizi, üyelerinizi ve derlemelerinizi doğru bir şekilde atfetmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="74ad7-192">Aşağıdaki durumlardan biri geçerliyse XAML türü sistem bilgilerinin raporlanması önemlidir:</span><span class="sxs-lookup"><span data-stu-id="74ad7-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="74ad7-193">Doğrudan .NET XAML Hizmetleri XAML okuyucularına ve XAML yazarlarını temel alan XAML sistemlerinde kullanım için türünüzü niyetindesiniz.</span><span class="sxs-lookup"><span data-stu-id="74ad7-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="74ad7-194">Bu XAML okuyucuları ve XAML yazarlarını temel alan XAML kullanan bir çerçeve tanımlar veya kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="74ad7-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="74ad7-195">Özel türlerinizin XAML desteğiyle alakalı her XAML ile ilgili özniteliğin listesi [için, Özel Türler ve Kitaplıklar için XAML ile ilgili CLR Öznitelikleri'ne](clr-attributes-with-custom-types-and-libraries.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="74ad7-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="74ad7-196">Kullanım</span><span class="sxs-lookup"><span data-stu-id="74ad7-196">Usage</span></span>

<span data-ttu-id="74ad7-197">Özel türlerin kullanımı, biçimlendirme yazarının özel türü içeren derleme ve CLR ad alanı için bir önek eşlemesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="74ad7-198">Bu yordam bu konuda belgelenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="74ad7-199">Erişim Düzeyi</span><span class="sxs-lookup"><span data-stu-id="74ad7-199">Access Level</span></span>

<span data-ttu-id="74ad7-200">XAML, erişim düzeyine sahip türleri yüklemek ve `internal` anlık olarak yüklemek için bir araç sağlar.</span><span class="sxs-lookup"><span data-stu-id="74ad7-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="74ad7-201">Bu özellik, kullanıcı kodunun kendi türlerini tanımlayabilmesi ve ardından aynı kullanıcı kodu kapsamının bir parçası olan biçimlendirmeden bu sınıfları anında atabilmesi için sağlanır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="74ad7-202">WPF'den bir örnek, kullanıcı kodu, kullanıcı arabirimi davranışını yeniden düzenlemenin bir yolu olarak tasarlanmış bir kullanıcı kodu tanımladığı, <xref:System.Windows.Controls.UserControl> ancak destek `public` çisi sini erişim düzeyiyle beyan ederek ima edilebilen olası uzantı mekanizmasının bir parçası olarak tanımlanmamasıdır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="74ad7-203">Destek <xref:System.Windows.Controls.UserControl> kodu XAML türü olarak başvurulmulan aynı derleme içine derlenirse, böyle bir erişim ile `internal` bildirilebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="74ad7-204">XAML'yi tam güven altında yükleyen ve <xref:System.Xaml.XamlObjectWriter> `internal` kullanan bir uygulama için, erişim düzeyine sahip yükleme sınıfları her zaman etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="74ad7-205">XAML'yi kısmi güven altında yükleyen bir uygulama için, <xref:System.Xaml.Permissions.XamlAccessLevel> API'yi kullanarak erişim düzeyi özelliklerini denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="74ad7-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="74ad7-206">Ayrıca, erteleme mekanizmaları (WPF şablon sistemi gibi) herhangi bir erişim düzeyi izinleri yaymak ve nihai çalışma süresi değerlendirmeleri için bunları korumak gerekir; bu <xref:System.Xaml.Permissions.XamlAccessLevel> bilgi geçirerek dahili olarak ele alınır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="74ad7-207">WPF Uygulaması</span><span class="sxs-lookup"><span data-stu-id="74ad7-207">WPF Implementation</span></span>

<span data-ttu-id="74ad7-208">WPF XAML, BAML kısmi güven altında yüklenirse, erişimin <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> BAML kaynağı olan derlemeyle sınırlı olduğu kısmi güven erişim modeli kullanır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="74ad7-209">Erteleme için WPF, <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> erişim düzeyi bilgilerini aktarmak için bir mekanizma olarak kullanır.</span><span class="sxs-lookup"><span data-stu-id="74ad7-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="74ad7-210">WPF XAML terminolojisinde, dahili bir *tür,* xaml referansını da içeren aynı derleme tarafından tanımlanan bir türdür.</span><span class="sxs-lookup"><span data-stu-id="74ad7-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="74ad7-211">Böyle bir tür, örneğin, bir eşlemenin derleme= bölümünü kasten atlayan bir XAML `xmlns:local="clr-namespace:WPFApplication1"`ad alanı üzerinden eşlenebilir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="74ad7-212">BAML bir iç türe başvuruyorsa ve bu tür erişim düzeyine sahipse, `internal` bu derleme için bir `GeneratedInternalTypeHelper` sınıf oluşturur.</span><span class="sxs-lookup"><span data-stu-id="74ad7-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="74ad7-213">Kaçınmak `GeneratedInternalTypeHelper`istiyorsanız, erişim düzeyini kullanmanız `public` veya ilgili sınıfı ayrı bir derlemeye dahil etmeniz ve bu derlemeyi bağımlı hale getirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="74ad7-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="74ad7-214">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="74ad7-214">See also</span></span>

- [<span data-ttu-id="74ad7-215">Özel Türler ve Kitaplıkar İçin XAML İlişkili CLR Öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="74ad7-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="74ad7-216">XAML Hizmetleri</span><span class="sxs-lookup"><span data-stu-id="74ad7-216">XAML Services</span></span>](../../../api/index.md)
