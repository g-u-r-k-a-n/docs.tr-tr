---
title: 'Türleri ve üyelerini tanımlama-C turu #'
description: Programların yapı taşları türlerdir. C# ' de sınıflar, yapılar, arabirimler ve daha fazlasını oluşturma hakkında bilgi edinin.
ms.date: 08/06/2020
ms.openlocfilehash: b1ce24611fec6fdf01d5ecb8d6ae974e147c78c5
ms.sourcegitcommit: 68c9d9d9a97aab3b59d388914004b5474cf1dbd7
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/30/2021
ms.locfileid: "99216609"
---
# <a name="types-and-members"></a><span data-ttu-id="e68ae-104">Türler ve Üyeler</span><span class="sxs-lookup"><span data-stu-id="e68ae-104">Types and members</span></span>

<span data-ttu-id="e68ae-105">C#, nesne yönelimli bir dil olarak kapsülleme, devralma ve çok biçimlilik kavramlarını destekler.</span><span class="sxs-lookup"><span data-stu-id="e68ae-105">As an object-oriented language, C# supports the concepts of encapsulation, inheritance, and polymorphism.</span></span> <span data-ttu-id="e68ae-106">Bir sınıf doğrudan bir üst sınıftan devralınabilir ve herhangi bir sayıda arabirim uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-106">A class may inherit directly from one parent class, and it may implement any number of interfaces.</span></span> <span data-ttu-id="e68ae-107">Bir üst sınıftaki sanal yöntemleri geçersiz kılan yöntemler, yanlışlıkla yeniden `override` tanımı önlemek için anahtar sözcüğünü gerektirir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-107">Methods that override virtual methods in a parent class require the `override` keyword as a way to avoid accidental redefinition.</span></span> <span data-ttu-id="e68ae-108">C# ' de, bir struct basit bir sınıf gibidir; Bu, arabirimleri uygulayasağlayan ancak devralmayı desteklemeyen, yığın olarak ayrılmış bir türdür.</span><span class="sxs-lookup"><span data-stu-id="e68ae-108">In C#, a struct is like a lightweight class; it's a stack-allocated type that can implement interfaces but doesn't support inheritance.</span></span> <span data-ttu-id="e68ae-109">C# Ayrıca, amacı Aslında veri değerlerini depolayan sınıf türleri olan kayıtlar da sağlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-109">C# also provides records, which are class types whose purpose is primarily storing data values.</span></span>

## <a name="classes-and-objects"></a><span data-ttu-id="e68ae-110">Sınıflar ve nesneler</span><span class="sxs-lookup"><span data-stu-id="e68ae-110">Classes and objects</span></span>

<span data-ttu-id="e68ae-111">*Sınıflar* C# türlerinin en temel larıdır.</span><span class="sxs-lookup"><span data-stu-id="e68ae-111">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="e68ae-112">Bir sınıf, durumu (alanları) ve eylemleri (Yöntemler ve diğer işlev üyelerini) tek bir birimde birleştiren bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="e68ae-112">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="e68ae-113">Sınıf, *nesne* olarak da bilinen sınıf *örnekleri* için bir tanım sağlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-113">A class provides a definition for *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="e68ae-114">Sınıflar, *Devralma* ve çok *biçimlilik* desteği, *türetilmiş sınıfların* *temel sınıfları* genişletebileceği ve özelleştirilebilecek mekanizmalar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-114">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="e68ae-115">Yeni sınıflar sınıf bildirimleri kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="e68ae-115">New classes are created using class declarations.</span></span> <span data-ttu-id="e68ae-116">Sınıf bildirimi, üst bilgiyle başlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-116">A class declaration starts with a header.</span></span> <span data-ttu-id="e68ae-117">Üst bilgi şunları belirtir:</span><span class="sxs-lookup"><span data-stu-id="e68ae-117">The header specifies:</span></span>

- <span data-ttu-id="e68ae-118">Sınıfın öznitelikleri ve değiştiriciler</span><span class="sxs-lookup"><span data-stu-id="e68ae-118">The attributes and modifiers of the class</span></span>
- <span data-ttu-id="e68ae-119">Sınıfın adı</span><span class="sxs-lookup"><span data-stu-id="e68ae-119">The name of the class</span></span>
- <span data-ttu-id="e68ae-120">Temel sınıf (bir [taban sınıftan](#base-classes)devralınırken)</span><span class="sxs-lookup"><span data-stu-id="e68ae-120">The base class (when inheriting from a [base class](#base-classes))</span></span>
- <span data-ttu-id="e68ae-121">Sınıf tarafından uygulanan Arabirimler.</span><span class="sxs-lookup"><span data-stu-id="e68ae-121">The interfaces implemented by the class.</span></span>

<span data-ttu-id="e68ae-122">Üst bilgi, sınırlayıcılar ve arasında yazılmış üye bildirimlerinin listesinden oluşan sınıf gövdesinden gelir `{` `}` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-122">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="e68ae-123">Aşağıdaki kod, adlı basit bir sınıfın bir bildirimini gösterir `Point` :</span><span class="sxs-lookup"><span data-stu-id="e68ae-123">The following code shows a declaration of a simple class named `Point`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointClass":::

<span data-ttu-id="e68ae-124">Sınıf örnekleri `new` , yeni bir örnek için bellek ayıran işleç kullanılarak oluşturulur, örneği başlatmak için bir oluşturucu çağırır ve örneğe bir başvuru döndürür.</span><span class="sxs-lookup"><span data-stu-id="e68ae-124">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="e68ae-125">Aşağıdaki deyimler iki nesne oluşturur `Point` ve bu nesnelere başvuruları iki değişken halinde depolar:</span><span class="sxs-lookup"><span data-stu-id="e68ae-125">The following statements create two `Point` objects and store references to those objects in two variables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePoints":::

<span data-ttu-id="e68ae-126">Nesne artık erişilebilir olmadığında bir nesnenin kapladığı bellek otomatik olarak geri kazanılır.</span><span class="sxs-lookup"><span data-stu-id="e68ae-126">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="e68ae-127">C# dilinde nesneleri açıkça serbest bırakmak gerekli değildir veya mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-127">It's not necessary or possible to explicitly deallocate objects in C#.</span></span>

### <a name="type-parameters"></a><span data-ttu-id="e68ae-128">Tür parametreleri</span><span class="sxs-lookup"><span data-stu-id="e68ae-128">Type parameters</span></span>

<span data-ttu-id="e68ae-129">Genel sınıflar [ \* **tür parametrelerini** tanımlar _](../programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="e68ae-129">Generic classes define [\***type parameters** _](../programming-guide/generics/index.md).</span></span> <span data-ttu-id="e68ae-130">Tür parametreleri, açılı ayraçlar içine alınmış tür parametre adlarının bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-130">Type parameters are a list of type parameter names enclosed in angle brackets.</span></span> <span data-ttu-id="e68ae-131">Tür parametreleri sınıf adını izler.</span><span class="sxs-lookup"><span data-stu-id="e68ae-131">Type parameters follow the class name.</span></span> <span data-ttu-id="e68ae-132">Daha sonra tür parametreleri sınıfının üyelerini tanımlamak için sınıf bildirimlerinin gövdesinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-132">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="e68ae-133">Aşağıdaki örnekte, öğesinin tür parametreleri `Pair` `TFirst` ve `TSecond` :</span><span class="sxs-lookup"><span data-stu-id="e68ae-133">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DefinePairClass":::

<span data-ttu-id="e68ae-134">Tür parametrelerini almak için belirtilen bir sınıf türüne, _generic sınıf türü \* denir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-134">A class type that is declared to take type parameters is called a _generic class type\*.</span></span> <span data-ttu-id="e68ae-135">Yapı, arabirim ve temsilci türleri de genel olabilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-135">Struct, interface, and delegate types can also be generic.</span></span>
<span data-ttu-id="e68ae-136">Genel sınıf kullanıldığında, tür parametrelerinin her biri için tür bağımsız değişkenlerinin sağlanması gerekir:</span><span class="sxs-lookup"><span data-stu-id="e68ae-136">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="CreatePairObject":::

<span data-ttu-id="e68ae-137">Yukarıda olduğu gibi, tür bağımsız değişkenlerine sahip genel bir tür, `Pair<int,string>` oluşturulmuş bir *tür* olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="e68ae-137">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

### <a name="base-classes"></a><span data-ttu-id="e68ae-138">Temel sınıflar</span><span class="sxs-lookup"><span data-stu-id="e68ae-138">Base classes</span></span>

<span data-ttu-id="e68ae-139">Sınıf bildirimi, bir temel sınıf belirtebilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-139">A class declaration may specify a base class.</span></span> <span data-ttu-id="e68ae-140">Sınıf adını ve tür parametrelerini, iki nokta üst üste ve temel sınıfın adına uygulayın.</span><span class="sxs-lookup"><span data-stu-id="e68ae-140">Follow the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="e68ae-141">Temel sınıf belirtiminin atlanması, türden türetmeye benzer `object` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-141">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="e68ae-142">Aşağıdaki örnekte, öğesinin temel sınıfı `Point3D` olur `Point` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-142">In the following example, the base class of `Point3D` is `Point`.</span></span> <span data-ttu-id="e68ae-143">İlk örnekte, öğesinin temel sınıfı `Point` Şu şekilde olur `object` :</span><span class="sxs-lookup"><span data-stu-id="e68ae-143">From the first example, the base class of `Point` is `object`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="Create3DPoint":::

<span data-ttu-id="e68ae-144">Bir sınıf, temel sınıfının üyelerini devralır.</span><span class="sxs-lookup"><span data-stu-id="e68ae-144">A class inherits the members of its base class.</span></span> <span data-ttu-id="e68ae-145">Devralma, bir sınıfın temel sınıfının neredeyse tüm üyelerini dolaylı olarak içerdiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-145">Inheritance means that a class implicitly contains almost all members of its base class.</span></span> <span data-ttu-id="e68ae-146">Bir sınıf örneği ve statik oluşturucuları ve sonlandırıcıyı almaz.</span><span class="sxs-lookup"><span data-stu-id="e68ae-146">A class doesn't inherit the instance and static constructors, and the finalizer.</span></span> <span data-ttu-id="e68ae-147">Türetilmiş bir sınıf, devraldığı üyelere yeni üyeler ekleyebilir, ancak devralınan bir üyenin tanımını kaldıramıyorum.</span><span class="sxs-lookup"><span data-stu-id="e68ae-147">A derived class can add new members to those members it inherits, but it can't remove the definition of an inherited member.</span></span> <span data-ttu-id="e68ae-148">Önceki örnekte, `Point3D` `X` ve `Y` üyelerini devralır `Point` ve her `Point3D` örnek üç özellik içerir,, `X` `Y` ve `Z` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-148">In the previous example, `Point3D` inherits the `X` and `Y` members from `Point`, and every `Point3D` instance contains three properties, `X`, `Y`, and `Z`.</span></span>

<span data-ttu-id="e68ae-149">Bir sınıf türünden, temel sınıf türlerinden herhangi birine örtük bir dönüştürme vardır.</span><span class="sxs-lookup"><span data-stu-id="e68ae-149">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="e68ae-150">Bir sınıf türünün değişkeni, bu sınıfın bir örneğine veya türetilmiş herhangi bir sınıfın örneğine başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-150">A variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="e68ae-151">Örneğin, önceki sınıf bildirimleri verildiğinde, türünde bir değişken `Point` bir `Point` veya a başvurabilir `Point3D` :</span><span class="sxs-lookup"><span data-stu-id="e68ae-151">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplicitCastToBase":::

## <a name="structs"></a><span data-ttu-id="e68ae-152">Yapılar</span><span class="sxs-lookup"><span data-stu-id="e68ae-152">Structs</span></span>

<span data-ttu-id="e68ae-153">Sınıflar devralmayı ve çok biçimliliği destekleyen türleri tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-153">Classes define types that support inheritance and polymorphism.</span></span> <span data-ttu-id="e68ae-154">Bunlar, türetilmiş sınıfların hiyerarşileri temelinde gelişmiş davranışlar oluşturmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-154">They enable you to create sophisticated behaviors based on hierarchies of derived classes.</span></span> <span data-ttu-id="e68ae-155">Buna karşılık, [ \* **struct** _](../language-reference/builtin-types/struct.md) Types, birincil amacı veri değerlerini depolamak olan daha basit türlerdir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-155">By contrast, [\***struct** _](../language-reference/builtin-types/struct.md) types are simpler types whose primary purpose is to store data values.</span></span> <span data-ttu-id="e68ae-156">Yapılar temel bir tür bildiremeyebilir; örtülü olarak türeteler <xref:System.ValueType?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="e68ae-156">Structs can't declare a base type; they implicitly derive from <xref:System.ValueType?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e68ae-157">`struct`Bir türden başka türler türetilemiyor `struct` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-157">You can't derive other `struct` types from a `struct` type.</span></span> <span data-ttu-id="e68ae-158">Örtülü olarak mühürlenirler.</span><span class="sxs-lookup"><span data-stu-id="e68ae-158">They're implicitly sealed.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="PointStruct":::

## <a name="interfaces"></a><span data-ttu-id="e68ae-159">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="e68ae-159">Interfaces</span></span>

<span data-ttu-id="e68ae-160">[_*_Arabirim_*_](../programming-guide/interfaces/index.md) , sınıflar ve yapılar tarafından uygulanabilecek bir sözleşmeyi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-160">An [_*_interface_*_](../programming-guide/interfaces/index.md) defines a contract that can be implemented by classes and structs.</span></span> <span data-ttu-id="e68ae-161">Arabirim, Yöntemler, özellikler, olaylar ve Dizin oluşturucular içerebilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-161">An interface can contain methods, properties, events, and indexers.</span></span> <span data-ttu-id="e68ae-162">Bir arabirim genellikle tanımladığı üyelerin uygulamalarını sağlamaz; yalnızca arabirimini uygulayan sınıflar veya yapılar tarafından sağlanması gereken üyeleri belirtir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-162">An interface typically doesn't provide implementations of the members it defines—it merely specifies the members that must be supplied by classes or structs that implement the interface.</span></span>

<span data-ttu-id="e68ae-163">Arabirimler _*_birden fazla devralma_*_ kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-163">Interfaces may employ _*_multiple inheritance_*_.</span></span> <span data-ttu-id="e68ae-164">Aşağıdaki örnekte, arabirimi `IComboBox` hem hem de öğesinden devralır `ITextBox` `IListBox` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-164">In the following example, the interface `IComboBox` inherits from both `ITextBox` and `IListBox`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FirstInterfaces":::

<span data-ttu-id="e68ae-165">Sınıflar ve yapılar birden çok arabirim uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-165">Classes and structs can implement multiple interfaces.</span></span> <span data-ttu-id="e68ae-166">Aşağıdaki örnekte, sınıfı `EditBox` hem hem de uygular `IControl` `IDataBound` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-166">In the following example, the class `EditBox` implements both `IControl` and `IDataBound`.</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="ImplementInterfaces":::

<span data-ttu-id="e68ae-167">Bir sınıf veya yapı belirli bir arabirimi uygularsa, bu sınıfın veya yapının örnekleri örtülü olarak bu arabirim türüne dönüştürülebilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-167">When a class or struct implements a particular interface, instances of that class or struct can be implicitly converted to that interface type.</span></span> <span data-ttu-id="e68ae-168">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="e68ae-168">For example</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UseInterfaces":::

## <a name="enums"></a><span data-ttu-id="e68ae-169">Numaralandırmalar</span><span class="sxs-lookup"><span data-stu-id="e68ae-169">Enums</span></span>

<span data-ttu-id="e68ae-170">Sabit [_*_listesi_*_](../language-reference/builtin-types/enum.md) türü bir sabit değerler kümesini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-170">An [_*_Enum_*_](../language-reference/builtin-types/enum.md) type defines a set of constant values.</span></span> <span data-ttu-id="e68ae-171">Aşağıdaki, `enum` farklı kök vegetables değerlerini tanımlayan sabitleri bildirir:</span><span class="sxs-lookup"><span data-stu-id="e68ae-171">The following `enum` declares constants that define different root vegetables:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="EnumDeclaration":::

<span data-ttu-id="e68ae-172">Ayrıca, `enum` bayrak olarak birlikte kullanılacak bir de tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e68ae-172">You can also define an `enum` to be used in combination as flags.</span></span> <span data-ttu-id="e68ae-173">Aşağıdaki bildirim dört mevsimler için bir bayraklar kümesi bildirir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-173">The following declaration declares a set of flags for the four seasons.</span></span> <span data-ttu-id="e68ae-174">Tüm mevsimleri içeren bir değer de dahil olmak üzere mevsimlerin herhangi bir birleşimi uygulanabilir `All` :</span><span class="sxs-lookup"><span data-stu-id="e68ae-174">Any combination of the seasons may be applied, including an `All` value that includes all seasons:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="FlagsEnumDeclaration":::

<span data-ttu-id="e68ae-175">Aşağıdaki örnekte, önceki Numaralandırmaların bildirimleri gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="e68ae-175">The following example shows declarations of both the preceding enums:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="UsingEnums":::

## <a name="nullable-types"></a><span data-ttu-id="e68ae-176">Null atanabilir türler</span><span class="sxs-lookup"><span data-stu-id="e68ae-176">Nullable types</span></span>

<span data-ttu-id="e68ae-177">Herhangi bir türdeki değişkenler _*_null atanamaz_*_ veya _*_null yapılabilir_*_ olarak belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-177">Variables of any type may be declared as _*_non-nullable_*_ or _*_nullable_*_.</span></span> <span data-ttu-id="e68ae-178">Null atanabilir bir değişken `null` , değer olmadığını gösteren ek bir değer tutabilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-178">A nullable variable can hold an additional `null` value, indicating no value.</span></span> <span data-ttu-id="e68ae-179">Null yapılabilir değer türleri (yapılar veya numaralandırmalar) tarafından temsil edilir <xref:System.Nullable%601?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="e68ae-179">Nullable Value types (structs or enums) are represented by <xref:System.Nullable%601?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e68ae-180">Null yapılamayan ve Nullable başvuru türleri, her ikisi de temel alınan başvuru türü tarafından temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-180">Non-nullable and Nullable Reference types are both represented by the underlying reference type.</span></span> <span data-ttu-id="e68ae-181">Ayrım, derleyici tarafından okunan meta veriler ve bazı kitaplıklar tarafından temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-181">The distinction is represented by metadata read by the compiler and some libraries.</span></span> <span data-ttu-id="e68ae-182">Derleyici, null yapılabilir başvurular, önce değeri denetlenmeden başvurulduğunu uyarı verir `null` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-182">The compiler provides warnings when nullable references are dereferenced without first checking their value against `null`.</span></span> <span data-ttu-id="e68ae-183">Ayrıca, null yapılamayan başvurulara olabilecek bir değer atandığında derleyici de uyarılar sağlar `null` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-183">The compiler also provides warnings when non-nullable references are assigned a value that may be `null`.</span></span> <span data-ttu-id="e68ae-184">Aşağıdaki örnek, _*_null atanabilir bir int_*_ bildirir ve ' a başlatılıyor `null` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-184">The following example declares a _*_nullable int_*_, initializing it to `null`.</span></span> <span data-ttu-id="e68ae-185">Ardından, değerini olarak ayarlar `5` .</span><span class="sxs-lookup"><span data-stu-id="e68ae-185">Then, it sets the value to `5`.</span></span> <span data-ttu-id="e68ae-186">Aynı şekilde _*_null olabilen bir dize_*_ ile aynı kavramı gösterir.</span><span class="sxs-lookup"><span data-stu-id="e68ae-186">It demonstrates the same concept with a _*_nullable string_*_.</span></span> <span data-ttu-id="e68ae-187">Daha fazla bilgi için bkz. [Nullable değer türleri](../language-reference/builtin-types/nullable-value-types.md) ve [null yapılabilir başvuru türleri](../nullable-references.md).</span><span class="sxs-lookup"><span data-stu-id="e68ae-187">For more information, see [nullable value types](../language-reference/builtin-types/nullable-value-types.md) and [nullable reference types](../nullable-references.md).</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareNullable":::

## <a name="tuples"></a><span data-ttu-id="e68ae-188">Demetler</span><span class="sxs-lookup"><span data-stu-id="e68ae-188">Tuples</span></span>

<span data-ttu-id="e68ae-189">C#, hafif bir veri yapısındaki birden çok veri öğesini gruplamak için kısa sözdizimi sağlayan [_ *_tanımlama gruplarını_* \*](../language-reference/builtin-types/value-tuples.md)destekler.</span><span class="sxs-lookup"><span data-stu-id="e68ae-189">C# supports [_ *_tuples_*\*](../language-reference/builtin-types/value-tuples.md), which provides concise syntax to group multiple data elements in a lightweight data structure.</span></span> <span data-ttu-id="e68ae-190">`(` `)` Aşağıdaki örnekte gösterildiği gibi, ve arasındaki üyelerin türlerini ve adlarını bildirerek bir tanımlama grubu örneğini oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e68ae-190">You instantiate a tuple by declaring the types and names of the members between `(` and `)`, as shown in the following example:</span></span>

:::code language="csharp" source="./snippets/shared/Types.cs" ID="DeclareTuples":::

<span data-ttu-id="e68ae-191">Tanımlama grupları, bir sonraki makalede açıklanan yapı taşlarını kullanmadan, birden fazla üye içeren veri yapısına bir alternatif sağlar.</span><span class="sxs-lookup"><span data-stu-id="e68ae-191">Tuples provide an alternative for data structure with multiple members, without using the building blocks described in the next article.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="e68ae-192">[Önceki](index.md) 
> [Sonraki](program-building-blocks.md)</span><span class="sxs-lookup"><span data-stu-id="e68ae-192">[Previous](index.md)
[Next](program-building-blocks.md)</span></span>
