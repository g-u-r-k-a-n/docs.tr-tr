---
title: Etki alanı olayları. Tasarım ve uygulama
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmetleri mimarisi | Toplamalar arasında iletişim kurmak için önemli bir kavram olan etki alanı olaylarının derinlemesine bir görünümünü alın.
ms.date: 10/08/2018
ms.openlocfilehash: 0cc2072408e110d94b47bd47a9c337a604d4c1a3
ms.sourcegitcommit: e0803b8975d3eb12e735a5d07637020dd6dac5ef
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/01/2020
ms.locfileid: "89271782"
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="3677b-104">Etki alanı olayları: tasarım ve uygulama</span><span class="sxs-lookup"><span data-stu-id="3677b-104">Domain events: design and implementation</span></span>

<span data-ttu-id="3677b-105">Etki alanınız içindeki değişikliklerin yan etkilerini açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="3677b-105">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="3677b-106">Diğer bir deyişle ve DDD terminolojisini kullanarak, birden çok toplama arasında yan etkileri açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="3677b-106">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="3677b-107">İsteğe bağlı olarak, veritabanı kilitlerinde daha iyi ölçeklenebilirlik ve daha az etki sağlamak için aynı etki alanı içindeki toplamalar arasında nihai tutarlılığı kullanın.</span><span class="sxs-lookup"><span data-stu-id="3677b-107">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="3677b-108">Etki alanı olayı nedir?</span><span class="sxs-lookup"><span data-stu-id="3677b-108">What is a domain event?</span></span>

<span data-ttu-id="3677b-109">Bir olay geçmişte gerçekleşen bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="3677b-109">An event is something that has happened in the past.</span></span> <span data-ttu-id="3677b-110">Etki alanı olayı, etki alanında aynı etki alanının (işlem içi) diğer bölümlerinin farkında olmasını istediğiniz bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="3677b-110">A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of.</span></span> <span data-ttu-id="3677b-111">Bildirilen parçalar genellikle olaylara bir şekilde tepki verir.</span><span class="sxs-lookup"><span data-stu-id="3677b-111">The notified parts usually react somehow to the events.</span></span>

<span data-ttu-id="3677b-112">Etki alanı olaylarının önemli bir avantajı, yan etkilerin açık olarak ifade edilebilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-112">An important benefit of domain events is that side effects can be expressed explicitly.</span></span>

<span data-ttu-id="3677b-113">Örneğin, yalnızca Entity Framework kullanıyorsanız ve bazı olayların yeniden eylemde olması gerekiyorsa, büyük olasılıkla olayın tetiklediği her şeyi kodlıyoruz.</span><span class="sxs-lookup"><span data-stu-id="3677b-113">For example, if you're just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event.</span></span> <span data-ttu-id="3677b-114">Bu nedenle kural, örtülü olarak, koda bağlı ve koda bakmamız gerekir. Bu durumda, kuralın burada uygulandığını fark edersiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-114">So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</span></span>

<span data-ttu-id="3677b-115">Diğer taraftan, etki alanı olaylarının kullanılması kavramı açık hale getirir, çünkü bir `DomainEvent` ve en az bir tane vardır `DomainEventHandler` .</span><span class="sxs-lookup"><span data-stu-id="3677b-115">On the other hand, using domain events makes the concept explicit, because there is a `DomainEvent` and at least one `DomainEventHandler` involved.</span></span>

<span data-ttu-id="3677b-116">Örneğin, eShopOnContainers uygulamasında, bir sipariş oluşturulduğunda Kullanıcı bir alıcı haline gelir ve bu nedenle `OrderStartedDomainEvent` , `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler` temel kavramda etkin hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-116">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an `OrderStartedDomainEvent` is raised and handled in the `ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler`, so the underlying concept is evident.</span></span>

<span data-ttu-id="3677b-117">Kısaca etki alanı etkinlikleri, etki alanı uzmanları tarafından sağlanan ubititous diline bağlı olarak etki alanı kurallarını hızlı bir şekilde ifade etmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="3677b-117">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts.</span></span> <span data-ttu-id="3677b-118">Etki alanı olayları aynı etki alanındaki sınıflar arasındaki kaygıları daha iyi bir şekilde ayırmayı de olanaklı hale getirir.</span><span class="sxs-lookup"><span data-stu-id="3677b-118">Domain events also enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="3677b-119">Bir veritabanı işlemi gibi, bir etki alanı olay ile ilgili tüm işlemlerin başarıyla bitmesini veya hiçbirinin bitmemesini sağlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-119">It's important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</span></span>

<span data-ttu-id="3677b-120">Etki alanı olayları, önemli bir farklılık ile mesajlaşma stili olaylara benzerdir.</span><span class="sxs-lookup"><span data-stu-id="3677b-120">Domain events are similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="3677b-121">AMQP kullanan gerçek mesajlaşma, Message Queuing, ileti aracıları veya hizmet veri yolu ile bir ileti her zaman zaman uyumsuz olarak gönderilir ve süreçler ve makineler arasında iletilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-121">With real messaging, message queuing, message brokers, or a service bus using AMQP, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="3677b-122">Bu, birden çok sınırlanmış bağlamı, mikro hizmetleri ve hatta farklı uygulamaları tümleştirmek için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="3677b-123">Bununla birlikte, etki alanı olayları ile, çalıştırmakta olduğunuz etki alanı işleminden bir olay yükseltmek istersiniz, ancak herhangi bir yan etkilerin aynı etki alanı içinde gerçekleşmesini istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="3677b-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="3677b-124">Etki alanı olayları ve yan etkileri (daha sonra olay işleyicileri tarafından yönetilen eylemler) hemen hemen, işlem içi ve aynı etki alanı içinde gerçekleşmelidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="3677b-125">Bu nedenle, etki alanı olayları zaman uyumlu veya zaman uyumsuz olabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="3677b-126">Ancak, tümleştirme olayları her zaman zaman uyumsuz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="3677b-127">Etki alanı olayları ve tümleştirme olayları</span><span class="sxs-lookup"><span data-stu-id="3677b-127">Domain events versus integration events</span></span>

<span data-ttu-id="3677b-128">Anlam, etki alanı ve tümleştirme olayları aynı şeydir: yalnızca gerçekleşen bir şey hakkında bildirimler.</span><span class="sxs-lookup"><span data-stu-id="3677b-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="3677b-129">Ancak, bunların uygulamaları farklı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-129">However, their implementation must be different.</span></span> <span data-ttu-id="3677b-130">Etki alanı olayları yalnızca bir etki alanı olay dağıtıcısına gönderilen iletilerdir. Bu, bir IOC kapsayıcısına veya başka bir yönteme bağlı olarak bellek içi bir Mediator olarak uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="3677b-131">Diğer yandan, tümleştirme olaylarının amacı, diğer mikro hizmetler, sınırlı bağlamlar veya hatta dış uygulamalar gibi diğer alt sistemlere uygulanan işlem ve güncelleştirmeleri yaymaya yönelik olur.</span><span class="sxs-lookup"><span data-stu-id="3677b-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="3677b-132">Bu nedenle, bu, yalnızca varlık başarıyla kalıcı olduğunda gerçekleşmelidir, aksi takdirde işlemin tamamı asla gerçekleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-132">Hence, they should occur only if the entity is successfully persisted, otherwise it's as if the entire operation never happened.</span></span>

<span data-ttu-id="3677b-133">Daha önce bahsedildiği gibi, tümleştirme olayları birden çok mikro hizmet (diğer sınırlanmış bağlamlar) veya hatta dış sistem/uygulama arasındaki zaman uyumsuz iletişimi temel almalıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-133">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span>

<span data-ttu-id="3677b-134">Bu nedenle, olay veri yolu arabirimine, uzak hizmetler arasında işlemler arası ve dağıtılmış iletişime izin veren bir altyapı gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="3677b-135">Bu, ticari bir hizmet veri yoluna, kuyruklara, posta kutusu olarak kullanılan paylaşılan bir veritabanına veya diğer dağıtılmış ve ideal gönderim tabanlı mesajlaşma sistemine dayalı olabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="3677b-136">Aynı etki alanı içindeki birden çok toplama arasında yan etkileri tetiklemenin tercih edilen bir yolu olarak etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="3677b-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="3677b-137">Bir toplu örnekle ilişkili bir komut yürütülebilmeniz için bir veya daha fazla ek toplama üzerinde ek etki alanı kurallarının çalıştırılmasını gerektiriyorsa, bu yan etkileri, etki alanı olayları tarafından tetiklenecek şekilde tasarlamanız ve uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="3677b-138">Şekil 7-14 ' de gösterildiği gibi ve en önemli kullanım çalışmalarından biri olarak, aynı etki alanı modeli içindeki birden çok toplama arasında durum değişikliklerini yaymak için bir etki alanı olayının kullanılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-138">As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![Bir alıcı toplamasına veri denetleyen bir etki alanı olayını gösteren diyagram.](./media/domain-events-design-implementation/domain-model-ordering-microservice.png)

<span data-ttu-id="3677b-140">**Şekil 7-14**.</span><span class="sxs-lookup"><span data-stu-id="3677b-140">**Figure 7-14**.</span></span> <span data-ttu-id="3677b-141">Aynı etki alanı içinde birden çok toplama arasında tutarlılığı zorlamak için etki alanı olayları</span><span class="sxs-lookup"><span data-stu-id="3677b-141">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="3677b-142">Şekil 7-14, toplamalar arasındaki tutarlılığı etki alanı olayları tarafından nasıl elde edildiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="3677b-142">Figure 7-14 shows how consistency between aggregates is achieved by domain events.</span></span> <span data-ttu-id="3677b-143">Kullanıcı bir sipariş başlattığında sıra toplaması bir `OrderStarted` etki alanı olayı gönderir.</span><span class="sxs-lookup"><span data-stu-id="3677b-143">When the user initiates an order, the Order Aggregate sends an `OrderStarted` domain event.</span></span> <span data-ttu-id="3677b-144">OrderStarted etki alanı olayı, alıcı toplama tarafından, kimlik mikro hizmetindeki özgün kullanıcı bilgilerine göre (CreateOrder komutunda belirtilen bilgiler ile) sıralama mikro hizmetinde bir alıcı nesnesi oluşturmak için işlenir.</span><span class="sxs-lookup"><span data-stu-id="3677b-144">The OrderStarted domain event is handled by the Buyer Aggregate to create a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span>

<span data-ttu-id="3677b-145">Alternatif olarak, toplama kökünün toplamaların (alt varlıklar) üyeleri tarafından oluşturulan olaylar için abone olmasını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-145">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="3677b-146">Örneğin, her OrderItem alt varlığı, öğe fiyatı belirli bir tutardan yüksek olduğunda veya ürün öğesi miktarı çok yüksek olduğunda bir olay oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-146">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="3677b-147">Toplam kök, daha sonra bu olayları alabilir ve küresel bir hesaplama veya toplama gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-147">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="3677b-148">Bu olay tabanlı iletişimin doğrudan toplamalar içinde uygulanmadığını anlamak önemlidir; etki alanı olay işleyicilerini uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-148">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span>

<span data-ttu-id="3677b-149">Etki alanı olaylarını işlemek bir uygulama konusudur.</span><span class="sxs-lookup"><span data-stu-id="3677b-149">Handling the domain events is an application concern.</span></span> <span data-ttu-id="3677b-150">Etki alanı modeli katmanı yalnızca etki alanı mantığına odaklanmalıdır — bir etki alanı uzmanının, depolar gibi uygulama altyapısını ve depoları kullanarak yan etkisi Kalıcılık eylemlerini değil.</span><span class="sxs-lookup"><span data-stu-id="3677b-150">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="3677b-151">Bu nedenle, uygulama katmanı düzeyi, etki alanı olayı tetiklendiğinde etki alanı olay işleyicilerinin eylemleri tetiklemedir.</span><span class="sxs-lookup"><span data-stu-id="3677b-151">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="3677b-152">Etki alanı olayları, herhangi bir sayıda uygulama eylemini tetiklemek için de kullanılabilir ve daha fazla önemli olan bu sayının gelecekte ayrılmış bir şekilde artması için açık olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-152">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="3677b-153">Örneğin, sipariş başlatıldığında, bu bilgileri diğer toplamalara yaymak veya bildirimler gibi uygulama eylemlerini yükseltmek için bir etki alanı olayı yayımlamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-153">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="3677b-154">Anahtar noktası, bir etki alanı olayı gerçekleştiğinde yürütülecek eylemlerin açık sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-154">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="3677b-155">Sonuç olarak, etki alanı ve uygulamadaki eylemler ve kurallar büyüyecektir.</span><span class="sxs-lookup"><span data-stu-id="3677b-155">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="3677b-156">Bir şeyin anlamı artar, ancak kodunuz "tutkalla" (diğer bir deyişle, ile belirli nesneler oluşturma) ile birlikte kullanıldığında, `new` çalışan ve test edilmiş kodu değiştirmeniz gerekir. Ayrıca, çalışma ve test edilen kodu değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-156">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with "glue" (that is, creating specific objects with `new`), then every time you needed to add a new action you would also need to change working and tested code.</span></span>

<span data-ttu-id="3677b-157">Bu değişiklik yeni hatalara neden olabilir ve bu yaklaşım da [kesintisiz](https://en.wikipedia.org/wiki/SOLID) [açık/kapalı ilkesine](https://en.wikipedia.org/wiki/Open/closed_principle) karşı gider.</span><span class="sxs-lookup"><span data-stu-id="3677b-157">This change could result in new bugs and this approach also goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID).</span></span> <span data-ttu-id="3677b-158">Yalnızca, işlemleri düzenleyen özgün sınıf, [tek sorumluluk prensibi (SRP) Ile aynı](https://en.wikipedia.org/wiki/Single_responsibility_principle)şekilde büyütülür ve büyümeye devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="3677b-158">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="3677b-159">Diğer taraftan, etki alanı olaylarını kullanıyorsanız, sorumlulukları Bu yaklaşımla ayırarak ayrıntılı ve ayrılmış bir uygulama oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="3677b-159">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1. <span data-ttu-id="3677b-160">Bir komut (örneğin, CreateOrder) gönderin.</span><span class="sxs-lookup"><span data-stu-id="3677b-160">Send a command (for example, CreateOrder).</span></span>
2. <span data-ttu-id="3677b-161">Komutu bir komut işleyicisinde alın.</span><span class="sxs-lookup"><span data-stu-id="3677b-161">Receive the command in a command handler.</span></span>
   - <span data-ttu-id="3677b-162">Tek bir toplamanın işlemini yürütün.</span><span class="sxs-lookup"><span data-stu-id="3677b-162">Execute a single aggregate's transaction.</span></span>
   - <span data-ttu-id="3677b-163">Seçim Yan etkilere yönelik etki alanı olaylarını yükseltin (örneğin, OrderStartedDomainEvent).</span><span class="sxs-lookup"><span data-stu-id="3677b-163">(Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</span></span>
3. <span data-ttu-id="3677b-164">Çoklu toplamalarda veya uygulama eylemlerinde açık sayıda yan efekt yürütecek olan etki alanı olaylarını (geçerli işlem dahilinde) işleyin.</span><span class="sxs-lookup"><span data-stu-id="3677b-164">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="3677b-165">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="3677b-165">For example:</span></span>
   - <span data-ttu-id="3677b-166">Alıcı ve ödeme yöntemini doğrulayın veya oluşturun.</span><span class="sxs-lookup"><span data-stu-id="3677b-166">Verify or create buyer and payment method.</span></span>
   - <span data-ttu-id="3677b-167">Olayları mikro hizmetlere yaymak veya alıcıya e-posta gönderme gibi dış eylemleri tetiklemek için olay veri yoluna ilgili bir tümleştirme olayı oluşturun ve gönderin.</span><span class="sxs-lookup"><span data-stu-id="3677b-167">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
   - <span data-ttu-id="3677b-168">Diğer yan etkileri işleyin.</span><span class="sxs-lookup"><span data-stu-id="3677b-168">Handle other side effects.</span></span>

<span data-ttu-id="3677b-169">Şekil 7-15 ' de gösterildiği gibi, aynı etki alanı olayından başlayarak, etki alanındaki diğer toplalarla ilgili birden çok eylemi veya tümleştirme olayları ve olay veri yolu ile bağlantı kurarak mikro hizmetler genelinde gerçekleştirmeniz gereken ek uygulama eylemlerini işleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-169">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![Birkaç olay işleyicisine veri geçiren bir etki alanı olayını gösteren diyagram.](./media/domain-events-design-implementation/aggregate-domain-event-handlers.png)

<span data-ttu-id="3677b-171">**Şekil 7-15**.</span><span class="sxs-lookup"><span data-stu-id="3677b-171">**Figure 7-15**.</span></span> <span data-ttu-id="3677b-172">Etki alanı başına birden çok eylemi işleme</span><span class="sxs-lookup"><span data-stu-id="3677b-172">Handling multiple actions per domain</span></span>

<span data-ttu-id="3677b-173">Uygulama katmanında aynı etki alanı olayı için birkaç işleyici olabilir. bir işleyici, toplamalar arasındaki tutarlılığı çözebileceği gibi, başka bir işleyici de bir tümleştirme olayı yayımlayabilir, böylece diğer mikro hizmetler onunla ilgili bir işlem yapabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-173">There can be several handlers for the same domain event in the Application Layer, one handler can solve consistency between aggregates and another handler can publish an integration event, so other microservices can do something with it.</span></span> <span data-ttu-id="3677b-174">Olay işleyicileri genellikle uygulama katmanında bulunur çünkü, mikro hizmet davranışı için depolar veya bir uygulama API 'SI gibi altyapı nesneleri kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="3677b-174">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice's behavior.</span></span> <span data-ttu-id="3677b-175">Bu anlamda, olay işleyicileri komut işleyicileriyle benzerdir, bu nedenle her ikisi de uygulama katmanının bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-175">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="3677b-176">Önemli fark, bir komutun yalnızca bir kez işlenmesi gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-176">The important difference is that a command should be processed only once.</span></span> <span data-ttu-id="3677b-177">Her işleyici için farklı bir amaçla birden çok alıcı veya olay işleyicisi tarafından alınabileceğinden, bir etki alanı olayı sıfır veya *n* kez işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-177">A domain event could be processed zero or *n* times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="3677b-178">Etki alanı başına açık sayıda işleyicinin olması, mevcut kodu etkilemeden gereken sayıda etki alanı kuralı eklemenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="3677b-178">Having an open number of handlers per domain event allows you to add as many domain rules as needed, without affecting  current code.</span></span> <span data-ttu-id="3677b-179">Örneğin, aşağıdaki iş kuralının uygulanması çok sayıda olay işleyicisi (ya da yalnızca bir tane) eklemek kadar kolay olabilir:</span><span class="sxs-lookup"><span data-stu-id="3677b-179">For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</span></span>

> <span data-ttu-id="3677b-180">Mağazadaki bir müşteri tarafından satın alınan toplam miktar, herhangi bir sayıda sipariş için $6.000 değerini aşarsa, her yeni siparişe %10 kapalı indirimi uygular ve gelecekteki siparişler için bu indirimle ilgili bir e-posta ile müşteriyi bilgilendirir.</span><span class="sxs-lookup"><span data-stu-id="3677b-180">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implement-domain-events"></a><span data-ttu-id="3677b-181">Etki alanı olaylarını uygulama</span><span class="sxs-lookup"><span data-stu-id="3677b-181">Implement domain events</span></span>

<span data-ttu-id="3677b-182">C# ' de, bir etki alanı olayı, aşağıdaki örnekte gösterildiği gibi, etki alanında gerçekleşdiklerle ilgili tüm bilgileri içeren bir veri tutan yapı veya sınıf olur.</span><span class="sxs-lookup"><span data-stu-id="3677b-182">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : INotification
{
    public string UserId { get; }
    public int CardTypeId { get; }
    public string CardNumber { get; }
    public string CardSecurityNumber { get; }
    public string CardHolderName { get; }
    public DateTime CardExpiration { get; }
    public Order Order { get; }

    public OrderStartedDomainEvent(Order order,
                                   int cardTypeId, string cardNumber,
                                   string cardSecurityNumber, string cardHolderName,
                                   DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="3677b-183">Bu aslında, OrderStarted olayı ile ilgili tüm verileri tutan bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="3677b-183">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="3677b-184">Etki alanının ubititous dili açısından, bir olay geçmişte gerçekleşen bir şey olduğundan, olayın sınıf adı OrderStartedDomainEvent veya OrderShippedDomainEvent gibi bir geçmiş-zaman hali fiili olarak temsil edilmelidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-184">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="3677b-185">Bu, etki alanı olayının eShopOnContainers 'daki sıralama mikro hizmetinde nasıl uygulandığı.</span><span class="sxs-lookup"><span data-stu-id="3677b-185">That's how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="3677b-186">Daha önce belirtildiği gibi, olayların önemli bir özelliği, bir olayın geçmişte gerçekleşen bir şey olduğundan, değişmemelidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-186">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="3677b-187">Bu nedenle, sabit bir sınıf olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-187">Therefore, it must be an immutable class.</span></span> <span data-ttu-id="3677b-188">Önceki kodda, özelliklerin salt okunurdur.</span><span class="sxs-lookup"><span data-stu-id="3677b-188">You can see in the previous code that the properties are read-only.</span></span> <span data-ttu-id="3677b-189">Nesneyi güncelleştirmenin bir yolu yoktur, yalnızca oluşturma sırasında değerleri ayarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-189">There's no way to update the object, you can only set values when you create it.</span></span>

<span data-ttu-id="3677b-190">Burada, etki alanı olaylarının zaman uyumsuz olarak işlenebileceği, olay nesnelerinin serileştirilmesi ve serisini kaldırmada gerekli olan bir kuyruk kullanılarak, özelliklerin salt okuma yerine "özel küme" olması gerekir, bu nedenle seri hale getirici, kaldırma işlemleri sonrasında değerleri atayabilecektir.</span><span class="sxs-lookup"><span data-stu-id="3677b-190">It's important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be "private set" instead of read-only, so the deserializer would be able to assign the values upon dequeuing.</span></span> <span data-ttu-id="3677b-191">Etki alanı olay pub/Sub, MediatR kullanılarak eşzamanlı olarak uygulandığından, bu sıralama mikro hizmetindeki bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="3677b-191">This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</span></span>

### <a name="raise-domain-events"></a><span data-ttu-id="3677b-192">Etki alanı olaylarını Yükselt</span><span class="sxs-lookup"><span data-stu-id="3677b-192">Raise domain events</span></span>

<span data-ttu-id="3677b-193">Sonraki soru, bir etki alanı olayının ilgili olay işleyicilerine ulaşmasını sağlayacak şekilde nasıl tetiklemedir.</span><span class="sxs-lookup"><span data-stu-id="3677b-193">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="3677b-194">Birden çok yaklaşımdan yararlanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-194">You can use multiple approaches.</span></span>

<span data-ttu-id="3677b-195">UDI Dahan başlangıçta önerilir (örneğin, [etki alanı olayları](https://udidahan.com/2008/08/25/domain-events-take-2/)gibi bazı ilgili gönderilerde) olayları yönetmek ve yükseltmek için statik bir sınıf kullanın.</span><span class="sxs-lookup"><span data-stu-id="3677b-195">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](https://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="3677b-196">Bu, DomainEvents adlı statik bir sınıfı içerebilir ve bu, etki alanı olaylarını, çağrıldığında, gibi bir sözdizimi kullanarak bir şekilde doğrudan tetikleyebilir `DomainEvents.Raise(Event myEvent)` .</span><span class="sxs-lookup"><span data-stu-id="3677b-196">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like `DomainEvents.Raise(Event myEvent)`.</span></span> <span data-ttu-id="3677b-197">Jimmy Bogard, benzer bir yaklaşım öneren bir blog gönderisi ([etki alanınızı güçleyebilirsiniz: etki alanı olayları](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) yazdı.</span><span class="sxs-lookup"><span data-stu-id="3677b-197">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="3677b-198">Ancak, etki alanı olayları sınıfı statikse, Ayrıca, işleyiciler için hemen de dağıtım yapılır.</span><span class="sxs-lookup"><span data-stu-id="3677b-198">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="3677b-199">Bu, test ve hata ayıklamayı daha zor hale getirir, çünkü yan etkileri olan olay işleyicileri olay oluşturulduktan hemen sonra yürütülür.</span><span class="sxs-lookup"><span data-stu-id="3677b-199">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="3677b-200">Test ve hata ayıklama yaparken, üzerine odaklanmak ve yalnızca geçerli toplama sınıflarında neler olduğunu yapmak istersiniz; başka toplamalar veya uygulama mantığı ile ilgili yan etkileri için aniden başka olay işleyicilerine yeniden yönlendirilmek istemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-200">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="3677b-201">Sonraki bölümde açıklandığı gibi diğer yaklaşımların gelişmesinin nedeni budur.</span><span class="sxs-lookup"><span data-stu-id="3677b-201">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-to-raise-and-dispatch-events"></a><span data-ttu-id="3677b-202">Olayları yükseltme ve gönderme için ertelenmiş yaklaşım</span><span class="sxs-lookup"><span data-stu-id="3677b-202">The deferred approach to raise and dispatch events</span></span>

<span data-ttu-id="3677b-203">Bir etki alanı olay işleyicisine hemen dağıtım yapmak yerine, etki alanı olaylarını bir koleksiyona eklemek ve ardından işlem *tamamlandıktan sonra* bu etki alanı olaylarını *doğrudan* veya *sağ* bir şekilde göndermek için daha iyi bir yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="3677b-203">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="3677b-204">(Bu yaklaşım [daha Iyi bir etki alanı olayları deseninin](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)bulunduğu bu postadaki cemy Bogard tarafından açıklanmıştı.)</span><span class="sxs-lookup"><span data-stu-id="3677b-204">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="3677b-205">Aynı işlemin parçası olarak veya farklı işlemlerde yan etkileri dahil edilip edilmeyeceğini belirlediği için, işlem tamamlandıktan sonra etki alanı olaylarını hemen önce veya sağa göndermenizden karar vermek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-205">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="3677b-206">İkinci durumda, birden çok toplama arasında nihai tutarlılık ile uğraşmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-206">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="3677b-207">Bu konu, sonraki bölümde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="3677b-207">This topic is discussed in the next section.</span></span>

<span data-ttu-id="3677b-208">Ertelenmiş yaklaşım eShopOnContainers 'ın kullandığı şeydir.</span><span class="sxs-lookup"><span data-stu-id="3677b-208">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="3677b-209">İlk olarak, varlıklarınızda oluşan olayları, varlık başına bir koleksiyona veya olay listesine eklersiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-209">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="3677b-210">Bu liste, varlık temel sınıfının aşağıdaki örneğinde gösterildiği gibi, temel varlık sınıfınızın bir parçası olan varlık nesnesinin bir parçası olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="3677b-210">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example of the Entity base class:</span></span>

```csharp
public abstract class Entity
{
     //...
     private List<INotification> _domainEvents;
     public List<INotification> DomainEvents => _domainEvents;

     public void AddDomainEvent(INotification eventItem)
     {
         _domainEvents = _domainEvents ?? new List<INotification>();
         _domainEvents.Add(eventItem);
     }

     public void RemoveDomainEvent(INotification eventItem)
     {
         _domainEvents?.Remove(eventItem);
     }
     //... Additional code
}
```

<span data-ttu-id="3677b-211">Bir olayı yükseltmek istediğinizde, bunu yalnızca toplu kök varlığın herhangi bir yöntemindeki koddan olay koleksiyonuna eklersiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-211">When you want to raise an event, you just add it to the event collection from code at any method of the aggregate-root entity.</span></span>

<span data-ttu-id="3677b-212">Aşağıdaki kod, [eShopOnContainers 'Da Order Aggregate kökünün](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs)bir parçası olarak bir örnek gösterir:</span><span class="sxs-lookup"><span data-stu-id="3677b-212">The following code, part of the [Order aggregate-root at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs), shows an example:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
                                                          cardTypeId, cardNumber,
                                                          cardSecurityNumber,
                                                          cardHolderName,
                                                          cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="3677b-213">AddDomainEvent yönteminin yaptığı tek şey listeye bir olay eklemediğine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="3677b-213">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="3677b-214">Henüz hiçbir olay dağıtılamadı ve henüz hiçbir olay işleyicisi çağrılmamıştır.</span><span class="sxs-lookup"><span data-stu-id="3677b-214">No event is dispatched yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="3677b-215">İşlemleri veritabanına kaydederken, gerçekten üzerine olayları göndermek istersiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-215">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="3677b-216">Entity Framework Core kullanıyorsanız, bu, aşağıdaki kodda olduğu gibi EF DbContext 'in SaveChanges yönteminde olduğu anlamına gelir:</span><span class="sxs-lookup"><span data-stu-id="3677b-216">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default(CancellationToken))
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);

        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be committed
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="3677b-217">Bu kodla, varlık olaylarını ilgili olay işleyicileriyle birlikte ileolursunuz.</span><span class="sxs-lookup"><span data-stu-id="3677b-217">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="3677b-218">Genel sonuç olarak, bir etki alanı olayının (bellekte bir listeye basit bir ekleme) bir olay işleyicisine gönderdikten sonra bir etki alanı olayının dağıtımını ayırmıştır.</span><span class="sxs-lookup"><span data-stu-id="3677b-218">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="3677b-219">Ayrıca, kullanmakta olduğunuz Dispatcher türüne bağlı olarak olayları zaman uyumlu veya zaman uyumsuz olarak dağıtabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-219">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="3677b-220">İşlem sınırlarının burada önemli bir şekilde oynatılmakta olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="3677b-220">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="3677b-221">İş biriminiz ve işlem, birden fazla toplama yayılabildiği zaman (EF Core ve ilişkisel bir veritabanı kullanırken olduğu gibi), bu da iyi çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-221">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="3677b-222">Ancak işlem toplamalara yayılamaz, örneğin Azure CosmosDB gibi bir NoSQL veritabanı kullanırken, tutarlılığı sağlamak için ek adımlar uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-222">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure CosmosDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="3677b-223">Bu, kalıcılık Ignorance 'in evrensel olmadığı başka bir nedendir; Bu, kullandığınız depolama sistemine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-223">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="3677b-224">Toplamalar genelinde tek bir işlem, toplamalar arasında nihai tutarlılığa karşı</span><span class="sxs-lookup"><span data-stu-id="3677b-224">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="3677b-225">Toplamalar genelinde tek bir işlem yapılıp yapılmayacağını ve bu toplamalar genelinde nihai tutarlılığa bağlı olarak, bir controversıal.</span><span class="sxs-lookup"><span data-stu-id="3677b-225">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="3677b-226">Eric Evans ve Vaughn Verone gibi birçok DDD yazarı, bir işlemin = bir toplama olduğunu ve bu nedenle toplamalar arasında nihai tutarlılığın sonunda olduğunu belirten kuralı kabul ediyorum.</span><span class="sxs-lookup"><span data-stu-id="3677b-226">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="3677b-227">Örneğin, kitabın *etki alanı odaklı tasarımında*, Eric Evans şöyle diyor:</span><span class="sxs-lookup"><span data-stu-id="3677b-227">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

> <span data-ttu-id="3677b-228">Toplamaları kapsayan herhangi bir kuralın her zaman güncel olması beklenmez.</span><span class="sxs-lookup"><span data-stu-id="3677b-228">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="3677b-229">Olay işleme, toplu işlem veya diğer güncelleştirme mekanizmaları aracılığıyla, diğer bağımlılıklar belirli bir süre içinde çözülebilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-229">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="3677b-230">(sayfa 128)</span><span class="sxs-lookup"><span data-stu-id="3677b-230">(page 128)</span></span>

<span data-ttu-id="3677b-231">Vaughn versuz, aşağıdaki etkili toplama tasarımında şunu söylemiştir [. Bölüm II: toplamalar birlikte çalışır hale getirme](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="3677b-231">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

> <span data-ttu-id="3677b-232">Bu nedenle, bir toplu örnek üzerinde bir komut yürütülerek bir veya daha fazla toplamada ek iş kurallarının yürütülmesi gerekir, nihai tutarlılık kullanın \[ ... \] Bir DDD modelinde nihai tutarlılığı desteklemeye yönelik pratik bir yöntem vardır.</span><span class="sxs-lookup"><span data-stu-id="3677b-232">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="3677b-233">Toplama yöntemi bir veya daha fazla zaman uyumsuz aboneye teslim edilen zaman bir etki alanı olayını yayımlar.</span><span class="sxs-lookup"><span data-stu-id="3677b-233">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="3677b-234">Bu kalationale, birçok toplama veya varlığı kapsayan işlemler yerine hassas işlemleri benimseme tabanlıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-234">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="3677b-235">İkinci durumda, veritabanı kilitlerinin sayısının yüksek ölçeklenebilirlik gereksinimlerine sahip büyük ölçekli uygulamalarda önemli olacağı fikir.</span><span class="sxs-lookup"><span data-stu-id="3677b-235">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="3677b-236">Yüksek düzeyde ölçeklenebilir uygulamaların birden çok toplama arasında anlık işlem tutarlılığı olmaması, nihai tutarlılık kavramını kabul etmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="3677b-236">Embracing the fact that highly scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="3677b-237">Atomik değişiklikler genellikle işletme tarafından gerekli değildir ve belirli işlemler için atomik işlemler gerekip gerekmediğini söylemek için etki alanı uzmanlarının sorumluluğunda olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-237">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="3677b-238">Bir işlemin her zaman birden çok toplama arasında atomik bir işleme ihtiyacı varsa, toplamanız büyük veya doğru şekilde tasarlanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-238">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="3677b-239">Ancak, Jimmy Bogard gibi diğer geliştiriciler ve mimarlar, tek bir işlemi birkaç toplama arasında dağıtmayı, ancak yalnızca bu ek toplamalar aynı orijinal komutun yan etkileri ile ilgili olduğunda geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-239">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="3677b-240">Örneğin, [daha Iyi bir etki alanı olayları](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)düzeninde Bogard şöyle diyor:</span><span class="sxs-lookup"><span data-stu-id="3677b-240">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

> <span data-ttu-id="3677b-241">Genellikle, bir etki alanı olayının yan etkilerinin aynı mantıksal işlem içinde gerçekleşmesini istiyorum, ancak etki alanı olayını yükseltmek için aynı kapsamda olması gerekmez \[ ... \] İşleminizi işlemeden hemen önce, olaylarımızı ilgili işleyicilerle gönderiyoruz.</span><span class="sxs-lookup"><span data-stu-id="3677b-241">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="3677b-242">İlk işlemi gerçekleştirmeden *önce* etki alanı olaylarını dağıtırsanız, bu olayların yan etkilerinin aynı işleme dahil edilmesini istiyor olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-242">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="3677b-243">Örneğin, EF DbContext SaveChanges yöntemi başarısız olursa işlem, ilgili etki alanı olay işleyicileri tarafından uygulanan herhangi bir yan efekt işleminin sonucu da dahil olmak üzere tüm değişiklikleri geri alınacaktır.</span><span class="sxs-lookup"><span data-stu-id="3677b-243">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="3677b-244">Bunun nedeni, DbContext yaşam kapsamının varsayılan olarak "kapsamlıdır" olarak tanımlanmış olmasından kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="3677b-244">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="3677b-245">Bu nedenle, DbContext nesnesi aynı kapsam veya nesne grafiğinde oluşturulan birden çok depo nesnesi arasında paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="3677b-245">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="3677b-246">Bu saatle çakışan Web API 'SI veya MVC uygulamaları geliştirirken HttpRequest kapsamıyla birlikte.</span><span class="sxs-lookup"><span data-stu-id="3677b-246">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="3677b-247">Aslında, her iki yaklaşım (tek atomik işlem ve nihai tutarlılık) doğru olabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-247">Actually, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="3677b-248">Bu, etki alanı veya iş gereksinimlerinize ve etki alanı uzmanlarına sizi nasıl söylediğinize bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-248">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="3677b-249">Ayrıca, hizmetin ne kadar ölçeklenebilir olduğuna da bağlıdır (daha ayrıntılı işlemler veritabanı kilitleri açısından daha az etkiye sahiptir).</span><span class="sxs-lookup"><span data-stu-id="3677b-249">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="3677b-250">Ve bu, son tutarlılık, toplamalar genelinde olası tutarsızlıkları tespit etmek için daha karmaşık kod gerektirdiğinden ve telafi etme eylemlerini uygulama ihtiyacı olduğundan kodunuzda ne kadar yatırım yapmaya ihtiyacınız olduğuna bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-250">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="3677b-251">Değişiklikleri orijinal toplamalarda yürütmeniz ve daha sonra olaylar dağıtıldığınızda, bir sorun varsa ve olay işleyicileri yan etkileri işleiyorsa, toplamalar arasında tutarsızlıklara sahip olursunuz.</span><span class="sxs-lookup"><span data-stu-id="3677b-251">Consider that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, if there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="3677b-252">Telafi eylemlerine izin veren bir yol, etki alanı olaylarını, özgün işlemin bir parçası olacak şekilde ek veritabanı tablolarında depolarlar.</span><span class="sxs-lookup"><span data-stu-id="3677b-252">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="3677b-253">Daha sonra, tutarsızlıkları algılayan ve maaş eylemlerini çalıştıran bir toplu işlem, toplamların listesini toplamaların geçerli durumuyla karşılaştırarak gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="3677b-253">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="3677b-254">Telafi eylemleri, iş kullanıcısı ve etki alanı uzmanları ile tartışmak dahil olmak üzere, sizin tarafınızdan derin analiz gerektiren bir karmaşık konunun parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-254">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="3677b-255">Herhangi bir durumda, ihtiyacınız olan yaklaşımı seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-255">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="3677b-256">Ancak ilk ertelenmiş yaklaşım — işlemeden önce olayları oluştururken tek bir işlem kullanmanız gerekir. EF Core ve ilişkisel bir veritabanı kullanırken en basit yaklaşım olur.</span><span class="sxs-lookup"><span data-stu-id="3677b-256">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="3677b-257">Birçok iş durumunda uygulanması ve geçerli olması daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="3677b-257">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="3677b-258">Ayrıca, eShopOnContainers 'daki sıralama mikro hizmetinde kullanılan yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-258">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="3677b-259">Ancak bu olayları ilgili olay işleyicileriyle nasıl gerçekten gönderir?</span><span class="sxs-lookup"><span data-stu-id="3677b-259">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="3677b-260">`_mediator`Önceki örnekte gördüğünüz nesne nedir?</span><span class="sxs-lookup"><span data-stu-id="3677b-260">What's the `_mediator` object you see in the previous example?</span></span> <span data-ttu-id="3677b-261">Olaylar ile olay işleyicileri arasında eşleme yapmak için kullandığınız teknikler ve yapıtlar ile aynı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-261">It has to do with the techniques and artifacts you use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="3677b-262">Etki alanı olay dağıtıcısı: olaylardan olay işleyicilerine eşleme</span><span class="sxs-lookup"><span data-stu-id="3677b-262">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="3677b-263">Olayları dağıtmak veya yayımlamak için, her ilgili işleyicinin bu olaya göre onu alabilmesi ve yan etkileri işleyebilmesi için olayı yayımlayabilecek bir tür yapıya ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="3677b-263">Once you're able to dispatch or publish the events, you need some kind of artifact that will publish the event, so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="3677b-264">Bir yaklaşım, büyük olasılıkla bellek içi olaylara karşı bir hizmet veri yolu temel alınarak gerçek bir mesajlaşma sistemidir veya hatta bir olay veri yolundan biridir.</span><span class="sxs-lookup"><span data-stu-id="3677b-264">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="3677b-265">Ancak, bu olayları yalnızca aynı işlem içinde (diğer bir deyişle, aynı etki alanı ve uygulama katmanında) işlemeniz gerektiğinden, ilk durumda, gerçek mesajlaşma, etki alanı olaylarını işlemek için fazla sonlandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="3677b-265">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="3677b-266">Olayları birden çok olay işleyicisine eşlemenin bir diğer yolu da bir IOC kapsayıcısına kayıt türlerini kullanarak olayların nereye gönderdiğini dinamik olarak çıkarılabilmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="3677b-266">Another way to map events to multiple event handlers is by using types registration in an IoC container so you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="3677b-267">Diğer bir deyişle, belirli bir olayı hangi olay işleyicilerinin almak gerektiğini bilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-267">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="3677b-268">Şekil 7-16, bu yaklaşım için basitleştirilmiş bir yaklaşım gösterir.</span><span class="sxs-lookup"><span data-stu-id="3677b-268">Figure 7-16 shows a simplified approach for this approach.</span></span>

![Uygun işleyicilere olay gönderen bir etki alanı olay dağıtıcısı gösteren diyagram.](./media/domain-events-design-implementation/domain-event-dispatcher.png)

<span data-ttu-id="3677b-270">**Şekil 7-16**.</span><span class="sxs-lookup"><span data-stu-id="3677b-270">**Figure 7-16**.</span></span> <span data-ttu-id="3677b-271">IOC kullanarak etki alanı olay dağıtıcısı</span><span class="sxs-lookup"><span data-stu-id="3677b-271">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="3677b-272">Bu yaklaşımı kendiniz uygulamak için tüm sıhhi tesisat ve yapıtları oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-272">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="3677b-273">Ancak, kapsamakta olan IFC kapsayıcınızı kullanan [mediaTR](https://github.com/jbogard/MediatR) gibi kullanılabilir kitaplıkları da kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-273">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR) that uses your IoC container under the covers.</span></span> <span data-ttu-id="3677b-274">Bu nedenle, önceden tanımlanmış arabirimleri ve Mediator nesnesinin yayımlama/dağıtma yöntemlerini doğrudan kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="3677b-274">You can therefore directly use the predefined interfaces and the mediator object's publish/dispatch methods.</span></span>

<span data-ttu-id="3677b-275">Kodda, ilk olarak olay işleyicisi türlerini IOC kapsayıcısına kaydetmeniz gerekir, [Eshoponcontainers sıralama mikro hizmeti](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs)' nde aşağıdaki örnekte gösterildiği gibi:</span><span class="sxs-lookup"><span data-stu-id="3677b-275">In code, you first need to register the event handler types in your IoC container, as shown in the following example at [eShopOnContainers Ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Infrastructure/AutofacModules/MediatorModule.cs):</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement IAsyncNotificationHandler<>)
        // in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
                                       .GetTypeInfo().Assembly)
                                         .AsClosedTypesOf(typeof(IAsyncNotificationHandler<>));
        // Other registrations ...
    }
}
```

<span data-ttu-id="3677b-276">Kod önce işleyicileri (typeof (ValidateOrAddBuyerAggregateWhenXxxx) kullanarak etki alanı olay işleyicilerini içeren derlemeyi tanımlar, ancak derlemeyi bulmak için başka herhangi bir olay işleyicisini seçmiş olabilirsiniz).</span><span class="sxs-lookup"><span data-stu-id="3677b-276">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="3677b-277">Tüm olay işleyicileri ıasyncnotificationhandler arabirimini kullandığından, kod yalnızca bu türleri arar ve tüm olay işleyicilerini kaydeder.</span><span class="sxs-lookup"><span data-stu-id="3677b-277">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="3677b-278">Etki alanı olaylarına abone olma</span><span class="sxs-lookup"><span data-stu-id="3677b-278">How to subscribe to domain events</span></span>

<span data-ttu-id="3677b-279">MediatR kullandığınızda, her olay işleyicisi aşağıdaki kodda görebileceğiniz gibi ınocertificate parametresinin genel parametresinde sağlanmış bir olay türü kullanmalıdır:</span><span class="sxs-lookup"><span data-stu-id="3677b-279">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the INotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="3677b-280">Abonelik olarak kabul edilebilir olay ve olay işleyicisi arasındaki ilişkiye bağlı olarak, MediatR yapıtı her olay için tüm olay işleyicilerini bulabilir ve bu olay işleyicilerinin her birini tetikleyebilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-280">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each one of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="3677b-281">Etki alanı olaylarını işleme</span><span class="sxs-lookup"><span data-stu-id="3677b-281">How to handle domain events</span></span>

<span data-ttu-id="3677b-282">Son olarak, olay işleyicisi genellikle gerekli ek toplamaları elde etmek ve yan etki alanı mantığını yürütmek için altyapı depoları kullanan uygulama katmanı kodunu uygular.</span><span class="sxs-lookup"><span data-stu-id="3677b-282">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="3677b-283">[EShopOnContainers 'daki aşağıdaki etki alanı olay işleyicisi kodu](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs)bir uygulama örneği gösterir.</span><span class="sxs-lookup"><span data-stu-id="3677b-283">The following [domain event handler code at eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/DomainEventHandlers/OrderStartedEvent/ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler.cs), shows an implementation example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
                   : INotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;

    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // ...Parameter validations...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;

        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }

        buyer.VerifyOrAddPaymentMethod(cardTypeId,
                                       $"Payment Method on {DateTime.UtcNow}",
                                       orderStartedEvent.CardNumber,
                                       orderStartedEvent.CardSecurityNumber,
                                       orderStartedEvent.CardHolderName,
                                       orderStartedEvent.CardExpiration,
                                       orderStartedEvent.Order.Id);

        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer)
                                                                      : _buyerRepository.Add(buyer);

        await _buyerRepository.UnitOfWork
                .SaveEntitiesAsync();

        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="3677b-284">Altyapı kalıcılığı katmanının sonraki bölümünde açıklandığı gibi, önceki etki alanı olay işleyicisi kodu, uygulama katmanı kodu olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-284">The previous domain event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="3677b-285">Olay işleyicileri de diğer altyapı bileşenlerini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-285">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="3677b-286">Etki alanı olayları, mikro hizmet sınırlarının dışında yayımlanacak tümleştirme olayları oluşturabilir</span><span class="sxs-lookup"><span data-stu-id="3677b-286">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="3677b-287">Son olarak, bazı durumlarda olayları birden fazla mikro hizmette yaymaya isteyebileceğiniz bir bahsetmek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="3677b-287">Finally, it's important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="3677b-288">Bu yayma bir tümleştirme olayıdır ve belirli bir etki alanı olay işleyicisinden bir olay veri yolundan yayımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="3677b-288">That propagation is an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="3677b-289">Etki alanı olaylarında ekibinizle</span><span class="sxs-lookup"><span data-stu-id="3677b-289">Conclusions on domain events</span></span>

<span data-ttu-id="3677b-290">Belirtildiği gibi, etki alanınız içindeki değişikliklerin yan etkilerini açıkça uygulamak için etki alanı olaylarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="3677b-290">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="3677b-291">DDD terminolojisini kullanmak için etki alanı olaylarını kullanarak bir veya birden çok toplama arasında yan etkileri açıkça uygulayın.</span><span class="sxs-lookup"><span data-stu-id="3677b-291">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="3677b-292">Ayrıca, daha iyi ölçeklenebilirlik ve veritabanı kilitleri üzerinde daha az etki sağlamak için aynı etki alanı içindeki toplamalar arasında nihai tutarlılığı kullanın.</span><span class="sxs-lookup"><span data-stu-id="3677b-292">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

<span data-ttu-id="3677b-293">Başvuru uygulaması, tek bir işlem içinde etki alanı olaylarını, toplamalar arasında zaman uyumlu olarak yaymak için [mediaTR](https://github.com/jbogard/MediatR) kullanır.</span><span class="sxs-lookup"><span data-stu-id="3677b-293">The reference app uses [MediatR](https://github.com/jbogard/MediatR) to propagate domain events synchronously across aggregates, within a single transaction.</span></span> <span data-ttu-id="3677b-294">Ancak, son tutarlılığı kullanarak etki alanı olaylarını zaman uyumsuz olarak yaymak için [Kbbitmq](https://www.rabbitmq.com/) veya [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) gibi bazı AMQP uygulamasını da kullanabilirsiniz, ancak Yukarıda bahsedildiği gibi, bir başarısızlık durumunda telafi eylemlerine yönelik ihtiyacı göz önünde bulundurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="3677b-294">However, you could also use some AMQP implementation like [RabbitMQ](https://www.rabbitmq.com/) or [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) to propagate domain events asynchronously, using eventual consistency but, as mentioned above, you have to consider the need for compensatory actions in case of failures.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="3677b-295">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="3677b-295">Additional resources</span></span>

- <span data-ttu-id="3677b-296">**Greg başak. Etki alanı olayı nedir?**</span><span class="sxs-lookup"><span data-stu-id="3677b-296">**Greg Young. What is a Domain Event?**</span></span> \
  <https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf#page=25>

- <span data-ttu-id="3677b-297">**Jan Stenberg. Etki alanı olayları ve nihai tutarlılık** </span><span class="sxs-lookup"><span data-stu-id="3677b-297">**Jan Stenberg. Domain Events and Eventual Consistency** </span></span>\
  <https://www.infoq.com/news/2015/09/domain-events-consistency>

- <span data-ttu-id="3677b-298">**Jimmy Bogard. Daha iyi bir etki alanı olayları deseninin** </span><span class="sxs-lookup"><span data-stu-id="3677b-298">**Jimmy Bogard. A better domain events pattern** </span></span>\
  <https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/>

- <span data-ttu-id="3677b-299">**Vaughn versuz. Etkili toplu tasarım bölümü II: toplamalar birlikte çalışır hale getirme** </span><span class="sxs-lookup"><span data-stu-id="3677b-299">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together** </span></span>\
  [https://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf](https://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)

- <span data-ttu-id="3677b-300">**Jimmy Bogard. Etki alanınızı güçlendirerek: etki alanı etkinlikleri** </span><span class="sxs-lookup"><span data-stu-id="3677b-300">**Jimmy Bogard. Strengthening your domain: Domain Events** </span></span>\
  <https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>

- <span data-ttu-id="3677b-301">**Üzerinde bulunan Truong. Etki alanı olayları deseninin örneği** </span><span class="sxs-lookup"><span data-stu-id="3677b-301">**Tony Truong. Domain Events Pattern Example** </span></span>\
  <https://www.tonytruong.net/domain-events-pattern-example/>

- <span data-ttu-id="3677b-302">**UDI Dahan. Tamamen kapsüllenmiş etki alanı modelleri oluşturma** </span><span class="sxs-lookup"><span data-stu-id="3677b-302">**Udi Dahan. How to create fully encapsulated Domain Models** </span></span>\
  <https://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/>

- <span data-ttu-id="3677b-303">**UDI Dahan. Etki alanı olayları – 2. alın** </span><span class="sxs-lookup"><span data-stu-id="3677b-303">**Udi Dahan. Domain Events – Take 2** </span></span>\
  <https://udidahan.com/2008/08/25/domain-events-take-2/>

- <span data-ttu-id="3677b-304">**UDI Dahan. Etki alanı olayları-sallanmayı** </span><span class="sxs-lookup"><span data-stu-id="3677b-304">**Udi Dahan. Domain Events – Salvation** </span></span>\
  <https://udidahan.com/2009/06/14/domain-events-salvation/>

- <span data-ttu-id="3677b-305">**Jan kroni. Etki alanı olaylarını yayımlamayın, döndürün!**</span><span class="sxs-lookup"><span data-stu-id="3677b-305">**Jan Kronquist. Don't publish Domain Events, return them!**</span></span> \
  <https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/>

- <span data-ttu-id="3677b-306">**Cesar de La Torre. Etki alanı olayları ile DDD ve mikro hizmet mimarilerinde tümleştirme olayları** </span><span class="sxs-lookup"><span data-stu-id="3677b-306">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures** </span></span>\
  <https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/>

>[!div class="step-by-step"]
><span data-ttu-id="3677b-307">[Önceki](client-side-validation.md) 
> [Sonraki](infrastructure-persistence-layer-design.md)</span><span class="sxs-lookup"><span data-stu-id="3677b-307">[Previous](client-side-validation.md)
[Next](infrastructure-persistence-layer-design.md)</span></span>
