---
title: Modern masaüstü uygulamalarını geçirme
description: Modern masaüstü uygulamalarına yönelik geçiş süreci hakkında bilmeniz gereken her şey.
ms.date: 01/19/2021
ms.openlocfilehash: b5bea6e601dc040adfd8ed410320a3416cb3372e
ms.sourcegitcommit: 632818f4b527e5bf3c48fc04e0c7f3b4bdb8a248
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/20/2021
ms.locfileid: "98615769"
---
# <a name="migrating-modern-desktop-applications"></a><span data-ttu-id="757c4-103">Modern masaüstü uygulamalarını geçirme</span><span class="sxs-lookup"><span data-stu-id="757c4-103">Migrating Modern Desktop applications</span></span>

<span data-ttu-id="757c4-104">Bu bölümde, var olan bir uygulamayı .NET Framework .NET 'e geçirirken en yaygın sorunları ve sorunları araştırıyoruz.</span><span class="sxs-lookup"><span data-stu-id="757c4-104">In this chapter, we're exploring the most common issues and challenges you can face when migrating an existing application from .NET Framework to .NET.</span></span>

<span data-ttu-id="757c4-105">Karmaşık bir masaüstü uygulaması yalıtımta çalışmaz ve yerel makinede veya uzak bir sunucuda bulunabilecek alt sistemler ile ilgili bir tür etkileşime ihtiyaç duyuyor.</span><span class="sxs-lookup"><span data-stu-id="757c4-105">A complex desktop application doesn't work in isolation and needs some kind of interaction with subsystems that may reside on the local machine or on a remote server.</span></span> <span data-ttu-id="757c4-106">Büyük olasılıkla yerel olarak veya uzaktan bir kalıcılık depolaması olarak bağlanmak için bir tür veritabanına ihtiyacı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="757c4-106">It will probably need some kind of database to connect as a persistence storage either locally or remotely.</span></span> <span data-ttu-id="757c4-107">Internet ve hizmet odaklı mimarilerin yaptığı gibi, uygulamanızın uzak bir sunucuda veya bulutta bulunan bir hizmet sıralaması ile bağlantılı olması yaygındır.</span><span class="sxs-lookup"><span data-stu-id="757c4-107">With the raise of Internet and service-oriented architectures, it's common to have your application connected to some sort of service residing on a remote server or in the cloud.</span></span> <span data-ttu-id="757c4-108">Bazı işlevleri uygulamak için makine dosya sistemine erişmeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="757c4-108">You may need to access the machine file system to implement some functionality.</span></span> <span data-ttu-id="757c4-109">Alternatif olarak, uygulamanızın dışında bir COM nesnesi içinde bulunan bir işlev parçası kullanıyor olabilirsiniz, örneğin, kuruluşunuzda Office derlemelerini Tümleştirdiğiniz durumlarda yaygın bir senaryo olur.</span><span class="sxs-lookup"><span data-stu-id="757c4-109">Alternatively, maybe you're using a piece of functionality that resides inside a COM object outside your application, which is a common scenario if, for example, you're integrating Office assemblies in your app.</span></span>

<span data-ttu-id="757c4-110">Bunun yanı sıra, API yüzeyinde .NET Framework ve .NET tarafından sunulan farklar vardır ve .NET Framework sunulan bazı özellikler .NET üzerinde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="757c4-110">Besides, there are differences in the API surface that is exposed by .NET Framework and .NET, and some features that are available on .NET Framework aren't available on .NET.</span></span> <span data-ttu-id="757c4-111">Bu nedenle, bir geçiş planlarken bunları bilmeniz ve dikkate almanız önemlidir.</span><span class="sxs-lookup"><span data-stu-id="757c4-111">So, it's important for you to know and take them into account when planning a migration.</span></span>

## <a name="configuration-files"></a><span data-ttu-id="757c4-112">Yapılandırma dosyaları</span><span class="sxs-lookup"><span data-stu-id="757c4-112">Configuration files</span></span>

<span data-ttu-id="757c4-113">Yapılandırma dosyaları, çalışma zamanında okunan özellik kümelerini depolamayı ve bir veritabanının nerede bulunacağı veya bir döngünün kaç kez yürütüleceğini gösteren uygulamalarımızın davranışını etkileme olasılığını sunar.</span><span class="sxs-lookup"><span data-stu-id="757c4-113">Configuration files offer the possibility to store sets of properties that are read at run time and affect the behavior of our apps, such as where to locate a database or how many times to execute a loop.</span></span> <span data-ttu-id="757c4-114">Bu tekniğin, yeniden kodlanmadan ve yeniden derlemenize gerek kalmadan uygulamanın bazı yönlerini değiştiremeyeceğiniz bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="757c4-114">The beauty of this technique is that you can modify some aspects of the application without the need to recode and recompile.</span></span> <span data-ttu-id="757c4-115">Örneğin, aynı uygulama kodu bir geliştirme ortamında belirli bir yapılandırma değerleri kümesiyle ve farklı bir şekilde üretimde çalıştırıldığında bu yararlı gelir.</span><span class="sxs-lookup"><span data-stu-id="757c4-115">This comes in handy when, for example, the same app code runs on a development environment with a certain set of configuration values and in production with a different one.</span></span>

### <a name="configuration-on-net-framework"></a><span data-ttu-id="757c4-116">.NET Framework yapılandırma</span><span class="sxs-lookup"><span data-stu-id="757c4-116">Configuration on .NET Framework</span></span>

<span data-ttu-id="757c4-117">Çalışan bir .NET Framework masaüstü uygulamanız varsa, ad alanından sınıfından erişilen bir *app.config* dosyasına sahip olursunuz <xref:System.Configuration.AppSettingsSection> `System.Configuration` .</span><span class="sxs-lookup"><span data-stu-id="757c4-117">If you have a working .NET Framework desktop application, chances are you have an *app.config* file accessed through the <xref:System.Configuration.AppSettingsSection> class from the `System.Configuration` namespace.</span></span>

<span data-ttu-id="757c4-118">.NET Framework altyapısı içinde, üst öğelerinden özellikleri devralan yapılandırma dosyalarının bir hiyerarşisi vardır.</span><span class="sxs-lookup"><span data-stu-id="757c4-118">Within the .NET Framework infrastructure, there's a hierarchy of configuration files that inherit properties from its parents.</span></span> <span data-ttu-id="757c4-119">Herhangi bir alt yapılandırma dosyasında kullanılabilecek veya geçersiz kılınabilen birçok özellik ve yapılandırma bölümünü tanımlayan bir *machine.config* dosyası bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-119">You can find a *machine.config* file that defines many properties and configuration sections that can be used or overridden in any descendant configuration file.</span></span>

### <a name="configuration-on-net"></a><span data-ttu-id="757c4-120">.NET üzerinde yapılandırma</span><span class="sxs-lookup"><span data-stu-id="757c4-120">Configuration on .NET</span></span>

<span data-ttu-id="757c4-121">.NET dünyasında *machine.config* dosyası yoktur.</span><span class="sxs-lookup"><span data-stu-id="757c4-121">In the .NET world, there's no *machine.config* file.</span></span> <span data-ttu-id="757c4-122">Eski tip ad alanını kullanmaya devam edebilse de <xref:System.Configuration> , <xref:Microsoft.Extensions.Configuration> iyi sayıda geliştirme sunan modern 'e geçmeyi düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-122">And even though you can continue to use the old fashioned <xref:System.Configuration> namespace, you may consider switching to the modern <xref:Microsoft.Extensions.Configuration>, which offers a good number of enhancements.</span></span>

<span data-ttu-id="757c4-123">Yapılandırma API 'SI yapılandırma sağlayıcısı kavramını destekler, bu da yapılandırmayı yüklemek için kullanılacak veri kaynağını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="757c4-123">The configuration API supports the concept of configuration provider, which defines the data source to be used to load the configuration.</span></span> <span data-ttu-id="757c4-124">Farklı türlerde yerleşik sağlayıcılar vardır, örneğin:</span><span class="sxs-lookup"><span data-stu-id="757c4-124">There are different kinds of built-in providers, such as:</span></span>

- <span data-ttu-id="757c4-125">Bellek içi .NET nesneleri</span><span class="sxs-lookup"><span data-stu-id="757c4-125">In-memory .NET objects</span></span>
- <span data-ttu-id="757c4-126">INı dosyaları</span><span class="sxs-lookup"><span data-stu-id="757c4-126">INI files</span></span>
- <span data-ttu-id="757c4-127">JSON dosyaları</span><span class="sxs-lookup"><span data-stu-id="757c4-127">JSON files</span></span>
- <span data-ttu-id="757c4-128">XML dosyaları</span><span class="sxs-lookup"><span data-stu-id="757c4-128">XML files</span></span>
- <span data-ttu-id="757c4-129">Komut satırı bağımsız değişkenleri</span><span class="sxs-lookup"><span data-stu-id="757c4-129">Command-line arguments</span></span>
- <span data-ttu-id="757c4-130">Ortam değişkenleri</span><span class="sxs-lookup"><span data-stu-id="757c4-130">Environment variables</span></span>
- <span data-ttu-id="757c4-131">Şifrelenmiş kullanıcı deposu</span><span class="sxs-lookup"><span data-stu-id="757c4-131">Encrypted user store</span></span>

 <span data-ttu-id="757c4-132">Ya da kendi kendinizinkini oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-132">Or you can build your own.</span></span>

<span data-ttu-id="757c4-133">Yeni yapılandırma, çok düzeyli bir hiyerarşide gruplandırılabilen ad-değer çiftleri listesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="757c4-133">The new configuration allows a list of name-value pairs that can be grouped into a multi-level hierarchy.</span></span> <span data-ttu-id="757c4-134">Depolanan herhangi bir değer bir dizeye eşlenir ve ayarları özel bir düz eski CLR nesne (POCO) nesnesine serisini kaldırmanıza olanak sağlayan yerleşik bağlama desteği vardır.</span><span class="sxs-lookup"><span data-stu-id="757c4-134">Any stored value maps to a string, and there's built-in binding support that allows you to deserialize settings into a custom plain old CLR object (POCO) object.</span></span>

<span data-ttu-id="757c4-135"><xref:Microsoft.Extensions.Configuration.ConfigurationBuilder>Nesnesi, tercihinizi çözümlemek için öncelik kuralını kullanarak uygulamanız için ihtiyacınız olabilecek birçok yapılandırma sağlayıcısı eklemenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="757c4-135">The <xref:Microsoft.Extensions.Configuration.ConfigurationBuilder> object lets you add as many configuration providers you may need for your application, using a precedence rule to resolve preference.</span></span> <span data-ttu-id="757c4-136">Bu nedenle, kodunuzda eklediğiniz son sağlayıcı diğerlerini geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="757c4-136">So, the last provider you add in your code will override the others.</span></span> <span data-ttu-id="757c4-137">Geliştirme, test ve üretim ortamları için farklı konfigürasyonlar tanımlayabileceğinizden ve bunları kodunuzun içindeki tek bir işlevde yönetebilmeniz için, yürütme için farklı ortamları yönetmeye yönelik harika bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="757c4-137">This is a great feature for managing different environments for execution since you can define different configurations for development, testing and production environments, and manage them on a single function inside your code.</span></span>

### <a name="migrating-configuration-files"></a><span data-ttu-id="757c4-138">Yapılandırma dosyalarını geçirme</span><span class="sxs-lookup"><span data-stu-id="757c4-138">Migrating Configuration files</span></span>

<span data-ttu-id="757c4-139">Mevcut app.config XML dosyanızı kullanmaya devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-139">You can continue to use your existing app.config XML file.</span></span> <span data-ttu-id="757c4-140">Ancak, bu fırsatı .NET ' te yapılan çeşitli geliştirmelerden yararlanmak üzere geçirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-140">However, you could take this opportunity to migrate your configuration to benefit from the several enhancements made on .NET.</span></span>

<span data-ttu-id="757c4-141">Eski stil *app.config* yeni bir yapılandırma dosyasına geçirmek için, bir XML BIÇIMI ve JSON biçimi arasında seçim yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="757c4-141">To migrate from an old-style *app.config* to a new configuration file, you should choose between an XML format and a JSON format.</span></span>

<span data-ttu-id="757c4-142">XML seçerseniz, dönüştürme basittir.</span><span class="sxs-lookup"><span data-stu-id="757c4-142">If you choose XML, the conversion is straightforward.</span></span> <span data-ttu-id="757c4-143">İçerik aynı olduğundan, *app.config* dosyasını XML ile tür olarak kaydetmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-143">Since the content is the same, just save the *app.config* file with XML as type.</span></span> <span data-ttu-id="757c4-144">Daha sonra, sınıfını kullanmak için AppSettings 'e başvuran kodu değiştirin `ConfigurationBuilder` .</span><span class="sxs-lookup"><span data-stu-id="757c4-144">Then, change the code that references AppSettings to use the `ConfigurationBuilder` class.</span></span> <span data-ttu-id="757c4-145">Bu değişiklik kolay olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="757c4-145">This change should be easy.</span></span>

<span data-ttu-id="757c4-146">Bir JSON biçimi kullanmak istiyorsanız ve el ile geçiş yapmak istemiyorsanız, .NET 'te bir *app.config* dosyasını JSON yapılandırma dosyasına dönüştürebilen [DotNet-config2json](https://www.nuget.org/packages/dotnet-config2json/) adlı bir araç bulunmaktadır.</span><span class="sxs-lookup"><span data-stu-id="757c4-146">If you want to use a JSON format and you don't want to migrate by hand, there's a tool called [dotnet-config2json](https://www.nuget.org/packages/dotnet-config2json/) available on .NET that can convert an *app.config* file to a JSON configuration file.</span></span>

<span data-ttu-id="757c4-147">Ayrıca, *machine.config* dosyasında tanımlı yapılandırma bölümlerini kullanırken bazı sorunlarla karşılaşabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-147">You may also come across some issues when using configuration sections that were defined in the *machine.config* file.</span></span> <span data-ttu-id="757c4-148">Örneğin, aşağıdaki yapılandırmayı göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="757c4-148">For example, consider the following configuration:</span></span>

```xml
<configuration>
    <system.diagnostics>
        <switches>
            <add name="General" value="4" />
        </switches>
        <trace autoflush="true" indentsize="2">
            <listeners>
                <add name="myListener"
                     type="System.Diagnostics.TextWriterTraceListener,
                           System, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                     initializeData="MyListener.log"
                     traceOutputOptions="ProcessId, LogicalOperationStack, Timestamp, ThreadId, Callstack, DateTime" />
            </listeners>
        </trace>
    </system.diagnostics>
</configuration>
```

<span data-ttu-id="757c4-149">Bu yapılandırmayı bir .NET 'e alırsanız, bir özel durum alırsınız:</span><span class="sxs-lookup"><span data-stu-id="757c4-149">If you take this configuration to a .NET, you'll get an exception:</span></span>

> <span data-ttu-id="757c4-150">Tanınmayan yapılandırma bölümü System. Diagnostics</span><span class="sxs-lookup"><span data-stu-id="757c4-150">Unrecognized configuration section System.Diagnostics</span></span>

<span data-ttu-id="757c4-151">Bu özel durum, bu bölüm ve bu bölümün işlenmesinden sorumlu olan derleme *machine.config* dosyasında tanımlandığından, artık mevcut olmayan bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="757c4-151">This exception occurs because that section and the assembly responsible for handling that section was defined in the *machine.config* file, which now doesn't exist.</span></span>

<span data-ttu-id="757c4-152">Sorunu kolayca çözebilmeniz için, Bölüm tanımını eski *machine.config* yeni yapılandırma dosyanıza kopyalayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="757c4-152">To easily fix the issue, you can copy the section definition from your old *machine.config* to your new configuration file:</span></span>

```xml
<configSections>
    <section name="system.diagnostics"
             type="System.Diagnostics.SystemDiagnosticsSection,
                   System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
</configSections>
```

## <a name="accessing-databases"></a><span data-ttu-id="757c4-153">Veritabanlarına erişme</span><span class="sxs-lookup"><span data-stu-id="757c4-153">Accessing databases</span></span>

<span data-ttu-id="757c4-154">Neredeyse her masaüstü uygulamasının bir tür veritabanına ihtiyacı vardır.</span><span class="sxs-lookup"><span data-stu-id="757c4-154">Almost every desktop application needs some kind of database.</span></span> <span data-ttu-id="757c4-155">Masaüstü için, masaüstü uygulaması ve veritabanı altyapısı arasında doğrudan bağlantıyla istemci-sunucu mimarilerini bulmak yaygın bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="757c4-155">For desktop, it's common to find client-server architectures with a direct connection between the desktop app and the database engine.</span></span> <span data-ttu-id="757c4-156">Bu veritabanları, farklı kullanıcılar arasında bilgi paylaşma gereksinimine bağlı olarak yerel veya uzak olabilir.</span><span class="sxs-lookup"><span data-stu-id="757c4-156">These databases can be local or remote depending on the need to share information between different users.</span></span>

<span data-ttu-id="757c4-157">Kod perspektifinden, geliştiricilere bir veritabanını bağlama, sorgulama ve güncelleştirme olanağı sağlamak için birçok teknoloji ve çerçeve daha vardır.</span><span class="sxs-lookup"><span data-stu-id="757c4-157">From the code perspective, there have been many technologies and frameworks to give the developer the possibility to connect, query, and update a database.</span></span>

<span data-ttu-id="757c4-158">Windows masaüstü uygulaması hakkında konuşurken bulabileceğiniz en yaygın veritabanı örnekleri, Microsoft Access ve Microsoft SQL Server.</span><span class="sxs-lookup"><span data-stu-id="757c4-158">The most common examples of database you can find when talking about Windows Desktop application are Microsoft Access and Microsoft SQL Server.</span></span> <span data-ttu-id="757c4-159">Masaüstüne yönelik 20 yıldan daha fazla deneyim yaşarsanız, ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ ve Entity Framework gibi adlar tanıdık gelecektir.</span><span class="sxs-lookup"><span data-stu-id="757c4-159">If you have more than 20 years of experience programming for the desktop, names like ODBC, OLEDB, RDO, ADO, ADO.NET, LINQ, and Entity Framework will sound familiar.</span></span>

### <a name="odbc"></a><span data-ttu-id="757c4-160">ODBC</span><span class="sxs-lookup"><span data-stu-id="757c4-160">ODBC</span></span>

<span data-ttu-id="757c4-161">Microsoft `System.Data.Odbc` kitaplığı .NET Standard 2,0 ile uyumlu olduğundan, .net ÜZERINDE ODBC kullanmaya devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-161">You can continue to use ODBC on .NET since Microsoft is providing the `System.Data.Odbc` library compatible with .NET Standard 2.0.</span></span>

### <a name="ole-db"></a><span data-ttu-id="757c4-162">OLE DB</span><span class="sxs-lookup"><span data-stu-id="757c4-162">OLE DB</span></span>

<span data-ttu-id="757c4-163">[OLE DB](/previous-versions/windows/desktop/ms722784(v=vs.85)) , çeşitli veri kaynaklarına tek bir şekilde erişmenin harika bir yoludur.</span><span class="sxs-lookup"><span data-stu-id="757c4-163">[OLE DB](/previous-versions/windows/desktop/ms722784(v=vs.85)) has been a great way to access various data sources in a uniform manner.</span></span> <span data-ttu-id="757c4-164">Ancak bu, yalnızca Windows teknolojisi olan ve .NET gibi platformlar arası bir teknolojinin en iyi şekilde uyum sağlayan COM 'a dayalıdır.</span><span class="sxs-lookup"><span data-stu-id="757c4-164">But it was based on COM, which is a Windows-only technology, and as such wasn't the best fit for a cross-platform technology such as .NET.</span></span> <span data-ttu-id="757c4-165">Ayrıca, 2014 ve üzeri sürümlerde SQL Server de desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="757c4-165">It's also unsupported in SQL Server versions 2014 and later.</span></span> <span data-ttu-id="757c4-166">Bu nedenlerden dolayı, OLE DB .NET tarafından desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="757c4-166">For those reasons, OLE DB won't be supported by .NET.</span></span>

### <a name="adonet"></a><span data-ttu-id="757c4-167">ADO.NET</span><span class="sxs-lookup"><span data-stu-id="757c4-167">ADO.NET</span></span>

<span data-ttu-id="757c4-168">ADO.NET kullanmaya devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-168">You can still use ADO.NET from your existing desktop code on .NET.</span></span> <span data-ttu-id="757c4-169">Yalnızca bazı NuGet paketlerini güncelleştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="757c4-169">You just need to update some NuGet packages.</span></span>

### <a name="ef-core-vs-ef6"></a><span data-ttu-id="757c4-170">EF Core vs. EF6</span><span class="sxs-lookup"><span data-stu-id="757c4-170">EF Core vs. EF6</span></span>

<span data-ttu-id="757c4-171">Entity Framework (EF), Entity Framework 6 (EF6) ve EF Core desteklenen iki sürümü vardır.</span><span class="sxs-lookup"><span data-stu-id="757c4-171">There are two currently supported versions of Entity Framework (EF), Entity Framework 6 (EF6) and EF Core.</span></span>

<span data-ttu-id="757c4-172">.NET Framework dünyanın bir parçası olarak yayınlanan en son teknoloji, en son sürüm olan 6,4 ile Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="757c4-172">The latest technology released as part of the .NET Framework world is Entity Framework, with 6.4 being the latest version.</span></span> <span data-ttu-id="757c4-173">Microsoft, .NET Core 'u başlatarak Entity Framework göre yeni bir veri erişim yığını da yayımladı ve Entity Framework Core çağırılır.</span><span class="sxs-lookup"><span data-stu-id="757c4-173">With the launch of .NET Core, Microsoft also released a new data access stack based on Entity Framework and called Entity Framework Core.</span></span>

<span data-ttu-id="757c4-174">Hem .NET Framework hem de .NET EF Core EF 6,4 ve kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-174">You can use EF 6.4 and EF Core from both .NET Framework and .NET.</span></span> <span data-ttu-id="757c4-175">Bu nedenle, iki arasında karar vermeye yardımcı olacak karar etmenleri nelerdir?</span><span class="sxs-lookup"><span data-stu-id="757c4-175">So, what are the decision drivers to help to decide between the two?</span></span>

<span data-ttu-id="757c4-176">EF 6,3, .NET ve iş arası platformlar üzerinde çalışabilen ilk EF6 sürümüdür.</span><span class="sxs-lookup"><span data-stu-id="757c4-176">EF 6.3 is the first version of EF6 that can run on .NET and work cross-platform.</span></span> <span data-ttu-id="757c4-177">Aslında, bu yayının ana amacı, EF6 kullanan mevcut uygulamaları .NET 'a geçirmeyi daha kolay hale sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="757c4-177">In fact, the main goal of this release was to make it easier to migrate existing applications that use EF6 to .NET.</span></span>

<span data-ttu-id="757c4-178">EF Core, EF6 benzer bir geliştirici deneyimi sağlamak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="757c4-178">EF Core was designed to provide a developer experience similar to EF6.</span></span> <span data-ttu-id="757c4-179">En üst düzey API 'lerin çoğu aynı kalır, bu nedenle EF Core, EF6 kullanan geliştiricilere tanıdık gelecektir.</span><span class="sxs-lookup"><span data-stu-id="757c4-179">Most of the top-level APIs remain the same, so EF Core will feel familiar to developers who have used EF6.</span></span>

<span data-ttu-id="757c4-180">Uyumlu olsa da, bir karar vermeden önce kontrol etmeniz gereken uygulama farklılıkları vardır.</span><span class="sxs-lookup"><span data-stu-id="757c4-180">Although compatible, there are differences on the implementation you should check before making a decision.</span></span>
<span data-ttu-id="757c4-181">Daha fazla bilgi için bkz. [Compare EF Core & EF6](/ef/efcore-and-ef6/).</span><span class="sxs-lookup"><span data-stu-id="757c4-181">For more information, see [Compare EF Core & EF6](/ef/efcore-and-ef6/).</span></span>

<span data-ttu-id="757c4-182">Şu durumlarda EF Core kullanımı önerilir:</span><span class="sxs-lookup"><span data-stu-id="757c4-182">The recommendation is to use EF Core if:</span></span>

* <span data-ttu-id="757c4-183">Uygulama .NET özelliklerine ihtiyaç duyuyor.</span><span class="sxs-lookup"><span data-stu-id="757c4-183">The app needs the capabilities of .NET.</span></span>
* <span data-ttu-id="757c4-184">EF Core, uygulamanın gerektirdiği tüm özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="757c4-184">EF Core supports all of the features that the app requires.</span></span>

<span data-ttu-id="757c4-185">Aşağıdaki koşulların her ikisi de doğruysa EF6 kullanmayı düşünün:</span><span class="sxs-lookup"><span data-stu-id="757c4-185">Consider using EF6 if both of the following conditions are true:</span></span>

* <span data-ttu-id="757c4-186">Uygulama Windows ve .NET Framework 4,0 veya üzeri sürümlerde çalışır.</span><span class="sxs-lookup"><span data-stu-id="757c4-186">The app will run on Windows and .NET Framework 4.0 or later.</span></span>
* <span data-ttu-id="757c4-187">EF6, uygulamanın gerektirdiği tüm özellikleri destekler.</span><span class="sxs-lookup"><span data-stu-id="757c4-187">EF6 supports all of the features that the app requires.</span></span>

### <a name="relational-databases"></a><span data-ttu-id="757c4-188">İlişkisel veritabanları</span><span class="sxs-lookup"><span data-stu-id="757c4-188">Relational databases</span></span>

#### <a name="sql-server"></a><span data-ttu-id="757c4-189">SQL Server</span><span class="sxs-lookup"><span data-stu-id="757c4-189">SQL Server</span></span>

<span data-ttu-id="757c4-190">SQL Server, masaüstü için birkaç yıl önce geliştirildiğinizi tercih ettiğiniz veritabanlarından biridir.</span><span class="sxs-lookup"><span data-stu-id="757c4-190">SQL Server has been one of the databases of choice if you were developing for the desktop some years ago.</span></span> <span data-ttu-id="757c4-191">.NET Framework kullanımı ile <xref:System.Data.SqlClient> , veritabanına özgü protokolleri kapsülleyen SQL Server sürümlerine erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-191">With the use of <xref:System.Data.SqlClient> in .NET Framework, you could access versions of SQL Server, which encapsulates database-specific protocols.</span></span>

<span data-ttu-id="757c4-192">.NET ' te, `SqlClient` .NET Framework var olan, ancak kitaplıkta bulunan yeni bir sınıf bulabilirsiniz <xref:Microsoft.Data.SqlClient> .</span><span class="sxs-lookup"><span data-stu-id="757c4-192">In .NET, you can find a new `SqlClient` class, fully compatible with the one existing in the .NET Framework but located in the <xref:Microsoft.Data.SqlClient> library.</span></span> <span data-ttu-id="757c4-193">Yalnızca [Microsoft. Data. SqlClient](https://www.nuget.org/packages/Microsoft.Data.SqlClient/) NuGet paketine bir başvuru eklemeniz ve ad alanları için birkaç yeniden adlandırma yapmanız ve her şeyin beklendiği gibi çalışması gerekir.</span><span class="sxs-lookup"><span data-stu-id="757c4-193">You just have to add a reference to the [Microsoft.Data.SqlClient](https://www.nuget.org/packages/Microsoft.Data.SqlClient/) NuGet package and do some renaming for the namespaces and everything should work as expected.</span></span>

#### <a name="microsoft-access"></a><span data-ttu-id="757c4-194">Microsoft Access</span><span class="sxs-lookup"><span data-stu-id="757c4-194">Microsoft Access</span></span>

<span data-ttu-id="757c4-195">Microsoft Access, gelişmiş ve daha ölçeklenebilir SQL Server gerekmeyen yıllar için kullanılmıştır.</span><span class="sxs-lookup"><span data-stu-id="757c4-195">Microsoft Access has been used for years when the sophisticated and more scalable SQL Server wasn't needed.</span></span> <span data-ttu-id="757c4-196">Kitaplığı kullanarak Microsoft Access 'e yine de bağlanabilirsiniz <xref:System.Data.Odbc> .</span><span class="sxs-lookup"><span data-stu-id="757c4-196">You can still connect to Microsoft Access using the <xref:System.Data.Odbc> library.</span></span>

## <a name="consuming-services"></a><span data-ttu-id="757c4-197">Hizmetleri kullanma</span><span class="sxs-lookup"><span data-stu-id="757c4-197">Consuming services</span></span>

<span data-ttu-id="757c4-198">Hizmet odaklı mimarilerin yerine, masaüstü uygulamaları, bir istemci-sunucu modelinden üç katmanlı yaklaşıma gelişmeye başlamıştır.</span><span class="sxs-lookup"><span data-stu-id="757c4-198">With the raise of service-oriented architectures, desktop applications began to evolve from a client-server model to the three-layer approach.</span></span> <span data-ttu-id="757c4-199">İstemci-sunucu yaklaşımında, genellikle tek bir EXE dosyasının içinde iş mantığını tutan istemciden doğrudan bir veritabanı bağlantısı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="757c4-199">In the client-server approach, a direct database connection is established from the client holding the business logic usually inside a single EXE file.</span></span> <span data-ttu-id="757c4-200">Öte yandan, üç katmanlı yaklaşım, daha iyi güvenlik, ölçeklenebilirlik ve yeniden kullanılabilirlik sağlayan iş mantığı ve veritabanı erişimi uygulayan bir ara hizmet katmanı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="757c4-200">On the other hand, the three-layer approach establishes an intermediate service layer implementing business logic and database access allowing for better security, scalability, and reusability.</span></span> <span data-ttu-id="757c4-201">Veri veri kümeleri ile doğrudan çalışmak yerine, katman yaklaşımı, sözleşmeleri uygulayan bir dizi hizmete dayanır ve veri aktarımını uygulamak için bir yöntem olarak nesneleri ayarlar.</span><span class="sxs-lookup"><span data-stu-id="757c4-201">Instead of working directly with datasets of data, the layer approach relies in a set of services implementing contracts and types objects as a way to implement data transfer.</span></span>

<span data-ttu-id="757c4-202">WCF hizmetini kullanan bir masaüstü uygulamanız varsa ve bunu .NET 'e geçirmek istiyorsanız göz önünde bulundurmanız gereken bazı noktalar vardır.</span><span class="sxs-lookup"><span data-stu-id="757c4-202">If you have a desktop application using a WCF service and you want to migrate it to .NET, there are some things to consider.</span></span>

<span data-ttu-id="757c4-203">İlk şey, hizmete erişmek için yapılandırmanın çözümlenme yöntemi olur.</span><span class="sxs-lookup"><span data-stu-id="757c4-203">The first thing is how to resolve the configuration to access the service.</span></span> <span data-ttu-id="757c4-204">Yapılandırma .NET üzerinde farklı olduğundan, yapılandırma dosyanızda bazı güncelleştirmeler yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="757c4-204">Because the configuration is different on .NET, you'll need to make some updates in your configuration file.</span></span>

<span data-ttu-id="757c4-205">İkinci olarak, hizmet istemcisini Visual Studio 2019 ' de bulunan yeni araçlarla yeniden oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="757c4-205">Second, you'll need to regenerate the service client with the new tools present on Visual Studio 2019.</span></span> <span data-ttu-id="757c4-206">Bu adımda, istemciyi mevcut kodunuzla uyumlu hale getirmek için zaman uyumlu işlemlerin oluşturulmasını etkinleştirmeyi düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-206">In this step, you must consider activating the generation of the synchronous operations to make the client compatible with your existing code.</span></span>

<span data-ttu-id="757c4-207">Geçişten sonra, .NET üzerinde mevcut olmayan kitaplıkların olduğunu fark ederseniz, [Microsoft. Windows. Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility) NuGet paketine bir başvuru ekleyebilir ve eksik işlevlerin orada olup olmadığını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-207">After the migration, if you find that there are libraries you need that aren't present on .NET, you can add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility) NuGet package and see if the missing functions are there.</span></span>

<span data-ttu-id="757c4-208"><xref:System.Net.WebRequest>Web hizmeti çağrılarını gerçekleştirmek için sınıfını kullanıyorsanız, .NET ile ilgili bazı farklılıklar bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="757c4-208">If you're using the <xref:System.Net.WebRequest> class to perform web service calls, you may find some differences on .NET.</span></span> <span data-ttu-id="757c4-209">Bunun yerine System .net. http. HttpClient kullanılması önerilir.</span><span class="sxs-lookup"><span data-stu-id="757c4-209">The recommendation is to use the System.Net.Http.HttpClient instead.</span></span>

## <a name="consuming-a-com-object"></a><span data-ttu-id="757c4-210">COM nesnesi kullanma</span><span class="sxs-lookup"><span data-stu-id="757c4-210">Consuming a COM Object</span></span>

<span data-ttu-id="757c4-211">Şu anda, .NET ile kullanmak üzere Visual Studio 2019 ' den bir COM nesnesine başvuru eklemenin bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="757c4-211">Currently, there's no way to add a reference to a COM object from Visual Studio 2019 to use with .NET.</span></span> <span data-ttu-id="757c4-212">Bu nedenle, proje dosyasını el ile değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="757c4-212">So, you have to manually modify the project file.</span></span>

<span data-ttu-id="757c4-213">`COMReference`Proje dosyasının içine aşağıdaki örnekteki gibi bir yapı ekleyin:</span><span class="sxs-lookup"><span data-stu-id="757c4-213">Insert a `COMReference` structure inside the project file like in the following example:</span></span>

```xml
<ItemGroup>
    <COMReference Include="MSHTML">
        <Guid>{3050F1C5-98B5-11CF-BB82-00AA00BDCE0B}\</Guid>
        <VersionMajor>4</VersionMajor>
        <VersionMinor>0</VersionMinor>
        <Lcid>0</Lcid>
        <WrapperTool>primary</WrapperTool>
        <Isolated>false</Isolated>
    </COMReference>
</ItemGroup>
```

## <a name="more-things-to-consider"></a><span data-ttu-id="757c4-214">Dikkate alınması gereken şeyler</span><span class="sxs-lookup"><span data-stu-id="757c4-214">More things to consider</span></span>

<span data-ttu-id="757c4-215">.NET Framework kitaplıkları için kullanılabilen çeşitli teknolojiler .NET Core veya .NET 5 için kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="757c4-215">Several technologies available to .NET Framework libraries aren't available for .NET Core or .NET 5.</span></span> <span data-ttu-id="757c4-216">Kodunuz Bu teknolojilerden bazılarını kullanıyorsa, bu bölümde özetlenen alternatif yaklaşımları göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="757c4-216">If your code relies on some of these technologies, consider the alternative approaches outlined in this section.</span></span>

<span data-ttu-id="757c4-217">[Windows Uyumluluk Paketi](../../core/porting/windows-compat-pack.md) , daha önce yalnızca .NET Framework için kullanılabilir olan API 'lere erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="757c4-217">The [Windows Compatibility Pack](../../core/porting/windows-compat-pack.md) provides access to APIs that were previously available only for .NET Framework.</span></span> <span data-ttu-id="757c4-218">.NET Core ve .NET Standard projelerinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="757c4-218">It can be used on .NET Core and .NET Standard projects.</span></span>

<span data-ttu-id="757c4-219">API uyumluluğu hakkında daha fazla bilgi için, konumundaki son değişiklikler ve kullanım dışı/eski API 'Ler hakkında belge bulabilirsiniz <https://docs.microsoft.com/dotnet/core/compatibility/fx-core> .</span><span class="sxs-lookup"><span data-stu-id="757c4-219">For more information on API compatibility, you can find documentation about breaking changes and deprecated/legacy APIs at <https://docs.microsoft.com/dotnet/core/compatibility/fx-core>.</span></span>

### <a name="appdomains"></a><span data-ttu-id="757c4-220">Uygulama</span><span class="sxs-lookup"><span data-stu-id="757c4-220">AppDomains</span></span>

<span data-ttu-id="757c4-221">Uygulama etki alanları (AppDomain), uygulamaları birbirinden ayırır.</span><span class="sxs-lookup"><span data-stu-id="757c4-221">Application domains (AppDomains) isolate apps from one another.</span></span> <span data-ttu-id="757c4-222">AppDomain, çalışma zamanı desteği gerektirir ve pahalıdır.</span><span class="sxs-lookup"><span data-stu-id="757c4-222">AppDomains require runtime support and are expensive.</span></span> <span data-ttu-id="757c4-223">Ek uygulama etki alanlarının oluşturulması desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="757c4-223">Creating additional app domains isn't supported.</span></span> <span data-ttu-id="757c4-224">Kod yalıtımı için, farklı süreçler veya kapsayıcılar kullanmanın alternatif olarak kullanılması önerilir.</span><span class="sxs-lookup"><span data-stu-id="757c4-224">For code isolation, we recommend separate processes or using containers as an alternative.</span></span> <span data-ttu-id="757c4-225">Derlemelerin dinamik yüklemesi için yeni <xref:System.Runtime.Loader.AssemblyLoadContext> sınıfı öneririz.</span><span class="sxs-lookup"><span data-stu-id="757c4-225">For the dynamic loading of assemblies, we recommend the new <xref:System.Runtime.Loader.AssemblyLoadContext> class.</span></span>

<span data-ttu-id="757c4-226">Kod geçişinin .NET Framework daha kolay hale getirmek için .NET, bazı `AppDomain` API yüzeyini kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="757c4-226">To make code migration from .NET Framework easier, .NET exposes some of the `AppDomain` API surface.</span></span> <span data-ttu-id="757c4-227">API 'lerden bazıları normal olarak çalışır (örneğin, <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> ), bazı Üyeler hiçbir şey yapmaz (örneğin,) <xref:System.AppDomain.SetCachePath%2A> ve bazıları <xref:System.PlatformNotSupportedException> (örneğin, <xref:System.AppDomain.CreateDomain%2A> ).</span><span class="sxs-lookup"><span data-stu-id="757c4-227">Some of the APIs function normally (for example, <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>), some members do nothing (for example, <xref:System.AppDomain.SetCachePath%2A>), and some of them throw <xref:System.PlatformNotSupportedException> (for example, <xref:System.AppDomain.CreateDomain%2A>).</span></span>

### <a name="remoting"></a><span data-ttu-id="757c4-228">Uzaktan iletişim</span><span class="sxs-lookup"><span data-stu-id="757c4-228">Remoting</span></span>

<span data-ttu-id="757c4-229">.NET Remoting, artık desteklenmeyen geçici AppDomain iletişimi için kullanıldı.</span><span class="sxs-lookup"><span data-stu-id="757c4-229">.NET Remoting was used for cross-AppDomain communication, which is no longer supported.</span></span> <span data-ttu-id="757c4-230">Ayrıca, uzaktan Iletişim için, bakım açısından pahalı olan çalışma zamanı desteği gerekir.</span><span class="sxs-lookup"><span data-stu-id="757c4-230">Also, Remoting requires runtime support, which is expensive to maintain.</span></span> <span data-ttu-id="757c4-231">Bu nedenlerden dolayı .NET Remoting .net üzerinde desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="757c4-231">For these reasons, .NET Remoting isn't supported on .NET.</span></span>

<span data-ttu-id="757c4-232">İşlemler arasında iletişim için, veya sınıfı gibi uzaktan iletişim (IPC) mekanizmalarını bir alternatif olarak düşünmeniz gerekir <xref:System.IO.Pipes?displayProperty=nameWithType> <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> .</span><span class="sxs-lookup"><span data-stu-id="757c4-232">For communication across processes, you should consider inter-process communication (IPC) mechanisms as an alternative to Remoting, such as the <xref:System.IO.Pipes?displayProperty=nameWithType> or the <xref:System.IO.MemoryMappedFiles.MemoryMappedFile> class.</span></span>

<span data-ttu-id="757c4-233">Makineler arasında, alternatif olarak ağ tabanlı bir çözüm kullanın.</span><span class="sxs-lookup"><span data-stu-id="757c4-233">Across machines, use a network-based solution as an alternative.</span></span> <span data-ttu-id="757c4-234">Tercihen, HTTP gibi düşük ek bir düz metin protokolü kullanın.</span><span class="sxs-lookup"><span data-stu-id="757c4-234">Preferably, use a low-overhead plaintext protocol, such as HTTP.</span></span> <span data-ttu-id="757c4-235">ASP.NET Core tarafından kullanılan Web sunucusu olan Kestrel Web sunucusu, burada bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="757c4-235">The Kestrel web server, the web server used by ASP.NET Core, is an option here.</span></span>

### <a name="code-access-security-cas"></a><span data-ttu-id="757c4-236">Kod Erişimi Güvenliği (CAS)</span><span class="sxs-lookup"><span data-stu-id="757c4-236">Code Access Security (CAS)</span></span>

<span data-ttu-id="757c4-237">Yönetilen bir uygulamanın veya kitaplığın hangi kaynakları kullandığını veya çalıştığını kısıtlamak için çalışma zamanına veya çerçeveye dayanan korumalı alana alma, .NET üzerinde desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="757c4-237">Sandboxing, which relies on the runtime or the framework to constrain which resources a managed application or library uses or runs, isn't supported on .NET.</span></span>

<span data-ttu-id="757c4-238">İşletim sistemi tarafından sunulan sanallaştırma, kapsayıcılar veya en düşük ayrıcalık kümesi ile işlem çalıştırmak için Kullanıcı hesapları gibi güvenlik sınırlarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="757c4-238">Use security boundaries that are provided by the operating system, such as virtualization, containers, or user accounts for running processes with the minimum set of privileges.</span></span>

### <a name="security-transparency"></a><span data-ttu-id="757c4-239">Güvenlik saydamlığı</span><span class="sxs-lookup"><span data-stu-id="757c4-239">Security Transparency</span></span>

<span data-ttu-id="757c4-240">CA 'lara benzer şekilde, güvenlik saydamlığı, korumalı kodu bildirimle güvenlik açısından kritik koddan ayırır, ancak artık güvenlik sınırı olarak desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="757c4-240">Similar to CAS, Security Transparency separates sandboxed code from security critical code in a declarative fashion but is no longer supported as a security boundary.</span></span>

<span data-ttu-id="757c4-241">İşletim sistemi tarafından sunulan sanallaştırma, kapsayıcılar veya en az ayrıcalık kümesiyle işlem çalıştırmak için Kullanıcı hesapları gibi güvenlik sınırlarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="757c4-241">Use security boundaries that are provided by the operating system, such as virtualization, containers, or user accounts for running processes with the least set of privileges.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="757c4-242">[Önceki](whats-new-dotnet.md ) 
> [Sonraki](windows-migration.md)</span><span class="sxs-lookup"><span data-stu-id="757c4-242">[Previous](whats-new-dotnet.md )
[Next](windows-migration.md)</span></span>
