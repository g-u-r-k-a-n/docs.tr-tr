---
title: Yerel işlevler - C# Programlama Kılavuzu
ms.date: 06/14/2017
helpviewer_keywords:
- local functions [C#]
ms.openlocfilehash: 200fbd097b7c71a1cd392d62622955528a80fd66
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2020
ms.locfileid: "82102950"
---
# <a name="local-functions-c-programming-guide"></a><span data-ttu-id="2a82d-102">Yerel işlevler (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="2a82d-102">Local functions (C# Programming Guide)</span></span>

<span data-ttu-id="2a82d-103">C# 7.0 ile başlayarak, C# *yerel işlevleri*destekler.</span><span class="sxs-lookup"><span data-stu-id="2a82d-103">Starting with C# 7.0, C# supports *local functions*.</span></span> <span data-ttu-id="2a82d-104">Yerel işlevler, başka bir üyede iç içe olan bir türdeki özel yöntemlerdir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-104">Local functions are private methods of a type that are nested in another member.</span></span> <span data-ttu-id="2a82d-105">Yalnızca kendi üyelerinden çağrılabilirler.</span><span class="sxs-lookup"><span data-stu-id="2a82d-105">They can only be called from their containing member.</span></span> <span data-ttu-id="2a82d-106">Yerel işlevler bildirilebilir ve şu andan itibaren çağrılabilir:</span><span class="sxs-lookup"><span data-stu-id="2a82d-106">Local functions can be declared in and called from:</span></span>

- <span data-ttu-id="2a82d-107">Yöntemler, özellikle reeratör yöntemleri ve async yöntemleri</span><span class="sxs-lookup"><span data-stu-id="2a82d-107">Methods, especially iterator methods and async methods</span></span>
- <span data-ttu-id="2a82d-108">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="2a82d-108">Constructors</span></span>
- <span data-ttu-id="2a82d-109">Özellik erişime girenler</span><span class="sxs-lookup"><span data-stu-id="2a82d-109">Property accessors</span></span>
- <span data-ttu-id="2a82d-110">Etkinlik erişime girenler</span><span class="sxs-lookup"><span data-stu-id="2a82d-110">Event accessors</span></span>
- <span data-ttu-id="2a82d-111">Anonim yöntemler</span><span class="sxs-lookup"><span data-stu-id="2a82d-111">Anonymous methods</span></span>
- <span data-ttu-id="2a82d-112">Lambda ifadeleri</span><span class="sxs-lookup"><span data-stu-id="2a82d-112">Lambda expressions</span></span>
- <span data-ttu-id="2a82d-113">Sonlandırıcılar</span><span class="sxs-lookup"><span data-stu-id="2a82d-113">Finalizers</span></span>
- <span data-ttu-id="2a82d-114">Diğer yerel işlevler</span><span class="sxs-lookup"><span data-stu-id="2a82d-114">Other local functions</span></span>

<span data-ttu-id="2a82d-115">Ancak, yerel işlevler ifade gövdeli bir üye içinde bildirilemez.</span><span class="sxs-lookup"><span data-stu-id="2a82d-115">However, local functions can't be declared inside an expression-bodied member.</span></span>

> [!NOTE]
> <span data-ttu-id="2a82d-116">Bazı durumlarda, yerel bir işlev tarafından da desteklenen işlevselliği uygulamak için bir lambda ifadesi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a82d-116">In some cases, you can use a lambda expression to implement functionality also supported by a local function.</span></span> <span data-ttu-id="2a82d-117">Karşılaştırma için, [yerel işlevler vs lambda ifadeler](#local-functions-vs-lambda-expressions)bakın.</span><span class="sxs-lookup"><span data-stu-id="2a82d-117">For a comparison, see [Local functions vs. lambda expressions](#local-functions-vs-lambda-expressions).</span></span>

<span data-ttu-id="2a82d-118">Yerel işlevler, kodunuzu açıkça ortaya kovar.</span><span class="sxs-lookup"><span data-stu-id="2a82d-118">Local functions make the intent of your code clear.</span></span> <span data-ttu-id="2a82d-119">Kodunuzu okuyan herkes, içeren yöntem dışında yöntemin çağrılabilir olmadığını görebilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-119">Anyone reading your code can see that the method is not callable except by the containing method.</span></span> <span data-ttu-id="2a82d-120">Takım projeleri için, başka bir geliştiricinin yöntemi yanlışlıkla sınıfın veya yapının başka bir yerinden yanlışlıkla aramasını da imkansız hale getirir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-120">For team projects, they also make it impossible for another developer to mistakenly call the method directly from elsewhere in the class or struct.</span></span>

## <a name="local-function-syntax"></a><span data-ttu-id="2a82d-121">Yerel işlev sözdizimi</span><span class="sxs-lookup"><span data-stu-id="2a82d-121">Local function syntax</span></span>

<span data-ttu-id="2a82d-122">Yerel bir işlev, iç içe bir üyenin içinde iç içe bir yöntem olarak tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-122">A local function is defined as a nested method inside a containing member.</span></span> <span data-ttu-id="2a82d-123">Tanımıaşağıdaki sözdizimine sahiptir:</span><span class="sxs-lookup"><span data-stu-id="2a82d-123">Its definition has the following syntax:</span></span>

```csharp
<modifiers: async | unsafe> <return-type> <method-name> <parameter-list>
```

<span data-ttu-id="2a82d-124">Yerel işlevler [async](../../language-reference/keywords/async.md) ve [güvensiz](../../language-reference/keywords/unsafe.md) değiştiriciler kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a82d-124">Local functions can use the [async](../../language-reference/keywords/async.md) and [unsafe](../../language-reference/keywords/unsafe.md) modifiers.</span></span>

<span data-ttu-id="2a82d-125">Yöntem parametreleri de dahil olmak üzere, ilgili üyede tanımlanan tüm yerel değişkenlere yerel işlevde erişilebilir olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="2a82d-125">Note that all local variables that are defined in the containing member, including its method parameters, are accessible in the local function.</span></span>

<span data-ttu-id="2a82d-126">Yöntem tanımının aksine, yerel işlev tanımı üye erişim değiştiriciyi içeremez.</span><span class="sxs-lookup"><span data-stu-id="2a82d-126">Unlike a method definition, a local function definition cannot include the member access modifier.</span></span> <span data-ttu-id="2a82d-127">`private` Anahtar kelime gibi bir erişim değiştirici de dahil olmak üzere tüm yerel işlevler özel olduğundan, cs0106 derleyici hatası oluşturur, "Değiştirici 'özel' bu öğe için geçerli değildir."</span><span class="sxs-lookup"><span data-stu-id="2a82d-127">Because all local functions are private, including an access modifier, such as the `private` keyword, generates compiler error CS0106, "The modifier 'private' is not valid for this item."</span></span>

> [!NOTE]
> <span data-ttu-id="2a82d-128">C# 8.0'dan önce yerel `static` işlevler değiştiriciyi içeremez.</span><span class="sxs-lookup"><span data-stu-id="2a82d-128">Prior to C# 8.0, local functions cannot include the `static` modifier.</span></span> <span data-ttu-id="2a82d-129">`static` Anahtar kelime de dahil olmak üzere derleyici hatası CS0106 oluşturur, "Değiştirici 'statik' bu öğe için geçerli değildir."</span><span class="sxs-lookup"><span data-stu-id="2a82d-129">Including the `static` keyword generates compiler error CS0106, "The modifier 'static' is not valid for this item."</span></span>

<span data-ttu-id="2a82d-130">Ayrıca, öznitelikler yerel işleve veya parametrelerine ve tür parametrelerine uygulanamaz.</span><span class="sxs-lookup"><span data-stu-id="2a82d-130">In addition, attributes can't be applied to the local function or to its parameters and type parameters.</span></span>

<span data-ttu-id="2a82d-131">Aşağıdaki örnek, adlı bir `AppendPathSeparator` yönteme özel olan `GetText`yerel bir işlev tanımlar:</span><span class="sxs-lookup"><span data-stu-id="2a82d-131">The following example defines a local function named `AppendPathSeparator` that is private to a method named `GetText`:</span></span>

[!code-csharp[LocalFunctionExample](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions1.cs)]  

## <a name="local-functions-and-exceptions"></a><span data-ttu-id="2a82d-132">Yerel işlevler ve özel durumlar</span><span class="sxs-lookup"><span data-stu-id="2a82d-132">Local functions and exceptions</span></span>

<span data-ttu-id="2a82d-133">Yerel işlevlerin yararlı özelliklerinden biri, özel durumların hemen yüzeye çıkmasına izin verebilmeleridir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-133">One of the useful features of local functions is that they can allow exceptions to surface immediately.</span></span> <span data-ttu-id="2a82d-134">Yöntem yineleyicileri için, özel durumlar yalnızca döndürülen sıra numaralandırıldığında su yüzüne çıkar, yineleyici alındığında değil.</span><span class="sxs-lookup"><span data-stu-id="2a82d-134">For method iterators, exceptions are surfaced only when the returned sequence is enumerated, and not when the iterator is retrieved.</span></span> <span data-ttu-id="2a82d-135">Async yöntemleri için, döndürülen görev bekleniyor zaman bir async yöntemi atılan tüm özel durumlar gözlenir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-135">For async methods, any exceptions thrown in an async method are observed when the returned task is awaited.</span></span>

<span data-ttu-id="2a82d-136">Aşağıdaki örnek, belirli `OddSequence` bir aralık arasında tek sayılar numaralandırmak bir yöntem tanımlar.</span><span class="sxs-lookup"><span data-stu-id="2a82d-136">The following example defines an `OddSequence` method that enumerates odd numbers between a specified range.</span></span> <span data-ttu-id="2a82d-137">Numaralandırma yöntemine 100'den `OddSequence` büyük bir sayı geçtiği için, yöntem <xref:System.ArgumentOutOfRangeException>bir .</span><span class="sxs-lookup"><span data-stu-id="2a82d-137">Because it passes a number greater than 100 to the `OddSequence` enumerator method, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="2a82d-138">Örnekteki çıktının gösterdiği gibi, özel durum yalnızca sayıyı kaydettiğinizde değil, sayıları yinelediğinizde ortaya çıkar.</span><span class="sxs-lookup"><span data-stu-id="2a82d-138">As the output from the example shows, the exception surfaces only when you iterate the numbers, and not when you retrieve the enumerator.</span></span>

[!code-csharp[LocalFunctionIterator1](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator1.cs)]

<span data-ttu-id="2a82d-139">Bunun yerine, doğrulama gerçekleştirirken ve aşağıdaki örnekte görüldüğü gibi, yineleyiciyi yerel bir işlevden döndürerek yineleyiciyi almadan önce bir özel durum atabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a82d-139">Instead, you can throw an exception when performing validation and before retrieving the iterator by returning the iterator from a local function, as the following example shows.</span></span>

[!code-csharp[LocalFunctionIterator2](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-iterator2.cs)]

<span data-ttu-id="2a82d-140">Yerel işlevler, asynchronous işleminin dışındaki özel durumları işlemek için benzer bir şekilde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-140">Local functions can be used in a similar way to handle exceptions outside of the asynchronous operation.</span></span> <span data-ttu-id="2a82d-141">Normalde, async yönteminde atılan özel durumlar, bir <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="2a82d-141">Ordinarily, exceptions thrown in async method require that you examine the inner exceptions of an <xref:System.AggregateException>.</span></span> <span data-ttu-id="2a82d-142">Yerel işlevler, kodunuzun hızlı bir şekilde başarısız olmasını ve özel durumlarınızın hem atılmasına hem de eşzamanlı olarak gözlenmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-142">Local functions allow your code to fail fast and allow your exception to be both thrown and observed synchronously.</span></span>

<span data-ttu-id="2a82d-143">Aşağıdaki örnek, belirli bir saniye `GetMultipleAsync` sayısı için duraklatmak ve bu saniye sayısının rasgele bir katını döndürecek bir değer döndürmek için adlandırılmış bir eşzamanlı yöntem kullanır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-143">The following example uses an asynchronous method named `GetMultipleAsync` to pause for a specified number of seconds and return a value that is a random multiple of that number of seconds.</span></span> <span data-ttu-id="2a82d-144">Maksimum gecikme 5 saniyedir; değeri <xref:System.ArgumentOutOfRangeException> 5'ten büyükse sonuç verir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-144">The maximum delay is 5 seconds; an <xref:System.ArgumentOutOfRangeException> results if the value is greater than 5.</span></span> <span data-ttu-id="2a82d-145">Aşağıdaki örnekte de görüldüğü gibi, `GetMultipleAsync` <xref:System.AggregateException> `GetMultipleAsync` yönteme 6 değeri geçirildiğinde atılan özel durum, yöntem yürütmeye başladıktan sonra bir şekilde sarılır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-145">As the following example shows, the exception that is thrown when a value of 6 is passed to the `GetMultipleAsync` method is wrapped in an <xref:System.AggregateException> after the `GetMultipleAsync` method begins execution.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async1.cs)]

<span data-ttu-id="2a82d-146">Yöntem yineleyicide yaptığımız gibi, asynchronous yöntemini aramadan önce doğrulamayı gerçekleştirmek için bu örnekteki kodu yeniden değerlendirebiliriz.</span><span class="sxs-lookup"><span data-stu-id="2a82d-146">As we did with the method iterator, we can refactor the code from this example to perform the validation before calling the asynchronous method.</span></span> <span data-ttu-id="2a82d-147">Aşağıdaki örnekteki çıktının gösterdiği <xref:System.ArgumentOutOfRangeException> gibi, bir <xref:System.AggregateException>.</span><span class="sxs-lookup"><span data-stu-id="2a82d-147">As the output from the following example shows, the <xref:System.ArgumentOutOfRangeException> is not wrapped in a <xref:System.AggregateException>.</span></span>

[!code-csharp[LocalFunctionAsync](~/samples/snippets/csharp/programming-guide/classes-and-structs/local-functions-async2.cs)]

## <a name="local-functions-vs-lambda-expressions"></a><span data-ttu-id="2a82d-148">Yerel işlevler vs lambda ifadeler</span><span class="sxs-lookup"><span data-stu-id="2a82d-148">Local functions vs. lambda expressions</span></span>

<span data-ttu-id="2a82d-149">İlk bakışta, yerel [fonksiyonlar](../statements-expressions-operators/lambda-expressions.md) ve lambda ifadeler çok benzer.</span><span class="sxs-lookup"><span data-stu-id="2a82d-149">At first glance, local functions and [lambda expressions](../statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="2a82d-150">Birçok durumda, lambda ifadeleri ve yerel işlevleri kullanarak arasındaki seçim tarzı ve kişisel tercih meselesidir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-150">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="2a82d-151">Ancak, farkında olması gereken birini veya diğerini kullanabileceğiniz gerçek farklılıklar vardır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-151">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="2a82d-152">Faktöriyel algoritmanın yerel fonksiyon ve lambda ifade uygulamaları arasındaki farkları inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="2a82d-152">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="2a82d-153">Önce yerel bir işlev kullanarak sürümü:</span><span class="sxs-lookup"><span data-stu-id="2a82d-153">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="2a82d-154">Bu uygulamanın lambda ifadelerini kullanan bir sürümle karşılatılması:</span><span class="sxs-lookup"><span data-stu-id="2a82d-154">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="2a82d-155">Yerel işlevlerin adları vardır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-155">The local functions have names.</span></span> <span data-ttu-id="2a82d-156">Lambda ifadeleri, türdeki değişkenlere atanan anonim `Func` yöntemlerdir. `Action`</span><span class="sxs-lookup"><span data-stu-id="2a82d-156">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="2a82d-157">Yerel bir işlev bildirdiğinizde, bağımsız değişken türleri ve iade türü işlev bildiriminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-157">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="2a82d-158">Lambda ifadesinin gövdesinin bir parçası olmak yerine, argüman türleri ve dönüş türü lambda ifadesinin değişken türü deyiminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-158">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="2a82d-159">Bu iki fark daha net kod neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-159">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="2a82d-160">Yerel işlevlerin kesin atama için lambda ifadelerinden farklı kuralları vardır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-160">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="2a82d-161">Yerel işlev bildirimi, kapsamda olduğu herhangi bir kod konumundan başvurulabilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-161">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="2a82d-162">Bir lambda ifadesine erişilebilmek için önce bir temsilci değişkenine atanmalıdır (veya lambda ifadesine başvuran temsilci aracılığıyla çağrılanmalıdır).</span><span class="sxs-lookup"><span data-stu-id="2a82d-162">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression).</span></span> <span data-ttu-id="2a82d-163">Lambda ifadesini kullanan sürümü tanımlamadan önce lambda ifadesini `nthFactorial` beyan etmesi ve başlatması gerektiğine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="2a82d-163">Notice that the version using the lambda expression must declare and initialize the lambda expression `nthFactorial` before defining it.</span></span> <span data-ttu-id="2a82d-164">Bunu yapmamak, atamadan önce başvurmak `nthFactorial` için bir derleme zaman hatasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="2a82d-164">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span> <span data-ttu-id="2a82d-165">Bu farklar, özyinelemeli algoritmaların yerel işlevleri kullanarak oluşturulmasının daha kolay olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-165">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="2a82d-166">Kendisini çağıran yerel bir işlev bildirebilir ve tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="2a82d-166">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="2a82d-167">Lambda ifadeleri beyan edilmeli ve aynı lambda ifadesine başvuran bir gövdeye yeniden atanabilmeleri için varsayılan bir değer atanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-167">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="2a82d-168">Kesin atama kuralları, yerel işlev veya lambda ifadesi tarafından yakalanan değişkenleri de etkiler.</span><span class="sxs-lookup"><span data-stu-id="2a82d-168">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="2a82d-169">Hem yerel işlevler hem de lambda ifade kuralları, yakalanan değişkenlerin, yerel işlevin veya lambda ifadesinin bir temsilciye dönüştürüldüğü noktada kesinlikle atanmasını ister.</span><span class="sxs-lookup"><span data-stu-id="2a82d-169">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="2a82d-170">Aradaki fark, lambda ifadeleri beyan edildiğinde delegelere dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="2a82d-170">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="2a82d-171">Yerel işlevler yalnızca temsilci olarak kullanıldığında temsilciye dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="2a82d-171">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="2a82d-172">Yerel bir işlev bildirir ve yalnızca bir yöntem gibi çağırarak başvurursanız, bu işlev bir temsilciye dönüştürülmez.</span><span class="sxs-lookup"><span data-stu-id="2a82d-172">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="2a82d-173">Bu kural, yerel bir işlevi ekkapsamına giren herhangi bir uygun konumda bildirmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-173">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="2a82d-174">İade bildirimlerinden sonra, ana yöntemin sonunda yerel işlevleri bildirmek yaygındır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-174">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="2a82d-175">Üçüncü olarak, derleyici, yerel işlevlerin yakalanan değişkenleri kesinlikle çevreleyen kapsamda atamasını sağlayan statik çözümleme gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-175">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="2a82d-176">Bu örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="2a82d-176">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="2a82d-177">Derleyici çağrıldığında `LocalFunction` kesinlikle `y` atadığını belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-177">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="2a82d-178">Çünkü `LocalFunction` ifadeden `return` önce `y` çağrılır, `return` kesinlikle deyimde atanır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-178">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="2a82d-179">Örnek çözümlemesini sağlayan çözümleme dördüncü farkı sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a82d-179">The analysis that enables the example analysis enables the fourth difference.</span></span> <span data-ttu-id="2a82d-180">Kullanımlarına bağlı olarak, yerel işlevler lambda ifadeleri için her zaman gerekli olan yığın ayırmalarından kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-180">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="2a82d-181">Yerel bir işlev hiçbir zaman temsilciye dönüştürülmezse ve yerel işlev tarafından yakalanan değişkenlerin hiçbiri diğer lambda'lar veya temsilciye dönüştürülen yerel işlevler tarafından yakalanırsa, derleyici yığın ayırmalarından kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-181">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="2a82d-182">Bu async örneğini göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="2a82d-182">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="2a82d-183">Bu lambda ifadesinin `address`kapanışı `index` `name` , ve değişkenleri içerir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-183">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="2a82d-184">Yerel işlevler söz konusu olduğunda, kapatmayı uygulayan `struct` nesne bir tür olabilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-184">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="2a82d-185">Bu yapı türü yerel işleve atıfta bulunularak geçirilir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-185">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="2a82d-186">Uygulamadaki bu fark bir ayırmada tasarruf sağlar.</span><span class="sxs-lookup"><span data-stu-id="2a82d-186">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="2a82d-187">Lambda ifadeleri için gerekli anlık algılama, zaman açısından kritik kod yollarında bir performans faktörü olabilecek ekstra bellek ayırmaları anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-187">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span> <span data-ttu-id="2a82d-188">Yerel işlevler bu ek yükü tabi değildir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-188">Local functions do not incur this overhead.</span></span> <span data-ttu-id="2a82d-189">Yukarıdaki örnekte, yerel işlevler sürümü lambda ifade sürümünden 2 daha az ayırmaya sahiptir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-189">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="2a82d-190">Bu yöntemin yerel işlev eşdeğeri de kapatma için bir sınıf kullanır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-190">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="2a82d-191">Yerel bir işlevin kapatılmasının a `class` veya `struct` a olarak uygulanıp uygulanmadığı bir uygulama ayrıntısýr.</span><span class="sxs-lookup"><span data-stu-id="2a82d-191">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="2a82d-192">Yerel bir `struct` fonksiyon bir lambda her zaman `class`bir .</span><span class="sxs-lookup"><span data-stu-id="2a82d-192">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="2a82d-193">Bu örnekte gösterilmemiş son bir avantaj, yerel işlevlerin bir değer `yield return` dizisi oluşturmak için sözdizimini kullanarak yineleyici olarak uygulanabiliyor olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-193">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="2a82d-194">Lambda `yield return` ifadelerinde ifadeye izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="2a82d-194">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="2a82d-195">Yerel işlevler lambda ifadeleri için gereksiz görünse de, aslında farklı amaçlara hizmet ve farklı kullanımları vardır.</span><span class="sxs-lookup"><span data-stu-id="2a82d-195">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span> <span data-ttu-id="2a82d-196">Yerel işlevler, yalnızca başka bir yöntemin bağlamından çağrılan bir işlev yazmak istediğinizde, servis talebi için daha verimlidir.</span><span class="sxs-lookup"><span data-stu-id="2a82d-196">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>

## <a name="see-also"></a><span data-ttu-id="2a82d-197">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="2a82d-197">See also</span></span>

- [<span data-ttu-id="2a82d-198">Yöntemler</span><span class="sxs-lookup"><span data-stu-id="2a82d-198">Methods</span></span>](methods.md)
