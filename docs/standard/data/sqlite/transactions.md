---
title: İşlemler
ms.date: 09/08/2020
description: İşlemleri nasıl kullanacağınızı öğrenin.
ms.openlocfilehash: 50c4cd1023eac892cafc3ae4395e9168bd8e9f36
ms.sourcegitcommit: aa6d8a90a4f5d8fe0f6e967980b8c98433f05a44
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/16/2020
ms.locfileid: "90678868"
---
# <a name="transactions"></a><span data-ttu-id="27691-103">İşlemler</span><span class="sxs-lookup"><span data-stu-id="27691-103">Transactions</span></span>

<span data-ttu-id="27691-104">İşlemler, birden çok SQL deyimini veritabanına tek bir atomik birim olarak işlenen tek bir iş biriminde gruplandırmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="27691-104">Transactions let you group multiple SQL statements into a single unit of work that is committed to the database as one atomic unit.</span></span> <span data-ttu-id="27691-105">İşlemdeki herhangi bir deyim başarısız olursa, önceki deyimler tarafından yapılan değişiklikler geri alınabilir.</span><span class="sxs-lookup"><span data-stu-id="27691-105">If any statement in the transaction fails, changes made by the previous statements can be rolled back.</span></span> <span data-ttu-id="27691-106">İşlem başlatıldığında veritabanının ilk durumu korunur.</span><span class="sxs-lookup"><span data-stu-id="27691-106">The initial state of the database when the transaction was started is preserved.</span></span> <span data-ttu-id="27691-107">Bir işlemin kullanılması, veritabanında aynı anda çok sayıda değişiklik yaparken SQLite 'un performansını da artırır.</span><span class="sxs-lookup"><span data-stu-id="27691-107">Using a transaction can also improve performance on SQLite when making numerous changes to the database at once.</span></span>

## <a name="concurrency"></a><span data-ttu-id="27691-108">Eşzamanlılık</span><span class="sxs-lookup"><span data-stu-id="27691-108">Concurrency</span></span>

<span data-ttu-id="27691-109">SQLite 'ta, tek seferde veritabanında bekleyen değişikliklere yalnızca bir işlem izin verilir.</span><span class="sxs-lookup"><span data-stu-id="27691-109">In SQLite, only one transaction is allowed to have changes pending in the database at a time.</span></span> <span data-ttu-id="27691-110">Bu nedenle, <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> `Execute` <xref:Microsoft.Data.Sqlite.SqliteCommand> başka bir işlemin tamamlanamayacak kadar uzun sürme durumunda ve üzerinde yapılan çağrılar zaman aşımına uğrar.</span><span class="sxs-lookup"><span data-stu-id="27691-110">Because of this, calls to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> and the `Execute` methods on <xref:Microsoft.Data.Sqlite.SqliteCommand> may time out if another transaction takes too long to complete.</span></span>

<span data-ttu-id="27691-111">Kilitleme, yeniden denemeler ve zaman aşımları hakkında daha fazla bilgi için bkz. [veritabanı hataları](database-errors.md).</span><span class="sxs-lookup"><span data-stu-id="27691-111">For more information about locking, retries, and timeouts, see [Database errors](database-errors.md).</span></span>

## <a name="isolation-levels"></a><span data-ttu-id="27691-112">Yalıtım düzeyleri</span><span class="sxs-lookup"><span data-stu-id="27691-112">Isolation levels</span></span>

<span data-ttu-id="27691-113">İşlem, SQLite içinde varsayılan olarak **seri hale getirilebilir** .</span><span class="sxs-lookup"><span data-stu-id="27691-113">Transactions are **serializable** by default in SQLite.</span></span> <span data-ttu-id="27691-114">Bu yalıtım düzeyi, bir işlem içinde yapılan tüm değişikliklerin tamamen yalıtılmış olmasını güvence altına alır.</span><span class="sxs-lookup"><span data-stu-id="27691-114">This isolation level guarantees that any changes made within a transaction are completely isolated.</span></span> <span data-ttu-id="27691-115">İşlemin dışında yürütülen diğer deyimler işlemin değişikliklerinden etkilenmez.</span><span class="sxs-lookup"><span data-stu-id="27691-115">Other statements executed outside of the transaction aren't affected by the transaction's changes.</span></span>

<span data-ttu-id="27691-116">SQLite, paylaşılan bir önbellek kullanılırken **read UNCOMMITTED** öğesini de destekler.</span><span class="sxs-lookup"><span data-stu-id="27691-116">SQLite also supports **read uncommitted** when using a shared cache.</span></span> <span data-ttu-id="27691-117">Bu düzey, kirli okuma, tekrarlanabilir okuma ve hayalet düzeylerine izin verir:</span><span class="sxs-lookup"><span data-stu-id="27691-117">This level allows dirty reads, nonrepeatable reads, and phantoms:</span></span>

- <span data-ttu-id="27691-118">Bir işlemde bekleyen değişiklikler işlem dışında bir sorgu tarafından döndürüldüğünde *kirli okuma* oluşur, ancak işlemdeki değişiklikler geri alınır.</span><span class="sxs-lookup"><span data-stu-id="27691-118">A *dirty read* occurs when changes pending in one transaction are returned by a query outside of the transaction, but the changes in the transaction are rolled back.</span></span> <span data-ttu-id="27691-119">Sonuçlar veritabanına hiçbir daha önce teslim edilmemiş verileri içerir.</span><span class="sxs-lookup"><span data-stu-id="27691-119">The results contain data that was never actually committed to the database.</span></span>

- <span data-ttu-id="27691-120">Bir işlem aynı satırı iki kez sorguladığında, *tekrarlanabilir bir okuma* gerçekleşir, ancak başka bir işlem tarafından iki sorgu arasında değiştirildiğinden sonuçlar farklıdır.</span><span class="sxs-lookup"><span data-stu-id="27691-120">A *nonrepeatable read* occurs when a transaction queries same row twice, but the results are different because it was changed between the two queries by another transaction.</span></span>

- <span data-ttu-id="27691-121">*Hayali* nesnelerin, bir işlem sırasında bir sorgunun where yan tümcesini karşılamak için değiştirilen veya eklenen satırlardır.</span><span class="sxs-lookup"><span data-stu-id="27691-121">*Phantoms* are rows that get changed or added to meet the where clause of a query during a transaction.</span></span> <span data-ttu-id="27691-122">İzin veriliyorsa aynı sorgu aynı işlemde iki kez yürütüldüğünde aynı sorgu farklı satırlar döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="27691-122">If allowed, the same query could return different rows when executed twice in the same transaction.</span></span>

<span data-ttu-id="27691-123">Microsoft. Data. SQLite, geçirilen IsolationLevel 'ı <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> En düşük düzey olarak değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="27691-123">Microsoft.Data.Sqlite treats the IsolationLevel passed to <xref:Microsoft.Data.Sqlite.SqliteConnection.BeginTransaction%2A> as a minimum level.</span></span> <span data-ttu-id="27691-124">Gerçek yalıtım düzeyi READ UNCOMMITTED veya Serializable olarak yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="27691-124">The actual isolation level will be promoted to either read uncommitted or serializable.</span></span>

<span data-ttu-id="27691-125">Aşağıdaki kod, bir kirli okumayı benzetir.</span><span class="sxs-lookup"><span data-stu-id="27691-125">The following code simulates a dirty read.</span></span> <span data-ttu-id="27691-126">Bağlantı dizesinin içermesi gerektiğini göz önünde bulundurun `Cache=Shared` .</span><span class="sxs-lookup"><span data-stu-id="27691-126">Note, the connection string must include `Cache=Shared`.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DirtyReadSample/Program.cs?name=snippet_DirtyRead)]

## <a name="deferred-transactions"></a><span data-ttu-id="27691-127">Ertelenmiş işlemler</span><span class="sxs-lookup"><span data-stu-id="27691-127">Deferred transactions</span></span>

<span data-ttu-id="27691-128">Microsoft. Data. SQLite sürüm 5,0 ' den başlayarak, işlemler ertelenebilir.</span><span class="sxs-lookup"><span data-stu-id="27691-128">Starting with Microsoft.Data.Sqlite version 5.0, transactions can be deferred.</span></span> <span data-ttu-id="27691-129">Bu, ilk komut yürütülene kadar veritabanındaki gerçek işlemin oluşturulmasını erteler.</span><span class="sxs-lookup"><span data-stu-id="27691-129">This defers the creation of the actual transaction in the database until the first command is executed.</span></span> <span data-ttu-id="27691-130">Ayrıca, bu işlem, bir okuma işleminden, komutlarının gerektiğinde bir yazma işlemine aşamalı olarak yükseltilmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="27691-130">It also causes the transaction to gradually upgrade from a read transaction to a write transaction as needed by its commands.</span></span> <span data-ttu-id="27691-131">Bu işlem sırasında veritabanına eş zamanlı erişimi etkinleştirmek için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="27691-131">This can be useful for enabling concurrent access to the database during the transaction.</span></span>

[!code-csharp[](../../../../samples/snippets/standard/data/sqlite/DeferredTransactionSample/Program.cs?name=snippet_DeferredTransaction)]

> [!WARNING]
> <span data-ttu-id="27691-132">Ertelenmiş bir işlem içindeki komutlar, veritabanı kilitliyken işlemin bir okuma işleminden bir yazma işlemine yükseltilmesine neden olursa başarısız olabilir.</span><span class="sxs-lookup"><span data-stu-id="27691-132">Commands inside a deferred transaction can fail if they cause the transaction to be upgraded from a read transaction to a write transaction while the database is locked.</span></span> <span data-ttu-id="27691-133">Bu durumda, uygulamanın tüm işlemi yeniden denemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="27691-133">When this happens, the application will need to retry the entire transaction.</span></span>
