---
title: Nullable başvuru türlerini kullanmak için kod tabanınızı güncelleştirin
description: Nullable başvuru türlerini kullanmak için kod tabanınızı yükseltmek için en iyi stratejiyi seçin.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: b4a10863aea5c47b47c2a017afb20786b1e67528
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/23/2020
ms.locfileid: "82103529"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="289a4-103">Geçersiz başvuru türlerini kullanmak ve arayanlara geçersiz kuralları iletmek için kitaplıkları güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="289a4-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="289a4-104">[Nullable başvuru türlerinin](nullable-references.md) eklenmesi, her değişken `null` için bir değere izin verilip verilmediğini veya beklenmediğini bildirebileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="289a4-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="289a4-105">Buna ek olarak, bir dizi `AllowNull`öznitelik uygulayabilirsiniz: `NotNullIfNotNull` , , `DisallowNull` `MaybeNull` `NotNull` `NotNullWhen`, , `MaybeNullWhen`, , ve tamamen bağımsız değişken ve dönüş değerleri null durumları açıklamak için.</span><span class="sxs-lookup"><span data-stu-id="289a4-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="289a4-106">Bu kod yazmak gibi büyük bir deneyim sağlar.</span><span class="sxs-lookup"><span data-stu-id="289a4-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="289a4-107">Nullable olmayan bir değişken ' olarak `null`ayarlanmış olabilir uyarılar alırsınız.</span><span class="sxs-lookup"><span data-stu-id="289a4-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="289a4-108">Geçersiz bir değişken, başvurudan çıkmadan önce null-check-checked değilse uyarılar alırsınız.</span><span class="sxs-lookup"><span data-stu-id="289a4-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="289a4-109">Kitaplıklarınızı güncellemek zaman alabilir, ancak ödemeler buna değer.</span><span class="sxs-lookup"><span data-stu-id="289a4-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="289a4-110">Derleyiciye bir `null` değere *ne zaman* izin verildiği veya ne zaman yasakolduğu hakkında ne kadar çok bilgi sağlarsanız, API'nizin kullanıcıları o kadar iyi uyarılar alır.</span><span class="sxs-lookup"><span data-stu-id="289a4-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="289a4-111">Tanıdık bir örnekle başlayalım.</span><span class="sxs-lookup"><span data-stu-id="289a4-111">Let's start with a familiar example.</span></span> <span data-ttu-id="289a4-112">Kitaplığınızın kaynak dizesini almak için aşağıdaki API'ye sahip olduğunu düşünün:</span><span class="sxs-lookup"><span data-stu-id="289a4-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="289a4-113">Önceki örnek .NET'teki tanıdık `Try*` deseni izler.</span><span class="sxs-lookup"><span data-stu-id="289a4-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="289a4-114">Bu API için iki başvuru `key` bağımsız `message` değişkeni vardır: ve parametre.</span><span class="sxs-lookup"><span data-stu-id="289a4-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="289a4-115">Bu API, bu bağımsız değişkenlerin nullness ile ilgili aşağıdaki kurallara sahiptir:</span><span class="sxs-lookup"><span data-stu-id="289a4-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="289a4-116">Arayanlar için `key`argüman `null` olarak geçmemelidir.</span><span class="sxs-lookup"><span data-stu-id="289a4-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="289a4-117">Arayanlar, değeri bağımsız değişken `null` olarak olan `message`bir değişkeni geçirebilir.</span><span class="sxs-lookup"><span data-stu-id="289a4-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="289a4-118">`TryGetMessage` Yöntem dönerse, `true`değeri null `message` değildir.</span><span class="sxs-lookup"><span data-stu-id="289a4-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="289a4-119">İade değeri `false,` `message` (ve null durumu) değeri ise null.</span><span class="sxs-lookup"><span data-stu-id="289a4-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="289a4-120">Kural tamamen `key` değişken türü ile ifade `key` edilebilir: nullable olmayan bir referans türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="289a4-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="289a4-121">Parametre `message` daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="289a4-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="289a4-122">Bu `null` argüman olarak izin verir, ama garanti, `out` başarı, bu argüman null değildir.</span><span class="sxs-lookup"><span data-stu-id="289a4-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="289a4-123">Bu senaryolar için, beklentileri açıklamak için daha zengin bir kelime gerekir.</span><span class="sxs-lookup"><span data-stu-id="289a4-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="289a4-124">Kitaplığınızı geçersiz başvurular için güncelleştirmek, bazı `?` değişkenlere ve tür adlarına serpintiden daha fazlasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="289a4-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="289a4-125">Önceki örnek, API'lerinizi incelemeniz ve her giriş bağımsız değişkeni için beklentilerinizi göz önünde bulundurmanız gerektiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="289a4-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="289a4-126">İade değeri garantilerini ve yöntemin `out` `ref` iadesi üzerine herhangi bir veya bağımsız değişkeni göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="289a4-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="289a4-127">Ardından bu kuralları derleyiciye iletin ve derleyici arayanlar bu kurallara uymadığında uyarılar sağlar.</span><span class="sxs-lookup"><span data-stu-id="289a4-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="289a4-128">Bu iş zaman alır.</span><span class="sxs-lookup"><span data-stu-id="289a4-128">This work takes time.</span></span> <span data-ttu-id="289a4-129">Diğer gereksinimleri ve teslim edilebilirleri dengelerken kitaplığınızı veya uygulamanızı geçersiz kılınabilir hale getirecek stratejilerle başlayalım.</span><span class="sxs-lookup"><span data-stu-id="289a4-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements and deliverables.</span></span> <span data-ttu-id="289a4-130">Geçersiz başvuru türlerini etkinleştiren devam eden geliştirmeyi nasıl dengelersiniz göreceğiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="289a4-131">Genel tür tanımları için zorlukları öğreneceksiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="289a4-132">Tek tek API'larda ön ve sonrası koşulları açıklamak için öznitelikleri uygulamayı öğreneceksiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="289a4-133">Nullable başvuru türleri için bir strateji seçin</span><span class="sxs-lookup"><span data-stu-id="289a4-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="289a4-134">İlk seçenek, geçersiz başvuru türlerinin varsayılan olarak açık mı yoksa kapalı mı olması gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="289a4-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="289a4-135">İki stratejiniz var:</span><span class="sxs-lookup"><span data-stu-id="289a4-135">You have two strategies:</span></span>

- <span data-ttu-id="289a4-136">Tüm proje için geçersiz başvuru türlerini etkinleştirin ve hazır olmayan kodda devre dışı edin.</span><span class="sxs-lookup"><span data-stu-id="289a4-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="289a4-137">Yalnızca nullable başvuru türleri için açıklamalı olan kod için nullable başvuru türlerini etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="289a4-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="289a4-138">İlk strateji, geçersiz başvuru türleri için güncellerken kitaplığa diğer özellikler eklerken en iyi şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="289a4-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="289a4-139">Tüm yeni gelişme geçersiz farkındadır.</span><span class="sxs-lookup"><span data-stu-id="289a4-139">All new development is nullable aware.</span></span> <span data-ttu-id="289a4-140">Varolan kodu güncelleştirerken, bu sınıflarda nullable başvuru türlerini etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="289a4-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="289a4-141">Bu ilk stratejiyi izleyerek aşağıdakileri yaparsınız:</span><span class="sxs-lookup"><span data-stu-id="289a4-141">Following this first strategy, you do the following:</span></span>

1. <span data-ttu-id="289a4-142">Öğeyi `<Nullable>enable</Nullable>` *csproj* dosyalarınıza ekleyerek tüm proje için nullable başvuru türlerini etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="289a4-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="289a4-143">Projenizdeki `#nullable disable` her kaynak dosyaya pragma ekleyin.</span><span class="sxs-lookup"><span data-stu-id="289a4-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="289a4-144">Her dosya üzerinde çalışırken, pragma kaldırın ve herhangi bir uyarı adresi.</span><span class="sxs-lookup"><span data-stu-id="289a4-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="289a4-145">Bu ilk strateji, her dosyaya pragma eklemek için daha ön çalışma vardır.</span><span class="sxs-lookup"><span data-stu-id="289a4-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="289a4-146">Avantajı, projeye eklenen her yeni kod dosyasının boşalınabilen etkin olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="289a4-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="289a4-147">Herhangi bir yeni iş farkında geçersiz olacaktır; yalnızca varolan kodun güncelleştirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="289a4-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="289a4-148">İkinci strateji, kitaplık genellikle kararlıysa daha iyi çalışır ve geliştirmenin ana odak noktası geçersiz başvuru türlerini benimsemektir.</span><span class="sxs-lookup"><span data-stu-id="289a4-148">The second strategy works better if the library is generally stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="289a4-149">API'lere açıklama eklerken geçersiz başvuru türlerini açarsınız.</span><span class="sxs-lookup"><span data-stu-id="289a4-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="289a4-150">Bitirdikten sonra, tüm proje için geçersiz başvuru türlerini etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="289a4-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="289a4-151">Bu ikinci stratejiyi takip ederek aşağıdakileri yaparsınız:</span><span class="sxs-lookup"><span data-stu-id="289a4-151">Following this second strategy you do the following:</span></span>

1. <span data-ttu-id="289a4-152">Nullable `#nullable enable` farkında yapmak istediğiniz dosyaya pragma ekleyin.</span><span class="sxs-lookup"><span data-stu-id="289a4-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="289a4-153">Tüm uyarıları ele alın.</span><span class="sxs-lookup"><span data-stu-id="289a4-153">Address any warnings.</span></span>
1. <span data-ttu-id="289a4-154">Tüm kitaplığı geçersiz kılınana kadar bu ilk iki adıma devam edin.</span><span class="sxs-lookup"><span data-stu-id="289a4-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="289a4-155">Öğeyi `<Nullable>enable</Nullable>` *csproj* dosyalarınıza ekleyerek tüm proje için geçersiz türleri etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="289a4-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="289a4-156">Pragmaları `#nullable enable` kaldırın, çünkü artık ihtiyaç duyulmaz.</span><span class="sxs-lookup"><span data-stu-id="289a4-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="289a4-157">Bu ikinci strateji daha az iş ön vardır.</span><span class="sxs-lookup"><span data-stu-id="289a4-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="289a4-158">Takas, yeni bir dosya oluşturduğunuzda ilk görevin pragmayı eklemek ve onu geçersiz kılınabilir hale getirmek olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="289a4-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="289a4-159">Ekibinizdeki herhangi bir geliştirici unutursa, bu yeni kod artık tüm kodu geçersiz kılmak için birikme çalışmasının biriktirme listesindedir.</span><span class="sxs-lookup"><span data-stu-id="289a4-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="289a4-160">Seçtiğiniz bu stratejilerden hangisi, projenizde ne kadar etkin geliştirme nin gerçekleştiğine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="289a4-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="289a4-161">Projeniz ne kadar olgun ve istikrarlı sayılsa, ikinci strateji de o kadar iyi.</span><span class="sxs-lookup"><span data-stu-id="289a4-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="289a4-162">Ne kadar çok özellik geliştirilirse, ilk strateji o kadar iyi.</span><span class="sxs-lookup"><span data-stu-id="289a4-162">The more features being developed, the better the first strategy.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="289a4-163">Geçersiz uyarılar kırılma değişikliklerine neden olmalı mı?</span><span class="sxs-lookup"><span data-stu-id="289a4-163">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="289a4-164">Nullable başvuru türlerini etkinleştirmeden önce, değişkenler *geçersiz olarak*kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="289a4-164">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="289a4-165">Nullable başvuru türlerini etkinleştirdikten sonra, tüm bu değişkenler *nullable değildir.*</span><span class="sxs-lookup"><span data-stu-id="289a4-165">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="289a4-166">Derleyici, bu değişkenler null olmayan değerlere başharflemedeğilse uyarılar verir.</span><span class="sxs-lookup"><span data-stu-id="289a4-166">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="289a4-167">Olası bir diğer uyarı kaynağı da, değer başharfe atılmamışsa iade değerleridir.</span><span class="sxs-lookup"><span data-stu-id="289a4-167">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="289a4-168">Derleyici uyarılarıele ilk adım, bağımsız `?` değişkenlerin veya iade değerlerinin ne zaman null olabileceğini belirtmek için parametre ve iade türlerinde ek açıklamalar kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="289a4-168">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="289a4-169">Başvuru değişkenleri null olmamalıdır, özgün bildirimi doğrudur.</span><span class="sxs-lookup"><span data-stu-id="289a4-169">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="289a4-170">Bunu yaptığınızda, amacınız sadece uyarıları düzeltmek değildir.</span><span class="sxs-lookup"><span data-stu-id="289a4-170">As you do this, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="289a4-171">Daha önemli amaç, derleyicinin olası null değerleri için niyetinizi anlamasını sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="289a4-171">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="289a4-172">Uyarıları incelerken, kitaplığınız için bir sonraki önemli kararınızı verirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-172">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="289a4-173">Tasarım amacınızı daha net bir şekilde iletmek için API imzalarını değiştirmeyi düşünüyor musunuz?</span><span class="sxs-lookup"><span data-stu-id="289a4-173">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="289a4-174">Daha önce incelenen `TryGetMessage` yöntem için daha iyi bir API imzası olabilir:</span><span class="sxs-lookup"><span data-stu-id="289a4-174">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="289a4-175">İade değeri başarı veya başarısızlık gösterir ve değer bulunursa değeri taşır.</span><span class="sxs-lookup"><span data-stu-id="289a4-175">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="289a4-176">Çoğu durumda, API imzalarını değiştirmek boş değerleri nasıl ilettiklerini artırabilir.</span><span class="sxs-lookup"><span data-stu-id="289a4-176">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="289a4-177">Ancak, genel kitaplıklar veya büyük kullanıcı tabanlarına sahip kitaplıklar için, api imza değişiklikleri sunmamayı tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-177">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="289a4-178">Bu gibi durumlar ve diğer yaygın desenler için, bir bağımsız değişken veya `null`iade değeri ne zaman olabilir daha net tanımlamak için öznitelikleri uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-178">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="289a4-179">API'nizin yüzeyini değiştirmeyi düşünseniz de düşünmeseniz de, tür ek açıklamalarının bağımsız `null` değişkenler veya döndürme değerleri için değerleri açıklamak için tek başına yeterli olmadığını görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="289a4-179">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="289a4-180">Bu gibi durumlarda, bir API'yi daha net açıklamak için öznitelikleri uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-180">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="289a4-181">Öznitelikler tür ek açıklamalarını genişletir</span><span class="sxs-lookup"><span data-stu-id="289a4-181">Attributes extend type annotations</span></span>

<span data-ttu-id="289a4-182">Değişkenlerin null durumu hakkında ek bilgi ifade etmek için çeşitli öznitelikler eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="289a4-182">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="289a4-183">C# 8'den önce yazdığınız tüm kodlar nullable referans türlerini tanıttı *null habersiz*oldu.</span><span class="sxs-lookup"><span data-stu-id="289a4-183">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="289a4-184">Bu, herhangi bir başvuru türü değişkeninin null olabileceği, ancak null denetimlerin gerekli olmadığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="289a4-184">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="289a4-185">Bir kez kodunuzu *farkında geçersiz*olduğunda, bu kurallar değişir.</span><span class="sxs-lookup"><span data-stu-id="289a4-185">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="289a4-186">Referans türleri hiçbir `null` zaman değer olmamalıdır ve geçersiz başvuru `null` türleri referans gösterilmeden önce karşı denetlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="289a4-186">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="289a4-187">API senaryoda gördüğünüz gibi, API'lerinizin `TryGetValue` kuralları büyük olasılıkla daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="289a4-187">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="289a4-188">API'lerinizin çoğu, değişkenlerin ne zaman olabilir veya `null`olamaz için daha karmaşık kurallara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="289a4-188">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="289a4-189">Bu gibi durumlarda, bu kuralları ifade etmek için öznitelikleri kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="289a4-189">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="289a4-190">API'nizin anlambilimini açıklayan öznitelikler, [geçersiz çözümlemesi etkileyen Öznitelikler](./language-reference/attributes/nullable-analysis.md)makalesinde bulunur.</span><span class="sxs-lookup"><span data-stu-id="289a4-190">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="289a4-191">Genel tanımlar ve nullability</span><span class="sxs-lookup"><span data-stu-id="289a4-191">Generic definitions and nullability</span></span>

<span data-ttu-id="289a4-192">Genel türlerin ve genel yöntemlerin null durumunu doğru bir şekilde iletmek özel bakım gerektirir.</span><span class="sxs-lookup"><span data-stu-id="289a4-192">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="289a4-193">Bu, nullable değer türü ve nullable referans türü temelde farklı olduğu gerçeğinden kaynaklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="289a4-193">This stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="289a4-194">An, `int?` derleyici tarafından eklenen bir `string?` öznitelik ile ise eşanlamlıdır. `string` `Nullable<int>`</span><span class="sxs-lookup"><span data-stu-id="289a4-194">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="289a4-195">Sonuç olarak derleyici bir `T?` veya bir `T` `class` `struct`olup olmadığını bilmeden doğru kod oluşturamaz.</span><span class="sxs-lookup"><span data-stu-id="289a4-195">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="289a4-196">Bu, kapalı bir genel tür için tür bağımsız değişkeni olarak geçersiz bir türü (değer türü veya başvuru türü) kullanamayacağınız anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="289a4-196">This doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="289a4-197">Her `List<string?>` `List<int?>` ikisi de ve `List<T>`geçerli anlık vardır.</span><span class="sxs-lookup"><span data-stu-id="289a4-197">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="289a4-198">Bunun anlamı, kısıtlamalar olmadan genel `T?` bir sınıf veya yöntem bildiriminde kullanamadığınızdır.</span><span class="sxs-lookup"><span data-stu-id="289a4-198">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="289a4-199">Örneğin, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> döndürmek `T?`için değiştirilmez.</span><span class="sxs-lookup"><span data-stu-id="289a4-199">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="289a4-200">Bu sınırlamayı, kısıtlama yı `struct` `class` veya kısıtlamayı ekleyerek aşabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-200">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="289a4-201">Bu kısıtlamalardan herhangi biriyle, derleyici hem de `T` . `T?`</span><span class="sxs-lookup"><span data-stu-id="289a4-201">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="289a4-202">Genel bir tür bağımsız değişkeni için kullanılan türlerin nullable olmayan türleri olarak kısıtlamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-202">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="289a4-203">Bunu, bu tür `notnull` bağımsız değişkenine kısıtlama ekleyerek yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="289a4-203">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="289a4-204">Bu kısıtlama uygulandığında, tür bağımsız değişkeni nullable türü olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="289a4-204">When that constraint is applied, the type argument must not be a nullable type.</span></span>
