---
title: Hizmetten hizmete iletişim
description: Arka uç bulutu yerel mikro hizmetlerinin diğer arka uç mikro hizmetleriyle nasıl iletişim kuracağını öğrenin.
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: a5124b8b83f62ff17b1230ead63db26e0c1f2a5b
ms.sourcegitcommit: 7f8eeef060ddeb2cabfa52843776faf652c5a1f5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/14/2019
ms.locfileid: "74087605"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="c8251-103">Hizmetten hizmete iletişim</span><span class="sxs-lookup"><span data-stu-id="c8251-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="c8251-104">Ön uç istemcisinden geçiş yapmak için artık arka uç mikro hizmetleri birbirleriyle iletişim kuracak şekilde adresliyoruz.</span><span class="sxs-lookup"><span data-stu-id="c8251-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="c8251-105">Bulutta yerel bir uygulama oluştururken, arka uç hizmetlerinin birbirleriyle iletişim kurmasına karşı hassas olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="c8251-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="c8251-106">İdeal olarak, hizmet içi iletişim, daha iyi.</span><span class="sxs-lookup"><span data-stu-id="c8251-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="c8251-107">Bununla birlikte, arka uç hizmetleri genellikle bir işlemi tamamlamaya yönelik bir diğerine bağımlı olduğu için engelleme her zaman mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="c8251-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="c8251-108">Çapraz hizmet iletişimini uygulamak için yaygın olarak kabul edilen birkaç yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="c8251-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="c8251-109">*İletişim etkileşiminin türü* genellikle en iyi yaklaşımı saptacaktır.</span><span class="sxs-lookup"><span data-stu-id="c8251-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="c8251-110">Aşağıdaki etkileşim türlerini göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="c8251-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="c8251-111">*Sorgu* – çağıran bir mikro hizmet, "Hey, belirli bir müşteri kimliği için alıcı bilgilerini ver" gibi adlı bir mikro hizmetten yanıt gerektirdiğinde.</span><span class="sxs-lookup"><span data-stu-id="c8251-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="c8251-112">*Komut* – çağıran mikro hizmet, bir eylemi yürütmek için başka bir mikro hizmete ihtiyaç duyar ancak "Hey, bu siparişi gönder" gibi bir yanıt gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="c8251-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="c8251-113">*Olay* – yayımcı olarak adlandırılan bir mikro hizmet, durumun değiştiği veya bir eylemin gerçekleştiği bir olay oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c8251-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="c8251-114">Abone olarak adlandırılan diğer mikro hizmetler olaya uygun şekilde tepki verebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="c8251-115">Yayımcı ve aboneler birbirleriyle uyumlu değildir.</span><span class="sxs-lookup"><span data-stu-id="c8251-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="c8251-116">Mikro hizmet sistemleri, genellikle çapraz hizmet etkileşimi gerektiren işlemleri yürütürken bu etkileşim türlerinin bir birleşimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="c8251-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="c8251-117">Her birine ve bunları nasıl uygulayabileceğinizi yakından inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="c8251-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="c8251-118">Sorgular</span><span class="sxs-lookup"><span data-stu-id="c8251-118">Queries</span></span>

<span data-ttu-id="c8251-119">Birçok kez, bir mikro hizmetin bir işlemi tamamlamaya yönelik acil bir yanıt gerektiren başka bir şekilde *sorgu* yapması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="c8251-120">Bir alışveriş sepeti mikro hizmeti, ürün bilgileri ve sepetine bir öğe eklemek için bir fiyat gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="c8251-121">Sorgu işlemlerini uygulamak için birkaç yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="c8251-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="c8251-122">İstek/yanıt Iletisi</span><span class="sxs-lookup"><span data-stu-id="c8251-122">Request/Response Messaging</span></span>

<span data-ttu-id="c8251-123">Bu senaryoyu uygulamaya yönelik bir seçenek, arama arka uç mikro hizmeti 'nin sorgu yapması gereken mikro hizmetlere doğrudan HTTP istekleri yapmasını sağlamak için Şekil 4-8 ' de gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="c8251-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![Doğrudan HTTP iletişimi](./media/direct-http-communication.png)

<span data-ttu-id="c8251-125">**Şekil 4-8**.</span><span class="sxs-lookup"><span data-stu-id="c8251-125">**Figure 4-8**.</span></span> <span data-ttu-id="c8251-126">Doğrudan HTTP iletişimi</span><span class="sxs-lookup"><span data-stu-id="c8251-126">Direct HTTP communication</span></span>

<span data-ttu-id="c8251-127">Mikro hizmetler arasındaki doğrudan HTTP çağrılarının uygulanması nispeten basittir, ancak bu uygulamayı en aza indirmek için dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c8251-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="c8251-128">Başlamak için, bu çağrılar her zaman *zaman uyumludur* ve bir sonuç döndürülene veya istek zaman aşımlarına kadar işlemi engeller.</span><span class="sxs-lookup"><span data-stu-id="c8251-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="c8251-129">Bağımsız olarak, bağımsız hizmetler, bağımsız olarak gelişebilir ve sık sık dağıtımı yapabildikleri için, artık birbirleriyle birbirine bağlanmış hale gelmiştir.</span><span class="sxs-lookup"><span data-stu-id="c8251-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="c8251-130">Mikro hizmetler arasında bir eşlenme artışı artdıkça, bunların mimari avantajları azalmaktadır.</span><span class="sxs-lookup"><span data-stu-id="c8251-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="c8251-131">Başka bir mikro hizmete tek bir doğrudan HTTP çağrısı yapan seyrek erişimli bir isteğin yürütülmesi bazı sistemler için kabul edilebilir durumda olabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="c8251-132">Ancak, birden fazla mikro hizmete doğrudan HTTP çağrıları çağıran yüksek hacimli çağrılar önerilmez.</span><span class="sxs-lookup"><span data-stu-id="c8251-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="c8251-133">Gecikme süresini artırabilir ve sisteminizin performansını, ölçeklenebilirliğini ve kullanılabilirliğini olumsuz yönde etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="c8251-134">Daha da kötüleşirse, uzun bir doğrudan HTTP iletişimi dizisi, Şekil 4-9 ' de gösterilen, zaman uyumlu mikro hizmet çağrılarının derin ve karmaşık zincirlerine yol açabilir:</span><span class="sxs-lookup"><span data-stu-id="c8251-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![HTTP sorgularını zincirleme](./media/chaining-http-queries.png)

<span data-ttu-id="c8251-136">**Şekil 4-9**.</span><span class="sxs-lookup"><span data-stu-id="c8251-136">**Figure 4-9**.</span></span> <span data-ttu-id="c8251-137">HTTP sorgularını zincirleme</span><span class="sxs-lookup"><span data-stu-id="c8251-137">Chaining HTTP queries</span></span>

<span data-ttu-id="c8251-138">Önceki görüntüde gösterilen tasarımda riski tamamen hayal edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c8251-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="c8251-139">Adım \#3 başarısız olursa ne olur?</span><span class="sxs-lookup"><span data-stu-id="c8251-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="c8251-140">Ya da \#8. adım başarısız oluyor?</span><span class="sxs-lookup"><span data-stu-id="c8251-140">Or Step \#8 fails?</span></span> <span data-ttu-id="c8251-141">Nasıl kurtarılır?</span><span class="sxs-lookup"><span data-stu-id="c8251-141">How do you recover?</span></span> <span data-ttu-id="c8251-142">Temel alınan hizmet meşgul olduğundan \#6 ' nın yavaşlamasına neden olur?</span><span class="sxs-lookup"><span data-stu-id="c8251-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="c8251-143">Nasıl devam edersiniz?</span><span class="sxs-lookup"><span data-stu-id="c8251-143">How do you continue?</span></span> <span data-ttu-id="c8251-144">Tümü doğru çalışıyor olsa bile, her adımın gecikme süresinin toplamı olan bu çağrının tabi olacağı gecikmeyi düşünün.</span><span class="sxs-lookup"><span data-stu-id="c8251-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="c8251-145">Önceki görüntüde geçen büyük ölçüde, hizmetlerin en iyi modellenmedi.</span><span class="sxs-lookup"><span data-stu-id="c8251-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="c8251-146">Bu, takımın tasarımını yeniden ziyaret behoove.</span><span class="sxs-lookup"><span data-stu-id="c8251-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="c8251-147">Gerçekleştirilmiş görünüm deseninin</span><span class="sxs-lookup"><span data-stu-id="c8251-147">Materialized View pattern</span></span>

<span data-ttu-id="c8251-148">Mikro hizmet bağlantısını kaldırmaya yönelik popüler bir seçenek [gerçekleştirilmiş görünüm](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)modelidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="c8251-149">Bu düzende, bir mikro hizmet, diğer hizmetlere ait kendi yerel, Normalleştirilmemiş verileri saklar.</span><span class="sxs-lookup"><span data-stu-id="c8251-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="c8251-150">Ürün kataloğunu ve fiyatlandırma mikro hizmetlerini sorgulayan alışveriş sepeti mikro hizmeti yerine, bu verilerin kendi yerel kopyasını tutar.</span><span class="sxs-lookup"><span data-stu-id="c8251-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="c8251-151">Bu kalıp gereksiz kuponu ortadan kaldırır ve güvenilirliği ve yanıt süresini geliştirir.</span><span class="sxs-lookup"><span data-stu-id="c8251-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="c8251-152">Tüm işlem tek bir işlem içinde yürütülür.</span><span class="sxs-lookup"><span data-stu-id="c8251-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="c8251-153">Bölüm 5 ' teki bu model ve diğer veri sorunlarını araştırıyoruz.</span><span class="sxs-lookup"><span data-stu-id="c8251-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="c8251-154">Hizmet toplayıcı stili</span><span class="sxs-lookup"><span data-stu-id="c8251-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="c8251-155">Mikro hizmetten mikro hizmet bağlantısını ortadan kaldırmaya yönelik başka bir seçenek de Şekil 4-10 ' de mor renkte gösterilen bir [toplayıcı mikro hizmetidir](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/).</span><span class="sxs-lookup"><span data-stu-id="c8251-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![Toplayıcı hizmeti](./media/aggregator-service.png)

<span data-ttu-id="c8251-157">**Şekil 4-10**.</span><span class="sxs-lookup"><span data-stu-id="c8251-157">**Figure 4-10**.</span></span> <span data-ttu-id="c8251-158">Toplayıcı mikro hizmeti</span><span class="sxs-lookup"><span data-stu-id="c8251-158">Aggregator microservice</span></span>

<span data-ttu-id="c8251-159">Bu model, birden fazla arka uç mikro hizmetine çağrı yapan ve mantığını özel bir mikro hizmet halinde sunan bir işlemi yalıtır.</span><span class="sxs-lookup"><span data-stu-id="c8251-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="c8251-160">Önceki şekildeki mor kullanıma alma toplayıcısı mikro hizmeti, kullanıma alma işlemi için iş akışını düzenler.</span><span class="sxs-lookup"><span data-stu-id="c8251-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="c8251-161">Sıralı bir düzende birkaç arka uç mikro hizmet çağrısı içerir.</span><span class="sxs-lookup"><span data-stu-id="c8251-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="c8251-162">İş akışındaki veriler toplanır ve çağırana döndürülür.</span><span class="sxs-lookup"><span data-stu-id="c8251-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="c8251-163">Doğrudan HTTP çağrıları uyguladığından toplayıcı mikro hizmeti, arka uç mikro hizmetleri arasındaki doğrudan bağımlılıkları azaltır.</span><span class="sxs-lookup"><span data-stu-id="c8251-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="c8251-164">İstek/yanıt kalıbı</span><span class="sxs-lookup"><span data-stu-id="c8251-164">Request/Reply Pattern</span></span>

<span data-ttu-id="c8251-165">Zaman uyumlu HTTP iletilerini ayrışmaya yönelik başka bir yaklaşım, kuyruğa alma iletişimini kullanan bir [istek-yanıt Örünğidir](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html).</span><span class="sxs-lookup"><span data-stu-id="c8251-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="c8251-166">Bir kuyruk kullanan iletişim, bir üretici tarafından iletiyi gönderen ve tüketiciye alan tek yönlü bir kanaldır.</span><span class="sxs-lookup"><span data-stu-id="c8251-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="c8251-167">Bu düzende, Şekil 4-11 ' de gösterilen bir istek kuyruğu ve yanıt kuyruğu uygulanır.</span><span class="sxs-lookup"><span data-stu-id="c8251-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![İstek-yanıt kalıbı](./media/request-reply-pattern.png)

<span data-ttu-id="c8251-169">**Şekil 4-11**.</span><span class="sxs-lookup"><span data-stu-id="c8251-169">**Figure 4-11**.</span></span> <span data-ttu-id="c8251-170">İstek-yanıt kalıbı</span><span class="sxs-lookup"><span data-stu-id="c8251-170">Request-reply pattern</span></span>

<span data-ttu-id="c8251-171">Burada ileti üreticisi, benzersiz bir bağıntı KIMLIĞI içeren sorgu tabanlı bir ileti oluşturur ve bunu bir istek kuyruğuna koyar.</span><span class="sxs-lookup"><span data-stu-id="c8251-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="c8251-172">Tüketen hizmet iletileri kuyruktan kaldırır, işler ve yanıtı aynı bağıntı KIMLIĞI ile yanıt kuyruğuna koyar.</span><span class="sxs-lookup"><span data-stu-id="c8251-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="c8251-173">Üretici hizmeti iletiyi kuyruktan kaldırır, bağıntı KIMLIĞIYLE eşleşmez ve işlemeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="c8251-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="c8251-174">Sonraki bölümde kuyrukları ayrıntılı olarak ele aldık.</span><span class="sxs-lookup"><span data-stu-id="c8251-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="c8251-175">Komutlar</span><span class="sxs-lookup"><span data-stu-id="c8251-175">Commands</span></span>

<span data-ttu-id="c8251-176">Başka bir iletişim etkileşimi türü bir *komuttur*.</span><span class="sxs-lookup"><span data-stu-id="c8251-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="c8251-177">Bir mikro hizmetin bir eylemi gerçekleştirmesi için başka bir mikro hizmet gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="c8251-178">Sipariş mikro hizmeti, onaylanmış bir sipariş için bir sevkiyat oluşturmak üzere, gönderim mikro hizmeti 'ne ihtiyaç duyuyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="c8251-179">Şekil 4-12 ' de, üretici olarak adlandırılan bir mikro hizmet, başka bir mikro hizmet olan tüketiciye bir ileti gönderir ve bunu bir şey yapması için iletir.</span><span class="sxs-lookup"><span data-stu-id="c8251-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![Kuyrukla komut etkileşimi](./media/command-interaction-with-queue.png)

<span data-ttu-id="c8251-181">**Şekil 4-12**.</span><span class="sxs-lookup"><span data-stu-id="c8251-181">**Figure 4-12**.</span></span> <span data-ttu-id="c8251-182">Kuyrukla komut etkileşimi</span><span class="sxs-lookup"><span data-stu-id="c8251-182">Command interaction with a queue</span></span>

<span data-ttu-id="c8251-183">Çoğu zaman, üretici bir yanıt gerektirmez ve iletiyi *başlatamaz ve unutabilirler* .</span><span class="sxs-lookup"><span data-stu-id="c8251-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="c8251-184">Bir yanıt gerekiyorsa, tüketici başka bir kanalda üretici 'ya ayrı bir ileti gönderir.</span><span class="sxs-lookup"><span data-stu-id="c8251-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="c8251-185">Bir komut iletisi en iyi şekilde bir ileti kuyruğu ile zaman uyumsuz olarak gönderilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="c8251-186">bir hafif ileti Aracısı tarafından desteklenir.</span><span class="sxs-lookup"><span data-stu-id="c8251-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="c8251-187">Önceki diyagramda, bir sıranın her iki hizmeti nasıl ayırdığına ve bunların nasıl ayrılmış olduğuna ilişkin bir sıra.</span><span class="sxs-lookup"><span data-stu-id="c8251-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="c8251-188">İleti kuyruğu, bir üreticinin ve tüketicinin ileti iletgeçen bir ara yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="c8251-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="c8251-189">Kuyruklar, zaman uyumsuz, noktadan noktaya mesajlaşma düzenlerini uygular.</span><span class="sxs-lookup"><span data-stu-id="c8251-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="c8251-190">Üretici bir komutun doğru bir şekilde gönderilmesi ve yönlendirilmesi gereken yerleri bilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="c8251-191">Sıra, bir iletinin, kanaldan okuyan tüketici örneklerinden tam olarak bir ileti ile işlenmesini güvence altına alır.</span><span class="sxs-lookup"><span data-stu-id="c8251-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="c8251-192">Bu senaryoda, üretici veya tüketici hizmeti diğerini etkilemeden ölçeği değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="c8251-193">Ayrıca, teknolojiler her bir tarafta farklı olabilir, yani bir [Golang](https://golang.org) mikro hizmeti çağıran bir Java mikro hizmeti olabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="c8251-194">Bölüm 1 ' de, *yedekleme hizmetleri*hakkında konuşuyoruz.</span><span class="sxs-lookup"><span data-stu-id="c8251-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="c8251-195">Yedekleme Hizmetleri, bulutta yerel sistemlerin bağımlı olduğu yardımcı kaynaklardır.</span><span class="sxs-lookup"><span data-stu-id="c8251-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="c8251-196">İleti kuyrukları Hizmetleri yedekliyor.</span><span class="sxs-lookup"><span data-stu-id="c8251-196">Message queues are backing services.</span></span> <span data-ttu-id="c8251-197">Azure bulutu, bulutta yerel sistemlerinizin komut iletilerini uygulamak için tüketebileceği iki tür ileti kuyruğu destekler: Azure depolama kuyrukları ve Azure Service Bus kuyrukları.</span><span class="sxs-lookup"><span data-stu-id="c8251-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="c8251-198">Azure depolama kuyrukları</span><span class="sxs-lookup"><span data-stu-id="c8251-198">Azure Storage Queues</span></span>

<span data-ttu-id="c8251-199">Azure depolama kuyrukları, hızlı, ekonomik ve Azure depolama hesapları tarafından desteklenen basit bir sıraya alma altyapısı sunar.</span><span class="sxs-lookup"><span data-stu-id="c8251-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="c8251-200">[Azure depolama kuyrukları](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) , güvenilir ve kalıcı mesajlaşma ile REST tabanlı bir sıraya alma mekanizması özelliği.</span><span class="sxs-lookup"><span data-stu-id="c8251-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="c8251-201">Bunlar en az bir özellik kümesi sağlar, ancak ucuzdur ve milyonlarca ileti depolar.</span><span class="sxs-lookup"><span data-stu-id="c8251-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="c8251-202">Kapasite aralıkları 500 TB 'a kadar değişir.</span><span class="sxs-lookup"><span data-stu-id="c8251-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="c8251-203">Tek bir ileti boyutu 64 KB 'ye kadar olabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="c8251-204">HTTP veya HTTPS kullanarak kimliği doğrulanmış çağrılar aracılığıyla dünyanın her yerinden iletilere erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c8251-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="c8251-205">Depolama kuyrukları, trafik artışlarını işlemek için çok sayıda eşzamanlı istemciye ölçeklenebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="c8251-206">Bu, hizmetle ilgili sınırlamalar vardır:</span><span class="sxs-lookup"><span data-stu-id="c8251-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="c8251-207">İleti sırası garanti edilmez.</span><span class="sxs-lookup"><span data-stu-id="c8251-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="c8251-208">İleti, otomatik olarak kaldırılmadan önce yedi gün boyunca devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="c8251-209">Durum yönetimi için destek, yinelenen algılama veya işlemler kullanılamıyor.</span><span class="sxs-lookup"><span data-stu-id="c8251-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="c8251-210">Şekil 4-13 ' de bir Azure depolama sırasının hiyerarşisi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="c8251-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![Depolama kuyruğu hiyerarşisi](./media/storage-queue-hierarchy.png)

<span data-ttu-id="c8251-212">**Şekil 4-13**.</span><span class="sxs-lookup"><span data-stu-id="c8251-212">**Figure 4-13**.</span></span> <span data-ttu-id="c8251-213">Depolama kuyruğu hiyerarşisi</span><span class="sxs-lookup"><span data-stu-id="c8251-213">Storage queue hierarchy</span></span>

<span data-ttu-id="c8251-214">Önceki şekilde, depolama sıralarının iletilerini temel alınan Azure depolama hesabında nasıl depolamalarını aklınızda bir yere göz önüne alın.</span><span class="sxs-lookup"><span data-stu-id="c8251-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="c8251-215">Geliştiriciler için Microsoft, depolama kuyruğu işleme için birkaç istemci ve sunucu tarafı kitaplığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="c8251-216">.NET, Java, JavaScript, Ruby, Python ve go dahil çoğu büyük platform desteklenir.</span><span class="sxs-lookup"><span data-stu-id="c8251-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="c8251-217">Geliştiriciler hiçbir şekilde doğrudan bu kitaplıklarla iletişim kurmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="c8251-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="c8251-218">Bunun yapılması, mikro hizmet kodunuzu Azure depolama Kuyruk hizmeti sıkı bir şekilde daha sıkı bir şekilde ister.</span><span class="sxs-lookup"><span data-stu-id="c8251-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="c8251-219">API 'nin uygulama ayrıntılarını tahmin etmek daha iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="c8251-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="c8251-220">Genel işlemleri sunan ve somut kitaplığı kapsülleyen bir intermediation katmanını veya ara API 'yi tanıtın.</span><span class="sxs-lookup"><span data-stu-id="c8251-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="c8251-221">Bu gevşek bağlantısı, ana hat Hizmeti kodunda değişiklik yapmak zorunda kalmadan bir sıraya alma hizmetini başka bir sıraya takabilmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="c8251-222">Azure depolama kuyrukları, bulutta yerel uygulamalarınızda komut mesajlaşmasını uygulamak için ekonomik bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="c8251-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="c8251-223">Özellikle bir sıra boyutu 80 GB 'ı aşacağından veya basit bir özellik kümesi kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="c8251-224">Yalnızca iletilerin depolanması için ödeme yaparsınız; Sabit saatlik ücret yoktur.</span><span class="sxs-lookup"><span data-stu-id="c8251-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="c8251-225">Azure Service Bus kuyrukları</span><span class="sxs-lookup"><span data-stu-id="c8251-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="c8251-226">Daha karmaşık mesajlaşma gereksinimleri için Azure Service Bus kuyrukları göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="c8251-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="c8251-227">Güvenilir bir ileti altyapısı [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) , *aracılı bir mesajlaşma modelini*destekler.</span><span class="sxs-lookup"><span data-stu-id="c8251-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="c8251-228">İletiler, tüketici tarafından alınana kadar güvenilir bir şekilde bir aracıda (kuyruk) depolanır.</span><span class="sxs-lookup"><span data-stu-id="c8251-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="c8251-229">Kuyruk, iletilerin kuyruğa eklenme sırasını önceden belirleyen Ilk/Ilk çıkar (FıFO) ileti teslimini garanti eder.</span><span class="sxs-lookup"><span data-stu-id="c8251-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="c8251-230">Bir iletinin boyutu, 256 KB 'a kadar çok daha büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="c8251-231">İletiler kuyrukta sınırsız bir süre için kalıcıdır.</span><span class="sxs-lookup"><span data-stu-id="c8251-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="c8251-232">Service Bus yalnızca HTTP tabanlı çağrıların değil, ayrıca [Ampq Protokolü](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)için tam destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="c8251-233">AMPQ, bir ikili Protokolü ve daha yüksek düzeyde güvenilirliği destekleyen satıcılar genelinde açık bir standarttır.</span><span class="sxs-lookup"><span data-stu-id="c8251-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="c8251-234">Service Bus, [işlem desteği](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) ve [yinelenen bir algılama özelliği](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)de dahil olmak üzere zengin bir özellik kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="c8251-235">Kuyruk, ileti başına "en fazla bir kez teslimi" garantisi verir.</span><span class="sxs-lookup"><span data-stu-id="c8251-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="c8251-236">Zaten gönderilen bir iletiyi otomatik olarak atar.</span><span class="sxs-lookup"><span data-stu-id="c8251-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="c8251-237">Bir üretici şüpheli ise, aynı iletiyi yeniden gönderebilir ve Service Bus yalnızca tek bir kopyanın işleneceğini garanti eder.</span><span class="sxs-lookup"><span data-stu-id="c8251-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="c8251-238">Yinelenen algılama, sizi ek altyapı sıhhi tesisat oluşturmak zorunda kalmaktan kurtarır.</span><span class="sxs-lookup"><span data-stu-id="c8251-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="c8251-239">Daha fazla kurumsal özellik bölümlendirme ve oturumlardır.</span><span class="sxs-lookup"><span data-stu-id="c8251-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="c8251-240">Geleneksel Service Bus kuyruğu tek bir ileti Aracısı tarafından işlenir ve tek bir ileti deposunda depolanır.</span><span class="sxs-lookup"><span data-stu-id="c8251-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="c8251-241">Ancak [Service Bus bölümleme](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) , kuyruğu birden çok ileti aracılarında ve ileti depolarında yayar.</span><span class="sxs-lookup"><span data-stu-id="c8251-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="c8251-242">Genel aktarım hızı artık tek bir ileti aracısının veya mesajlaşma deposunun performansıyla sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="c8251-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="c8251-243">Bir mesajlaşma deposunun geçici bir kesinti, bölümlenmiş bir kuyruğu kullanılamaz olarak işlemez.</span><span class="sxs-lookup"><span data-stu-id="c8251-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="c8251-244">[Service Bus oturumlar](https://codingcanvas.com/azure-service-bus-sessions/) , gruplandırılmanız için bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="c8251-245">İletilerin birlikte işlenmesi ve işlemin sonunda tamamlanması gereken bir iş akışı senaryosu düşünün.</span><span class="sxs-lookup"><span data-stu-id="c8251-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="c8251-246">Tüm avantajlardan yararlanmak için, oturum açık olarak Kuyruk için etkin olmalıdır ve ilgili her bir ileti aynı oturum KIMLIĞINI içermelidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="c8251-247">Ancak bazı önemli uyarılar vardır: Service Bus kuyruk boyutu 80 GB ile sınırlıdır ve bu, mağaza kuyruklarından kullanılabilir olandan çok daha küçüktür.</span><span class="sxs-lookup"><span data-stu-id="c8251-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="c8251-248">Ayrıca, Service Bus kuyruklar bir temel maliyet ve işlem başına ücretlendirilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="c8251-249">Şekil 4-14 Service Bus sırasının üst düzey mimarisini özetler.</span><span class="sxs-lookup"><span data-stu-id="c8251-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![Service Bus kuyruğu](./media/service-bus-queue.png)

<span data-ttu-id="c8251-251">**Şekil 4-14**.</span><span class="sxs-lookup"><span data-stu-id="c8251-251">**Figure 4-14**.</span></span> <span data-ttu-id="c8251-252">Service Bus kuyruğu</span><span class="sxs-lookup"><span data-stu-id="c8251-252">Service Bus queue</span></span>

<span data-ttu-id="c8251-253">Önceki şekilde, noktadan noktaya ilişkisini aklınızda yapın.</span><span class="sxs-lookup"><span data-stu-id="c8251-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="c8251-254">Aynı sağlayıcının iki örneği iletileri tek bir Service Bus kuyruğuna sıraya ayırır.</span><span class="sxs-lookup"><span data-stu-id="c8251-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="c8251-255">Her ileti, sağdaki üç tüketici örneğinin yalnızca biri tarafından kullanılır.</span><span class="sxs-lookup"><span data-stu-id="c8251-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="c8251-256">Daha sonra, farklı tüketicilerin aynı iletiyle ilgilendiği mesajlaşmayı nasıl uygulayabileceğinizi anladık.</span><span class="sxs-lookup"><span data-stu-id="c8251-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="c8251-257">Olaylar</span><span class="sxs-lookup"><span data-stu-id="c8251-257">Events</span></span>

<span data-ttu-id="c8251-258">Message Queuing, bir üreticinin zaman uyumsuz olarak bir tüketici ileti gönderebildiği iletişim uygulamak için etkili bir yoldur.</span><span class="sxs-lookup"><span data-stu-id="c8251-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="c8251-259">Ancak, aynı iletiyle *birçok farklı tüketici* ilgilendiğinde ne olur?</span><span class="sxs-lookup"><span data-stu-id="c8251-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="c8251-260">Her tüketiciye yönelik adanmış bir ileti kuyruğu iyi ölçeklendirilmez ve yönetimi zor hale gelir.</span><span class="sxs-lookup"><span data-stu-id="c8251-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="c8251-261">Bu senaryoyu ele almak için, üçüncü ileti etkileşim türüne ( *olay*) geçeceğiz.</span><span class="sxs-lookup"><span data-stu-id="c8251-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="c8251-262">Bir mikro hizmet, bir eylemin oluştuğunu duyurur.</span><span class="sxs-lookup"><span data-stu-id="c8251-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="c8251-263">Diğer mikro hizmetler, ilgileniyorsa eyleme veya olaya tepki verir.</span><span class="sxs-lookup"><span data-stu-id="c8251-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="c8251-264">Olay iki adımlı bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="c8251-264">Eventing is a two-step process.</span></span> <span data-ttu-id="c8251-265">Bir mikro hizmet, belirli bir durum değişikliği için ileti aracısına bir olay yayımlar ve bunu başka bir ilgilenen mikro hizmet tarafından kullanılabilir hale getirir.</span><span class="sxs-lookup"><span data-stu-id="c8251-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="c8251-266">İleti aracısıdır olayına abone olunarak ilgilendiğimiz mikro hizmet bildirilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="c8251-267">[Olay tabanlı iletişim](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)uygulamak için [Yayımla/abone ol](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) ' a gidin.</span><span class="sxs-lookup"><span data-stu-id="c8251-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="c8251-268">Şekil 4-15 ' de, bir olay yayımlayan bir alışveriş sepeti mikro hizmeti, diğer iki mikro hizmetle abone olur.</span><span class="sxs-lookup"><span data-stu-id="c8251-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![Olay odaklı mesajlaşma](./media/event-driven-messaging.png)

<span data-ttu-id="c8251-270">**Şekil 4-15**.</span><span class="sxs-lookup"><span data-stu-id="c8251-270">**Figure 4-15**.</span></span> <span data-ttu-id="c8251-271">Olay odaklı mesajlaşma</span><span class="sxs-lookup"><span data-stu-id="c8251-271">Event-Driven messaging</span></span>

<span data-ttu-id="c8251-272">İletişim kanalının ortasında bulunan *olay veri yolu* bileşenini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="c8251-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="c8251-273">Bu, ileti Aracısı 'nı kapsülleyen ve temel alınan uygulamadan ayrışlayan özel bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="c8251-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="c8251-274">Sıralama ve stok mikro hizmetleri, olayı birbirleriyle veya alışveriş sepeti mikro hizmeti olmadan bağımsız olarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="c8251-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="c8251-275">Kayıtlı olay, olay veri yoluna yayımlandığında, üzerinde işlem görür.</span><span class="sxs-lookup"><span data-stu-id="c8251-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="c8251-276">Olay ile, sıraya alma teknolojisinden *konulara*geçiş yaptık.</span><span class="sxs-lookup"><span data-stu-id="c8251-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="c8251-277">Bir [Konu](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) bir sıraya benzer, ancak bire çok mesajlaşma düzenlerini destekler.</span><span class="sxs-lookup"><span data-stu-id="c8251-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="c8251-278">Bir mikro hizmet bir ileti yayımlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-278">One microservice publishes a message.</span></span> <span data-ttu-id="c8251-279">Birden çok abone mikro hizmet, bu iletiyi almayı ve üzerinde işlem yapmak için seçim yapabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="c8251-280">Şekil 4-16, bir konu mimarisini gösterir.</span><span class="sxs-lookup"><span data-stu-id="c8251-280">Figure 4-16 shows a topic architecture.</span></span>

![Konu mimarisi](./media/topic-architecture.png)

<span data-ttu-id="c8251-282">**Şekil 4-16**.</span><span class="sxs-lookup"><span data-stu-id="c8251-282">**Figure 4-16**.</span></span> <span data-ttu-id="c8251-283">Konu mimarisi</span><span class="sxs-lookup"><span data-stu-id="c8251-283">Topic architecture</span></span>

<span data-ttu-id="c8251-284">Önceki şekilde, yayımcılar konuya iletiler gönderir.</span><span class="sxs-lookup"><span data-stu-id="c8251-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="c8251-285">Son sırada aboneler aboneliklerden ileti alır.</span><span class="sxs-lookup"><span data-stu-id="c8251-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="c8251-286">Ortasında, konu, koyu mavi kutular halinde gösterilen bir dizi *kurala*göre iletileri aboneliklere iletir.</span><span class="sxs-lookup"><span data-stu-id="c8251-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="c8251-287">Kurallar, belirli iletileri bir aboneliğe ileten bir filtre işlevi görür.</span><span class="sxs-lookup"><span data-stu-id="c8251-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="c8251-288">Burada, abonelik \#1 ve abonelik \#3 ' e bir "CreateOrder" olayı gönderilebilir, ancak abonelik \#2 ' ye uygulanmaz.</span><span class="sxs-lookup"><span data-stu-id="c8251-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="c8251-289">Abonelik \#2 ' ye ve \#3 aboneliğine "OrderCompleted" olayı gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="c8251-290">Azure bulutu iki farklı konu hizmetini destekler: Azure Service Bus konuları ve Azure EventGrid.</span><span class="sxs-lookup"><span data-stu-id="c8251-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="c8251-291">Azure Service Bus konuları</span><span class="sxs-lookup"><span data-stu-id="c8251-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="c8251-292">Aynı güçlü aracılı ileti modelinin en üstünde oturur Azure Service Bus kuyrukları [Azure Service Bus konulardır](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="c8251-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="c8251-293">Bir konu, birden fazla bağımsız yayımcıların iletilerini alabilir ve en fazla 2.000 aboneye ileti gönderebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="c8251-294">Abonelikler, sistemi durdurmadan veya konu başlığı oluşturmadan dinamik olarak çalışma zamanında eklenebilir veya kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="c8251-295">Azure Service Bus kuyruklardan birçok gelişmiş özellik, [yinelenen algılama](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) ve [işlem desteği](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)dahil olmak üzere konular için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="c8251-296">Varsayılan olarak, Service Bus konular tek bir ileti Aracısı tarafından işlenir ve tek bir ileti deposunda depolanır.</span><span class="sxs-lookup"><span data-stu-id="c8251-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="c8251-297">Ancak [Service Bus bölümlendirme](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) , bir konuyu birçok ileti aracılarına ve ileti depolarına yayarak ölçeklendirir.</span><span class="sxs-lookup"><span data-stu-id="c8251-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="c8251-298">[Zamanlanan Ileti teslimi](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) , işlenmek üzere belirli bir zamana sahip bir iletiyi etiketleyen bir ileti.</span><span class="sxs-lookup"><span data-stu-id="c8251-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="c8251-299">İleti, ilgili zamandan önceki konu başlığında görünmez.</span><span class="sxs-lookup"><span data-stu-id="c8251-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="c8251-300">[Ileti erteleme](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) , bir iletinin daha sonra bir kez alınmasını ertelemenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="c8251-301">Her ikisi de genellikle işlemlerin belirli bir sırada işlendiği iş akışı işleme senaryolarında kullanılır.</span><span class="sxs-lookup"><span data-stu-id="c8251-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="c8251-302">Önceki iş tamamlanana kadar alınan iletilerin işlenmesini erteleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c8251-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="c8251-303">Service Bus konular, bulutta yerel sistemlerinizde yayımlama/abone olma iletişimini etkinleştirmeye yönelik sağlam ve kanıtlanmış bir teknolojidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="c8251-304">Azure Event Grid</span><span class="sxs-lookup"><span data-stu-id="c8251-304">Azure Event Grid</span></span>

<span data-ttu-id="c8251-305">Azure Service Bus, bir çift kurumsal özellikler kümesiyle test edilmiş bir mesajlaşma Aracısı olsa da, bloktaki yeni çocuk [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) .</span><span class="sxs-lookup"><span data-stu-id="c8251-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="c8251-306">İlk bakışta Event Grid yalnızca başka bir konu tabanlı mesajlaşma sistemine benzeyebilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="c8251-307">Ancak, bu birçok şekilde farklıdır.</span><span class="sxs-lookup"><span data-stu-id="c8251-307">However, it's different in many ways.</span></span> <span data-ttu-id="c8251-308">Olay odaklı iş yüklerine odaklandığı için, gerçek zamanlı olay işleme, derin Azure tümleştirmesi ve bir açık platform olan, sunucusuz altyapıda daha az bir altyapı sunar.</span><span class="sxs-lookup"><span data-stu-id="c8251-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="c8251-309">Modern bulutla yerel ve sunucusuz uygulamalar için tasarlanmıştır</span><span class="sxs-lookup"><span data-stu-id="c8251-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="c8251-310">Merkezi bir *olay biriktirme düzeyi*veya kanal olarak Event Grid Azure kaynakları içindeki olaylara ve kendi hizmetlerinize yeniden işlem yapar.</span><span class="sxs-lookup"><span data-stu-id="c8251-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="c8251-311">Olay bildirimleri, her olayı bir aboneliğe yönlendiren bir Event Grid konuya yayımlanır.</span><span class="sxs-lookup"><span data-stu-id="c8251-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="c8251-312">Aboneler aboneliklerle eşlenir ve olayları tüketir.</span><span class="sxs-lookup"><span data-stu-id="c8251-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="c8251-313">Service Bus gibi, Event Grid, bir aboneliğin alması istediği olaylar için kural ayarlayan *filtrelenmiş bir abone modelini* destekler.</span><span class="sxs-lookup"><span data-stu-id="c8251-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="c8251-314">Event Grid, yaklaşık gerçek zamanlı teslimin en fazla Azure Service Bus oluşturabileceği kadar çok daha fazlasını sağlayan, saniyede 10.000.000 olay garantisi sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="c8251-315">Event Grid SWE, Azure altyapısının dokusuna yönelik derin tümleştirmedir.</span><span class="sxs-lookup"><span data-stu-id="c8251-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="c8251-316">Cosmos DB gibi bir Azure kaynağı, yerleşik olayları özel koda gerek duymadan doğrudan diğer Azure kaynaklarına yayımlayabilirler.</span><span class="sxs-lookup"><span data-stu-id="c8251-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="c8251-317">Event Grid, bir Azure aboneliğinden, kaynak grubundan veya hizmetten olay yayımlayabilir, geliştiricilerin bulut kaynakları yaşam döngüsü üzerinde ayrıntılı denetim sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="c8251-318">Ancak Event Grid Azure ile sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="c8251-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="c8251-319">Bu, uygulamalardan veya üçüncü taraf hizmetlerden yayınlanan özel HTTP olaylarını kullanabilen ve olayları dış abonelere yönlendiren açık bir platformdur.</span><span class="sxs-lookup"><span data-stu-id="c8251-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="c8251-320">Azure kaynaklarından yerel olayları yayımlarken ve abone olurken, kodlama gerekmez.</span><span class="sxs-lookup"><span data-stu-id="c8251-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="c8251-321">Basit yapılandırma sayesinde, bir Azure kaynağından olayları, konular ve abonelikler için yerleşik bir tesisten yararlanarak tümleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c8251-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="c8251-322">Şekil 4-17 Event Grid ' nin anatommumu gösterir.</span><span class="sxs-lookup"><span data-stu-id="c8251-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![Event Grid anatomi](./media/event-grid-anatomy.png)

<span data-ttu-id="c8251-324">**Şekil 4-17**.</span><span class="sxs-lookup"><span data-stu-id="c8251-324">**Figure 4-17**.</span></span> <span data-ttu-id="c8251-325">Event Grid anatomi</span><span class="sxs-lookup"><span data-stu-id="c8251-325">Event Grid anatomy</span></span>

<span data-ttu-id="c8251-326">EventGrid ve Service Bus arasındaki önemli bir fark, temeldeki *ileti değişim*modelidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="c8251-327">Service Bus, aşağı akış abonenin yeni iletiler için konu aboneliğini etkin bir şekilde yokladığı eski bir stil *çekme modeli* uygular.</span><span class="sxs-lookup"><span data-stu-id="c8251-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="c8251-328">Bu yaklaşım, en sonunda aboneye iletileri işleyen hızda abone tam denetim sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="c8251-329">Bu, belirli bir zamanda ne zaman ve kaç mesaj işleyeceğini denetler.</span><span class="sxs-lookup"><span data-stu-id="c8251-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="c8251-330">Okunmamış iletiler, işlenene kadar abonelikte kalır.</span><span class="sxs-lookup"><span data-stu-id="c8251-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="c8251-331">Önemli bir Short, olayın oluşturulduğu zaman ve bu iletiyi işlenmek üzere abone 'e çeken yoklama işlemi arasındaki gecikmedir.</span><span class="sxs-lookup"><span data-stu-id="c8251-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="c8251-332">Ayrıca, sonraki olay için sabit yoklamanın ek yükü kaynakları ve paradan tüketir.</span><span class="sxs-lookup"><span data-stu-id="c8251-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="c8251-333">Ancak EventGrid farklı.</span><span class="sxs-lookup"><span data-stu-id="c8251-333">EventGrid, however, is different.</span></span> <span data-ttu-id="c8251-334">Olayların EventHandlers gönderildiği şekilde gönderildiği ve gerçek zamanlı olay teslimi sağlayan bir *anında iletme modeli* uygular.</span><span class="sxs-lookup"><span data-stu-id="c8251-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="c8251-335">Hizmetin yalnızca bir olayı tüketmesi gerektiğinde tetiklendiği ve sürekli olarak yoklama ile olduğu gibi, maliyeti de düşürür.</span><span class="sxs-lookup"><span data-stu-id="c8251-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="c8251-336">Bu şekilde, bir olay işleyicisinin gelen yükü işlemesi ve kendisini korumak için azaltma mekanizmaları sağlaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="c8251-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="c8251-337">Azure Işlevleri ve Logic Apps gibi bu olayları kullanan pek çok Azure hizmeti, daha fazla yükü işlemek için otomatik otomatik ölçeklendirme özellikleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="c8251-338">Event Grid, tam olarak yönetilen bir sunucusuz bulut hizmetidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="c8251-339">Bu, trafiğinizi temel alarak dinamik olarak ölçeklendirin ve yalnızca gerçek kullanımınız için ücretlendirilirken, önceden satın alınmış kapasiteye değil, size</span><span class="sxs-lookup"><span data-stu-id="c8251-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="c8251-340">Ayda ilk 100.000 işlem ücretsiz – olay girişi (gelen olay bildirimleri), abonelik teslim denemeleri, yönetim çağrıları ve konuya göre filtreleme olarak tanımlanmakta olan operasyonlardır.</span><span class="sxs-lookup"><span data-stu-id="c8251-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="c8251-341">% 99,99 kullanılabilirlik ile EventGrid, başarısız teslimat için yerleşik yeniden deneme işlevselliği ile, bir olayın 24 saatlik bir süre içinde teslimini garanti eder.</span><span class="sxs-lookup"><span data-stu-id="c8251-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="c8251-342">Teslim edilmemiş iletiler, çözüm için "atılacak mektup" kuyruğuna taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="c8251-343">Azure Service Bus farklı olarak, Event Grid hızlı performans için ayarlanmıştır ve sıralı mesajlaşma, işlemler ve oturumlar gibi özellikleri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="c8251-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="c8251-344">Azure bulutu 'nda akış iletileri</span><span class="sxs-lookup"><span data-stu-id="c8251-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="c8251-345">Azure Service Bus ve Event Grid, bir Cosmos DB eklenmiş yeni bir belge gibi tek ve ayrı olaylar sunan uygulamalar için harika destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="c8251-346">Ancak, bulutta yerel sisteminizin *ilgili olayların akışını*işlemesi gerekiyorsa ne olacak?</span><span class="sxs-lookup"><span data-stu-id="c8251-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="c8251-347">[Olay akışları](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="c8251-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="c8251-348">Bunlar genellikle zaman içinde sıralanmıştır, birbirleriyle ilişkilidir ve bir grup olarak işlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="c8251-349">[Azure Olay Hub](https://azure.microsoft.com/services/event-hubs/) 'ı, olayları toplayan, dönüştüren ve depolayan bir veri akışı platformu ve olay alma hizmetidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="c8251-350">Bir telemetri bağlamından yayılan sürekli olay bildirimleri gibi akış verilerini yakalamak için ince ayar yapılır.</span><span class="sxs-lookup"><span data-stu-id="c8251-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="c8251-351">Hizmet yüksek oranda ölçeklenebilir ve [saniye başına milyonlarca olayı depolayıp işleyebilir](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span><span class="sxs-lookup"><span data-stu-id="c8251-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="c8251-352">Şekil 4-18 ' de gösterildiği gibi, genellikle olay işlem hattının bir ön kapıdır ve olay tüketimine ait alma akışını ayırır.</span><span class="sxs-lookup"><span data-stu-id="c8251-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure Olay Hub'ı](./media/azure-event-hub.png)

<span data-ttu-id="c8251-354">**Şekil 4-18**.</span><span class="sxs-lookup"><span data-stu-id="c8251-354">**Figure 4-18**.</span></span> <span data-ttu-id="c8251-355">Azure Olay Hub'ı</span><span class="sxs-lookup"><span data-stu-id="c8251-355">Azure Event Hub</span></span>

<span data-ttu-id="c8251-356">Olay Hub 'ı, düşük gecikme süresini ve yapılandırılabilir zaman bekletmesini destekler.</span><span class="sxs-lookup"><span data-stu-id="c8251-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="c8251-357">Kuyrukların ve konuların aksine, bir tüketici tarafından okunduktan sonra olay verilerini saklayın Event Hubs.</span><span class="sxs-lookup"><span data-stu-id="c8251-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="c8251-358">Bu özellik, iç ve dış diğer veri analizi hizmetlerinin, daha fazla analiz için verileri yeniden oynamalarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="c8251-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="c8251-359">Olay Hub 'ında depolanan olaylar yalnızca, varsayılan olarak bir gün olan ancak yapılandırılabilir olan bekletme döneminin süresi dolduktan sonra silinir.</span><span class="sxs-lookup"><span data-stu-id="c8251-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="c8251-360">Olay Hub 'ı, HTTPS ve AMQP dahil olmak üzere ortak olay yayımlama protokollerini destekler.</span><span class="sxs-lookup"><span data-stu-id="c8251-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="c8251-361">Ayrıca Kafka 1,0 de desteklenir.</span><span class="sxs-lookup"><span data-stu-id="c8251-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="c8251-362">Mevcut Kafka uygulamaları, büyük Kafka kümelerinin yönetilmesine alternatif sağlayan Kafka protokolünü kullanarak [Olay Hub 'ı ile iletişim](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) kurabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="c8251-363">Birçok açık kaynaklı bulut Yerel sistemi emayraç Kafka.</span><span class="sxs-lookup"><span data-stu-id="c8251-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="c8251-364">Event Hubs, her tüketicinin ileti akışının yalnızca belirli bir alt kümesini veya bölümünü okuduğu [bölümlenmiş bir tüketici modeli](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) aracılığıyla ileti akışı uygular.</span><span class="sxs-lookup"><span data-stu-id="c8251-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="c8251-365">Bu düzende olay işleme için inanılmaz yatay ölçek etkinleştirilir ve sıralarda ve konularda kullanılamayan diğer akışa odaklanmış özellikler sağlanır.</span><span class="sxs-lookup"><span data-stu-id="c8251-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="c8251-366">Bölüm bir olay hub'ında tutulan olayların sıralı dizisidir.</span><span class="sxs-lookup"><span data-stu-id="c8251-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="c8251-367">Daha yeni olaylar geldikçe, bu sıranın sonuna eklenir.</span><span class="sxs-lookup"><span data-stu-id="c8251-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="c8251-368"> Şekil 4-19 bir olay hub 'ında Bölümlendirmeyi gösterir.</span><span class="sxs-lookup"><span data-stu-id="c8251-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![Olay Hub 'ı bölümlendirme](./media/event-hub-partitioning.png)

<span data-ttu-id="c8251-370">**Şekil 4-19**.</span><span class="sxs-lookup"><span data-stu-id="c8251-370">**Figure 4-19**.</span></span> <span data-ttu-id="c8251-371">Olay Hub 'ı bölümlendirme</span><span class="sxs-lookup"><span data-stu-id="c8251-371">Event Hub partitioning</span></span>

<span data-ttu-id="c8251-372">Aynı kaynaktan okumak yerine, her tüketici grubu ileti akışının bir alt kümesi veya bölümü üzerinde okur.</span><span class="sxs-lookup"><span data-stu-id="c8251-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="c8251-373">Çok sayıda olayı akışı gereken bulutta yerel uygulamalar için, Azure Olay Hub 'ı sağlam ve uygun maliyetli bir çözüm olabilir.</span><span class="sxs-lookup"><span data-stu-id="c8251-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="c8251-374">[Önceki](front-end-communication.md)
>[İleri](rest-grpc.md)</span><span class="sxs-lookup"><span data-stu-id="c8251-374">[Previous](front-end-communication.md)
[Next](rest-grpc.md)</span></span>
