---
title: Zaman uyumsuz, derinlemesine
description: .NET görev tabanlı zaman uyumsuz model kullanarak g/ç 'ye bağlı ve CPU 'ya bağlı zaman uyumsuz kod yazma hakkında bilgi edinin.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 7fcc41c4ea5037d643402fc722e8f16f28d560ee
ms.sourcegitcommit: 965a5af7918acb0a3fd3baf342e15d511ef75188
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/18/2020
ms.locfileid: "94823335"
---
# <a name="async-in-depth"></a><span data-ttu-id="dd5ff-103">Zaman uyumsuz, derinlemesine</span><span class="sxs-lookup"><span data-stu-id="dd5ff-103">Async in depth</span></span>

<span data-ttu-id="dd5ff-104">G/ç ve CPU 'ya bağlı zaman uyumsuz kod yazma, .NET görev tabanlı zaman uyumsuz model kullanılarak basittir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="dd5ff-105">Model `Task` ve `Task<T>` türleri ve `async` `await` C# ve Visual Basic ve anahtar kelimeleri tarafından gösterilir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="dd5ff-106">(Dile özgü kaynaklar [Ayrıca bkz](#see-also) . bölümünde bulunur.) Bu makalede, .NET Async 'in nasıl kullanılacağı açıklanmaktadır ve bu bilgiler, kapsamakta olan zaman uyumsuz Framework hakkında öngörüler sağlar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-taskt"></a><span data-ttu-id="dd5ff-107">Görev ve görev\<T></span><span class="sxs-lookup"><span data-stu-id="dd5ff-107">Task and Task\<T></span></span>

<span data-ttu-id="dd5ff-108">Görevler, [taahhüt modelinin Promise modeli olarak Bilinünü](https://en.wikipedia.org/wiki/Futures_and_promises)uygulamak için kullanılan yapılardır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="dd5ff-109">Kısa bir süre sonra, iş daha sonraki bir noktada tamamlanacak bir "Promise" sunar ve bu da bir temiz API ile Promise ile koordine etmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

- <span data-ttu-id="dd5ff-110">`Task` değer döndürmeyen tek bir işlemi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-110">`Task` represents a single operation which does not return a value.</span></span>
- <span data-ttu-id="dd5ff-111">`Task<T>` türünde bir değer döndüren tek bir işlemi temsil eder `T` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="dd5ff-112">Görevler, iş parçacığı üzerinde bir soyutlama değil, zaman uyumsuz olarak gerçekleşen işin soyut kısımları olarak *gerçekleşmekte* önemlidir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="dd5ff-113">Varsayılan olarak, görevler geçerli iş parçacığı üzerinde yürütülür ve uygun şekilde Işletim sisteminde iş devredebilir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="dd5ff-114">İsteğe bağlı olarak, görevler API aracılığıyla ayrı bir iş parçacığında çalışmak üzere açıkça istenebilir `Task.Run` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="dd5ff-115">Görevler, izleme için bir API protokolünü açığa çıkarır, bir görevin sonuç değerine (Bu durumda) ve bunlara erişmeyi bekler `Task<T>` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="dd5ff-116">Anahtar sözcüğü ile dil tümleştirmesi, `await` görevleri kullanmaya yönelik daha yüksek düzeyde bir soyutlama sağlar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span>

<span data-ttu-id="dd5ff-117">Kullanılarak `await` , görev tamamlanana kadar, bir görev çalışırken bir görev çalışırken, bir görev çalışırken, uygulama veya hizmetinizin yararlı çalışmalar gerçekleştirmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="dd5ff-118">Görev tamamlandıktan sonra, bir yürütmeye devam etmek için kodunuzun geri çağırmaları veya olaylara dayalı olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="dd5ff-119">Dil ve görev API 'SI tümleştirmesi sizin için bunu yapar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="dd5ff-120">Kullanıyorsanız `Task<T>` , `await` anahtar sözcüğü görev tamamlandığında döndürülen değeri "sarmalama" olarak da döndürür.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="dd5ff-121">Bunun nasıl çalıştığına ilişkin ayrıntılar aşağıda açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="dd5ff-122">Görevler hakkında daha fazla bilgi edinmek için [görev tabanlı zaman uyumsuz düzende (dokunarak)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) bunlarla etkileşimde bulunmak için farklı yollar bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](./asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="dd5ff-123">G/ç ile bağlantılı bir Işlem için görevlere daha derin bakış</span><span class="sxs-lookup"><span data-stu-id="dd5ff-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="dd5ff-124">Aşağıdaki bölümde, tipik bir zaman uyumsuz g/ç çağrısıyla ne olacağı hakkında 10.000 Foot görünümü açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="dd5ff-125">Birkaç örnek ile başlayalım.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="dd5ff-126">İlk örnek, zaman uyumsuz bir yöntemi çağırır ve muhtemelen tamamlanmamış olan etkin bir görevi döndürüyor.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();

    return client.GetStringAsync("https://www.dotnetfoundation.org");
}
```

<span data-ttu-id="dd5ff-127">İkinci örnek, `async` `await` görev üzerinde çalışmak için ve anahtar sözcüklerinin kullanımını ekler.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();

    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("https://www.dotnetfoundation.org");

    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.

    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="dd5ff-128">`GetStringAsync()`Alt düzey .NET kitaplıkları (Belki de diğer zaman uyumsuz yöntemleri çağırır) aracılığıyla çağrı yapılan çağrı, yerel bir ağ kitaplığına P/Invoke birlikte çalışabilirlik çağrısına erişene kadar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="dd5ff-129">Yerel kitaplık daha sonra bir sistem API çağrısı ( `write()` Linux üzerinde bir yuva gibi) ile çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="dd5ff-130">Bir görev nesnesi, muhtemelen [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600))kullanılarak yerel/yönetilen sınırında oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="dd5ff-131">Görev nesnesi, büyük olasılıkla üzerinde çalıştırılan veya doğrudan döndürülen, sonunda ilk çağırana döndürülen katmanlarla geçirilir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span>

<span data-ttu-id="dd5ff-132">Yukarıdaki ikinci örnekte, `Task<T>` öğesinden bir nesne döndürülür `GetStringAsync` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="dd5ff-133">Anahtar sözcüğünün kullanılması, `await` yönteminin yeni oluşturulan bir görev nesnesi döndürmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="dd5ff-134">Denetim, yöntemde bu konumdan çağırana döner `GetFirstCharactersCountAsync` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="dd5ff-135">[Görev &lt; T &gt; ](xref:System.Threading.Tasks.Task%601) nesnesinin yöntemleri ve özellikleri, çağrı yapanların, Getfirstkarakterscountasync içindeki geri kalan kod yürütüldüğünde tamamlanacak olan görevin ilerlemesini izlemelerine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="dd5ff-136">Sistem API çağrısından sonra, istek artık çekirdek alanında bulunur ve bu, işletim sisteminin ağ alt sistemine (Linux çekirdekte olduğu gibi) yol getirir `/net` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="dd5ff-137">Burada işletim sistemi ağ isteklerini *zaman uyumsuz* olarak işleyecek.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="dd5ff-138">Ayrıntılar, kullanılan işletim sistemine bağlı olarak farklı olabilir (cihaz sürücüsü çağrısı çalışma zamanına geri gönderilen bir sinyal olarak zamanlanabilir veya bir cihaz sürücüsü çağrısı yapılabilir ve *sonra* bir sinyal geri gönderilebilir), ancak sonunda çalışma zamanı, ağ isteğinin devam ettiğini bilgilendirilir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="dd5ff-139">Şu anda, cihaz sürücüsü için çalışma zamanlanmış, devam ediyor veya zaten bitmiş (istek zaten "kablo üzerinden") olur, ancak bu durum zaman uyumsuz olarak yapıldığından, cihaz sürücüsü başka bir şeyi hemen işleyebilir!</span><span class="sxs-lookup"><span data-stu-id="dd5ff-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="dd5ff-140">Örneğin, Windows 'da bir işletim sistemi iş parçacığı ağ aygıtı sürücüsüne bir çağrı yapar ve bunu işlemi temsil eden bir kesme Isteği paketi (IRP) aracılığıyla ağ işlemini gerçekleştirmesini ister.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="dd5ff-141">Aygıt sürücüsü IRP 'yi alır, ağa çağrı yapar, IRP 'yi "bekliyor" olarak işaretler ve işletim sistemine geri döner.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="dd5ff-142">İşletim sistemi iş parçacığı artık IRP 'nin "bekliyor" olduğunu bildiğinden, bu iş için daha fazla iş yapmaya sahip değildir ve diğer işleri gerçekleştirmek için kullanılabilmesi için "geri döndürür".</span><span class="sxs-lookup"><span data-stu-id="dd5ff-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="dd5ff-143">İstek yerine getirildiyse ve veriler cihaz sürücüsü aracılığıyla geri geldiğinde, bir kesme aracılığıyla alınan yeni verilerin CPU 'suna bildirir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="dd5ff-144">Bu kesmenin nasıl işlendiği, IŞLETIM sistemine bağlı olarak farklılık gösterir, ancak sonunda bir sistem birlikte çalışma çağrısına ulaşıncaya kadar veriler IŞLETIM sistemi üzerinden geçirilir (örneğin, Linux 'ta bir kesme işleyicisi verileri işletim sistemi ile zaman uyumsuz olarak geçirmek için IRQ 'nun alt yarısını zamanlıyor).</span><span class="sxs-lookup"><span data-stu-id="dd5ff-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="dd5ff-145">Bunun *de* zaman uyumsuz olarak gerçekleştiğini unutmayın!</span><span class="sxs-lookup"><span data-stu-id="dd5ff-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="dd5ff-146">Sonuç, bir sonraki kullanılabilir iş parçacığı zaman uyumsuz yöntemini yürütebilene ve tamamlanmış görevin sonucunu "sarmadan" çıkana kadar sıraya alınır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-146">The result is queued up until the next available thread is able to execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="dd5ff-147">Bu işlemin tamamında, bir anahtar, **görevi çalıştırmak için hiçbir iş parçacığının ayrılmadığı** bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="dd5ff-148">Çalışma bazı bağlamda yürütülse de (yani işletim sisteminin bir cihaz sürücüsüne veri geçirmesi ve kesintiye yanıt vermesi gerekir), isteğin geri *dönmesi* için ayrılan iş parçacığı yok.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="dd5ff-149">Bu, sistemin bazı g/ç çağrısının tamamlanmasını beklemek yerine çok daha büyük bir iş hacmi işlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="dd5ff-150">Yukarıdaki çok fazla iş olması gibi görünse de, duvar saati zamanı bakımından ölçüldüğünde, bu, gerçek g/ç işinin yapılması için gereken süre ile karşılaştırıldığında minscc olur.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="dd5ff-151">Her türlü kesin olmasa da bu tür bir çağrının olası bir zaman çizelgesi şuna benzer:</span><span class="sxs-lookup"><span data-stu-id="dd5ff-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="dd5ff-152">0-1 ———————————————————————————————————————————————— – 2-3</span><span class="sxs-lookup"><span data-stu-id="dd5ff-152">0-1————————————————————————————————————————————————–2-3</span></span>

- <span data-ttu-id="dd5ff-153">`0` `1` Zaman uyumsuz bir yöntem, çağıranına denetim yapana kadar her şey için noktadan geçen süre.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
- <span data-ttu-id="dd5ff-154">Noktadan itibaren harcanan süre `1` , `2` CPU maliyeti olmadan g/ç 'de harcanan süredir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
- <span data-ttu-id="dd5ff-155">Son olarak, noktadan harcanan süre `2` `3` zaman uyumsuz metoda denetim geri (ve potansiyel bir değer) geçirmekte ve bu noktada yeniden yürütüyordur.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="dd5ff-156">Bu bir sunucu senaryosu için ne anlama geliyor?</span><span class="sxs-lookup"><span data-stu-id="dd5ff-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="dd5ff-157">Bu model tipik bir sunucu senaryosu iş yükü ile iyi şekilde çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="dd5ff-158">Tamamlanmamış görevlerde engellemeye ayrılmış iş parçacığı olmadığından, sunucu ThreadPool çok daha yüksek bir Web istekleri hacmine hizmet edebilir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="dd5ff-159">İki sunucu düşünün: zaman uyumsuz kod çalıştıran bir ve olmayan bir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="dd5ff-160">Bu örneğin, her sunucuda yalnızca hizmet istekleri için kullanılabilir 5 iş parçacığı bulunur.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="dd5ff-161">Bu sayıların imaginarily küçük olduğunu ve yalnızca bir gösterim amaçlıdır bağlamında işlev olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="dd5ff-162">Her iki sunucunun da 6 eşzamanlı istek alacağını varsayın.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="dd5ff-163">Her istek bir g/ç işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="dd5ff-164">Zaman uyumsuz kod *içermeyen* sunucu, 5 iş parçacığından biri g/ç ile bağlantılı çalışmayı tamamlayana ve yanıt yazana kadar 6. isteği sıraya almak zorunda değildir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="dd5ff-165">20. isteğin geldiği noktada, sıra çok uzun sürtiğinden sunucu yavaşlamaya başlayabilir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="dd5ff-166">Üzerinde çalışan zaman uyumsuz koda *sahip* sunucu yine 6. isteği sıraya alır, ancak kullandığından `async` `await` , iş parçacıklarının her biri bittiğinde değil g/ç bağlı iş başladığında serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="dd5ff-167">20. isteğin geldiği zamana göre, gelen isteklerin kuyruğu çok daha küçüktür (herhangi bir şey varsa) ve sunucu yavaşmaz.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="dd5ff-168">Bu bir contrived örneği olmasına rağmen gerçek dünyada çok benzer bir biçimde çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="dd5ff-169">Aslında, bir sunucunun `async` , `await` aldığı her istek için bir iş parçacığını ayrılmış hale aldığına göre daha fazla istek sırasını işleyebilmesini sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="dd5ff-170">Bu, istemci senaryosu için ne anlama geliyor?</span><span class="sxs-lookup"><span data-stu-id="dd5ff-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="dd5ff-171">İstemci uygulaması için ve kullanmanın en büyük kazancı, `async` `await` yanıt verme hızını artırır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="dd5ff-172">Bir uygulamayı iş parçacıklarını el ile oluşturarak yanıt verebilseniz de, iş parçacığı oluşturma işlemi, yalnızca ve ile ilgili pahalı bir işlemdir `async` `await` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="dd5ff-173">Özellikle bir mobil oyun gibi bir şey için, g/ç 'nin ilgili olduğu durumlarda Kullanıcı arabirimi iş parçacığını olabildiğince az etkilediğinde.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="dd5ff-174">Daha da önemlisi, g/ç bağlı işi CPU üzerinde neredeyse zaman harcadığından, tüm CPU iş parçacığını çok iyi bir şekilde gerçekleştirmek için kullanılabilir olan tüm yararlı işler, kaynakların kötü bir şekilde kullanılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="dd5ff-175">Ek olarak, Kullanıcı arabirimi iş parçacığına (Kullanıcı arabirimini güncelleştirme gibi) dağıtım çok basittir `async` ve ek iş gerektirmez (iş parçacığı güvenli temsilcisini çağırma gibi).</span><span class="sxs-lookup"><span data-stu-id="dd5ff-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-taskt-for-a-cpu-bound-operation"></a><span data-ttu-id="dd5ff-176">CPU-Bound Işlemi için görev ve göreve daha derin bakış \<T></span><span class="sxs-lookup"><span data-stu-id="dd5ff-176">Deeper Dive into Task and Task\<T> for a CPU-Bound Operation</span></span>

<span data-ttu-id="dd5ff-177">CPU-bağlantılı `async` kod, g/ç ile bağlantılı koddan biraz farklıdır `async` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="dd5ff-178">İş CPU üzerinde yapıldığından, bir iş parçacığını hesaplama altına almanın bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="dd5ff-179">Ve kullanımı, `async` `await` bir arka plan iş parçacığı ile etkileşime geçmek için temiz bir yol sağlar ve zaman uyumsuz yöntem çağıranı yanıt vermeye devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="dd5ff-180">Bunun, paylaşılan veriler için herhangi bir koruma sağlamayacağını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="dd5ff-181">Paylaşılan veriler kullanıyorsanız, yine de uygun bir eşitleme stratejisi uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="dd5ff-182">CPU ile bağlantılı zaman uyumsuz çağrının 10.000 Foot görünümü aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="dd5ff-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));

    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!

    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;

    return result;
}
```

<span data-ttu-id="dd5ff-183">`CalculateResult()` üzerinde çağrıldığı iş parçacığı üzerinde yürütülür.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="dd5ff-184">Çağırdığında, `Task.Run` iş parçacığı havuzunda PAHALı CPU 'ya bağlı işlemi sıraya `DoExpensiveCalculation()` alır ve bir `Task<int>` tanıtıcı alır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="dd5ff-185">`DoExpensiveCalculation()` , büyük olasılıkla başka bir CPU çekirdeğinde, bir sonraki kullanılabilir iş parçacığında eşzamanlı olarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="dd5ff-186">`DoExpensiveCalculation()`Çağıran iş parçacığı çalışmaya devam ettiği için, başka bir iş parçacığında meşgul olduğu sürece eşzamanlı çalışma yapılabilir `CalculateResult()` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="dd5ff-187">`await`Bir kez karşılaşılırsa, yürütülmesi `CalculateResult()` çağrı yapana geri gönderilir ve bu, bir sonucu ortaya tutarken geçerli iş parçacığı ile diğer çalışmanın yapılmasına izin verir `DoExpensiveCalculation()` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="dd5ff-188">İşlem tamamlandıktan sonra, sonuç ana iş parçacığında çalışacak şekilde sıralanır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="dd5ff-189">Sonuç olarak, ana iş parçacığı yürütmek üzere döner ve `CalculateResult()` Bu noktada sonucunu elde edecektir `DoExpensiveCalculation()` .</span><span class="sxs-lookup"><span data-stu-id="dd5ff-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="dd5ff-190">Zaman uyumsuz yardım neden burada?</span><span class="sxs-lookup"><span data-stu-id="dd5ff-190">Why does async help here?</span></span>

<span data-ttu-id="dd5ff-191">`async` ve `await` yanıt verme GEREKTIĞINDE CPU ile bağlantılı çalışmanın yönetilmesi için en iyi uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-191">`async` and `await` are the best practice for managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="dd5ff-192">CPU ile bağlantılı çalışmalarla zaman uyumsuz olarak kullanılması için birden çok desen vardır.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="dd5ff-193">Zaman uyumsuz kullanmanın küçük bir maliyeti olduğunu ve sıkı döngüler için önerilmediğini aklınızda bulundurmamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="dd5ff-194">Kodunuzu bu yeni özellik etrafında nasıl yazacağınızı belirlemektir.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="dd5ff-195">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="dd5ff-195">See also</span></span>

- [<span data-ttu-id="dd5ff-196">C 'de zaman uyumsuz programlama #</span><span class="sxs-lookup"><span data-stu-id="dd5ff-196">Asynchronous programming in C#</span></span>](../csharp/async.md)
- [<span data-ttu-id="dd5ff-197">Async ve await ile zaman uyumsuz programlama (C#)</span><span class="sxs-lookup"><span data-stu-id="dd5ff-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)
- [<span data-ttu-id="dd5ff-198">F 'de zaman uyumsuz programlama #</span><span class="sxs-lookup"><span data-stu-id="dd5ff-198">Async Programming in F#</span></span>](../fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)
- [<span data-ttu-id="dd5ff-199">Async ve await ile zaman uyumsuz programlama (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="dd5ff-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](../visual-basic/programming-guide/concepts/async/index.md)
