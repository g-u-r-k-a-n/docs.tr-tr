---
title: Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, when to upgrade
ms.assetid: a9babe97-e457-4ff3-b528-a1bc940d5320
ms.openlocfilehash: 5a0abef6de9f932f44fc7e3239b98c3a27846580
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "75711226"
---
# <a name="when-to-use-a-thread-safe-collection"></a><span data-ttu-id="4a17d-102">Bir İş Parçacığı Koleksiyonunun Ne Zaman Kullanılacağı</span><span class="sxs-lookup"><span data-stu-id="4a17d-102">When to Use a Thread-Safe Collection</span></span>
<span data-ttu-id="4a17d-103">.NET Framework 4, çok iş parçacığı ekleme ve kaldırma işlemlerini desteklemek için özel olarak tasarlanmış beş yeni toplama türü sunar.</span><span class="sxs-lookup"><span data-stu-id="4a17d-103">The .NET Framework 4 introduces five new collection types that are specially designed to support multi-threaded add and remove operations.</span></span> <span data-ttu-id="4a17d-104">İş parçacığı güvenliğini sağlamak için, bu yeni türler çeşitli verimli kilitleme ve kilitsiz eşitleme mekanizmaları kullanır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-104">To achieve thread-safety, these new types use various kinds of efficient locking and lock-free synchronization mechanisms.</span></span> <span data-ttu-id="4a17d-105">Eşitleme, bir işlem için ek yükü ekler.</span><span class="sxs-lookup"><span data-stu-id="4a17d-105">Synchronization adds overhead to an operation.</span></span> <span data-ttu-id="4a17d-106">Ek yükün miktarı, kullanılan eşitleme türüne, gerçekleştirilen işlemlerin türüne ve koleksiyona aynı anda erişmeye çalışan iş parçacığı sayısı gibi diğer etkenlere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-106">The amount of overhead depends on the kind of synchronization that is used, the kind of operations that are performed, and other factors such as the number of threads that are trying to concurrently access the collection.</span></span>  
  
 <span data-ttu-id="4a17d-107">Bazı senaryolarda, eşitleme yükü ihmal edilebilir ve çok iş parçacığı türünün önemli ölçüde daha hızlı çalışmasını ve harici bir kilitle korunduğunda iş parçacığı güvenli olmayan eşdeğerinden çok daha iyi ölçeklenmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-107">In some scenarios, synchronization overhead is negligible and enables the multi-threaded type to perform significantly faster and scale far better than its non-thread-safe equivalent when protected by an external lock.</span></span> <span data-ttu-id="4a17d-108">Diğer senaryolarda, ek yükü iş parçacığı güvenli türü gerçekleştirmek ve aynı veya hatta daha yavaş türü harici kilitli, iş parçacığı güvenli olmayan sürümü daha ilgili ölçeklendirmek neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-108">In other scenarios, the overhead can cause the thread-safe type to perform and scale about the same or even more slowly than the externally-locked, non-thread-safe version of the type.</span></span>  
  
 <span data-ttu-id="4a17d-109">Aşağıdaki bölümler, okuma ve yazma işlemlerinin etrafında kullanıcı tarafından sağlanan kilit olan iş parçacığı güvenli olmayan eşdeğeri ile iş parçacığı güvenli bir koleksiyonun ne zaman kullanılacağı hakkında genel rehberlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="4a17d-109">The following sections provide general guidance about when to use a thread-safe collection versus its non-thread-safe equivalent that has a user-provided lock around its read and write operations.</span></span> <span data-ttu-id="4a17d-110">Performans birçok etkene bağlı olarak değişebileceğinden, kılavuz belirli değildir ve her koşulda mutlaka geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-110">Because performance may vary depending on many factors, the guidance is not specific and is not necessarily valid in all circumstances.</span></span> <span data-ttu-id="4a17d-111">Performans çok önemliyse, hangi toplama türünü kullanacağımı belirlemenin en iyi yolu temsili bilgisayar yapılandırmalarına ve yüklerine göre performansı ölçmektir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-111">If performance is very important, then the best way to determine which collection type to use is to measure performance based on representative computer configurations and loads.</span></span> <span data-ttu-id="4a17d-112">Bu belge aşağıdaki terimleri kullanır:</span><span class="sxs-lookup"><span data-stu-id="4a17d-112">This document uses the following terms:</span></span>  
  
 <span data-ttu-id="4a17d-113">*Saf üretici-tüketici senaryosu*</span><span class="sxs-lookup"><span data-stu-id="4a17d-113">*Pure producer-consumer scenario*</span></span>  
 <span data-ttu-id="4a17d-114">Verilen herhangi bir iş parçacığı öğeleri ekleyerek veya kaldırıyor, ancak her ikisi de değil.</span><span class="sxs-lookup"><span data-stu-id="4a17d-114">Any given thread is either adding or removing elements, but not both.</span></span>  
  
 <span data-ttu-id="4a17d-115">*Karışık üretici-tüketici senaryosu*</span><span class="sxs-lookup"><span data-stu-id="4a17d-115">*Mixed producer-consumer scenario*</span></span>  
 <span data-ttu-id="4a17d-116">Verilen herhangi bir iş parçacığı hem ekleme ve öğeleri kaldırma.</span><span class="sxs-lookup"><span data-stu-id="4a17d-116">Any given thread is both adding and removing elements.</span></span>  
  
 <span data-ttu-id="4a17d-117">*Speedup*</span><span class="sxs-lookup"><span data-stu-id="4a17d-117">*Speedup*</span></span>  
 <span data-ttu-id="4a17d-118">Aynı senaryoda başka bir türe göre daha hızlı algoritmik performans.</span><span class="sxs-lookup"><span data-stu-id="4a17d-118">Faster algorithmic performance relative to another type in the same scenario.</span></span>  
  
 <span data-ttu-id="4a17d-119">*Ölçeklenebilir -lik*</span><span class="sxs-lookup"><span data-stu-id="4a17d-119">*Scalability*</span></span>  
 <span data-ttu-id="4a17d-120">Bilgisayardaki çekirdek sayısıyla orantılı performans artışı.</span><span class="sxs-lookup"><span data-stu-id="4a17d-120">The increase in performance that is proportional to the number of cores on the computer.</span></span> <span data-ttu-id="4a17d-121">Ölçeklendirilen bir algoritma sekiz çekirdeküzerinde iki çekirdekten daha hızlı çalışır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-121">An algorithm that scales performs faster on eight cores than it does on two cores.</span></span>  
  
## <a name="concurrentqueuet-vs-queuet"></a><span data-ttu-id="4a17d-122">Eşzamanlı Sıra(T) ile Sıra(T)</span><span class="sxs-lookup"><span data-stu-id="4a17d-122">ConcurrentQueue(T) vs. Queue(T)</span></span>  
 <span data-ttu-id="4a17d-123">Saf üretici-tüketici senaryolarında, her öğe için işlem süresi çok küçük <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> (birkaç talimatlar), daha <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> sonra harici bir kilit olan bir üzerinde mütevazı performans yararları sunabilir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-123">In pure producer-consumer scenarios, where the processing time for each element is very small (a few instructions), then <xref:System.Collections.Concurrent.ConcurrentQueue%601?displayProperty=nameWithType> can offer modest performance benefits over a <xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType> that has an external lock.</span></span> <span data-ttu-id="4a17d-124">Bu senaryoda, <xref:System.Collections.Concurrent.ConcurrentQueue%601> özel bir iş parçacığı sıraya girdiğinde ve özel bir iş parçacığı sıraya eklendiğinde en iyi performansı gösterir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-124">In this scenario, <xref:System.Collections.Concurrent.ConcurrentQueue%601> performs best when one dedicated thread is queuing and one dedicated thread is de-queuing.</span></span> <span data-ttu-id="4a17d-125">Bu kuralı uygulamazsanız, <xref:System.Collections.Generic.Queue%601> birden çok çeki <xref:System.Collections.Concurrent.ConcurrentQueue%601> olan bilgisayarlarda biraz daha hızlı performans gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-125">If you do not enforce this rule, then <xref:System.Collections.Generic.Queue%601> might even perform slightly faster than <xref:System.Collections.Concurrent.ConcurrentQueue%601> on computers that have multiple cores.</span></span>  
  
 <span data-ttu-id="4a17d-126">İşlem süresi 500 FLOP (kayan nokta işlemleri) veya daha fazla olduğunda, iki <xref:System.Collections.Concurrent.ConcurrentQueue%601>iş parçacığı kuralı , daha sonra çok iyi ölçeklenebilirlik vardır geçerli değildir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-126">When processing time is around 500 FLOPS (floating point operations) or more, then the two-thread rule does not apply to <xref:System.Collections.Concurrent.ConcurrentQueue%601>, which then has very good scalability.</span></span> <span data-ttu-id="4a17d-127"><xref:System.Collections.Generic.Queue%601>bu senaryoda iyi ölçeklendirmeyapmaz.</span><span class="sxs-lookup"><span data-stu-id="4a17d-127"><xref:System.Collections.Generic.Queue%601> does not scale well in this scenario.</span></span>  
  
 <span data-ttu-id="4a17d-128">Karışık üretici-tüketici senaryolarında, işlem süresi çok küçük <xref:System.Collections.Generic.Queue%601> olduğunda, harici kilit ölçeklere sahip olan bir ölçekdaha <xref:System.Collections.Concurrent.ConcurrentQueue%601> vardır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-128">In mixed producer-consumer scenarios, when the processing time is very small, a <xref:System.Collections.Generic.Queue%601> that has an external lock scales better than <xref:System.Collections.Concurrent.ConcurrentQueue%601> does.</span></span> <span data-ttu-id="4a17d-129">Ancak, işlem süresi 500 FLOP veya daha <xref:System.Collections.Concurrent.ConcurrentQueue%601> fazla olduğunda, o zaman ölçekler daha iyi.</span><span class="sxs-lookup"><span data-stu-id="4a17d-129">However, when processing time is around 500 FLOPS or more, then the <xref:System.Collections.Concurrent.ConcurrentQueue%601> scales better.</span></span>  
  
## <a name="concurrentstack-vs-stack"></a><span data-ttu-id="4a17d-130">EşzamanlıStack vs Stack</span><span class="sxs-lookup"><span data-stu-id="4a17d-130">ConcurrentStack vs. Stack</span></span>  
 <span data-ttu-id="4a17d-131">Saf üretici-tüketici senaryolarında, işleme süresi çok <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> küçük <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> olduğunda, o zaman ve harici bir kilit muhtemelen bir özel itme iş parçacığı ve özel bir haşhaş iplik ile yaklaşık aynı gerçekleştirecektir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-131">In pure producer-consumer scenarios, when processing time is very small, then <xref:System.Collections.Concurrent.ConcurrentStack%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.Stack%601?displayProperty=nameWithType> that has an external lock will probably perform about the same with one dedicated pushing thread and one dedicated popping thread.</span></span> <span data-ttu-id="4a17d-132">Ancak, iş parçacığı sayısı arttıkça, her iki tür de <xref:System.Collections.Generic.Stack%601> artan çekişme <xref:System.Collections.Concurrent.ConcurrentStack%601>nedeniyle yavaşlar ve .'den daha iyi performans gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-132">However, as the number of threads increases, both types slow down because of increased contention, and <xref:System.Collections.Generic.Stack%601> might perform better than <xref:System.Collections.Concurrent.ConcurrentStack%601>.</span></span> <span data-ttu-id="4a17d-133">İşlem süresi 500 FLOP veya daha fazla olduğunda, her iki tür de yaklaşık aynı hızda ölçeklenir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-133">When processing time is around 500 FLOPS or more, then both types scale at about the same rate.</span></span>  
  
 <span data-ttu-id="4a17d-134">Karışık üretici-tüketici senaryolarında, <xref:System.Collections.Concurrent.ConcurrentStack%601> hem küçük hem de büyük iş yükleri için daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-134">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentStack%601> is faster for both small and large workloads.</span></span>  
  
 <span data-ttu-id="4a17d-135">Ve kullanımı <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> büyük <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> ölçüde erişim sürelerini hızlandırabilir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-135">The use of the <xref:System.Collections.Concurrent.ConcurrentStack%601.PushRange%2A> and <xref:System.Collections.Concurrent.ConcurrentStack%601.TryPopRange%2A> may greatly speed up access times.</span></span>  
  
## <a name="concurrentdictionary-vs-dictionary"></a><span data-ttu-id="4a17d-136">EşzamanlıSözlük vs Sözlük</span><span class="sxs-lookup"><span data-stu-id="4a17d-136">ConcurrentDictionary vs. Dictionary</span></span>  
 <span data-ttu-id="4a17d-137">Genel olarak, <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> anahtarları veya değerleri aynı anda birden çok iş parçacığından eklediğiniz ve güncellediğiniz herhangi bir senaryoda kullanın.</span><span class="sxs-lookup"><span data-stu-id="4a17d-137">In general, use a <xref:System.Collections.Concurrent.ConcurrentDictionary%602?displayProperty=nameWithType> in any scenario where you are adding and updating keys or values concurrently from multiple threads.</span></span> <span data-ttu-id="4a17d-138">Sık sık güncelleştirmeler ve nispeten az <xref:System.Collections.Concurrent.ConcurrentDictionary%602> okuma içeren senaryolarda, genellikle mütevazı faydalar sunar.</span><span class="sxs-lookup"><span data-stu-id="4a17d-138">In scenarios that involve frequent updates and relatively few reads, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally offers modest benefits.</span></span> <span data-ttu-id="4a17d-139">Çok okuma ve çok güncelleştirmeiçeren senaryolarda, <xref:System.Collections.Concurrent.ConcurrentDictionary%602> genellikle herhangi bir sayıda çekirdek olan bilgisayarlarda önemli ölçüde daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-139">In scenarios that involve many reads and many updates, the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> generally is significantly faster on computers that have any number of cores.</span></span>  
  
 <span data-ttu-id="4a17d-140">Sık güncelleştirmeler içeren senaryolarda, eşzamanlılık derecesini artırabilir <xref:System.Collections.Concurrent.ConcurrentDictionary%602> ve daha fazla çekirdek olan bilgisayarlarda performansın artıp artmadığını görmek için ölçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4a17d-140">In scenarios that involve frequent updates, you can increase the degree of concurrency in the <xref:System.Collections.Concurrent.ConcurrentDictionary%602> and then measure to see whether performance increases on computers that have more cores.</span></span> <span data-ttu-id="4a17d-141">Eşzamanlılık düzeyini değiştirirseniz, genel işlemlerden mümkün olduğunca kaçının.</span><span class="sxs-lookup"><span data-stu-id="4a17d-141">If you change the concurrency level, avoid global operations as much as possible.</span></span>  
  
 <span data-ttu-id="4a17d-142">Yalnızca anahtar veya değerleri okuyorsanız, sözlük herhangi <xref:System.Collections.Generic.Dictionary%602> bir iş parçacığı tarafından değiştirilmiyorsa eşitleme gerekmediği için daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="4a17d-142">If you are only reading key or values, the <xref:System.Collections.Generic.Dictionary%602> is faster because no synchronization is required if the dictionary is not being modified by any threads.</span></span>  
  
## <a name="concurrentbag"></a><span data-ttu-id="4a17d-143">Concurrentbag</span><span class="sxs-lookup"><span data-stu-id="4a17d-143">ConcurrentBag</span></span>  
 <span data-ttu-id="4a17d-144">Saf üretici-tüketici senaryolarında, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> büyük olasılıkla diğer eşzamanlı toplama türlerine göre daha yavaş gerçekleştirecektir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-144">In pure producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601?displayProperty=nameWithType> will probably perform more slowly than the other concurrent collection types.</span></span>  
  
 <span data-ttu-id="4a17d-145">Karışık üretici-tüketici senaryolarında, <xref:System.Collections.Concurrent.ConcurrentBag%601> genellikle hem büyük hem de küçük iş yükleri için diğer eşzamanlı toplama türünden çok daha hızlı ve daha ölçeklenebilir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-145">In mixed producer-consumer scenarios, <xref:System.Collections.Concurrent.ConcurrentBag%601> is generally much faster and more scalable than any other concurrent collection type for both large and small workloads.</span></span>  
  
## <a name="blockingcollection"></a><span data-ttu-id="4a17d-146">BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="4a17d-146">BlockingCollection</span></span>  
 <span data-ttu-id="4a17d-147">Sınırlama ve engelleme semantik gerektiğinde, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> büyük olasılıkla herhangi bir özel uygulama daha hızlı gerçekleştirecektir.</span><span class="sxs-lookup"><span data-stu-id="4a17d-147">When bounding and blocking semantics are required, <xref:System.Collections.Concurrent.BlockingCollection%601?displayProperty=nameWithType> will probably perform faster than any custom implementation.</span></span> <span data-ttu-id="4a17d-148">Ayrıca zengin iptal, numaralandırma ve özel durum işleme destekler.</span><span class="sxs-lookup"><span data-stu-id="4a17d-148">It also supports rich cancellation, enumeration, and exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4a17d-149">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="4a17d-149">See also</span></span>

- <xref:System.Collections.Concurrent?displayProperty=nameWithType>
- [<span data-ttu-id="4a17d-150">İş Parçacığı Koleksiyonları</span><span class="sxs-lookup"><span data-stu-id="4a17d-150">Thread-Safe Collections</span></span>](../../../../docs/standard/collections/thread-safe/index.md)
- [<span data-ttu-id="4a17d-151">Paralel Programlama</span><span class="sxs-lookup"><span data-stu-id="4a17d-151">Parallel Programming</span></span>](../../../../docs/standard/parallel-programming/index.md)
