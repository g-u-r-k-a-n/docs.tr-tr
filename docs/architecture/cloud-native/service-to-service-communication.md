---
title: Servise servis iletişimi
description: Arka uç bulut yerel mikro hizmetlerin diğer arka uç mikro hizmetlerle nasıl iletişim kurduğunu öğrenin.
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: a5124b8b83f62ff17b1230ead63db26e0c1f2a5b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401601"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="facaa-103">Servise servis iletişimi</span><span class="sxs-lookup"><span data-stu-id="facaa-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="facaa-104">Ön uç istemciden hareket lediğimizde, artık arka uçtaki mikro servislerin birbirleriyle iletişim kurmasına değiniyoruz.</span><span class="sxs-lookup"><span data-stu-id="facaa-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="facaa-105">Bulut açi tabanlı bir uygulama yaparken, arka uç hizmetlerin birbiriyle nasıl iletişim kurduğukonusunda duyarlı olmak istersiniz.</span><span class="sxs-lookup"><span data-stu-id="facaa-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="facaa-106">İdeal olarak, daha az hizmet arası iletişim, daha iyi.</span><span class="sxs-lookup"><span data-stu-id="facaa-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="facaa-107">Ancak, arka uç hizmetleri genellikle bir işlemi tamamlamak için birbirlerine güvendiğinden kaçınma her zaman mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="facaa-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="facaa-108">Hizmet ler arası iletişimi uygulamak için yaygın olarak kabul görmüş birçok yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="facaa-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="facaa-109">*İletişim etkileşimi türü* genellikle en iyi yaklaşımı belirleyecektir.</span><span class="sxs-lookup"><span data-stu-id="facaa-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="facaa-110">Aşağıdaki etkileşim türlerini göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="facaa-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="facaa-111">*Sorgu* – bir arama microservice gibi bir microservice bir yanıt gerektirir, gibi, "Hey, bana belirli bir müşteri Kimliği için alıcı bilgilerini verin."</span><span class="sxs-lookup"><span data-stu-id="facaa-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="facaa-112">*Komut* – arama microservice bir eylem yürütmek için başka bir microservice ihtiyacı ama bir yanıt gerektirmez, gibi, "Hey, sadece bu sipariş gemi."</span><span class="sxs-lookup"><span data-stu-id="facaa-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="facaa-113">*Olay* – yayımcı adı verilen bir mikro hizmet, durum değişti veya bir eylem oluştu bir olay yükseltir.</span><span class="sxs-lookup"><span data-stu-id="facaa-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="facaa-114">İlgilenen aboneler olarak adlandırılan diğer mikro hizmetler, olaya uygun şekilde tepki verebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="facaa-115">Yayıncı ve aboneler birbirlerinden haberdar değil.</span><span class="sxs-lookup"><span data-stu-id="facaa-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="facaa-116">Microservice sistemleri genellikle çapraz hizmet etkileşimi gerektiren işlemleri yürütürken bu etkileşim türlerinin bir birleşimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="facaa-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="facaa-117">Her biri ve bunları nasıl uygulayabileceğinizi yakından inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="facaa-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="facaa-118">Sorgular</span><span class="sxs-lookup"><span data-stu-id="facaa-118">Queries</span></span>

<span data-ttu-id="facaa-119">Çoğu zaman, bir microservice bir işlemi tamamlamak için hemen yanıt gerektiren, başka bir *sorgu* gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="facaa-120">Bir alışveriş sepeti microservice ürün bilgileri ve sepetine bir öğe eklemek için bir fiyat gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="facaa-121">Sorgu işlemlerini uygulamak için bir dizi yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="facaa-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="facaa-122">İstek/Yanıt Mesajlaşması</span><span class="sxs-lookup"><span data-stu-id="facaa-122">Request/Response Messaging</span></span>

<span data-ttu-id="facaa-123">Bu senaryoyu uygulamak için bir seçenek, arama arka uç mikro hizmetinin, Şekil 4-8'de gösterilen sorgulaması gereken mikro hizmetlere doğrudan HTTP isteklerini yapmasıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![Doğrudan HTTP iletişimi](./media/direct-http-communication.png)

<span data-ttu-id="facaa-125">**Şekil 4-8**.</span><span class="sxs-lookup"><span data-stu-id="facaa-125">**Figure 4-8**.</span></span> <span data-ttu-id="facaa-126">Doğrudan HTTP iletişimi</span><span class="sxs-lookup"><span data-stu-id="facaa-126">Direct HTTP communication</span></span>

<span data-ttu-id="facaa-127">Mikro hizmetler arasındaki doğrudan HTTP çağrılarının uygulanması nispeten basit olmakla birlikte, bu uygulamayı en aza indirmek için dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="facaa-128">Başlamak için, bu aramalar her zaman *eşzamanlıdır* ve bir sonuç döndürülene veya istek süreleri çıkana kadar işlemi engeller.</span><span class="sxs-lookup"><span data-stu-id="facaa-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="facaa-129">Bir zamanlar bağımsız olarak evrimleşebilen ve sık sık konuşlandırılabilen bağımsız hizmetler, artık birbiriyle birleşti.</span><span class="sxs-lookup"><span data-stu-id="facaa-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="facaa-130">Mikro hizmetler arasındaki bağlantı arttıkça mimari faydaları da azalır.</span><span class="sxs-lookup"><span data-stu-id="facaa-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="facaa-131">Başka bir microservice için tek bir doğrudan HTTP arama yapar seyrek bir istek yürütme bazı sistemler için kabul edilebilir olabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="facaa-132">Ancak, birden çok mikro hizmete doğrudan HTTP çağrıları çağıran yüksek hacimli aramalar tavsiye edilmez.</span><span class="sxs-lookup"><span data-stu-id="facaa-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="facaa-133">Gecikme yi artırabilir ve sisteminizin performansını, ölçeklenebilirliğini ve kullanılabilirliğini olumsuz etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="facaa-134">Daha da kötüsü, doğrudan HTTP iletişim uzun bir dizi senkron mikrohizmetler aramaları derin ve karmaşık zincirleri yol açabilir, Şekil 4-9 gösterilen:</span><span class="sxs-lookup"><span data-stu-id="facaa-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![HTTP sorgularını zincirleme](./media/chaining-http-queries.png)

<span data-ttu-id="facaa-136">**Şekil 4-9**.</span><span class="sxs-lookup"><span data-stu-id="facaa-136">**Figure 4-9**.</span></span> <span data-ttu-id="facaa-137">HTTP sorgularını zincirleme</span><span class="sxs-lookup"><span data-stu-id="facaa-137">Chaining HTTP queries</span></span>

<span data-ttu-id="facaa-138">Bir önceki resimde gösterilen tasarımdaki riski kesinlikle hayal edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="facaa-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="facaa-139">Adım \#3 başarısız olursa ne olur?</span><span class="sxs-lookup"><span data-stu-id="facaa-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="facaa-140">Ya \#da Adım 8 başarısız oldu mu?</span><span class="sxs-lookup"><span data-stu-id="facaa-140">Or Step \#8 fails?</span></span> <span data-ttu-id="facaa-141">Nasıl iyileşirsin?</span><span class="sxs-lookup"><span data-stu-id="facaa-141">How do you recover?</span></span> <span data-ttu-id="facaa-142">Temel hizmet \#meşgul olduğu için Adım 6 yavaşsa ne olur?</span><span class="sxs-lookup"><span data-stu-id="facaa-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="facaa-143">Nasıl devam ediyorsun?</span><span class="sxs-lookup"><span data-stu-id="facaa-143">How do you continue?</span></span> <span data-ttu-id="facaa-144">Tüm doğru çalışsa bile, bu çağrının neden olacağı gecikmeyi düşünün, bu da her adımın gecikme sinin toplamıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="facaa-145">Önceki resimdeki büyük bağlantı derecesi, hizmetlerin en iyi şekilde modellenmediğini göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="facaa-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="facaa-146">Ekibin tasarımlarını tekrar gözden geçirmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="facaa-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="facaa-147">Gerçekleştirilmiş Görünüm düzeni</span><span class="sxs-lookup"><span data-stu-id="facaa-147">Materialized View pattern</span></span>

<span data-ttu-id="facaa-148">Mikro hizmet bağlantısını kaldırmak için popüler bir seçenek [Maddeleştirilmiş Görünüm desenidir.](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="facaa-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="facaa-149">Bu desenle, bir microservice diğer hizmetlere ait olan verilerin kendi yerel, denormalize kopyasını depolar.</span><span class="sxs-lookup"><span data-stu-id="facaa-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="facaa-150">Ürün Kataloğu ve Fiyatlandırma mikrohizmetlerini sorgulayan Alışveriş Sepeti microservice yerine, bu verilerin kendi yerel kopyasını korur.</span><span class="sxs-lookup"><span data-stu-id="facaa-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="facaa-151">Bu desen gereksiz bağlantı ortadan kaldırır ve güvenilirlik ve yanıt süresini artırır.</span><span class="sxs-lookup"><span data-stu-id="facaa-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="facaa-152">Tüm işlem tek bir işlem içinde yürütülür.</span><span class="sxs-lookup"><span data-stu-id="facaa-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="facaa-153">Bu deseni ve diğer veri endişelerini Bölüm 5'te inceliyoruz.</span><span class="sxs-lookup"><span data-stu-id="facaa-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="facaa-154">Hizmet Toplayıcı Deseni</span><span class="sxs-lookup"><span data-stu-id="facaa-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="facaa-155">Mikrohizmet-mikrohizmet bağlantı ortadan kaldırmak için başka bir seçenek bir [Toplayıcı microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), Şekil 4-10 mor gösterilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![Toplayıcı hizmeti](./media/aggregator-service.png)

<span data-ttu-id="facaa-157">**Şekil 4-10**.</span><span class="sxs-lookup"><span data-stu-id="facaa-157">**Figure 4-10**.</span></span> <span data-ttu-id="facaa-158">Toplayıcı mikroservice</span><span class="sxs-lookup"><span data-stu-id="facaa-158">Aggregator microservice</span></span>

<span data-ttu-id="facaa-159">Desen, birden çok arka uç mikro hizmeti çağıran bir işlemi yalıtır ve mantığını özel bir mikro hizmete merkezileştirerek.</span><span class="sxs-lookup"><span data-stu-id="facaa-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="facaa-160">Önceki figürdeki mor ödeme toplayıcı mikrohizmeti, Ödeme işlemi için iş akışını yönetir.</span><span class="sxs-lookup"><span data-stu-id="facaa-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="facaa-161">Sıralı bir sırada birkaç arka uç mikro hizmetine yapılan çağrıları içerir.</span><span class="sxs-lookup"><span data-stu-id="facaa-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="facaa-162">İş akışından elde edilen veriler toplanır ve arayana döndürülür.</span><span class="sxs-lookup"><span data-stu-id="facaa-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="facaa-163">Hala doğrudan HTTP çağrıları uygular iken, toplayıcı microservice arka uç mikro hizmetler arasında doğrudan bağımlılıkları azaltır.</span><span class="sxs-lookup"><span data-stu-id="facaa-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="facaa-164">İstek/Yanıt Deseni</span><span class="sxs-lookup"><span data-stu-id="facaa-164">Request/Reply Pattern</span></span>

<span data-ttu-id="facaa-165">Senkron HTTP iletilerini ayrıştırmak için başka bir yaklaşım, sıraya alma iletişimini kullanan Bir [İstek-Yanıt Deseni'dir.](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html)</span><span class="sxs-lookup"><span data-stu-id="facaa-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="facaa-166">Sıra yı kullanan iletişim her zaman tek yönlü bir kanaldır ve bir üretici ileiletiyi gönderir ve tüketici mesajı alır.</span><span class="sxs-lookup"><span data-stu-id="facaa-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="facaa-167">Bu desenle, Şekil 4-11'de gösterilen hem istek sırası hem de yanıt sırası uygulanır.</span><span class="sxs-lookup"><span data-stu-id="facaa-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![İstek-yanıt deseni](./media/request-reply-pattern.png)

<span data-ttu-id="facaa-169">**Şekil 4-11**.</span><span class="sxs-lookup"><span data-stu-id="facaa-169">**Figure 4-11**.</span></span> <span data-ttu-id="facaa-170">İstek-yanıt deseni</span><span class="sxs-lookup"><span data-stu-id="facaa-170">Request-reply pattern</span></span>

<span data-ttu-id="facaa-171">Burada, ileti oluşturici benzersiz bir korelasyon kimliği içeren sorgu tabanlı bir ileti oluşturur ve bunu istek kuyruğuna yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="facaa-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="facaa-172">Tüketen hizmet iletileri sıradan ayırıyor, işler ve yanıtı aynı korelasyon kimliğiyle yanıt kuyruğuna yerleştirir.</span><span class="sxs-lookup"><span data-stu-id="facaa-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="facaa-173">Üretici hizmeti iletiyi sıradan ayırıyor, korelasyon kimliğiyle eşleşiyor ve işleme devam ediyor.</span><span class="sxs-lookup"><span data-stu-id="facaa-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="facaa-174">Bir sonraki bölümde kuyrukları ayrıntılı olarak ele alıyoruz.</span><span class="sxs-lookup"><span data-stu-id="facaa-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="facaa-175">Komutlar</span><span class="sxs-lookup"><span data-stu-id="facaa-175">Commands</span></span>

<span data-ttu-id="facaa-176">İletişim etkileşiminin bir diğer türü de *komutdur.*</span><span class="sxs-lookup"><span data-stu-id="facaa-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="facaa-177">Bir microservice bir eylem gerçekleştirmek için başka bir microservice gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="facaa-178">Sipariş microservice onaylı bir sipariş için bir sevkiyat oluşturmak için Nakliye microservice gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="facaa-179">Şekil 4-12'de, Üretici adı verilen bir microservice, başka bir microservice,Tüketiciye bir mesaj gönderir ve bir şeyler yapmasını emreder.</span><span class="sxs-lookup"><span data-stu-id="facaa-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![Sırayla komut etkileşimi](./media/command-interaction-with-queue.png)

<span data-ttu-id="facaa-181">**Şekil 4-12**.</span><span class="sxs-lookup"><span data-stu-id="facaa-181">**Figure 4-12**.</span></span> <span data-ttu-id="facaa-182">Sırayla komut etkileşimi</span><span class="sxs-lookup"><span data-stu-id="facaa-182">Command interaction with a queue</span></span>

<span data-ttu-id="facaa-183">Çoğu zaman, Üretici bir yanıt gerektirmez ve mesajı *ateşleyebilir ve unutabilir.*</span><span class="sxs-lookup"><span data-stu-id="facaa-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="facaa-184">Yanıt gerekirse, Tüketici başka bir kanalda Üretici'ye ayrı bir ileti gönderir.</span><span class="sxs-lookup"><span data-stu-id="facaa-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="facaa-185">Komut iletisi en iyi ileti sırası ile eşzamanlı olarak gönderilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="facaa-186">hafif bir mesaj aracısı tarafından desteklenir.</span><span class="sxs-lookup"><span data-stu-id="facaa-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="facaa-187">Önceki diyagramda, bir sıranın her iki hizmeti nasıl ayırdığını ve ayırdığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="facaa-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="facaa-188">İleti sırası, üretici ve tüketicinin bir iletiyi iletdiği bir aracı yapıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="facaa-189">Kuyruklar, noktadan noktaya ileti deseni uygular.</span><span class="sxs-lookup"><span data-stu-id="facaa-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="facaa-190">Üretici, bir komutun nereye gönderilmesi gerektiğini bilir ve uygun şekilde yönlendirir.</span><span class="sxs-lookup"><span data-stu-id="facaa-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="facaa-191">Kuyruk, bir iletinin kanaldan okunan tüketici örneklerinden biri tarafından işlenmesini garanti eder.</span><span class="sxs-lookup"><span data-stu-id="facaa-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="facaa-192">Bu senaryoda, üretici veya tüketici hizmeti diğerini etkilemeden ölçeklenebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="facaa-193">Yanı sıra, teknolojiler her iki tarafta farklı olabilir, bir Java microservice bir [Golang](https://golang.org) microservice çağıran olabilir anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="facaa-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="facaa-194">Bölüm 1'de, *hizmetleri desteklemekten*bahsettik.</span><span class="sxs-lookup"><span data-stu-id="facaa-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="facaa-195">Destek hizmetleri, bulut açi sistemlerinin bağlı olduğu yardımcı kaynaklardır.</span><span class="sxs-lookup"><span data-stu-id="facaa-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="facaa-196">İleti kuyrukları hizmetleri destekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-196">Message queues are backing services.</span></span> <span data-ttu-id="facaa-197">Azure bulutu, bulut tabanlı sistemlerinizin komut iletisi uygulamak için tüketebileceği iki tür ileti kuyruğunu destekler: Azure Depolama Kuyrukları ve Azure Hizmet Veri Sırası.</span><span class="sxs-lookup"><span data-stu-id="facaa-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="facaa-198">Azure Depolama Kuyrukları</span><span class="sxs-lookup"><span data-stu-id="facaa-198">Azure Storage Queues</span></span>

<span data-ttu-id="facaa-199">Azure depolama kuyrukları, hızlı, uygun fiyatlı ve Azure depolama hesapları tarafından desteklenen basit bir kuyruk altyapısı sunar.</span><span class="sxs-lookup"><span data-stu-id="facaa-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="facaa-200">[Azure Depolama Kuyrukları,](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) güvenilir ve kalıcı iletiiçeren REST tabanlı bir kuyruk mekanizmasına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="facaa-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="facaa-201">Bunlar en az özellik kümesi sağlar, ancak ucuzdur ve milyonlarca ileti depolar.</span><span class="sxs-lookup"><span data-stu-id="facaa-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="facaa-202">Kapasiteleri 500 TB'ye kadar değişmektedir.</span><span class="sxs-lookup"><span data-stu-id="facaa-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="facaa-203">Tek bir ileti 64 KB boyutuna kadar olabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="facaa-204">Http veya HTTPS kullanarak kimlik doğrulaması yapılan aramalar aracılığıyla dünyanın her yerinden mesajlara erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="facaa-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="facaa-205">Depolama kuyrukları, trafik artışlarını işlemek için çok sayıda eşzamanlı istemciye ölçeklenebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="facaa-206">Bununla birlikte, hizmetle ilgili sınırlamalar vardır:</span><span class="sxs-lookup"><span data-stu-id="facaa-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="facaa-207">İleti siparişi garanti değildir.</span><span class="sxs-lookup"><span data-stu-id="facaa-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="facaa-208">İleti otomatik olarak kaldırılmadan önce yalnızca yedi gün süreyle devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="facaa-209">Devlet yönetimi, yinelenen algılama veya hareketler için destek kullanılamıyor.</span><span class="sxs-lookup"><span data-stu-id="facaa-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="facaa-210">Şekil 4-13, Azure Depolama Kuyruğu'nun hiyerarşisini gösterir.</span><span class="sxs-lookup"><span data-stu-id="facaa-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![Depolama sırası hiyerarşisi](./media/storage-queue-hierarchy.png)

<span data-ttu-id="facaa-212">**Şekil 4-13**.</span><span class="sxs-lookup"><span data-stu-id="facaa-212">**Figure 4-13**.</span></span> <span data-ttu-id="facaa-213">Depolama sırası hiyerarşisi</span><span class="sxs-lookup"><span data-stu-id="facaa-213">Storage queue hierarchy</span></span>

<span data-ttu-id="facaa-214">Önceki şekilde, depolama kuyruklarının iletilerini temel Azure Depolama hesabında nasıl depolatadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="facaa-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="facaa-215">Geliştiriciler için Microsoft, Depolama sıra işleme için birkaç istemci ve sunucu tarafı kitaplıkları sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="facaa-216">.NET, Java, JavaScript, Ruby, Python ve Go dahil olmak üzere en önemli platformlar desteklenir.</span><span class="sxs-lookup"><span data-stu-id="facaa-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="facaa-217">Geliştiriciler bu kitaplıklarla asla doğrudan iletişim kurmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="facaa-218">Bunu yapmak, mikro hizmet kodunuzu Azure Depolama Sırası hizmetiyle sıkı bir şekilde biraraya getirecektir.</span><span class="sxs-lookup"><span data-stu-id="facaa-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="facaa-219">API'nin uygulama ayrıntılarını yalıtmak daha iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="facaa-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="facaa-220">Genel işlemleri ortaya çıkaran ve beton kitaplığı kapsülleyen bir ara bağlantı katmanı veya ara API tanıtın.</span><span class="sxs-lookup"><span data-stu-id="facaa-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="facaa-221">Bu gevşek bağlantı, ana hat hizmet kodunda değişiklik yapmak zorunda kalmadan bir kuyruk hizmetini başka bir hizmetle değiştirmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="facaa-222">Azure Depolama kuyrukları, bulut tası uygulamalarınızda komut iletisi uygulamak için ekonomik bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="facaa-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="facaa-223">Özellikle bir kuyruk boyutu 80 GB'ı aşacaksa veya basit bir özellik kümesi kabul edilebilirse.</span><span class="sxs-lookup"><span data-stu-id="facaa-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="facaa-224">Yalnızca iletilerin depolanması için ödeme yapıyorsun; sabit saatlik ücret yoktur.</span><span class="sxs-lookup"><span data-stu-id="facaa-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="facaa-225">Azure Service Bus Kuyrukları</span><span class="sxs-lookup"><span data-stu-id="facaa-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="facaa-226">Daha karmaşık ileti gereksinimleri için Azure Servis Veri Servisi sıralarını göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="facaa-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="facaa-227">Sağlam bir ileti altyapısının üzerinde oturan [Azure Servis Veri Servisi,](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) aracılı bir *mesajlaşma modelini*destekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="facaa-228">İletiler, tüketici tarafından alınana kadar bir brokerda (kuyrukta) güvenilir bir şekilde depolanır.</span><span class="sxs-lookup"><span data-stu-id="facaa-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="facaa-229">Kuyruk, iletilerin sıraya eklenme sırasına göre İlk Giren/İlk Çıkış (FIFO) ileti teslimini garanti eder.</span><span class="sxs-lookup"><span data-stu-id="facaa-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="facaa-230">İletinin boyutu 256 KB'ye kadar çok daha büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="facaa-231">İletiler sınırsız bir süre için kuyrukta kalıcıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="facaa-232">Servis Veri Servisi yalnızca HTTP tabanlı aramaları desteklemekle kalmıyor, aynı zamanda [AMPQ protokolü](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)için tam destek de sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="facaa-233">AMPQ, ikili protokolü ve daha yüksek güvenilirlik derecelerini destekleyen satıcılar arasında açık standarttır.</span><span class="sxs-lookup"><span data-stu-id="facaa-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="facaa-234">Service Bus, [işlem desteği](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) ve yinelenen algılama [özelliği](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)de dahil olmak üzere zengin bir özellik kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="facaa-235">Sıra, ileti başına "en fazla bir kez teslimat" garantisi vetir.</span><span class="sxs-lookup"><span data-stu-id="facaa-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="facaa-236">Önceden gönderilmiş bir iletiyi otomatik olarak atar.</span><span class="sxs-lookup"><span data-stu-id="facaa-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="facaa-237">Bir üreticinin şüphesi varsa, aynı iletiyi yeniden gönderebilir ve Servis Veri Servisi yalnızca bir kopyanın işlenmesini garanti eder.</span><span class="sxs-lookup"><span data-stu-id="facaa-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="facaa-238">Yinelenen algılama, ek altyapı tesisatı oluşturmak zorunda kalmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="facaa-239">İki kurumsal özellik daha bölümleme ve oturumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="facaa-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="facaa-240">Geleneksel Bir Hizmet Veri Servisi sırası tek bir ileti aracısı tarafından işlenir ve tek bir ileti deposunda depolanır.</span><span class="sxs-lookup"><span data-stu-id="facaa-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="facaa-241">Ancak, [Servis Veri Servisi Bölümleme](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) birden çok ileti aracısı ve ileti mağazaları arasında kuyruk yayılır.</span><span class="sxs-lookup"><span data-stu-id="facaa-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="facaa-242">Genel iş ortası artık tek bir ileti aracıcısının veya mesajlaşma mağazasının performansıyla sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="facaa-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="facaa-243">İleti deposunun geçici kesintisi, bölümlenmiş bir sırayı kullanılamaz hale getirmez.</span><span class="sxs-lookup"><span data-stu-id="facaa-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="facaa-244">[Servis Veri Yolu Oturumları,](https://codingcanvas.com/azure-service-bus-sessions/) grupla ilgili iletilere giden bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="facaa-245">İletilerin birlikte işlenmesi ve işlemin sonunda tamamlanması gereken bir iş akışı senaryosu düşünün.</span><span class="sxs-lookup"><span data-stu-id="facaa-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="facaa-246">Bu avantajdan yararlanmak için, sıra için oturumların açıkça etkinleştirilmesi ve ilgili iletilerin her birinin aynı oturum kimliğini içermesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="facaa-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="facaa-247">Ancak, bazı önemli uyarılar vardır: Servis Veri Servisi kuyrukları boyutu 80 GB ile sınırlıdır ve bu da mağaza kuyruklarında mevcut olandan çok daha küçüktür.</span><span class="sxs-lookup"><span data-stu-id="facaa-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="facaa-248">Ayrıca, Servis Veri Servisi kuyrukları işlem başına temel maliyet ve ücrete tabidir.</span><span class="sxs-lookup"><span data-stu-id="facaa-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="facaa-249">Şekil 4-14, Servis Veri Servisi kuyruğunun üst düzey mimarisini özetlemektedir.</span><span class="sxs-lookup"><span data-stu-id="facaa-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![Service Bus kuyruğu](./media/service-bus-queue.png)

<span data-ttu-id="facaa-251">**Şekil 4-14**.</span><span class="sxs-lookup"><span data-stu-id="facaa-251">**Figure 4-14**.</span></span> <span data-ttu-id="facaa-252">Service Bus kuyruğu</span><span class="sxs-lookup"><span data-stu-id="facaa-252">Service Bus queue</span></span>

<span data-ttu-id="facaa-253">Önceki şekilde, noktadan noktaya ilişkiye dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="facaa-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="facaa-254">Aynı sağlayıcının iki örneği, iletileri tek bir Hizmet Veri Günü kuyruğuna sıralıyor.</span><span class="sxs-lookup"><span data-stu-id="facaa-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="facaa-255">Her ileti, sağdaki üç tüketici örneğinden yalnızca biri tarafından tüketilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="facaa-256">Daha sonra, farklı tüketicilerin aynı mesajın ilginizi çekebileceği mesajlaşmanın nasıl uygulanacağını tartışıyoruz.</span><span class="sxs-lookup"><span data-stu-id="facaa-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="facaa-257">Olaylar</span><span class="sxs-lookup"><span data-stu-id="facaa-257">Events</span></span>

<span data-ttu-id="facaa-258">İleti sıraya bir üretici eşsenkronize bir tüketici bir mesaj gönderebilirsiniz iletişim uygulamak için etkili bir yoldur.</span><span class="sxs-lookup"><span data-stu-id="facaa-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="facaa-259">Ancak, birçok *farklı tüketici* aynı mesajla ilgilendiğinde ne olur?</span><span class="sxs-lookup"><span data-stu-id="facaa-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="facaa-260">Her tüketici için özel bir ileti sırası iyi ölçek olmaz ve yönetmek zor olur.</span><span class="sxs-lookup"><span data-stu-id="facaa-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="facaa-261">Bu senaryoyu ele almak için, üçüncü ileti etkileşimi türüne, *olaya*geçiyoruz.</span><span class="sxs-lookup"><span data-stu-id="facaa-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="facaa-262">Bir microservice bir eylem meydana geldiğini duyurdu.</span><span class="sxs-lookup"><span data-stu-id="facaa-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="facaa-263">Diğer mikro hizmetler, eğer ilgileniyorsa, eyleme veya olaya tepki verir.</span><span class="sxs-lookup"><span data-stu-id="facaa-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="facaa-264">Olay iki adımlı bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="facaa-264">Eventing is a two-step process.</span></span> <span data-ttu-id="facaa-265">Belirli bir durum değişikliği için, bir microservice bir ileti aracısına bir olay yayınlar ve bu da olayı diğer ilgili microservice'ler için kullanılabilir hale getirir.</span><span class="sxs-lookup"><span data-stu-id="facaa-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="facaa-266">İlgili microservice mesaj komisyoncusu olay abone tarafından bildirilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="facaa-267">[Olay tabanlı iletişimi](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)uygulamak için [Yayımla/Abone Ol](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) modelini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="facaa-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="facaa-268">Şekil 4-15 bir alışveriş sepeti microservice diğer iki mikro hizmetler abone bir olay yayın gösterir.</span><span class="sxs-lookup"><span data-stu-id="facaa-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![Olay Odaklı mesajlaşma](./media/event-driven-messaging.png)

<span data-ttu-id="facaa-270">**Şekil 4-15**.</span><span class="sxs-lookup"><span data-stu-id="facaa-270">**Figure 4-15**.</span></span> <span data-ttu-id="facaa-271">Olay Odaklı mesajlaşma</span><span class="sxs-lookup"><span data-stu-id="facaa-271">Event-Driven messaging</span></span>

<span data-ttu-id="facaa-272">İletişim kanalının ortasında bulunan *olay veri yolunda* bileşene dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="facaa-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="facaa-273">İleti aracısını kapsülleyen ve temel uygulamadan ayıran özel bir sınıf.</span><span class="sxs-lookup"><span data-stu-id="facaa-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="facaa-274">Sipariş ve envanter mikrohizmetleri, ne birbirlerinden hiçbir bilgi olmadan ne de alışveriş sepeti microservice olmadan olay bağımsız olarak çalışır.</span><span class="sxs-lookup"><span data-stu-id="facaa-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="facaa-275">Kayıtlı olay olay otobüsüne yayınlandığında, buna göre hareket ederler.</span><span class="sxs-lookup"><span data-stu-id="facaa-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="facaa-276">Eventing ile, biz *konulara*kuyruk teknolojisi hareket .</span><span class="sxs-lookup"><span data-stu-id="facaa-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="facaa-277">[Bir konu](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) kuyruğa benzer, ancak bir-çok ileti deseni destekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="facaa-278">Bir microservice bir ileti yayımlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-278">One microservice publishes a message.</span></span> <span data-ttu-id="facaa-279">Birden fazla abone mikro hizmetleri almak ve bu ileti üzerine hareket seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="facaa-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="facaa-280">Şekil 4-16 bir konu mimarisini gösterir.</span><span class="sxs-lookup"><span data-stu-id="facaa-280">Figure 4-16 shows a topic architecture.</span></span>

![Konu mimarisi](./media/topic-architecture.png)

<span data-ttu-id="facaa-282">**Şekil 4-16**.</span><span class="sxs-lookup"><span data-stu-id="facaa-282">**Figure 4-16**.</span></span> <span data-ttu-id="facaa-283">Konu mimarisi</span><span class="sxs-lookup"><span data-stu-id="facaa-283">Topic architecture</span></span>

<span data-ttu-id="facaa-284">Önceki şekilde, yayıncılar konuya ileti gönderir.</span><span class="sxs-lookup"><span data-stu-id="facaa-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="facaa-285">Sonunda, aboneler aboneliklerden ileti alır.</span><span class="sxs-lookup"><span data-stu-id="facaa-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="facaa-286">Ortada, konu iletileri koyu mavi kutularda gösterilen bir dizi *kurala*göre aboneliklere iletilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="facaa-287">Kurallar, belirli iletileri aboneye ileden bir filtre görevi görede dir.</span><span class="sxs-lookup"><span data-stu-id="facaa-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="facaa-288">Burada, Bir "CreateOrder" etkinliği Abonelik \#1 \#ve Abonelik 3'e gönderilir, ancak Abonelik \#2'ye gönderilmez.</span><span class="sxs-lookup"><span data-stu-id="facaa-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="facaa-289">Abonelik 2 ve Abonelik \# \#3'e bir "Sipariş Tamamlandı" etkinliği gönderilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="facaa-290">Azure bulutu iki farklı konu hizmetini destekler: Azure Hizmet Veri Veri Günü Konuları ve Azure EventGrid.</span><span class="sxs-lookup"><span data-stu-id="facaa-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="facaa-291">Azure Service Bus Konuları</span><span class="sxs-lookup"><span data-stu-id="facaa-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="facaa-292">Azure Hizmet Veri Servisi Veri Hizmetleri kuyruklarının aynı sağlam aracılı ileti modelinin üzerinde oturan [Azure Hizmet Veri Meskeni Konularıdır.](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)</span><span class="sxs-lookup"><span data-stu-id="facaa-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="facaa-293">Bir konu birden çok bağımsız yayımcıdan ileti alabilir ve en fazla 2.000 aboneye ileti gönderebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="facaa-294">Abonelikler, sistemi durdurmadan veya konuyu yeniden oluşturmadan çalışma zamanında dinamik olarak eklenebilir veya kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="facaa-295">[Yinelenen Algılama](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) ve [İşlem desteği](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)de dahil olmak üzere konular için Azure Servis Veri Servisi veri hizmeti kuyruklarından birçok gelişmiş özellik de mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="facaa-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="facaa-296">Varsayılan olarak, Hizmet Veri Mes'i konuları tek bir ileti aracısı tarafından işlenir ve tek bir ileti deposunda depolanır.</span><span class="sxs-lookup"><span data-stu-id="facaa-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="facaa-297">Ancak, [Servis Veri Hizmetleri Bölümleme](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) birçok mesaj broker ve mesaj mağazaları arasında yayArak bir konu ölçekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="facaa-298">[Zamanlanmış İleti Teslimi,](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) işleme için belirli bir zamanı olan bir iletiyi etiketler.</span><span class="sxs-lookup"><span data-stu-id="facaa-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="facaa-299">İleti bu tarihten önce konuiçinde görünmez.</span><span class="sxs-lookup"><span data-stu-id="facaa-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="facaa-300">[İleti Erteleme,](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) iletinin alınmasını daha sonraki bir zamana ertelemenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="facaa-301">Her ikisi de, işlemlerin belirli bir sırada işlendiği iş akışı işleme senaryolarında yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="facaa-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="facaa-302">Alınan iletilerin işlenmesini önceki çalışma tamamlanana kadar erteleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="facaa-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="facaa-303">Servis Veri Mes'i konuları, bulut tabanlı sistemlerinizde yayın/abone iletişimi etkinleştirmek için sağlam ve kanıtlanmış bir teknolojidir.</span><span class="sxs-lookup"><span data-stu-id="facaa-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="facaa-304">Azure Event Grid</span><span class="sxs-lookup"><span data-stu-id="facaa-304">Azure Event Grid</span></span>

<span data-ttu-id="facaa-305">Azure Hizmet Veri Yolu, tam kurumsal özelliklere sahip savaş testine tabi bir mesajlaşma aracısı olsa da, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) bloktaki yeni çocuktur.</span><span class="sxs-lookup"><span data-stu-id="facaa-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="facaa-306">İlk bakışta, Olay Izgara sadece başka bir konu tabanlı mesajlaşma sistemi gibi görünebilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="facaa-307">Ancak, birçok yönden farklı.</span><span class="sxs-lookup"><span data-stu-id="facaa-307">However, it's different in many ways.</span></span> <span data-ttu-id="facaa-308">Olay odaklı iş yüklerine odaklanan bu proje, gerçek zamanlı etkinlik işleme, derin Azure tümleştirmesi ve sunucusuz altyapıda açık bir platform sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="facaa-309">Çağdaş bulut tabanlı ve sunucusuz uygulamalar için tasarlanmıştır</span><span class="sxs-lookup"><span data-stu-id="facaa-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="facaa-310">Merkezi bir *olay arka düzlemi*veya boş tabiri olarak, Olay Grid Azure kaynakları içindeki ve kendi hizmetlerinizdeki olaylara tepki verir.</span><span class="sxs-lookup"><span data-stu-id="facaa-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="facaa-311">Olay bildirimleri, sırayla her olayı bir aboneye yönlendirir bir Olay Izgara Konusu'nda yayınlanır.</span><span class="sxs-lookup"><span data-stu-id="facaa-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="facaa-312">Aboneler aboneliklerin haritasını çıkarır ve olayları tüketir.</span><span class="sxs-lookup"><span data-stu-id="facaa-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="facaa-313">Hizmet Veri Servisi gibi, Olay Izgara sıda almak istediği etkinlikler için abonelik kuralını ayarladığı *filtrelenmiş* bir abone modelini destekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="facaa-314">Olay Izgarası, azure servis veri hizmeti veri nelerinin oluşturabileceğinden çok daha fazla gerçek zamanlı teslimatı sağlayan saniyede 10 milyon olay garantisi ile hızlı iş artışı sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="facaa-315">Event Grid için tatlı bir nokta, Azure altyapısının dokusuna derin entegrasyonudur.</span><span class="sxs-lookup"><span data-stu-id="facaa-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="facaa-316">Cosmos DB gibi bir Azure kaynağı, yerleşik olayları özel koda gerek kalmadan doğrudan diğer ilgili Azure kaynaklarına yayınlayabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="facaa-317">Olay Ağıt, bir Azure Aboneliği, Kaynak Grubu veya Hizmetten etkinlikler yayımlayarak geliştiricilere bulut kaynaklarının yaşam döngüsü üzerinde ince düzeyli denetim sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="facaa-318">Ancak, Olay Izgarası Azure ile sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="facaa-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="facaa-319">Uygulamalardan veya üçüncü taraf hizmetlerden yayınlanan özel HTTP olaylarını tüketebilen ve olayları harici abonelere yönlendirebilen açık bir platformdur.</span><span class="sxs-lookup"><span data-stu-id="facaa-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="facaa-320">Azure kaynaklarından yerel etkinlikleryayımlanır ken ve abone yken kodlama gerekmez.</span><span class="sxs-lookup"><span data-stu-id="facaa-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="facaa-321">Basit yapılandırmayla, etkinlikleri bir Azure kaynağından diğerine, Konular ve Abonelikler için yerleşik tesisattan yararlanarak entegre edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="facaa-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="facaa-322">Şekil 4-17 Olay Izgara anatomisi gösterir.</span><span class="sxs-lookup"><span data-stu-id="facaa-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![Olay Izgara anatomisi](./media/event-grid-anatomy.png)

<span data-ttu-id="facaa-324">**Şekil 4-17**.</span><span class="sxs-lookup"><span data-stu-id="facaa-324">**Figure 4-17**.</span></span> <span data-ttu-id="facaa-325">Olay Izgara anatomisi</span><span class="sxs-lookup"><span data-stu-id="facaa-325">Event Grid anatomy</span></span>

<span data-ttu-id="facaa-326">EventGrid ve Servis Veri Servisi arasındaki önemli bir fark, temel *ileti alışverişi desenidir.*</span><span class="sxs-lookup"><span data-stu-id="facaa-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="facaa-327">Service Bus, alt akış abonesinin yeni iletiler için konu aboneliğini etkin olarak yokladığı eski bir stil *çekme modeli* uygular.</span><span class="sxs-lookup"><span data-stu-id="facaa-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="facaa-328">İyi tarafından bakarsak, bu yaklaşım aboneye iletileri işleyen hızı tam olarak kontrol eder.</span><span class="sxs-lookup"><span data-stu-id="facaa-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="facaa-329">Herhangi bir zamanda ne zaman ve kaç iletinin işletileceğini denetler.</span><span class="sxs-lookup"><span data-stu-id="facaa-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="facaa-330">Okunmamış iletiler işlenene kadar abonelikte kalır.</span><span class="sxs-lookup"><span data-stu-id="facaa-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="facaa-331">Önemli bir eksiklik, olayın oluşturulduğu saat ile bu iletiyi işleme için aboneye çeken yoklama işlemi arasındaki gecikmedir.</span><span class="sxs-lookup"><span data-stu-id="facaa-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="facaa-332">Ayrıca, bir sonraki olay için sürekli yoklama yükü kaynakları ve para tüketir.</span><span class="sxs-lookup"><span data-stu-id="facaa-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="facaa-333">Ancak EventGrid farklıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-333">EventGrid, however, is different.</span></span> <span data-ttu-id="facaa-334">Olayların alındığı gibi EventHandlers'a gönderildiği bir *itme modeli* uygular ve neredeyse gerçek zamanlı etkinlik teslimi verir.</span><span class="sxs-lookup"><span data-stu-id="facaa-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="facaa-335">Ayrıca, hizmet yalnızca bir olayı tüketmek gerektiğinde tetiklendiğinden ( sürekli olarak yoklamada olduğu gibi değil- maliyeti azaltır.</span><span class="sxs-lookup"><span data-stu-id="facaa-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="facaa-336">Bununla ilgili olarak, bir olay işleyicisi gelen yükü işlemeli ve kendini bunalmayı korumak için azaltma mekanizmaları sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="facaa-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="facaa-337">Azure İşlevleri ve Mantıksal Uygulamalar gibi bu olayları tüketen birçok Azure hizmeti, artan yükleri işlemek için otomatik otomatik ölçekleme özellikleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="facaa-338">Olay Grid tamamen yönetilen sunucusuz bir bulut hizmetidir.</span><span class="sxs-lookup"><span data-stu-id="facaa-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="facaa-339">Trafiğinize göre dinamik olarak ölçeklendirilir ve önceden satın alınan kapasiteiçin değil, yalnızca gerçek kullanımınız için ücretlendirilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="facaa-340">Ayda ilk 100.000 işlem ücretsizdir – etkinlik girişi (gelen olay bildirimleri), abonelik teslim girişimleri, yönetim çağrıları ve konuya göre filtreleme olarak tanımlanan işlemler.</span><span class="sxs-lookup"><span data-stu-id="facaa-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="facaa-341">%99,99 kullanılabilirlik ile EventGrid, başarısız teslimat için yerleşik yeniden deneme işleviyle bir etkinliğin 24 saatlik bir süre içinde teslim ini garanti eder.</span><span class="sxs-lookup"><span data-stu-id="facaa-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="facaa-342">Teslim edilmeyen iletiler çözüm için "ölü harf" kuyruğuna taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="facaa-343">Azure Servis Veri Servisi'nin aksine, Event Grid hızlı performans için ayarlanmıştır ve sipariş edilen ileti, işlem ve oturum gibi özellikleri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="facaa-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="facaa-344">Azure bulutunda ileti akışı</span><span class="sxs-lookup"><span data-stu-id="facaa-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="facaa-345">Azure Hizmet Veri Servisi ve Etkinlik Ağıtı, Cosmos DB'ye yeni bir belge eklenmiş gibi tek ve ayrı olayları ortaya çıkaran uygulamalar için büyük destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="facaa-346">Ancak, bulut tabanlı *sisteminizin ilgili olaylar akışını işlemesi*gerekiyorsa ne olur?</span><span class="sxs-lookup"><span data-stu-id="facaa-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="facaa-347">[Olay akışları](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="facaa-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="facaa-348">Genellikle zaman sıralı, birbiriyle ilişkili ve bir grup olarak işlenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="facaa-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="facaa-349">[Azure Event Hub,](https://azure.microsoft.com/services/event-hubs/) olayları toplayan, dönüştüren ve depolayan bir veri akış platformu ve etkinlik hizmetidir.</span><span class="sxs-lookup"><span data-stu-id="facaa-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="facaa-350">Telemetri bağlamından yayılan sürekli olay bildirimleri gibi akış verilerini yakalamak için ince ayar lı.</span><span class="sxs-lookup"><span data-stu-id="facaa-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="facaa-351">Hizmet son derece ölçeklenebilir ve saniyede milyonlarca olayı depolayabilir ve [işleyebilir.](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)</span><span class="sxs-lookup"><span data-stu-id="facaa-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="facaa-352">Şekil 4-18'de gösterildiği gibi, genellikle bir olay boru hattı için bir ön kapıdır ve akış ları olay tüketiminden ayırır.</span><span class="sxs-lookup"><span data-stu-id="facaa-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure Event Hub](./media/azure-event-hub.png)

<span data-ttu-id="facaa-354">**Şekil 4-18**.</span><span class="sxs-lookup"><span data-stu-id="facaa-354">**Figure 4-18**.</span></span> <span data-ttu-id="facaa-355">Azure Event Hub</span><span class="sxs-lookup"><span data-stu-id="facaa-355">Azure Event Hub</span></span>

<span data-ttu-id="facaa-356">Olay Hub düşük gecikme süresi ve yapılandırılabilir zaman tutma destekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="facaa-357">Sıraların ve konuların aksine, Olay Hub'ları olay verilerini bir tüketici tarafından okunduktan sonra saklar.</span><span class="sxs-lookup"><span data-stu-id="facaa-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="facaa-358">Bu özellik, diğer veri analitik hizmetlerinin, hem dahili hem de harici olarak, daha fazla analiz için verileri yeniden oynatmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="facaa-359">Olay merkezinde depolanan olaylar yalnızca bekletme süresinin sona ermesinden sonra silinir, bu da varsayılan olarak bir gün, ancak yapılandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="facaa-360">Olay Hub' ı HTTPS ve AMQP gibi yaygın olay yayımlama protokollerini destekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="facaa-361">Ayrıca Kafka 1.0 destekler.</span><span class="sxs-lookup"><span data-stu-id="facaa-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="facaa-362">Mevcut Kafka uygulamaları, büyük Kafka kümelerini yönetmeye alternatif sağlayan Kafka protokolünü kullanarak [Event Hub ile iletişim kurabilir.](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)</span><span class="sxs-lookup"><span data-stu-id="facaa-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="facaa-363">Birçok açık kaynak bulut-yerli sistemleri Kafka kucaklamak.</span><span class="sxs-lookup"><span data-stu-id="facaa-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="facaa-364">Olay Hub'ları, her tüketicinin ileti akışının yalnızca belirli bir alt kümesini veya bölümlerini okuduğu [bölümlenmiş](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) bir tüketici modeli aracılığıyla ileti akışı uygular.</span><span class="sxs-lookup"><span data-stu-id="facaa-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="facaa-365">Bu desen, olay işleme için muazzam yatay ölçek sağlar ve kuyruklarda ve konularda kullanılamayan diğer akış odaklı özellikler sağlar.</span><span class="sxs-lookup"><span data-stu-id="facaa-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="facaa-366">Bölüm bir olay hub'ında tutulan olayların sıralı dizisidir.</span><span class="sxs-lookup"><span data-stu-id="facaa-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="facaa-367">Yeni olaylar geldikçe, bu dizinin sonuna eklenir.</span><span class="sxs-lookup"><span data-stu-id="facaa-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="facaa-368">Şekil 4-19, Bir Olay Hub'ında bölümleme gösterir.</span><span class="sxs-lookup"><span data-stu-id="facaa-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![Olay Hub bölümleme](./media/event-hub-partitioning.png)

<span data-ttu-id="facaa-370">**Şekil 4-19**.</span><span class="sxs-lookup"><span data-stu-id="facaa-370">**Figure 4-19**.</span></span> <span data-ttu-id="facaa-371">Olay Hub bölümleme</span><span class="sxs-lookup"><span data-stu-id="facaa-371">Event Hub partitioning</span></span>

<span data-ttu-id="facaa-372">Her tüketici grubu, aynı kaynaktan okumak yerine, ileti akışının bir alt kümesini veya bölümlerini okur.</span><span class="sxs-lookup"><span data-stu-id="facaa-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="facaa-373">Azure Etkinlik Hub'ı, çok sayıda etkinlik akışı yapması gereken bulut tabanlı uygulamalar için sağlam ve uygun maliyetli bir çözüm olabilir.</span><span class="sxs-lookup"><span data-stu-id="facaa-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="facaa-374">[Önceki](front-end-communication.md)
>[Sonraki](rest-grpc.md)</span><span class="sxs-lookup"><span data-stu-id="facaa-374">[Previous](front-end-communication.md)
[Next](rest-grpc.md)</span></span>
