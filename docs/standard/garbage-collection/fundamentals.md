---
title: Çöp toplamanın temelleri
description: Çöp toplayıcısının nasıl çalıştığını ve en iyi performans için nasıl yapılandırılabileceğini öğrenin.
ms.date: 03/08/2018
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background garbage collection
- garbage collection, concurrent garbage collection
- garbage collection, server garbage collection
- garbage collection, workstation garbage collection
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 2c1b73108227160aaff28525beeca7f3bd4cb5f8
ms.sourcegitcommit: 559259da2738a7b33a46c0130e51d336091c2097
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/22/2019
ms.locfileid: "72775320"
---
# <a name="fundamentals-of-garbage-collection"></a><span data-ttu-id="ed7a4-103">Çöp toplamanın temelleri</span><span class="sxs-lookup"><span data-stu-id="ed7a4-103">Fundamentals of garbage collection</span></span>

<a name="top"></a><span data-ttu-id="ed7a4-104">Ortak dil çalışma zamanında (CLR), çöp toplayıcı otomatik bellek yöneticisi olarak görev yapar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-104">In the common language runtime (CLR), the garbage collector serves as an automatic memory manager.</span></span> <span data-ttu-id="ed7a4-105">Aşağıdaki avantajları sağlar:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-105">It provides the following benefits:</span></span>

- <span data-ttu-id="ed7a4-106">Oluşturduğunuz nesneler için el ile bellek boşaltmaya gerek kalmadan uygulamanızı geliştirmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-106">Enables you to develop your application without having to manually free memory for objects you create.</span></span>

- <span data-ttu-id="ed7a4-107">Yönetilen yığında nesneleri verimli bir şekilde ayırır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-107">Allocates objects on the managed heap efficiently.</span></span>

- <span data-ttu-id="ed7a4-108">Artık kullanılmayan nesneleri geri kazanır, hafızasını temizler ve belleğin gelecekteki ayırmalarda kullanılabilmesini önler.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-108">Reclaims objects that are no longer being used, clears their memory, and keeps the memory available for future allocations.</span></span> <span data-ttu-id="ed7a4-109">Yönetilen nesneler, ile başlamak için otomatik olarak temiz içerik alır, bu nedenle oluşturucuların her veri alanını başlatması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-109">Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</span></span>

- <span data-ttu-id="ed7a4-110">Bir nesnenin başka bir nesnenin içeriğini kullanabilmesi için bellek güvenliği sağlar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-110">Provides memory safety by making sure that an object cannot use the content of another object.</span></span>

 <span data-ttu-id="ed7a4-111">Bu konuda çöp toplamanın temel kavramları açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-111">This topic describes the core concepts of garbage collection.</span></span>

<a name="fundamentals_of_memory"></a>

## <a name="fundamentals-of-memory"></a><span data-ttu-id="ed7a4-112">Belleğin temelleri</span><span class="sxs-lookup"><span data-stu-id="ed7a4-112">Fundamentals of memory</span></span>

<span data-ttu-id="ed7a4-113">Aşağıdaki listede, önemli CLR belleği kavramları özetlenmektedir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-113">The following list summarizes important CLR memory concepts.</span></span>

- <span data-ttu-id="ed7a4-114">Her işlemin kendi kendine ayrı bir sanal adres alanı vardır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-114">Each process has its own, separate virtual address space.</span></span> <span data-ttu-id="ed7a4-115">Aynı bilgisayardaki tüm işlemlerin aynı fiziksel belleği paylaştığı ve varsa sayfa dosyasını paylaştığı bir işlem.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-115">All processes on the same computer share the same physical memory, and share the page file if there is one.</span></span>

- <span data-ttu-id="ed7a4-116">Varsayılan olarak, 32 bit bilgisayarlarda, her işlemin 2 GB 'lık bir Kullanıcı modu sanal adres alanı vardır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-116">By default, on 32-bit computers, each process has a 2-GB user-mode virtual address space.</span></span>

- <span data-ttu-id="ed7a4-117">Bir uygulama geliştiricisi olarak yalnızca sanal adres alanı ile çalışır ve fiziksel belleği doğrudan hiçbir şekilde işlemeyin.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-117">As an application developer, you work only with virtual address space and never manipulate physical memory directly.</span></span> <span data-ttu-id="ed7a4-118">Çöp toplayıcı, yönetilen yığında sizin için sanal belleği ayırır ve serbest bırakır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-118">The garbage collector allocates and frees virtual memory for you on the managed heap.</span></span>

  <span data-ttu-id="ed7a4-119">Yerel kod yazıyorsanız, sanal adres alanı ile çalışmak için Win32 işlevlerini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-119">If you are writing native code, you use Win32 functions to work with the virtual address space.</span></span> <span data-ttu-id="ed7a4-120">Bu işlevler, yerel yığınlardaki sanal belleği ayırır ve boşaltır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-120">These functions allocate and free virtual memory for you on native heaps.</span></span>

- <span data-ttu-id="ed7a4-121">Sanal bellek üç durumda olabilir:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-121">Virtual memory can be in three states:</span></span>

  - <span data-ttu-id="ed7a4-122">Süz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-122">Free.</span></span> <span data-ttu-id="ed7a4-123">Bellek bloğunun kendisine başvuru yoktur ve ayırma için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-123">The block of memory has no references to it and is available for allocation.</span></span>

  - <span data-ttu-id="ed7a4-124">Ayrılamadı.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-124">Reserved.</span></span> <span data-ttu-id="ed7a4-125">Bellek bloğu kullanım için kullanılabilir ve diğer herhangi bir ayırma isteği için kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-125">The block of memory is available for your use and cannot be used for any other allocation request.</span></span> <span data-ttu-id="ed7a4-126">Ancak, bu bellek bloğunda verileri kaydedilene kadar depoleyemez.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-126">However, you cannot store data to this memory block until it is committed.</span></span>

  - <span data-ttu-id="ed7a4-127">Yazıldı.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-127">Committed.</span></span> <span data-ttu-id="ed7a4-128">Bellek bloğu fiziksel depolamaya atanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-128">The block of memory is assigned to physical storage.</span></span>

- <span data-ttu-id="ed7a4-129">Sanal adres alanı parçalanabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-129">Virtual address space can get fragmented.</span></span> <span data-ttu-id="ed7a4-130">Bu, adres alanında delik olarak da bilinen boş blokların olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-130">This means that there are free blocks, also known as holes, in the address space.</span></span> <span data-ttu-id="ed7a4-131">Sanal bellek ayırma istendiğinde, sanal bellek yöneticisinin, bu ayırma isteğini karşılamak için yeterince büyük olan tek bir ücretsiz blok bulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-131">When a virtual memory allocation is requested, the virtual memory manager has to find a single free block that is large enough to satisfy that allocation request.</span></span> <span data-ttu-id="ed7a4-132">2 GB boş alan olsa bile, tüm bu boş alan tek bir adres bloğunda yer almadığı takdirde 2 GB gerektiren ayırma başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-132">Even if you have 2 GB of free space, the allocation that requires 2 GB will be unsuccessful unless all of that free space is in a single address block.</span></span>

- <span data-ttu-id="ed7a4-133">Ayrılacak sanal adres alanı tükenmeniz veya fiziksel alanın kaydedilmesi için bellek tükeniyor.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-133">You can run out of memory if you run out of virtual address space to reserve or physical space to commit.</span></span>

<span data-ttu-id="ed7a4-134">Fiziksel bellek baskısı (yani fiziksel bellek talebi) düşük olsa bile sayfa dosyanız kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-134">Your page file is used even if physical memory pressure (that is, demand for physical memory) is low.</span></span> <span data-ttu-id="ed7a4-135">Fiziksel bellek basıncını ilk kez yüksek olduğunda, işletim sisteminin verileri depolamak için fiziksel bellekte yer yapması gerekir ve fiziksel bellekteki bazı verileri sayfa dosyasına yedekler.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-135">The first time your physical memory pressure is high, the operating system must make room in physical memory to store data, and it backs up some of the data that is in physical memory to the page file.</span></span> <span data-ttu-id="ed7a4-136">Bu veriler, gerekli olana kadar sayfalanmadığı için fiziksel bellek basıncının çok düşük olduğu durumlarda sayfalama ile karşılaşmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-136">That data is not paged until it is needed, so it is possible to encounter paging in situations where the physical memory pressure is very low.</span></span>

[<span data-ttu-id="ed7a4-137">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-137">Back to top</span></span>](#top)

<a name="conditions_for_a_garbage_collection"></a>

## <a name="conditions-for-a-garbage-collection"></a><span data-ttu-id="ed7a4-138">Çöp toplama koşulları</span><span class="sxs-lookup"><span data-stu-id="ed7a4-138">Conditions for a garbage collection</span></span>

<span data-ttu-id="ed7a4-139">Çöp toplama, aşağıdaki koşullardan biri doğru olduğunda gerçekleşir:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-139">Garbage collection occurs when one of the following conditions is true:</span></span>

- <span data-ttu-id="ed7a4-140">Sistemde fiziksel bellek yetersiz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-140">The system has low physical memory.</span></span> <span data-ttu-id="ed7a4-141">Bu, ana bilgisayar tarafından belirtilen işletim sistemi ya da düşük bellekten düşük bellek bildirimi tarafından algılanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-141">This is detected by either the low memory notification from the OS or low memory indicated by the host.</span></span>

- <span data-ttu-id="ed7a4-142">Yönetilen yığında ayrılmış nesneler tarafından kullanılan bellek, kabul edilebilir bir eşik geçirir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-142">The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold.</span></span> <span data-ttu-id="ed7a4-143">İşlem çalışırken bu eşik sürekli olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-143">This threshold is continuously adjusted as the process runs.</span></span>

- <span data-ttu-id="ed7a4-144">@No__t_0 yöntemi çağrılır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-144">The <xref:System.GC.Collect%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="ed7a4-145">Neredeyse tüm durumlarda, çöp toplayıcı sürekli çalıştığından bu yöntemi çağırmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-145">In almost all cases, you do not have to call this method, because the garbage collector runs continuously.</span></span> <span data-ttu-id="ed7a4-146">Bu yöntem öncelikle benzersiz durumlar ve test için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-146">This method is primarily used for unique situations and testing.</span></span>

[<span data-ttu-id="ed7a4-147">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-147">Back to top</span></span>](#top)

<a name="the_managed_heap"></a>

## <a name="the-managed-heap"></a><span data-ttu-id="ed7a4-148">Yönetilen yığın</span><span class="sxs-lookup"><span data-stu-id="ed7a4-148">The managed heap</span></span>

<span data-ttu-id="ed7a4-149">Çöp toplayıcı CLR tarafından başlatıldıktan sonra, nesneleri depolamak ve yönetmek için bir bellek segmenti ayırır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-149">After the garbage collector is initialized by the CLR, it allocates a segment of memory to store and manage objects.</span></span> <span data-ttu-id="ed7a4-150">Bu bellek, işletim sistemindeki yerel bir yığının aksine yönetilen yığın olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-150">This memory is called the managed heap, as opposed to a native heap in the operating system.</span></span>

<span data-ttu-id="ed7a4-151">Yönetilen her işlem için yönetilen bir yığın vardır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-151">There is a managed heap for each managed process.</span></span> <span data-ttu-id="ed7a4-152">İşlemdeki tüm iş parçacıkları aynı yığında nesneler için bellek ayırır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-152">All threads in the process allocate memory for objects on the same heap.</span></span>

<span data-ttu-id="ed7a4-153">Bellek ayırmak için, çöp toplayıcı Win32 [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) işlevini çağırır ve yönetilen uygulamalar için bir seferde bir bellek segmentini ayırır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-153">To reserve memory, the garbage collector calls the Win32 [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) function, and reserves one segment of memory at a time for managed applications.</span></span> <span data-ttu-id="ed7a4-154">Çöp toplayıcı aynı zamanda kesimleri gereken şekilde ayırır ve Win32 [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) işlevini çağırarak kesimleri işletim sistemine (herhangi bir nesne temizlenmeden sonra) yeniden yayınlar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-154">The garbage collector also reserves segments as needed, and releases segments back to the operating system (after clearing them of any objects) by calling the Win32 [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree) function.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="ed7a4-155">Çöp toplayıcı tarafından ayrılan parçaların boyutu uygulamaya özgüdür ve düzenli güncelleştirmeler de dahil olmak üzere herhangi bir zamanda değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-155">The size of segments allocated by the garbage collector is implementation-specific and is subject to change at any time, including in periodic updates.</span></span> <span data-ttu-id="ed7a4-156">Uygulamanız, belirli bir kesim boyutuna ilişkin varsayımları asla belirtmemelidir veya buna bağlı olarak, kesim ayırmaları için kullanılabilir bellek miktarını yapılandırmayı denemelidir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-156">Your app should never make assumptions about or depend on a particular segment size, nor should it attempt to configure the amount of memory available for segment allocations.</span></span>

<span data-ttu-id="ed7a4-157">Yığın üzerinde daha az nesne ayrılmışsa, çöp toplayıcının yapması gereken daha az iş vardır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-157">The fewer objects allocated on the heap, the less work the garbage collector has to do.</span></span> <span data-ttu-id="ed7a4-158">Nesneleri ayırdığınızda, yalnızca 15 bayta ihtiyacınız olduğunda 32 baytlık bir dizi tahsis etme gibi gereksinimlerinizi aşan yuvarlanmış değerler kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-158">When you allocate objects, do not use rounded-up values that exceed your needs, such as allocating an array of 32 bytes when you need only 15 bytes.</span></span>

<span data-ttu-id="ed7a4-159">Çöp toplama tetiklendiğinde çöp toplayıcı, ölü nesneler tarafından kullanılan belleği geri kazanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-159">When a garbage collection is triggered, the garbage collector reclaims the memory that is occupied by dead objects.</span></span> <span data-ttu-id="ed7a4-160">Geri kazanma işlemi, canlı nesneleri bir araya gelecek şekilde sıkıştırır ve atılacak alan kaldırıldıktan sonra yığın daha küçük hale getirir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-160">The reclaiming process compacts live objects so that they are moved together, and the dead space is removed, thereby making the heap smaller.</span></span> <span data-ttu-id="ed7a4-161">Bu, birlikte ayrılan nesnelerin, konumlarını korumak için yönetilen yığında birlikte kalmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-161">This ensures that objects that are allocated together stay together on the managed heap, to preserve their locality.</span></span>

<span data-ttu-id="ed7a4-162">Çöp koleksiyonlarının sürekliliği (sıklığı ve süresi), ayırma hacminin ve yönetilen yığında kalan bellek miktarının sonucudur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-162">The intrusiveness (frequency and duration) of garbage collections is the result of the volume of allocations and the amount of survived memory on the managed heap.</span></span>

<span data-ttu-id="ed7a4-163">Yığın iki sayfa@@ 'nin birikmesi olarak düşünülebilir: [büyük nesne yığını](large-object-heap.md) ve küçük nesne yığını.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-163">The heap can be considered as the accumulation of two heaps: the [large object heap](large-object-heap.md) and the small object heap.</span></span>

<span data-ttu-id="ed7a4-164">[Büyük nesne yığını](large-object-heap.md) 85.000 bayt ve daha büyük olan çok büyük nesneler içerir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-164">The [large object heap](large-object-heap.md) contains very large objects that are 85,000 bytes and larger.</span></span> <span data-ttu-id="ed7a4-165">Büyük nesne yığınındaki nesneler genellikle dizilerdir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-165">The objects on the large object heap are usually arrays.</span></span> <span data-ttu-id="ed7a4-166">Örnek nesnesinin son derece büyük olması nadir bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-166">It is rare for an instance object to be extremely large.</span></span>

[<span data-ttu-id="ed7a4-167">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-167">Back to top</span></span>](#top)

<a name="generations"></a>

## <a name="generations"></a><span data-ttu-id="ed7a4-168">İse</span><span class="sxs-lookup"><span data-stu-id="ed7a4-168">Generations</span></span>

<span data-ttu-id="ed7a4-169">Yığın, uzun süreli ve kısa süreli nesneleri işleyebilmesi için nesiller halinde düzenlenir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-169">The heap is organized into generations so it can handle long-lived and short-lived objects.</span></span> <span data-ttu-id="ed7a4-170">Çöp toplama öncelikli olarak genellikle yığının yalnızca küçük bir kısmını kaplayan kısa süreli nesneler geri kazanma ile gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-170">Garbage collection primarily occurs with the reclamation of short-lived objects that typically occupy only a small part of the heap.</span></span> <span data-ttu-id="ed7a4-171">Yığında üç Neste nesne vardır:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-171">There are three generations of objects on the heap:</span></span>

- <span data-ttu-id="ed7a4-172">**Nesil 0**.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-172">**Generation 0**.</span></span> <span data-ttu-id="ed7a4-173">Bu, kardeşinizin nesli ve kısa süreli nesneler içerir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-173">This is the youngest generation and contains short-lived objects.</span></span> <span data-ttu-id="ed7a4-174">Kısa süreli bir nesne örneği, geçici bir değişkendir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-174">An example of a short-lived object is a temporary variable.</span></span> <span data-ttu-id="ed7a4-175">Çöp toplama bu nesde en sık oluşur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-175">Garbage collection occurs most frequently in this generation.</span></span>

  <span data-ttu-id="ed7a4-176">Yeni ayrılmış nesneler yeni nesil nesneler oluşturur ve büyük nesneler olmadıkları müddetçe örtük olarak nesil 0 koleksiyonlardır ve bu durumda 2. nesil bir koleksiyonda büyük nesne yığınında gider.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-176">Newly allocated objects form a new generation of objects and are implicitly generation 0 collections, unless they are large objects, in which case they go on the large object heap in a generation 2 collection.</span></span>

  <span data-ttu-id="ed7a4-177">Çoğu nesne, oluşturma 0 ' da çöp toplama için geri kazanılır ve bir sonraki nesle devam etmez.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-177">Most objects are reclaimed for garbage collection in generation 0 and do not survive to the next generation.</span></span>

- <span data-ttu-id="ed7a4-178">**1. nesil**.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-178">**Generation 1**.</span></span> <span data-ttu-id="ed7a4-179">Bu nesil, kısa süreli nesneler içerir ve kısa süreli nesneler ve uzun süreli nesneler arasında bir arabellek işlevi görür.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-179">This generation contains short-lived objects and serves as a buffer between short-lived objects and long-lived objects.</span></span>

- <span data-ttu-id="ed7a4-180">**2. nesil**.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-180">**Generation 2**.</span></span> <span data-ttu-id="ed7a4-181">Bu nesil uzun süreli nesneler içerir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-181">This generation contains long-lived objects.</span></span> <span data-ttu-id="ed7a4-182">Uzun süreli bir nesne örneği, işlem süresince canlı olan statik verileri içeren bir sunucu uygulamasındaki nesnedir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-182">An example of a long-lived object is an object in a server application that contains static data that is live for the duration of the process.</span></span>

<span data-ttu-id="ed7a4-183">Atık koleksiyonlar belirli nesiller üzerinde koşullar garanti olarak oluşur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-183">Garbage collections occur on specific generations as conditions warrant.</span></span> <span data-ttu-id="ed7a4-184">Oluşturma toplanması, bu kuşak ve tüm küçük nesiller içindeki nesnelerin toplanması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-184">Collecting a generation means collecting objects in that generation and all its younger generations.</span></span> <span data-ttu-id="ed7a4-185">2\. nesil atık toplama, tüm nesiller içindeki tüm nesneleri geri kazanır (yani, yönetilen yığındaki tüm nesneler) olduğu için tam çöp toplama olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-185">A generation 2 garbage collection is also known as a full garbage collection, because it reclaims all objects in all generations (that is, all objects in the managed heap).</span></span>

### <a name="survival-and-promotions"></a><span data-ttu-id="ed7a4-186">Acil ihtiyaç ve promosyonlar</span><span class="sxs-lookup"><span data-stu-id="ed7a4-186">Survival and promotions</span></span>

<span data-ttu-id="ed7a4-187">Atık toplamada geri kazanımayan nesneler, acil sanal öğeler olarak bilinir ve bir sonraki nesil olarak yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-187">Objects that are not reclaimed in a garbage collection are known as survivors, and are promoted to the next generation.</span></span> <span data-ttu-id="ed7a4-188">Nesil 0 atık toplamayı sürdüren nesneler 1. nesil olarak yükseltilir; 1. nesil atık toplamayı sürdüren nesneler 2. nesil olarak yükseltilir; ve 2. nesil bir atık toplamayı sürdüren nesneler 2. kuşak olarak kalır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-188">Objects that survive a generation 0 garbage collection are promoted to generation 1; objects that survive a generation 1 garbage collection are promoted to generation 2; and objects that survive a generation 2 garbage collection remain in generation 2.</span></span>

<span data-ttu-id="ed7a4-189">Çöp toplayıcı, bir kuşakma hızının yüksek olduğunu algıladığında, bu kuşak için ayırmaların eşiğini artırır, bu nedenle sonraki koleksiyon, geri kazanılan bellek miktarını önemli ölçüde alır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-189">When the garbage collector detects that the survival rate is high in a generation, it increases the threshold of allocations for that generation, so the next collection gets a substantial size of reclaimed memory.</span></span> <span data-ttu-id="ed7a4-190">CLR sürekli olarak iki öncelik dengeler: bir uygulamanın çalışma kümesinin çöp toplamayı erteleyerek çok büyük almasını ve çöp toplamanın çok sık çalışmasına izin vermez.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-190">The CLR continually balances two priorities: not letting an application's working set get too big by delaying garbage collection and not letting the garbage collection run too frequently.</span></span>

### <a name="ephemeral-generations-and-segments"></a><span data-ttu-id="ed7a4-191">Kısa ömürlü Nesler ve segmentler</span><span class="sxs-lookup"><span data-stu-id="ed7a4-191">Ephemeral generations and segments</span></span>

<span data-ttu-id="ed7a4-192">Nesil 0 ve 1 ' deki nesneler kısa süreli olduğundan, bu nesiller, kısa ömürlü nesiller olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-192">Because objects in generations 0 and 1 are short-lived, these generations are known as the ephemeral generations.</span></span>

<span data-ttu-id="ed7a4-193">Kısa ömürlü nesiller, kısa ömürlü segment olarak bilinen bellek segmentinde ayrılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-193">Ephemeral generations must be allocated in the memory segment that is known as the ephemeral segment.</span></span> <span data-ttu-id="ed7a4-194">Çöp toplayıcı tarafından alınan her yeni segment, yeni kısa ömürlü segment olur ve 0. nesil atık toplamayı izleyen nesneleri içerir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-194">Each new segment acquired by the garbage collector becomes the new ephemeral segment and contains the objects that survived a generation 0 garbage collection.</span></span> <span data-ttu-id="ed7a4-195">Eski kısa ömürlü segment, yeni nesil 2 segmentine dönüşür.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-195">The old ephemeral segment becomes the new generation 2 segment.</span></span>

<span data-ttu-id="ed7a4-196">Kısa ömürlü segmentin boyutu sistemin 32 veya 64 bit olmasına ve çalıştırdığı çöp toplayıcı türüne bağlı olarak farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-196">The size of the ephemeral segment varies depending on whether a system is 32- or 64-bit, and on the type of garbage collector it is running.</span></span> <span data-ttu-id="ed7a4-197">Varsayılan değerler aşağıdaki tabloda gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-197">Default values are shown in the following table.</span></span>

||<span data-ttu-id="ed7a4-198">32 bit:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-198">32-bit</span></span>|<span data-ttu-id="ed7a4-199">64 bit</span><span class="sxs-lookup"><span data-stu-id="ed7a4-199">64-bit</span></span>|
|-|-------------|-------------|
|<span data-ttu-id="ed7a4-200">İş istasyonu GC</span><span class="sxs-lookup"><span data-stu-id="ed7a4-200">Workstation GC</span></span>|<span data-ttu-id="ed7a4-201">16 MB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-201">16 MB</span></span>|<span data-ttu-id="ed7a4-202">256 MB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-202">256 MB</span></span>|
|<span data-ttu-id="ed7a4-203">Sunucu GC</span><span class="sxs-lookup"><span data-stu-id="ed7a4-203">Server GC</span></span>|<span data-ttu-id="ed7a4-204">64 MB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-204">64 MB</span></span>|<span data-ttu-id="ed7a4-205">4 GB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-205">4 GB</span></span>|
|<span data-ttu-id="ed7a4-206">> 4 mantıksal CPU içeren sunucu GC</span><span class="sxs-lookup"><span data-stu-id="ed7a4-206">Server GC with > 4 logical CPUs</span></span>|<span data-ttu-id="ed7a4-207">32 MB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-207">32 MB</span></span>|<span data-ttu-id="ed7a4-208">2 GB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-208">2 GB</span></span>|
|<span data-ttu-id="ed7a4-209">> 8 mantıksal CPU 'Lar ile sunucu GC</span><span class="sxs-lookup"><span data-stu-id="ed7a4-209">Server GC with > 8 logical CPUs</span></span>|<span data-ttu-id="ed7a4-210">16 MB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-210">16 MB</span></span>|<span data-ttu-id="ed7a4-211">1 GB</span><span class="sxs-lookup"><span data-stu-id="ed7a4-211">1 GB</span></span>|

<span data-ttu-id="ed7a4-212">Kısa ömürlü segment 2. nesil nesneleri içerebilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-212">The ephemeral segment can include generation 2 objects.</span></span> <span data-ttu-id="ed7a4-213">2\. nesil nesneler birden çok segment kullanabilir (işleminiz için gereken ve belleğin izin verdiği kadar).</span><span class="sxs-lookup"><span data-stu-id="ed7a4-213">Generation 2 objects can use multiple segments (as many as your process requires and memory allows for).</span></span>

<span data-ttu-id="ed7a4-214">Kısa ömürlü atık toplamanın serbest bırakılan bellek miktarı, kısa ömürlü segmentin boyutuyla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-214">The amount of freed memory from an ephemeral garbage collection is limited to the size of the ephemeral segment.</span></span> <span data-ttu-id="ed7a4-215">Serbest bırakılan bellek miktarı, ölü nesneler tarafından kullanılan alanla orantılıdır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-215">The amount of memory that is freed is proportional to the space that was occupied by the dead objects.</span></span>

[<span data-ttu-id="ed7a4-216">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-216">Back to top</span></span>](#top)

<a name="what_happens_during_a_garbage_collection"></a>

## <a name="what-happens-during-a-garbage-collection"></a><span data-ttu-id="ed7a4-217">Çöp toplama sırasında ne olur?</span><span class="sxs-lookup"><span data-stu-id="ed7a4-217">What happens during a garbage collection</span></span>

<span data-ttu-id="ed7a4-218">Bir çöp toplama işlemi aşağıdaki aşamaları içerir:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-218">A garbage collection has the following phases:</span></span>

- <span data-ttu-id="ed7a4-219">Tüm canlı nesnelerin listesini bulan ve oluşturan bir işaretleme aşaması.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-219">A marking phase that finds and creates a list of all live objects.</span></span>

- <span data-ttu-id="ed7a4-220">Düzenlenecek nesneler için başvuruları güncelleştiren bir değiştirme aşaması.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-220">A relocating phase that updates the references to the objects that will be compacted.</span></span>

- <span data-ttu-id="ed7a4-221">Yok sayılma nesnelerinin kapladığı alanı geri kazanır ve kalan nesneleri sıkıştırarak bir düzenleme aşaması.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-221">A compacting phase that reclaims the space occupied by the dead objects and compacts the surviving objects.</span></span> <span data-ttu-id="ed7a4-222">Sıkıştırma aşaması, bir atık toplamayı, segmentin eski ucuna doğru bir şekilde taşımış nesneleri hareket ettirir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-222">The compacting phase moves objects that have survived a garbage collection toward the older end of the segment.</span></span>

  <span data-ttu-id="ed7a4-223">2\. nesil koleksiyonlar birden çok parçayı kaplayabildiğinden, 2. nesil olarak yükseltilen nesneler eski bir kesime taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-223">Because generation 2 collections can occupy multiple segments, objects that are promoted into generation 2 can be moved into an older segment.</span></span> <span data-ttu-id="ed7a4-224">2\. nesil ve 2. nesil ve 2. nesil daha fazla VNet, 1. kuşak olarak yükseltildikleri için farklı bir kesime taşınabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-224">Both generation 1 and generation 2 survivors can be moved to a different segment, because they are promoted to generation 2.</span></span>

  <span data-ttu-id="ed7a4-225">Genellikle büyük nesne yığını düzenlenmez, çünkü büyük nesneleri kopyalamak bir performans cezası uygular.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-225">Ordinarily, the large object heap is not compacted, because copying large objects imposes a performance penalty.</span></span> <span data-ttu-id="ed7a4-226">Ancak, .NET Framework 4.5.1 ile başlayarak, büyük nesne yığınını isteğe bağlı olarak sıkıştırmak için <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> özelliğini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-226">However, starting with the .NET Framework 4.5.1, you can use the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to compact the large object heap on demand.</span></span>

<span data-ttu-id="ed7a4-227">Çöp toplayıcı, nesnelerin canlı olup olmadığını anlamak için aşağıdaki bilgileri kullanır:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-227">The garbage collector uses the following information to determine whether objects are live:</span></span>

- <span data-ttu-id="ed7a4-228">**Yığın kökleri**.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-228">**Stack roots**.</span></span> <span data-ttu-id="ed7a4-229">Tam zamanında (JıT) derleyici ve yığın denetçisi tarafından sunulan yığın değişkenleri.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-229">Stack variables provided by the just-in-time (JIT) compiler and stack walker.</span></span> <span data-ttu-id="ed7a4-230">JıT iyileştirmelerinin, yığın değişkenlerinin çöp toplayıcısına bildirildiği kod bölgelerini uzatabilir veya kısaltabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-230">Note that JIT optimizations can lengthen or shorten regions of code within which stack variables are reported to the garbage collector.</span></span>

- <span data-ttu-id="ed7a4-231">**Çöp toplama tutamaçları**.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-231">**Garbage collection handles**.</span></span> <span data-ttu-id="ed7a4-232">Yönetilen nesneleri işaret eden ve Kullanıcı kodu veya ortak dil çalışma zamanı tarafından ayrılabilen işler.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-232">Handles that point to managed objects and that can be allocated by user code or by the common language runtime.</span></span>

- <span data-ttu-id="ed7a4-233">**Statik veriler**.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-233">**Static data**.</span></span> <span data-ttu-id="ed7a4-234">Uygulama etki alanlarında diğer nesnelere başvurıbir statik nesneler.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-234">Static objects in application domains that could be referencing other objects.</span></span> <span data-ttu-id="ed7a4-235">Her uygulama etki alanı, kendi statik nesnelerini izler.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-235">Each application domain keeps track of its static objects.</span></span>

<span data-ttu-id="ed7a4-236">Çöp toplama başlamadan önce, çöp toplamayı tetikleyen iş parçacığı hariç tüm yönetilen iş parçacıkları askıya alınır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-236">Before a garbage collection starts, all managed threads are suspended except for the thread that triggered the garbage collection.</span></span>

<span data-ttu-id="ed7a4-237">Aşağıdaki çizimde, çöp toplamayı tetikleyen ve diğer iş parçacıklarının askıya alınmasına neden olan bir iş parçacığı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-237">The following illustration shows a thread that triggers a garbage collection and causes the other threads to be suspended.</span></span>

<span data-ttu-id="ed7a4-238">![Bir iş parçacığı bir çöp toplama işlemi tetiklerse](../../../docs/standard/garbage-collection/media/gc-triggered.png "Bir iş parçacığı bir çöp toplama işlemi tetiklerse")</span><span class="sxs-lookup"><span data-stu-id="ed7a4-238">![When a thread triggers a Garbage Collection](../../../docs/standard/garbage-collection/media/gc-triggered.png "When a thread triggers a Garbage Collection")</span></span>

[<span data-ttu-id="ed7a4-239">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-239">Back to top</span></span>](#top)

<a name="manipulating_unmanaged_resources"></a>

## <a name="manipulating-unmanaged-resources"></a><span data-ttu-id="ed7a4-240">Yönetilmeyen kaynakları düzenleme</span><span class="sxs-lookup"><span data-stu-id="ed7a4-240">Manipulating unmanaged resources</span></span>

<span data-ttu-id="ed7a4-241">Yönetilen nesneleriniz, kendi yerel dosya tutamaçlarını kullanarak yönetilmeyen nesnelere başvuru yaptığından, atık toplayıcı yalnızca yönetilen yığında belleği izlediğinden, yönetilmeyen nesneleri açık bir şekilde serbest yapmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-241">If your managed objects reference unmanaged objects by using their native file handles, you have to explicitly free the unmanaged objects, because the garbage collector tracks memory only on the managed heap.</span></span>

<span data-ttu-id="ed7a4-242">Yönetilen nesnenizin kullanıcıları, nesne tarafından kullanılan yerel kaynakları yok edebilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-242">Users of your managed object may not dispose the native resources used by the object.</span></span> <span data-ttu-id="ed7a4-243">Temizleme işlemini gerçekleştirmek için, yönetilen nesnenizin sonlandırılabilir olmasını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-243">To perform the cleanup, you can make your managed object finalizable.</span></span> <span data-ttu-id="ed7a4-244">Sonlandırma, nesne artık kullanımda olmadığında yürütmeniz gereken Temizleme eylemlerinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-244">Finalization consists of cleanup actions that you execute when the object is no longer in use.</span></span> <span data-ttu-id="ed7a4-245">Yönetilen nesneniz, sonlandırıcı yönteminde belirtilen temizleme eylemlerini gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-245">When your managed object dies, it performs cleanup actions that are specified in its finalizer method.</span></span>

<span data-ttu-id="ed7a4-246">Sonlandırılabilir bir nesnenin etkin olmadığı tespit edildiğinde, temizleme eylemlerinin yürütülmesi için Sonlandırıcı bir sıraya konur, ancak nesnenin kendisi bir sonraki oluşturmaya yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-246">When a finalizable object is discovered to be dead, its finalizer is put in a queue so that its cleanup actions are executed, but the object itself is promoted to the next generation.</span></span> <span data-ttu-id="ed7a4-247">Bu nedenle, nesnenin geri kazanılıp kazanılmadığını öğrenmek için bu kuşada gerçekleşen sonraki atık toplamaya (bir sonraki atık toplama olması gerekmez) kadar beklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-247">Therefore, you have to wait until the next garbage collection that occurs on that generation (which is not necessarily the next garbage collection) to determine whether the object has been reclaimed.</span></span>

[<span data-ttu-id="ed7a4-248">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-248">Back to top</span></span>](#top)

<a name="workstation_and_server_garbage_collection"></a>

## <a name="workstation-and-server-garbage-collection"></a><span data-ttu-id="ed7a4-249">İş istasyonu ve sunucu atık toplama</span><span class="sxs-lookup"><span data-stu-id="ed7a4-249">Workstation and server garbage collection</span></span>

<span data-ttu-id="ed7a4-250">Çöp toplayıcı kendi kendini ayarlamadır ve çok çeşitli senaryolarda çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-250">The garbage collector is self-tuning and can work in a wide variety of scenarios.</span></span> <span data-ttu-id="ed7a4-251">Bir yapılandırma dosyası ayarını, iş yükünün özelliklerine göre çöp toplamanın türünü ayarlamak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-251">You can use a configuration file setting to set the type of garbage collection based on the characteristics of the workload.</span></span> <span data-ttu-id="ed7a4-252">CLR aşağıdaki çöp toplama türlerini sağlar:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-252">The CLR provides the following types of garbage collection:</span></span>

- <span data-ttu-id="ed7a4-253">Tüm istemci iş istasyonları ve tek başına bilgisayarlar için olan iş istasyonu atık toplama.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-253">Workstation garbage collection, which is for all client workstations and stand-alone PCs.</span></span> <span data-ttu-id="ed7a4-254">Bu, çalışma zamanı yapılandırma şemasında [\<gcServer > öğesi](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) için varsayılan ayardır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-254">This is the default setting for the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) in the runtime configuration schema.</span></span>

  <span data-ttu-id="ed7a4-255">İş istasyonu atık toplama işlemi eşzamanlı olabilir veya eşzamanlı olmayan bir şekilde olabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-255">Workstation garbage collection can be concurrent or non-concurrent.</span></span> <span data-ttu-id="ed7a4-256">Eşzamanlı atık toplama, yönetilen iş parçacıklarının bir çöp toplama sırasında işlemlere devam etmesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-256">Concurrent garbage collection enables managed threads to continue operations during a garbage collection.</span></span>

  <span data-ttu-id="ed7a4-257">.NET Framework 4 ' ten başlayarak, arka plan atık toplama, eşzamanlı çöp toplama yerini alır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-257">Starting with the .NET Framework 4, background garbage collection replaces concurrent garbage collection.</span></span>

- <span data-ttu-id="ed7a4-258">Yüksek aktarım hızı ve ölçeklenebilirlik gerektiren sunucu uygulamalarına yönelik olan sunucu çöp toplama.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-258">Server garbage collection, which is intended for server applications that need high throughput and scalability.</span></span> <span data-ttu-id="ed7a4-259">Sunucu atık toplama, eş zamanlı olmayan veya arka plan olabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-259">Server garbage collection can be non-concurrent or background.</span></span>

<span data-ttu-id="ed7a4-260">Aşağıdaki çizimde, bir sunucusunda çöp toplamayı gerçekleştiren adanmış iş parçacıkları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-260">The following illustration shows the dedicated threads that perform the garbage collection on a server.</span></span>

<span data-ttu-id="ed7a4-261">![Sunucu atık toplama Iş parçacıkları](../../../docs/standard/garbage-collection/media/gc-server.png "Sunucu atık toplama Iş parçacıkları")</span><span class="sxs-lookup"><span data-stu-id="ed7a4-261">![Server Garbage Collection Threads](../../../docs/standard/garbage-collection/media/gc-server.png "Server Garbage Collection Threads")</span></span>

### <a name="configuring-garbage-collection"></a><span data-ttu-id="ed7a4-262">Çöp toplamayı yapılandırma</span><span class="sxs-lookup"><span data-stu-id="ed7a4-262">Configuring garbage collection</span></span>

<span data-ttu-id="ed7a4-263">CLR 'nin gerçekleştirmesini istediğiniz çöp toplamanın türünü belirtmek için çalışma zamanı yapılandırma şemasının [\<gcServer > öğesini](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-263">You can use the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) of the runtime configuration schema to specify the type of garbage collection you want the CLR to perform.</span></span> <span data-ttu-id="ed7a4-264">Bu öğenin `enabled` özniteliği `false` (varsayılan) olarak ayarlandığında, CLR iş istasyonu atık toplama işlemini gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-264">When this element's `enabled` attribute is set to `false` (the default), the CLR performs workstation garbage collection.</span></span> <span data-ttu-id="ed7a4-265">@No__t_0 özniteliğini `true` olarak belirlediğinizde, CLR sunucu çöp toplama işlemini gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-265">When you set the `enabled` attribute to `true`, the CLR performs server garbage collection.</span></span>

<span data-ttu-id="ed7a4-266">Eşzamanlı atık toplama, çalışma zamanı yapılandırma şemasının [\<gcConcurrent > öğesiyle](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) belirtildi.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-266">Concurrent garbage collection is specified with the [\<gcConcurrent> element](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) of the runtime configuration schema.</span></span> <span data-ttu-id="ed7a4-267">Varsayılan ayar `enabled` ' dır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-267">The default setting is `enabled`.</span></span> <span data-ttu-id="ed7a4-268">Bu ayar hem eşzamanlı hem de arka plan çöp toplamayı denetler.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-268">This setting controls both concurrent and background garbage collection.</span></span>

<span data-ttu-id="ed7a4-269">Ayrıca, yönetilmeyen barındırma arabirimleriyle sunucu çöp toplamayı belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-269">You can also specify server garbage collection with unmanaged hosting interfaces.</span></span> <span data-ttu-id="ed7a4-270">ASP.NET ve SQL Server, uygulamanız bu ortamların birinde barındırılıyorsa sunucu çöp toplamayı otomatik olarak etkinleştirdiğine unutmayın.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-270">Note that ASP.NET and SQL Server enable server garbage collection automatically if your application is hosted inside one of these environments.</span></span>

### <a name="comparing-workstation-and-server-garbage-collection"></a><span data-ttu-id="ed7a4-271">İş istasyonu ve sunucu çöp toplamayı karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="ed7a4-271">Comparing workstation and server garbage collection</span></span>

<span data-ttu-id="ed7a4-272">İş istasyonu çöp toplama işlemi için iş parçacığı ve performans değerlendirmeleri aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-272">The following are threading and performance considerations for workstation garbage collection:</span></span>

- <span data-ttu-id="ed7a4-273">Koleksiyon, çöp toplamayı tetikleyen ve aynı önceliğe kalan Kullanıcı iş parçacığında oluşur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-273">The collection occurs on the user thread that triggered the garbage collection and remains at the same priority.</span></span> <span data-ttu-id="ed7a4-274">Kullanıcı iş parçacıkları genellikle normal öncelikte çalıştığı için çöp toplayıcı (normal bir öncelikli iş parçacığı üzerinde çalışır), CPU süresi için diğer iş parçacıklarıyla rekabet etmelidir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-274">Because user threads typically run at normal priority, the garbage collector (which runs on a normal priority thread) must compete with other threads for CPU time.</span></span>

  <span data-ttu-id="ed7a4-275">Yerel kod çalıştıran iş parçacıkları askıya alınmaz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-275">Threads that are running native code are not suspended.</span></span>

- <span data-ttu-id="ed7a4-276">İş istasyonu çöp toplama, [\<gcServer >](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) ayarından bağımsız olarak yalnızca bir işlemciye sahip olan bir bilgisayarda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-276">Workstation garbage collection is always used on a computer that has only one processor, regardless of the [\<gcServer>](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) setting.</span></span> <span data-ttu-id="ed7a4-277">Sunucu çöp toplamayı belirtirseniz, CLR eşzamanlılık devre dışı olan iş istasyonu çöp toplamayı kullanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-277">If you specify server garbage collection, the CLR uses workstation garbage collection with concurrency disabled.</span></span>

<span data-ttu-id="ed7a4-278">Aşağıda sunucu çöp toplama için iş parçacığı ve performans konuları verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-278">The following are threading and performance considerations for server garbage collection:</span></span>

- <span data-ttu-id="ed7a4-279">Koleksiyon `THREAD_PRIORITY_HIGHEST` öncelik düzeyinde çalışan birden fazla adanmış iş parçacığında oluşur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-279">The collection occurs on multiple dedicated threads that are running at `THREAD_PRIORITY_HIGHEST` priority level.</span></span>

- <span data-ttu-id="ed7a4-280">Her CPU için bir yığın ve bir ayrılmış iş parçacığı her CPU için sağlanır ve sayfa@@ 'ler aynı anda toplanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-280">A heap and a dedicated thread to perform garbage collection are provided for each CPU, and the heaps are collected at the same time.</span></span> <span data-ttu-id="ed7a4-281">Her yığın küçük bir nesne yığını ve büyük bir nesne yığını içerir ve tüm yığınlara Kullanıcı kodu tarafından erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-281">Each heap contains a small object heap and a large object heap, and all heaps can be accessed by user code.</span></span> <span data-ttu-id="ed7a4-282">Farklı yığınlardaki nesneler birbirlerine başvurabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-282">Objects on different heaps can refer to each other.</span></span>

- <span data-ttu-id="ed7a4-283">Birden çok çöp toplama iş parçacığı birlikte çalıştığından, sunucu çöp toplama, aynı boyuttaki yığında iş istasyonu atık toplamadan daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-283">Because multiple garbage collection threads work together, server garbage collection is faster than workstation garbage collection on the same size heap.</span></span>

- <span data-ttu-id="ed7a4-284">Sunucu çöp toplama genellikle daha büyük boyut segmentlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-284">Server garbage collection often has larger size segments.</span></span> <span data-ttu-id="ed7a4-285">Bununla birlikte, bunun yalnızca bir Genelleştirme olduğunu unutmayın: segment boyutu uygulamaya özgüdür ve değişikliğe tabidir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-285">Note, however, that this is only a generalization: segment size is implementation-specific and is subject to change.</span></span> <span data-ttu-id="ed7a4-286">Uygulamanızı ayarlamaya yönelik çöp toplayıcı tarafından ayrılan segmentlerin boyutu hakkında bir varsayımın olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-286">You should make no assumptions about the size of segments allocated by the garbage collector when tuning your app.</span></span>

- <span data-ttu-id="ed7a4-287">Sunucu atık toplama, kaynak kullanımı yoğun olabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-287">Server garbage collection can be resource-intensive.</span></span> <span data-ttu-id="ed7a4-288">Örneğin, 4 işlemcili bir bilgisayarda çalışan 12 işlem varsa, sunucu çöp toplama işlemi kullanılıyorsa 48 adanmış çöp toplama iş parçacığı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-288">For example, if you have 12 processes running on a computer that has 4 processors, there will be 48 dedicated garbage collection threads if they are all using server garbage collection.</span></span> <span data-ttu-id="ed7a4-289">Yüksek bellek yükleme durumunda, tüm süreçler çöp toplama işlemini başlatırsanız, çöp toplayıcının zamanlamaya göre 48 iş parçacığı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-289">In a high memory load situation, if all the processes start doing garbage collection, the garbage collector will have 48 threads to schedule.</span></span>

<span data-ttu-id="ed7a4-290">Bir uygulamanın yüzlerce örneğini çalıştırıyorsanız, eşzamanlı atık toplama devre dışı bırakılmış iş istasyonu çöp toplamayı kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-290">If you are running hundreds of instances of an application, consider using workstation garbage collection with concurrent garbage collection disabled.</span></span> <span data-ttu-id="ed7a4-291">Bu, performansı iyileştirebilen daha az bağlam geçişe neden olur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-291">This will result in less context switching, which can improve performance.</span></span>

[<span data-ttu-id="ed7a4-292">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-292">Back to top</span></span>](#top)

<a name="concurrent_garbage_collection"></a>

## <a name="concurrent-garbage-collection"></a><span data-ttu-id="ed7a4-293">Eşzamanlı atık toplama</span><span class="sxs-lookup"><span data-stu-id="ed7a4-293">Concurrent garbage collection</span></span>

<span data-ttu-id="ed7a4-294">İş istasyonu veya sunucu çöp toplama bölümünde, iş parçacıklarının, koleksiyon süresince büyük bir süre için çöp toplamayı gerçekleştiren adanmış bir iş parçacığıyla eşzamanlı olarak çalışmasını sağlayan eşzamanlı atık toplamayı etkinleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-294">In workstation or server garbage collection, you can enable concurrent garbage collection, which enables threads to run concurrently with a dedicated thread that performs the garbage collection for most of the duration of the collection.</span></span> <span data-ttu-id="ed7a4-295">Bu seçenek, kuşak 2 ' de yalnızca çöp koleksiyonlarını etkiler; nesil 0 ve 1 her zaman eşzamanlı değildir çünkü çok hızlı tamamlanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-295">This option affects only garbage collections in generation 2; generations 0 and 1 are always non-concurrent because they finish very fast.</span></span>

<span data-ttu-id="ed7a4-296">Eşzamanlı atık toplama, bir koleksiyon için duraklamaları en aza indirerek etkileşimli uygulamaların daha fazla yanıt vermesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-296">Concurrent garbage collection enables interactive applications to be more responsive by minimizing pauses for a collection.</span></span> <span data-ttu-id="ed7a4-297">Yönetilen iş parçacıkları, eşzamanlı atık toplama iş parçacığı çalışırken çoğu zaman çalışmaya devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-297">Managed threads can continue to run most of the time while the concurrent garbage collection thread is running.</span></span> <span data-ttu-id="ed7a4-298">Çöp toplama işlemi gerçekleşirken bu, daha kısa duraklamalar oluşur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-298">This results in shorter pauses while a garbage collection is occurring.</span></span>

<span data-ttu-id="ed7a4-299">Birkaç işlem çalışırken performansı artırmak için, eşzamanlı atık toplamayı devre dışı bırakın.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-299">To improve performance when several processes are running, disable concurrent garbage collection.</span></span> <span data-ttu-id="ed7a4-300">Bunu, uygulamanın yapılandırma dosyasına bir [\<gcConcurrent > öğesi](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) ekleyerek ve `enabled` özniteliğinin değerini `"false"` olarak ayarlayarak yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-300">You can do this by adding a [\<gcConcurrent> element](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) to the app's configuration file and setting the value of its `enabled` attribute to `"false"`.</span></span>

<span data-ttu-id="ed7a4-301">Eş zamanlı çöp toplama, adanmış bir iş parçacığında gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-301">Concurrent garbage collection is performed on a dedicated thread.</span></span> <span data-ttu-id="ed7a4-302">Varsayılan olarak, CLR, eşzamanlı atık toplama özellikli iş istasyonu çöp toplamayı çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-302">By default, the CLR runs workstation garbage collection with concurrent garbage collection enabled.</span></span> <span data-ttu-id="ed7a4-303">Bu, tek işlemci ve çok işlemcili bilgisayarlar için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-303">This is true for single-processor and multi-processor computers.</span></span>

<span data-ttu-id="ed7a4-304">Eşzamanlı atık toplama sırasında yığın üzerinde küçük nesneler ayırma olanağınız, eşzamanlı bir atık toplama başladığında kısa ömürlü kesimde kalan nesnelerle sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-304">Your ability to allocate small objects on the heap during a concurrent garbage collection is limited by the objects left on the ephemeral segment when a concurrent garbage collection starts.</span></span> <span data-ttu-id="ed7a4-305">Segmentin sonuna ulaştığınızda, küçük nesne ayırmaları yapmak için gereken yönetilen iş parçacıkları askıya alındığında eşzamanlı çöp toplama işleminin bitmesini beklemeniz gerekecektir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-305">As soon as you reach the end of the segment, you will have to wait for the concurrent garbage collection to finish while managed threads that have to make small object allocations are suspended.</span></span>

<span data-ttu-id="ed7a4-306">Eşzamanlı atık toplama işlemi, eşzamanlı toplama sırasında nesneleri ayırabilmeniz için biraz daha büyük bir çalışma kümesine (eşzamanlı olmayan Çöp toplamakla karşılaştırıldığında) sahiptir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-306">Concurrent garbage collection has a slightly bigger working set (compared with non-concurrent garbage collection), because you can allocate objects during concurrent collection.</span></span> <span data-ttu-id="ed7a4-307">Ancak, ayırdığı nesneler çalışma kümesinin bir parçası haline geldiği için bu, performansı etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-307">However, this can affect performance, because the objects that you allocate become part of your working set.</span></span> <span data-ttu-id="ed7a4-308">Temelde, eşzamanlı atık toplama, daha kısa duraklamalar için bazı CPU ve bellek ile ilgili bir süre</span><span class="sxs-lookup"><span data-stu-id="ed7a4-308">Essentially, concurrent garbage collection trades some CPU and memory for shorter pauses.</span></span>

<span data-ttu-id="ed7a4-309">Aşağıdaki çizimde ayrı bir adanmış iş parçacığında gerçekleştirilen eşzamanlı çöp toplama gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-309">The following illustration shows concurrent garbage collection performed on a separate dedicated thread.</span></span>

<span data-ttu-id="ed7a4-310">![Eşzamanlı atık toplama Iş parçacıkları](../../../docs/standard/garbage-collection/media/gc-concurrent.png "Eşzamanlı atık toplama Iş parçacıkları")</span><span class="sxs-lookup"><span data-stu-id="ed7a4-310">![Concurrent Garbage Collection Threads](../../../docs/standard/garbage-collection/media/gc-concurrent.png "Concurrent Garbage Collection Threads")</span></span>

[<span data-ttu-id="ed7a4-311">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-311">Back to top</span></span>](#top)

<a name="background_garbage_collection"></a>

## <a name="background-workstation-garbage-collection"></a><span data-ttu-id="ed7a4-312">Arka plan iş istasyonu çöp toplama</span><span class="sxs-lookup"><span data-stu-id="ed7a4-312">Background workstation garbage collection</span></span>

<span data-ttu-id="ed7a4-313">Arka plan atık toplama, .NET Framework 4 ile başlayarak eşzamanlı iş istasyonu çöp toplama yerini alır ve .NET Framework 4,5 ile başlayan eşzamanlı sunucu çöp toplama yerini alır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-313">Background garbage collection replaces concurrent workstation garbage collection starting with the .NET Framework 4, and it replaces concurrent server garbage collection starting with the .NET Framework 4.5.</span></span>  <span data-ttu-id="ed7a4-314">Arka plan atık toplamada, 2. nesil toplama işlemi devam ederken, kısa ömürlü nesiller (0 ve 1) gerektiği şekilde toplanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-314">In background garbage collection, ephemeral generations (0 and 1) are collected as needed while the collection of generation 2 is in progress.</span></span> <span data-ttu-id="ed7a4-315">Özel bir iş parçacığında gerçekleştirilir ve yalnızca 2. nesil koleksiyonlar için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-315">It is performed on a dedicated thread and is applicable only to generation 2 collections.</span></span> <span data-ttu-id="ed7a4-316">Arka plan atık toplama otomatik olarak varsayılan olarak etkindir ve .NET Framework uygulamalarında [\<gcConcurrent >](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) yapılandırma ayarıyla etkinleştirilebilir veya devre dışı bırakılabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-316">Background garbage collection is automatically enabled by default, and can be enabled or disabled with the [\<gcConcurrent>](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) configuration setting in .NET Framework applications.</span></span> 

> [!NOTE]
> <span data-ttu-id="ed7a4-317">Arka plan atık toplama yalnızca .NET Framework 4 ve üzeri sürümlerde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-317">Background garbage collection is available only in the .NET Framework 4 and later versions.</span></span> <span data-ttu-id="ed7a4-318">.NET Framework 4 ' te yalnızca iş istasyonu çöp toplama için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-318">In the .NET Framework 4, it is supported only for workstation garbage collection.</span></span> <span data-ttu-id="ed7a4-319">.NET Framework 4,5 ' den başlayarak, arka plan atık toplama hem iş istasyonu hem de sunucu çöp toplama için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-319">Starting with the .NET Framework 4.5, background garbage collection is available for both workstation and server garbage collection.</span></span>

<span data-ttu-id="ed7a4-320">Arka plan atık toplama sırasında kısa ömürlü oluşumlara yönelik bir koleksiyon, ön plan atık toplama olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-320">A collection on ephemeral generations during background garbage collection is known as foreground garbage collection.</span></span> <span data-ttu-id="ed7a4-321">Ön plan atık koleksiyonları gerçekleştiğinde, tüm yönetilen iş parçacıkları askıya alınır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-321">When foreground garbage collections occur, all managed threads are suspended.</span></span>

<span data-ttu-id="ed7a4-322">Arka plan atık toplama işlemi devam ederken ve nesil 0 ' da yeterli nesne ayırdığınızda CLR, 1. nesil bir ön plan atık toplama işlemi gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-322">When background garbage collection is in progress and you have allocated enough objects in generation 0, the CLR performs a generation 0 or generation 1 foreground garbage collection.</span></span> <span data-ttu-id="ed7a4-323">Adanmış arka plan atık toplama iş parçacığı, ön plan atık toplama için bir istek olup olmadığını anlamak için sık kullanılan güvenli noktaları denetler.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-323">The dedicated background garbage collection thread checks at frequent safe points to determine whether there is a request for foreground garbage collection.</span></span> <span data-ttu-id="ed7a4-324">Varsa, ön plan atık toplama işleminin gerçekleşmesi için arka plan koleksiyonu kendisini askıya alır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-324">If there is, the background collection suspends itself so that foreground garbage collection can occur.</span></span> <span data-ttu-id="ed7a4-325">Ön plan atık toplama işlemi tamamlandıktan sonra, adanmış arka plan atık toplama iş parçacığı ve Kullanıcı iş parçacıkları sürdürülür.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-325">After the foreground garbage collection is completed, the dedicated background garbage collection thread and user threads resume.</span></span>

<span data-ttu-id="ed7a4-326">Arka plan atık toplama sırasında kısa ömürlü çöp koleksiyonları gerçekleşebildiğinden arka plan atık toplama, eşzamanlı atık toplama tarafından uygulanan ayırma kısıtlamalarını ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-326">Background garbage collection removes allocation restrictions imposed by concurrent garbage collection, because ephemeral garbage collections can occur during background garbage collection.</span></span> <span data-ttu-id="ed7a4-327">Bu, arka plan atık toplamanın kısa ömürlü nesillerdeki ölü nesneleri kaldırabileceği ve 1. nesil atık toplama sırasında gerekirse yığını genişletebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-327">This means that background garbage collection can remove dead objects in ephemeral generations and can also expand the heap if needed during a generation 1 garbage collection.</span></span>

<span data-ttu-id="ed7a4-328">Aşağıdaki çizimde, bir iş istasyonunda ayrı bir adanmış iş parçacığında gerçekleştirilen arka plan atık toplama işlemi gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-328">The following illustration shows background garbage collection performed on a separate dedicated thread on a workstation:</span></span>

<span data-ttu-id="ed7a4-329">![Arka plan iş istasyonu çöp toplamayı gösteren diyagram.](./media/fundamentals/background-workstation-garbage-collection.png "Arka plan iş istasyonu çöp toplamayı gösteren diyagram.")</span><span class="sxs-lookup"><span data-stu-id="ed7a4-329">![Diagram that shows background workstation garbage collection.](./media/fundamentals/background-workstation-garbage-collection.png "Diagram that shows background workstation garbage collection.")</span></span>

[<span data-ttu-id="ed7a4-330">Başa dön</span><span class="sxs-lookup"><span data-stu-id="ed7a4-330">Back to top</span></span>](#top)

<a name="background_server_garbage_collection"></a>

## <a name="background-server-garbage-collection"></a><span data-ttu-id="ed7a4-331">Arka plan sunucusu çöp toplama</span><span class="sxs-lookup"><span data-stu-id="ed7a4-331">Background server garbage collection</span></span>

<span data-ttu-id="ed7a4-332">.NET Framework 4,5 ile başlayarak, arka plan sunucusu çöp toplama sunucu çöp toplama için varsayılan moddur.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-332">Starting with the .NET Framework 4.5, background server garbage collection is the default mode for server garbage collection.</span></span> <span data-ttu-id="ed7a4-333">Bu modu seçmek için, [\<gcServer > öğesinin](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) `enabled` özniteliğini çalışma zamanı yapılandırma şemasında `true` olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-333">To choose this mode, set the `enabled` attribute of the [\<gcServer> element](../../../docs/framework/configure-apps/file-schema/runtime/gcserver-element.md) to `true` in the runtime configuration schema.</span></span> <span data-ttu-id="ed7a4-334">Bu mod, önceki bölümde açıklanan arka plan iş istasyonu çöp toplamasına benzer şekilde çalışır, ancak birkaç farklılık vardır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-334">This mode functions similarly to background workstation garbage collection, described in the previous section, but there are a few differences.</span></span> <span data-ttu-id="ed7a4-335">Arka plan iş istasyonu çöp toplama, bir adanmış arka plan atık toplama iş parçacığı kullanır, ancak arka plan sunucusu çöp toplama, genellikle her mantıksal işlemci için ayrılmış bir iş parçacığı kullanır.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-335">Background workstation garbage collection uses one dedicated background garbage collection thread, whereas background server garbage collection uses multiple threads, typically a dedicated thread for each logical processor.</span></span> <span data-ttu-id="ed7a4-336">İş istasyonu arka plan atık toplama iş parçacığından farklı olarak, bu iş parçacıkları zaman aşımına uğrar.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-336">Unlike the workstation background garbage collection thread, these threads do not time out.</span></span>

<span data-ttu-id="ed7a4-337">Aşağıdaki çizimde, bir sunucudaki ayrı bir adanmış iş parçacığında gerçekleştirilen arka plan atık toplama işlemi gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="ed7a4-337">The following illustration shows background garbage collection performed on a separate dedicated thread on a server:</span></span>

<span data-ttu-id="ed7a4-338">![Arka plan sunucusu çöp toplamayı gösteren diyagram.](./media/fundamentals/background-server-garbage-collection.png "Arka plan sunucusu çöp toplamayı gösteren diyagram.")</span><span class="sxs-lookup"><span data-stu-id="ed7a4-338">![Diagram that shows background server garbage collection.](./media/fundamentals/background-server-garbage-collection.png "Diagram that shows background server garbage collection.")</span></span>

## <a name="see-also"></a><span data-ttu-id="ed7a4-339">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="ed7a4-339">See also</span></span>

- [<span data-ttu-id="ed7a4-340">Atık Toplama</span><span class="sxs-lookup"><span data-stu-id="ed7a4-340">Garbage Collection</span></span>](../../../docs/standard/garbage-collection/index.md)
