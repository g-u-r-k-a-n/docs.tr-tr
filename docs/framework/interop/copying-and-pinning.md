---
title: Kopyalama ve Sabitleme
description: Birlikte çalışma sıralayıcısı 'nın sıralanmış verileri nasıl kopyalayabilir veya sabitleyebilir olduğunu gözden geçirin. Verilerin kopyalanması, verilerin bir kopyasını bir bellek konumundan başka bir konuma koyar.
ms.date: 03/30/2017
helpviewer_keywords:
- pinning, interop marshaling
- copying, interop marshaling
- interop marshaling, copying
- interop marshaling, pinning
ms.assetid: 0059f576-e460-4e70-b257-668870e420b8
ms.openlocfilehash: b7931813cd5254375eda81515f388c85c78fa284
ms.sourcegitcommit: e02d17b2cf9c1258dadda4810a5e6072a0089aee
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/01/2020
ms.locfileid: "85618785"
---
# <a name="copying-and-pinning"></a><span data-ttu-id="516bb-104">Kopyalama ve Sabitleme</span><span class="sxs-lookup"><span data-stu-id="516bb-104">Copying and Pinning</span></span>

<span data-ttu-id="516bb-105">Verileri sıralama sırasında birlikte çalışma sıralayıcısı, sıralanan verileri kopyalayabilir veya sabitleyebilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-105">When marshaling data, the interop marshaler can copy or pin the data being marshaled.</span></span> <span data-ttu-id="516bb-106">Verilerin kopyalanması, verilerin bir kopyasını başka bir bellek konumundaki bir bellek konumundan bir konuma koyar.</span><span class="sxs-lookup"><span data-stu-id="516bb-106">Copying the data places a copy of data from one memory location in another memory location.</span></span> <span data-ttu-id="516bb-107">Aşağıdaki çizimde, bir değer türü kopyalama ve bir başvuruya göre geçirilen bir tür ile yönetilmeyen belleğe kopyalama arasındaki farklar gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="516bb-107">The following illustration shows the differences between copying a value type and copying a type passed by reference from managed to unmanaged memory.</span></span>

![Değer ve başvuru türlerinin nasıl kopyalanacağını gösteren diyagram.](./media/copying-and-pinning/interop-marshal-copy.gif)

<span data-ttu-id="516bb-109">Değer tarafından geçirilen yöntem bağımsız değişkenleri, yığın üzerinde değer olarak yönetilmeyen koda sıralanır.</span><span class="sxs-lookup"><span data-stu-id="516bb-109">Method arguments passed by value are marshaled to unmanaged code as values on the stack.</span></span> <span data-ttu-id="516bb-110">Kopyalama işlemi doğrudan olur.</span><span class="sxs-lookup"><span data-stu-id="516bb-110">The copying process is direct.</span></span> <span data-ttu-id="516bb-111">Başvuruya göre geçirilen bağımsız değişkenler yığına işaretçiler olarak geçirilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-111">Arguments passed by reference are passed as pointers on the stack.</span></span> <span data-ttu-id="516bb-112">Başvuru türleri de değere ve başvuruya göre geçirilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-112">Reference types are also passed by value and by reference.</span></span> <span data-ttu-id="516bb-113">Aşağıdaki çizimde gösterildiği gibi, değer tarafından geçirilen başvuru türleri kopyalanır veya sabitlenir:</span><span class="sxs-lookup"><span data-stu-id="516bb-113">As the following illustration shows, reference types passed by value are either copied or pinned:</span></span>

![Değere ve başvuruya göre geçirilen başvuru türlerini gösteren diyagram.](./media/copying-and-pinning/interop-marshal-reference-pin.gif)

<span data-ttu-id="516bb-115">Veri sabitleme, verileri geçerli bellek konumunda geçici olarak kilitler ve bu sayede ortak dil çalışma zamanının çöp toplayıcısının yeniden konumlandırılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="516bb-115">Pinning temporarily locks the data in its current memory location, thus keeping it from being relocated by the common language runtime's garbage collector.</span></span> <span data-ttu-id="516bb-116">Sıralayıcı, performansı kopyalama ve geliştirme yükünü azaltmak için verileri sabitler.</span><span class="sxs-lookup"><span data-stu-id="516bb-116">The marshaler pins data to reduce the overhead of copying and enhance performance.</span></span> <span data-ttu-id="516bb-117">Verilerin türü, sıralama işlemi sırasında kopyalanıp kopyalanmadığını veya sabitlenmeyeceğini belirler.</span><span class="sxs-lookup"><span data-stu-id="516bb-117">The type of the data determines whether it is copied or pinned during the marshaling process.</span></span>  <span data-ttu-id="516bb-118">Sabitleme, gibi nesneler için sıralama sırasında otomatik olarak gerçekleştirilir <xref:System.String> , ancak sınıfı kullanarak belleği el ile sabitleyebilirsiniz <xref:System.Runtime.InteropServices.GCHandle> .</span><span class="sxs-lookup"><span data-stu-id="516bb-118">Pinning is automatically performed during marshaling for objects such as <xref:System.String>, however you can also manually pin memory using the <xref:System.Runtime.InteropServices.GCHandle> class.</span></span>

## <a name="formatted-blittable-classes"></a><span data-ttu-id="516bb-119">Biçimlendirilen blittable sınıfları</span><span class="sxs-lookup"><span data-stu-id="516bb-119">Formatted Blittable Classes</span></span>

<span data-ttu-id="516bb-120">Biçimlendirilen [blittable](blittable-and-non-blittable-types.md) sınıflarının hem yönetilen hem de yönetilmeyen bellekte sabit düzeni (biçimli) ve ortak veri temsili vardır.</span><span class="sxs-lookup"><span data-stu-id="516bb-120">Formatted [blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) and common data representation in both managed and unmanaged memory.</span></span> <span data-ttu-id="516bb-121">Bu türler sıralama gerektirdiğinde, yığında nesne işaretçisi doğrudan çağrıa geçirilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-121">When these types require marshaling, a pointer to the object in the heap is passed to the callee directly.</span></span> <span data-ttu-id="516bb-122">Aranan, işaretçinin başvurduğu bellek konumunun içeriğini değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-122">The callee can change the contents of the memory location being referenced by the pointer.</span></span>

> [!NOTE]
> <span data-ttu-id="516bb-123">Parametre dışarı veya dışarı işaretlenmişse, çağrılan bellek içeriğini değiştirebilir. Buna karşılık, parametresi ' de olarak sıralama olarak ayarlandığında, aranan blittable türleri için varsayılan değer olan, aranan içeriği değiştirmekten kaçınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="516bb-123">The callee can change the memory contents if the parameter is marked Out or In/Out. In contrast, the callee should avoid changing the contents when the parameter is set to marshal as In, which is the default for formatted blittable types.</span></span> <span data-ttu-id="516bb-124">Bir ın nesnesini değiştirmek, aynı sınıf bir tür kitaplığına aktarıldığında ve çapraz grup çağrıları yapmak için kullanıldığında sorunlar oluşturur.</span><span class="sxs-lookup"><span data-stu-id="516bb-124">Modifying an In object generates problems when the same class is exported to a type library and used to make cross-apartment calls.</span></span>

## <a name="formatted-non-blittable-classes"></a><span data-ttu-id="516bb-125">Blittable olmayan sınıflar biçimlendirildi</span><span class="sxs-lookup"><span data-stu-id="516bb-125">Formatted Non-Blittable Classes</span></span>

<span data-ttu-id="516bb-126">Biçimlendirilen [non-blittable](blittable-and-non-blittable-types.md) sınıfları sabit düzene sahip (biçimlendirildi), ancak veri gösterimi yönetilen ve yönetilmeyen bellekte farklıdır.</span><span class="sxs-lookup"><span data-stu-id="516bb-126">Formatted [non-blittable](blittable-and-non-blittable-types.md) classes have fixed layout (formatted) but the data representation is different in managed and unmanaged memory.</span></span> <span data-ttu-id="516bb-127">Veriler aşağıdaki koşullarda Dönüşüm gerektirebilir:</span><span class="sxs-lookup"><span data-stu-id="516bb-127">The data can require transformation under the following conditions:</span></span>

- <span data-ttu-id="516bb-128">Blittable olmayan bir sınıf değere göre sıralandıysanız, çağrılan, veri yapısının bir kopyasına bir işaretçi alır.</span><span class="sxs-lookup"><span data-stu-id="516bb-128">If a non-blittable class is marshaled by value, the callee receives a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="516bb-129">Blittable olmayan bir sınıf başvuruya göre sıralandıysanız, çağrılan, veri yapısının bir kopyasına yönelik bir işaretçi alır.</span><span class="sxs-lookup"><span data-stu-id="516bb-129">If a non-blittable class is marshaled by reference, the callee receives a pointer to a pointer to a copy of the data structure.</span></span>

- <span data-ttu-id="516bb-130"><xref:System.Runtime.InteropServices.InAttribute>Özniteliği ayarlandıysa, bu kopya her zaman örneğin durumuyla başlatılır ve gerektiğinde sıralama yapılır.</span><span class="sxs-lookup"><span data-stu-id="516bb-130">If the <xref:System.Runtime.InteropServices.InAttribute> attribute is set, this copy is always initialized with the instance's state, marshaling as necessary.</span></span>

- <span data-ttu-id="516bb-131"><xref:System.Runtime.InteropServices.OutAttribute>Öznitelik ayarlandıysa, durum her zaman dönüş sırasında örneğe kopyalanır ve gerektiğinde sıralama yapılır.</span><span class="sxs-lookup"><span data-stu-id="516bb-131">If the <xref:System.Runtime.InteropServices.OutAttribute> attribute is set, the state is always copied back to the instance on return, marshaling as necessary.</span></span>

- <span data-ttu-id="516bb-132">**InAttribute** ve **OutAttribute** öğelerinin her ikisi de ayarlanırsa, her iki kopya de gereklidir.</span><span class="sxs-lookup"><span data-stu-id="516bb-132">If both **InAttribute** and **OutAttribute** are set, both copies are required.</span></span> <span data-ttu-id="516bb-133">Her iki öznitelik de atlanırsa Sıralayıcı, kopyayı ortadan kaldırarak iyileştirebilirler.</span><span class="sxs-lookup"><span data-stu-id="516bb-133">If either attribute is omitted, the marshaler can optimize by eliminating either copy.</span></span>

## <a name="reference-types"></a><span data-ttu-id="516bb-134">Başvuru Türleri</span><span class="sxs-lookup"><span data-stu-id="516bb-134">Reference Types</span></span>

<span data-ttu-id="516bb-135">Başvuru türleri, değere veya başvuruya göre geçirilebilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-135">Reference types can be passed by value or by reference.</span></span> <span data-ttu-id="516bb-136">Değer ile geçirildiğinde, yığına tür işaretçisi geçirilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-136">When they are passed by value, a pointer to the type is passed on the stack.</span></span> <span data-ttu-id="516bb-137">Başvuruya göre geçirildiğinde, tür işaretçisine bir işaretçi yığına geçirilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-137">When passed by reference, a pointer to a pointer to the type is passed on the stack.</span></span>

<span data-ttu-id="516bb-138">Başvuru türleri aşağıdaki koşullu davranışa sahiptir:</span><span class="sxs-lookup"><span data-stu-id="516bb-138">Reference types have the following conditional behavior:</span></span>

- <span data-ttu-id="516bb-139">Bir başvuru türü değere göre geçirilir ve blittable olmayan türlerde üyelere sahipse türler iki kez dönüştürülür:</span><span class="sxs-lookup"><span data-stu-id="516bb-139">If a reference type is passed by value and it has members of non-blittable types, the types are converted twice:</span></span>

  - <span data-ttu-id="516bb-140">Yönetilmeyen tarafa bir bağımsız değişken geçirildiğinde.</span><span class="sxs-lookup"><span data-stu-id="516bb-140">When an argument is passed to the unmanaged side.</span></span>

  - <span data-ttu-id="516bb-141">Çağrıdan geri dönün.</span><span class="sxs-lookup"><span data-stu-id="516bb-141">On return from the call.</span></span>

  <span data-ttu-id="516bb-142">Gereksiz kopyalama ve dönüştürmeyi önlemek için bu türler parametrelerde olduğu gibi sıralanır.</span><span class="sxs-lookup"><span data-stu-id="516bb-142">To avoid unnecessarily copying and conversion, these types are marshaled as In parameters.</span></span> <span data-ttu-id="516bb-143">Çağıran tarafından yapılan değişiklikleri görmek için bir bağımsız değişkene **InAttribute** ve **OutAttribute** özniteliklerini açıkça uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="516bb-143">You must explicitly apply the **InAttribute** and **OutAttribute** attributes to an argument for the caller to see changes made by the callee.</span></span>

- <span data-ttu-id="516bb-144">Bir başvuru türü değere göre geçirilmişse ve yalnızca blittable türlerin üyeleri içeriyorsa, sıralama sırasında sabitlenebilir ve aranan tarafından tür üyelerinde yapılan değişiklikler arayan tarafından görülür.</span><span class="sxs-lookup"><span data-stu-id="516bb-144">If a reference type is passed by value and it has only members of blittable types, it can be pinned during marshaling and any changes made to the members of the type by the callee are seen by the caller.</span></span> <span data-ttu-id="516bb-145">Bu davranışı isterseniz **InAttribute** ve **OutAttribute** 'ı açık bir şekilde uygulayın.</span><span class="sxs-lookup"><span data-stu-id="516bb-145">Apply **InAttribute** and **OutAttribute** explicitly if you want this behavior.</span></span> <span data-ttu-id="516bb-146">Bu yönlü öznitelikler olmadan, birlikte çalışma sıralayıcısı yönlü bilgileri tür kitaplığına dışa aktarmaz (varsayılan olan ' de olarak dışa aktarır) ve bu, COM çapraz grup sıralaması ile ilgili sorunlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-146">Without these directional attributes, the interop marshaler does not export directional information to the type library (it exports as In, which is the default) and this can cause problems with COM cross-apartment marshaling.</span></span>

- <span data-ttu-id="516bb-147">Başvuru türü başvuru ile geçirilmezse, varsayılan olarak Içinde/dışarı olarak sıralanır.</span><span class="sxs-lookup"><span data-stu-id="516bb-147">If a reference type is passed by reference, it will be marshaled as In/Out by default.</span></span>

## <a name="systemstring-and-systemtextstringbuilder"></a><span data-ttu-id="516bb-148">System. String ve System. Text. StringBuilder</span><span class="sxs-lookup"><span data-stu-id="516bb-148">System.String and System.Text.StringBuilder</span></span>

<span data-ttu-id="516bb-149">Veriler, değere veya başvuruya göre yönetilmeyen koda sıralandığında, Sıralayıcı tipik olarak verileri ikincil bir arabelleğe kopyalar (büyük olasılıkla kopya sırasında karakter kümelerini dönüştürüyor) ve bir arabelleğe bir başvuru çağırarak aranan öğesine geçirir.</span><span class="sxs-lookup"><span data-stu-id="516bb-149">When data is marshaled to unmanaged code by value or by reference, the marshaler typically copies the data to a secondary buffer (possibly converting character sets during the copy) and passes a reference to the buffer to the callee.</span></span> <span data-ttu-id="516bb-150">Başvuru, **SysAllocString**ile ayrılmış bir **BSTR** değilse, başvuru her zaman **CoTaskMemAlloc**ile ayrılır.</span><span class="sxs-lookup"><span data-stu-id="516bb-150">Unless the reference is a **BSTR** allocated with **SysAllocString**, the reference is always allocated with **CoTaskMemAlloc**.</span></span>

<span data-ttu-id="516bb-151">Dize türü değere göre sıralanmışsa (örneğin, bir Unicode karakter dizesi), Sıralayıcı çağıran, iç Unicode arabelleğinde yönetilen dizelere doğrudan bir işaretçi ekleyerek onu yeni bir arabelleğe kopyalamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="516bb-151">As an optimization when either string type is marshaled by value (such as a Unicode character string), the marshaler passes the callee a direct pointer to managed strings in the internal Unicode buffer instead of copying it to a new buffer.</span></span>

> [!CAUTION]
> <span data-ttu-id="516bb-152">Bir dize değere göre geçirildiğinde, çağrılan, Sıralayıcı tarafından geçirilen başvuruyu hiçbir zaman değiştirmemelidir.</span><span class="sxs-lookup"><span data-stu-id="516bb-152">When a string is passed by value, the callee must never alter the reference passed by the marshaler.</span></span> <span data-ttu-id="516bb-153">Bunun yapılması yönetilen yığının bozulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-153">Doing so can corrupt the managed heap.</span></span>

<span data-ttu-id="516bb-154">Bir <xref:System.String?displayProperty=nameWithType> başvuru ile geçirildiğinde Sıralayıcı, çağrıyı yapmadan önce içeriği bir ikincil arabelleğe kopyalar.</span><span class="sxs-lookup"><span data-stu-id="516bb-154">When a <xref:System.String?displayProperty=nameWithType> is passed by reference, the marshaler copies the contents the string to a secondary buffer before making the call.</span></span> <span data-ttu-id="516bb-155">Ardından, arabelleğin içeriğini çağrıdan dönüşte yeni bir dizeye kopyalar.</span><span class="sxs-lookup"><span data-stu-id="516bb-155">It then copies the contents of the buffer into a new string on return from the call.</span></span> <span data-ttu-id="516bb-156">Bu teknik, sabit yönetilen dizenin değiştirilmemiş olarak kalmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="516bb-156">This technique ensures that the immutable managed string remains unaltered.</span></span>

<span data-ttu-id="516bb-157">Bir <xref:System.Text.StringBuilder?displayProperty=nameWithType> değere göre geçirildiğinde Sıralayıcı, **StringBuilder** 'ın iç arabelleğine doğrudan çağırana bir başvuru geçirir.</span><span class="sxs-lookup"><span data-stu-id="516bb-157">When a <xref:System.Text.StringBuilder?displayProperty=nameWithType> is passed by value, the marshaler passes a reference to the internal buffer of the **StringBuilder** directly to the caller.</span></span> <span data-ttu-id="516bb-158">Çağıran ve çağrılan, arabelleğin boyutunu kabul etmelidir.</span><span class="sxs-lookup"><span data-stu-id="516bb-158">The caller and callee must agree on the size of the buffer.</span></span> <span data-ttu-id="516bb-159">Çağıran, yeterli uzunlukta bir **StringBuilder** oluşturmaktan sorumludur.</span><span class="sxs-lookup"><span data-stu-id="516bb-159">The caller is responsible for creating a **StringBuilder** of adequate length.</span></span> <span data-ttu-id="516bb-160">Aranan, arabelleğin taşma olmamasını sağlamak için gerekli önlemleri almalıdır.</span><span class="sxs-lookup"><span data-stu-id="516bb-160">The callee must take the necessary precautions to ensure that the buffer is not overrun.</span></span> <span data-ttu-id="516bb-161">**StringBuilder** , değere göre geçirilen başvuru türleri varsayılan olarak parametrelerde olarak geçirilir kural için bir özel durumdur.</span><span class="sxs-lookup"><span data-stu-id="516bb-161">**StringBuilder** is an exception to the rule that reference types passed by value are passed as In parameters by default.</span></span> <span data-ttu-id="516bb-162">Her zaman Içinde/dışarı olarak geçirilir.</span><span class="sxs-lookup"><span data-stu-id="516bb-162">It is always passed as In/Out.</span></span>

## <a name="see-also"></a><span data-ttu-id="516bb-163">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="516bb-163">See also</span></span>

- [<span data-ttu-id="516bb-164">Varsayılan Sıralama Davranışı</span><span class="sxs-lookup"><span data-stu-id="516bb-164">Default Marshaling Behavior</span></span>](default-marshaling-behavior.md)
- <span data-ttu-id="516bb-165">[Yönlü öznitelikler](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span><span class="sxs-lookup"><span data-stu-id="516bb-165">[Directional Attributes](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/77e6taeh(v=vs.100))</span></span>
- [<span data-ttu-id="516bb-166">Birlikte Çalışma Hazırlama</span><span class="sxs-lookup"><span data-stu-id="516bb-166">Interop Marshaling</span></span>](interop-marshaling.md)
