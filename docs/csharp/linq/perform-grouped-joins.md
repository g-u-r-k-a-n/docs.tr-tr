---
title: Gruplanmış birleşimler gerçekleştirme (C# üzerinde LINQ)
description: C# ' de LINQ kullanarak gruplanmış birleşimler gerçekleştirmeyi öğrenin.
ms.date: 04/22/2020
ms.assetid: 9667daf9-a5fd-4b43-a5c4-a9c2b744000e
ms.openlocfilehash: 740a861da7dfb9653a874d5baf67eeb2030555b4
ms.sourcegitcommit: 8b02d42f93adda304246a47f49f6449fc74a3af4
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/24/2020
ms.locfileid: "82135756"
---
# <a name="perform-grouped-joins"></a><span data-ttu-id="519c5-103">Gruplanmış birleşimler gerçekleştirme</span><span class="sxs-lookup"><span data-stu-id="519c5-103">Perform grouped joins</span></span>

<span data-ttu-id="519c5-104">Grup birleştirmesi, hiyerarşik veri yapıları üretmek için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="519c5-104">The group join is useful for producing hierarchical data structures.</span></span> <span data-ttu-id="519c5-105">İkinci koleksiyondaki bağıntılı öğeler kümesiyle ilk koleksiyondaki her öğeyi çiftler.</span><span class="sxs-lookup"><span data-stu-id="519c5-105">It pairs each element from the first collection with a set of correlated elements from the second collection.</span></span>

<span data-ttu-id="519c5-106">Örneğin, adlı `Student` bir sınıf veya ilişkisel veritabanı tablosu iki alan içerebilir: `Id` ve. `Name`</span><span class="sxs-lookup"><span data-stu-id="519c5-106">For example, a class or a relational database table named `Student` might contain two fields: `Id` and `Name`.</span></span> <span data-ttu-id="519c5-107">Adlı `Course` ikinci bir sınıf veya ilişkisel veritabanı tablosu iki alan içerebilir: `StudentId` ve. `CourseTitle`</span><span class="sxs-lookup"><span data-stu-id="519c5-107">A second class or relational database table named `Course` might contain two fields: `StudentId` and `CourseTitle`.</span></span> <span data-ttu-id="519c5-108">Bu iki veri kaynağına, `Student.Id` eşleştirmeye göre bir grup birleşimi `Course.StudentId`, her birini `Student` bir `Course` nesne koleksiyonu (boş olabilir) ile gruplandırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="519c5-108">A group join of these two data sources, based on matching `Student.Id` and `Course.StudentId`, would group each `Student` with a collection of `Course` objects (which might be empty).</span></span>

> [!NOTE]
> <span data-ttu-id="519c5-109">İlk koleksiyonun her öğesi, bir grup birleşimi sonuç kümesinde, bağıntılı öğelerin ikinci koleksiyonda bulunup bulunamadığına bakılmaksızın görünür.</span><span class="sxs-lookup"><span data-stu-id="519c5-109">Each element of the first collection appears in the result set of a group join regardless of whether correlated elements are found in the second collection.</span></span> <span data-ttu-id="519c5-110">Bağıntılı öğelerin bulunamadığı durumda, bu öğe için bağıntılı öğelerin sırası boştur.</span><span class="sxs-lookup"><span data-stu-id="519c5-110">In the case where no correlated elements are found, the sequence of correlated elements for that element is empty.</span></span> <span data-ttu-id="519c5-111">Bu nedenle, sonuç seçicisinin ilk koleksiyonun her öğesine erişimi vardır.</span><span class="sxs-lookup"><span data-stu-id="519c5-111">The result selector therefore has access to every element of the first collection.</span></span> <span data-ttu-id="519c5-112">Bu, ikinci koleksiyonda eşleşmesi olmayan ilk koleksiyondaki öğelere erişemeyen, grup olmayan bir birleşimde elde edilen sonuç seçiciden farklıdır.</span><span class="sxs-lookup"><span data-stu-id="519c5-112">This differs from the result selector in a non-group join, which cannot access elements from the first collection that have no match in the second collection.</span></span>

> [!WARNING]
> <span data-ttu-id="519c5-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType>geleneksel ilişkisel veritabanı koşullarında doğrudan eşdeğer değildir.</span><span class="sxs-lookup"><span data-stu-id="519c5-113"><xref:System.Linq.Enumerable.GroupJoin%2A?displayProperty=nameWithType> has no direct equivalent in traditional relational database terms.</span></span> <span data-ttu-id="519c5-114">Ancak, bu yöntem, İç birleştirmeler ve sol dış birleşimlerin bir üst kümesini uygular.</span><span class="sxs-lookup"><span data-stu-id="519c5-114">However, this method does implement a superset of inner joins and left outer joins.</span></span> <span data-ttu-id="519c5-115">Bu işlemlerin her ikisi de gruplanmış bir JOIN bakımından yazılabilir.</span><span class="sxs-lookup"><span data-stu-id="519c5-115">Both of these operations can be written in terms of a grouped join.</span></span> <span data-ttu-id="519c5-116">Daha fazla bilgi için bkz. [JOIN işlemleri](../programming-guide/concepts/linq/join-operations.md) ve [Entity Framework Core, groupjoın](https://docs.microsoft.com/ef/core/querying/complex-query-operators#groupjoin).</span><span class="sxs-lookup"><span data-stu-id="519c5-116">For more information, see [Join Operations](../programming-guide/concepts/linq/join-operations.md) and [Entity Framework Core, GroupJoin](https://docs.microsoft.com/ef/core/querying/complex-query-operators#groupjoin).</span></span>

<span data-ttu-id="519c5-117">Bu makaledeki ilk örnekte, Grup birleştirmesini nasıl gerçekleştireceğiniz gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="519c5-117">The first example in this article shows you how to perform a group join.</span></span> <span data-ttu-id="519c5-118">İkinci örnek, bir grup birleştirmenin XML öğeleri oluşturmak için nasıl kullanılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="519c5-118">The second example shows you how to use a group join to create XML elements.</span></span>

## <a name="example---group-join"></a><span data-ttu-id="519c5-119">Örnek-gruba ekleme</span><span class="sxs-lookup"><span data-stu-id="519c5-119">Example - Group join</span></span>

<span data-ttu-id="519c5-120">Aşağıdaki `Person` örnek, türüyle `Pet` `Person` eşleşen ve `Pet.Owner` özelliğine dayalı olarak nesne grubuna bir grup birleşimi uygular.</span><span class="sxs-lookup"><span data-stu-id="519c5-120">The following example performs a group join of objects of type `Person` and `Pet` based on the `Person` matching the `Pet.Owner` property.</span></span> <span data-ttu-id="519c5-121">Her eşleşme için bir öğe çifti üreten grup olmayan bir birleştirmenin aksine, Group JOIN, ilk koleksiyondaki her öğe için yalnızca bir sonuç nesnesi oluşturur, bu örnekte bir `Person` nesnedir.</span><span class="sxs-lookup"><span data-stu-id="519c5-121">Unlike a non-group join, which would produce a pair of elements for each match, the group join produces only one resulting object for each element of the first collection, which in this example is a `Person` object.</span></span> <span data-ttu-id="519c5-122">Bu örnekte nesneler olan `Pet` ikinci koleksiyondaki karşılık gelen öğeler, bir koleksiyon halinde gruplandırılır.</span><span class="sxs-lookup"><span data-stu-id="519c5-122">The corresponding elements from the second collection, which in this example are `Pet` objects, are grouped into a collection.</span></span> <span data-ttu-id="519c5-123">Son olarak, sonuç Seçicisi işlevi bir `Person.FirstName` `Pet` nesne koleksiyonundan oluşan her bir eşleşme için anonim bir tür oluşturur.</span><span class="sxs-lookup"><span data-stu-id="519c5-123">Finally, the result selector function creates an anonymous type for each match that consists of `Person.FirstName` and a collection of `Pet` objects.</span></span>

[!code-csharp[CsLINQProgJoining#5](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_1.cs)]

## <a name="example---group-join-to-create-xml"></a><span data-ttu-id="519c5-124">Örnek-XML oluşturmak için gruba ekleme</span><span class="sxs-lookup"><span data-stu-id="519c5-124">Example - Group join to create XML</span></span>

<span data-ttu-id="519c5-125">Grup birleşimleri, LINQ to XML kullanarak XML oluşturmak için idealdir.</span><span class="sxs-lookup"><span data-stu-id="519c5-125">Group joins are ideal for creating XML by using LINQ to XML.</span></span> <span data-ttu-id="519c5-126">Aşağıdaki örnek, anonim türler oluşturmak yerine bir önceki örneğe benzerdir, sonuç Seçici işlevi de birleştirilmiş nesneleri temsil eden XML öğeleri oluşturur.</span><span class="sxs-lookup"><span data-stu-id="519c5-126">The following example is similar to the previous example except that instead of creating anonymous types, the result selector function creates XML elements that represent the joined objects.</span></span>

[!code-csharp[CsLINQProgJoining#6](~/samples/snippets/csharp/concepts/linq/how-to-perform-grouped-joins_2.cs)]

## <a name="see-also"></a><span data-ttu-id="519c5-127">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="519c5-127">See also</span></span>

- <xref:System.Linq.Enumerable.Join%2A>
- <xref:System.Linq.Enumerable.GroupJoin%2A>
- [<span data-ttu-id="519c5-128">İç birleşimler gerçekleştirme</span><span class="sxs-lookup"><span data-stu-id="519c5-128">Perform inner joins</span></span>](perform-inner-joins.md)
- [<span data-ttu-id="519c5-129">Sol dış birleşimler gerçekleştirme</span><span class="sxs-lookup"><span data-stu-id="519c5-129">Perform left outer joins</span></span>](perform-left-outer-joins.md)
- [<span data-ttu-id="519c5-130">Anonim türler</span><span class="sxs-lookup"><span data-stu-id="519c5-130">Anonymous types</span></span>](../programming-guide/classes-and-structs/anonymous-types.md)
