---
title: releaseHandleFailed MDA
description: .NET 'teki kaynak veya bellek sızıntıları nedeniyle etkinleştirilebilecek releaseHandleFailed Managed hata ayıklama Yardımcısı 'nı (MDA) gözden geçirin.
ms.date: 03/30/2017
helpviewer_keywords:
- managed debugging assistants (MDAs), handles
- release handle failed
- CriticalHandle class, run-time errors
- releaseHandleFailed MDA
- ReleaseHandle method
- SafeHandle class, run-time errors
- MDAs (managed debugging assistants), handles
ms.assetid: 44cd98ba-95e5-40a1-874d-e8e163612c51
ms.openlocfilehash: 167a304b4571aa35f758a2054caf6ae1c60a3c60
ms.sourcegitcommit: c23d9666ec75b91741da43ee3d91c317d68c7327
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/01/2020
ms.locfileid: "85803644"
---
# <a name="releasehandlefailed-mda"></a><span data-ttu-id="f8e3d-103">releaseHandleFailed MDA</span><span class="sxs-lookup"><span data-stu-id="f8e3d-103">releaseHandleFailed MDA</span></span>
<span data-ttu-id="f8e3d-104">`releaseHandleFailed`Yönetilen hata ayıklama Yardımcısı (MDA) etkinleştirilir, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> veya sınıfından türetilen bir sınıf yöntemi olduğunda geliştiricilere bildirimde bulunur <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.CriticalHandle> `false` .</span><span class="sxs-lookup"><span data-stu-id="f8e3d-104">The `releaseHandleFailed` managed debugging assistant (MDA) is activated is to notify developers when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of a class derived from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> returns `false`.</span></span>  
  
## <a name="symptoms"></a><span data-ttu-id="f8e3d-105">Belirtiler</span><span class="sxs-lookup"><span data-stu-id="f8e3d-105">Symptoms</span></span>  
 <span data-ttu-id="f8e3d-106">Kaynak veya bellek sızıntıları.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-106">Resource or memory leaks.</span></span>  <span data-ttu-id="f8e3d-107"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>Sınıfın yöntemi öğesinden türetiliyor <xref:System.Runtime.InteropServices.SafeHandle> veya <xref:System.Runtime.InteropServices.CriticalHandle> başarısız olursa, sınıf tarafından kapsüllenmiş kaynak serbest bırakılmış veya temizlenmiş olabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-107">If the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method of the class deriving from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> fails, then the resource encapsulated by the class might not have been released or cleaned up.</span></span>  
  
## <a name="cause"></a><span data-ttu-id="f8e3d-108">Nedeni</span><span class="sxs-lookup"><span data-stu-id="f8e3d-108">Cause</span></span>  
 <span data-ttu-id="f8e3d-109"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>Veya ' den türetilen sınıflar oluşturduklarında, kullanıcıların yöntemi uygulamasını sağlaması gerekir; bu <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.CriticalHandle> nedenle, koşullar ayrı kaynağa özgüdür.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-109">Users must provide the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method if they create classes that derive from <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle>; thus, the circumstances are specific to the individual resource.</span></span> <span data-ttu-id="f8e3d-110">Ancak, gereksinimler aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="f8e3d-110">However, the requirements are as follows:</span></span>  
  
- <span data-ttu-id="f8e3d-111"><xref:System.Runtime.InteropServices.SafeHandle>ve <xref:System.Runtime.InteropServices.CriticalHandle> türler, önemli işlem kaynakları etrafındaki sarmalayıcıları temsil eder.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-111"><xref:System.Runtime.InteropServices.SafeHandle> and <xref:System.Runtime.InteropServices.CriticalHandle> types represent wrappers around vital process resources.</span></span> <span data-ttu-id="f8e3d-112">Bellek sızıntısı işlemi zaman içinde kullanılamaz hale getirir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-112">A memory leak would make the process unusable over time.</span></span>  
  
- <span data-ttu-id="f8e3d-113"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>Yöntemi, işlevini gerçekleştirememelidir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-113">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method must not fail to perform its function.</span></span> <span data-ttu-id="f8e3d-114">İşlem böyle bir kaynağı aldıktan sonra, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> bunu serbest bırakmaya yönelik tek yoldur.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-114">Once the process acquires such a resource, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is the only way to release it.</span></span> <span data-ttu-id="f8e3d-115">Bu nedenle, hata kaynak sızıntılarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-115">Therefore, failure implies resource leaks.</span></span>  
  
- <span data-ttu-id="f8e3d-116">' Nin yürütülmesi sırasında oluşan herhangi bir hata, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> kaynağın serbest bırakılması sırasında oluşan bir hata, yöntemin kendi uygulamasındaki bir hatadır <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> .</span><span class="sxs-lookup"><span data-stu-id="f8e3d-116">Any failure that does occur during the execution of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, impeding the release of the resource, is a bug in the implementation of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method itself.</span></span> <span data-ttu-id="f8e3d-117">Bu kod, kendi işlevini gerçekleştirmek için başka biri tarafından yazılan kodu çağırıyor olsa bile, sözleşmenin karşılandığından emin olmak için programcının sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-117">It is the responsibility of the programmer to ensure that the contract is fulfilled, even if that code calls code authored by someone else to perform its function.</span></span>  
  
## <a name="resolution"></a><span data-ttu-id="f8e3d-118">Çözüm</span><span class="sxs-lookup"><span data-stu-id="f8e3d-118">Resolution</span></span>  
 <span data-ttu-id="f8e3d-119"><xref:System.Runtime.InteropServices.SafeHandle>MDA bildirimini oluşturan belirli (veya) türü kullanan kod, <xref:System.Runtime.InteropServices.CriticalHandle> Ham tanıtıcı değerinin öğesinden <xref:System.Runtime.InteropServices.SafeHandle> ayıklanıp başka bir yerde kopyalandığı yerleri arayarak incelenmelidir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-119">The code that uses the specific <xref:System.Runtime.InteropServices.SafeHandle> (or <xref:System.Runtime.InteropServices.CriticalHandle>) type that raised the MDA notification should be reviewed, looking for places where the raw handle value is extracted from the <xref:System.Runtime.InteropServices.SafeHandle> and copied elsewhere.</span></span> <span data-ttu-id="f8e3d-120"><xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.CriticalHandle> Ham tanıtıcı değerinin kullanımı artık çalışma zamanı tarafından izlenmediğinden, bu, veya uygulamalarındaki hataların olağan nedendir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-120">This is the usual cause of failures within <xref:System.Runtime.InteropServices.SafeHandle> or <xref:System.Runtime.InteropServices.CriticalHandle> implementations, because the usage of the raw handle value is then no longer tracked by the runtime.</span></span> <span data-ttu-id="f8e3d-121">Ham tutamaç kopyası daha sonra kapatılırsa, bu durum <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> artık geçersiz olan tanıtıcı aynı tanıtıcıda denendiğinden sonraki çağrının başarısız olmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-121">If the raw handle copy is subsequently closed, it can cause a later <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> call to fail because the close is attempted on the same handle, which is now invalid.</span></span>  
  
 <span data-ttu-id="f8e3d-122">Yanlış tanıtıcı çoğaltmanın gerçekleşebileceği çeşitli yollar vardır:</span><span class="sxs-lookup"><span data-stu-id="f8e3d-122">There are a number of ways in which incorrect handle duplication can occur:</span></span>  
  
- <span data-ttu-id="f8e3d-123">Yöntemine yapılan çağrıları arayın <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> .</span><span class="sxs-lookup"><span data-stu-id="f8e3d-123">Look for calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.</span></span> <span data-ttu-id="f8e3d-124">Bu yönteme yapılan çağrılar, seyrek görülen bir şekilde yazılmalıdır ve bulduğunuz her türlü, ve yöntemlerine yapılan çağrılarla çevrelenmelidir <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> .</span><span class="sxs-lookup"><span data-stu-id="f8e3d-124">Calls to this method should be exceedingly rare, and any that you find should be surrounded by calls to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods.</span></span> <span data-ttu-id="f8e3d-125">Bu ikinci Yöntemler, ham tanıtıcı değerinin güvenli bir şekilde kullanılabileceği kod bölgesini belirtir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-125">These latter methods specify the region of code in which the raw handle value may be safely used.</span></span> <span data-ttu-id="f8e3d-126">Bu bölgenin dışında veya başvuru sayısı ilk yerde hiç artmadıysa, tanıtıcı değeri <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> başka bir iş parçacığı üzerinde veya üzerinde yapılan bir çağrı tarafından herhangi bir zamanda geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-126">Outside this region, or if the reference count is never incremented in the first place, the handle value can be invalidated at any time by a call to <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> on another thread.</span></span> <span data-ttu-id="f8e3d-127">' Nin tüm kullanımları <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> izlendikten sonra, ham tanıtıcının, sonunda çağrı yapılacak `CloseHandle` bir bileşen veya tanıtıcıyı serbest bırakılacak başka bir alt düzey yerel yöntem için kullanıma almadığından emin olmak için bu yolu izlemelisiniz.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-127">Once all uses of <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> have been tracked down, you should follow the path the raw handle takes to ensure it is not handed off to some component that will eventually call `CloseHandle` or another low-level native method that will release the handle.</span></span>  
  
- <span data-ttu-id="f8e3d-128"><xref:System.Runtime.InteropServices.SafeHandle>Geçerli bir ham tanıtıcı değeri ile başlatmak için kullanılan kodun tanıtıcıya sahip olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-128">Ensure that the code that is used to initialize the <xref:System.Runtime.InteropServices.SafeHandle> with a valid raw handle value owns the handle.</span></span> <span data-ttu-id="f8e3d-129">Bir <xref:System.Runtime.InteropServices.SafeHandle> tanıtıcı etrafında bir `ownsHandle` parametre oluşturduğunuzda, kodunuzun temel oluşturucuda öğesine ayarlamadan önce, `false` hem hem de <xref:System.Runtime.InteropServices.SafeHandle> gerçek tutamaç sahibi tanıtıcıyı kapatmayı deneyebilir, bu da, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> <xref:System.Runtime.InteropServices.SafeHandle> yarış durumu kaybederse içindeki bir hataya önde gelen bir hataya neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-129">If you form a <xref:System.Runtime.InteropServices.SafeHandle> around a handle your code does not own without setting the `ownsHandle` parameter to `false` in the base constructor, then both the <xref:System.Runtime.InteropServices.SafeHandle> and the real handle owner can try to close the handle, leading to an error in <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> if the <xref:System.Runtime.InteropServices.SafeHandle> loses the race.</span></span>  
  
- <span data-ttu-id="f8e3d-130"><xref:System.Runtime.InteropServices.SafeHandle>Uygulama etki alanları arasında bir sıraya eklendiğinde, <xref:System.Runtime.InteropServices.SafeHandle> kullanılan Türetmenin seri hale getirilebilir olarak işaretlendiğinden emin olun.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-130">When a <xref:System.Runtime.InteropServices.SafeHandle> is marshaled between application domains, confirm the <xref:System.Runtime.InteropServices.SafeHandle> derivation being used has been marked as serializable.</span></span> <span data-ttu-id="f8e3d-131">Öğesinden türetilen bir sınıfın <xref:System.Runtime.InteropServices.SafeHandle> seri hale getirilebilir olduğu nadir durumlarda, <xref:System.Runtime.Serialization.ISerializable> arabirimini uygulamalıdır veya serileştirme ve seri durumdan çıkarma işlemini el ile denetlemek için diğer tekniklerin birini kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-131">In the rare cases where a class derived from <xref:System.Runtime.InteropServices.SafeHandle> has been made serializable, it should implement the <xref:System.Runtime.Serialization.ISerializable> interface or use one of the other techniques for controlling the serialization and deserialization process manually.</span></span> <span data-ttu-id="f8e3d-132">Bu, varsayılan serileştirme eylemi, iliştirilmiş ham tanıtıcı değerinin bit düzeyinde bir kopyasını oluşturmak olduğu için gereklidir, sonuçta iki <xref:System.Runtime.InteropServices.SafeHandle> örnek de aynı tutamaya sahip olduğunu düşünmektedir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-132">This is required because the default serialization action is to create a bitwise clone of the enclosed raw handle value, resulting in two <xref:System.Runtime.InteropServices.SafeHandle> instances thinking they own the same handle.</span></span> <span data-ttu-id="f8e3d-133">Her ikisi de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> aynı tanıtıcıda bir noktada çağrı yapmayı dener.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-133">Both will try to call <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> on the same handle at some point.</span></span> <span data-ttu-id="f8e3d-134"><xref:System.Runtime.InteropServices.SafeHandle>Bunu yapmak için ikinci işlem başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-134">The second <xref:System.Runtime.InteropServices.SafeHandle> to do this will fail.</span></span> <span data-ttu-id="f8e3d-135">Bir işlem serileştirilirken doğru eylem kursu, <xref:System.Runtime.InteropServices.SafeHandle> `DuplicateHandle` farklı bir yasal tanıtıcı kopyası oluşturmak için yerel tanıtıcı türü için işlevi veya benzer bir işlevi çağırmak olur.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-135">The correct course of action when serializing a <xref:System.Runtime.InteropServices.SafeHandle> is to call the `DuplicateHandle` function or a similar function for your native handle type to make a distinct legal handle copy.</span></span> <span data-ttu-id="f8e3d-136">Tanıtıcı türü bunu desteklemiyorsa <xref:System.Runtime.InteropServices.SafeHandle> tür kaydırması seri hale getirilebilir yapılamaz.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-136">If your handle type does not support this then the <xref:System.Runtime.InteropServices.SafeHandle> type wrapping it cannot be made serializable.</span></span>  
  
- <span data-ttu-id="f8e3d-137">Bir tanıtıcının erken kapatılmakta olduğunu izlemek mümkün olabilir, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> Örneğin, işleyiciyi serbest bırakmak için kullanılan yerel yordama bir hata ayıklayıcı kesme noktası yerleştirilerek, yöntemin son çağrıldığı bir hata ile başa dön, örneğin `CloseHandle` işlev.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-137">It may be possible to track where a handle is being closed early, leading to a failure when the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is finally called, by placing a debugger breakpoint on the native routine used to release the handle, for example the `CloseHandle` function.</span></span> <span data-ttu-id="f8e3d-138">Bu işlem, genellikle ile ilgili olan yoğun trafik nedeniyle, yük senaryoları veya hatta orta ölçekli işlevsel sınamalar için mümkün olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-138">This may not be possible for stress scenarios or even medium-sized functional tests due to the heavy traffic such routines often deal with.</span></span> <span data-ttu-id="f8e3d-139">Arayanın kimliğini veya büyük olasılıkla tam bir yığın izlemesini ve serbest bırakılmakta olan tanıtıcının değerini yakalamak için, yerel yayın yöntemini çağıran kodu işaretlememeye yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-139">It may help to instrument the code that calls the native release method, in order to capture the identity of the caller, or possibly a full stack trace, and the value of the handle being released.</span></span>  <span data-ttu-id="f8e3d-140">Tanıtıcı değeri, bu MDA tarafından raporlanan değerle karşılaştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-140">The handle value can be compared with the value reported by this MDA.</span></span>  
  
- <span data-ttu-id="f8e3d-141">İşlev aracılığıyla yayımlanabileceği tüm Win32 tutamaçları gibi bazı yerel tanıtıcı türleri `CloseHandle` aynı tanıtıcı ad alanını paylaşır.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-141">Note that some native handle types, such as all the Win32 handles that can be released via the `CloseHandle` function, share the same handle namespace.</span></span> <span data-ttu-id="f8e3d-142">Bir tanıtıcı türünün hatalı bir sürümü başka bir sorun oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-142">An erroneous release of one handle type can cause problems with another.</span></span> <span data-ttu-id="f8e3d-143">Örneğin, yanlışlıkla bir Win32 olay işleyicisini iki kez kapatmak, ilişkisiz bir dosya tutamacının zamanından önce kapanmasına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-143">For instance, accidentally closing a Win32 event handle twice might lead to an apparently unrelated file handle being closed prematurely.</span></span> <span data-ttu-id="f8e3d-144">Bu, tanıtıcı serbest bırakıldığında ve tanıtıcı değeri başka bir kaynağı izlemek için kullanılabilir hale geldiğinde (büyük olasılıkla başka bir tür) gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-144">This happens when the handle is released and the handle value becomes available for use to track another resource, potentially of another type.</span></span> <span data-ttu-id="f8e3d-145">Bu durumda ve ardından hatalı ikinci bir yayın varsa, ilgisiz bir iş parçacığının tanıtıcısı geçersiz kılınabilir.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-145">If this happens and is followed by an erroneous second release, the handle of an unrelated thread might be invalidated.</span></span>  
  
## <a name="effect-on-the-runtime"></a><span data-ttu-id="f8e3d-146">Çalışma zamanında etki</span><span class="sxs-lookup"><span data-stu-id="f8e3d-146">Effect on the Runtime</span></span>  
 <span data-ttu-id="f8e3d-147">Bu MDA, CLR üzerinde hiçbir etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-147">This MDA has no effect on the CLR.</span></span>  
  
## <a name="output"></a><span data-ttu-id="f8e3d-148">Çıktı</span><span class="sxs-lookup"><span data-stu-id="f8e3d-148">Output</span></span>  
 <span data-ttu-id="f8e3d-149">Bir veya ' nin <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.Runtime.InteropServices.CriticalHandle> tanıtıcıyı doğru bir şekilde serbest bırakmadığını belirten bir ileti.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-149">A message indicating that a <xref:System.Runtime.InteropServices.SafeHandle> or a <xref:System.Runtime.InteropServices.CriticalHandle> failed to properly release the handle.</span></span> <span data-ttu-id="f8e3d-150">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="f8e3d-150">For example:</span></span>  
  
```output
"A SafeHandle or CriticalHandle of type 'MyBrokenSafeHandle'
failed to properly release the handle with value 0x0000BEEF. This
usually indicates that the handle was released incorrectly via
another means (such as extracting the handle using DangerousGetHandle
and closing it directly or building another SafeHandle around it."  
```  
  
## <a name="configuration"></a><span data-ttu-id="f8e3d-151">Yapılandırma</span><span class="sxs-lookup"><span data-stu-id="f8e3d-151">Configuration</span></span>  
  
```xml  
<mdaConfig>  
  <assistants>  
    <releaseHandleFailed/>  
  </assistants>  
</mdaConfig>  
```  
  
## <a name="example"></a><span data-ttu-id="f8e3d-152">Örnek</span><span class="sxs-lookup"><span data-stu-id="f8e3d-152">Example</span></span>  
 <span data-ttu-id="f8e3d-153">Aşağıda, MDA ' i etkinleştirebilecek bir kod örneği verilmiştir `releaseHandleFailed` .</span><span class="sxs-lookup"><span data-stu-id="f8e3d-153">The following is a code example that can activate the `releaseHandleFailed` MDA.</span></span>  
  
```csharp
bool ReleaseHandle()  
{  
    // Calling the Win32 CloseHandle function to release the
    // native handle wrapped by this SafeHandle. This method returns
    // false on failure, but should only fail if the input is invalid
    // (which should not happen here). The method specifically must not
    // fail simply because of lack of resources or other transient
    // failures beyond the user’s control. That would make it unacceptable
    // to call CloseHandle as part of the implementation of this method.  
    return CloseHandle(handle);  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="f8e3d-154">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="f8e3d-154">See also</span></span>

- <xref:System.Runtime.InteropServices.MarshalAsAttribute>
- [<span data-ttu-id="f8e3d-155">Yönetilen Hata Ayıklama Yardımcıları ile Hataları Tanılama</span><span class="sxs-lookup"><span data-stu-id="f8e3d-155">Diagnosing Errors with Managed Debugging Assistants</span></span>](diagnosing-errors-with-managed-debugging-assistants.md)
- [<span data-ttu-id="f8e3d-156">Birlikte Çalışma Hazırlama</span><span class="sxs-lookup"><span data-stu-id="f8e3d-156">Interop Marshaling</span></span>](../interop/interop-marshaling.md)
