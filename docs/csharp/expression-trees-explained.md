---
title: İfade Ağaçları Açıklaması
description: İfade ağaçları ve yürütmeden önce dış yürütme ve kodu denetleme algoritmaları çevirmede nasıl yararlı oldukları hakkında bilgi edinin.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036987"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="b3dee-103">İfade Ağaçları Açıklaması</span><span class="sxs-lookup"><span data-stu-id="b3dee-103">Expression Trees Explained</span></span>

[<span data-ttu-id="b3dee-104">Önceki -- Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="b3dee-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="b3dee-105">İfade Ağacı, kodu tanımlayan bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="b3dee-106">Bunlar, derleyicinin kodu çözümlemek ve derlenmiş çıktıyı oluşturmak için kullandığı yapıları temel alır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="b3dee-107">Bu öğretici aracılığıyla okurken, İfade Ağaçlar ve [Analizörler ve CodeFixes](https://github.com/dotnet/roslyn-analyzers)oluşturmak için Roslyn API'lerde kullanılan türleri arasında benzerlik biraz fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="b3dee-108">(Çözümleyiciler ve CodeFixes kod üzerinde statik analiz gerçekleştiren ve bir geliştirici için olası düzeltmeler önerebilir NuGet paketleridir.) Kavramlar benzerdir ve sonuç kaynak kodun anlamlı bir şekilde incelenmesine olanak tanıyan bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="b3dee-109">Ancak, İfade Ağaçları Roslyn API'lerinden tamamen farklı sınıflara ve API'lere dayanır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="b3dee-110">Basit bir örneğe bakalım.</span><span class="sxs-lookup"><span data-stu-id="b3dee-110">Let's look at a simple example.</span></span>
<span data-ttu-id="b3dee-111">İşte bir kod satırı:</span><span class="sxs-lookup"><span data-stu-id="b3dee-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="b3dee-112">Bunu bir ifade ağacı olarak çözümleseydiniz, ağaç birkaç düğüm içerir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="b3dee-113">En dıştaki düğüm atamaile değişken bildirim`var sum = 1 + 2;`deyimidir ( ) En dıştaki düğüm birkaç alt düğüm içerir: değişken bildirimi, bir atama işleci ve eşitler işaretinin sağ tarafını temsil eden bir ifade.</span><span class="sxs-lookup"><span data-stu-id="b3dee-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="b3dee-114">Bu ifade, ekleme işlemini temsil eden ifadelere ve eklemenin sol ve sağ operandlarına daha fazla bölünmüştür.</span><span class="sxs-lookup"><span data-stu-id="b3dee-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="b3dee-115">Eşitler işaretinin sağ tarafını oluşturan ifadelere biraz daha inelim.</span><span class="sxs-lookup"><span data-stu-id="b3dee-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="b3dee-116">İfade. `1 + 2`</span><span class="sxs-lookup"><span data-stu-id="b3dee-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="b3dee-117">Bu ikili bir ifade.</span><span class="sxs-lookup"><span data-stu-id="b3dee-117">That's a binary expression.</span></span> <span data-ttu-id="b3dee-118">Daha spesifik olarak, bu bir ikili ekleme ifadesidir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="b3dee-119">İkili ek ifade, ek ifadenin sol ve sağ düğümlerini temsil eden iki çocuktan içerir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="b3dee-120">Burada, her iki düğüm de sabit ifadelerdir: Sol `1`operand değeridir ve sağ `2`operand değeridir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="b3dee-121">Görsel olarak, tüm deyim bir ağaçtır: Kök düğümünden başlayabilir ve deyimi oluşturan kodu görmek için ağaçtaki her düğüme seyahat edebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="b3dee-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="b3dee-122">Atama lı değişken`var sum = 1 + 2;`bildirim deyimi ( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="b3dee-123">Örtük değişken`var sum`türü bildirimi ( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="b3dee-124">Örtük var`var`anahtar kelimesi ( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="b3dee-125">Değişken ad`sum`bildirimi ( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="b3dee-126">Atama işleci (`=`)</span><span class="sxs-lookup"><span data-stu-id="b3dee-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="b3dee-127">İkili ekleme`1 + 2`ifadesi ( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="b3dee-128">Sol operand`1`( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="b3dee-129">İlave`+`işleci ( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="b3dee-130">Sağ operand`2`( )</span><span class="sxs-lookup"><span data-stu-id="b3dee-130">Right operand (`2`)</span></span>

<span data-ttu-id="b3dee-131">Bu karmaşık görünebilir, ama çok güçlü.</span><span class="sxs-lookup"><span data-stu-id="b3dee-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="b3dee-132">Aynı işlemi takiben, çok daha karmaşık ifadeleri ayrıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="b3dee-133">Şu ifadeyi göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="b3dee-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="b3dee-134">Yukarıdaki ifade de bir atama ile değişken bildirimidir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="b3dee-135">Bu durumda, atamanın sağ tarafı çok daha karmaşık bir ağaçtır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="b3dee-136">Bu ifadeyi ayrıştırmayacağım, ama farklı düğümlerin ne olabileceğini düşünün.</span><span class="sxs-lookup"><span data-stu-id="b3dee-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="b3dee-137">Geçerli nesneyi alıcı olarak kullanan yöntem çağrıları vardır, `this` açık alıcısı olan, olmayan bir yöntem çağrıları vardır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="b3dee-138">Diğer alıcı nesneleri kullanarak yöntem çağrıları vardır, farklı türde sabit bağımsız değişkenler vardır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="b3dee-139">Ve son olarak, bir ikili ekleme işleci vardır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="b3dee-140">İade türüne bağlı `SecretSauceFunction()` olarak, `MoreSecretSauce()`bu ikili ekleme işleci, bir sınıf için tanımlanan ikili ekleme işleci için statik bir yöntem çağrısı çözme, geçersiz kılınmış bir ek işleç için bir yöntem çağrısı olabilir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="b3dee-141">Algılanan bu karmaşıklığa rağmen, yukarıdaki ifade ilk örnek kadar kolay gezinilebilen bir ağaç yapısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="b3dee-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="b3dee-142">İfadede yaprak düğümleri bulmak için alt düğümleri geçiş yapmaya devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="b3dee-143">Üst düğümlerin çocuklarına referansları olacaktır ve her düğümün ne tür bir düğüm olduğunu açıklayan bir özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="b3dee-144">İfade ağacının yapısı çok tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="b3dee-145">Temel bilgileri öğrendikten sonra, ifade ağacı olarak temsil edildiğinde en karmaşık kodu bile anlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="b3dee-146">Veri yapısındaki zarafet, C# derleyicisinin en karmaşık C# programlarını nasıl analiz edebildiğini ve bu karmaşık kaynak kodundan uygun çıktıyı nasıl oluşturabileceğini açıklar.</span><span class="sxs-lookup"><span data-stu-id="b3dee-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="b3dee-147">İfade ağaçlarının yapısına aşina olduktan sonra, hızlı bir şekilde kazandığınız bilginin çok daha gelişmiş senaryolarla çalışmanızı sağladığını göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="b3dee-148">Ağaçları ifade etmek için inanılmaz bir güç var.</span><span class="sxs-lookup"><span data-stu-id="b3dee-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="b3dee-149">Diğer ortamlarda yürütmek için algoritmaları çevirmeye ek olarak, ifade ağaçları yürütmeden önce kodu denetleyen algoritmalar yazmayı kolaylaştırmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="b3dee-150">Bağımsız değişkenleri ifade olan bir yöntem yazabilir ve kodu yürütmeden önce bu ifadeleri inceleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="b3dee-151">İfade Ağacı kodun tam bir temsilidir: herhangi bir alt ifadenin değerlerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="b3dee-152">Yöntem ve özellik adlarını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-152">You can see method and property names.</span></span> <span data-ttu-id="b3dee-153">Sabit ifadelerin değerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="b3dee-154">Ayrıca bir ifade ağacını yürütülebilir bir temsilciye dönüştürebilir ve kodu yürütebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="b3dee-155">İfade Ağaçları için API'ler, hemen hemen her geçerli kod yapısını temsil eden ağaçlar oluşturmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="b3dee-156">Ancak, bazı şeyleri mümkün olduğunca basit tutmak için, bazı C# deyimleri bir ifade ağacında oluşturulamaz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="b3dee-157">Bir örnek asynchronous ifadeler `async` (ve `await` anahtar kelimeler kullanarak).</span><span class="sxs-lookup"><span data-stu-id="b3dee-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="b3dee-158">Gereksinimleriniz eşzamanlı algoritmalar gerektiriyorsa, derleyici desteğine `Task` güvenmek yerine nesneleri doğrudan işlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="b3dee-159">Başka bir döngüler oluşturma.</span><span class="sxs-lookup"><span data-stu-id="b3dee-159">Another is in creating loops.</span></span> <span data-ttu-id="b3dee-160">Genellikle, bunları , , `for` `foreach` `while` veya `do` döngüler kullanarak oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="b3dee-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="b3dee-161">[Bu serinin ilerleyen saatlerinde](expression-trees-building.md)göreceğiniz gibi, ifade ağaçları için API'ler döngüyü yineleyen ifadeleri ve `break` `continue` ifadeleri içeren tek bir döngü ifadesini destekler.</span><span class="sxs-lookup"><span data-stu-id="b3dee-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="b3dee-162">Yapamayacağınız tek şey bir ifade ağacını değiştirmektir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="b3dee-163">İfade Ağaçları değişmez veri yapılarıdır.</span><span class="sxs-lookup"><span data-stu-id="b3dee-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="b3dee-164">Bir ifade ağacını mutasyona uğratmak (değiştirmek) istiyorsanız, özgün bir kopyasını, ancak istediğiniz değişikliklerle birlikte yeni bir ağaç oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b3dee-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="b3dee-165">Sonraki -- İfade Ağaçlarını Destekleyen Çerçeve Türleri</span><span class="sxs-lookup"><span data-stu-id="b3dee-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
