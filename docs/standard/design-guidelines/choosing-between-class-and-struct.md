---
title: Sınıf ile Yapı Arasında Seçim Yapma
ms.date: 10/22/2008
ms.technology: dotnet-standard
helpviewer_keywords:
- class library design guidelines [.NET Framework], structures
- class library design guidelines [.NET Framework], classes
- structures [.NET Framework], vs. classes
- classes [.NET Framework], design guidelines
- type design guidelines, structures
- structures [.NET Framework], design guidelines
- classes [.NET Framework], vs. structures
- type design guidelines, classes
ms.assetid: f8b8ec9b-0ba7-4dea-aadf-a93395cd804f
ms.openlocfilehash: 76042bef1475f2fdf14e309390dcba6654ccfaa9
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/24/2020
ms.locfileid: "76741751"
---
# <a name="choosing-between-class-and-struct"></a><span data-ttu-id="a3e63-102">Sınıf ile Yapı Arasında Seçim Yapma</span><span class="sxs-lookup"><span data-stu-id="a3e63-102">Choosing Between Class and Struct</span></span>
<span data-ttu-id="a3e63-103">Temel tasarım kararlarından biri olan her çerçeve tasarlayıcı, bir türü Sınıf (başvuru türü) veya yapı (değer türü) olarak tasarlamayacağındır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-103">One of the basic design decisions every framework designer faces is whether to design a type as a class (a reference type) or as a struct (a value type).</span></span> <span data-ttu-id="a3e63-104">Bu seçimi yapmak için başvuru türleri ve değer türleri davranışlarındaki farkları iyi anlamak çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-104">Good understanding of the differences in the behavior of reference types and value types is crucial in making this choice.</span></span>

 <span data-ttu-id="a3e63-105">Başvuru türleri ve değer türleri arasındaki ilk fark, başvuru türlerinin yığın ve atık toplama üzerinde ayrıldığı, ancak değer türlerinin yığın üzerinde ayrıldığı ya da yığın üzerinde serbest bırakıldığı ve yığın olduğunda serbest bırakıldığı durumlarda dikkate alınması gerektiğini düşüneceğiz. ya da içerdiği tür serbest bırakılır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-105">The first difference between reference types and value types we will consider is that reference types are allocated on the heap and garbage-collected, whereas value types are allocated either on the stack or inline in containing types and deallocated when the stack unwinds or when their containing type gets deallocated.</span></span> <span data-ttu-id="a3e63-106">Bu nedenle, değer türlerinin ayırmaları ve ayırması, genel bir ucuz 'da, başvuru türlerinin tahsislerini ve ayırmayı kaldırır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-106">Therefore, allocations and deallocations of value types are in general cheaper than allocations and deallocations of reference types.</span></span>

 <span data-ttu-id="a3e63-107">Daha sonra, başvuru türü dizileri satır dışı ayrılır, yani dizi öğeleri yalnızca yığında bulunan başvuru türünün örneklerine başvurudur.</span><span class="sxs-lookup"><span data-stu-id="a3e63-107">Next, arrays of reference types are allocated out-of-line, meaning the array elements are just references to instances of the reference type residing on the heap.</span></span> <span data-ttu-id="a3e63-108">Değer türü dizileri satır içi olarak ayrılır, yani dizi öğeleri değer türünün gerçek örnekleridir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-108">Value type arrays are allocated inline, meaning that the array elements are the actual instances of the value type.</span></span> <span data-ttu-id="a3e63-109">Bu nedenle, değer türü dizilerinin ayırmaları ve ayırmaları, başvuru türü dizilerinin ayırmaya ve ayırmaya göre çok daha ucuz.</span><span class="sxs-lookup"><span data-stu-id="a3e63-109">Therefore, allocations and deallocations of value type arrays are much cheaper than allocations and deallocations of reference type arrays.</span></span> <span data-ttu-id="a3e63-110">Bunlara ek olarak, çoğu durumda değer türü dizileri başvurunun çok daha iyi yer aldığı yeri gösterir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-110">In addition, in a majority of cases value type arrays exhibit much better locality of reference.</span></span>

 <span data-ttu-id="a3e63-111">Sonraki fark, bellek kullanımıyla ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-111">The next difference is related to memory usage.</span></span> <span data-ttu-id="a3e63-112">Değer türleri, bir başvuru türüne veya uygulamadıkları arabirimlerden birine dönüştürme yaparken kutulanır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-112">Value types get boxed when cast to a reference type or one of the interfaces they implement.</span></span> <span data-ttu-id="a3e63-113">Değer türüne geri dönüştürme yapıldıklarında kutulanmamış alırlar.</span><span class="sxs-lookup"><span data-stu-id="a3e63-113">They get unboxed when cast back to the value type.</span></span> <span data-ttu-id="a3e63-114">Kutular, yığında ayrılan ve atık olarak toplanmış olan nesneler olduğundan, çok fazla kutulama ve kutudan çıkarma yığın üzerinde olumsuz bir etkiye, çöp toplayıcısına ve sonuç olarak uygulamanın performansına sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-114">Because boxes are objects that are allocated on the heap and are garbage-collected, too much boxing and unboxing can have a negative impact on the heap, the garbage collector, and ultimately the performance of the application.</span></span>  <span data-ttu-id="a3e63-115">Buna karşılık, başvuru türleri atama olarak böyle bir kutulama gerçekleşmez.</span><span class="sxs-lookup"><span data-stu-id="a3e63-115">In contrast, no such boxing occurs as reference types are cast.</span></span> <span data-ttu-id="a3e63-116">(Daha fazla bilgi için bkz. [kutulama ve kutudan](../../csharp/programming-guide/types/boxing-and-unboxing.md)çıkarma).</span><span class="sxs-lookup"><span data-stu-id="a3e63-116">(For more information, see [Boxing and Unboxing](../../csharp/programming-guide/types/boxing-and-unboxing.md)).</span></span>

 <span data-ttu-id="a3e63-117">Ardından, başvuru türü atamaları başvuruyu kopyalar, ancak değer türü atamaları tüm değeri kopyalar.</span><span class="sxs-lookup"><span data-stu-id="a3e63-117">Next, reference type assignments copy the reference, whereas value type assignments copy the entire value.</span></span> <span data-ttu-id="a3e63-118">Bu nedenle, büyük başvuru türlerinin atamaları büyük değer türlerinin atamalarından çok daha ucuz.</span><span class="sxs-lookup"><span data-stu-id="a3e63-118">Therefore, assignments of large reference types are cheaper than assignments of large value types.</span></span>

 <span data-ttu-id="a3e63-119">Son olarak, başvuru türleri başvuruya göre geçirilir, ancak değer türleri değere göre geçirilir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-119">Finally, reference types are passed by reference, whereas value types are passed by value.</span></span> <span data-ttu-id="a3e63-120">Başvuru türünün bir örneğinde yapılan değişiklikler örneğe işaret eden tüm başvuruları etkiler.</span><span class="sxs-lookup"><span data-stu-id="a3e63-120">Changes to an instance of a reference type affect all references pointing to the instance.</span></span> <span data-ttu-id="a3e63-121">Değer türü örnekleri, değere göre geçirildiğinde kopyalanır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-121">Value type instances are copied when they are passed by value.</span></span> <span data-ttu-id="a3e63-122">Bir değer türünün örneği değiştirildiğinde, kurs herhangi bir kopyasını etkilemez.</span><span class="sxs-lookup"><span data-stu-id="a3e63-122">When an instance of a value type is changed, it of course does not affect any of its copies.</span></span> <span data-ttu-id="a3e63-123">Kopyalar Kullanıcı tarafından açıkça oluşturulmadığından ancak bağımsız değişkenler geçtiğinde veya dönüş değerleri döndürüldüğünde örtük olarak oluşturulduysa, değiştirilebilen değer türleri çok sayıda kullanıcıya kafa karıştırıcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-123">Because the copies are not created explicitly by the user but are implicitly created when arguments are passed or return values are returned, value types that can be changed can be confusing to many users.</span></span> <span data-ttu-id="a3e63-124">Bu nedenle, değer türleri sabit olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-124">Therefore, value types should be immutable.</span></span>

 <span data-ttu-id="a3e63-125">Thumb kuralı olarak, bir çerçevede türlerin çoğunluğu sınıf olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-125">As a rule of thumb, the majority of types in a framework should be classes.</span></span> <span data-ttu-id="a3e63-126">Ancak, bir değer türünün özelliklerinin yapıları kullanmak için daha uygun hale yaptığı bazı durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-126">There are, however, some situations in which the characteristics of a value type make it more appropriate to use structs.</span></span>

 <span data-ttu-id="a3e63-127">✔️, türün örnekleri küçük ve genellikle kısa süreli ise veya genellikle diğer nesnelere katıştırılmışsa sınıf yerine bir struct tanımlamayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="a3e63-127">✔️ CONSIDER defining a struct instead of a class if instances of the type are small and commonly short-lived or are commonly embedded in other objects.</span></span>

 <span data-ttu-id="a3e63-128">tür aşağıdaki özelliklerin tümüne sahip olmadığı takdirde bir struct tanımlamaktan KAÇıNıN: ❌</span><span class="sxs-lookup"><span data-stu-id="a3e63-128">❌ AVOID defining a struct unless the type has all of the following characteristics:</span></span>

- <span data-ttu-id="a3e63-129">Temel türler (`int`, `double`, vb.) gibi tek bir değeri mantıksal olarak temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a3e63-129">It logically represents a single value, similar to primitive types (`int`, `double`, etc.).</span></span>

- <span data-ttu-id="a3e63-130">16 baytlık bir örnek boyutu vardır.</span><span class="sxs-lookup"><span data-stu-id="a3e63-130">It has an instance size under 16 bytes.</span></span>

- <span data-ttu-id="a3e63-131">Bu sabittir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-131">It is immutable.</span></span>

- <span data-ttu-id="a3e63-132">Sık olarak kutulanabilir olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="a3e63-132">It will not have to be boxed frequently.</span></span>

 <span data-ttu-id="a3e63-133">Diğer tüm durumlarda türlerinizi sınıflar olarak tanımlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a3e63-133">In all other cases, you should define your types as classes.</span></span>

 <span data-ttu-id="a3e63-134">*© Bölümleri 2005, 2009 Microsoft Corporation. Tüm hakları saklıdır.*</span><span class="sxs-lookup"><span data-stu-id="a3e63-134">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>

 <span data-ttu-id="a3e63-135">*İzni Pearson eğitim, Inc. tarafından yeniden yazdırılmaları [çerçeve tasarım yönergeleri: kuralları, deyimlerini ve yeniden kullanılabilir .NET kitaplıkları, sürüm 2 için desenler](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) Krzysztof Cwalina ve Brad Abrams, 22 Eki 2008 tarafından yayımlanan Microsoft Windows geliştirme serisi bir parçası olarak Addison Wesley Professional.*</span><span class="sxs-lookup"><span data-stu-id="a3e63-135">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>

## <a name="see-also"></a><span data-ttu-id="a3e63-136">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="a3e63-136">See also</span></span>

- [<span data-ttu-id="a3e63-137">Tür Tasarımı Yönergeleri</span><span class="sxs-lookup"><span data-stu-id="a3e63-137">Type Design Guidelines</span></span>](../../../docs/standard/design-guidelines/type.md)
- [<span data-ttu-id="a3e63-138">Çerçeve Tasarım Yönergeleri</span><span class="sxs-lookup"><span data-stu-id="a3e63-138">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)
