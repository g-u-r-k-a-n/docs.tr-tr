---
title: WPF Mimarisi
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: 382facef15e79c4ce49fdedaeb1a072b7591e4a0
ms.sourcegitcommit: 9a97c76e141333394676bc5d264c6624b6f45bcf
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/08/2020
ms.locfileid: "75740216"
---
# <a name="wpf-architecture"></a><span data-ttu-id="279c9-102">WPF Mimarisi</span><span class="sxs-lookup"><span data-stu-id="279c9-102">WPF Architecture</span></span>
<span data-ttu-id="279c9-103">Bu konu, Windows Presentation Foundation (WPF) sınıf hiyerarşisinde kılavuzlu bir tur sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="279c9-104">WPF 'nin büyük alt sistemlerinin çoğunu kapsamakta ve nasıl etkileşime gireceğini anlatmaktadır.</span><span class="sxs-lookup"><span data-stu-id="279c9-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="279c9-105">Ayrıca WPF 'nin mimarları tarafından yapılan seçimlerin bazılarını da ayrıntılarıyla görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="279c9-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="279c9-106">System.Object</span></span>  
 <span data-ttu-id="279c9-107">Birincil WPF programlama modeli, yönetilen kod aracılığıyla sunulur.</span><span class="sxs-lookup"><span data-stu-id="279c9-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="279c9-108">WPF 'nin tasarım aşamasının başlarında, sistemin yönetilen bileşenleri ve yönetilmeyen bileşenler arasında çizginin nerede çizildiğini öğrenmek için bir dizi yorumladığınıza vardı.</span><span class="sxs-lookup"><span data-stu-id="279c9-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="279c9-109">CLR, geliştirmeyi daha üretken ve sağlam hale getirmek (bellek yönetimi, hata işleme, ortak tür sistemi vb. dahil olmak üzere), ancak bir maliyetle karşılaştıkları bir dizi özellik sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="279c9-110">WPF 'nin ana bileşenleri aşağıdaki şekilde gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="279c9-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="279c9-111">Diyagramın kırmızı bölümleri (PresentationFramework, PresentationCore ve milcore) WPF 'nin önemli kod bölümlerinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="279c9-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="279c9-112">Bunlardan yalnızca biri yönetilmeyen bir bileşen-milcore ' dır.</span><span class="sxs-lookup"><span data-stu-id="279c9-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="279c9-113">Milcore, DirectX ile sıkı tümleştirmeyi sağlamak için yönetilmeyen koda yazılır.</span><span class="sxs-lookup"><span data-stu-id="279c9-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="279c9-114">WPF 'deki tüm görüntüler DirectX altyapısı aracılığıyla yapılır, bu da etkili donanım ve yazılım işleme sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="279c9-115">WPF ayrıca bellek ve yürütme üzerinde ince denetim gerektirir.</span><span class="sxs-lookup"><span data-stu-id="279c9-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="279c9-116">Frecore 'daki bileşim altyapısı son derece performansa duyarlıdır ve performans kazanmak için CLR 'nin pek çok avantaj elde etmek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="279c9-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="279c9-117">![.NET Framework içinde WPF 'nin konumu.](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="279c9-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="279c9-118">WPF 'nin yönetilen ve yönetilmeyen kısımları arasındaki iletişim, bu konunun ilerleyen kısımlarında ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="279c9-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="279c9-119">Yönetilen programlama modelinin geri kalanı aşağıda açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="279c9-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="279c9-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="279c9-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="279c9-121">WPF içindeki çoğu nesne, eşzamanlılık ve iş parçacığı oluşturma konusunda temel yapılar sağlayan <xref:System.Windows.Threading.DispatcherObject>'ten türetilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="279c9-122">WPF, dağıtıcı tarafından uygulanan bir mesajlaşma sistemini temel alır.</span><span class="sxs-lookup"><span data-stu-id="279c9-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="279c9-123">Bu, tanıdık Win32 ileti göndericisi gibi çok daha iyi çalışabilir; Aslında, WPF dağıtıcısı çapraz iş parçacığı çağrılarını gerçekleştirmek için User32 iletileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="279c9-124">WPF 'de eşzamanlılık, dağıtıcı ve iş parçacığı benzeşimi ile tartışırken anlaşılması için aslında iki temel kavram vardır.</span><span class="sxs-lookup"><span data-stu-id="279c9-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="279c9-125">WPF 'in tasarım aşamasında, amaç tek bir yürütme iş parçacığına, ancak iş parçacığı olmayan "bir" uyumsuz "modele geçmektir.</span><span class="sxs-lookup"><span data-stu-id="279c9-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="279c9-126">İş parçacığı benzeşimi, bir bileşen bir tür durum depolamak için yürütülen iş parçacığının kimliğini kullandığında oluşur.</span><span class="sxs-lookup"><span data-stu-id="279c9-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="279c9-127">Bunun en yaygın biçimi, durumu depolamak için iş parçacığı yerel deposu (TLS) kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="279c9-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="279c9-128">İş parçacığı benzeşimi, her bir mantıksal iş parçacığının işletim sisteminde yalnızca bir fiziksel iş parçacığından sahip olmasını gerektirir, bu da bellek yoğunluğu haline gelebilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="279c9-129">Son olarak, WPF 'in iş parçacığı modeli, iş parçacığı benzeşimi ile tek iş parçacıklı yürütmenin mevcut User32 iş parçacığı modeliyle eşitlenmiş olarak tutulmuştur.</span><span class="sxs-lookup"><span data-stu-id="279c9-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="279c9-130">Bunun birincil nedeni, birlikte çalışabilirlik – OLE 2,0, pano ve Internet Explorer gibi sistemlerin hepsi tek iş parçacığı benzeşimi (STA) yürütmeyi gerektirir.</span><span class="sxs-lookup"><span data-stu-id="279c9-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="279c9-131">STA iş parçacıklı nesneleriniz olduğundan, iş parçacıkları arasında iletişim kurmak ve doğru iş parçacığında olduğunu doğrulamak için bir yol gerekir.</span><span class="sxs-lookup"><span data-stu-id="279c9-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="279c9-132">Buradaki dağıtıcı rolünü alır.</span><span class="sxs-lookup"><span data-stu-id="279c9-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="279c9-133">Dağıtıcı, birden çok önceliklendirilmiş kuyruğu olan temel bir ileti gönderme sistemidir.</span><span class="sxs-lookup"><span data-stu-id="279c9-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="279c9-134">İleti örnekleri arasında ham giriş bildirimleri (fare taşınan), çerçeve işlevleri (Düzen) veya Kullanıcı komutları (bu yöntemi Yürüt) verilebilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="279c9-135"><xref:System.Windows.Threading.DispatcherObject>türettikten sonra, STA davranışına sahip bir CLR nesnesi oluşturursunuz ve oluşturma zamanında dağıtıcı için bir işaretçi verilecek.</span><span class="sxs-lookup"><span data-stu-id="279c9-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="279c9-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="279c9-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="279c9-137">WPF oluştururken kullanılan birincil mimari felsefeleri, Yöntemler veya olaylar üzerinde özellikler için bir tercihiydi.</span><span class="sxs-lookup"><span data-stu-id="279c9-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="279c9-138">Özellikler bildirime sahiptir ve eylem yerine daha kolay bir amaç belirtmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="279c9-139">Bu, Kullanıcı arabirimi içeriğini görüntülemek için model temelli veya veri odaklı bir sistem de destekliyordu.</span><span class="sxs-lookup"><span data-stu-id="279c9-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="279c9-140">Bu FIN, bir uygulamanın davranışını daha iyi denetlemek için, bağlayacağınız daha fazla özelliği oluşturma amacını taşımaktadır.</span><span class="sxs-lookup"><span data-stu-id="279c9-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="279c9-141">Özelliklerden daha fazlasına sahip olmak için, CLR 'nin sağladığı daha zengin bir özellik sistemi gerekir.</span><span class="sxs-lookup"><span data-stu-id="279c9-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="279c9-142">Bu zenginleştirme için basit bir örnek, değişiklik bildirimlerinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="279c9-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="279c9-143">İki yönlü bağlamayı etkinleştirmek için, bağlantı değişikliği bildirimini destekleyen her iki tarafa de ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="279c9-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="279c9-144">Özellik değerlerine bağlı davranışa sahip olmak için, özellik değeri değiştiğinde bildirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="279c9-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="279c9-145">Microsoft .NET Framework, bir nesnenin değişiklik bildirimlerini yayımlamasına izin veren **INotifyPropertyChange**arabirimine sahiptir, ancak isteğe bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="279c9-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="279c9-146">WPF <xref:System.Windows.DependencyObject> türünden türetilmiş daha zengin bir özellik sistemi sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="279c9-147">Özellik sistemi gerçek anlamda Özellik ifadeleri arasındaki bağımlılıkları izleyen ve bağımlılıklar değiştiğinde özellik değerlerini otomatik olarak yeniden doğrulayan bir "bağımlılık" özellik sistemidir.</span><span class="sxs-lookup"><span data-stu-id="279c9-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="279c9-148">Örneğin, devralınan bir özelliği varsa (<xref:System.Windows.Controls.Control.FontSize%2A>gibi), özelliği değeri devralan bir öğenin üst öğesinde değişirse sistem otomatik olarak güncelleştirilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="279c9-149">WPF özellik sisteminin temeli bir özellik ifadesinin kavramıdır.</span><span class="sxs-lookup"><span data-stu-id="279c9-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="279c9-150">WPF 'in bu ilk sürümünde, özellik ifadesi sistemi kapatılır ve ifadeler Framework 'ün bir parçası olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="279c9-151">İfadeler, özellik sisteminde neden veri bağlama, stil oluşturma veya devralma sabit kodlanmış değil, ancak Framework içindeki daha sonraki katmanlar tarafından sağlanmıyor.</span><span class="sxs-lookup"><span data-stu-id="279c9-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="279c9-152">Özellik sistemi, özellik değerlerinin seyrek depolanması için de sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="279c9-153">Nesneler, özelliklerinde (yüzlerce değilse) bir özellik olabileceğinden ve değerlerin çoğunun varsayılan durumunda (devralınan, stiller, vb.) olması nedeniyle, bir nesnenin her örneğinin, üzerinde tanımlanan her özelliğin tam ağırlığına sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="279c9-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="279c9-154">Özellik sisteminin son yeni özelliği, eklenen özelliklerin kavramından oluşur.</span><span class="sxs-lookup"><span data-stu-id="279c9-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="279c9-155">WPF öğeleri, bileşim ve bileşen yeniden kullanım prensibi temel alınarak oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="279c9-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="279c9-156">Genellikle kapsayan bir öğenin (bir <xref:System.Windows.Controls.Grid> düzeni öğesi gibi), davranışını denetlemek için alt öğelerde ek verilere ihtiyacı vardır (satır/sütun bilgileri gibi).</span><span class="sxs-lookup"><span data-stu-id="279c9-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="279c9-157">Tüm bu özellikleri her öğe ile ilişkilendirmek yerine, herhangi bir nesnenin başka bir nesne için özellik tanımları sağlamasına izin verilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="279c9-158">Bu, JavaScript 'in "özelliği" özelliğine benzer.</span><span class="sxs-lookup"><span data-stu-id="279c9-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="279c9-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="279c9-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="279c9-160">Bir sistem tanımlı olarak, bir sonraki adım ekrana çizilen pikselleri alıyor.</span><span class="sxs-lookup"><span data-stu-id="279c9-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="279c9-161"><xref:System.Windows.Media.Visual> sınıfı, her isteğe bağlı olarak, bu yönergelerin nasıl işlendiğine ilişkin çizim talimatlarını ve meta verileri içeren bir görsel nesne ağacı oluşturmak için sağlar (kırpma, dönüşüm, vb.).</span><span class="sxs-lookup"><span data-stu-id="279c9-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="279c9-162"><xref:System.Windows.Media.Visual> son derece hafif ve esnek olacak şekilde tasarlanmıştır. bu sayede özelliklerin çoğu ortak API pozlaması yoktur ve korumalı geri arama işlevlerini yoğun bir şekilde kullanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="279c9-163"><xref:System.Windows.Media.Visual>, WPF bileşim sistemine gerçekten giriş noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="279c9-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="279c9-164"><xref:System.Windows.Media.Visual>, bu iki alt sistemi, yönetilen API ve yönetilmeyen milcore arasındaki bağlantı noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="279c9-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="279c9-165">WPF, milcore tarafından yönetilen yönetilmeyen veri yapılarına geçiş yaparak verileri görüntüler.</span><span class="sxs-lookup"><span data-stu-id="279c9-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="279c9-166">Kompozisyon düğümleri olarak adlandırılan bu yapılar, her düğümdeki işleme talimatlarıyla hiyerarşik bir görüntüleme ağacını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="279c9-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="279c9-167">Aşağıdaki şeklin sağ tarafında gösterilen bu ağaca yalnızca bir mesajlaşma protokolü aracılığıyla erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="279c9-168">WPF programlama yaparken, bu mesajlaşma protokolü aracılığıyla iç birleşim ağacı ile iletişim kuran <xref:System.Windows.Media.Visual> öğeleri ve türetilmiş türler oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="279c9-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="279c9-169">WPF içindeki her <xref:System.Windows.Media.Visual> bir, hiçbiri veya birkaç bileşim düğümü oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="279c9-170">![Windows Presentation Foundation görsel ağacı.](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="279c9-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="279c9-171">Burada bildirimde bulunan çok önemli bir mimari ayrıntısı vardır: tüm görsellerin ve çizim yönergelerinin tamamı önbelleğe alınır.</span><span class="sxs-lookup"><span data-stu-id="279c9-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="279c9-172">Grafik koşullarında WPF, korunan bir işleme sistemi kullanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="279c9-173">Bu, sistemin, geri çağırmalar üzerinde kullanıcı koduna çağrı yapmadan yüksek yenileme hızlarında yeniden örneklemesinin yapılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="279c9-174">Bu, yanıt vermeyen bir uygulamanın görünümünü önlemeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="279c9-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="279c9-175">Diyagramda gerçekten fark olmayan önemli bir ayrıntı, sistemin aslında oluşturma işlemini nasıl gerçekleştirdiğine ilişkin bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="279c9-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="279c9-176">User32 ve GDI 'da sistem, bir anlık mod kırpma sisteminde çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="279c9-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="279c9-177">Bir bileşenin işlenmesi gerektiğinde, sistem, bileşenin piksellere dokunmasına izin verilmeyen bir kırpma sınırları oluşturur ve ardından bileşene bu kutudaki pikselleri boyamak istenir.</span><span class="sxs-lookup"><span data-stu-id="279c9-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="279c9-178">Bu sistem, yalnızca etkilenen bileşene dokunmanız gerektiğinde hiçbir değişiklik yapıldığında, her zaman tek bir pikselin rengine katkıda bulunmadığı için bellek kısıtlı sistemlerde çok iyi çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="279c9-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="279c9-179">WPF, "boyacısı 'nın algoritması" boyama modelini kullanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="279c9-180">Bu, her bir bileşenin kırpılması yerine her bileşenin geri dönerek ekran önüne işlenmesi istenir.</span><span class="sxs-lookup"><span data-stu-id="279c9-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="279c9-181">Bu, her bir bileşenin önceki bileşenin görüntüsüne göre boyamasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="279c9-182">Bu modelin avantajı karmaşık, kısmen saydam şekillere sahip olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="279c9-183">Günümüzün modern grafik donanımıyla, bu model görece hızlıdır (User32/GDI oluşturulduğunda bu durum değildir).</span><span class="sxs-lookup"><span data-stu-id="279c9-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="279c9-184">Daha önce belirtildiği gibi, WPF 'nin çekirdek felseı daha bildirime dayalı, "Özellik merkezli" programlama modeline geçmektedir.</span><span class="sxs-lookup"><span data-stu-id="279c9-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="279c9-185">Görsel sistemde bu, birkaç ilginç yerde görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="279c9-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="279c9-186">İlk olarak, korunan mod grafik sistemi hakkında düşündüğünüzde bu aslında kesin bir DrawLine/DrawLine tür modelinden veri yönelimli bir modele (yeni satır ()/New Line () kadar geçiş yapılmakta.</span><span class="sxs-lookup"><span data-stu-id="279c9-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="279c9-187">Veri odaklı işleme taşıma, çizim yönergelerindeki karmaşık işlemlere özellikler kullanılarak ifade yapılmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="279c9-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="279c9-188"><xref:System.Windows.Media.Drawing> türetilen türler, işleme için nesne modelidir.</span><span class="sxs-lookup"><span data-stu-id="279c9-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="279c9-189">İkinci olarak, animasyon sistemini değerlendirdiğiniz takdirde neredeyse tamamen bildirime dayalı olduğunu görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="279c9-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="279c9-190">Bir geliştiricinin bir sonraki konumu veya bir sonraki rengi hesaplamasını gerektirmek yerine, animasyonları bir animasyon nesnesi üzerinde özellikler kümesi olarak ifade edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="279c9-191">Bu animasyonlar daha sonra geliştirici veya tasarımcı amacını ifade edebilir (bu düğmeyi 5 saniye içinde buraya taşıyın) ve sistem bunu gerçekleştirmek için en verimli yolu belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="279c9-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="279c9-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="279c9-193"><xref:System.Windows.UIElement> düzen, giriş ve olaylar dahil olmak üzere çekirdek alt sistemlerini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="279c9-194">Düzen, WPF 'de temel bir kavramdır.</span><span class="sxs-lookup"><span data-stu-id="279c9-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="279c9-195">Birçok sistemde, sabit bir düzen modeli kümesi vardır (HTML, düzen için üç modeli destekler; Flow, mutlak ve tablolar) ya da düzen için model yoktur (User32 gerçekten mutlak konumlandırmayı destekler).</span><span class="sxs-lookup"><span data-stu-id="279c9-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="279c9-196">WPF, geliştiricilerin ve tasarımcıların, kesinlik mantığı yerine özellik değerleri tarafından yönetilen esnek, genişletilebilir bir düzen modeli istediği varsayımıyla başladı.</span><span class="sxs-lookup"><span data-stu-id="279c9-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="279c9-197"><xref:System.Windows.UIElement> düzeyinde, düzen için temel sözleşme, <xref:System.Windows.UIElement.Measure%2A> ve <xref:System.Windows.UIElement.Arrange%2A> geçişleri olan iki aşamalı bir modeldir.</span><span class="sxs-lookup"><span data-stu-id="279c9-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="279c9-198"><xref:System.Windows.UIElement.Measure%2A>, bir bileşenin ne kadar boyutta gelmesi gerektiğini belirlemesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="279c9-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="279c9-199">Bir üst öğenin en iyi konumunu ve boyutunu belirlemesi için birkaç kez bir alt öğe ölçmesini isteyeceğinden, bu <xref:System.Windows.UIElement.Arrange%2A> ayrı bir aşamadır.</span><span class="sxs-lookup"><span data-stu-id="279c9-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="279c9-200">Üst öğelerin ölçü için alt öğelere sormasını gerektiren olgu, WPF 'nin başka bir önemli felsefını içeriğe göre boyutlanacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="279c9-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="279c9-201">WPF 'deki tüm denetimler içeriklerinin doğal boyutuna göre boyut yeteneğini destekler.</span><span class="sxs-lookup"><span data-stu-id="279c9-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="279c9-202">Bu, yerelleştirmeyi çok daha kolay hale getirir ve öğelerin yeniden boyutlandırılması halinde dinamik düzen oluşturulmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="279c9-203"><xref:System.Windows.UIElement.Arrange%2A> aşaması üst öğenin, her bir alt öğenin son boyutunu değiştirmesine ve belirlemesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="279c9-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="279c9-204">Çoğu zaman WPF – <xref:System.Windows.Media.Visual> ve ilgili nesnelerin çıkış tarafı hakkında konuşuyor.</span><span class="sxs-lookup"><span data-stu-id="279c9-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="279c9-205">Ancak giriş tarafında çok fazla yenilik de vardır.</span><span class="sxs-lookup"><span data-stu-id="279c9-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="279c9-206">WPF için giriş modelinde en temel değişiklik büyük olasılıkla, giriş olaylarının sistem aracılığıyla yönlendirildiği tutarlı modeldir.</span><span class="sxs-lookup"><span data-stu-id="279c9-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="279c9-207">Giriş, bir çekirdek modu cihaz sürücüsünde sinyal olarak gelir ve Windows çekirdeği ve User32 ile ilgili karmaşık bir süreç aracılığıyla doğru işleme ve iş parçacığına yönlendirilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="279c9-208">Girişe karşılık gelen User32 iletisi WPF 'e yönlendirildikten sonra WPF ham giriş iletisine dönüştürülür ve dağıtıcıya gönderilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="279c9-209">WPF, ham giriş olaylarının birden çok gerçek olaya dönüştürülmesini sağlar ve bu sayede "MouseEnter" gibi özelliklerin, garantili teslimin bulunduğu düşük düzeyde sisteme uygulanması sağlanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="279c9-210">Her giriş olayı en az iki olaya dönüştürülür: bir "Önizleme" olayı ve gerçek olay.</span><span class="sxs-lookup"><span data-stu-id="279c9-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="279c9-211">WPF 'deki tüm olayların, öğe ağacı aracılığıyla yönlendirme kavramı vardır.</span><span class="sxs-lookup"><span data-stu-id="279c9-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="279c9-212">Olaylar, bir hedeften köke kadar geziniyorlarsa "kabarcık" olarak bildirilir ve kökte başlayıp bir hedefe geçiş yaptıysanız "tünel" olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="279c9-213">Giriş önizleme olayları tüneli, ağaçtaki herhangi bir öğenin olayı filtreleme veya eylem üzerinde işlem yapması için bir fırsat sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="279c9-214">Normal (Önizleme dışı) olaylar bundan sonra hedeften köke kadar kabarcık sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="279c9-215">Bu, tünel ve kabarcık aşaması arasında bölünen, klavye hızlandırıcıları gibi özelliklerin uygulanması bileşik bir dünyada tutarlı bir biçimde çalışır.</span><span class="sxs-lookup"><span data-stu-id="279c9-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="279c9-216">User32 ' de, desteklemek istediğiniz tüm Hızlandırıcılar içeren tek bir genel tabloya sahip olarak klavye hızlandırıcılarını (CTRL + N "yeni" ile eşleme) uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="279c9-217">Uygulamanıza yönelik dağıtıcıda, User32 'deki giriş iletilerini saptayabilir ve herhangi bir kayıtlı hızlandırıcı ile eşleşen bir hızlandırıcının olduğunu tespit eden **TranslateAccelerator** öğesini çağırırdı.</span><span class="sxs-lookup"><span data-stu-id="279c9-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="279c9-218">WPF 'de, sistem tamamen "birleştirilebilen" olduğundan çalışmaz; herhangi bir öğe herhangi bir klavye hızlandırıcıyı işleyebilir ve kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="279c9-219">Bu iki aşama modelinin giriş için olması, bileşenlerin kendi "TranslateAccelerator" uygulamasını uygulamasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="279c9-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="279c9-220">Bu adımı daha fazla yapmak için, <xref:System.Windows.UIElement> CommandBindings kavramını da tanıtır.</span><span class="sxs-lookup"><span data-stu-id="279c9-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="279c9-221">WPF komut sistemi, geliştiricilerin bir komut uç noktası açısından işlevselliği tanımlamasına olanak tanır. <xref:System.Windows.Input.ICommand>uygulayan bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="279c9-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="279c9-222">Komut bağlamaları bir giriş hareketi (CTRL + N) ile bir komut (yeni) arasında eşleme tanımlamak için bir öğe etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="279c9-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="279c9-223">Hem giriş hareketleri hem de komut tanımları genişletilebilir ve kullanım zamanında birbirine bağlanabilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="279c9-224">Bu, örneğin, son kullanıcının bir uygulama içinde kullanmak istedikleri anahtar bağlamalarını özelleştirmesini sağlamak gibi basit hale getirir.</span><span class="sxs-lookup"><span data-stu-id="279c9-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="279c9-225">Bu noktaya kadar, WPF 'nin "çekirdek" özellikleri – PresentationCore derlemesinde uygulanan özellikler odağa sahiptir.</span><span class="sxs-lookup"><span data-stu-id="279c9-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="279c9-226">WPF oluştururken, temel parçalar ( **Ölçü** ve **düzenleme**ile düzen için anlaşma gibi) ve çerçeve parçaları (<xref:System.Windows.Controls.Grid>gibi belirli bir düzenin uygulanması gibi) arasında temiz bir ayrım, istenen sonuç idi.</span><span class="sxs-lookup"><span data-stu-id="279c9-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="279c9-227">Amaç, bir yığında düşük bir genişletilebilirlik noktası sağlamaktır. Bu, dış geliştiricilerin gerekirse kendi çerçevelerini oluşturmalarına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="279c9-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="279c9-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="279c9-229"><xref:System.Windows.FrameworkElement>, iki farklı şekilde aranabilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="279c9-230">WPF 'nin alt katmanlarında tanıtılan alt sistemler üzerinde bir ilke ve özelleştirme kümesi sunar.</span><span class="sxs-lookup"><span data-stu-id="279c9-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="279c9-231">Ayrıca yeni alt sistemler kümesi de sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="279c9-232"><xref:System.Windows.FrameworkElement> tarafından tanıtılan birincil ilke, uygulama düzeni etrafında.</span><span class="sxs-lookup"><span data-stu-id="279c9-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="279c9-233"><xref:System.Windows.FrameworkElement>, <xref:System.Windows.UIElement> tarafından tanıtılan temel düzen sözleşmesinde yapılar ve düzen yazarlarının bir dizi özellik temelli düzen semantiğini daha kolay hale getiren bir "yuva" düzeni kavramı ekler.</span><span class="sxs-lookup"><span data-stu-id="279c9-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="279c9-234"><xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>ve <xref:System.Windows.FrameworkElement.Margin%2A> gibi Özellikler (bir ad vermek için), tüm bileşenlere, Düzen kapsayıcıları içindeki <xref:System.Windows.FrameworkElement> tutarlı bir davranışdan türetilmiş tüm bileşenleri verir.</span><span class="sxs-lookup"><span data-stu-id="279c9-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="279c9-235"><xref:System.Windows.FrameworkElement> Ayrıca WPF 'nin temel katmanlarında bulunan birçok özelliğe daha kolay API pozlaması sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="279c9-236">Örneğin, <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> yöntemi aracılığıyla animasyonuna doğrudan erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="279c9-237"><xref:System.Windows.Media.Animation.Storyboard>, bir dizi özellik için birden çok animasyonları betiğe yönelik bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="279c9-238"><xref:System.Windows.FrameworkElement> tanıtılmakta olan en önemli iki şey veri bağlama ve stillerdir.</span><span class="sxs-lookup"><span data-stu-id="279c9-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="279c9-239">WPF 'deki veri bağlama alt sistemi, uygulama [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]oluşturmak için [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] veya ASP.NET kullanan herkese görece tanıdık olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="279c9-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="279c9-240">Bu sistemlerin her birinde, belirli bir öğeden bir veya daha fazla özelliği bir veri parçasına bağlamak istediğinizi ifade etmek için basit bir yol vardır.</span><span class="sxs-lookup"><span data-stu-id="279c9-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="279c9-241">WPF özellik bağlama, dönüştürme ve liste bağlama için tam desteğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="279c9-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="279c9-242">WPF 'deki veri bağlamasının en ilginç özelliklerinden biri veri şablonlarının sunumlarıdır.</span><span class="sxs-lookup"><span data-stu-id="279c9-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="279c9-243">Veri şablonları, verilerin bir parçasının görselleştirme şeklini bildirimli olarak belirtmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="279c9-244">Verilere bağlanabilen özel bir kullanıcı arabirimi oluşturmak yerine, bunun yerine sorunu açıp verilerin oluşturulacak görüntüyü belirlemesine izin verebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="279c9-245">Stil oluşturma aslında veri bağlamanın hafif bir biçimidir.</span><span class="sxs-lookup"><span data-stu-id="279c9-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="279c9-246">Stil oluşturma kullanarak, paylaşılan bir tanımdan bir veya daha fazla öğe örneğine bir özellik kümesi bağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="279c9-247">Stiller bir öğeye açık başvuruya göre (<xref:System.Windows.FrameworkElement.Style%2A> özelliği ayarlanarak) veya bir stili öğenin CLR türüyle ilişkilendirerek dolaylı olarak uygulanır.</span><span class="sxs-lookup"><span data-stu-id="279c9-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="279c9-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="279c9-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="279c9-249">Denetimin en önemli özelliği şablon oluşturma ' dır.</span><span class="sxs-lookup"><span data-stu-id="279c9-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="279c9-250">WPF 'in bileşim sistemini bir tutulan mod işleme sistemi olarak düşünüyorsanız, şablon oluşturma bir denetimin işlemesini parametreli, bildirime dayalı bir şekilde açıklamaya olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="279c9-251">Bir <xref:System.Windows.Controls.ControlTemplate>, bir alt öğe kümesi oluşturmak için bir betikten fazla değil, denetimin sunduğu özelliklerin bağlamalarıyla birlikte.</span><span class="sxs-lookup"><span data-stu-id="279c9-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="279c9-252"><xref:System.Windows.Controls.Control>, bazı şablon yazarlarının bir denetimin görüntülenmesini özelleştirmek için kullanabileceği bir dizi hisse senedi özelliği, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="279c9-253">Bir denetimin uygulanması bir veri modeli ve etkileşim modeli sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="279c9-254">Etkileşim modeli, giriş hareketlerine (pencerenin üst köşesindeki kırmızı X simgesine tıklanması gibi) bir dizi komut (pencere için yakın) ve bağlamalar tanımlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="279c9-255">Veri modeli, etkileşim modelini özelleştirmek veya görüntülemeyi özelleştirmek (şablon tarafından belirlenir) için bir özellikler kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="279c9-256">Veri modeli (Özellikler), etkileşim modeli (komutlar ve olaylar) ve görüntüleme modeli (şablonlar) arasında bölünen bu, bir denetimin görünüm ve davranışının tamamen özelleştirilmesine izin vermez.</span><span class="sxs-lookup"><span data-stu-id="279c9-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="279c9-257">Denetimlerin veri modelinin ortak bir yönü, içerik modelidir.</span><span class="sxs-lookup"><span data-stu-id="279c9-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="279c9-258"><xref:System.Windows.Controls.Button>gibi bir denetime bakarsanız, <xref:System.Object>türünün "Içerik" adlı bir özelliğe sahip olduğunu görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="279c9-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="279c9-259">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] ve ASP.NET içinde, bu özellik genellikle bir dize olur, ancak bir düğmeye koyabileceğiniz içerik türünü sınırlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="279c9-260">Bir düğmenin içeriği basit bir dize, karmaşık veri nesnesi veya bir öğe ağacının tamamı olabilir.</span><span class="sxs-lookup"><span data-stu-id="279c9-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="279c9-261">Veri nesnesi söz konusu olduğunda, veri şablonu bir görüntü oluşturmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="279c9-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="279c9-262">Özet</span><span class="sxs-lookup"><span data-stu-id="279c9-262">Summary</span></span>  
 <span data-ttu-id="279c9-263">WPF, dinamik, veri odaklı sunum sistemleri oluşturmanıza olanak tanımak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="279c9-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="279c9-264">Sistemin her bölümü, davranışını oluşturan özellik kümeleri aracılığıyla nesne oluşturmak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="279c9-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="279c9-265">Veri bağlama, sistemin temel bir parçasıdır ve her katmanda tümleşiktir.</span><span class="sxs-lookup"><span data-stu-id="279c9-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="279c9-266">Geleneksel uygulamalar bir görüntü oluşturup daha sonra bazı verilere bağlar.</span><span class="sxs-lookup"><span data-stu-id="279c9-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="279c9-267">WPF 'de, denetimle ilgili her şey, her bir veri bağlama türü tarafından oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="279c9-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="279c9-268">Düğme içinde bulunan metin, düğmenin içinde oluşturulan bir denetim oluşturularak ve görünümünü düğmenin içerik özelliğine bağlayarak görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="279c9-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="279c9-269">WPF tabanlı uygulamalar geliştirmeye başladığınızda çok tanıdık gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="279c9-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="279c9-270">[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] veya ASP.NET kullanarak özellikleri, nesneleri ve veri bağlamayı birçok şekilde ayarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-270">You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or ASP.NET.</span></span> <span data-ttu-id="279c9-271">WPF mimarisine daha derin bir araştırma sayesinde, uygulamanın çekirdek sürücüsü olarak verileri temel alan çok daha zengin uygulamalar oluşturmak için bir olasılık olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="279c9-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="279c9-272">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="279c9-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="279c9-273">Veri Bağlamaya Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="279c9-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="279c9-274">Düzen</span><span class="sxs-lookup"><span data-stu-id="279c9-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="279c9-275">Animasyona Genel bakış</span><span class="sxs-lookup"><span data-stu-id="279c9-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
