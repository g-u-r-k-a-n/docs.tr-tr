---
title: EventWaitHandle
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 80c90254978495a58d228c4302eda84d6165c800
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "73138070"
---
# <a name="eventwaithandle"></a><span data-ttu-id="bc297-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="bc297-102">EventWaitHandle</span></span>
<span data-ttu-id="bc297-103">Sınıf, <xref:System.Threading.EventWaitHandle> iş parçacıklarının sinyal vererek ve sinyalleri bekleyerek birbirleriyle iletişim kurmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="bc297-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="bc297-104">Olay bekleme tutamaçları (yalnızca olaylar olarak da adlandırılır) bir veya daha fazla bekleyen iş parçacığı serbest bırakmak için sinyal verilebilen bekleme tutamaçlarıdır.</span><span class="sxs-lookup"><span data-stu-id="bc297-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="bc297-105">Sinyal edildikten sonra, olay bekleme tutamacı el ile veya otomatik olarak sıfırlanır.</span><span class="sxs-lookup"><span data-stu-id="bc297-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="bc297-106">Sınıf, <xref:System.Threading.EventWaitHandle> yerel bir olay bekleme tanıtıcısını (yerel olay) veya adlandırılmış bir sistem olayı bekleme tutamacını (adı verilen olay veya sistem olayı, tüm işlemler tarafından görülebilir) temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bc297-107">Olay bekleme tutamaçları .NET [olayları](../events/index.md)değildir.</span><span class="sxs-lookup"><span data-stu-id="bc297-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="bc297-108">İşin içinde temsilci veya olay işleyicisi yok.</span><span class="sxs-lookup"><span data-stu-id="bc297-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="bc297-109">"Olay" sözcüğü, geleneksel olarak işletim sistemi olayları olarak adlandırıldıkları ve bekleme tutamacını işaret etme eylemi bir olayın oluştuğunu bekleyen iş parçacıklarına işaret ettiği için bunları tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="bc297-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="bc297-110">Hem yerel hem de adlandırılmış olay bekleme işleyicileri, <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> kaynakların serbest bırakılmasını sağlamak için sarmalayıcılar tarafından korunan sistem eşitleme nesnelerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="bc297-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="bc297-111">Nesneyi <xref:System.Threading.WaitHandle.Dispose%2A> kullanmayı bitirdiğinizde kaynakları hemen serbest etmek için yöntemi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bc297-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="bc297-112">Otomatik Olarak Sıfırlanan Olay Bekleme Tutamaçları</span><span class="sxs-lookup"><span data-stu-id="bc297-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="bc297-113">Nesneyi ne zaman oluşturduğunuzu <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> belirterek otomatik sıfırlama olayı oluşturursunuz. <xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="bc297-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="bc297-114">Adından da anlaşılacağı gibi, bu eşitleme olayı tek bir bekleme iş parçacığı yayımladıktan sonra, sinyal verildiğinde otomatik olarak sıfırlanır.</span><span class="sxs-lookup"><span data-stu-id="bc297-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="bc297-115">Yöntemini çağırarak <xref:System.Threading.EventWaitHandle.Set%2A> olayı işaret edin.</span><span class="sxs-lookup"><span data-stu-id="bc297-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="bc297-116">Otomatik sıfırlama olayları genellikle aynı anda tek bir iş parçacığı için bir kaynağa özel erişim sağlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="bc297-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="bc297-117">Bir iş parçacığı <xref:System.Threading.WaitHandle.WaitOne%2A> yöntemi çağırarak kaynak ister.</span><span class="sxs-lookup"><span data-stu-id="bc297-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="bc297-118">Bekleme tutamacını başka bir iş parçacığı `true` tutmuyorsa, yöntem döndürür ve arama iş parçacığı kaynağın denetimine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="bc297-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="bc297-119">Tüm eşitleme mekanizmalarında olduğu gibi, korumalı bir kaynağa erişmeden önce tüm kod yollarının uygun bekleme tanıtıcıda beklediğinden emin olmalısınız.</span><span class="sxs-lookup"><span data-stu-id="bc297-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="bc297-120">İş parçacığı senkronizasyonu işbirliği dir.</span><span class="sxs-lookup"><span data-stu-id="bc297-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="bc297-121">İş parçacığı beklemezken otomatik sıfırlama olayı sinyal verirken, bir iş parçacığı üzerinde beklemeye çalışana kadar sinyal olarak kalır.</span><span class="sxs-lookup"><span data-stu-id="bc297-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="bc297-122">Olay iş parçacığı bültenleri ve hemen sıfırlar, sonraki iş parçacığı engelleme.</span><span class="sxs-lookup"><span data-stu-id="bc297-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="bc297-123">Olay Bekle Handles Bu Sıfırlama El Ile</span><span class="sxs-lookup"><span data-stu-id="bc297-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="bc297-124">Nesneyi ne zaman oluşturduğunuzu <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> belirterek el ile sıfırlama olayı oluşturursunuz. <xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="bc297-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="bc297-125">Adından da anlaşılacağı gibi, bu eşitleme olayı sinyal verildikten sonra el ile sıfırlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="bc297-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="bc297-126">Sıfırlanana kadar, <xref:System.Threading.EventWaitHandle.Reset%2A> yöntemini arayarak, olay tutamacında bekleyen iş parçacıkları engellenmeden hemen devam eder.</span><span class="sxs-lookup"><span data-stu-id="bc297-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="bc297-127">El ile sıfırlama olayı bir ağıl kapısı gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="bc297-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="bc297-128">Olay sinyal verilmediğinde, ağıldaki atlar gibi blokta bekleyen iplikler.</span><span class="sxs-lookup"><span data-stu-id="bc297-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="bc297-129">Olay sinyal verildiğinde, <xref:System.Threading.EventWaitHandle.Set%2A> yöntemini çağırarak, tüm bekleyen iş parçacıkları devam etmek için ücretsizdir.</span><span class="sxs-lookup"><span data-stu-id="bc297-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="bc297-130">Olay, yöntemi çağrılana <xref:System.Threading.EventWaitHandle.Reset%2A> kadar sinyal olarak kalır.</span><span class="sxs-lookup"><span data-stu-id="bc297-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="bc297-131">Bu, el ile sıfırlama olayını, bir iş parçacığı görevi bitirene kadar beklemesi gereken iş parçacıklarını tutmak için ideal bir yol haline getirir.</span><span class="sxs-lookup"><span data-stu-id="bc297-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="bc297-132">Ağıldan çıkan atlar gibi, serbest bırakılan iş parçacıklarının işletim sistemi tarafından zamanlanması ve yürütmeye devam edilmesi zaman alır.</span><span class="sxs-lookup"><span data-stu-id="bc297-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="bc297-133"><xref:System.Threading.EventWaitHandle.Reset%2A> Tüm iş parçacıkları yürütme devam etmeden önce yöntem çağrılırsa, kalan iş parçacıkları bir kez daha blok.</span><span class="sxs-lookup"><span data-stu-id="bc297-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="bc297-134">Hangi iş parçacıkları devam eder ve hangi iş parçacıkları bloğu sistemdeki yük, zamanlayıcıyı bekleyen iş parçacığı sayısı ve benzeri gibi rasgele etkenlere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="bc297-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="bc297-135">Olayı işaret eden iş parçacığı sinyalden sonra sona ererse, en yaygın kullanım deseni bu sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="bc297-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="bc297-136">Tüm bekleyen iş parçacıkları devam ettikten sonra olay sinyali veren iş parçacığının yeni bir göreve başlamasını istiyorsanız, tüm bekleyen iş parçacıkları devam edene kadar bunu engellemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="bc297-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="bc297-137">Aksi takdirde, bir Yarış koşulu var ve koddavranış öngörülemeyen.</span><span class="sxs-lookup"><span data-stu-id="bc297-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="bc297-138">Otomatik ve Manuel Etkinliklerde Ortak Özellikler</span><span class="sxs-lookup"><span data-stu-id="bc297-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="bc297-139">Genellikle, engellenmemiş bir iş parçacığı <xref:System.Threading.EventWaitHandle> bekleyen iş parçacığı (otomatik sıfırlama olayları durumunda) veya hepsi (el ile sıfırlama olayları durumunda) bültenleri <xref:System.Threading.EventWaitHandle.Set%2A> yöntemi çağıran kadar bir veya daha fazla iş parçacığı blok.</span><span class="sxs-lookup"><span data-stu-id="bc297-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="bc297-140">Bir iş parçacığı <xref:System.Threading.EventWaitHandle> statik <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> yöntemi çağırarak, atomik bir işlem olarak bir sinyal ve sonra onu bloke edebilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="bc297-141"><xref:System.Threading.EventWaitHandle>nesneler statik <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> ve <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> yöntemlerle kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="bc297-142">Hem <xref:System.Threading.EventWaitHandle> sınıflar <xref:System.Threading.Mutex> hem de <xref:System.Threading.WaitHandle>sınıflar bu yöntemlerle her iki sınıfı da kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bc297-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="bc297-143">Adlandırılmış Etkinlikler</span><span class="sxs-lookup"><span data-stu-id="bc297-143">Named Events</span></span>  
 <span data-ttu-id="bc297-144">Windows işletim sistemi olay bekleme tutamaçlarının adlara sahip olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="bc297-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="bc297-145">Adlandırılmış bir olay sistem genelindedir.</span><span class="sxs-lookup"><span data-stu-id="bc297-145">A named event is system wide.</span></span> <span data-ttu-id="bc297-146">Diğer bir deyişle, adlandırılmış olay oluşturulduktan sonra, tüm işlemlerdeki tüm iş parçacıkları tarafından görülebilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="bc297-147">Böylece, adlandırılmış olaylar iş parçacıkları nın yanı sıra işlemlerin etkinliklerini eşitlemek için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="bc297-148">Bir olay <xref:System.Threading.EventWaitHandle> adını belirten oluşturuculardan birini kullanarak adlandırılmış bir sistem olayını temsil eden bir nesne oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bc297-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bc297-149">Adlandırılmış olaylar sistem genelinde olduğundan, aynı <xref:System.Threading.EventWaitHandle> adlı olayı temsil eden birden çok nesne olması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="bc297-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="bc297-150">Bir oluşturucuyu veya <xref:System.Threading.EventWaitHandle.OpenExisting%2A> yöntemi her çağırdığınızda yeni <xref:System.Threading.EventWaitHandle> bir nesne oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="bc297-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="bc297-151">Aynı adı belirtme, aynı adı taşıyan olayı temsil eden birden çok nesne oluşturur.</span><span class="sxs-lookup"><span data-stu-id="bc297-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="bc297-152">Adlandırılmış olayları kullanırken dikkatli olunması önerilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-152">Caution is advised in using named events.</span></span> <span data-ttu-id="bc297-153">Sistem genelinde olduklarından, aynı adı kullanan başka bir işlem iş parçacığınızı beklenmedik bir şekilde engelleyebilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="bc297-154">Aynı bilgisayarda çalıştırılabilen kötü amaçlı kod, bunu hizmet reddi saldırısının temeli olarak kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="bc297-155">Adlandırılmış bir olayı <xref:System.Threading.EventWaitHandle> temsil eden bir nesneyi korumak için erişim denetimi güvenliğini <xref:System.Security.AccessControl.EventWaitHandleSecurity> kullanın, tercihen bir nesne belirten bir oluşturucu kullanarak.</span><span class="sxs-lookup"><span data-stu-id="bc297-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="bc297-156"><xref:System.Threading.EventWaitHandle.SetAccessControl%2A> Bu yöntemkullanarak erişim denetimi güvenliği de uygulayabilirsiniz, ancak bu olay bekleme tanıtıcısı oluşturulduğu zaman ve korunduğu zaman arasında bir güvenlik açığı penceresi bırakır.</span><span class="sxs-lookup"><span data-stu-id="bc297-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="bc297-157">Olayları erişim denetimi güvenliğiyle korumak kötü amaçlı saldırıları önlemeye yardımcı olur, ancak istenmeyen ad çakışmasorununu çözmez.</span><span class="sxs-lookup"><span data-stu-id="bc297-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bc297-158"><xref:System.Threading.EventWaitHandle> Sınıfın aksine, türetilmiş sınıflar <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent> yalnızca yerel bekleme tutamaçları temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="bc297-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="bc297-159">Adlandırılmış sistem olaylarını temsil edemezler.</span><span class="sxs-lookup"><span data-stu-id="bc297-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bc297-160">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="bc297-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
