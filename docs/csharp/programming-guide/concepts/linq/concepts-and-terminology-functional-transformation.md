---
title: Kavramlar ve Terminoloji (Fonksiyonel Dönüşüm) (C#)
ms.date: 07/20/2015
ms.assetid: 03defb3a-7e17-4ab1-8efa-4dd66621e860
ms.openlocfilehash: 3e2ecc4c2f70700ae92ee36b6f122059b922332e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "70040628"
---
# <a name="concepts-and-terminology-functional-transformation-c"></a><span data-ttu-id="9829e-102">Kavramlar ve Terminoloji (Fonksiyonel Dönüşüm) (C#)</span><span class="sxs-lookup"><span data-stu-id="9829e-102">Concepts and Terminology (Functional Transformation) (C#)</span></span>

<span data-ttu-id="9829e-103">Bu konu, saf işlevsel dönüşümlerin kavramlarını ve terminolojisini tanımaktadır.</span><span class="sxs-lookup"><span data-stu-id="9829e-103">This topic introduces the concepts and terminology of pure functional transformations.</span></span> <span data-ttu-id="9829e-104">Veri dönüştürmeiçin işlevsel dönüşüm yaklaşımı, genellikle programa daha hızlı, daha anlamlı ve hata ayıklama ve daha geleneksel, zorunlu programlama daha korumak daha kolay kod verir.</span><span class="sxs-lookup"><span data-stu-id="9829e-104">The functional transformation approach to transforming data yields code that is often quicker to program, more expressive, and easier to debug and maintain than more traditional, imperative programming.</span></span>

<span data-ttu-id="9829e-105">Bu bölümdeki konuların işlevsel programlamayı tam olarak açıklamak için tasarlanmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="9829e-105">Note that the topics in this section are not intended to fully explain functional programming.</span></span> <span data-ttu-id="9829e-106">Bunun yerine, bu konular, XML'i bir şekilden diğerine dönüştürmeyi kolaylaştıran bazı işlevsel programlama özelliklerini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="9829e-106">Instead, these topics identify some of the functional programming capabilities that make it easier to transform XML from one shape to another.</span></span>

## <a name="what-is-pure-functional-transformation"></a><span data-ttu-id="9829e-107">Saf Fonksiyonel Dönüşüm Nedir?</span><span class="sxs-lookup"><span data-stu-id="9829e-107">What Is Pure Functional Transformation?</span></span>

<span data-ttu-id="9829e-108">*Saf işlevsel dönüşümde,* *saf işlevler*olarak adlandırılan bir dizi işlev, yapılandırılmış bir veri kümesinin orijinal formundan başka bir forma nasıl dönüştürüldüğünü tanımlar.</span><span class="sxs-lookup"><span data-stu-id="9829e-108">In *pure functional transformation*, a set of functions, called *pure functions*, define how to transform a set of structured data from its original form into another form.</span></span> <span data-ttu-id="9829e-109">"Saf" sözcüğü, işlevlerin *birleştirilebilir*olduğunu ve bunların bir arada olduğunu gösterir:</span><span class="sxs-lookup"><span data-stu-id="9829e-109">The word "pure" indicates that the functions are *composable*, which requires that they are:</span></span>

- <span data-ttu-id="9829e-110">*Kendi kendine yeten*, böylece serbestçe sipariş ve programın geri kalanı ile dolaşıklık veya karşılıklı bağımlılık olmadan yeniden düzenlenebilir.</span><span class="sxs-lookup"><span data-stu-id="9829e-110">*Self-contained*, so that they can be freely ordered and rearranged without entanglement or interdependencies with the rest of the program.</span></span> <span data-ttu-id="9829e-111">Saf dönüşümlerin çevreleri hakkında hiçbir bilgisi veya etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="9829e-111">Pure transformations have no knowledge of or effect upon their environment.</span></span> <span data-ttu-id="9829e-112">Yani dönüşümde kullanılan işlevlerin *hiçbir yan etkisi*yoktur.</span><span class="sxs-lookup"><span data-stu-id="9829e-112">That is, the functions used in the transformation have no *side effects*.</span></span>

- <span data-ttu-id="9829e-113">*Stateless*, böylece aynı işlev veya aynı giriş üzerinde işlevleri belirli bir dizi yürütme her zaman aynı çıktı neden olur.</span><span class="sxs-lookup"><span data-stu-id="9829e-113">*Stateless*, so that executing the same function or specific set of functions on the same input will always result in the same output.</span></span> <span data-ttu-id="9829e-114">Saf dönüşümler, önceki kullanımları hakkında hiçbir belleğe sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="9829e-114">Pure transformations have no memory of their prior use.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="9829e-115">Bu öğreticinin geri kalanında, "saf işlev" terimi, belirli bir dil özelliğini değil, programlama yaklaşımını belirtmek için genel anlamda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9829e-115">In the rest of this tutorial, the term "pure function" is used in a general sense to indicate a programming approach, and not a specific language feature.</span></span>
>
> <span data-ttu-id="9829e-116">Saf işlevlerin C#'da yöntem olarak uygulanması gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="9829e-116">Note that pure functions must be implemented as methods in C#.</span></span>
>
> <span data-ttu-id="9829e-117">Ayrıca, saf işlevleri C++'da saf sanal yöntemlerle karıştırmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="9829e-117">Also, you should not confuse pure functions with pure virtual methods in C++.</span></span> <span data-ttu-id="9829e-118">İkincisi, içeren sınıfın soyut olduğunu ve hiçbir yöntem gövdesinin sağlanolmadığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="9829e-118">The latter indicates that the containing class is abstract and that no method body is supplied.</span></span>

### <a name="functional-programming"></a><span data-ttu-id="9829e-119">Fonksiyonel Programlama</span><span class="sxs-lookup"><span data-stu-id="9829e-119">Functional Programming</span></span>

<span data-ttu-id="9829e-120">*İşlevsel programlama,* saf işlevsel dönüşümü doğrudan destekleyen bir programlama yaklaşımıdır.</span><span class="sxs-lookup"><span data-stu-id="9829e-120">*Functional programming* is a programming approach that directly supports pure functional transformation.</span></span>

<span data-ttu-id="9829e-121">Tarihsel olarak, ML, Scheme, Haskell ve F# gibi genel amaçlı işlevsel programlama dilleri öncelikle akademik topluluğun ilgisini çekebilir.</span><span class="sxs-lookup"><span data-stu-id="9829e-121">Historically, general-purpose functional programming languages, such as ML, Scheme, Haskell, and F#, have been primarily of interest to the academic community.</span></span> <span data-ttu-id="9829e-122">C#'da saf işlevsel dönüşümler yazmak her zaman mümkün olsa da, bunu yapmanın zorluğu onu çoğu programcı için cazip bir seçenek haline getirmiyor.</span><span class="sxs-lookup"><span data-stu-id="9829e-122">Although it has always been possible to write pure functional transformations in C#, the difficulty of doing so has not made it an attractive option to most programmers.</span></span> <span data-ttu-id="9829e-123">Ancak C#'ın son sürümlerinde lambda ifadeleri ve tür çıkarımı gibi yeni dil yapıları işlevsel programlamayı çok daha kolay ve üretken hale getirir.</span><span class="sxs-lookup"><span data-stu-id="9829e-123">In recent versions of C#, however, new language constructs such as lambda expressions and type inference make it functional programming much easier and more productive.</span></span>

<span data-ttu-id="9829e-124">İşlevsel programlama hakkında daha fazla bilgi için [Bkz. İşlevsel Programlama ve Zorunlu Programlama (C#)](./functional-programming-vs-imperative-programming.md).</span><span class="sxs-lookup"><span data-stu-id="9829e-124">For more information about functional programming, see [Functional Programming vs. Imperative Programming (C#)](./functional-programming-vs-imperative-programming.md).</span></span>

#### <a name="domain-specific-fp-languages"></a><span data-ttu-id="9829e-125">Etki Alanına Özel FP Dilleri</span><span class="sxs-lookup"><span data-stu-id="9829e-125">Domain-Specific FP Languages</span></span>

<span data-ttu-id="9829e-126">Genel işlevsel programlama dilleri yaygın olarak benimsenmese de, etki alanına özgü belirli işlevsel programlama dilleri daha başarılı olmuştur.</span><span class="sxs-lookup"><span data-stu-id="9829e-126">Although general functional programming languages have not been widely adopted, specific domain-specific functional programming languages have had better success.</span></span> <span data-ttu-id="9829e-127">Örneğin, Basamaklı Stil Sayfaları (CSS) birçok Web sayfasının görünümünü ve hissini belirlemek için kullanılır ve Genişletilebilir Stil Sayfası Dil Dönüşümleri (XSLT) stil sayfaları XML veri işlemede yaygın olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9829e-127">For example, Cascading Style Sheets (CSS) are used to determine the look and feel of many Web pages, and Extensible Stylesheet Language Transformations (XSLT) style sheets are used extensively in XML data manipulation.</span></span> <span data-ttu-id="9829e-128">XSLT hakkında daha fazla bilgi için [Bkz. XSLT Dönüşümleri.](../../../../standard/data/xml/xslt-transformations.md)</span><span class="sxs-lookup"><span data-stu-id="9829e-128">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>

## <a name="terminology"></a><span data-ttu-id="9829e-129">Terminoloji</span><span class="sxs-lookup"><span data-stu-id="9829e-129">Terminology</span></span>

<span data-ttu-id="9829e-130">Aşağıdaki tabloda işlevsel dönüşümlerle ilgili bazı terimler tanımlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="9829e-130">The following table defines some terms related to functional transformations.</span></span>

<span data-ttu-id="9829e-131">üst düzey (birinci sınıf) fonksiyonu </span><span class="sxs-lookup"><span data-stu-id="9829e-131">higher-order (first-class) function </span></span>\
<span data-ttu-id="9829e-132">Programlı bir nesne olarak kabul edilebilen bir işlev.</span><span class="sxs-lookup"><span data-stu-id="9829e-132">A function that can be treated as a programmatic object.</span></span> <span data-ttu-id="9829e-133">Örneğin, daha yüksek bir sıra işlevi diğer işlevlere geçirilebilir veya döndürülebilir.</span><span class="sxs-lookup"><span data-stu-id="9829e-133">For example, a higher-order function can be passed to or returned from other functions.</span></span> <span data-ttu-id="9829e-134">C#c'de, temsilciler ve lambda ifadeleri üst düzey işlevleri destekleyen dil özellikleridir.</span><span class="sxs-lookup"><span data-stu-id="9829e-134">In C#c, delegates and lambda expressions are language features that support higher-order functions.</span></span> <span data-ttu-id="9829e-135">Daha yüksek bir sıralı işlev yazmak için, bir veya daha fazla bağımsız değişkeni temsilci almak için bildirirsiniz ve genellikle arama yaparken lambda ifadeleri kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="9829e-135">To write a higher-order function, you declare one or more arguments to take delegates, and you often use lambda expressions when calling it.</span></span> <span data-ttu-id="9829e-136">Standart sorgu işleçlerinin çoğu daha yüksek sıralı işlevlerdir.</span><span class="sxs-lookup"><span data-stu-id="9829e-136">Many of the standard query operators are higher-order functions.</span></span>

<span data-ttu-id="9829e-137">Daha fazla bilgi için, [Bkz. Standart Sorgu Operatörleri Genel Bakış (C#)](./standard-query-operators-overview.md).</span><span class="sxs-lookup"><span data-stu-id="9829e-137">For more information, see [Standard Query Operators Overview (C#)](./standard-query-operators-overview.md).</span></span>

<span data-ttu-id="9829e-138">lambda ifade </span><span class="sxs-lookup"><span data-stu-id="9829e-138">lambda expression </span></span>\
<span data-ttu-id="9829e-139">Esasen, temsilci türünün beklendiği her yerde kullanılabilecek satır lı anonim bir işlev.</span><span class="sxs-lookup"><span data-stu-id="9829e-139">Essentially, an inline anonymous function that can be used wherever a delegate type is expected.</span></span> <span data-ttu-id="9829e-140">Bu lambda ifadelerin basitleştirilmiş bir tanımıdır, ancak bu öğretici amaçları için yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="9829e-140">This is a simplified definition of lambda expressions, but it is adequate for the purposes of this tutorial.</span></span>

<span data-ttu-id="9829e-141">Hakkında daha fazla bilgi için [Lambda İfadeleri'ne](../../statements-expressions-operators/lambda-expressions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="9829e-141">For more information about, see [Lambda Expressions](../../statements-expressions-operators/lambda-expressions.md).</span></span>

<span data-ttu-id="9829e-142">toplama </span><span class="sxs-lookup"><span data-stu-id="9829e-142">collection </span></span>\
<span data-ttu-id="9829e-143">Genellikle tek tipte yapılandırılmış bir veri kümesi.</span><span class="sxs-lookup"><span data-stu-id="9829e-143">A structured set of data, usually of a uniform type.</span></span> <span data-ttu-id="9829e-144">LINQ ile uyumlu olması için, <xref:System.Collections.IEnumerable> bir koleksiyonun arabirimi veya <xref:System.Linq.IQueryable> arabirimi <xref:System.Collections.Generic.IEnumerator%601> (veya genel karşılıklarından birini veya). <xref:System.Linq.IQueryable%601></span><span class="sxs-lookup"><span data-stu-id="9829e-144">To be compatible with LINQ, a collection must implement the <xref:System.Collections.IEnumerable> interface or the <xref:System.Linq.IQueryable> interface (or one of their generic counterparts, <xref:System.Collections.Generic.IEnumerator%601> or <xref:System.Linq.IQueryable%601>).</span></span>

<span data-ttu-id="9829e-145">tuple (anonim türleri) </span><span class="sxs-lookup"><span data-stu-id="9829e-145">tuple (anonymous types) </span></span>\
<span data-ttu-id="9829e-146">Matematiksel bir kavram, bir tuple nesnelerin sınırlı bir dizi, belirli bir tür her.</span><span class="sxs-lookup"><span data-stu-id="9829e-146">A mathematical concept, a tuple is a finite sequence of objects, each of a specific type.</span></span> <span data-ttu-id="9829e-147">Bir tuple sıralı liste olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="9829e-147">A tuple is also known as an ordered list.</span></span> <span data-ttu-id="9829e-148">Anonim türler, bu kavramın, adsız bir sınıf türünün bildirilmesini ve bu tür bir nesnenin aynı anda anlık olarak görüntülemesini sağlayan bir dil uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="9829e-148">Anonymous types are a language implementation of this concept, which enable an unnamed class type to be declared and an object of that type to be instantiated at the same time.</span></span>

<span data-ttu-id="9829e-149">Daha fazla bilgi için [Bkz. Anonim Türler.](../../classes-and-structs/anonymous-types.md)</span><span class="sxs-lookup"><span data-stu-id="9829e-149">For more information, see [Anonymous Types](../../classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="9829e-150">tür çıkarım (örtülü yazma) </span><span class="sxs-lookup"><span data-stu-id="9829e-150">type inference (implicit typing) </span></span>\
<span data-ttu-id="9829e-151">Derleyicinin açık bir tür bildirimi yokluğunda bir değişkenin türünü belirleme yeteneği.</span><span class="sxs-lookup"><span data-stu-id="9829e-151">The ability of a compiler to determine the type of a variable in the absence of an explicit type declaration.</span></span>

<span data-ttu-id="9829e-152">Daha fazla bilgi için [bkz.](../../classes-and-structs/implicitly-typed-local-variables.md)</span><span class="sxs-lookup"><span data-stu-id="9829e-152">For more information, see [Implicitly Typed Local Variables](../../classes-and-structs/implicitly-typed-local-variables.md).</span></span>

<span data-ttu-id="9829e-153">ertelenmiş yürütme ve tembel değerlendirme </span><span class="sxs-lookup"><span data-stu-id="9829e-153">deferred execution and lazy evaluation </span></span>\
<span data-ttu-id="9829e-154">Bir ifadenin çözümlenen değerine kadar değerlendirilmesinin geciktirilmesi gerçekten gereklidir.</span><span class="sxs-lookup"><span data-stu-id="9829e-154">The delaying of evaluation of an expression until its resolved value is actually required.</span></span> <span data-ttu-id="9829e-155">Ertelenmiş yürütme koleksiyonlarda desteklenir.</span><span class="sxs-lookup"><span data-stu-id="9829e-155">Deferred execution is supported in collections.</span></span>

<span data-ttu-id="9829e-156">Daha fazla bilgi için [linq sorgularına giriş (C#)](./introduction-to-linq-queries.md) ve [Linq'te Ertelenmiş Yürütme ve Tembel Değerlendirme ile XML (C#) bölümüne](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="9829e-156">For more information, see [Introduction to LINQ Queries (C#)](./introduction-to-linq-queries.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).</span></span>

<span data-ttu-id="9829e-157">Bu dil özellikleri bu bölüm boyunca kod örneklerinde kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="9829e-157">These language features will be used in code samples throughout this section.</span></span>

## <a name="see-also"></a><span data-ttu-id="9829e-158">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="9829e-158">See also</span></span>

- [<span data-ttu-id="9829e-159">Saf İşlevsel Dönüşümlere Giriş (C#)</span><span class="sxs-lookup"><span data-stu-id="9829e-159">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="9829e-160">Fonksiyonel Programlama ve Zorunlu Programlama (C#)</span><span class="sxs-lookup"><span data-stu-id="9829e-160">Functional Programming vs. Imperative Programming (C#)</span></span>](./functional-programming-vs-imperative-programming.md)
