### YamlMime:Tutorial
title: 6 C# C# etkileşimli C# öğreticiyi keşfet
metadata:
  title: 6 C# ' yı keşfet-tarayıcınızı kullanarak 6 C# ' da yeni özellikleri etkileşimli olarak deneyin
  description: Bu öğreticide, tarayıcınızı kullanarak 6 etkileşimli olarak keşfedebilirsiniz C# . Daha kısa ve okunabilir kod sağlamak için 6 ile C# kullanabileceğiniz yeni deyimleri keşfedebilirsiniz.
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 594ae1530ac9ef41d6f3200b3e218db026552b95
  ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
  ms.translationtype: MT
  ms.contentlocale: tr-TR
  ms.lasthandoff: 03/03/2020
  ms.locfileid: "78240408"
items:
- durationInMinutes: 1
  content: >
    Bu öğretici, kodunuzu derleyip C# çalıştırmanın sonuçlarını yazmak C# ve görüntülemek için tarayıcınızı kullanarak 6 etkileşimli olarak araştırmanıza olanak sağlar. Önceki C# uygulamaları daha yeni, daha kısa C# 6 özellikleri kullanacak şekilde değiştiren bir dizi ders içerir. Bu makalenin geri kalanında, her bir özelliği keşfetmeye yönelik bir bağlantı ile bu özelliklerin her biri için bir genel bakış sunulmaktadır.
- title: Salt okuma otomatik özellikleri salt okuma türlerini etkinleştir
  durationInMinutes: 2
  content: "Otomatik özellik sözdiziminde iki geliştirme özelliği, otomatik özelliklerin daha fazla yerde kullanılmasını kolaylaştırır: salt okunurdur otomatik özellikler ve otomatik özellik başlatıcıları. Bu küçük programı göz önünde bulundurun:\n\n[!code-csharp[Starter](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n Odak moduna girer, önceki kodu C# etkileşimli pencereye kopyalayın. Ardından kodun ne yaptığını görmek için *Çalıştır* ' ı seçin. `AllCaps`, özellik değerlerini, büyük harfli dizeyi döndürerek birlikte değiştirmenin istenmeyen yan etkisine sahiptir. `Person` sınıfının yazarı `FirstName` ve `LastName` dizelerin salt okunurdur. 6 C# ile, bu amacı açık hale getirebilirsiniz. Salt okunurdur otomatik özellik oluşturmak için her iki özellikten `private set` kaldırın. Derleyicinin `FirstName` ve `LastName` özelliklerinin değiştiği iki konum olduğunu görmek için *Çalıştır* ' ı seçin. Derleyici hatasını çözebilmeniz için `AllCaps` yöntemini aşağıdaki kodla değiştirebilirsiniz:\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\nDerleyici, bu yeni söz dizimini kullanarak özelliklerin sabit olmasını sağlar.\n"
- title: Otomatik özellikler için yedekleme alanlarını başlatma
  durationInMinutes: 1
  content: "6 ' da C# yeni sözdizimi otomatik özellikler için başlatıcıları kullanmanıza olanak sağlar. Bu, sınıflar yeni özellikleri büyürken daha önemli hale gelir. Bir göbek adı özelliği ve `Person` sınıfınıza üç dize alan yeni bir Oluşturucu ekleyin:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n`MiddleName` özelliğindeki atama bir başlatıcıdır. İkinci ad için derleyici tarafından oluşturulan yedekleme alanını başlatır.\n"
- title: İfade gövdeli üyeler
  durationInMinutes: 2
  content: >
    İfade-Bodied Üyeler hafif yöntemler için hafif bir sözdizimi sağlar. `Person` sınıfında iki harika aday vardır. `ToString`bildirimine bakın:


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    Bu `ToString` bildirimini aşağıdaki kodla değiştirin:


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    `AllCaps` yöntemiyle aynısını deneyin. Bu küçük bir iyileştirmedir, ancak özellikle de Veri Aktarımı nesneleri (DTOs) ve en az davranışa sahip diğer türler için çok daha okunabilir kod oluşturur.
- title: Tek bir sınıfı içeri aktarma
  durationInMinutes: 2
  content: "Kodunuzun tamamında sürekli olarak bir sınıf ' statik yöntemleri kullanırsanız (her zaman kodunuzun anlamını her olumsuz bir şekilde). `Person` sınıfı şu anda yalnızca <xref:System.Console?displayProperty=nameWithType> kullanılmasına rağmen `System` ad alanını içeri aktarır. `using` ifadesini aşağıdaki gibi değiştirin:\n\n[!code-csharp[MiddleName](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n`static using` deyimleri, [`string`](xref:System.String) sınıfı veya <xref:System.Math?displayProperty=nameWithType> sınıfı gibi birçok statik yöntemle tek bir sınıftan çok daha yararlı hale gelir.\n"
- title: Daha iyi bir dize biçimi
  durationInMinutes: 2
  content: "C#6 bir dizeden dize oluşturmaya yönelik yeni sözdizimi ve diğer dize değerlerini oluşturmak için değerlendirilen katıştırılmış ifadeleri içerir. `ToString` ve `AllCaps` yöntemlerini bu söz dizimini kullanacak şekilde değiştirebilirsiniz:\n\n[!code-csharp[StringInterpolation](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n`{` ve `}`arasında konumsal bağımsız değişkenler yerine, ifadeleri doğrudan yazarsınız C# . `Main` yönteminde aynısını yapabilirsiniz. Mevcut kodu şu kodla değiştirin:\n\n[!code-csharp[InterpolationMain](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\nBu İfadelerdeki tek bir değişkenle sınırlı değilsiniz. Yeni bir örnekle başlayalım ve dize ilişkilendirimiyle kullanabileceğiniz diğer ifadeleri gösterecek şekilde değiştirin. Aşağıdaki kodu `Main` yönteminde etkileşimli pencereye yapıştırın:\n\n[!code-csharp[Phrases](../../../../samples/snippets/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \nBu, LINQ kullanan bu nedenle, aşağıdaki using ifadesini etkileşimli pencerenin en üstüne eklemeniz gerekir:\n\n```csharp\nusing System.Linq;\n```\n\nYerel değişkeni `average` kaldırabilir ve bu hesaplamayı, enterpolasyonlu dize ifadesinin bir parçası olarak gerçekleştirebilirsiniz. Son iki satırı aşağıdaki kodla değiştirin:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\nYukarıdaki örneği çalıştırırken, `Average` çıkışının istediğiniz kadar ondalık basamak olduğunu fark edersiniz. Dize ilişkilendirme sözdizimi, önceki biçimlendirme yöntemleri kullanılarak kullanılabilir olan tüm biçim dizelerini destekler. Biçim dizesini küme ayraçları içinde belirtirsiniz. Biçimlendirilecek ifadeyi izleyerek `:` ekleyin:\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: Hızlı ve kolay null denetimler
  durationInMinutes: 2
  content: "`?.` (null koşullu) operatörü, ek `if` denetimleri olmadan, `null` değerleri hesaba sorunsuz bir şekilde yazmayı kolaylaştırır. Özelliği araştırmak için, aşağıdaki kodu denemek üzere etkileşimli pencereye kopyalayarak başlayın:\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\nÖrneği çalıştırdığınızda bir <xref:System.NullReferenceException> oluşturur. `.` member Access işlecini **null koşullu işlece**değiştirin:\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\nBu değişiklikten sonra çıkış yok. Bunun nedeni, `s.Length` sonucu bir `int`olduğunda `s?.Length` sonucu bir `int?`. Bu örnekte, `s?.Length` `null`. `?.`, sol işleneni `null``null` döndürür. Sağ işlenenin türü bir değer türü ise, `?.` işleci bu tür için null yapılabilir bir tür döndürür. `?.` buna ek olarak, dizi veya Dizin Oluşturucu erişimi için `?[]` kullanabilirsiniz. Etkileşimli pencerede aşağıdaki kodu deneyin:\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n Birden çok koşullu işleç tek bir ifadede birleştirilebilir. `null` Left işleneni, üyenin üyelerine erişim için iç içe geçmiş yan tümcelerinin oluşmasını önlemeye olanak sağlayan `null` bir sonuç üretir. Örneğin, etkileşimli pencerede aşağıdaki kodu deneyin:\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n Yukarıdaki örnek, varsayılan bir değer sağlamak için **null birleşim işleci** kullanılarak basitleştirilebilir:\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n **Null koşullu operatör** , `null` değerleri için sorunsuz bir test ederken çekirdek mantığınızı temizlemenizi sağlayan kodu yazmanıza yardımcı olur.\n"
- title: Özel durum filtreleri
  durationInMinutes: 2
  content: "Özel durum filtreleri, bir özel durumu bir koşula göre yakalayacak şekilde etkinleştirir. Yaygın olarak kullanılan bir yöntem, özel durumları günlüğe kaydeden ancak bu özel durumları hiçbir şekilde işlemez bir filtre yöntemi oluşturmaktır. Özel durum filtresi, `catch` yan tümcesinin yürütülmesi gerektiğinde `true` ve özel durumun `catch` yan tümcesi tarafından yakalanmadığında `false` bir Boolean ifadedir. Etkileşimli pencerede aşağıdaki kodu deneyin: özel durum türünü ve iletisini konsola kaydeder. Özel durumun işlenemediğini belirten `false` döndürür. Programı etkileşimli pencerede deneyin.\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n`LogException` yönteminden ve ardından varsayılan özel durum iletisinden iletiyi görmeniz gerekir. Denemek için `return false` ifadesini `return true` olarak değiştirip yeniden çalıştırın. Şimdi özel durum yakalandı ve program tamamlanmak üzere çalışıyor.\n\nGünlüğe kaydetme senaryolarının ötesinde özel durum filtreleri, bir özel durumun özelliği hangi eylemin yapılacağını belirlerken en yararlı olabilir. Örneğin, içerilen özel durumların ne olduğunu görmek için bir <xref:System.AggregateException> içinde görünebilmeniz ve belirli özel duruma bağlı olarak uygun bir işlem yapmanız gerekir.\n"
- title: NameOf kullanma
  durationInMinutes: 2
  content: "`nameof` işleci herhangi bir değişkenin, türün veya türün üyesinin adını döndürür. Nasıl çalıştığını görmek için etkileşimli pencerede aşağıdaki kodu deneyin:\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\nÇıktı, değişkenin veya türün adıyla eşleşir. Tam nitelikli tür adı (örneğin `System.String`) sağlasanız bile `nameof` işleci nitelenmemiş adı döndürür. Bu özellik, bir parametre veya özellik adını bir dizeye dönüştürmeniz gerektiğinde faydalıdır. Örnek olarak, bir <xref:System.ArgumentNullException> veya <xref:System.ArgumentException>oluşturmak için bir bağımsız değişkenin adını yakalama veya <xref:System.ComponentModel.INotifyPropertyChanged>uygularken değiştirilen bir özelliğin adını yakalama sayılabilir. \n"
- title: Yeni nesne başlatma sözdizimi
  durationInMinutes: 2
  content: "Nesne başlatıcısı sözdizimi artık *dizin oluşturucularının* yanı sıra özellikleri ve alanları başlatmayı desteklemektedir. Bu ek, sözlükleri ve diğer türleri başlatmayı kolaylaştırır. Bir sözlük ile başlayın. Etkileşimli pencerede aşağıdaki kodu çalıştırın:\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\nBir dizin oluşturucuda bir değer ayarlayan bu sözdizimi, bir dizin oluşturucuda erişilebilir bir set erişimcisine sahip olan herhangi bir tür için kullanılabilir.\n\nİkinci bir değişiklik, dizileri temsil eden türler için Başlatıcı sözdiziminin etkinleşmesini kolaylaştırır. Koleksiyon başlatıcıları, <xref:System.Collections.IEnumerable> uygulayan ve genel olarak erişilebilen bir `Add` yöntemi olan herhangi bir sınıfta kullanılabilir. Bu `Add` yöntemi artık bir genişletme yöntemi olabilir. \n\nAşağıdaki örnekte bu söz dizimi için bir senaryo gösterilmektedir. `IEnumerable<Point3D>` uygulayan ve üç bağımsız değişken alan noktaları eklemek için bir yöntemine sahip bir `Path` sınıfı oluşturur. `Extensions` sınıfı, üç bileşenlerinden yeni bir nokta eklemek için ek bir `Add` yöntemi oluşturur. Bu örnek, ortamdaki kısıtlamalar nedeniyle şu anda etkileşimli olarak çalışmaz.\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: 6 ' daki C# yeni özellikleri araştırmayı tamamladınız. Şimdi bunları uygulamalarınızda kendiniz deneyin.
