---
title: Desen Eşleştirme - C# Kılavuzu
description: "C'deki desen eşleştirme ifadeleri hakkında bilgi edinin #"
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: bb6baf3771024d02b2027f81fd35b8be4872cf6e
ms.sourcegitcommit: 99b153b93bf94d0fecf7c7bcecb58ac424dfa47c
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/25/2020
ms.locfileid: "80249239"
---
# <a name="pattern-matching"></a><span data-ttu-id="016c8-103">Desen Eşleştirme</span><span class="sxs-lookup"><span data-stu-id="016c8-103">Pattern Matching</span></span>

<span data-ttu-id="016c8-104">Desenler, bir değerin belirli bir *şekle*sahip olduğunu ve eşleşen şekle sahip olduğunda değerden bilgi *ayıklayabildiği* kadar sınar.</span><span class="sxs-lookup"><span data-stu-id="016c8-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="016c8-105">Desen eşleştirme, bugün zaten kullandığınız algoritmalar için daha kısa sözdizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="016c8-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="016c8-106">Varolan sözdizimini kullanarak desen eşleştirme algoritmaları zaten oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="016c8-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="016c8-107">Değerleri `if` sınamak için yazınız veya `switch` deyimlersiniz.</span><span class="sxs-lookup"><span data-stu-id="016c8-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="016c8-108">Daha sonra, bu ifadeler eşleştiğinde, bu değerden bilgileri ayıklar ve kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="016c8-109">Yeni sözdizimi öğeleri, zaten aşina olduğunuz deyimlerin `is` `switch`uzantılarıdır: ve .</span><span class="sxs-lookup"><span data-stu-id="016c8-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="016c8-110">Bu yeni uzantılar bir değeri sınayıp bu bilgileri ayıklamakla birleştirir.</span><span class="sxs-lookup"><span data-stu-id="016c8-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="016c8-111">Bu makalede, okunabilir, kısa kod sağlar nasıl göstermek için yeni sözdizimi bakacağız.</span><span class="sxs-lookup"><span data-stu-id="016c8-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="016c8-112">Desen eşleştirme, verilerin ve bunları manipüle eden yöntemlerin sıkıca birleştiği nesne yönelimli tasarımların aksine, verilerin ve kodun ayrıldığı deyimleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="016c8-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="016c8-113">Bu yeni deyimleri göstermek için, desen eşleştirme ifadelerini kullanarak geometrik şekilleri temsil eden yapılarla çalışalım.</span><span class="sxs-lookup"><span data-stu-id="016c8-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="016c8-114">Büyük olasılıkla sınıf hiyerarşileri oluşturma ve nesnenin çalışma zamanı türüne göre nesne davranışını özelleştirmek için [sanal yöntemler ve geçersiz kılınan yöntemler](methods.md#inherited) oluşturmaya aşinasınızdır.</span><span class="sxs-lookup"><span data-stu-id="016c8-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="016c8-115">Bu teknikler, sınıf hiyerarşisinde yapılandırılan veriler için mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="016c8-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="016c8-116">Veriler ve yöntemler ayrı olduğunda, başka araçlara ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="016c8-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="016c8-117">Yeni *desen eşleştirme* yapıları, verileri incelemek için daha temiz sözdizimini etkinleştirir ve bu verilerin herhangi bir durumuna göre denetim akışını manipüle eder.</span><span class="sxs-lookup"><span data-stu-id="016c8-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="016c8-118">Zaten ifadeler `if` yazmak `switch` ve bir değişkenin değerini test.</span><span class="sxs-lookup"><span data-stu-id="016c8-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="016c8-119">Bir `is` değişkenin türünü sınanan ifadeler yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="016c8-120">*Desen eşleştirme* bu ifadelere yeni özellikler ekler.</span><span class="sxs-lookup"><span data-stu-id="016c8-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="016c8-121">Bu makalede, farklı geometrik şekillerin alanını hesaplayan bir yöntem oluşturacaksınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="016c8-122">Ancak, nesne yönelimli tekniklere başvurmadan ve farklı şekiller için bir sınıf hiyerarşisi oluşturmadan bunu yapacaksınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="016c8-123">Bunun yerine *desen eşleştirme* kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="016c8-124">Bu örnekten geçerken, bu kodu nesne hiyerarşisi olarak nasıl yapılandırışla karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="016c8-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="016c8-125">Sorgulamanız ve işlemeniz gereken veriler bir sınıf hiyerarşisi değilse, desen eşleştirme zarif tasarımlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="016c8-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="016c8-126">Soyut şekil tanımıyla başlayıp farklı şekil sınıfları eklemek yerine, geometrik şekillerin her biri için basit veri tanımlarıyla başlayalım:</span><span class="sxs-lookup"><span data-stu-id="016c8-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="016c8-127">Bu yapılardan, bir şeklin alanını hesaplayan bir yöntem yazalım.</span><span class="sxs-lookup"><span data-stu-id="016c8-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="016c8-128">Tür `is` deseni ifadesi</span><span class="sxs-lookup"><span data-stu-id="016c8-128">The `is` type pattern expression</span></span>

<span data-ttu-id="016c8-129">C# 7.0'dan önce, her türü bir dizi `if` `is` ve deyimde test etmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="016c8-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="016c8-130">Yukarıdaki kod *tür deseninin*klasik bir ifadesidir : Bir değişkeni türünü belirlemek için sınamak ve bu türe göre farklı bir eylem demlersiniz.</span><span class="sxs-lookup"><span data-stu-id="016c8-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="016c8-131">Bu kod, test başarılı olursa `is` bir değişken atamak için ifade uzantıları kullanarak daha basit hale gelir:</span><span class="sxs-lookup"><span data-stu-id="016c8-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="016c8-132">Bu güncelleştirilmiş sürümde, `is` ifade hem değişkeni sınar hem de uygun türde yeni bir değişkene atar.</span><span class="sxs-lookup"><span data-stu-id="016c8-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="016c8-133">Ayrıca, bu sürümü `Rectangle` n . `struct`</span><span class="sxs-lookup"><span data-stu-id="016c8-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="016c8-134">Yeni `is` ifade, başvuru türlerinin yanı sıra değer türleri ile birlikte çalışır.</span><span class="sxs-lookup"><span data-stu-id="016c8-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="016c8-135">Desen eşleştirme ifadeleri için dil kuralları, eşleşme ifadesinin sonuçlarını yanlış kullanmaktan kaçınmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="016c8-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="016c8-136">Yukarıdaki örnekte, değişkenler `s` `c`, `r` ve yalnızca kapsam içindedir ve ilgili desen `true` eşleşmeifadeleri sonuçları olduğunda kesinlikle atanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="016c8-137">Her iki değişkeni de başka bir konumda kullanmaya çalışırsanız, kodunuz derleyici hataları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="016c8-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="016c8-138">Kapsamdan başlayarak bu kuralların her ikisini de ayrıntılı olarak inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="016c8-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="016c8-139">Değişken `c` yalnızca ilk `else` `if` ifadenin dalında kapsamdadır.</span><span class="sxs-lookup"><span data-stu-id="016c8-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="016c8-140">Değişken `s` yöntemde `ComputeAreaModernIs`kapsam içindedir.</span><span class="sxs-lookup"><span data-stu-id="016c8-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="016c8-141">Bunun nedeni, bir `if` deyimin her dalı değişkenler için ayrı bir kapsam oluşturmasıdır.</span><span class="sxs-lookup"><span data-stu-id="016c8-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="016c8-142">Ancak, `if` ifadenin kendisi değil.</span><span class="sxs-lookup"><span data-stu-id="016c8-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="016c8-143">Bu, `if` deyimde bildirilen değişkenlerin `if` deyimle aynı kapsamda olduğu anlamına gelir (bu durumda yöntem.) Bu davranış desen eşleştirmesine özgü değildir, ancak değişken kapsamlar `if` `else` ve deyimler için tanımlanmış davranıştır.</span><span class="sxs-lookup"><span data-stu-id="016c8-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="016c8-144">Değişkenler `c` ve `s` ilgili `if` ifadeler doğru olduğunda, gerçek mekanizma zaman kesinlikle atanan nedeniyle atanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="016c8-145">Bu konudaki örnekler, bir desen eşleşmesi `is` ifadesinin `true` `if` ifadenin deyiminin dalındaki eşleşme değişkenini kesinlikle atadığı önerilen yapıyı kullanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="016c8-146">Söyleyerek `if (!(shape is Square s))` mantığı tersine çevirebilirsiniz `s` ve değişken kesinlikle yalnızca `false` dalda atanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="016c8-147">Bu geçerli C# olsa da, mantığı takip etmek daha kafa karıştırıcı olduğundan önerilmez.</span><span class="sxs-lookup"><span data-stu-id="016c8-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="016c8-148">Bu kurallar, bu desen karşılanmadığında yanlışlıkla bir desen eşleşmesi ifadesinin sonucuna erişme olasılığının düşük olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="016c8-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="016c8-149">Desen eşleştirme `switch` ifadelerini kullanma</span><span class="sxs-lookup"><span data-stu-id="016c8-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="016c8-150">Zaman geçtikçe, diğer şekil türlerini desteklemeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="016c8-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="016c8-151">Test ettiğiniz koşulların sayısı arttıkça, `is` desen eşleşen ifadeleri kullanarak hantal hale gelebilir bulacaksınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="016c8-152">Denetlemek istediğiniz her `if` türde deyim ler gerektirmesinin `is` yanı sıra, giriş tek bir türle eşleşip eşleşmediyse ifadeler sınamayla sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="016c8-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="016c8-153">Bu durumda, `switch` desen eşleşen ifadeler daha iyi bir seçim olur bulacaksınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span>

<span data-ttu-id="016c8-154">Geleneksel `switch` ifade bir desen ifadesiydi: sabit deseni destekledi.</span><span class="sxs-lookup"><span data-stu-id="016c8-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="016c8-155">Bir değişkeni bir deyimde kullanılan `case` herhangi bir sabitle karşılaştırabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="016c8-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="016c8-156">`switch` İfade tarafından desteklenen tek desen sabit desen oldu.</span><span class="sxs-lookup"><span data-stu-id="016c8-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="016c8-157">Daha fazla sayısal türleri ve `string` türü ile sınırlıydı.</span><span class="sxs-lookup"><span data-stu-id="016c8-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="016c8-158">Bu kısıtlamalar kaldırıldı ve şimdi tür `switch` deseni kullanarak bir deyim yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="016c8-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="016c8-159">Desen eşleştirme `switch` deyimi, geleneksel C stili `switch` deyimini kullanan geliştiriciler için tanıdık sözdizimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="016c8-160">Her `case` biri değerlendirilir ve giriş değişkeni ile eşleşen koşulun altındaki kod yürütülür.</span><span class="sxs-lookup"><span data-stu-id="016c8-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="016c8-161">Kod yürütme bir servis talebi ifadesinden diğerine "düşemez"; `case` deyiminin sözdizimi, her `case` bir `break`ucun bir , `return`veya `goto`.</span><span class="sxs-lookup"><span data-stu-id="016c8-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="016c8-162">Başka `goto` bir etikete atlamak için ifadeler yalnızca sabit desen (klasik anahtar deyimi) için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="016c8-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="016c8-163">İfadeyi `switch` yöneten önemli yeni kurallar vardır.</span><span class="sxs-lookup"><span data-stu-id="016c8-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="016c8-164">İfadedeki değişkenin türüne `switch` ilişkin kısıtlamalar kaldırıldı.</span><span class="sxs-lookup"><span data-stu-id="016c8-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="016c8-165">Bu örnekte `object` olduğu gibi herhangi bir tür kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="016c8-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="016c8-166">Servis talebi ifadeleri artık sabit değerlerle sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="016c8-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="016c8-167">Bu sınırlamanın kaldırılması, `switch` bölümleri yeniden sıralamanın bir programın davranışını değiştirebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="016c8-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="016c8-168">Sabit değerlerle sınırlı olduğunda, `case` en fazla bir etiket `switch` ifadenin değeriyle eşleşemez.</span><span class="sxs-lookup"><span data-stu-id="016c8-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="016c8-169">Bunu, her `switch` bölümün bir sonraki bölüme düşmemesi gerektiği kuralıyla `switch` birleştirin ve bölümleri davranışı etkilemeden herhangi bir sırada yeniden düzenlenebileceğini söyledi.</span><span class="sxs-lookup"><span data-stu-id="016c8-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="016c8-170">Şimdi, daha genelifadeler `switch` ile, her bölümün sırası önemlidir.</span><span class="sxs-lookup"><span data-stu-id="016c8-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="016c8-171">İfadeler `switch` metin sırasına göre değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="016c8-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="016c8-172">Yürütme, `switch` ifadeyle `switch` eşleşen ilk etikete aktar.</span><span class="sxs-lookup"><span data-stu-id="016c8-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="016c8-173">Servis `default` talebi yalnızca başka bir servis talebi etiketi eşleşmezse yürütülür.</span><span class="sxs-lookup"><span data-stu-id="016c8-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="016c8-174">Dava, `default` metin seli ne olursa olsun en son değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="016c8-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="016c8-175">Herhangi bir durum `default` yoksa ve diğer `case` ifadelerin hiçbiri eşleşmezse, `switch` açıklamanın ardından yapılan açıklamada yürütme devam eder.</span><span class="sxs-lookup"><span data-stu-id="016c8-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="016c8-176">Etiketler kodunun `case` hiçbiri yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="016c8-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="016c8-177">`when`ifadelerdeki `case` yan tümceler</span><span class="sxs-lookup"><span data-stu-id="016c8-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="016c8-178">`case` Etiketüzerinde bir `when` yan tümce kullanarak 0 alanına sahip bu şekiller için özel durumlar yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="016c8-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="016c8-179">Yan uzunluğu 0 olan bir kare veya 0 yarıçapı olan bir daire0 alana sahiptir.</span><span class="sxs-lookup"><span data-stu-id="016c8-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="016c8-180">Bu koşulu `when` `case` etikette bir yan tümce kullanarak belirtirsiniz:</span><span class="sxs-lookup"><span data-stu-id="016c8-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="016c8-181">Bu değişiklik, yeni sözdizimi hakkında birkaç önemli noktayı gösterir.</span><span class="sxs-lookup"><span data-stu-id="016c8-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="016c8-182">İlk olarak, birden çok `case` `switch` etiket bir bölüme uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="016c8-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="016c8-183">Bu etiketlerden herhangi biri `true`.</span><span class="sxs-lookup"><span data-stu-id="016c8-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="016c8-184">Bu durumda, `switch` ifade bir daire veya 0 alana sahip bir kare ise, yöntem 0 sabitini döndürür.</span><span class="sxs-lookup"><span data-stu-id="016c8-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="016c8-185">Bu örnek, ilk `case` `switch` blok için iki etikette iki farklı değişken tanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="016c8-186">Bu `switch` bloktaki deyimlerin değişkenleri `c` (daire için) veya `s` (kare için) kullanmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="016c8-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="016c8-187">Bu değişkenlerden hiçbiri kesinlikle bu `switch` blokta atanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="016c8-188">Bu durumlardan biri eşleşirse, açıkça değişkenlerden biri atanmıştır.</span><span class="sxs-lookup"><span data-stu-id="016c8-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="016c8-189">Ancak, derle zamanında *hangisinin* atandığını söylemek imkansızdır, çünkü her iki durumda da çalışma zamanında eşleşebilir.</span><span class="sxs-lookup"><span data-stu-id="016c8-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="016c8-190">Bu nedenle, çoğu zaman aynı `case` blok için birden çok etiket kullandığınızda, `case` deyimde yeni bir değişken tanıtamazsınız `when` veya yalnızca yan tümcedeki değişkeni kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="016c8-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="016c8-191">0 alana sahip bu şekilleri ekledikten sonra, birkaç şekil türü daha ekleyelim: bir dikdörtgen ve üçgen:</span><span class="sxs-lookup"><span data-stu-id="016c8-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="016c8-192">Bu değişiklik kümesi, dejenere servis talebi için etiketler, yeni şekillerin her biri için etiketler ve bloklar ekler. `case`</span><span class="sxs-lookup"><span data-stu-id="016c8-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span>

<span data-ttu-id="016c8-193">Son olarak, bağımsız `null` değişkenin aşağıdakilerden `null`emin olmak için bir servis talebi ekleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="016c8-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="016c8-194">`null` Desendeki sabitin `null` bir türü olmadığından, ancak herhangi bir başvuru türüne veya nullable değer türüne dönüştürülebildiği için desen için özel davranış ilginçtir.</span><span class="sxs-lookup"><span data-stu-id="016c8-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable value type.</span></span> <span data-ttu-id="016c8-195">Dil, a'yı `null` herhangi bir türe `null` dönüştürmek yerine, değişkenin derleme zamanı türünden bağımsız olarak bir değerin herhangi bir tür deseniyle eşleşmeymeyeceğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="016c8-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="016c8-196">Bu davranış, `switch` yeni tabanlı tür `is` deseni `is` deyimle `false` tutarlı hale getirir: `null`denetlenen değer işaretlendiğinde deyimler her zaman geri döner.</span><span class="sxs-lookup"><span data-stu-id="016c8-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="016c8-197">Aynı zamanda daha basittir: türü kontrol ettiğinizde, ek bir null çekgerekmez.</span><span class="sxs-lookup"><span data-stu-id="016c8-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="016c8-198">Yukarıdaki örneklerin hiçbir servis talebi bloğunda null denetim olmamasından görebilirsiniz: tür deseni eşleştirmenin null olmayan bir değeri garanti etmesi gerektiğinden, bunlar gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="016c8-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="016c8-199">`var`ifadelerdeki `case` bildirimler</span><span class="sxs-lookup"><span data-stu-id="016c8-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="016c8-200">Eşmaç `var` ifadelerinden biri olarak giriş, desen eşleşmesine yeni kurallar sunar.</span><span class="sxs-lookup"><span data-stu-id="016c8-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="016c8-201">İlk kural, bildirimin `var` normal tür çıkarım kurallarını izlemesidir: Tür, anahtar ifadesinin statik türü olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="016c8-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="016c8-202">Bu kurala göre, tür her zaman eşleşir.</span><span class="sxs-lookup"><span data-stu-id="016c8-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="016c8-203">İkinci kural, bir `var` bildirimin diğer tür desen ifadelerinin içerdiği null denetimine sahip olmamasıdır.</span><span class="sxs-lookup"><span data-stu-id="016c8-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="016c8-204">Bu, değişkenin null olabileceği ve bu durumda null çek gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="016c8-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="016c8-205">Bu iki kural, birçok durumda, `var` bir `case` ifadedeki bir bildirimin `default` ifadeyle aynı koşullarla eşleştiğini anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="016c8-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="016c8-206">Varsayılan olmayan herhangi bir servis `default` talebi servis `default` talebi için tercih olduğundan, servis talebi asla yürütülmeyecektir.</span><span class="sxs-lookup"><span data-stu-id="016c8-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="016c8-207">Derleyici, bir `default` servis talebinin yazıldığı durumlarda bir uyarı yapmaz, ancak hiçbir zaman yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="016c8-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="016c8-208">Bu, olası `switch` tüm durumların listelendiği geçerli deyim davranışıyla tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="016c8-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="016c8-209">Üçüncü kural, bir `var` servis talebinin yararlı olabileceği kullanımları tanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="016c8-210">Girişin bir dize olduğu ve bilinen komut değerlerini aradığınız bir desen eşleşmesi yaptığınızı düşünün.</span><span class="sxs-lookup"><span data-stu-id="016c8-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="016c8-211">Şöyle bir şey yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="016c8-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="016c8-212">`var` Büyük/küçük `null`harf eşleşmeleri, boş dize veya yalnızca beyaz boşluk içeren herhangi bir dize.</span><span class="sxs-lookup"><span data-stu-id="016c8-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="016c8-213">Önceki kodun `?.` yanlışlıkla bir <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="016c8-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="016c8-214">Servis `default` talebi, bu komut parer tarafından anlaşılmayan diğer dize değerlerini işler.</span><span class="sxs-lookup"><span data-stu-id="016c8-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="016c8-215">Bu, bir ifadeden farklı bir `var` durum ifadesini dikkate `default` almak isteyebileceğiniz bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="016c8-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="016c8-216">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="016c8-216">Conclusions</span></span>

<span data-ttu-id="016c8-217">*Desen Eşleştirme yapıları,* devralma hiyerarşisi ile ilişkili olmayan farklı değişkenler ve türler arasındaki denetim akışını kolayca yönetmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="016c8-218">Ayrıca, değişken üzerinde test ettiğiniz herhangi bir koşulu kullanmak için mantığı da denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="016c8-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="016c8-219">Daha fazla dağıtılmış uygulama oluştururken, verilerin ve bu verileri işleme yöntemlerinin ayrı olduğu daha sık ihtiyaç dizinlere ve deyimlere olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="016c8-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="016c8-220">Bu örnekte kullanılan şekil yapılarının herhangi bir yöntem içermediğini, yalnızca salt okunur özellikler içerdiğini fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="016c8-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="016c8-221">Desen Eşleştirme herhangi bir veri türüyle çalışır.</span><span class="sxs-lookup"><span data-stu-id="016c8-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="016c8-222">Nesneyi inceleyen ifadeler yazar ve bu koşullara göre denetim akışı kararları verirsiniz.</span><span class="sxs-lookup"><span data-stu-id="016c8-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="016c8-223">Bu örnekteki kodu, alanı hesaplamak için kendi sanal yöntem `Shape` uygulamasıyla soyut ve belirli türemiş şekiller için sınıf hiyerarşisi oluşturarak izleyen tasarımla karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="016c8-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="016c8-224">Verilerle çalışırken ve veri depolama yla ilgili endişeleri davranış kaygılarından ayırmak istediğinizde desen eşleştirme ifadelerinin çok yararlı bir araç olabileceğini sık sık göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="016c8-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="016c8-225">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="016c8-225">See also</span></span>

- [<span data-ttu-id="016c8-226">Öğretici: Veri türlerini genişletmek için desen eşleştirme özelliklerini kullanma</span><span class="sxs-lookup"><span data-stu-id="016c8-226">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
