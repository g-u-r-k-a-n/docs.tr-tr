---
title: 'C# ayrılmış öznitelikleri: çeşitli'
ms.date: 03/18/2021
description: 'Derleyici tarafından oluşturulan kodu etkileyen öznitelikler hakkında bilgi edinin: koşullu, Kullanımdan kaldırılmış, AttributeUsage, Modulebaşlatıcı ve Skiplocalsinıt öznitelikleri.'
ms.openlocfilehash: 6b8cda658ec5b3f81a7f903d8cadae0fe30e8ac2
ms.sourcegitcommit: e16315d9f1ff355f55ff8ab84a28915be0a8e42b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/25/2021
ms.locfileid: "105111328"
---
# <a name="reserved-attributes-miscellaneous"></a><span data-ttu-id="a59c4-103">Ayrılmış öznitelikler: çeşitli</span><span class="sxs-lookup"><span data-stu-id="a59c4-103">Reserved attributes: Miscellaneous</span></span>

<span data-ttu-id="a59c4-104">Bu öznitelikler, kodunuzdaki öğelere uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-104">These attributes can be applied to elements in your code.</span></span> <span data-ttu-id="a59c4-105">Bunlar bu öğelere anlam anlam ekler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-105">They add semantic meaning to those elements.</span></span> <span data-ttu-id="a59c4-106">Derleyici, kodunuzu kullanarak geliştiricilerin çıktısını değiştirmek ve olası hataları raporlamak için bu anlamsal anlamları kullanır.</span><span class="sxs-lookup"><span data-stu-id="a59c4-106">The compiler uses those semantic meanings to alter its output and report possible mistakes by developers using your code.</span></span>

## <a name="conditional-attribute"></a><span data-ttu-id="a59c4-107">`Conditional` özniteliği</span><span class="sxs-lookup"><span data-stu-id="a59c4-107">`Conditional` attribute</span></span>

<span data-ttu-id="a59c4-108">`Conditional`Özniteliği bir işlem ön işleme tanımlayıcısına bağımlı bir yöntemin yürütülmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="a59c4-108">The `Conditional` attribute makes the execution of a method dependent on a preprocessing identifier.</span></span> <span data-ttu-id="a59c4-109">`Conditional`Özniteliği için bir diğer addır <xref:System.Diagnostics.ConditionalAttribute> ve bir yönteme veya öznitelik sınıfına uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-109">The `Conditional` attribute is an alias for <xref:System.Diagnostics.ConditionalAttribute>, and can be applied to a method or an attribute class.</span></span>

<span data-ttu-id="a59c4-110">Aşağıdaki örnekte, `Conditional` programa özgü tanılama bilgilerinin görüntülenmesini etkinleştirmek veya devre dışı bırakmak için bir yönteme uygulanır:</span><span class="sxs-lookup"><span data-stu-id="a59c4-110">In the following example, `Conditional` is applied to a method to enable or disable the display of program-specific diagnostic information:</span></span>

:::code language="csharp" source="snippets/trace.cs" interactive="try-dotnet" :::

<span data-ttu-id="a59c4-111">`TRACE_ON`Tanımlayıcı tanımlanmamışsa, izleme çıktısı gösterilmez.</span><span class="sxs-lookup"><span data-stu-id="a59c4-111">If the `TRACE_ON` identifier isn't defined, the trace output isn't displayed.</span></span> <span data-ttu-id="a59c4-112">Etkileşimli pencerede kendiniz için araştırma yapın.</span><span class="sxs-lookup"><span data-stu-id="a59c4-112">Explore for yourself in the interactive window.</span></span>

<span data-ttu-id="a59c4-113">`Conditional`Bu öznitelik, `DEBUG` Aşağıdaki örnekte gösterildiği gibi, genellikle hata ayıklama derlemeleri için izleme ve günlüğe kaydetme özelliklerini etkinleştirmek üzere tanımlayıcıda kullanılır:</span><span class="sxs-lookup"><span data-stu-id="a59c4-113">The `Conditional` attribute is often used with the `DEBUG` identifier to enable trace and logging features for debug builds but not in release builds, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/ConditionalExamples.cs" id="SnippetConditional" :::

<span data-ttu-id="a59c4-114">Koşullu olarak işaretlenmiş bir yöntem çağrıldığında, belirtilen ön işleme simgesinin varlığı veya yokluğu, çağrının eklenip eklenmeyeceğini veya atlanmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-114">When a method marked conditional is called, the presence or absence of the specified preprocessing symbol determines whether the call is included or omitted.</span></span> <span data-ttu-id="a59c4-115">Sembol tanımlanmışsa, çağrı dahil edilir; Aksi takdirde, çağrı atlanır.</span><span class="sxs-lookup"><span data-stu-id="a59c4-115">If the symbol is defined, the call is included; otherwise, the call is omitted.</span></span> <span data-ttu-id="a59c4-116">Koşullu Yöntem bir sınıf veya yapı bildiriminde bir yöntem olmalıdır ve bir `void` dönüş türüne sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a59c4-116">A conditional method must be a method in a class or struct declaration and must have a `void` return type.</span></span> <span data-ttu-id="a59c4-117">`Conditional`' Yi kullanarak temizleyici, daha zarif ve daha az hata, bloklar içindeki kapsayan metotlardan çok daha açıktır `#if…#endif` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-117">Using `Conditional` is cleaner, more elegant, and less error-prone than enclosing methods inside `#if…#endif` blocks.</span></span>

<span data-ttu-id="a59c4-118">Bir yöntemde birden çok `Conditional` öznitelik varsa, bir veya daha fazla koşullu sembol tanımlanmışsa yönteme bir çağrı dahil edilir (semboller, or işleci kullanılarak mantıksal olarak birbirlerine bağlanır).</span><span class="sxs-lookup"><span data-stu-id="a59c4-118">If a method has multiple `Conditional` attributes, a call to the method is included if at one or more conditional symbols is defined (the symbols are logically linked together by using the OR operator).</span></span> <span data-ttu-id="a59c4-119">Aşağıdaki örnekte, ya da `A` `B` bir yöntem çağrısında oluşur:</span><span class="sxs-lookup"><span data-stu-id="a59c4-119">In the following example, the presence of either `A` or `B` results in a method call:</span></span>

:::code language="csharp" source="snippets/ConditionalExamples.cs" id="SnippetMultipleConditions" :::

### <a name="using-conditional-with-attribute-classes"></a><span data-ttu-id="a59c4-120">`Conditional`Öznitelik sınıfları ile kullanma</span><span class="sxs-lookup"><span data-stu-id="a59c4-120">Using `Conditional` with attribute classes</span></span>

<span data-ttu-id="a59c4-121">`Conditional`Öznitelik, öznitelik sınıfı tanımına da uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-121">The `Conditional` attribute can also be applied to an attribute class definition.</span></span> <span data-ttu-id="a59c4-122">Aşağıdaki örnekte, özel öznitelik `Documentation` yalnızca tanımlanmazsa meta verilere bilgi ekler `DEBUG` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-122">In the following example, the custom attribute `Documentation` will only add information to the metadata if `DEBUG` is defined.</span></span>

:::code language="csharp" source="snippets/ConditionalExamples.cs" id="SnippetConditionalConditionalAttribute" :::

## <a name="obsolete-attribute"></a><span data-ttu-id="a59c4-123">`Obsolete` özniteliği</span><span class="sxs-lookup"><span data-stu-id="a59c4-123">`Obsolete` attribute</span></span>

<span data-ttu-id="a59c4-124">`Obsolete`Öznitelik, artık kullanım için önerilmeyen bir kod öğesini işaretler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-124">The `Obsolete` attribute marks a code element as no longer recommended for use.</span></span> <span data-ttu-id="a59c4-125">Kullanımdan kaldırılmış olarak işaretlenmiş bir varlığın kullanımı bir uyarı veya hata oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a59c4-125">Use of an entity marked obsolete generates a warning or an error.</span></span> <span data-ttu-id="a59c4-126">`Obsolete`Özniteliği tek kullanım özniteliğidir ve özniteliklere izin veren herhangi bir varlığa uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-126">The `Obsolete` attribute is a single-use attribute and can be applied to any entity that allows attributes.</span></span> <span data-ttu-id="a59c4-127">`Obsolete` , için bir diğer addır <xref:System.ObsoleteAttribute> .</span><span class="sxs-lookup"><span data-stu-id="a59c4-127">`Obsolete` is an alias for <xref:System.ObsoleteAttribute>.</span></span>

<span data-ttu-id="a59c4-128">Aşağıdaki örnekte, `Obsolete` özniteliği sınıfa `A` ve yöntemine uygulanır `B.OldMethod` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-128">In the following example the `Obsolete` attribute is applied to class `A` and to method `B.OldMethod`.</span></span> <span data-ttu-id="a59c4-129">Öğesine uygulanan öznitelik oluşturucusunun ikinci bağımsız değişkeni `B.OldMethod` olarak ayarlandığından `true` , bu yöntem bir derleyici hatasına neden olur, ancak sınıf kullanımı `A` yalnızca bir uyarı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a59c4-129">Because the second argument of the attribute constructor applied to `B.OldMethod` is set to `true`, this method will cause a compiler error, whereas using class `A` will just produce a warning.</span></span> <span data-ttu-id="a59c4-130">Ancak çağırma, `B.NewMethod` hiçbir uyarı veya hata üretir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-130">Calling `B.NewMethod`, however, produces no warning or error.</span></span> <span data-ttu-id="a59c4-131">Örneğin, önceki tanımlarla birlikte kullandığınızda, aşağıdaki kod iki uyarı ve bir hata oluşturur:</span><span class="sxs-lookup"><span data-stu-id="a59c4-131">For example, when you use it with the previous definitions, the following code generates two warnings and one error:</span></span>

:::code language="csharp" source="snippets/ObsoleteExample.cs" interactive="try-dotnet" :::

<span data-ttu-id="a59c4-132">Öznitelik oluşturucusuna ilk bağımsız değişken olarak girilen dize, uyarının veya hatanın bir parçası olarak görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-132">The string provided as the first argument to the attribute constructor will be displayed as part of the warning or error.</span></span> <span data-ttu-id="a59c4-133">Sınıf için iki uyarı `A` oluşturulur: biri sınıf başvurusunun bildirimi ve diğeri sınıf oluşturucusu içindir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-133">Two warnings for class `A` are generated: one for the declaration of the class reference, and one for the class constructor.</span></span> <span data-ttu-id="a59c4-134">`Obsolete`Özniteliği bağımsız değişkenler olmadan kullanılabilir, ancak bunun yerine kullanılacak bir açıklama dahil edilmesi önerilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-134">The `Obsolete` attribute can be used without arguments, but including an explanation what to use instead is recommended.</span></span>

## <a name="attributeusage-attribute"></a><span data-ttu-id="a59c4-135">`AttributeUsage` özniteliği</span><span class="sxs-lookup"><span data-stu-id="a59c4-135">`AttributeUsage` attribute</span></span>

<span data-ttu-id="a59c4-136">`AttributeUsage`Özniteliği özel bir öznitelik sınıfının nasıl kullanılabileceğini belirler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-136">The `AttributeUsage` attribute determines how a custom attribute class can be used.</span></span> <span data-ttu-id="a59c4-137"><xref:System.AttributeUsageAttribute> , özel öznitelik tanımlarına uyguladığınız bir özniteliktir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-137"><xref:System.AttributeUsageAttribute> is an attribute you apply to custom attribute definitions.</span></span> <span data-ttu-id="a59c4-138">`AttributeUsage`Özniteliği şunları denetlemenizi sağlar:</span><span class="sxs-lookup"><span data-stu-id="a59c4-138">The `AttributeUsage` attribute enables you to control:</span></span>

- <span data-ttu-id="a59c4-139">Hangi program öğeleri özniteliği uygulanabilir olabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-139">Which program elements attribute may be applied to.</span></span> <span data-ttu-id="a59c4-140">Kullanımını kısıtlamadığınız takdirde, aşağıdaki program öğelerinden birine bir öznitelik uygulanabilir:</span><span class="sxs-lookup"><span data-stu-id="a59c4-140">Unless you restrict its usage, an attribute may be applied to any of the following program elements:</span></span>
  - <span data-ttu-id="a59c4-141">derleme</span><span class="sxs-lookup"><span data-stu-id="a59c4-141">assembly</span></span>
  - <span data-ttu-id="a59c4-142">modül</span><span class="sxs-lookup"><span data-stu-id="a59c4-142">module</span></span>
  - <span data-ttu-id="a59c4-143">alan</span><span class="sxs-lookup"><span data-stu-id="a59c4-143">field</span></span>
  - <span data-ttu-id="a59c4-144">event</span><span class="sxs-lookup"><span data-stu-id="a59c4-144">event</span></span>
  - <span data-ttu-id="a59c4-145">method</span><span class="sxs-lookup"><span data-stu-id="a59c4-145">method</span></span>
  - <span data-ttu-id="a59c4-146">larına</span><span class="sxs-lookup"><span data-stu-id="a59c4-146">param</span></span>
  - <span data-ttu-id="a59c4-147">özellik</span><span class="sxs-lookup"><span data-stu-id="a59c4-147">property</span></span>
  - <span data-ttu-id="a59c4-148">return</span><span class="sxs-lookup"><span data-stu-id="a59c4-148">return</span></span>
  - <span data-ttu-id="a59c4-149">tür</span><span class="sxs-lookup"><span data-stu-id="a59c4-149">type</span></span>
- <span data-ttu-id="a59c4-150">Bir özniteliğin tek bir program öğesine birden çok kez uygulanıp uygulanamayacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-150">Whether an attribute can be applied to a single program element multiple times.</span></span>
- <span data-ttu-id="a59c4-151">Özniteliklerin türetilmiş sınıflar tarafından devralınıp alınmayacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-151">Whether attributes are inherited by derived classes.</span></span>

<span data-ttu-id="a59c4-152">Varsayılan ayarlar, açıkça uygulandığında aşağıdaki örneğe benzer şekilde görünür:</span><span class="sxs-lookup"><span data-stu-id="a59c4-152">The default settings look like the following example when applied explicitly:</span></span>

:::code language="csharp" source="snippets/NewAttribute.cs" id="SnippetUsageFirst" :::

<span data-ttu-id="a59c4-153">Bu örnekte, `NewAttribute` sınıfı desteklenen herhangi bir program öğesine uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-153">In this example, the `NewAttribute` class can be applied to any supported program element.</span></span> <span data-ttu-id="a59c4-154">Ancak, her bir varlığa yalnızca bir kez uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-154">But it can be applied only once to each entity.</span></span> <span data-ttu-id="a59c4-155">Öznitelik, bir temel sınıfa uygulandığında türetilmiş sınıflar tarafından devralınır.</span><span class="sxs-lookup"><span data-stu-id="a59c4-155">The attribute is inherited by derived classes when applied to a base class.</span></span>

<span data-ttu-id="a59c4-156"><xref:System.AttributeUsageAttribute.AllowMultiple>Ve <xref:System.AttributeUsageAttribute.Inherited> bağımsız değişkenleri isteğe bağlıdır, bu nedenle aşağıdaki kod aynı etkiye sahiptir:</span><span class="sxs-lookup"><span data-stu-id="a59c4-156">The <xref:System.AttributeUsageAttribute.AllowMultiple> and <xref:System.AttributeUsageAttribute.Inherited> arguments are optional, so the following code has the same effect:</span></span>

:::code language="csharp" source="snippets/NewAttribute.cs" id="SnippetUsageSecond" :::

<span data-ttu-id="a59c4-157">İlk <xref:System.AttributeUsageAttribute> bağımsız değişken, numaralandırmanın bir veya daha fazla öğesi olmalıdır <xref:System.AttributeTargets> .</span><span class="sxs-lookup"><span data-stu-id="a59c4-157">The first <xref:System.AttributeUsageAttribute> argument must be one or more elements of the <xref:System.AttributeTargets> enumeration.</span></span> <span data-ttu-id="a59c4-158">Aşağıdaki örnekte gösterildiği gibi birden çok hedef türü OR işleciyle birlikte bağlanabilir:</span><span class="sxs-lookup"><span data-stu-id="a59c4-158">Multiple target types can be linked together with the OR operator, like the following example shows:</span></span>

:::code language="csharp" source="snippets/NewPropertyOrFieldAttribute.cs" id="SnippetDefinePropertyAttribute" :::

<span data-ttu-id="a59c4-159">C# 7,3 ' den başlayarak, öznitelikler bir otomatik uygulanan özelliğin özelliğine veya yedekleme alanına uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-159">Beginning in C# 7.3, attributes can be applied to either the property or the backing field for an auto-implemented property.</span></span> <span data-ttu-id="a59c4-160">Özniteliği, özniteliğinde tanımlayıcı belirtmediğiniz müddetçe özelliği için geçerlidir `field` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-160">The attribute applies to the property, unless you specify the `field` specifier on the attribute.</span></span> <span data-ttu-id="a59c4-161">Her ikisi de aşağıdaki örnekte gösterilmiştir:</span><span class="sxs-lookup"><span data-stu-id="a59c4-161">Both are shown in the following example:</span></span>

:::code language="csharp" source="snippets/NewPropertyOrFieldAttribute.cs" id="SnippetUsePropertyAttribute" :::

<span data-ttu-id="a59c4-162"><xref:System.AttributeUsageAttribute.AllowMultiple>Bağımsız değişken ise `true` , aşağıdaki örnekte gösterildiği gibi, sonuç özniteliği tek bir varlığa birden çok kez uygulanabilir:</span><span class="sxs-lookup"><span data-stu-id="a59c4-162">If the <xref:System.AttributeUsageAttribute.AllowMultiple> argument is `true`, then the resulting attribute can be applied more than once to a single entity, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/MultiUseAttribute.cs" id="SnippetMultiUse" :::

<span data-ttu-id="a59c4-163">Bu durumda, `MultiUseAttribute` olarak ayarlandığı için tekrar tekrar uygulanabilir `AllowMultiple` `true` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-163">In this case, `MultiUseAttribute` can be applied repeatedly because `AllowMultiple` is set to `true`.</span></span> <span data-ttu-id="a59c4-164">Birden çok özniteliği uygulamak için gösterilen her iki biçim de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-164">Both formats shown for applying multiple attributes are valid.</span></span>

<span data-ttu-id="a59c4-165"><xref:System.AttributeUsageAttribute.Inherited>İse `false` öznitelik, öznitelikli bir sınıftan türetilmiş sınıflar tarafından devralınmaz.</span><span class="sxs-lookup"><span data-stu-id="a59c4-165">If <xref:System.AttributeUsageAttribute.Inherited> is `false`, then the attribute isn't inherited by classes derived from an attributed class.</span></span> <span data-ttu-id="a59c4-166">Örnek:</span><span class="sxs-lookup"><span data-stu-id="a59c4-166">For example:</span></span>

:::code language="csharp" source="snippets/NonInheritedAttribute.cs" id="SnippetNonInherited" :::

<span data-ttu-id="a59c4-167">Bu durumda `NonInheritedAttribute` devralma aracılığıyla öğesine uygulanmaz `DClass` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-167">In this case `NonInheritedAttribute` isn't applied to `DClass` via inheritance.</span></span>

## <a name="moduleinitializer-attribute"></a><span data-ttu-id="a59c4-168">`ModuleInitializer` özniteliği</span><span class="sxs-lookup"><span data-stu-id="a59c4-168">`ModuleInitializer` attribute</span></span>

<span data-ttu-id="a59c4-169">C# 9 ' dan itibaren `ModuleInitializer` öznitelik, derleme yüklendiğinde çalışma zamanının çağırdığı bir yöntemi işaretler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-169">Starting with C# 9, the `ModuleInitializer` attribute marks a method that the runtime calls when the assembly loads.</span></span> <span data-ttu-id="a59c4-170">`ModuleInitializer` , için bir diğer addır <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> .</span><span class="sxs-lookup"><span data-stu-id="a59c4-170">`ModuleInitializer` is an alias for <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute>.</span></span>

<span data-ttu-id="a59c4-171">`ModuleInitializer`Özniteliği yalnızca şu şekilde bir yönteme uygulanabilir:</span><span class="sxs-lookup"><span data-stu-id="a59c4-171">The `ModuleInitializer` attribute can only be applied to a method that:</span></span>

* <span data-ttu-id="a59c4-172">Statiktir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-172">Is static.</span></span>
* <span data-ttu-id="a59c4-173">Parametresiz.</span><span class="sxs-lookup"><span data-stu-id="a59c4-173">Is parameterless.</span></span>
* <span data-ttu-id="a59c4-174">`void` döndürür.</span><span class="sxs-lookup"><span data-stu-id="a59c4-174">Returns `void`.</span></span>
* <span data-ttu-id="a59c4-175">,, Veya içeren modülünden erişilebilir `internal` `public` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-175">Is accessible from the containing module, that is, `internal` or `public`.</span></span>
* <span data-ttu-id="a59c4-176">Genel bir yöntem değildir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-176">Isn't a generic method.</span></span>
* <span data-ttu-id="a59c4-177">Genel bir sınıfta içerilmiyor.</span><span class="sxs-lookup"><span data-stu-id="a59c4-177">Isn't contained in a generic class.</span></span>
* <span data-ttu-id="a59c4-178">Yerel bir işlev değil.</span><span class="sxs-lookup"><span data-stu-id="a59c4-178">Isn't a local function.</span></span>

<span data-ttu-id="a59c4-179">`ModuleInitializer`Özniteliği birden çok yönteme uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-179">The `ModuleInitializer` attribute can be applied to multiple methods.</span></span> <span data-ttu-id="a59c4-180">Bu durumda, çalışma zamanının onları çağıran sıra belirleyici olur ancak belirtilmez.</span><span class="sxs-lookup"><span data-stu-id="a59c4-180">In that case, the order in which the runtime calls them is deterministic but not specified.</span></span>

<span data-ttu-id="a59c4-181">Aşağıdaki örnekte, birden çok modül başlatıcısı yönteminin kullanımı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-181">The following example illustrates use of multiple module initializer methods.</span></span> <span data-ttu-id="a59c4-182">`Init1`Ve `Init2` yöntemleri daha önce çalışır `Main` ve her biri özelliğine bir dize ekler `Text` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-182">The `Init1` and `Init2` methods run before `Main`, and each adds a string to the `Text` property.</span></span> <span data-ttu-id="a59c4-183">Bu nedenle `Main` , özelliği çalıştırıldığında `Text` her iki Başlatıcı yönteminden dizeler zaten vardır.</span><span class="sxs-lookup"><span data-stu-id="a59c4-183">So when `Main` runs, the `Text` property already has strings from both initializer methods.</span></span>

:::code language="csharp" source="snippets/ModuleInitializerExampleMain.cs" :::

:::code language="csharp" source="snippets/ModuleInitializerExampleModule.cs" :::

<span data-ttu-id="a59c4-184">Kaynak kodu oluşturanlar bazen başlatma kodu üretmemelidir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-184">Source code generators sometimes need to generate initialization code.</span></span> <span data-ttu-id="a59c4-185">Modül başlatıcıları, bu kodun bulunması için standart bir yer sağlar.</span><span class="sxs-lookup"><span data-stu-id="a59c4-185">Module initializers provide a standard place for that code to reside.</span></span>

## <a name="skiplocalsinit-attribute"></a><span data-ttu-id="a59c4-186">`SkipLocalsInit` özniteliği</span><span class="sxs-lookup"><span data-stu-id="a59c4-186">`SkipLocalsInit` attribute</span></span>

<span data-ttu-id="a59c4-187">C# 9 ' dan itibaren `SkipLocalsInit` öznitelik, derleyicinin `.locals init` meta veriye yayırken bayrak değiştirmesini engeller.</span><span class="sxs-lookup"><span data-stu-id="a59c4-187">Starting in C# 9, the `SkipLocalsInit` attribute prevents the compiler from setting the `.locals init` flag when emitting to metadata.</span></span> <span data-ttu-id="a59c4-188">`SkipLocalsInit`Özniteliği tek kullanılan bir özniteliktir ve bir metoda, özelliğe, bir sınıfa, yapıya, arabirime veya modüle uygulanabilir ancak bir derlemeye uygulanamaz.</span><span class="sxs-lookup"><span data-stu-id="a59c4-188">The `SkipLocalsInit` attribute is a single-use attribute and can be applied to a method, a property, a class, a struct, an interface, or a module, but not to an assembly.</span></span> <span data-ttu-id="a59c4-189">`SkipLocalsInit` , için bir diğer addır <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> .</span><span class="sxs-lookup"><span data-stu-id="a59c4-189">`SkipLocalsInit` is an alias for <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span>

<span data-ttu-id="a59c4-190">`.locals init`Bayrak, clr 'nin bir yöntemde belirtilen tüm yerel değişkenleri varsayılan değerlerine başlatmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a59c4-190">The `.locals init` flag causes the CLR to initialize all of the local variables declared in a method to their default values.</span></span> <span data-ttu-id="a59c4-191">Derleyici aynı zamanda bir değeri bir değere atamadan önce hiçbir şekilde hiç bir değişken kullandığınızdan emin olduğundan, `.locals init` genellikle gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-191">Since the compiler also makes sure that you never use a variable before assigning some value to it, `.locals init` is typically not necessary.</span></span> <span data-ttu-id="a59c4-192">Ancak, yığın üzerinde bir dizi ayırmak için [stackalloc](../operators/stackalloc.md) kullandığınızda gibi, ek sıfır başlatma bazı senaryolarda ölçülebilir performans etkisine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-192">However, the extra zero-initialization may have measurable performance impact in some scenarios, such as when you use [stackalloc](../operators/stackalloc.md) to allocate an array on the stack.</span></span> <span data-ttu-id="a59c4-193">Bu durumlarda `SkipLocalsInit` özniteliği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a59c4-193">In those cases, you can add the `SkipLocalsInit` attribute.</span></span> <span data-ttu-id="a59c4-194">Bir yönteme doğrudan uygulanırsa öznitelik, Lambdalar ve yerel işlevler dahil olmak üzere bu yöntemi ve tüm iç içe geçmiş işlevleri etkiler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-194">If applied to a method directly, the attribute affects that method and all its nested functions, including lambdas and local functions.</span></span> <span data-ttu-id="a59c4-195">Bir tür veya modüle uygulanmışsa, içinde iç içe geçmiş tüm yöntemleri etkiler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-195">If applied to a type or module, it affects all methods nested inside.</span></span> <span data-ttu-id="a59c4-196">Bu öznitelik soyut yöntemleri etkilemez, ancak uygulama için oluşturulan kodu etkiler.</span><span class="sxs-lookup"><span data-stu-id="a59c4-196">This attribute does not affect abstract methods, but it does affect code generated for the implementation.</span></span>

<span data-ttu-id="a59c4-197">Bu öznitelik, [AllowUnsafeBlocks](../compiler-options/language.md#allowunsafeblocks) derleyici seçeneğini gerektiriyor.</span><span class="sxs-lookup"><span data-stu-id="a59c4-197">This attribute requires the [AllowUnsafeBlocks](../compiler-options/language.md#allowunsafeblocks) compiler option.</span></span> <span data-ttu-id="a59c4-198">Bu, bazı durumlarda kod atanmamış belleği (örneğin, başlatılmamış yığına ayrılan bellekten okuma) görüntüleyebileceğinden emin olmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a59c4-198">This is to signal that in some cases code could view unassigned memory (for example, reading from uninitialized stack-allocated memory).</span></span>

<span data-ttu-id="a59c4-199">Aşağıdaki örnek, `SkipLocalsInit` tarafından kullanılan bir yöntemde özniteliğinin etkisini gösterir `stackalloc` .</span><span class="sxs-lookup"><span data-stu-id="a59c4-199">The following example illustrates the effect of `SkipLocalsInit` attribute on a method that uses `stackalloc`.</span></span> <span data-ttu-id="a59c4-200">Bu yöntem, tamsayılar dizisi ayrıldığında bellekte ne olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="a59c4-200">The method displays whatever was in memory when the array of integers was allocated.</span></span>

:::code language="csharp" source="snippets/SkipLocalsInitExample.cs" id="ReadUninitializedMemory":::

<span data-ttu-id="a59c4-201">Bu kodu kendiniz denemek için `AllowUnsafeBlocks` *. csproj* dosyanızdaki derleyici seçeneğini ayarlayın:</span><span class="sxs-lookup"><span data-stu-id="a59c4-201">To try this code yourself, set the `AllowUnsafeBlocks` compiler option in your *.csproj* file:</span></span>

```xml
<PropertyGroup>
  ...
  <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
</PropertyGroup>
```

## <a name="see-also"></a><span data-ttu-id="a59c4-202">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="a59c4-202">See also</span></span>

- <xref:System.Attribute>
- <xref:System.Reflection>
- [<span data-ttu-id="a59c4-203">Öznitelikler</span><span class="sxs-lookup"><span data-stu-id="a59c4-203">Attributes</span></span>](../../../standard/attributes/index.md)
- [<span data-ttu-id="a59c4-204">Yansıma</span><span class="sxs-lookup"><span data-stu-id="a59c4-204">Reflection</span></span>](../../programming-guide/concepts/reflection.md)
