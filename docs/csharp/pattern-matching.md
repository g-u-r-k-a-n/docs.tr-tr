---
title: Model eşleştirme C# Kılavuzu
description: İçindeki desenler eşleşen ifadeler hakkında bilgi edininC#
ms.date: 04/10/2019
ms.technology: csharp-fundamentals
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: ffa59d073ad891fd93e0f8d7ad8889de0499b106
ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/03/2020
ms.locfileid: "78241019"
---
# <a name="pattern-matching"></a><span data-ttu-id="93a0c-103">Desen Eşleştirme</span><span class="sxs-lookup"><span data-stu-id="93a0c-103">Pattern Matching</span></span>

<span data-ttu-id="93a0c-104">Desenler bir değerin belirli bir *şekle*sahip olduğunu ve eşleşen şekline sahip olduğu zaman değerden bilgi *ayıklayabilirler* .</span><span class="sxs-lookup"><span data-stu-id="93a0c-104">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="93a0c-105">Model eşleştirme, günümüzde zaten kullandığınız algoritmalar için daha kısa sözdizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="93a0c-105">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="93a0c-106">Mevcut söz dizimini kullanarak model eşleştirme algoritmaları zaten oluşturmuş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-106">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="93a0c-107">Değerleri test eden `if` veya `switch` deyimlerini yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="93a0c-107">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="93a0c-108">Daha sonra, bu deyimler eşleşiyorsa, bu değerden bilgi ayıklar ve bunları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-108">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="93a0c-109">Yeni sözdizimi öğeleri, zaten bildiğiniz deyimlere yönelik uzantılardır: `is` ve `switch`.</span><span class="sxs-lookup"><span data-stu-id="93a0c-109">The new syntax elements are extensions to statements you're already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="93a0c-110">Bu yeni uzantılar bir değeri test eden ve bu bilgileri ayıklayarak birleştirir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-110">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="93a0c-111">Bu makalede, nasıl okunabilir, kısa kod etkinleştirmesinin nasıl yapıldığını gösteren yeni sözdizimine bakacağız.</span><span class="sxs-lookup"><span data-stu-id="93a0c-111">In this article, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="93a0c-112">Desen eşleştirme, verilerin ve kodun ayrıldığı ve verilerin ve bunları işleyen yöntemlerin sıkı bir şekilde birbirine bağlı olduğu nesne odaklı tasarımlardan farklı olarak, verilerin ve kodun ayrıldığı deyimler sunar.</span><span class="sxs-lookup"><span data-stu-id="93a0c-112">Pattern matching enables idioms where data and the code are separated, unlike object-oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="93a0c-113">Bu yeni deyimleri göstermek için, model eşleştirme deyimlerini kullanarak geometrik şekilleri temsil eden yapılarla çalışmaalım.</span><span class="sxs-lookup"><span data-stu-id="93a0c-113">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="93a0c-114">Nesnenin çalışma zamanı türüne göre nesne davranışını özelleştirmek için sınıf hiyerarşileri oluşturma ve [sanal yöntemleri oluşturma ve geçersiz kılınan Yöntemler](methods.md#inherited) hakkında bilgi sahibisiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-114">You're probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="93a0c-115">Bu teknikler, bir sınıf hiyerarşisinde yapılandırılmamış veriler için mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-115">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="93a0c-116">Veriler ve Yöntemler ayrı olduğunda, diğer araçlara ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-116">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="93a0c-117">Yeni *model eşleştirme* yapıları, verileri incelemek ve bu verilerin herhangi bir koşuluna göre denetim akışını işlemek için temizleyici sözdizimini etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-117">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="93a0c-118">Bir değişkenin değerini test eden `if` deyimlerini ve `switch` zaten yazın.</span><span class="sxs-lookup"><span data-stu-id="93a0c-118">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="93a0c-119">Bir değişkenin türünü test eden `is` deyimlerini yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="93a0c-119">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="93a0c-120">*Model eşleştirme* , bu deyimlere yeni yetenekler ekler.</span><span class="sxs-lookup"><span data-stu-id="93a0c-120">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="93a0c-121">Bu makalede, farklı geometrik şekillerin alanını hesaplayan bir yöntem oluşturacaksınız.</span><span class="sxs-lookup"><span data-stu-id="93a0c-121">In this article, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="93a0c-122">Ancak, nesne yönelimli teknikler için bir daha olmadan ve farklı şekiller için bir sınıf hiyerarşisi oluşturmadan bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-122">But, you'll do it without resorting to object-oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="93a0c-123">Bunun yerine *model eşleştirmeyi* kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="93a0c-123">You'll use *pattern matching* instead.</span></span>
<span data-ttu-id="93a0c-124">Bu örneğe giderek, bu kodun bir nesne hiyerarşisi olarak nasıl yapılandırıldığı ile karşıtlığı vardır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-124">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="93a0c-125">Sorgu ve işleme gereken veriler bir sınıf hiyerarşisi olmadığında, desen eşleştirme zarif tasarımları mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-125">When the data you must query and manipulate isn't a class hierarchy, pattern matching enables elegant designs.</span></span>

<span data-ttu-id="93a0c-126">Bir soyut şekil tanımıyla başlamak ve farklı özel şekil sınıfları eklemek yerine, yalnızca geometrik şekillerin her biri için yalnızca basit veri tanımlarıyla başlayalım.</span><span class="sxs-lookup"><span data-stu-id="93a0c-126">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/snippets/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="93a0c-127">Bu yapılardan, bazı şekillerin alanını hesaplayan bir yöntem yazalım.</span><span class="sxs-lookup"><span data-stu-id="93a0c-127">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="93a0c-128">`is` tür deseninin ifadesi</span><span class="sxs-lookup"><span data-stu-id="93a0c-128">The `is` type pattern expression</span></span>

<span data-ttu-id="93a0c-129">7,0 C# öncesinde, her türü bir dizi `if` ve `is` deyimlerde test etmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="93a0c-129">Before C# 7.0, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="93a0c-130">Yukarıdaki kod, *tür deseninin*klasik bir ifadesidir: türünü tespit etmek ve bu türe göre farklı bir eylem almak için bir değişkeni test etiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-130">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="93a0c-131">Bu kod, test başarılı olursa bir değişken atamak için `is` ifadesi uzantıları kullanılarak daha kolay hale gelir:</span><span class="sxs-lookup"><span data-stu-id="93a0c-131">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="93a0c-132">Bu güncelleştirilmiş sürümde, `is` ifadesi her ikisi de değişkeni sınar ve uygun türdeki yeni bir değişkene atar.</span><span class="sxs-lookup"><span data-stu-id="93a0c-132">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="93a0c-133">Ayrıca, bu sürümün bir `struct``Rectangle` türünü de içerdiğine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="93a0c-133">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="93a0c-134">Yeni `is` ifadesi, değer türleri ve başvuru türleri ile birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-134">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="93a0c-135">Bir eşleştirme ifadesinin sonuçlarının yanlış kullanılmasını önlemenize yardımcı olacak şekilde, model eşleştirme ifadelerine yönelik dil kuralları.</span><span class="sxs-lookup"><span data-stu-id="93a0c-135">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="93a0c-136">Yukarıdaki örnekte, `s`, `c`ve `r` değişkenleri yalnızca kapsamdadır ve ilgili model eşleştirme ifadelerinde `true` sonuçları olduğunda kesinlikle atanır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-136">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="93a0c-137">Başka bir konumda herhangi bir değişken kullanmayı denerseniz, kodunuz derleyici hataları oluşturur.</span><span class="sxs-lookup"><span data-stu-id="93a0c-137">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="93a0c-138">Bu kuralların her ikisini de kapsam ile başlayarak ayrıntılı bir şekilde incelim.</span><span class="sxs-lookup"><span data-stu-id="93a0c-138">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="93a0c-139">`c` değişkeni yalnızca ilk `if` deyimin `else` dalında kapsamdadır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-139">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="93a0c-140">`s` değişkeni, metot `ComputeAreaModernIs`kapsamdadır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-140">The variable `s` is in scope in the method `ComputeAreaModernIs`.</span></span> <span data-ttu-id="93a0c-141">Bunun nedeni, `if` deyimin her bir dalı değişkenler için ayrı bir kapsam oluşturur.</span><span class="sxs-lookup"><span data-stu-id="93a0c-141">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="93a0c-142">Ancak, `if` deyimin kendisi değildir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-142">However, the `if` statement itself doesn't.</span></span> <span data-ttu-id="93a0c-143">Diğer bir deyişle, `if` bildiriminde belirtilen değişkenlerin `if` bildirimiyle aynı kapsamda (Bu durumda, yöntemi). Bu davranış, model eşleştirmeye özgü değildir, ancak değişken kapsamları ve `if` ve `else` deyimleri için tanımlanan davranıştır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-143">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior isn't specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="93a0c-144">`c` ve `s` değişkenleri, kesin olarak atanan doğru mekanizmasından dolayı ilgili `if` deyimleri doğru olduğunda atanır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-144">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="93a0c-145">Bu konudaki örneklerde, `if` deyiminin `true` dalında eşleşme değişkenini kesin bir şekilde atayan bir model eşleştirme `is` ifadesi, önerilen yapıyı kullanır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-145">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="93a0c-146">`if (!(shape is Square s))` diyerek mantığı ters çevirebilirsiniz ve `s` değişkeni yalnızca `false` dalında kesinlikle atanmasını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-146">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="93a0c-147">Bu geçerli C#olsa da, mantığın izlenmesi daha kafa karıştırıcı olduğundan önerilmez.</span><span class="sxs-lookup"><span data-stu-id="93a0c-147">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="93a0c-148">Bu kurallar, bu düzenin karşılanmadığı zaman bir model eşleştirme ifadesinin sonucuna yanlışlıkla erişmeniz çok düşüktür.</span><span class="sxs-lookup"><span data-stu-id="93a0c-148">These rules mean that you're unlikely to accidentally access the result of a pattern match expression when that pattern wasn't met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="93a0c-149">Model eşleştirme `switch` deyimlerini kullanma</span><span class="sxs-lookup"><span data-stu-id="93a0c-149">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="93a0c-150">Aynı zamanda, diğer şekil türlerini desteklemeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-150">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="93a0c-151">Test ettiğiniz koşulların sayısı arttıkça, `is` deseninin eşleşen ifadelerin kullanımı fazla olabilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-151">As the number of conditions you're testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="93a0c-152">Denetlemek istediğiniz her türde `if` deyimlerinin gerektirmesinin yanı sıra, girişin tek bir türle eşleşmesi durumunda `is` ifadeleri test etmek için sınırlandırılır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-152">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="93a0c-153">Bu durumda, `switch` deseninin eşleşen ifadelerin daha iyi bir seçenek haline geldiğini göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-153">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="93a0c-154">Geleneksel `switch` deyimi bir desenli ifadedir: sabit örüntü destekleniyor.</span><span class="sxs-lookup"><span data-stu-id="93a0c-154">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="93a0c-155">Bir değişkeni `case` ifadesinde kullanılan herhangi bir sabitle karşılaştırabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="93a0c-155">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="93a0c-156">`switch` deyimin desteklediği tek desenler sabit bir modeldir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-156">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="93a0c-157">Sayısal türlerle ve `string` türüyle daha fazla sınırlandırıldı.</span><span class="sxs-lookup"><span data-stu-id="93a0c-157">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="93a0c-158">Bu kısıtlamalar kaldırılmıştır ve artık tür modelini kullanarak bir `switch` ifadesini yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="93a0c-158">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="93a0c-159">`switch` ifadesiyle eşleşen desenler, geleneksel C stili `switch` ifadesini kullanan geliştiriciler için tanıdık sözdizimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-159">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="93a0c-160">Her `case` değerlendirilir ve giriş değişkeniyle eşleşen koşulun altındaki kod yürütülür.</span><span class="sxs-lookup"><span data-stu-id="93a0c-160">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="93a0c-161">Kod yürütme, bir Case ifadesinden sonrakine "düşmüyor". `case` deyimin sözdizimi her bir `case` `break`, `return`veya `goto`ile bitmesidir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-161">Code execution can't "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="93a0c-162">Başka bir etikete atlanacak `goto` deyimleri yalnızca sabit model için geçerlidir (klasik switch deyimi).</span><span class="sxs-lookup"><span data-stu-id="93a0c-162">The `goto` statements to jump to another label are valid only for the constant pattern (the classic switch statement).</span></span>

<span data-ttu-id="93a0c-163">`switch` ifadesini düzenleyen önemli yeni kurallar vardır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-163">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="93a0c-164">`switch` ifadesindeki değişkenin türüyle ilgili kısıtlamalar kaldırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-164">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="93a0c-165">Bu örnekteki `object` gibi herhangi bir tür kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-165">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="93a0c-166">Case ifadeleri artık sabit değerlerle sınırlı değildir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-166">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="93a0c-167">Bu sınırlamanın kaldırılması, yeniden sıralama `switch` bölümlerinin bir programın davranışını değiştirebileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-167">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="93a0c-168">Sabit değerlerle sınırlı olduğunda, birden fazla `case` etiketi `switch` ifadesinin değeriyle eşleşemez.</span><span class="sxs-lookup"><span data-stu-id="93a0c-168">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="93a0c-169">Her `switch` bölümünün bir sonraki bölüme düşmemelidir ve `switch` bölümlerinin davranışı etkilemeden herhangi bir sırada yeniden düzenlenebilir olması için bunu birleştirin.</span><span class="sxs-lookup"><span data-stu-id="93a0c-169">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="93a0c-170">Artık, daha Genelleştirilmiş `switch` ifadelerle, her bölümün sırası önemlidir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-170">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="93a0c-171">`switch` ifadeleri metin sırasına göre değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-171">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="93a0c-172">Yürütme aktarımları, `switch` ifadesiyle eşleşen ilk `switch` etiketine aktarılır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-172">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="93a0c-173">`default` durum yalnızca başka bir durum etiketi eşleşmezse yürütülür.</span><span class="sxs-lookup"><span data-stu-id="93a0c-173">The `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="93a0c-174">`default` durum, metin sırası ne olursa olsun son olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-174">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="93a0c-175">`default` bir durum yoksa ve diğer `case` deyimlerinin hiçbiri eşleşmezse, yürütme, `switch` deyiminden sonraki deyimde devam eder.</span><span class="sxs-lookup"><span data-stu-id="93a0c-175">If there's no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="93a0c-176">`case` etiket kodunun hiçbiri yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="93a0c-176">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="93a0c-177">`case` ifadelerinde `when` yan tümceleri</span><span class="sxs-lookup"><span data-stu-id="93a0c-177">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="93a0c-178">`case` etiketinde bir `when` yan tümcesini kullanarak 0 alanı olan şekiller için özel durumlar yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-178">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="93a0c-179">Yüz uzunluğu 0 olan bir kare veya yarıçapı 0 olan bir daire 0 alanına sahiptir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-179">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="93a0c-180">`case` etiketinde `when` yan tümcesini kullanarak bu koşulu belirtirsiniz:</span><span class="sxs-lookup"><span data-stu-id="93a0c-180">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="93a0c-181">Bu değişiklik, yeni sözdizimi hakkında bazı önemli noktaları gösterir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-181">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="93a0c-182">İlk olarak, birden çok `case` etiketi bir `switch` bölümüne uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-182">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="93a0c-183">Bu etiketlerin herhangi biri `true`olduğunda, ekstre bloğu yürütülür.</span><span class="sxs-lookup"><span data-stu-id="93a0c-183">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="93a0c-184">Bu örnekte, `switch` ifadesi bir daire ya da 0 alanı olan bir kare ise, yöntem 0 sabitini döndürür.</span><span class="sxs-lookup"><span data-stu-id="93a0c-184">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="93a0c-185">Bu örnek, ilk `switch` bloğunun iki `case` etiketlerinde iki farklı değişken tanıtır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-185">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="93a0c-186">Bu `switch` bloğundaki deyimlerin `c` (daire için) veya `s` (kare için) değişkenlerini kullandığına dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="93a0c-186">Notice that the statements in this `switch` block don't use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="93a0c-187">Bu değişkenlerden hiçbiri kesinlikle bu `switch` bloğunda atanmaz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-187">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="93a0c-188">Bu durumlardan biri eşleşiyorsa, değişkenlerden açıkça biri atanır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-188">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="93a0c-189">Ancak, çalışma zamanında eşleşeceğinden, derleme zamanında *hangisinin* atandığını söylemek olanaksızdır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-189">However, it's impossible to tell *which* has been assigned at compile time, because either case could match at runtime.</span></span> <span data-ttu-id="93a0c-190">Bu nedenle, aynı blok için birden çok `case` etiketi kullandığınızda, `case` bildiriminde yeni bir değişken açıklamaz veya yalnızca `when` yan tümcesindeki değişkenini kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="93a0c-190">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you'll only use the variable in the `when` clause.</span></span>

<span data-ttu-id="93a0c-191">Bu şekilleri 0 alanla eklediyseniz, daha fazla şekil türü ekleyelim: dikdörtgen ve üçgen:</span><span class="sxs-lookup"><span data-stu-id="93a0c-191">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="93a0c-192">Bu değişiklik kümesi, Yeni şekillerin her biri için bozuk Case ve Labels ve blokların `case` Etiketler ekler.</span><span class="sxs-lookup"><span data-stu-id="93a0c-192">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="93a0c-193">Son olarak, bağımsız değişkenin `null`olmamasını sağlamak için `null` bir durum ekleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="93a0c-193">Finally, you can add a `null` case to ensure the argument isn't `null`:</span></span>

[!code-csharp[NullCase](../../samples/snippets/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="93a0c-194">`null` deseninin özel davranışı ilginç olduğundan, düzendeki sabit `null` bir tür olmadığından, ancak herhangi bir başvuru türüne veya null yapılabilir türe dönüştürülebildiğinden.</span><span class="sxs-lookup"><span data-stu-id="93a0c-194">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern doesn't have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="93a0c-195">`null`, herhangi bir türe dönüştürmek yerine, değişkenin derleme zamanı türünden bağımsız olarak, bir `null` değerinin herhangi bir tür düzeniyle eşleşmeyeceğini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="93a0c-195">Rather than convert a `null` to any type, the language defines that a `null` value won't match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="93a0c-196">Bu davranış yeni `switch` tabanlı tür deseninin `is` ifadesiyle tutarlı olmasını sağlar: `is` deyimleri, denetlenen değer `null`olduğunda her zaman `false` döndürür.</span><span class="sxs-lookup"><span data-stu-id="93a0c-196">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="93a0c-197">Ayrıca daha basittir: türü denetledikten sonra, ek null bir denetim gerekmez.</span><span class="sxs-lookup"><span data-stu-id="93a0c-197">It's also simpler: once you've checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="93a0c-198">Yukarıdaki örneklerin herhangi bir durum bloklarında hiçbir null denetim olmadığını ve tür örüntüsünün eşleşmesi null olmayan bir değer garantisi olduğundan, bu durum gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-198">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they aren't necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="93a0c-199">`case` ifadelerinde `var` bildirimleri</span><span class="sxs-lookup"><span data-stu-id="93a0c-199">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="93a0c-200">Eşleşme ifadelerinden biri olarak `var` giriş, model eşleştirmesinde yeni kurallar tanıtır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-200">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="93a0c-201">İlk kural `var` bildirimi normal tür çıkarımı kurallarını izliyorsa: tür, anahtar ifadesinin statik türü olarak algılanır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-201">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="93a0c-202">Bu kuraldan, türü her zaman eşleşir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-202">From that rule, the type always matches.</span></span>

<span data-ttu-id="93a0c-203">İkinci kural, `var` bildiriminde diğer tür deseninin içerdiği null denetimi yoktur.</span><span class="sxs-lookup"><span data-stu-id="93a0c-203">The second rule is that a `var` declaration doesn't have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="93a0c-204">Bu, değişkenin null olabileceği ve bu durumda null bir denetim olması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-204">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="93a0c-205">Bu iki kural birçok örnekte, bir `case` ifadesinde `var` bildirimi `default` ifadesiyle aynı koşullara uyan anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-205">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="93a0c-206">`default` durum için varsayılan olmayan herhangi bir durum tercih edildiği için, `default` durumu hiçbir şekilde yürütülmeyecektir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-206">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="93a0c-207">Derleyici, `default` bir durumun yazıldığı ancak hiçbir zaman yürütülebileceği durumlarda uyarı göstermez.</span><span class="sxs-lookup"><span data-stu-id="93a0c-207">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="93a0c-208">Bu, olası tüm durumlar listelendiğinde geçerli `switch` deyimin davranışıyla tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-208">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="93a0c-209">Üçüncü kural, `var` bir durumun yararlı olabileceği yerleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-209">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="93a0c-210">Girişin bir dize olduğu ve bilinen komut değerlerini aradığınız bir model eşleşmesi yaptığınızı düşünün.</span><span class="sxs-lookup"><span data-stu-id="93a0c-210">Imagine that you're doing a pattern match where the input is a string and you're searching for known command values.</span></span> <span data-ttu-id="93a0c-211">Şöyle bir işlem yazabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="93a0c-211">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/snippets/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="93a0c-212">`var` durum `null`, boş dize veya yalnızca boşluk içeren herhangi bir dizeyle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-212">The `var` case matches `null`, the empty string, or any string that contains only white space.</span></span> <span data-ttu-id="93a0c-213">Önceki kodun, yanlışlıkla bir <xref:System.NullReferenceException>oluşturmadığından emin olmak için `?.` işlecini kullandığına dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="93a0c-213">Notice that the preceding code uses the `?.` operator to ensure that it doesn't accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="93a0c-214">`default` durum, bu komut ayrıştırıcısı tarafından anlaşılmayan diğer dize değerlerini işler.</span><span class="sxs-lookup"><span data-stu-id="93a0c-214">The `default` case handles any other string values that aren't understood by this command parser.</span></span>

<span data-ttu-id="93a0c-215">Bu, bir `default` ifadesinden farklı bir `var` Case ifadesini düşünmek isteyebileceğiniz bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-215">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="93a0c-216">Sonuçlar</span><span class="sxs-lookup"><span data-stu-id="93a0c-216">Conclusions</span></span>

<span data-ttu-id="93a0c-217">*Model eşleştirme yapıları* , bir devralma hiyerarşisi tarafından ilgili olmayan farklı değişkenler ve türler arasında denetim akışını kolayca yönetmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="93a0c-217">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that aren't related by an inheritance hierarchy.</span></span> <span data-ttu-id="93a0c-218">Ayrıca, değişkende test ettiğiniz herhangi bir koşulu kullanmak için mantığı da denetleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-218">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="93a0c-219">Daha fazla dağıtılmış uygulama oluştururken daha sık ihtiyacınız olacak desenler ve deyimler sayesinde, verilerin ve bu verileri işleyen yöntemlerin ayrı olduğu durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="93a0c-219">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="93a0c-220">Bu örnekte kullanılan şekil yapıların hiçbir yöntem içermediğini, yalnızca salt okunurdur özellikleri olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-220">You'll notice that the shape structs used in this sample don't contain any methods, just read-only properties.</span></span>
<span data-ttu-id="93a0c-221">Model eşleştirme, herhangi bir veri türü ile birlikte çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="93a0c-221">Pattern Matching works with any data type.</span></span> <span data-ttu-id="93a0c-222">Nesneyi inceleyecek ve bu koşullara göre denetim akışı kararları veren ifadeler yazarsınız.</span><span class="sxs-lookup"><span data-stu-id="93a0c-222">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="93a0c-223">Bu örnekteki kodu, bir soyut `Shape` için bir sınıf hiyerarşisi oluşturmaktan ve her biri, alanı hesaplamak için bir sanal yöntemin kendi uygulamalarına sahip olan belirli türetilmiş şekillerin, bu örnekten karşılaştırın.</span><span class="sxs-lookup"><span data-stu-id="93a0c-223">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="93a0c-224">Genellikle, verilerle çalışırken ve veri depolama sorunlarını davranış kaygılarından ayırmak istediğinizde, model eşleştirme ifadelerinin çok faydalı bir araç olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-224">You'll often find that pattern matching expressions can be a very useful tool when you're working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

## <a name="see-also"></a><span data-ttu-id="93a0c-225">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="93a0c-225">See also</span></span>

- [<span data-ttu-id="93a0c-226">Öğretici: veri türlerini genişletmek için model eşleştirme özelliklerini kullanma</span><span class="sxs-lookup"><span data-stu-id="93a0c-226">Tutorial: Using pattern matching features to extend data types</span></span>](tutorials/pattern-matching.md)
