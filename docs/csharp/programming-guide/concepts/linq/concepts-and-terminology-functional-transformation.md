---
title: Kavramlar ve terminoloji (Işlevsel dönüşüm) (C#)
description: Fonksiyonel programlama özellikleri XML dönüştürmeyi kolaylaştırır. C# ' de saf işlevsel dönüşümlerinin kavramları ve terminolojisi hakkında bilgi edinin.
ms.date: 07/20/2015
ms.assetid: 03defb3a-7e17-4ab1-8efa-4dd66621e860
ms.openlocfilehash: ca05a914f6156730e773d1effebfc72626b16507
ms.sourcegitcommit: 7476c20d2f911a834a00b8a7f5e8926bae6804d9
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/11/2020
ms.locfileid: "88063282"
---
# <a name="concepts-and-terminology-functional-transformation-c"></a><span data-ttu-id="383a1-104">Kavramlar ve terminoloji (Işlevsel dönüşüm) (C#)</span><span class="sxs-lookup"><span data-stu-id="383a1-104">Concepts and Terminology (Functional Transformation) (C#)</span></span>

<span data-ttu-id="383a1-105">Bu konu, saf işlevsel dönüştürmelerin kavramlarını ve terminolojisini tanıtır.</span><span class="sxs-lookup"><span data-stu-id="383a1-105">This topic introduces the concepts and terminology of pure functional transformations.</span></span> <span data-ttu-id="383a1-106">Veri dönüştürme yaklaşımı, genellikle programa, daha ayrıntılı bir şekilde daha hızlı ve hata ayıklama ve daha geleneksel, kesinlik temelli programlama açısından daha kolay olan kodu verir.</span><span class="sxs-lookup"><span data-stu-id="383a1-106">The functional transformation approach to transforming data yields code that is often quicker to program, more expressive, and easier to debug and maintain than more traditional, imperative programming.</span></span>

<span data-ttu-id="383a1-107">Bu bölümdeki konuların işlevsel programlamayı tam olarak açıklamak için düşünülmediğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="383a1-107">Note that the topics in this section are not intended to fully explain functional programming.</span></span> <span data-ttu-id="383a1-108">Bunun yerine, bu konular XML 'i bir şekilden diğerine dönüştürmeyi kolaylaştıran bazı işlevsel programlama özelliklerini belirler.</span><span class="sxs-lookup"><span data-stu-id="383a1-108">Instead, these topics identify some of the functional programming capabilities that make it easier to transform XML from one shape to another.</span></span>

## <a name="what-is-pure-functional-transformation"></a><span data-ttu-id="383a1-109">Saf Işlevsel dönüştürme nedir?</span><span class="sxs-lookup"><span data-stu-id="383a1-109">What Is Pure Functional Transformation?</span></span>

<span data-ttu-id="383a1-110">*Saf işlevsel dönüşümde*, *saf işlevler*olarak adlandırılan bir işlevler kümesi, bir dizi yapısal veriyi özgün formdan başka bir biçime dönüştürmeyi tanımlar.</span><span class="sxs-lookup"><span data-stu-id="383a1-110">In *pure functional transformation*, a set of functions, called *pure functions*, define how to transform a set of structured data from its original form into another form.</span></span> <span data-ttu-id="383a1-111">"Saf" sözcüğü, işlevlerin *birleştirilebilen*şekilde olduğunu belirtir ve şunları gerektirir:</span><span class="sxs-lookup"><span data-stu-id="383a1-111">The word "pure" indicates that the functions are *composable*, which requires that they are:</span></span>

- <span data-ttu-id="383a1-112">*Kendi kendine dahil*olmak üzere, bağımsız olarak sıralanmış ve daha sonra programın geri kalanı olmadan bir arada ve yeniden düzenlenecek şekilde yeniden düzenlenebilir.</span><span class="sxs-lookup"><span data-stu-id="383a1-112">*Self-contained*, so that they can be freely ordered and rearranged without entanglement or interdependencies with the rest of the program.</span></span> <span data-ttu-id="383a1-113">Saf dönüşümler, ortamları hakkında bilgi sahibi değildir veya etkilemez.</span><span class="sxs-lookup"><span data-stu-id="383a1-113">Pure transformations have no knowledge of or effect upon their environment.</span></span> <span data-ttu-id="383a1-114">Diğer bir deyişle, dönüşümde kullanılan işlevlerin *yan etkileri*yoktur.</span><span class="sxs-lookup"><span data-stu-id="383a1-114">That is, the functions used in the transformation have no *side effects*.</span></span>

- <span data-ttu-id="383a1-115">*Durum bilgisiz*, aynı veya aynı girişte aynı işlevin veya belirli bir işlev kümesinin yürütülmesi her zaman aynı çıkışa neden olur.</span><span class="sxs-lookup"><span data-stu-id="383a1-115">*Stateless*, so that executing the same function or specific set of functions on the same input will always result in the same output.</span></span> <span data-ttu-id="383a1-116">Saf dönüşümlerinin önceki kullanımları belleği yoktur.</span><span class="sxs-lookup"><span data-stu-id="383a1-116">Pure transformations have no memory of their prior use.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="383a1-117">Bu öğreticinin geri kalanında, "saf işlev" terimi, belirli bir dil özelliği değil, programlama yaklaşımını göstermek için genel anlamda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="383a1-117">In the rest of this tutorial, the term "pure function" is used in a general sense to indicate a programming approach, and not a specific language feature.</span></span>
>
> <span data-ttu-id="383a1-118">Saf işlevlerin C# dilinde yöntemler olarak uygulanması gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="383a1-118">Note that pure functions must be implemented as methods in C#.</span></span>
>
> <span data-ttu-id="383a1-119">Ayrıca, saf işlevleri C++ ' da saf sanal yöntemlerle karıştırmayın.</span><span class="sxs-lookup"><span data-stu-id="383a1-119">Also, you should not confuse pure functions with pure virtual methods in C++.</span></span> <span data-ttu-id="383a1-120">İkincisi, kapsayan sınıfın soyut olduğunu ve hiçbir Yöntem gövdesinin sağlanmadığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="383a1-120">The latter indicates that the containing class is abstract and that no method body is supplied.</span></span>

### <a name="functional-programming"></a><span data-ttu-id="383a1-121">Fonksiyonel programlama</span><span class="sxs-lookup"><span data-stu-id="383a1-121">Functional Programming</span></span>

<span data-ttu-id="383a1-122">*Fonksiyonel programlama* , saf işlevsel dönüştürmeyi doğrudan destekleyen bir programlama yaklaşımıdır.</span><span class="sxs-lookup"><span data-stu-id="383a1-122">*Functional programming* is a programming approach that directly supports pure functional transformation.</span></span>

<span data-ttu-id="383a1-123">Geçmişte, genel amaçlı işlevsel programlama dilleri, örneğin ML, düzen, Haskell ve F #, birincil olarak akademik toplulukla ilgilenmiştir.</span><span class="sxs-lookup"><span data-stu-id="383a1-123">Historically, general-purpose functional programming languages, such as ML, Scheme, Haskell, and F#, have been primarily of interest to the academic community.</span></span> <span data-ttu-id="383a1-124">C# dilinde saf işlevsel dönüşümler yazmak her zaman mümkün olsa da, bunu yapmanın zorluğunu çoğu programcıya etkileyici bir seçenek yapmamıştır.</span><span class="sxs-lookup"><span data-stu-id="383a1-124">Although it has always been possible to write pure functional transformations in C#, the difficulty of doing so has not made it an attractive option to most programmers.</span></span> <span data-ttu-id="383a1-125">C# ' nin son sürümlerinde, lambda ifadeleri ve tür çıkarımı gibi yeni dil yapıları BT programlama açısından çok daha kolay ve üretken hale gelir.</span><span class="sxs-lookup"><span data-stu-id="383a1-125">In recent versions of C#, however, new language constructs such as lambda expressions and type inference make it functional programming much easier and more productive.</span></span>

<span data-ttu-id="383a1-126">Fonksiyonel programlama hakkında daha fazla bilgi için bkz. [fonksiyonel programlama vs. kesinlik programlama (C#)](./functional-programming-vs-imperative-programming.md).</span><span class="sxs-lookup"><span data-stu-id="383a1-126">For more information about functional programming, see [Functional Programming vs. Imperative Programming (C#)](./functional-programming-vs-imperative-programming.md).</span></span>

#### <a name="domain-specific-fp-languages"></a><span data-ttu-id="383a1-127">Etki alanına özgü FP dilleri</span><span class="sxs-lookup"><span data-stu-id="383a1-127">Domain-Specific FP Languages</span></span>

<span data-ttu-id="383a1-128">Genel fonksiyonel programlama dilleri çok daha fazla benimsemese de, etki alanına özgü belirli işlevsel programlama dillerinin başarısı daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="383a1-128">Although general functional programming languages have not been widely adopted, specific domain-specific functional programming languages have had better success.</span></span> <span data-ttu-id="383a1-129">Örneğin, birçok Web sayfasının görünümünü ve kullanımını belirlemede Geçişli Stil Sayfaları (CSS) kullanılır ve Genişletilebilir Stil sayfası dil dönüşümleri (XSLT) stil sayfaları, XML veri işleme açısından kapsamlı olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="383a1-129">For example, Cascading Style Sheets (CSS) are used to determine the look and feel of many Web pages, and Extensible Stylesheet Language Transformations (XSLT) style sheets are used extensively in XML data manipulation.</span></span> <span data-ttu-id="383a1-130">XSLT hakkında daha fazla bilgi için bkz. [XSLT dönüştürmeleri](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="383a1-130">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>

## <a name="terminology"></a><span data-ttu-id="383a1-131">Terminoloji</span><span class="sxs-lookup"><span data-stu-id="383a1-131">Terminology</span></span>

<span data-ttu-id="383a1-132">Aşağıdaki tabloda, işlevsel dönüşümlerle ilgili bazı terimler tanımlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="383a1-132">The following table defines some terms related to functional transformations.</span></span>

<span data-ttu-id="383a1-133">daha yüksek sıralı (birinci sınıf) işlev </span><span class="sxs-lookup"><span data-stu-id="383a1-133">higher-order (first-class) function </span></span>\
<span data-ttu-id="383a1-134">Programlı bir nesne olarak değerlendirilenebilir bir işlev.</span><span class="sxs-lookup"><span data-stu-id="383a1-134">A function that can be treated as a programmatic object.</span></span> <span data-ttu-id="383a1-135">Örneğin, daha yüksek sıralı bir işlev başka işlevlere geçirilebilir veya bu işlevlerden döndürülebilir.</span><span class="sxs-lookup"><span data-stu-id="383a1-135">For example, a higher-order function can be passed to or returned from other functions.</span></span> <span data-ttu-id="383a1-136">C # c 'de temsilciler ve lambda ifadeleri, daha yüksek sıralı işlevleri destekleyen dil özelliklerdir.</span><span class="sxs-lookup"><span data-stu-id="383a1-136">In C#c, delegates and lambda expressions are language features that support higher-order functions.</span></span> <span data-ttu-id="383a1-137">Daha yüksek sıralı bir işlev yazmak için temsilcileri almak üzere bir veya daha fazla bağımsız değişken bildirir ve genellikle bunu çağırırken Lambda ifadelerini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="383a1-137">To write a higher-order function, you declare one or more arguments to take delegates, and you often use lambda expressions when calling it.</span></span> <span data-ttu-id="383a1-138">Standart sorgu işleçlerinin birçoğu daha yüksek sıralı işlevlerdir.</span><span class="sxs-lookup"><span data-stu-id="383a1-138">Many of the standard query operators are higher-order functions.</span></span>

<span data-ttu-id="383a1-139">Daha fazla bilgi için bkz. [Standart sorgu Işleçlerine genel bakış (C#)](./standard-query-operators-overview.md).</span><span class="sxs-lookup"><span data-stu-id="383a1-139">For more information, see [Standard Query Operators Overview (C#)](./standard-query-operators-overview.md).</span></span>

<span data-ttu-id="383a1-140">Lambda ifadesi </span><span class="sxs-lookup"><span data-stu-id="383a1-140">lambda expression </span></span>\
<span data-ttu-id="383a1-141">Temelde, bir temsilci türünün beklendiği her yerde kullanılabilecek bir satır içi anonim işlev.</span><span class="sxs-lookup"><span data-stu-id="383a1-141">Essentially, an inline anonymous function that can be used wherever a delegate type is expected.</span></span> <span data-ttu-id="383a1-142">Bu, lambda ifadelerinin basitleştirilmiş bir tanımıdır, ancak Bu öğreticinin amaçları doğrultusunda yeterlidir.</span><span class="sxs-lookup"><span data-stu-id="383a1-142">This is a simplified definition of lambda expressions, but it is adequate for the purposes of this tutorial.</span></span>

<span data-ttu-id="383a1-143">Hakkında daha fazla bilgi için bkz. [lambda ifadeleri](../../../language-reference/operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="383a1-143">For more information about, see [Lambda Expressions](../../../language-reference/operators/lambda-expressions.md).</span></span>

<span data-ttu-id="383a1-144">koleksiyon</span><span class="sxs-lookup"><span data-stu-id="383a1-144">collection \</span></span>
<span data-ttu-id="383a1-145">Genellikle tek biçimli bir tür için yapılandırılmış bir veri kümesi.</span><span class="sxs-lookup"><span data-stu-id="383a1-145">A structured set of data, usually of a uniform type.</span></span> <span data-ttu-id="383a1-146">LINQ ile uyumlu olmak için bir koleksiyonun <xref:System.Collections.IEnumerable> arabirimini veya <xref:System.Linq.IQueryable> arabirimini (ya da kendi genel karşılıklarından birini veya) uygulaması gerekir <xref:System.Collections.Generic.IEnumerator%601> <xref:System.Linq.IQueryable%601> .</span><span class="sxs-lookup"><span data-stu-id="383a1-146">To be compatible with LINQ, a collection must implement the <xref:System.Collections.IEnumerable> interface or the <xref:System.Linq.IQueryable> interface (or one of their generic counterparts, <xref:System.Collections.Generic.IEnumerator%601> or <xref:System.Linq.IQueryable%601>).</span></span>

<span data-ttu-id="383a1-147">tanımlama grubu (anonim türler) </span><span class="sxs-lookup"><span data-stu-id="383a1-147">tuple (anonymous types) </span></span>\
<span data-ttu-id="383a1-148">Bir matematiksel kavram olan tanımlama grubu, belirli bir türün her biri için sınırlı bir nesne dizisidir.</span><span class="sxs-lookup"><span data-stu-id="383a1-148">A mathematical concept, a tuple is a finite sequence of objects, each of a specific type.</span></span> <span data-ttu-id="383a1-149">Bir tanımlama grubu sıralı liste olarak da bilinir.</span><span class="sxs-lookup"><span data-stu-id="383a1-149">A tuple is also known as an ordered list.</span></span> <span data-ttu-id="383a1-150">Anonim türler, bu kavramın bir dil uygulamasıdır. Bu, adlandırılmamış bir sınıf türünün bildirilmesini ve bu türden bir nesnenin aynı anda oluşturulmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="383a1-150">Anonymous types are a language implementation of this concept, which enable an unnamed class type to be declared and an object of that type to be instantiated at the same time.</span></span>

<span data-ttu-id="383a1-151">Daha fazla bilgi için bkz. [anonim türler](../../classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="383a1-151">For more information, see [Anonymous Types](../../classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="383a1-152">Tür çıkarımı (örtük yazma) </span><span class="sxs-lookup"><span data-stu-id="383a1-152">type inference (implicit typing) </span></span>\
<span data-ttu-id="383a1-153">Bir derleyicinin açık tür bildirimi yokluğunda bir değişkenin türünü belirleme özelliği.</span><span class="sxs-lookup"><span data-stu-id="383a1-153">The ability of a compiler to determine the type of a variable in the absence of an explicit type declaration.</span></span>

<span data-ttu-id="383a1-154">Daha fazla bilgi için bkz. [örtülü olarak yazılan yerel değişkenler](../../classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="383a1-154">For more information, see [Implicitly Typed Local Variables](../../classes-and-structs/implicitly-typed-local-variables.md).</span></span>

<span data-ttu-id="383a1-155">ertelenmiş yürütme ve geç değerlendirme </span><span class="sxs-lookup"><span data-stu-id="383a1-155">deferred execution and lazy evaluation </span></span>\
<span data-ttu-id="383a1-156">Çözümlenmiş değeri gerçekten gerekli olana kadar bir ifadenin değerlendirilme ertelenmesi.</span><span class="sxs-lookup"><span data-stu-id="383a1-156">The delaying of evaluation of an expression until its resolved value is actually required.</span></span> <span data-ttu-id="383a1-157">Ertelenmiş yürütme, koleksiyonlarda desteklenir.</span><span class="sxs-lookup"><span data-stu-id="383a1-157">Deferred execution is supported in collections.</span></span>

<span data-ttu-id="383a1-158">Daha fazla bilgi için bkz. LINQ to XML (C#) ' de [LINQ Sorgularına Giriş (c#)](./introduction-to-linq-queries.md) ve [ertelenmiş yürütme ve geç değerlendirme](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).</span><span class="sxs-lookup"><span data-stu-id="383a1-158">For more information, see [Introduction to LINQ Queries (C#)](./introduction-to-linq-queries.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).</span></span>

<span data-ttu-id="383a1-159">Bu dil özellikleri, bu bölümün tamamında kod örneklerinde kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="383a1-159">These language features will be used in code samples throughout this section.</span></span>

## <a name="see-also"></a><span data-ttu-id="383a1-160">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="383a1-160">See also</span></span>

- [<span data-ttu-id="383a1-161">Saf Işlevsel dönüşümlere giriş (C#)</span><span class="sxs-lookup"><span data-stu-id="383a1-161">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="383a1-162">Fonksiyonel programlama ile kesinlik temelli programlama (C#)</span><span class="sxs-lookup"><span data-stu-id="383a1-162">Functional Programming vs. Imperative Programming (C#)</span></span>](./functional-programming-vs-imperative-programming.md)
