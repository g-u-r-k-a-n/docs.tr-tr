---
title: Sözdizimi analizine başlayın (Roslyn API'leri)
description: Sözdizimi ağaçlarını gezmeye, sorgulamaya ve yürümeye giriş.
ms.date: 02/05/2018
ms.custom: mvc
ms.openlocfilehash: 22d1303c9daa2ae35cf130b0c857cd7a5efdbe76
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "78240525"
---
# <a name="get-started-with-syntax-analysis"></a><span data-ttu-id="6f6cf-103">Sözdizimi analizine başlayın</span><span class="sxs-lookup"><span data-stu-id="6f6cf-103">Get started with syntax analysis</span></span>

<span data-ttu-id="6f6cf-104">Bu eğitimde, **Sözdizimi API'sini**keşfedeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-104">In this tutorial, you'll explore the **Syntax API**.</span></span> <span data-ttu-id="6f6cf-105">Sözdizimi API' si, C# veya Visual Basic programını açıklayan veri yapılarına erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-105">The Syntax API provides access to the data structures that describe a C# or Visual Basic program.</span></span> <span data-ttu-id="6f6cf-106">Bu veri yapıları, herhangi bir boyuttaki herhangi bir programı tam olarak temsil edebilecekleri kadar ayrıntıya sahiptir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-106">These data structures have enough detail that they can fully represent any program of any size.</span></span> <span data-ttu-id="6f6cf-107">Bu yapılar, derleyen ve doğru çalışan tam programları açıklayabilir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-107">These structures can describe complete programs that compile and run correctly.</span></span> <span data-ttu-id="6f6cf-108">Ayrıca, siz yazarken eksik programları editörde tanımlayabilirler.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-108">They can also describe incomplete programs, as you write them, in the editor.</span></span>

<span data-ttu-id="6f6cf-109">Bu zengin ifadeyi etkinleştirmek için, Sözdizimi API'sini oluşturan veri yapıları ve API'ler mutlaka karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-109">To enable this rich expression, the data structures and APIs that make up the Syntax API are necessarily complex.</span></span> <span data-ttu-id="6f6cf-110">Tipik "Hello World" programı için veri yapısının nasıl göründüğüyle başlayalım:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-110">Let's start with what the data structure looks like for the typical "Hello World" program:</span></span>

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="6f6cf-111">Önceki programın metnine bakın.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-111">Look at the text of the previous program.</span></span> <span data-ttu-id="6f6cf-112">Tanıdık öğeleri tanıyorsun.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-112">You recognize familiar elements.</span></span> <span data-ttu-id="6f6cf-113">Metnin tamamı tek bir kaynak dosyayı veya **derleme birimini**temsil eder.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-113">The entire text represents a single source file, or a **compilation unit**.</span></span> <span data-ttu-id="6f6cf-114">Bu kaynak dosyanın ilk üç satırı **yönergeleri kullanıyor.**</span><span class="sxs-lookup"><span data-stu-id="6f6cf-114">The first three lines of that source file are **using directives**.</span></span> <span data-ttu-id="6f6cf-115">Kalan kaynak bir **ad alanı bildiriminde**bulunur.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-115">The remaining source is contained in a **namespace declaration**.</span></span> <span data-ttu-id="6f6cf-116">Ad alanı bildirimi bir alt **sınıf bildirimi**içerir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-116">The namespace declaration contains a child **class declaration**.</span></span> <span data-ttu-id="6f6cf-117">Sınıf bildirimi bir **yöntem bildirimi**içerir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-117">The class declaration contains one **method declaration**.</span></span>

<span data-ttu-id="6f6cf-118">Sözdizimi API derleme birimini temsil eden kök içeren bir ağaç yapısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-118">The Syntax API creates a tree structure with the root representing the compilation unit.</span></span> <span data-ttu-id="6f6cf-119">Ağaçtaki düğümler, kullanma yönergelerini, ad alanı bildirimini ve programın diğer tüm öğelerini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-119">Nodes in the tree represent the using directives, namespace declaration and all the other elements of the program.</span></span> <span data-ttu-id="6f6cf-120">Ağaç yapısı en düşük seviyelere kadar devam ediyor: dize "Merhaba Dünya!"</span><span class="sxs-lookup"><span data-stu-id="6f6cf-120">The tree structure continues down to the lowest levels: the string "Hello World!"</span></span> <span data-ttu-id="6f6cf-121">bir **bağımsız değişkenin**soyundan gelen bir **dize gerçek belirtecidir.**</span><span class="sxs-lookup"><span data-stu-id="6f6cf-121">is a **string literal token** that is a descendent of an **argument**.</span></span> <span data-ttu-id="6f6cf-122">Sözdizimi API'si programın yapısına erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-122">The Syntax API provides access to the structure of the program.</span></span> <span data-ttu-id="6f6cf-123">Belirli kod uygulamaları için sorgu yapabilir, kodu anlamak için tüm ağacı gezdirebilir ve varolan ağacı değiştirerek yeni ağaçlar oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-123">You can query for specific code practices, walk the entire tree to understand the code, and create new trees by modifying the existing tree.</span></span>

<span data-ttu-id="6f6cf-124">Bu kısa açıklama, Sözdizimi API'sini kullanarak erişilebilen bilgi türüne genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-124">That brief description provides an overview of the kind of information accessible using the Syntax API.</span></span> <span data-ttu-id="6f6cf-125">Sözdizimi API'si, C#'dan bildiğiniz tanıdık kod yapılarını açıklayan resmi bir API'den başka bir şey değildir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-125">The Syntax API is nothing more than a formal API that describes the familiar code constructs you know from C#.</span></span> <span data-ttu-id="6f6cf-126">Tam özellikler, satır sonları, beyaz boşluk ve girintiyi de içeren kodun nasıl biçimlendirilip biçimlendirilenhakkında bilgi içerir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-126">The full capabilities include information about how the code is formatted including line breaks, white space, and indenting.</span></span> <span data-ttu-id="6f6cf-127">Bu bilgileri kullanarak, kodu insan programcılar veya derleyici tarafından yazılmış ve okunmuş olarak tam olarak temsil edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-127">Using this information, you can fully represent the code as written and read by human programmers or the compiler.</span></span> <span data-ttu-id="6f6cf-128">Bu yapıyı kullanmak, kaynak kodla son derece anlamlı bir düzeyde etkileşim kurmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-128">Using this structure enables you to interact with the source code on a deeply meaningful level.</span></span> <span data-ttu-id="6f6cf-129">Artık metin dizeleri değil, C# programının yapısını temsil eden verilerdir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-129">It's no longer text strings, but data that represents the structure of a C# program.</span></span>

<span data-ttu-id="6f6cf-130">Başlamak için **.NET Derleyici Platformu SDK'yı**yüklemeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-130">To get started, you'll need to install the **.NET Compiler Platform SDK**:</span></span>

[!INCLUDE[interactive-note](~/includes/roslyn-installation.md)]

## <a name="understanding-syntax-trees"></a><span data-ttu-id="6f6cf-131">Sözdizimi ağaçlarını anlama</span><span class="sxs-lookup"><span data-stu-id="6f6cf-131">Understanding syntax trees</span></span>

<span data-ttu-id="6f6cf-132">C# kodunun yapısının herhangi bir analizi için Sözdizimi API'sini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-132">You use the Syntax API for any analysis of the structure of C# code.</span></span> <span data-ttu-id="6f6cf-133">**Sözdizimi API** ayrışdırıcıları, sözdizimi ağaçlarını ve sözdizimi ağaçlarını çözümleme ve oluşturma yardımcı larını ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-133">The **Syntax API** exposes the parsers, the syntax trees, and utilities for analyzing and constructing syntax trees.</span></span> <span data-ttu-id="6f6cf-134">Belirli sözdizimi öğeleri için kodu arama veya bir programın kodunu okuma şeklidir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-134">It's how you search code for specific syntax elements or read the code for a program.</span></span>

<span data-ttu-id="6f6cf-135">Sözdizimi ağacı, C# ve Visual Basic derleyicileri tarafından C# ve Visual Basic programlarını anlamak için kullanılan bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-135">A syntax tree is a data structure used by the C# and Visual Basic compilers to understand C# and Visual Basic programs.</span></span> <span data-ttu-id="6f6cf-136">Sözdizimi ağaçları, bir proje inşa edildiğinde veya geliştirici F5'e ulaştığında çalışan aynı ayrıştırıcı tarafından üretilir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-136">Syntax trees are produced by the same parser that runs when a project is built or a developer hits F5.</span></span> <span data-ttu-id="6f6cf-137">Sözdizimi ağaçları nın dili yle tam sadakati vardır; kod dosyasındaki her bilgi parçası ağaçta temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-137">The syntax trees have full-fidelity with the language; every bit of information in a code file is represented in the tree.</span></span> <span data-ttu-id="6f6cf-138">Metne sözdizimi ağacı yazmak, ayrıştırılan tam özgün metni yeniden üretir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-138">Writing a syntax tree to text reproduces the exact original text that was parsed.</span></span> <span data-ttu-id="6f6cf-139">Sözdizimi ağaçları da **değişmez;** bir kez oluşturulan bir sözdizimi ağacı asla değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-139">The syntax trees are also **immutable**; once created a syntax tree can never be changed.</span></span> <span data-ttu-id="6f6cf-140">Ağaçların tüketicileri, verilerin hiçbir zaman değişmediğini bilerek, kilitler veya diğer eşzamanlılık önlemleri olmadan ağaçları birden fazla iplik üzerinde analiz edebilirler.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-140">Consumers of the trees can analyze the trees on multiple threads, without locks or other concurrency measures, knowing the data never changes.</span></span> <span data-ttu-id="6f6cf-141">Varolan bir ağacı değiştirmenin sonucu olan yeni ağaçlar oluşturmak için API'leri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-141">You can use APIs to create new trees that are the result of modifying an existing tree.</span></span>

<span data-ttu-id="6f6cf-142">Sözdizimi ağaçlarının dört ana yapı taşları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-142">The four primary building blocks of syntax trees are:</span></span>

* <span data-ttu-id="6f6cf-143">Sınıf, <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> bir örneği tüm ayrışdıran ağacı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-143">The <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType> class, an instance of which represents an entire parse tree.</span></span> <span data-ttu-id="6f6cf-144"><xref:Microsoft.CodeAnalysis.SyntaxTree>dile özgü türevleri olan soyut bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-144"><xref:Microsoft.CodeAnalysis.SyntaxTree> is an abstract class that has language-specific derivatives.</span></span> <span data-ttu-id="6f6cf-145">C# veya Visual Basic'teki <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>metni ayrıştırmak için (veya) sınıfının <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> ayrıştırma yöntemlerini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-145">You use the parse methods of the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTree?displayProperty=nameWithType>) class to parse text in C# or Visual Basic.</span></span>
* <span data-ttu-id="6f6cf-146">Bildirimler, deyimler, yan tümceler ve ifadeler gibi sözdizim yapılarını temsil eden <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> sınıf.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-146">The <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType> class, instances of which represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span>
* <span data-ttu-id="6f6cf-147">Tek <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> bir anahtar kelimeyi, tanımlayıcıyı, işleçveya noktalama işaretlerini temsil eden yapı.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-147">The <xref:Microsoft.CodeAnalysis.SyntaxToken?displayProperty=nameWithType> structure, which represents an individual keyword, identifier, operator, or punctuation.</span></span>
* <span data-ttu-id="6f6cf-148">Ve son <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> olarak, belirteçler, ön işleme yönergeleri ve yorumlar arasındaki beyaz boşluk gibi sözdizimsel olarak önemsiz bilgi bitlerini temsil eden yapı.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-148">And lastly the <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> structure, which represents syntactically insignificant bits of information such as the white space between tokens, preprocessing directives, and comments.</span></span>

<span data-ttu-id="6f6cf-149">Trivia, belirteçleri ve düğümler hiyerarşik olarak Visual Basic veya C# kodunun bir parçasındaki her şeyi temsil eden bir ağaç oluşturmak üzere oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-149">Trivia, tokens, and nodes are composed hierarchically to form a tree that completely represents everything in a fragment of Visual Basic or C# code.</span></span> <span data-ttu-id="6f6cf-150">Bu yapıyı **Sözdizimi Görselleştiricisi** penceresini kullanarak görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-150">You can see this structure using the **Syntax Visualizer** window.</span></span> <span data-ttu-id="6f6cf-151">Visual Studio'da**Diğer Windows** > **Sözdizimi Görselleştiricisini** **Görüntüle'yi** > seçin.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-151">In Visual Studio, choose **View** > **Other Windows** > **Syntax Visualizer**.</span></span> <span data-ttu-id="6f6cf-152">Örneğin, **Sözdizimi Görselleştiricisi** kullanılarak incelenen önceki C# kaynak dosyası aşağıdaki şekilde görünür:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-152">For example, the preceding C# source file examined using the **Syntax Visualizer** looks like the following figure:</span></span>

<span data-ttu-id="6f6cf-153">**SözdizimiNode**: Mavi | **SözdizimiToken**: Yeşil | **SözdizimiTrivia** ![: Kırmızı C# Kodu Dosyası](media/walkthrough-csharp-syntax-figure1.png)</span><span class="sxs-lookup"><span data-stu-id="6f6cf-153">**SyntaxNode**: Blue | **SyntaxToken**: Green | **SyntaxTrivia**: Red ![C# Code File](media/walkthrough-csharp-syntax-figure1.png)</span></span>

<span data-ttu-id="6f6cf-154">Bu ağaç yapısında gezinerek, bir kod dosyasında herhangi bir ifade, ifade, belirteç veya beyaz boşluk biti bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-154">By navigating this tree structure, you can find any statement, expression, token, or bit of white space in a code file.</span></span>

<span data-ttu-id="6f6cf-155">Sözdizimi API'lerini kullanarak bir kod dosyasında herhangi bir şey bulabilirsiniz, ancak çoğu senaryo kod küçük parçacıkları inceleyerek veya belirli ifadeler veya parçalar için arama içerir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-155">While you can find anything in a code file using the Syntax APIs, most scenarios involve examining small snippets of code, or searching for particular statements or fragments.</span></span> <span data-ttu-id="6f6cf-156">İzleyen iki örnek, kodun yapısına göz atmak veya tek bir deyim aramak için tipik kullanımları gösterir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-156">The two examples that follow show typical uses to browse the structure of code, or search for single statements.</span></span>

## <a name="traversing-trees"></a><span data-ttu-id="6f6cf-157">Ağaçların geçişi</span><span class="sxs-lookup"><span data-stu-id="6f6cf-157">Traversing trees</span></span>

<span data-ttu-id="6f6cf-158">Sözdizimi ağacındaki düğümleri iki şekilde inceleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-158">You can examine the nodes in a syntax tree in two ways.</span></span> <span data-ttu-id="6f6cf-159">Her düğümü incelemek için ağaçta geçiş yapabilir veya belirli öğeleri veya düğümleri sorgulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-159">You can traverse the tree to examine each node, or you can query for specific elements or nodes.</span></span>

### <a name="manual-traversal"></a><span data-ttu-id="6f6cf-160">Manuel geçiş</span><span class="sxs-lookup"><span data-stu-id="6f6cf-160">Manual traversal</span></span>

<span data-ttu-id="6f6cf-161">Bu örneğin bitmiş kodunu [GitHub depomuzda](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart)görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-161">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="6f6cf-162">Sözdizimi Ağacı türleri, programdaki farklı konumlarda geçerli olan farklı sözdizimi öğelerini açıklamak için kalıtım kullanır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-162">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="6f6cf-163">Bu API'lerin kullanılması genellikle özellikleri veya koleksiyon üyelerini belirli türemiş türlere dökümü anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-163">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="6f6cf-164">Aşağıdaki örneklerde, atama ve dökümler, açıkça yazılan değişkenler kullanılarak ayrı ifadelerdir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-164">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="6f6cf-165">API'nin geri dönüş türlerini ve döndürülen nesnelerin çalışma zamanı türünü görmek için kodu okuyabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-165">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="6f6cf-166">Uygulamada, örtülü olarak yazılan değişkenleri kullanmak ve incelenmekte olan nesnelerin türünü açıklamak için API adlarına güvenmek daha yaygındır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-166">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="6f6cf-167">Yeni bir C# **Tek Başına Kod Analizi Aracı** projesi oluşturun:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-167">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="6f6cf-168">Visual Studio'da, Yeni Proje iletişim kutusunu görüntülemek için **Dosya** > **Yeni** > **Projesi'ni** seçin.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-168">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="6f6cf-169">**Visual C#** > **Genişletilebilirlik** **altında, Tek Başına Kod Analiz Aracı'nı**seçin.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-169">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="6f6cf-170">Projenizi "**SözdizimiTreeManualTraversal**" adını ver ve Tamam'ı tıklatın.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-170">Name your project "**SyntaxTreeManualTraversal**" and click OK.</span></span>

<span data-ttu-id="6f6cf-171">Temel "Merhaba Dünya"yı analiz edeceksin.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-171">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="6f6cf-172">program daha önce gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-172">program shown earlier.</span></span>
<span data-ttu-id="6f6cf-173">Merhaba Dünya programı için metni sınıfınızda `Program` sabit olarak ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-173">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program text](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="6f6cf-174">Ardından, `programText` sabitteki kod metni için **sözdizimi ağacı** oluşturmak için aşağıdaki kodu ekleyin.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-174">Next, add the following code to build the **syntax tree** for the code text in the `programText` constant.</span></span>  <span data-ttu-id="6f6cf-175">Yönteminize `Main` aşağıdaki satırı ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-175">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="6f6cf-176">Bu iki satır ağacı oluşturmak ve bu ağacın kök düğümünü almak.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-176">Those two lines create the tree and retrieve the root node of that tree.</span></span> <span data-ttu-id="6f6cf-177">Artık ağaçtaki düğümleri inceleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-177">You can now examine the nodes in the tree.</span></span> <span data-ttu-id="6f6cf-178">Ağaçtaki kök `Main` düğümünün bazı özelliklerini görüntülemek için yönteminize bu satırları ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-178">Add these lines to your `Main` method to display some of the properties of the root node in the tree:</span></span>

[!code-csharp[Examine the root node](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#3 "Examine the root node")]

<span data-ttu-id="6f6cf-179">Kodunuzun bu ağaçtaki kök düğümü hakkında ne bulduğunu görmek için uygulamayı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-179">Run the application to see what your code has discovered about the root node in this tree.</span></span>

<span data-ttu-id="6f6cf-180">Genellikle, kod hakkında bilgi edinmek için ağaç çapraz istiyorum.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-180">Typically, you'd traverse the tree to learn about the code.</span></span> <span data-ttu-id="6f6cf-181">Bu örnekte, API'leri keşfetmek için bildiğiniz kodu çözümlüyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-181">In this example, you're analyzing code you know to explore the APIs.</span></span> <span data-ttu-id="6f6cf-182">`root` Düğümün ilk üyesini incelemek için aşağıdaki kodu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-182">Add the following code to examine the first member of the `root` node:</span></span>

[!code-csharp[Find the first member](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#4 "Find the first member")]

<span data-ttu-id="6f6cf-183">Bu üye <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>bir .</span><span class="sxs-lookup"><span data-stu-id="6f6cf-183">That member is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6f6cf-184">Beyanname kapsamındaki her şeyi `namespace HelloWorld` temsil eder.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-184">It represents everything in the scope of the `namespace HelloWorld` declaration.</span></span> <span data-ttu-id="6f6cf-185">Ad alanı içinde hangi düğümlerin beyan edildiğine `HelloWorld` inanca göre aşağıdaki kodu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-185">Add the following code to examine what nodes are declared inside the `HelloWorld` namespace:</span></span>

[!code-csharp[Find the class declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#5 "Find the class declaration")]

<span data-ttu-id="6f6cf-186">Öğrendiklerinizi görmek için programı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-186">Run the program to see what you've learned.</span></span>

<span data-ttu-id="6f6cf-187">Artık, sınıf bildirimini <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>incelemek için bu tür yeni bir değişken bildirin.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-187">Now that you know the declaration is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax?displayProperty=nameWithType>, declare a new variable of that type to examine the class declaration.</span></span> <span data-ttu-id="6f6cf-188">Bu sınıf yalnızca bir `Main` üye içerir: yöntem.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-188">This class only contains one member: the `Main` method.</span></span> <span data-ttu-id="6f6cf-189">`Main` Yöntemi bulmak için aşağıdaki kodu ekleyin ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>bir .</span><span class="sxs-lookup"><span data-stu-id="6f6cf-189">Add the following code to find the `Main` method, and cast it to a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax?displayProperty=nameWithType>.</span></span>

[!code-csharp[Find the main declaration](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#6 "Find the main declaration")]

<span data-ttu-id="6f6cf-190">Yöntem bildirimi düğümü, yöntem le ilgili tüm sözdizimsiz bilgileri içerir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-190">The method declaration node contains all the syntactic information about the method.</span></span> <span data-ttu-id="6f6cf-191">Yöntemin `Main` dönüş türünü, bağımsız değişkenlerin sayısını ve türlerini ve yöntemin gövde metnini görüntüleyelim.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-191">Let's display the return type of the `Main` method, the number and types of the arguments, and the body text of the method.</span></span> <span data-ttu-id="6f6cf-192">Aşağıdaki kodu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-192">Add the following code:</span></span>

[!code-csharp[Examine the syntax of the main method](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#7 "Display information about the main method")]

<span data-ttu-id="6f6cf-193">Bu program hakkında keşfettiğiniz tüm bilgileri görmek için programı çalıştırın:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-193">Run the program to see all the information you've discovered about this program:</span></span>

```text
The tree is a CompilationUnit node.
The tree has 1 elements in it.
The tree has 4 using statements. They are:
        System
        System.Collections
        System.Linq
        System.Text
The first member is a NamespaceDeclaration.
There are 1 members declared in this namespace.
The first member is a ClassDeclaration.
There are 1 members declared in the Program class.
The first member is a MethodDeclaration.
The return type of the Main method is void.
The method has 1 parameters.
The type of the args parameter is string[].
The body text of the Main method follows:
        {
            Console.WriteLine("Hello, World!");
        }
```

### <a name="query-methods"></a><span data-ttu-id="6f6cf-194">Sorgu yöntemleri</span><span class="sxs-lookup"><span data-stu-id="6f6cf-194">Query methods</span></span>

<span data-ttu-id="6f6cf-195">Ağaçlarda geçişe ek olarak, sözdizimi ağacında <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>tanımlanan sorgu yöntemlerini kullanarak da keşfedebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-195">In addition to traversing trees, you can also explore the syntax tree using the query methods defined on <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6f6cf-196">Bu yöntemler, XPath'e aşina olan herkes için hemen bilinmelidir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-196">These methods should be immediately familiar to anyone familiar with XPath.</span></span> <span data-ttu-id="6f6cf-197">Bir ağaçtaki şeyleri hızlı bir şekilde bulmak için LINQ ile bu yöntemleri kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-197">You can use these methods with LINQ to quickly find things in a tree.</span></span> <span data-ttu-id="6f6cf-198">Gibi <xref:Microsoft.CodeAnalysis.SyntaxNode> sorgu yöntemleri <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>vardır <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>ve .</span><span class="sxs-lookup"><span data-stu-id="6f6cf-198">The <xref:Microsoft.CodeAnalysis.SyntaxNode> has query methods such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes%2A>.</span></span>

<span data-ttu-id="6f6cf-199">Bu sorgu yöntemlerini, `Main` yönteme bağımsız değişkeni ağaçta gezinmeye alternatif olarak bulmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-199">You can use these query methods to find the argument to the `Main` method as an alternative to navigating the tree.</span></span> <span data-ttu-id="6f6cf-200">Yönteminizin `Main` altına aşağıdaki kodu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-200">Add the following code to the bottom of your `Main` method:</span></span>

[!code-csharp[Query the tree for the arguments to Main](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/HelloSyntaxTree/Program.cs#8 "Query the tree for the arguments to Main")]

<span data-ttu-id="6f6cf-201">İlk deyim, önceki örnekteki <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> yle aynı parametreyi bulmak için bir LINQ ifadesi ve yöntem kullanır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-201">The first statement uses a LINQ expression and the <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A> method to locate the same parameter as in the previous example.</span></span>

<span data-ttu-id="6f6cf-202">Programı çalıştırdığınızda LINQ ifadesinin ağaçta el ile gezinmeyle aynı parametreyi bulduğunu görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-202">Run the program, and you can see that the LINQ expression found the same parameter as manually navigating the tree.</span></span>

<span data-ttu-id="6f6cf-203">Örnek, `WriteLine` sözdizimi ağaçlarının geçişi yle ilgili bilgileri görüntülemek için deyimleri kullanır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-203">The sample uses `WriteLine` statements to display information about the syntax trees as they are traversed.</span></span> <span data-ttu-id="6f6cf-204">Ayrıca hata ayıklama altında bitmiş programı çalıştırarak çok daha fazla bilgi edinebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-204">You can also learn much more by running the finished program under the debugger.</span></span> <span data-ttu-id="6f6cf-205">Merhaba dünya programı için oluşturulan sözdizimi ağacının bir parçası olan özellikleri ve yöntemleri daha inceleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-205">You can examine more of the properties and methods that are part of the syntax tree created for the hello world program.</span></span>

## <a name="syntax-walkers"></a><span data-ttu-id="6f6cf-206">Sözdizimi yürüteçleri</span><span class="sxs-lookup"><span data-stu-id="6f6cf-206">Syntax walkers</span></span>

<span data-ttu-id="6f6cf-207">Genellikle sözdizimi ağacında belirli bir türün tüm düğümlerini (örneğin, bir dosyadaki her özellik bildirimini) bulmak istersiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-207">Often you want to find all nodes of a specific type in a syntax tree, for example, every property declaration in a file.</span></span> <span data-ttu-id="6f6cf-208"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> Sınıfı genişleterek ve <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> yöntemi geçersiz kılarak, her özellik bildirimini bir sözdizimi ağacında yapısını önceden bilmeden işlersiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-208">By extending the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker?displayProperty=nameWithType> class and overriding the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)> method, you process every property declaration in a syntax tree without knowing its structure beforehand.</span></span> <span data-ttu-id="6f6cf-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>özyinelemeli bir <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> düğüm ve her çocuğunu ziyaret eden özel bir türdür.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-209"><xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> is a specific kind of <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor> that recursively visits a node and each of its children.</span></span>

<span data-ttu-id="6f6cf-210">Bu örnek, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> sözdizimi ağacını inceleyen bir uygulama uygular.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-210">This example implements a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines a syntax tree.</span></span> <span data-ttu-id="6f6cf-211">Ad alanı `using` almayan `System` yönergeleri toplar.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-211">It collects `using` directives it finds that aren't importing a `System` namespace.</span></span>

<span data-ttu-id="6f6cf-212">Yeni bir C# **Tek Başına Kod Analizi Aracı** projesi oluşturun; adı "**SyntaxWalker**."</span><span class="sxs-lookup"><span data-stu-id="6f6cf-212">Create a new C# **Stand-Alone Code Analysis Tool** project; name it "**SyntaxWalker**."</span></span>

<span data-ttu-id="6f6cf-213">Bu örneğin bitmiş kodunu [GitHub depomuzda](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart)görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-213">You can see the finished code for this sample in [our GitHub repository](https://github.com/dotnet/samples/tree/master/csharp/roslyn-sdk/SyntaxQuickStart).</span></span> <span data-ttu-id="6f6cf-214">GitHub'daki örnek, bu öğreticide açıklanan her iki projeyi de içerir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-214">The sample on GitHub contains both projects described in this tutorial.</span></span>

<span data-ttu-id="6f6cf-215">Önceki örnekte olduğu gibi, çözümleyeceğiniz programın metnini tutmak için bir dize sabiti tanımlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-215">As in the previous sample, you can define a string constant to hold the text of the program you're going to analyze:</span></span>

[!code-csharp[Define the code text to analyzer](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#1 "Define the program text to analyze")]

<span data-ttu-id="6f6cf-216">Bu kaynak `using` metin dört farklı konuma dağılmış yönergeleri içerir: dosya düzeyi, üst düzey ad alanında ve iç içe geçen iki ad alanında.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-216">This source text contains `using` directives scattered across four different locations: the file-level, in the top-level namespace, and in the two nested namespaces.</span></span> <span data-ttu-id="6f6cf-217">Bu örnek, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> sınıfı sorgu kodu için kullanmak için temel bir senaryoyu vurgular.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-217">This example highlights a core scenario for using the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> class to query code.</span></span> <span data-ttu-id="6f6cf-218">Bildirimleri kullanarak bulmak için kök sözdizimi ağacında her düğümü ziyaret etmek hantal olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-218">It would be cumbersome to visit every node in the root syntax tree to find using declarations.</span></span> <span data-ttu-id="6f6cf-219">Bunun yerine, türetilmiş bir sınıf oluşturur sunuz ve yalnızca ağaçtaki geçerli düğüm bir yönerge olduğunda çağrılan yöntemi geçersiz kılarsınız.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-219">Instead, you create a derived class and override the method that gets called only when the current node in the tree is a using directive.</span></span> <span data-ttu-id="6f6cf-220">Ziyaretçiniz diğer düğüm türleri üzerinde herhangi bir çalışma yapmaz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-220">Your visitor does not do any work on any other node types.</span></span> <span data-ttu-id="6f6cf-221">Bu tek `using` yöntem, ifadelerin her birini inceler ve `System` ad alanında olmayan ad alanlarının bir koleksiyon oluşturur.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-221">This single method examines each of the `using` statements and builds a collection of the namespaces that aren't in the `System` namespace.</span></span> <span data-ttu-id="6f6cf-222">Tüm <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> `using` ifadeleri inceleyen, sadece `using` ifadeleri inceleyen bir yapı oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-222">You build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> that examines all the `using` statements, but only the `using` statements.</span></span>

<span data-ttu-id="6f6cf-223">Artık program metnini tanımladığınıza göre, bir `SyntaxTree` oluşturmanız ve bu ağacın kökünü almanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-223">Now that you've defined the program text, you need to create a `SyntaxTree` and get the root of that tree:</span></span>

[!code-csharp[Create the Syntax tree and access the root](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#2 "Create the Syntax tree and access the root node.")]

<span data-ttu-id="6f6cf-224">Ardından, yeni bir sınıf oluşturun.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-224">Next, create a new class.</span></span> <span data-ttu-id="6f6cf-225">Visual Studio'da **Project** > **Add New Item'i**seçin.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-225">In Visual Studio, choose **Project** > **Add New Item**.</span></span> <span data-ttu-id="6f6cf-226">Yeni **Öğe Ekle** iletişim kutusunda dosya adı olarak *UsingCollector.cs.*</span><span class="sxs-lookup"><span data-stu-id="6f6cf-226">In the **Add New Item** dialog type *UsingCollector.cs* as the filename.</span></span>

<span data-ttu-id="6f6cf-227">`UsingCollector` Sınıfta `using` ziyaretçi işlevselliğini uygularsınız.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-227">You implement the `using` visitor functionality in the `UsingCollector` class.</span></span> <span data-ttu-id="6f6cf-228">`UsingCollector` Sınıfı' ndan <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>türeterek başlayın.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-228">Start by making the `UsingCollector` class derive from <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker>.</span></span>

[!code-csharp[Declare the base class for the using collector](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#3 "Declare the base class for the UsingCollector")]

<span data-ttu-id="6f6cf-229">Topladığınız ad alanı düğümlerini tutmak için depolama alanına ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-229">You need storage to hold the namespace nodes that you're collecting.</span></span>  <span data-ttu-id="6f6cf-230">Sınıfta herkese açık salt okunur `UsingCollector` bir özelliği bildirin; bulduğunuz düğümleri depolamak için bu değişkeni <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> kullanırsınız:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-230">Declare a public read-only property in the `UsingCollector` class; you use this variable to store the <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax> nodes you find:</span></span>

[!code-csharp[Declare storage for the using syntax nodes](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#4 "Declare storage for the using syntax nodes")]

<span data-ttu-id="6f6cf-231">Taban sınıf, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> sözdizimi ağacındaki her düğümü ziyaret etme mantığını uygular.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-231">The base class, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker> implements the logic to visit each node in the syntax tree.</span></span> <span data-ttu-id="6f6cf-232">Türemiş sınıf, ilgilendiğiniz belirli düğümler için çağrılan yöntemleri geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-232">The derived class overrides the methods called for the specific nodes you're interested in.</span></span> <span data-ttu-id="6f6cf-233">Bu durumda, herhangi bir `using` direktifle ilgileniyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-233">In this case, you're interested in any `using` directive.</span></span> <span data-ttu-id="6f6cf-234">Bu, <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> yöntemi geçersiz kılmanız gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-234">That means you must override the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> method.</span></span> <span data-ttu-id="6f6cf-235">Bu yöntemin tek bağımsız <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> değişkeni bir nesnedir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-235">The one argument to this method is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> object.</span></span> <span data-ttu-id="6f6cf-236">Bu ziyaretçileri kullanmak için önemli bir avantajdır: zaten belirli düğüm türüne döküm argümanlar ile geçersiz kılınan yöntemleri arayın.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-236">That's an important advantage to using the visitors: they call the overridden methods with arguments already cast to the specific node type.</span></span> <span data-ttu-id="6f6cf-237">Sınıfın, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> içe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> aktarılan ad alanının adını depolayan bir özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-237">The <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax?displayProperty=nameWithType> class has a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax.Name> property that stores the name of the namespace being imported.</span></span> <span data-ttu-id="6f6cf-238">Bu bir. <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="6f6cf-238">It is a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6f6cf-239">Geçersiz kılmaya <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> aşağıdaki kodu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-239">Add the following code in the <xref:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)> override:</span></span>

[!code-csharp[Examine using nodes for the System namespace](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/UsingCollector.cs#5 "Examine all using nodes for the System namespace.")]

<span data-ttu-id="6f6cf-240">Önceki örnekte olduğu gibi, bu yöntemin `WriteLine` anlaşılmasına yardımcı olmak için çeşitli ifadeler eklediniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-240">As with the earlier example, you've added a variety of `WriteLine` statements to aid in understanding of this method.</span></span> <span data-ttu-id="6f6cf-241">Ne zaman çağrıldığını ve her seferinde hangi bağımsız değişkenlerin aktarılabileceğini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-241">You can see when it's called, and what arguments are passed to it each time.</span></span>

<span data-ttu-id="6f6cf-242">Son olarak, oluşturmak için iki kod `UsingCollector` satırı eklemeniz ve tüm deyimleri `using` toplayarak kök düğümünü ziyaret etmesini zorunda kalmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-242">Finally, you need to add two lines of code to create the `UsingCollector` and have it visit the root node, collecting all the `using` statements.</span></span> <span data-ttu-id="6f6cf-243">Ardından, toplayıcınızın bulduğu `foreach` tüm `using` ifadeleri görüntülemek için bir döngü ekleyin:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-243">Then, add a `foreach` loop to display all the `using` statements your collector found:</span></span>

[!code-csharp[Create the UsingCollector and visit the root node.](../../../../samples/snippets/csharp/roslyn-sdk/SyntaxQuickStart/SyntaxWalker/Program.cs#6 "Create the UsingCollector and visit the root node.")]

<span data-ttu-id="6f6cf-244">Programı derle ve çalıştır.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-244">Compile and run the program.</span></span> <span data-ttu-id="6f6cf-245">Aşağıdaki çıktıyı görmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="6f6cf-245">You should see the following output:</span></span>

```console
        VisitUsingDirective called with System.
        VisitUsingDirective called with System.Collections.Generic.
        VisitUsingDirective called with System.Linq.
        VisitUsingDirective called with System.Text.
        VisitUsingDirective called with Microsoft.CodeAnalysis.
                Success. Adding Microsoft.CodeAnalysis.
        VisitUsingDirective called with Microsoft.CodeAnalysis.CSharp.
                Success. Adding Microsoft.CodeAnalysis.CSharp.
        VisitUsingDirective called with Microsoft.
                Success. Adding Microsoft.
        VisitUsingDirective called with System.ComponentModel.
        VisitUsingDirective called with Microsoft.Win32.
                Success. Adding Microsoft.Win32.
        VisitUsingDirective called with System.Runtime.InteropServices.
        VisitUsingDirective called with System.CodeDom.
        VisitUsingDirective called with Microsoft.CSharp.
                Success. Adding Microsoft.CSharp.
Microsoft.CodeAnalysis
Microsoft.CodeAnalysis.CSharp
Microsoft
Microsoft.Win32
Microsoft.CSharp
Press any key to continue . . .
```

<span data-ttu-id="6f6cf-246">Tebrikler!</span><span class="sxs-lookup"><span data-stu-id="6f6cf-246">Congratulations!</span></span> <span data-ttu-id="6f6cf-247">C# kaynak kodunda belirli c# deyimleri ve bildirimleri bulmak için **Sözdizimi API'sini** kullandınız.</span><span class="sxs-lookup"><span data-stu-id="6f6cf-247">You've used the **Syntax API** to locate specific kinds of C# statements and declarations in C# source code.</span></span>
