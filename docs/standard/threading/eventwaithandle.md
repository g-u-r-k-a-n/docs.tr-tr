---
title: EventWaitHandle
ms.date: 03/30/2017
helpviewer_keywords:
- threading [.NET], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET]
- threading [.NET], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
ms.openlocfilehash: 078bda2354a6f0aec2215b0c5da2a021f53ff922
ms.sourcegitcommit: d8020797a6657d0fbbdff362b80300815f682f94
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/24/2020
ms.locfileid: "95723790"
---
# <a name="eventwaithandle"></a><span data-ttu-id="f1a34-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="f1a34-102">EventWaitHandle</span></span>

<span data-ttu-id="f1a34-103"><xref:System.Threading.EventWaitHandle>Sınıfı, iş parçacıklarının sinyalle ve sinyalleri beklemeden birbirleriyle iletişim kurmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="f1a34-104">Olay bekleme tutamaçları (yalnızca olaylar olarak da bilinir), bir veya daha fazla bekleyen iş parçacığını serbest bırakmak için sinyallenebilir bekleme tanıtıcılardır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="f1a34-105">Sinyalden sonra bir olay bekleme tutamacı el ile veya otomatik olarak sıfırlanır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="f1a34-106"><xref:System.Threading.EventWaitHandle>Sınıfı, yerel bir olay bekleme tanıtıcısını (yerel olay) veya adlandırılmış bir sistem olay bekleme işleyicisini (tüm işlemlere görünür) temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f1a34-107">Olay bekleme tanıtıcıları .NET [olayları](../events/index.md)değildir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-107">Event wait handles are not .NET [events](../events/index.md).</span></span> <span data-ttu-id="f1a34-108">Dahil edilen temsilci veya olay işleyicisi yok.</span><span class="sxs-lookup"><span data-stu-id="f1a34-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="f1a34-109">"Event" sözcüğü, geleneksel olarak işletim sistemi olayları olarak adlandırıldıklarından ve bekleme tanıtıcısını sinyal eden bir olayın gerçekleştiği iş parçacıklarını beklediğini gösterdiği için bunları anlatmak üzere kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="f1a34-110">Hem yerel hem de adlandırılmış olay bekleme tanıtıcıları, <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> kaynakların serbest bırakılacağını sağlamak için sarmalayıcılar tarafından korunan sistem eşitleme nesnelerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="f1a34-111"><xref:System.Threading.WaitHandle.Dispose%2A>Nesnesini kullanmayı bitirdiğinizde kaynakları hemen serbest bırakmak için yöntemini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f1a34-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="f1a34-112">Olay bekleme tarafından otomatik olarak sıfırlanan Işleyiciler</span><span class="sxs-lookup"><span data-stu-id="f1a34-112">Event Wait Handles That Reset Automatically</span></span>  

 <span data-ttu-id="f1a34-113"><xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>Nesneyi ne zaman oluşturduğunuzda belirterek otomatik sıfırlama olayı oluşturursunuz <xref:System.Threading.EventWaitHandle> .</span><span class="sxs-lookup"><span data-stu-id="f1a34-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="f1a34-114">Adından da anlaşılacağı gibi, tek bir bekleyen iş parçacığı serbest bırakıldıktan sonra bu eşitleme olayı, sinyal edildiğinde otomatik olarak sıfırlanır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="f1a34-115">Yöntemini çağırarak olayı sinyal edin <xref:System.Threading.EventWaitHandle.Set%2A> .</span><span class="sxs-lookup"><span data-stu-id="f1a34-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="f1a34-116">Otomatik sıfırlama olayları genellikle tek bir iş parçacığı için bir kaynağa tek seferde özel erişim sağlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="f1a34-117">Bir iş parçacığı, yöntemini çağırarak kaynağı ister <xref:System.Threading.WaitHandle.WaitOne%2A> .</span><span class="sxs-lookup"><span data-stu-id="f1a34-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="f1a34-118">Bekleme tutamacını tutan başka bir iş parçacığı yoksa, yöntemi döndürür `true` ve çağıran iş parçacığı kaynağın denetimini içerir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="f1a34-119">Tüm eşitleme mekanizmalarından itibaren, korunan bir kaynağa erişmeden önce tüm kod yollarının uygun bekleme tanıtıcısından beklediğinden emin olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="f1a34-120">İş parçacığı eşitlemesi birlikte çalışır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="f1a34-121">Hiçbir iş parçacığı beklenirken otomatik sıfırlama olayı sinyallidir, bir iş parçacığı beklemek istediğinde sinyal kalır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="f1a34-122">Olay iş parçacığını yayınlar ve sonraki iş parçacıklarını engellemeyi hemen sıfırlar.</span><span class="sxs-lookup"><span data-stu-id="f1a34-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="f1a34-123">Olay bekleme tarafından el Ile sıfırlanan Işleyiciler</span><span class="sxs-lookup"><span data-stu-id="f1a34-123">Event Wait Handles That Reset Manually</span></span>  

 <span data-ttu-id="f1a34-124"><xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>Nesneyi ne zaman oluşturduğunuzda belirterek el ile sıfırlama olayı oluşturursunuz <xref:System.Threading.EventWaitHandle> .</span><span class="sxs-lookup"><span data-stu-id="f1a34-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="f1a34-125">Adından da anlaşılacağı gibi, bu eşitleme olayının sinyalden sonra el ile sıfırlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="f1a34-126">Sıfırlanana kadar, <xref:System.Threading.EventWaitHandle.Reset%2A> yöntemi çağırarak olay tanıtıcısını bekleyen iş parçacıkları doğrudan engellenmeden devam edilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="f1a34-127">El ile sıfırlama olayı bir Corral kapısı gibi davranır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="f1a34-128">Olay sinyalsiz olmadığında, Corral gibi, BT bloğunda bekleyen iş parçacıkları.</span><span class="sxs-lookup"><span data-stu-id="f1a34-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="f1a34-129">Olaya işaret edildiğinde, yöntemini çağırarak, <xref:System.Threading.EventWaitHandle.Set%2A> bekleyen tüm iş parçacıkları devam etmek ücretsizdir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="f1a34-130">Olayı, <xref:System.Threading.EventWaitHandle.Reset%2A> yöntemi çağrılana kadar sinyal olarak kalır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="f1a34-131">Bu, el ile sıfırlama olayını, bir iş parçacığının bir görevi bitirene kadar beklemesi gereken iş parçacıklarını tutmak için ideal bir yol haline getirir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="f1a34-132">Corral atmaya benzer şekilde, yayınlanan iş parçacıklarının işletim sistemi tarafından zamanlanması ve yürütmeyi sürdürmek için zaman alır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="f1a34-133">Yöntemi, <xref:System.Threading.EventWaitHandle.Reset%2A> tüm iş parçacıklarının yürütmeyi sürdürmesinden önce çağrılırsa, kalan iş parçacıkları yeniden engellenir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="f1a34-134">Hangi iş parçacıkları sürdürecek ve hangi iş parçacıklarının engellenmesi, sistemdeki yük, Scheduler için bekleyen iş parçacıklarının sayısı vb. gibi rastgele faktörlere bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="f1a34-135">Bu, olayı işaret eden iş parçacığı, en yaygın kullanım deseninin olduğu sinyalden sonra sona erdiğinde bu bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="f1a34-136">Tüm bekleyen iş parçacıkları devam ettirdikten sonra olayı işaret eden bir iş parçacığının yeni bir göreve başlamasını istiyorsanız, tüm bekleyen iş parçacıkları sürdürülene kadar bunu engellemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="f1a34-137">Aksi takdirde, bir yarış koşulunuz vardır ve kodunuzun davranışı tahmin edilemez.</span><span class="sxs-lookup"><span data-stu-id="f1a34-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="f1a34-138">Otomatik ve El Ile olaylar için ortak özellikler</span><span class="sxs-lookup"><span data-stu-id="f1a34-138">Features Common to Automatic and Manual Events</span></span>  

 <span data-ttu-id="f1a34-139">Genellikle, engellenmemiş bir iş parçacığından birini çağıran bir veya daha fazla iş parçacığı, <xref:System.Threading.EventWaitHandle> <xref:System.Threading.EventWaitHandle.Set%2A> bekleyen iş parçacıklarından birini (otomatik sıfırlama olayları durumunda) veya tümünü (el ile sıfırlama olayları durumunda) yayınlar.</span><span class="sxs-lookup"><span data-stu-id="f1a34-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="f1a34-140">Bir iş parçacığı bir üzerinde sinyal verebilir <xref:System.Threading.EventWaitHandle> ve sonra statik yöntemi çağırarak atomik bir işlem olarak bunu engelleyebilir <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="f1a34-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="f1a34-141"><xref:System.Threading.EventWaitHandle> nesneler statik <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> ve <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> yöntemlerle kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="f1a34-142"><xref:System.Threading.EventWaitHandle>Ve <xref:System.Threading.Mutex> sınıflarının her ikisi de öğesinden türetilmediği için <xref:System.Threading.WaitHandle> , her iki sınıfı da bu yöntemlerle kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f1a34-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="f1a34-143">Adlandırılmış olaylar</span><span class="sxs-lookup"><span data-stu-id="f1a34-143">Named Events</span></span>  

 <span data-ttu-id="f1a34-144">Windows işletim sistemi, olay bekleme tanıtıcılarının adlara sahip olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="f1a34-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="f1a34-145">Adlandırılmış bir olay sistem genelinde olur.</span><span class="sxs-lookup"><span data-stu-id="f1a34-145">A named event is system wide.</span></span> <span data-ttu-id="f1a34-146">Diğer bir deyişle, adlandırılmış olay oluşturulduktan sonra tüm süreçlerdeki tüm iş parçacıkları tarafından görülebilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="f1a34-147">Bu nedenle, adlandırılmış olaylar işlem etkinliklerini ve iş parçacıklarını eşitlemesi için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="f1a34-148"><xref:System.Threading.EventWaitHandle>Bir olay adı belirten oluşturuculardan birini kullanarak, adlandırılmış bir sistem olayını temsil eden bir nesne oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f1a34-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f1a34-149">Adlandırılmış olaylar sistem genelinde olduğundan, <xref:System.Threading.EventWaitHandle> aynı adlandırılmış olayı temsil eden birden çok nesne olması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f1a34-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="f1a34-150">Her bir oluşturucuyu veya yöntemini her çağırdığınızda <xref:System.Threading.EventWaitHandle.OpenExisting%2A> Yeni bir <xref:System.Threading.EventWaitHandle> nesne oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f1a34-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="f1a34-151">Aynı adın belirtilmesi, aynı adlandırılmış olayı temsil eden birden çok nesne oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f1a34-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="f1a34-152">Uyarı, adlandırılmış olayları kullanmanın kullanılması önerilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-152">Caution is advised in using named events.</span></span> <span data-ttu-id="f1a34-153">Sistem genelinde olduklarından aynı adı kullanan başka bir işlem, iş parçacıklarını beklenmedik şekilde engelleyebilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="f1a34-154">Aynı bilgisayarda çalışan kötü amaçlı kod bunu bir hizmet reddi saldırısı temeli olarak kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="f1a34-155"><xref:System.Threading.EventWaitHandle>Adlandırılmış bir olayı temsil eden bir nesneyi, tercihen bir nesneyi belirten bir oluşturucuyu kullanarak korumak için erişim denetimi güvenliği ' ni kullanın <xref:System.Security.AccessControl.EventWaitHandleSecurity> .</span><span class="sxs-lookup"><span data-stu-id="f1a34-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="f1a34-156">Yöntemi kullanarak erişim denetimi güvenliği de uygulayabilirsiniz <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> , ancak bu, olay bekleme tutamacının oluşturulduğu zaman ve koruduğu zaman arasında bir güvenlik açığı penceresi bırakır.</span><span class="sxs-lookup"><span data-stu-id="f1a34-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="f1a34-157">Erişim denetimi güvenliği ile olayları koruma kötü amaçlı saldırıları önlemeye yardımcı olur, ancak istemeden ad çakışmalarının sorununu çözmez.</span><span class="sxs-lookup"><span data-stu-id="f1a34-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f1a34-158">Sınıfından farklı olarak <xref:System.Threading.EventWaitHandle> türetilmiş sınıflar <xref:System.Threading.AutoResetEvent> ve <xref:System.Threading.ManualResetEvent> yalnızca yerel bekleme tutamaçlarını temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="f1a34-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="f1a34-159">Adlandırılmış sistem olaylarını temsil edemez.</span><span class="sxs-lookup"><span data-stu-id="f1a34-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f1a34-160">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="f1a34-160">See also</span></span>

- <xref:System.Threading.EventWaitHandle>
- <xref:System.Threading.WaitHandle>
- <xref:System.Threading.AutoResetEvent>
- <xref:System.Threading.ManualResetEvent>
