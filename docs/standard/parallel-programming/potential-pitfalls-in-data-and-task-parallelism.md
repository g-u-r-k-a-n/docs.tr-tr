---
title: Veri ve Görev Paralelliğinde Olası Tuzaklar
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- parallel programming, pitfalls
ms.assetid: 1e357177-e699-4b8f-9e49-56d3513ed128
ms.openlocfilehash: ff6ac9e8c41ee203ae72e1b28c088f462ddf6a54
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "73140024"
---
# <a name="potential-pitfalls-in-data-and-task-parallelism"></a><span data-ttu-id="5e23e-102">Veri ve Görev Paralelliğinde Olası Tuzaklar</span><span class="sxs-lookup"><span data-stu-id="5e23e-102">Potential Pitfalls in Data and Task Parallelism</span></span>
<span data-ttu-id="5e23e-103">Birçok durumda <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> ve <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> sıradan sıralı döngüler üzerinde önemli performans iyileştirmeleri sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-103">In many cases, <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> can provide significant performance improvements over ordinary sequential loops.</span></span> <span data-ttu-id="5e23e-104">Ancak, döngüparalelleştirme çalışması, sıralı kodolarak, yaygın olmayan veya hiç karşılaşılan sorunlara yol açabilecek karmaşıklık tanıtır.</span><span class="sxs-lookup"><span data-stu-id="5e23e-104">However, the work of parallelizing the loop introduces complexity that can lead to problems that, in sequential code, are not as common or are not encountered at all.</span></span> <span data-ttu-id="5e23e-105">Bu konu, paralel döngüler yazarken kaçınılması gereken bazı uygulamaları listeler.</span><span class="sxs-lookup"><span data-stu-id="5e23e-105">This topic lists some practices to avoid when you write parallel loops.</span></span>  
  
## <a name="do-not-assume-that-parallel-is-always-faster"></a><span data-ttu-id="5e23e-106">Paralelin her zaman daha hızlı olduğunu düşünmeyin</span><span class="sxs-lookup"><span data-stu-id="5e23e-106">Do Not Assume That Parallel Is Always Faster</span></span>  
 <span data-ttu-id="5e23e-107">Bazı durumlarda paralel döngü, sıralı eşdeğerinden daha yavaş çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-107">In certain cases a parallel loop might run slower than its sequential equivalent.</span></span> <span data-ttu-id="5e23e-108">Başparmak temel kuralı, birkaç yineleme ve hızlı kullanıcı temsilcileri olan paralel döngüler çok hızlandırmak olası değildir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-108">The basic rule of thumb is that parallel loops that have few iterations and fast user delegates are unlikely to speedup much.</span></span> <span data-ttu-id="5e23e-109">Ancak, performansta birçok etken söz konusu olduğundan, gerçek sonuçları her zaman ölçmenizi öneririz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-109">However, because many factors are involved in performance, we recommend that you always measure actual results.</span></span>  
  
## <a name="avoid-writing-to-shared-memory-locations"></a><span data-ttu-id="5e23e-110">Paylaşılan Bellek Konumlarına Yazmaktan Kaçının</span><span class="sxs-lookup"><span data-stu-id="5e23e-110">Avoid Writing to Shared Memory Locations</span></span>  
 <span data-ttu-id="5e23e-111">Sıralı kodda, statik değişkenlerden veya sınıf alanlarına okumak veya yazmak nadir değildir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-111">In sequential code, it is not uncommon to read from or write to static variables or class fields.</span></span> <span data-ttu-id="5e23e-112">Ancak, birden çok iş parçacığı aynı anda bu tür değişkenlere erişiyorsa, yarış koşulları için büyük bir potansiyel vardır.</span><span class="sxs-lookup"><span data-stu-id="5e23e-112">However, whenever multiple threads are accessing such variables concurrently, there is a big potential for race conditions.</span></span> <span data-ttu-id="5e23e-113">Değişkene erişimi eşitlemek için kilitleri kullanabiliyor olsanız da, eşitleme maliyeti performansa zarar verebilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-113">Even though you can use locks to synchronize access to the variable, the cost of synchronization can hurt performance.</span></span> <span data-ttu-id="5e23e-114">Bu nedenle, paylaşılan duruma mümkün olduğunca paralel bir döngü içinde erişimi önlemenizi veya en azından sınırlamanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-114">Therefore, we recommend that you avoid, or at least limit, access to shared state in a parallel loop as much as possible.</span></span> <span data-ttu-id="5e23e-115">Bunu yapmanın en iyi yolu, döngü <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> yürütme <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> sırasında <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> iş parçacığı yerel durumu depolamak için aşırı yükleri kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="5e23e-115">The best way to do this is to use the overloads of <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> that use a <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> variable to store thread-local state during loop execution.</span></span> <span data-ttu-id="5e23e-116">Daha fazla bilgi için [bkz: Thread-Local Variables ile Parallel.For Loop yazın](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) ve [Nasıl: Partition-Local Variables ile Parallel.ForEach Loop yazın.](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md)</span><span class="sxs-lookup"><span data-stu-id="5e23e-116">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../../docs/standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="avoid-over-parallelization"></a><span data-ttu-id="5e23e-117">Aşırı Paralelleştirmeden Kaçının</span><span class="sxs-lookup"><span data-stu-id="5e23e-117">Avoid Over-Parallelization</span></span>  
 <span data-ttu-id="5e23e-118">Paralel döngüler kullanarak, kaynak koleksiyonunu bölümleme ve alt iş parçacıklarını eşitleme nin genel gider maliyetlerine maruz kalırsınız.</span><span class="sxs-lookup"><span data-stu-id="5e23e-118">By using parallel loops, you incur the overhead costs of partitioning the source collection and synchronizing the worker threads.</span></span> <span data-ttu-id="5e23e-119">Paralelleştirmenin yararları bilgisayardaki işlemci sayısıyla daha da sınırlıdır.</span><span class="sxs-lookup"><span data-stu-id="5e23e-119">The benefits of parallelization are further limited by the number of processors on the computer.</span></span> <span data-ttu-id="5e23e-120">Tek bir işlemcide birden çok işlemle bağlı iş parçacığı çalıştırılarak hız kazanılacak bir hız yoktur.</span><span class="sxs-lookup"><span data-stu-id="5e23e-120">There is no speedup to be gained by running multiple compute-bound threads on just one processor.</span></span> <span data-ttu-id="5e23e-121">Bu nedenle, bir döngüyü aşırı paralelleştirmemeye dikkat etmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-121">Therefore, you must be careful not to over-parallelize a loop.</span></span>  
  
 <span data-ttu-id="5e23e-122">Aşırı paralelleştirmeoluşabilir en yaygın senaryo iç içe döngüler içinde.</span><span class="sxs-lookup"><span data-stu-id="5e23e-122">The most common scenario in which over-parallelization can occur is in nested loops.</span></span> <span data-ttu-id="5e23e-123">Çoğu durumda, aşağıdaki koşullardan biri veya daha fazlası geçerli olmadıkça yalnızca dış döngüyü paralelleştirmek en iyisidir:</span><span class="sxs-lookup"><span data-stu-id="5e23e-123">In most cases, it is best to parallelize only the outer loop unless one or more of the following conditions apply:</span></span>  
  
- <span data-ttu-id="5e23e-124">İç döngü çok uzun olduğu bilinmektedir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-124">The inner loop is known to be very long.</span></span>  
  
- <span data-ttu-id="5e23e-125">Her siparişte pahalı bir hesaplama gerçekleştiresiniz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-125">You are performing an expensive computation on each order.</span></span> <span data-ttu-id="5e23e-126">(Örnekte gösterilen işlem pahalı değildir.)</span><span class="sxs-lookup"><span data-stu-id="5e23e-126">(The operation shown in the example is not expensive.)</span></span>  
  
- <span data-ttu-id="5e23e-127">Hedef sistemde sorguyu paralelleştirerek üretilecek iş parçacığı sayısını işlemek için yeterli işlemciye sahip olduğu `cust.Orders`bilinmektedir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-127">The target system is known to have enough processors to handle the number of threads that will be produced by parallelizing the query on `cust.Orders`.</span></span>  
  
 <span data-ttu-id="5e23e-128">Her durumda, en iyi sorgu şeklini belirlemenin en iyi yolu sınamak ve ölçmektir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-128">In all cases, the best way to determine the optimum query shape is to test and measure.</span></span>  
  
## <a name="avoid-calls-to-non-thread-safe-methods"></a><span data-ttu-id="5e23e-129">İş Parçacığı Güvenli Olmayan Yöntemlere Yapılan Çağrılardan Kaçının</span><span class="sxs-lookup"><span data-stu-id="5e23e-129">Avoid Calls to Non-Thread-Safe Methods</span></span>  
 <span data-ttu-id="5e23e-130">Paralel bir döngüden iş parçacığı güvenli olmayan örnek yöntemlerine yazma, programınızda algılanmayan veya görünmeyen veri bozulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-130">Writing to non-thread-safe instance methods from a parallel loop can lead to data corruption which may or may not go undetected in your program.</span></span> <span data-ttu-id="5e23e-131">Ayrıca özel durumlara yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-131">It can also lead to exceptions.</span></span> <span data-ttu-id="5e23e-132">Aşağıdaki örnekte, birden çok iş parçacığı aynı <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType> anda, hangi sınıf tarafından desteklenmeyen yöntemi çağırmak için çalışıyor olacaktır.</span><span class="sxs-lookup"><span data-stu-id="5e23e-132">In the following example, multiple threads would be attempting to call the <xref:System.IO.FileStream.WriteByte%2A?displayProperty=nameWithType> method simultaneously, which is not supported by the class.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#04](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#04)]
 [!code-vb[TPL_Pitfalls#04](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#04)]  
  
## <a name="limit-calls-to-thread-safe-methods"></a><span data-ttu-id="5e23e-133">Aramaları İş Parçacığı Güvenli Yöntemlerle Sınırlandırın</span><span class="sxs-lookup"><span data-stu-id="5e23e-133">Limit Calls to Thread-Safe Methods</span></span>  
 <span data-ttu-id="5e23e-134">.NET Framework'deki statik yöntemlerin çoğu iş parçacığı açısından güvenlidir ve aynı anda birden çok iş parçacığından çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-134">Most static methods in the .NET Framework are thread-safe and can be called from multiple threads concurrently.</span></span> <span data-ttu-id="5e23e-135">Ancak, bu gibi durumlarda bile, söz konusu eşitleme sorguda önemli yavaşlamaya neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-135">However, even in these cases, the synchronization involved can lead to significant slowdown in the query.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5e23e-136">Sorgularınıza bazı aramalar <xref:System.Console.WriteLine%2A> ekleyerek bunu kendiniz test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-136">You can test for this yourself by inserting some calls to <xref:System.Console.WriteLine%2A> in your queries.</span></span> <span data-ttu-id="5e23e-137">Bu yöntem belge örneklerinde gösterim amacıyla kullanılsa da, gerekmedikçe paralel döngülerde kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="5e23e-137">Although this method is used in the documentation examples for demonstration purposes, do not use it in parallel loops unless necessary.</span></span>  
  
## <a name="be-aware-of-thread-affinity-issues"></a><span data-ttu-id="5e23e-138">Konu Afiyeti Sorunlarının Farkında Olun</span><span class="sxs-lookup"><span data-stu-id="5e23e-138">Be Aware of Thread Affinity Issues</span></span>  
 <span data-ttu-id="5e23e-139">Bazı teknolojiler, örneğin, Tek İş Parçacığı Daire (STA) bileşenleri, Windows Formları ve Windows Presentation Foundation (WPF) için COM birlikte çalışabilirliği, belirli bir iş parçacığı üzerinde çalıştırmak için kod gerektiren iş parçacığı afinite kısıtlamaları uygular.</span><span class="sxs-lookup"><span data-stu-id="5e23e-139">Some technologies, for example, COM interoperability for Single-Threaded Apartment (STA) components, Windows Forms, and Windows Presentation Foundation (WPF), impose thread affinity restrictions that require code to run on a specific thread.</span></span> <span data-ttu-id="5e23e-140">Örneğin, hem Windows Formlarında hem de WPF'de, denetime yalnızca oluşturulduğu iş parçacığında erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-140">For example, in both Windows Forms and WPF, a control can only be accessed on the thread on which it was created.</span></span> <span data-ttu-id="5e23e-141">Bu, örneğin, iş parçacığı zamanlayıcısını yalnızca Kullanıcı Arabirimi iş parçacığı üzerinde çalışacak şekilde yapılandırmadığınız sürece, bir liste denetimini paralel döngüden güncelleştiremeyeceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-141">This means, for example, that you cannot update a list control from a parallel loop unless you configure the thread scheduler to schedule work only on the UI thread.</span></span> <span data-ttu-id="5e23e-142">Daha fazla bilgi için [bkz.](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context)</span><span class="sxs-lookup"><span data-stu-id="5e23e-142">For more information, see [Specifying a synchronization context](xref:System.Threading.Tasks.TaskScheduler#specifying-a-synchronization-context).</span></span>  
  
## <a name="use-caution-when-waiting-in-delegates-that-are-called-by-parallelinvoke"></a><span data-ttu-id="5e23e-143">Paralel Olarak Çağrılan Temsilcilerde Beklerken Dikkatli Olun.Çağrıl</span><span class="sxs-lookup"><span data-stu-id="5e23e-143">Use Caution When Waiting in Delegates That Are Called by Parallel.Invoke</span></span>  
 <span data-ttu-id="5e23e-144">Belirli durumlarda, Görev Paralel Kitaplığı bir görev satır, hangi şu anda yürütülen iş parçacığı üzerinde görevde çalışır anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-144">In certain circumstances, the Task Parallel Library will inline a task, which means it runs on the task on the currently executing thread.</span></span> <span data-ttu-id="5e23e-145">(Daha fazla bilgi için [Görev Zamanlayıcıları'na](xref:System.Threading.Tasks.TaskScheduler)bakın.) Bu performans optimizasyonu bazı durumlarda kilitlenmelere neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-145">(For more information, see [Task Schedulers](xref:System.Threading.Tasks.TaskScheduler).) This performance optimization can lead to deadlock in certain cases.</span></span> <span data-ttu-id="5e23e-146">Örneğin, iki görev, bir olay oluştuğunda sinyal veren ve sonra diğer görevin sinyal gelmesini bekleyen aynı temsilci kodunu çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-146">For example, two tasks might run the same delegate code, which signals when an event occurs, and then waits for the other task to signal.</span></span> <span data-ttu-id="5e23e-147">İkinci görev ilki yle aynı iş parçacığıüzerinde sıralanmışsa ve ilki Bekle durumuna geçerse, ikinci görev hiçbir zaman olay sinyalini veremeyecektir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-147">If the second task is inlined on the same thread as the first, and the first goes into a Wait state, the second task will never be able to signal its event.</span></span> <span data-ttu-id="5e23e-148">Böyle bir oluşumu önlemek için, Bekleme işlemi nde bir zaman sonu belirtebilir veya bir görevin diğerini engelleyememesini sağlamaya yardımcı olmak için açık iş parçacığı oluşturucuları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-148">To avoid such an occurrence, you can specify a timeout on the Wait operation, or use explicit thread constructors to help ensure that one task cannot block the other.</span></span>  
  
## <a name="do-not-assume-that-iterations-of-foreach-for-and-forall-always-execute-in-parallel"></a><span data-ttu-id="5e23e-149">ForEach, For ve ForAll Yinelemelerinin Her Zaman Paralel Yürütüldettiğini Düşünmeyin</span><span class="sxs-lookup"><span data-stu-id="5e23e-149">Do Not Assume that Iterations of ForEach, For and ForAll Always Execute in Parallel</span></span>  
 <span data-ttu-id="5e23e-150">Bir <xref:System.Threading.Tasks.Parallel.For%2A>döngüdeki <xref:System.Threading.Tasks.Parallel.ForEach%2A> <xref:System.Linq.ParallelEnumerable.ForAll%2A> tek tek yinelemelerin, ancak paralel olarak yürütülmesi gerekmediğini göz önünde bulundurmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-150">It is important to keep in mind that individual iterations in a <xref:System.Threading.Tasks.Parallel.For%2A>, <xref:System.Threading.Tasks.Parallel.ForEach%2A> or <xref:System.Linq.ParallelEnumerable.ForAll%2A> loop may but do not have to execute in parallel.</span></span> <span data-ttu-id="5e23e-151">Bu nedenle, yinelemelerin paralel yürütülmesi veya belirli bir sırada yinelemelerin yürütülmesi doğruluğa bağlı herhangi bir kod yazmaktan kaçınmalısınız.</span><span class="sxs-lookup"><span data-stu-id="5e23e-151">Therefore, you should avoid writing any code that depends for correctness on parallel execution of iterations or on the execution of iterations in any particular order.</span></span> <span data-ttu-id="5e23e-152">Örneğin, bu kodun kilitlenme olasılığı yüksektir:</span><span class="sxs-lookup"><span data-stu-id="5e23e-152">For example, this code is likely to deadlock:</span></span>  
  
 [!code-csharp[TPL_Pitfalls#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#01)]
 [!code-vb[TPL_Pitfalls#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#01)]  
  
 <span data-ttu-id="5e23e-153">Bu örnekte, bir yineleme bir olay ayarlar ve diğer tüm yinelemeler olay üzerinde bekleyin.</span><span class="sxs-lookup"><span data-stu-id="5e23e-153">In this example, one iteration sets an event, and all other iterations wait on the event.</span></span> <span data-ttu-id="5e23e-154">Olay ayar yinelemesi tamamlanana kadar bekleyen yinelemelerin hiçbiri tamamlanamaz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-154">None of the waiting iterations can complete until the event-setting iteration has completed.</span></span> <span data-ttu-id="5e23e-155">Ancak, olay ayar yinelemesi yürütme şansı olmadan önce, bekleyen yinelemeler paralel döngü yürütmek için kullanılan tüm iş parçacığı engellemek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="5e23e-155">However, it is possible that the waiting iterations block all threads that are used to execute the parallel loop, before the event-setting iteration has had a chance to execute.</span></span> <span data-ttu-id="5e23e-156">Bu bir kilitlenme yle sonuçlanır – olay ayar yinelemesi asla yürütülmeyecek ve bekleyen yinelemeler asla uyanmayacak.</span><span class="sxs-lookup"><span data-stu-id="5e23e-156">This results in a deadlock – the event-setting iteration will never execute, and the waiting iterations will never wake up.</span></span>  
  
 <span data-ttu-id="5e23e-157">Özellikle, paralel bir döngü bir yineleme ilerleme yapmak için döngü başka bir yineleme beklemek asla.</span><span class="sxs-lookup"><span data-stu-id="5e23e-157">In particular, one iteration of a parallel loop should never wait on another iteration of the loop to make progress.</span></span> <span data-ttu-id="5e23e-158">Paralel döngü yinelemeleri sırayla ancak ters sırada zamanlamaya karar verirse, bir kilitlenme oluşur.</span><span class="sxs-lookup"><span data-stu-id="5e23e-158">If the parallel loop decides to schedule the iterations sequentially but in the opposite order, a deadlock will occur.</span></span>  
  
## <a name="avoid-executing-parallel-loops-on-the-ui-thread"></a><span data-ttu-id="5e23e-159">UI İş parçacığı üzerinde Paralel Döngüler Yürütme kaçının</span><span class="sxs-lookup"><span data-stu-id="5e23e-159">Avoid Executing Parallel Loops on the UI Thread</span></span>  
 <span data-ttu-id="5e23e-160">Uygulamanızın kullanıcı arabirimini (UI) duyarlı tutmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-160">It is important to keep your application's user interface (UI) responsive.</span></span> <span data-ttu-id="5e23e-161">Bir işlem paralelleştirmeyi gerektirecek kadar çalışma içeriyorsa, büyük olasılıkla bu işlemi UI iş parçacığı üzerinde çalıştırılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="5e23e-161">If an operation contains enough work to warrant parallelization, then it likely should not be run that operation on the UI thread.</span></span>  <span data-ttu-id="5e23e-162">Bunun yerine, bir arka plan iş parçacığı üzerinde çalıştırılmak üzere bu işlemi boşaltmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-162">Instead, it should offload that operation to be run on a background thread.</span></span> <span data-ttu-id="5e23e-163">Örneğin, daha sonra bir UI denetimine işlenmesi gereken bazı verileri hesaplamak için paralel bir döngü kullanmak istiyorsanız, doğrudan bir UI olay işleyicisi yerine bir görev örneği içinde döngü yürütme yi düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-163">For example, if you want to use a parallel loop to compute some data that should then be rendered into a UI control, you should consider executing the loop within a task instance rather than directly in a UI event handler.</span></span>  <span data-ttu-id="5e23e-164">Yalnızca çekirdek hesaplama tamamlandığında, kullanıcı arası bilgi alan güncelleştirmeyi kullanıcı arası birimi iş parçacığına geri döndürmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-164">Only when the core computation has completed should you then marshal the UI update back to the UI thread.</span></span>  
  
 <span data-ttu-id="5e23e-165">UI iş parçacığı üzerinde paralel döngüler çalıştırırsanız, döngü içinden UI denetimleri güncelleştirmeyi önlemek için dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="5e23e-165">If you do run parallel loops on the UI thread, be careful to avoid updating UI controls from within the loop.</span></span> <span data-ttu-id="5e23e-166">Kullanıcı Arabirimi iş parçacığı üzerinde çalışan paralel bir döngü içinde UI denetimleri güncelleştirmeye çalışırken, Kullanıcı Arabirimi güncelleştirmesinin nasıl çağrıldığine bağlı olarak durum bozulmasına, özel durumlara, gecikmeli güncelleştirmelere ve hatta kilitlenmelere neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-166">Attempting to update UI controls from within a parallel loop that is executing on the UI thread can lead to state corruption, exceptions, delayed updates, and even deadlocks, depending on how the UI update is invoked.</span></span> <span data-ttu-id="5e23e-167">Aşağıdaki örnekte, paralel döngü tüm yinelemeler tamamlanana kadar yürütüldettiği UI iş parçacığı engeller.</span><span class="sxs-lookup"><span data-stu-id="5e23e-167">In the following example, the parallel loop blocks the UI thread on which it’s executing until all iterations are complete.</span></span> <span data-ttu-id="5e23e-168">Ancak, döngü bir yineleme bir arka plan iş parçacığı <xref:System.Threading.Tasks.Parallel.For%2A> üzerinde çalışıyorsa (olabilir gibi), Çağrı çağrısı kullanıcı arabirimi iş parçacığına gönderilmesine neden olur ve bu iletinin işlenmesini bekleyen engeller.</span><span class="sxs-lookup"><span data-stu-id="5e23e-168">However, if an iteration of the loop is running on a background thread (as <xref:System.Threading.Tasks.Parallel.For%2A> may do), the call to Invoke causes a message to be submitted to the UI thread and blocks waiting for that message to be processed.</span></span> <span data-ttu-id="5e23e-169">UI iş parçacığı çalışırken engellenir <xref:System.Threading.Tasks.Parallel.For%2A>yana, ileti asla işlenebilir ve UI iş parçacığı kilitlenir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-169">Since the UI thread is blocked running the <xref:System.Threading.Tasks.Parallel.For%2A>, the message can never be processed, and the UI thread deadlocks.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#02)]
 [!code-vb[TPL_Pitfalls#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#02)]  
  
 <span data-ttu-id="5e23e-170">Aşağıdaki örnek, döngüyü bir görev örneğinin içinde çalıştırarak kilitlenmeyi nasıl önleyileceğimi gösterir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-170">The following example shows how to avoid the deadlock, by running the loop inside a task instance.</span></span> <span data-ttu-id="5e23e-171">UI iş parçacığı döngü tarafından engellenmez ve ileti işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="5e23e-171">The UI thread is not blocked by the loop, and the message can be processed.</span></span>  
  
 [!code-csharp[TPL_Pitfalls#03](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_pitfalls/cs/pitfalls.cs#03)]
 [!code-vb[TPL_Pitfalls#03](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_pitfalls/vb/pitfalls_vb.vb#03)]  
  
## <a name="see-also"></a><span data-ttu-id="5e23e-172">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="5e23e-172">See also</span></span>

- [<span data-ttu-id="5e23e-173">Paralel Programlama</span><span class="sxs-lookup"><span data-stu-id="5e23e-173">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
- [<span data-ttu-id="5e23e-174">PLINQ'te Olası Tuzaklar</span><span class="sxs-lookup"><span data-stu-id="5e23e-174">Potential Pitfalls with PLINQ</span></span>](../../../docs/standard/parallel-programming/potential-pitfalls-with-plinq.md)
- [<span data-ttu-id="5e23e-175">Paralel Programlama Kalıpları: .NET Framework 4 ile Paralel Desenlerin Anlaşılması ve Uygulanması</span><span class="sxs-lookup"><span data-stu-id="5e23e-175">Patterns for Parallel Programming: Understanding and Applying Parallel Patterns with the .NET Framework 4</span></span>](https://www.microsoft.com/download/details.aspx?id=19222)
