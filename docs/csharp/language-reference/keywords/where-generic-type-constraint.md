---
description: WHERE (genel tür kısıtlaması)-C# başvurusu
title: WHERE (genel tür kısıtlaması)-C# başvurusu
ms.date: 04/15/2020
f1_keywords:
- whereconstraint
- whereconstraint_CSharpKeyword
helpviewer_keywords:
- where (generic type constraint) [C#]
ms.openlocfilehash: 78f784135c6bf01ea9724fcf92be234e6b86ff07
ms.sourcegitcommit: d579fb5e4b46745fd0f1f8874c94c6469ce58604
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 08/30/2020
ms.locfileid: "89141913"
---
# <a name="where-generic-type-constraint-c-reference"></a><span data-ttu-id="88cde-103">where (genel tür kısıtlaması) (C# Başvurusu)</span><span class="sxs-lookup"><span data-stu-id="88cde-103">where (generic type constraint) (C# Reference)</span></span>

<span data-ttu-id="88cde-104">`where`Genel tanımda yer alan yan tümce, genel bir tür, metot, temsilci veya yerel işlevde tür parametreleri için bağımsız değişken olarak kullanılan türlerde kısıtlamalar belirtir.</span><span class="sxs-lookup"><span data-stu-id="88cde-104">The `where` clause in a generic definition specifies constraints on the types that are used as arguments for type parameters in a generic type, method, delegate, or local function.</span></span> <span data-ttu-id="88cde-105">Kısıtlamalar, arabirimler, temel sınıflar veya bir genel türün bir başvuru, değer veya yönetilmeyen tür olmasını gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="88cde-105">Constraints can specify interfaces, base classes, or require a generic type to be a reference, value, or unmanaged type.</span></span> <span data-ttu-id="88cde-106">Tür bağımsız değişkeninin sahip olması gereken özellikleri bildirir.</span><span class="sxs-lookup"><span data-stu-id="88cde-106">They declare capabilities that the type argument must have.</span></span>

<span data-ttu-id="88cde-107">Örneğin, `MyGenericClass` tür parametresi arabirimini uygulayan genel bir sınıf bildirebilirsiniz `T` <xref:System.IComparable%601> :</span><span class="sxs-lookup"><span data-stu-id="88cde-107">For example, you can declare a generic class, `MyGenericClass`, such that the type parameter `T` implements the <xref:System.IComparable%601> interface:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#1)]

> [!NOTE]
> <span data-ttu-id="88cde-108">Bir sorgu ifadesindeki WHERE yan tümcesi hakkında daha fazla bilgi için bkz. [WHERE yan tümcesi](where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="88cde-108">For more information on the where clause in a query expression, see [where clause](where-clause.md).</span></span>

<span data-ttu-id="88cde-109">`where`Yan tümce bir temel sınıf kısıtlaması de içerebilir.</span><span class="sxs-lookup"><span data-stu-id="88cde-109">The `where` clause can also include a base class constraint.</span></span> <span data-ttu-id="88cde-110">Temel sınıf kısıtlaması, bu genel türün tür bağımsız değişkeni olarak kullanılacak bir türün, temel sınıf olarak belirtilen sınıfa sahip olduğunu veya temel sınıf olduğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="88cde-110">The base class constraint states that a type to be used as a type argument for that generic type has the specified class as a base class, or is that base class.</span></span> <span data-ttu-id="88cde-111">Temel sınıf kısıtlaması kullanılırsa, bu tür parametresindeki diğer kısıtlamaların önüne gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="88cde-111">If the base class constraint is used, it must appear before any other constraints on that type parameter.</span></span> <span data-ttu-id="88cde-112">Bir temel sınıf kısıtlaması olarak bazı türlere izin verilmez: <xref:System.Object> , <xref:System.Array> ve <xref:System.ValueType> .</span><span class="sxs-lookup"><span data-stu-id="88cde-112">Some types are disallowed as a base class constraint: <xref:System.Object>, <xref:System.Array>, and <xref:System.ValueType>.</span></span> <span data-ttu-id="88cde-113">C# 7,3,, ve ' den önce <xref:System.Enum> <xref:System.Delegate> <xref:System.MulticastDelegate> temel sınıf kısıtlamaları olarak da izin verilmedi.</span><span class="sxs-lookup"><span data-stu-id="88cde-113">Before C# 7.3, <xref:System.Enum>, <xref:System.Delegate>, and <xref:System.MulticastDelegate> were also disallowed as base class constraints.</span></span> <span data-ttu-id="88cde-114">Aşağıdaki örnek, artık temel sınıf olarak belirtime türleri göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="88cde-114">The following example shows the types that can now be specified as a base class:</span></span>

[!code-csharp[using an interface constraint](snippets/GenericWhereConstraints.cs#2)]

<span data-ttu-id="88cde-115">C# 8,0 ve sonraki sürümlerde null yapılabilir bir bağlamda, temel sınıf türünün null değer alabilme değeri zorlanır.</span><span class="sxs-lookup"><span data-stu-id="88cde-115">In a nullable context in C# 8.0 and later, the nullability of the base class type is enforced.</span></span> <span data-ttu-id="88cde-116">Temel sınıf null atanamaz ise (örneğin `Base` ), tür bağımsız değişkeni null atanamaz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="88cde-116">If the base class is non-nullable (for example `Base`), the type argument must be non-nullable.</span></span> <span data-ttu-id="88cde-117">Temel sınıf null yapılabilir ise (örneğin `Base?` ), tür bağımsız değişkeni null yapılabilir veya null atanamaz bir başvuru türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="88cde-117">If the base class is nullable (for example `Base?`), the type argument may be either a nullable or non-nullable reference type.</span></span> <span data-ttu-id="88cde-118">Temel sınıf null olamayan bir başvuru türünde ise derleyici bir uyarı verir.</span><span class="sxs-lookup"><span data-stu-id="88cde-118">The compiler issues a warning if the type argument is a nullable reference type when the base class is non-nullable.</span></span>

<span data-ttu-id="88cde-119">`where`Yan tümce türün bir `class` veya bir olduğunu belirtebilir `struct` .</span><span class="sxs-lookup"><span data-stu-id="88cde-119">The `where` clause can specify that the type is a `class` or a `struct`.</span></span> <span data-ttu-id="88cde-120">`struct`Kısıtlama, öğesinin temel sınıf kısıtlamasını belirtme gereksinimini ortadan kaldırır `System.ValueType` .</span><span class="sxs-lookup"><span data-stu-id="88cde-120">The `struct` constraint removes the need to specify a base class constraint of `System.ValueType`.</span></span> <span data-ttu-id="88cde-121">`System.ValueType`Tür, temel sınıf kısıtlaması olarak kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="88cde-121">The `System.ValueType` type may not be used as a base class constraint.</span></span> <span data-ttu-id="88cde-122">Aşağıdaki örnek, `class` ve `struct` kısıtlamalarını göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="88cde-122">The following example shows both the `class` and `struct` constraints:</span></span>

[!code-csharp[using the class and struct constraints](snippets/GenericWhereConstraints.cs#3)]

<span data-ttu-id="88cde-123">C# 8,0 ve sonraki sürümlerde null yapılabilir bir bağlamda kısıtlama, `class` bir türün null yapılamayan bir başvuru türü olmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="88cde-123">In a nullable context in C# 8.0 and later, the `class` constraint requires a type to be a non-nullable reference type.</span></span> <span data-ttu-id="88cde-124">Null yapılabilir başvuru türlerine izin vermek için, `class?` hem null yapılabilir hem de null olamayan başvuru türlerine izin veren kısıtlamayı kullanın.</span><span class="sxs-lookup"><span data-stu-id="88cde-124">To allow nullable reference types, use the `class?` constraint, which allows both nullable and non-nullable reference types.</span></span>

<span data-ttu-id="88cde-125">`where`Yan tümce `notnull` kısıtlaması içerebilir.</span><span class="sxs-lookup"><span data-stu-id="88cde-125">The `where` clause may include the `notnull` constraint.</span></span> <span data-ttu-id="88cde-126">`notnull`Kısıtlama, tür parametresini null yapılamayan türler ile sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="88cde-126">The `notnull` constraint limits the type parameter to non-nullable types.</span></span> <span data-ttu-id="88cde-127">Bu tür bir [değer türü](../builtin-types/value-types.md) veya null yapılamayan bir başvuru türü olabilir.</span><span class="sxs-lookup"><span data-stu-id="88cde-127">That type may be a [value type](../builtin-types/value-types.md) or a non-nullable reference type.</span></span> <span data-ttu-id="88cde-128">`notnull`Kısıtlama, bir [ `nullable enable` bağlamda](../../nullable-references.md#nullable-contexts)derlenen kod için C# 8,0 ' den başlayarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="88cde-128">The `notnull` constraint is available starting in C# 8.0 for code compiled in a [`nullable enable` context](../../nullable-references.md#nullable-contexts).</span></span> <span data-ttu-id="88cde-129">Diğer kısıtlamaların aksine, bir tür bağımsız değişkeni kısıtlamayı ihlal ederse `notnull` , derleyici hata yerine bir uyarı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="88cde-129">Unlike other constraints, if a type argument violates the `notnull` constraint, the compiler generates a warning instead of an error.</span></span> <span data-ttu-id="88cde-130">Uyarılar yalnızca bir `nullable enable` bağlamda oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="88cde-130">Warnings are only generated in a `nullable enable` context.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="88cde-131">Kısıtlamayı içeren genel bildirimler, `notnull` null yapılabilir bir zorunluluvou bağlamında kullanılabilir, ancak derleyici kısıtlamayı zorlamaz.</span><span class="sxs-lookup"><span data-stu-id="88cde-131">Generic declarations that include the `notnull` constraint can be used in a nullable oblivious context, but compiler does not enforce the constraint.</span></span>

[!code-csharp[using the nonnull constraint](snippets/GenericWhereConstraints.cs#NotNull)]

<span data-ttu-id="88cde-132">`where`Yan tümce de bir kısıtlama içerebilir `unmanaged` .</span><span class="sxs-lookup"><span data-stu-id="88cde-132">The `where` clause may also include an `unmanaged` constraint.</span></span> <span data-ttu-id="88cde-133">`unmanaged`Kısıtlama, tür parametresini [yönetilmeyen türler](../builtin-types/unmanaged-types.md)olarak bilinen türlerle sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="88cde-133">The `unmanaged` constraint limits the type parameter to types known as [unmanaged types](../builtin-types/unmanaged-types.md).</span></span> <span data-ttu-id="88cde-134">`unmanaged`Kısıtlama, C# dilinde alt düzey birlikte çalışma kodu yazmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="88cde-134">The `unmanaged` constraint makes it easier to write low-level interop code in C#.</span></span> <span data-ttu-id="88cde-135">Bu kısıtlama, tüm yönetilmeyen türler arasında yeniden kullanılabilir yordamlar sunar.</span><span class="sxs-lookup"><span data-stu-id="88cde-135">This constraint enables reusable routines across all unmanaged types.</span></span> <span data-ttu-id="88cde-136">`unmanaged`Kısıtlama, `class` veya kısıtlaması ile birleştirilemez `struct` .</span><span class="sxs-lookup"><span data-stu-id="88cde-136">The `unmanaged` constraint can't be combined with the `class` or `struct` constraint.</span></span> <span data-ttu-id="88cde-137">`unmanaged`Kısıtlama, türün bir olması için şunu uygular `struct` :</span><span class="sxs-lookup"><span data-stu-id="88cde-137">The `unmanaged` constraint enforces that the type must be a `struct`:</span></span>

[!code-csharp[using the unmanaged constraint](snippets/GenericWhereConstraints.cs#4)]

<span data-ttu-id="88cde-138">`where`Yan tümce bir Oluşturucu kısıtlaması de içerebilir `new()` .</span><span class="sxs-lookup"><span data-stu-id="88cde-138">The `where` clause may also include a constructor constraint, `new()`.</span></span> <span data-ttu-id="88cde-139">Bu kısıtlama işleci kullanarak bir tür parametresinin örneğini oluşturmayı mümkün kılar `new` .</span><span class="sxs-lookup"><span data-stu-id="88cde-139">That constraint makes it possible to create an instance of a type parameter using the `new` operator.</span></span> <span data-ttu-id="88cde-140">[New () kısıtlaması](new-constraint.md) , derleyicinin sağlanan herhangi bir tür bağımsız değişkeninin erişilebilir parametresiz bir oluşturucuya sahip olması gerektiğini bilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="88cde-140">The [new() Constraint](new-constraint.md) lets the compiler know that any type argument supplied must have an accessible parameterless constructor.</span></span> <span data-ttu-id="88cde-141">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="88cde-141">For example:</span></span>

[!code-csharp[using the new constraint](snippets/GenericWhereConstraints.cs#5)]

<span data-ttu-id="88cde-142">`new()`Kısıtlama yan tümcesinde en son görünür `where` .</span><span class="sxs-lookup"><span data-stu-id="88cde-142">The `new()` constraint appears last in the `where` clause.</span></span> <span data-ttu-id="88cde-143">`new()`Kısıtlama `struct` veya `unmanaged` kısıtlamalarıyla birleştirilemez.</span><span class="sxs-lookup"><span data-stu-id="88cde-143">The `new()` constraint can't be combined with the `struct` or `unmanaged` constraints.</span></span> <span data-ttu-id="88cde-144">Bu kısıtlamaların karşılankarşılayan tüm türlerin erişilebilir bir parametresiz oluşturucusu olması gerekir ve `new()` kısıtlama gereksiz hale getirir.</span><span class="sxs-lookup"><span data-stu-id="88cde-144">All types satisfying those constraints must have an accessible parameterless constructor, making the `new()` constraint redundant.</span></span>

<span data-ttu-id="88cde-145">Birden çok tür `where` parametresiyle, her tür parametresi için bir yan tümce kullanın, örneğin:</span><span class="sxs-lookup"><span data-stu-id="88cde-145">With multiple type parameters, use one `where` clause for each type parameter, for example:</span></span>

[!code-csharp[using multiple where constraints](snippets/GenericWhereConstraints.cs#6)]

<span data-ttu-id="88cde-146">Ayrıca, aşağıdaki örnekte gösterildiği gibi genel yöntemlerin tür parametrelerine kısıtlamalar ekleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="88cde-146">You can also attach constraints to type parameters of generic methods, as shown in the following example:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#7)]

<span data-ttu-id="88cde-147">Temsilcilerle ilgili tür parametresi kısıtlamalarını betimleyen sözdiziminin, metodların türüyle aynı olduğunu unutmayın:</span><span class="sxs-lookup"><span data-stu-id="88cde-147">Notice that the syntax to describe type parameter constraints on delegates is the same as that of methods:</span></span>

[!code-csharp[where constraints with generic methods](snippets/GenericWhereConstraints.cs#8)]

<span data-ttu-id="88cde-148">Genel Temsilciler hakkında daha fazla bilgi için bkz. [Genel Temsilciler](../../programming-guide/generics/generic-delegates.md).</span><span class="sxs-lookup"><span data-stu-id="88cde-148">For information on generic delegates, see [Generic Delegates](../../programming-guide/generics/generic-delegates.md).</span></span>

<span data-ttu-id="88cde-149">Kısıtlamaların sözdizimi ve kullanımı hakkında ayrıntılı bilgi için bkz. [tür parametrelerindeki kısıtlamalar](../../programming-guide/generics/constraints-on-type-parameters.md).</span><span class="sxs-lookup"><span data-stu-id="88cde-149">For details on the syntax and use of constraints, see [Constraints on Type Parameters](../../programming-guide/generics/constraints-on-type-parameters.md).</span></span>

## <a name="c-language-specification"></a><span data-ttu-id="88cde-150">C# dili belirtimi</span><span class="sxs-lookup"><span data-stu-id="88cde-150">C# language specification</span></span>

 [!INCLUDE[CSharplangspec](~/includes/csharplangspec-md.md)]

## <a name="see-also"></a><span data-ttu-id="88cde-151">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="88cde-151">See also</span></span>

- [<span data-ttu-id="88cde-152">C# başvurusu</span><span class="sxs-lookup"><span data-stu-id="88cde-152">C# Reference</span></span>](../index.md)
- [<span data-ttu-id="88cde-153">C# Programlama Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="88cde-153">C# Programming Guide</span></span>](../../programming-guide/index.md)
- [<span data-ttu-id="88cde-154">Genel Türlere Giriş</span><span class="sxs-lookup"><span data-stu-id="88cde-154">Introduction to Generics</span></span>](../../programming-guide/generics/index.md)
- [<span data-ttu-id="88cde-155">Yeni kısıtlama</span><span class="sxs-lookup"><span data-stu-id="88cde-155">new Constraint</span></span>](./new-constraint.md)
- [<span data-ttu-id="88cde-156">Tür Parametrelerindeki Kısıtlamalar</span><span class="sxs-lookup"><span data-stu-id="88cde-156">Constraints on Type Parameters</span></span>](../../programming-guide/generics/constraints-on-type-parameters.md)
