---
title: Bir dizin ağacı aracılığıyla yineleme yapma-C# Programlama Kılavuzu
description: Bir dizin ağacında yineleme yapmayı öğrenin. Belirtilen kök klasörü altındaki her iç içe geçmiş alt dizindeki her bir dosyaya erişin.
ms.date: 07/20/2015
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
ms.openlocfilehash: 9d927e8517ddbdb1c5a9a8aa8ca3c321bf7e8d9c
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91178547"
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="c3289-104">Bir dizin ağacında yineleme yapma (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="c3289-104">How to iterate through a directory tree (C# Programming Guide)</span></span>

<span data-ttu-id="c3289-105">"Bir dizin ağacını yineleme" ifadesi, belirtilen kök klasörü altındaki her bir dosyaya her bir dosyanın herhangi bir derinliğine erişmesi anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="c3289-105">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="c3289-106">Her bir dosyayı açmak zorunda değilsiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-106">You do not necessarily have to open each file.</span></span> <span data-ttu-id="c3289-107">Dosya veya alt dizinin adını yalnızca bir olarak alabilir `string` veya bir veya nesnesi biçiminde ek bilgiler alabilirsiniz <xref:System.IO.FileInfo?displayProperty=nameWithType> <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="c3289-107">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c3289-108">Windows 'da, "Directory" ve "Folder" terimleri birbirinin yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="c3289-108">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="c3289-109">Çoğu belge ve Kullanıcı arabirimi metni "klasör" terimini kullanır, ancak .NET sınıf kitaplıkları "Dizin" terimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="c3289-109">Most documentation and user interface text uses the term "folder," but .NET class libraries use the term "directory."</span></span>  
  
 <span data-ttu-id="c3289-110">En basit durumda, belirli bir kök altındaki tüm dizinler için erişim izinleriniz olduğunu bildiğiniz, `System.IO.SearchOption.AllDirectories` bayrağını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-110">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="c3289-111">Bu bayrak, belirtilen Düzenle eşleşen tüm iç içe geçmiş alt dizinleri döndürür.</span><span class="sxs-lookup"><span data-stu-id="c3289-111">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="c3289-112">Aşağıdaki örnek, bu bayrağın nasıl kullanılacağını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="c3289-112">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="c3289-113">Bu yaklaşımdaki zayıflığın, belirtilen kök altındaki alt dizinlerin herhangi biri ya da bir <xref:System.IO.DirectoryNotFoundException> <xref:System.UnauthorizedAccessException> bütün yöntemin başarısız olmasına neden olur ve Dizin döndürmez.</span><span class="sxs-lookup"><span data-stu-id="c3289-113">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="c3289-114">Yöntemi kullandığınızda aynı değeri de geçerlidir <xref:System.IO.DirectoryInfo.GetFiles%2A> .</span><span class="sxs-lookup"><span data-stu-id="c3289-114">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="c3289-115">Bu özel durumları belirli alt klasörlerde işlemeniz gerekiyorsa, aşağıdaki örneklerde gösterildiği gibi, dizin ağacını el ile ilermalısınız.</span><span class="sxs-lookup"><span data-stu-id="c3289-115">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="c3289-116">Bir dizin ağacını el ile ilerlerinizden önce (*ön geçiş öncesi geçiş*) veya dosyaları önce (*sıra çapraz geçişi*), önce alt dizinleri işleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-116">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="c3289-117">Bir ön sırada çapraz geçiş gerçekleştirirseniz, doğrudan o klasörün içinde olan dosyalara geçmeden önce geçerli klasörün altındaki tüm ağaca ileredersiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-117">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="c3289-118">Bu belgenin ilerleyen kısımlarında yer değiştiren örnekler, son düzen çapraz geçişi gerçekleştirir, ancak bunları önceden sıralı çapraz geçiş gerçekleştirmek üzere kolayca değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-118">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="c3289-119">Diğer bir seçenek de özyineleme veya yığın tabanlı bir geçiş geçişinin kullanılıp kullanılmayacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="c3289-119">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="c3289-120">Bu belgede daha sonra gelen örneklerde her iki yaklaşım gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="c3289-120">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="c3289-121">Dosyalar ve klasörler üzerinde çeşitli işlemler gerçekleştirmeniz gerekiyorsa, işlemi tek bir temsilci kullanarak çağırabileceğiniz ayrı işlevlere yeniden düzenleyerek bu örnekleri modüle dönüştürebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-121">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c3289-122">NTFS dosya sistemleri, *birleşme noktaları*, *Simgesel bağlantılar*ve *sabit bağlantılar*biçiminde *yeniden ayrıştırma noktaları* içerebilir.</span><span class="sxs-lookup"><span data-stu-id="c3289-122">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="c3289-123">Ve gibi .NET yöntemleri <xref:System.IO.DirectoryInfo.GetFiles%2A> <xref:System.IO.DirectoryInfo.GetDirectories%2A> , yeniden ayrıştırma noktası altında herhangi bir alt dizin döndürmez.</span><span class="sxs-lookup"><span data-stu-id="c3289-123">.NET methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="c3289-124">Bu davranış, iki yeniden ayrıştırma noktası birbirine başvururken sonsuz döngüye girme riskiyle karşı koruma sağlar.</span><span class="sxs-lookup"><span data-stu-id="c3289-124">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="c3289-125">Genel olarak, dosyaları istem dışı olarak değiştirmeyin veya sildiğinizden emin olmak için yeniden ayrıştırma noktalarıyla uğraşdığınızda olağanüstü dikkatli olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c3289-125">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="c3289-126">Yeniden ayrıştırma noktaları üzerinde tam denetime ihtiyacınız varsa, doğrudan ilgili Win32 dosya sistemi yöntemlerini çağırmak için platform çağırma veya yerel kod kullanın.</span><span class="sxs-lookup"><span data-stu-id="c3289-126">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="c3289-127">Örnek</span><span class="sxs-lookup"><span data-stu-id="c3289-127">Example</span></span>  

 <span data-ttu-id="c3289-128">Aşağıdaki örnek, özyineleme kullanarak bir dizin ağacına nasıl yol gösterir.</span><span class="sxs-lookup"><span data-stu-id="c3289-128">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="c3289-129">Özyinelemeli yaklaşım zarif, ancak dizin ağacı büyük ve derin iç içe ise bir yığın taşması özel durumuna neden olur.</span><span class="sxs-lookup"><span data-stu-id="c3289-129">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="c3289-130">İşlenen özel durumlar ve her dosya veya klasör üzerinde gerçekleştirilen belirli eylemler yalnızca örnek olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="c3289-130">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="c3289-131">Bu kodu, özel gereksinimlerinizi karşılayacak şekilde değiştirmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-131">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="c3289-132">Daha fazla bilgi için koddaki açıklamalara bakın.</span><span class="sxs-lookup"><span data-stu-id="c3289-132">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#1)]  
  
## <a name="example"></a><span data-ttu-id="c3289-133">Örnek</span><span class="sxs-lookup"><span data-stu-id="c3289-133">Example</span></span>  

 <span data-ttu-id="c3289-134">Aşağıdaki örnek, özyineleme kullanılmadan bir dizin ağacındaki dosyalar ve klasörler arasında nasıl yineleme yapılacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="c3289-134">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="c3289-135">Bu teknik <xref:System.Collections.Generic.Stack%601> , son ilk çıkar (LIFO) yığını olan genel koleksiyon türünü kullanır.</span><span class="sxs-lookup"><span data-stu-id="c3289-135">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="c3289-136">İşlenen özel durumlar ve her dosya veya klasör üzerinde gerçekleştirilen belirli eylemler yalnızca örnek olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="c3289-136">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="c3289-137">Bu kodu, özel gereksinimlerinizi karşılayacak şekilde değiştirmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-137">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="c3289-138">Daha fazla bilgi için koddaki açıklamalara bakın.</span><span class="sxs-lookup"><span data-stu-id="c3289-138">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csFilesAndFolders/CS/FileIteration.cs#2)]  
  
 <span data-ttu-id="c3289-139">Uygulamanızın onu açma iznine sahip olup olmadığını anlamak için her klasörü sınamak genellikle çok zaman alır.</span><span class="sxs-lookup"><span data-stu-id="c3289-139">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="c3289-140">Bu nedenle, kod örneği işlemin yalnızca bu parçasını bir `try/catch` blokta barındırır.</span><span class="sxs-lookup"><span data-stu-id="c3289-140">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="c3289-141">`catch`Bir klasöre erişim izni reddedildiğinde, izinlerinizi yükseltmeyi ve sonra yeniden erişmeyi deneyerek engellemeyi değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-141">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="c3289-142">Bir kural olarak, yalnızca uygulamanızı bilinmeyen bir durumda bırakmadan işleyebilmeniz için bu özel durumları yakalayın.</span><span class="sxs-lookup"><span data-stu-id="c3289-142">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="c3289-143">Bir dizin ağacının içeriğini bellekte veya diskte depolamanız gerekirse, en iyi seçenek <xref:System.IO.FileSystemInfo.FullName%2A> her bir dosya için yalnızca özelliğini (türü) saklamalıdır `string` .</span><span class="sxs-lookup"><span data-stu-id="c3289-143">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="c3289-144">Daha sonra bu dizeyi <xref:System.IO.FileInfo> , gerektiğinde yeni bir veya nesne oluşturmak <xref:System.IO.DirectoryInfo> veya ek işlem gerektiren herhangi bir dosyayı açmak için kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c3289-144">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="c3289-145">Güçlü Programlama</span><span class="sxs-lookup"><span data-stu-id="c3289-145">Robust Programming</span></span>  

 <span data-ttu-id="c3289-146">Sağlam dosya yineleme kodu, dosya sisteminin birçok karmaşıklıklarını dikkate almalıdır.</span><span class="sxs-lookup"><span data-stu-id="c3289-146">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="c3289-147">Windows dosya sistemi hakkında daha fazla bilgi için bkz. [NTFS 'ye genel bakış](/windows-server/storage/file-server/ntfs-overview).</span><span class="sxs-lookup"><span data-stu-id="c3289-147">For more information on the Windows file system, see [NTFS overview](/windows-server/storage/file-server/ntfs-overview).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c3289-148">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="c3289-148">See also</span></span>

- <xref:System.IO>
- [<span data-ttu-id="c3289-149">LINQ ve Dosya Dizinleri</span><span class="sxs-lookup"><span data-stu-id="c3289-149">LINQ and File Directories</span></span>](../concepts/linq/linq-and-file-directories.md)
- [<span data-ttu-id="c3289-150">Dosya Sistemi ve Kayıt Defteri (C# Programlama Kılavuzu)</span><span class="sxs-lookup"><span data-stu-id="c3289-150">File System and the Registry (C# Programming Guide)</span></span>](./index.md)
