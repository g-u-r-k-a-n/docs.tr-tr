---
title: Dispose yöntemi uygulama
ms.date: 04/07/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- Dispose method
- garbage collection, Dispose method
ms.assetid: eb4e1af0-3b48-4fbc-ad4e-fc2f64138bf9
ms.openlocfilehash: 95726d4bfae6da43cd845d461caf8f1848d774f1
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/01/2019
ms.locfileid: "73424326"
---
# <a name="implementing-a-dispose-method"></a><span data-ttu-id="83f56-102">Dispose yöntemi uygulama</span><span class="sxs-lookup"><span data-stu-id="83f56-102">Implementing a Dispose method</span></span>

<span data-ttu-id="83f56-103">Uygulamanız tarafından kullanılan yönetilmeyen kaynakları serbest bırakmak için bir <xref:System.IDisposable.Dispose%2A> yöntemi uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="83f56-103">You implement a <xref:System.IDisposable.Dispose%2A> method to release unmanaged resources used by your application.</span></span> <span data-ttu-id="83f56-104">.NET atık toplayıcısı, yönetilmeyen bellek ayırır veya serbest bırakmaz.</span><span class="sxs-lookup"><span data-stu-id="83f56-104">The .NET garbage collector does not allocate or release unmanaged memory.</span></span>  
  
<span data-ttu-id="83f56-105">[Dispose düzeni](implementing-dispose.md)olarak adlandırılan bir nesneyi elden atma düzeni, bir nesnenin ömrüne göre sıra uygular.</span><span class="sxs-lookup"><span data-stu-id="83f56-105">The pattern for disposing an object, referred to as a [dispose pattern](implementing-dispose.md), imposes order on the lifetime of an object.</span></span> <span data-ttu-id="83f56-106">Dispose deseni yalnızca yönetilmeyen kaynaklara erişen, dosya ve kanal tanıtıcıları, kayıt defteri tanıtıcıları, bekleme tanıtıcıları veya yönetilmeyen bellek bloğu işaretçileri gibi nesneler için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="83f56-106">The dispose pattern is used only for objects that access unmanaged resources, such as file and pipe handles, registry handles, wait handles, or pointers to blocks of unmanaged memory.</span></span> <span data-ttu-id="83f56-107">Bunun nedeni, çöp toplayıcısının kullanılmayan yönetilen nesneleri geri kazanmada çok etkili olması, fakat yönetilmeyen nesneleri geri kazanamamasıdır.</span><span class="sxs-lookup"><span data-stu-id="83f56-107">This is because the garbage collector is very efficient at reclaiming unused managed objects, but it is unable to reclaim unmanaged objects.</span></span>  
  
<span data-ttu-id="83f56-108">Dispose deseninin iki çeşidi vardır:</span><span class="sxs-lookup"><span data-stu-id="83f56-108">The dispose pattern has two variations:</span></span>  
  
- <span data-ttu-id="83f56-109">Bir türün kullandığı her yönetilmeyen kaynağı bir güvenli tanıtıcıda (yani <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>türetilmiş bir sınıfta) sarın.</span><span class="sxs-lookup"><span data-stu-id="83f56-109">You wrap each unmanaged resource that a type uses in a safe handle (that is, in a class derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>).</span></span> <span data-ttu-id="83f56-110">Bu durumda, <xref:System.IDisposable> arabirimini ve ek bir `Dispose(Boolean)` yöntemini uygulayacağınızı görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="83f56-110">In this case, you implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method.</span></span> <span data-ttu-id="83f56-111">Bu önerilen çeşitdir ve <xref:System.Object.Finalize%2A?displayProperty=nameWithType> yöntemi geçersiz kılmayı gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="83f56-111">This is the recommended variation and doesn't require overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span>  
  
  > [!NOTE]
  > <span data-ttu-id="83f56-112"><xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> ad alanı, [güvenli Işleyiciler kullanma](#SafeHandles) bölümünde listelenen <xref:System.Runtime.InteropServices.SafeHandle>türetilmiş bir sınıf kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="83f56-112">The <xref:Microsoft.Win32.SafeHandles?displayProperty=nameWithType> namespace provides a set of classes derived from <xref:System.Runtime.InteropServices.SafeHandle>, which are listed in the [Using safe handles](#SafeHandles) section.</span></span> <span data-ttu-id="83f56-113">Yönetilmeyen kaynağınız serbest bırakmak için uygun bir sınıf bulamıyorsanız, kendi <xref:System.Runtime.InteropServices.SafeHandle>kendi alt sınıfınızı uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="83f56-113">If you can't find a class that is suitable for releasing your unmanaged resource, you can implement your own subclass of <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>  
  
- <span data-ttu-id="83f56-114"><xref:System.IDisposable> arabirimini ve ek bir `Dispose(Boolean)` yöntemini uygularsınız ve ayrıca <xref:System.Object.Finalize%2A?displayProperty=nameWithType> yöntemini geçersiz kılarsınız.</span><span class="sxs-lookup"><span data-stu-id="83f56-114">You implement the <xref:System.IDisposable> interface and an additional `Dispose(Boolean)` method, and you also override the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="83f56-115"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> uygulamanız, türden bir tüketici tarafından çağrılmadığı takdirde yönetilmeyen kaynakların ' ın çıkarıldığından emin olmak için <xref:System.Object.Finalize%2A> geçersiz kılmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="83f56-115">You must override <xref:System.Object.Finalize%2A> to ensure that unmanaged resources are disposed of if your <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation is not called by a consumer of your type.</span></span> <span data-ttu-id="83f56-116">Önceki madde işaretinde ele alınan önerilen tekniği kullanırsanız <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> sınıfı bunu sizin yerinize yapar.</span><span class="sxs-lookup"><span data-stu-id="83f56-116">If you use the recommended technique discussed in the previous bullet, the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class does this on your behalf.</span></span>  
  
<span data-ttu-id="83f56-117">Kaynakların her zaman uygun şekilde temizlendiğinden emin olmak için bir <xref:System.IDisposable.Dispose%2A> yöntemi özel durum oluşturmadan birden çok kez çağrılabilir olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="83f56-117">To help ensure that resources are always cleaned up appropriately, a <xref:System.IDisposable.Dispose%2A> method should be callable multiple times without throwing an exception.</span></span>  
  
<span data-ttu-id="83f56-118"><xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> yöntemi için belirtilen kod örneği, ısrarlı çöp toplamanın, geri kazanılan nesnenin bir üyesi hala yürütülürken sonlandırıcının çalışmasına nasıl neden olabileceği gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="83f56-118">The code example provided for the <xref:System.GC.KeepAlive%2A?displayProperty=nameWithType> method shows how aggressive garbage collection can cause a finalizer to run while a member of the reclaimed object is still executing.</span></span> <span data-ttu-id="83f56-119">Uzun bir <xref:System.IDisposable.Dispose%2A> yönteminin sonunda <xref:System.GC.KeepAlive%2A> yöntemini çağırmak iyi bir fikirdir.</span><span class="sxs-lookup"><span data-stu-id="83f56-119">It is a good idea to call the <xref:System.GC.KeepAlive%2A> method at the end of a lengthy <xref:System.IDisposable.Dispose%2A> method.</span></span>  
  
<a name="Dispose2"></a>
## <a name="dispose-and-disposeboolean"></a><span data-ttu-id="83f56-120">Dispose() ve Dispose(Boolean)</span><span class="sxs-lookup"><span data-stu-id="83f56-120">Dispose() and Dispose(Boolean)</span></span>  

<span data-ttu-id="83f56-121"><xref:System.IDisposable> arabirimi, <xref:System.IDisposable.Dispose%2A>tek bir parametresiz yöntemin uygulanmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="83f56-121">The <xref:System.IDisposable> interface requires the implementation of a single parameterless method, <xref:System.IDisposable.Dispose%2A>.</span></span> <span data-ttu-id="83f56-122">Ancak, Dispose deseninin uygulanması için iki `Dispose` yöntemi gerekir:</span><span class="sxs-lookup"><span data-stu-id="83f56-122">However, the dispose pattern requires two `Dispose` methods to be implemented:</span></span>  
  
- <span data-ttu-id="83f56-123">Bir parametre içermeyen, uygulama <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> ortak sanal olmayan bir (Visual Basic`NonInheritable`).</span><span class="sxs-lookup"><span data-stu-id="83f56-123">A public non-virtual (`NonInheritable` in Visual Basic) <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation that has no parameters.</span></span>  
  
- <span data-ttu-id="83f56-124">İmzaya sahip korumalı bir sanal (Visual Basic`Overridable`) `Dispose` yöntemi:</span><span class="sxs-lookup"><span data-stu-id="83f56-124">A protected virtual (`Overridable` in Visual Basic) `Dispose` method whose signature is:</span></span>  
  
  [!code-csharp[Conceptual.Disposable#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#8)]
  [!code-vb[Conceptual.Disposable#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#8)]  
  
### <a name="the-dispose-overload"></a><span data-ttu-id="83f56-125">Dispose () aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="83f56-125">The Dispose() overload</span></span>

<span data-ttu-id="83f56-126">Ortak, sanal olmayan (Visual Basic`NonInheritable`), parametresiz `Dispose` yöntemi türü bir tüketici tarafından çağrıldığından amacı, yönetilmeyen kaynakları serbest bırakmak ve varsa sonlandırıcının çalıştırması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="83f56-126">Because the public, non-virtual (`NonInheritable` in Visual Basic), parameterless `Dispose` method is called by a consumer of the type, its purpose is to free unmanaged resources and to indicate that the finalizer, if one is present, doesn't have to run.</span></span> <span data-ttu-id="83f56-127">Bu nedenle, standart bir uygulaması vardır:</span><span class="sxs-lookup"><span data-stu-id="83f56-127">Because of this, it has a standard implementation:</span></span>  
  
[!code-csharp[Conceptual.Disposable#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/dispose1.cs#7)]
[!code-vb[Conceptual.Disposable#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/dispose1.vb#7)]  
  
<span data-ttu-id="83f56-128">`Dispose` yöntemi tüm nesne temizleme işlemini gerçekleştirir, bu nedenle çöp toplayıcının artık ' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override ' nesnelerini çağırması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="83f56-128">The `Dispose` method performs all object cleanup, so the garbage collector no longer needs to call the objects' <xref:System.Object.Finalize%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="83f56-129">Bu nedenle, <xref:System.GC.SuppressFinalize%2A> yöntemine yapılan çağrı, çöp toplayıcısının sonlandırıcıyı çalıştırmasını önler.</span><span class="sxs-lookup"><span data-stu-id="83f56-129">Therefore, the call to the <xref:System.GC.SuppressFinalize%2A> method prevents the garbage collector from running the finalizer.</span></span> <span data-ttu-id="83f56-130">Türün sonlandırıcısı yoksa <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> çağrısının hiçbir etkisi olmaz.</span><span class="sxs-lookup"><span data-stu-id="83f56-130">If the type has no finalizer, the call to <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> has no effect.</span></span> <span data-ttu-id="83f56-131">Yönetilmeyen kaynakları serbest bırakma işinin gerçek işinin `Dispose` yönteminin ikinci aşırı yüklemesi tarafından gerçekleştirildiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="83f56-131">Note that the actual work of releasing unmanaged resources is performed by the second overload of the `Dispose` method.</span></span>  
  
### <a name="the-disposeboolean-overload"></a><span data-ttu-id="83f56-132">Dispose (Boolean) aşırı yüklemesi</span><span class="sxs-lookup"><span data-stu-id="83f56-132">The Dispose(Boolean) overload</span></span>

<span data-ttu-id="83f56-133">İkinci aşırı yüklemede, *disposing* parametresi, yöntem çağrısının bir <xref:System.IDisposable.Dispose%2A> yönteminden (değer `true`) mi yoksa sonlandırıcının mi (değer `false`) geldiğini belirten bir <xref:System.Boolean>.</span><span class="sxs-lookup"><span data-stu-id="83f56-133">In the second overload, the *disposing* parameter is a <xref:System.Boolean> that indicates whether the method call comes from a <xref:System.IDisposable.Dispose%2A> method (its value is `true`) or from a finalizer (its value is `false`).</span></span>  
  
<span data-ttu-id="83f56-134">Yöntemin gövdesi iki kod bloğundan oluşur:</span><span class="sxs-lookup"><span data-stu-id="83f56-134">The body of the method consists of two blocks of code:</span></span>  
  
- <span data-ttu-id="83f56-135">Yönetilmeyen kaynakları serbest bırakan bir blok.</span><span class="sxs-lookup"><span data-stu-id="83f56-135">A block that frees unmanaged resources.</span></span> <span data-ttu-id="83f56-136">Bu blok `disposing` parametresinin değerinden bağımsız olarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="83f56-136">This block executes regardless of the value of the `disposing` parameter.</span></span>  
  
- <span data-ttu-id="83f56-137">Yönetilen kaynakları serbest bırakan koşullu bir blok.</span><span class="sxs-lookup"><span data-stu-id="83f56-137">A conditional block that frees managed resources.</span></span> <span data-ttu-id="83f56-138">`disposing` değeri `true`ise bu blok yürütülür.</span><span class="sxs-lookup"><span data-stu-id="83f56-138">This block executes if the value of `disposing` is `true`.</span></span> <span data-ttu-id="83f56-139">Serbest bıraktığı yönetilen kaynaklar şunları içerebilir:</span><span class="sxs-lookup"><span data-stu-id="83f56-139">The managed resources that it frees can include:</span></span>  
  
  <span data-ttu-id="83f56-140">**<xref:System.IDisposable>uygulayan yönetilen nesneler.**</span><span class="sxs-lookup"><span data-stu-id="83f56-140">**Managed objects that implement <xref:System.IDisposable>.**</span></span> <span data-ttu-id="83f56-141">Koşullu blok, <xref:System.IDisposable.Dispose%2A> uygulamasını çağırmak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="83f56-141">The conditional block can be used to call their <xref:System.IDisposable.Dispose%2A> implementation.</span></span> <span data-ttu-id="83f56-142">Yönetilmeyen kaynağınızı kaydırmak için güvenli bir tanıtıcı kullandıysanız buradaki <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> uygulamasını çağırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="83f56-142">If you have used a safe handle to wrap your unmanaged resource, you should call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%28System.Boolean%29?displayProperty=nameWithType> implementation here.</span></span>  
  
  <span data-ttu-id="83f56-143">**Büyük miktarlarda bellek kullanan veya nadir kaynaklarını tüketen yönetilen nesneler.**</span><span class="sxs-lookup"><span data-stu-id="83f56-143">**Managed objects that consume large amounts of memory or consume scarce resources.**</span></span> <span data-ttu-id="83f56-144">Bu nesneleri açıkça `Dispose` yönteminde serbest bırakma, çöp toplayıcı tarafından belirleyici olmayan şekilde geri kazanıladıklarından daha hızlı bir şekilde serbest bırakır.</span><span class="sxs-lookup"><span data-stu-id="83f56-144">Freeing these objects explicitly in the `Dispose` method releases them faster than if they were reclaimed non-deterministically by the garbage collector.</span></span>  
  
<span data-ttu-id="83f56-145">Yöntem çağrısı bir sonlandırıcının geliyorsa (yani, *disposing* `false`), yalnızca yönetilmeyen kaynakları serbest bırakma kodu yürütülür.</span><span class="sxs-lookup"><span data-stu-id="83f56-145">If the method call comes from a finalizer (that is, if *disposing* is `false`), only the code that frees unmanaged resources executes.</span></span> <span data-ttu-id="83f56-146">Çöp toplayıcı 'nın sonlandırma sırasında yönetilen nesneleri yok ettiği sıra tanımlanmadığı için, bu `Dispose` aşırı yüklemesini `false` bir değer ile çağırmak, sonlandırıcının zaten yapılmış olabilecek yönetilen kaynakları serbest bırakmasına engel olur lamıyor.</span><span class="sxs-lookup"><span data-stu-id="83f56-146">Because the order in which the garbage collector destroys managed objects during finalization is not defined, calling this `Dispose` overload with a value of `false` prevents the finalizer from trying to release managed resources that may have already been reclaimed.</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="83f56-147">Dispose desenini bir temel sınıf için uygulama</span><span class="sxs-lookup"><span data-stu-id="83f56-147">Implementing the dispose pattern for a base class</span></span>

<span data-ttu-id="83f56-148">Dispose desenini bir temel sınıf için uygularsanız, aşağıdakileri sağlamanız gerekir:</span><span class="sxs-lookup"><span data-stu-id="83f56-148">If you implement the dispose pattern for a base class, you must provide the following:</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="83f56-149">Bu kalıbı <xref:System.IDisposable.Dispose> uygulayan ve `sealed` olmayan (Visual Basic`NotInheritable`) tüm temel sınıflar için uygulamalısınız.</span><span class="sxs-lookup"><span data-stu-id="83f56-149">You should implement this pattern for all base classes that implement <xref:System.IDisposable.Dispose> and are not `sealed` (`NotInheritable` in Visual Basic).</span></span>  
  
- <span data-ttu-id="83f56-150">`Dispose(Boolean)` yöntemini çağıran <xref:System.IDisposable.Dispose%2A> uygulama.</span><span class="sxs-lookup"><span data-stu-id="83f56-150">A <xref:System.IDisposable.Dispose%2A> implementation that calls the `Dispose(Boolean)` method.</span></span>  
  
- <span data-ttu-id="83f56-151">Kaynak bırakma işinin gerçek işini gerçekleştiren bir `Dispose(Boolean)` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="83f56-151">A `Dispose(Boolean)` method that performs the actual work of releasing resources.</span></span>  
  
- <span data-ttu-id="83f56-152">Yönetilmeyen kaynağı sarmalayan <xref:System.Runtime.InteropServices.SafeHandle> türetilen bir sınıf (önerilir) veya <xref:System.Object.Finalize%2A?displayProperty=nameWithType> yöntemine bir geçersiz kılma.</span><span class="sxs-lookup"><span data-stu-id="83f56-152">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="83f56-153"><xref:System.Runtime.InteropServices.SafeHandle> sınıfı, sizi kod içine almak zorunda kalmanızı sağlayan bir Sonlandırıcı sağlar.</span><span class="sxs-lookup"><span data-stu-id="83f56-153">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span>  
  
<span data-ttu-id="83f56-154">Aşağıda, güvenli tanıtıcı kullanan bir temel sınıf için Dispose deseninin uygulanması için genel bir model verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="83f56-154">Here's the general pattern for implementing the dispose pattern for a base class that uses a safe handle.</span></span>  
  
[!code-csharp[System.IDisposable#3](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
[!code-vb[System.IDisposable#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
> [!NOTE]
> <span data-ttu-id="83f56-155">Önceki örnek, bir <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> nesneyi kullanarak, kalıbı gösterir; <xref:System.Runtime.InteropServices.SafeHandle> türetilmiş herhangi bir nesne bunun yerine kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="83f56-155">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="83f56-156">Örneğin <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> nesnesinin düzgün şekilde örneklemez olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="83f56-156">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="83f56-157"><xref:System.Object.Finalize%2A?displayProperty=nameWithType>geçersiz kılan bir temel sınıf için Dispose deseninin uygulanması için genel bir örüntü.</span><span class="sxs-lookup"><span data-stu-id="83f56-157">Here's the general pattern for implementing the dispose pattern for a base class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span>  
  
[!code-csharp[System.IDisposable#5](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
[!code-vb[System.IDisposable#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
> [!NOTE]
> <span data-ttu-id="83f56-158">İçinde C#, bir [yıkıcı](../../csharp/programming-guide/classes-and-structs/destructors.md)tanımlayarak <xref:System.Object.Finalize%2A?displayProperty=nameWithType> geçersiz kılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="83f56-158">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
## <a name="implementing-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="83f56-159">Türetilen bir sınıf için dispose desenini uygulama</span><span class="sxs-lookup"><span data-stu-id="83f56-159">Implementing the dispose pattern for a derived class</span></span>

<span data-ttu-id="83f56-160"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> temel sınıf uygulaması türetilmiş sınıfları tarafından devralındığından, <xref:System.IDisposable> arabirimini uygulayan bir sınıftan türetilmiş bir sınıf <xref:System.IDisposable>uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="83f56-160">A class derived from a class that implements the <xref:System.IDisposable> interface shouldn't implement <xref:System.IDisposable>, because the base class implementation of <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> is inherited by its derived classes.</span></span> <span data-ttu-id="83f56-161">Onun yerine, türetilen bir sınıfa ilişkin olarak dispose desenini uygulamak için aşağıdakileri sağlarsınız:</span><span class="sxs-lookup"><span data-stu-id="83f56-161">Instead, to implement the dispose pattern for a derived class, you provide the following:</span></span>  
  
- <span data-ttu-id="83f56-162">Temel sınıf yöntemini geçersiz kılan ve türetilen sınıfın kaynaklarını serbest bırakma işinin asıl işini gerçekleştiren bir `protected Dispose(Boolean)` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="83f56-162">A `protected Dispose(Boolean)` method that overrides the base class method and performs the actual work of releasing the resources of the derived class.</span></span> <span data-ttu-id="83f56-163">Bu yöntem ayrıca temel sınıfın `Dispose(Boolean)` yöntemini çağırmalıdır ve bağımsız değişkeni için disposing durumunu iletmelidir.</span><span class="sxs-lookup"><span data-stu-id="83f56-163">This method should also call the `Dispose(Boolean)` method of the base class and pass its disposing status for the argument.</span></span>  
  
- <span data-ttu-id="83f56-164">Yönetilmeyen kaynağı sarmalayan <xref:System.Runtime.InteropServices.SafeHandle> türetilen bir sınıf (önerilir) veya <xref:System.Object.Finalize%2A?displayProperty=nameWithType> yöntemine bir geçersiz kılma.</span><span class="sxs-lookup"><span data-stu-id="83f56-164">Either a class derived from <xref:System.Runtime.InteropServices.SafeHandle> that wraps your unmanaged resource (recommended), or an override to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="83f56-165"><xref:System.Runtime.InteropServices.SafeHandle> sınıfı, sizi kod içine almak zorunda kalmanızı sağlayan bir Sonlandırıcı sağlar.</span><span class="sxs-lookup"><span data-stu-id="83f56-165">The <xref:System.Runtime.InteropServices.SafeHandle> class provides a finalizer that frees you from having to code one.</span></span> <span data-ttu-id="83f56-166">Bir Sonlandırıcı sağlarsanız, `false`bir *disposing* bağımsız değişkeniyle `Dispose(Boolean)` aşırı yüklemeyi çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="83f56-166">If you do provide a finalizer, it should call the `Dispose(Boolean)` overload with a *disposing* argument of `false`.</span></span>  
  
<span data-ttu-id="83f56-167">Güvenli tanıtıcı kullanan bir türetilen sınıf için dispose deseni uygulamada genel düzen aşağıdaki gibidir:</span><span class="sxs-lookup"><span data-stu-id="83f56-167">Here's the general pattern for implementing the dispose pattern for a derived class that uses a safe handle:</span></span>  
  
[!code-csharp[System.IDisposable#4](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
[!code-vb[System.IDisposable#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
> [!NOTE]
> <span data-ttu-id="83f56-168">Önceki örnek, bir <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> nesneyi kullanarak, kalıbı gösterir; <xref:System.Runtime.InteropServices.SafeHandle> türetilmiş herhangi bir nesne bunun yerine kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="83f56-168">The previous example uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to illustrate the pattern; any object derived from <xref:System.Runtime.InteropServices.SafeHandle> could be used instead.</span></span> <span data-ttu-id="83f56-169">Örneğin <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> nesnesinin düzgün şekilde örneklemez olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="83f56-169">Note that the example does not properly instantiate its <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object.</span></span>  
  
<span data-ttu-id="83f56-170"><xref:System.Object.Finalize%2A?displayProperty=nameWithType>geçersiz kılan türetilmiş bir sınıf için Dispose deseninin uygulanması için genel bir örüntü:</span><span class="sxs-lookup"><span data-stu-id="83f56-170">Here's the general pattern for implementing the dispose pattern for a derived class that overrides <xref:System.Object.Finalize%2A?displayProperty=nameWithType>:</span></span>  
  
[!code-csharp[System.IDisposable#6](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived2.cs#6)]
[!code-vb[System.IDisposable#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived2.vb#6)]  
  
> [!NOTE]
> <span data-ttu-id="83f56-171">İçinde C#, bir [yıkıcı](../../csharp/programming-guide/classes-and-structs/destructors.md)tanımlayarak <xref:System.Object.Finalize%2A?displayProperty=nameWithType> geçersiz kılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="83f56-171">In C#, you override <xref:System.Object.Finalize%2A?displayProperty=nameWithType> by defining a [destructor](../../csharp/programming-guide/classes-and-structs/destructors.md).</span></span>  
  
<a name="SafeHandles"></a>   
## <a name="using-safe-handles"></a><span data-ttu-id="83f56-172">Güvenli tanıtıcıları kullanma</span><span class="sxs-lookup"><span data-stu-id="83f56-172">Using safe handles</span></span>

<span data-ttu-id="83f56-173">Bir nesnenin sonlandırıcısı için kod yazmak, doğru yapılmaması durumunda sorunlara neden olabilecek karmaşık bir görevdir.</span><span class="sxs-lookup"><span data-stu-id="83f56-173">Writing code for an object's finalizer is a complex task that can cause problems if not done correctly.</span></span> <span data-ttu-id="83f56-174">Bu nedenle, bir sonlandırıcıyı uygulamak yerine <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> nesneleri oluşturmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="83f56-174">Therefore, we recommend that you construct <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> objects instead of implementing a finalizer.</span></span>  
  
<span data-ttu-id="83f56-175"><xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> sınıfından türetilmiş sınıflar, kesintiye uğramadan işleyicileri atayarak ve serbest bırakarak nesne ömrü sorunlarını basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="83f56-175">Classes derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class simplify object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="83f56-176">Uygulama etki alanı kaldırılırken çalıştırılması kesin olan kritik bir sonlandırıcı içerirler.</span><span class="sxs-lookup"><span data-stu-id="83f56-176">They contain a critical finalizer that is guaranteed to run while an application domain is unloading.</span></span> <span data-ttu-id="83f56-177">Güvenli bir tanıtıcı kullanmanın avantajları hakkında daha fazla bilgi için bkz. <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="83f56-177">For more information about the advantages of using a safe handle, see <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>.</span></span> <span data-ttu-id="83f56-178"><xref:Microsoft.Win32.SafeHandles> ad alanındaki aşağıdaki türetilmiş sınıflar, güvenli işleyiciler sağlar:</span><span class="sxs-lookup"><span data-stu-id="83f56-178">The following derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace provide safe handles:</span></span>  
  
- <span data-ttu-id="83f56-179">Dosyalar, bellek eşlemeli dosyalar ve kanallar için <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>ve <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="83f56-179">The <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle>, and <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class, for files, memory mapped files, and pipes.</span></span>  
  
- <span data-ttu-id="83f56-180">Bellek görünümleri için <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="83f56-180">The <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class, for memory views.</span></span>  
  
- <span data-ttu-id="83f56-181">Şifreleme yapıları için <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>ve <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> sınıfları.</span><span class="sxs-lookup"><span data-stu-id="83f56-181">The <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes, for cryptography constructs.</span></span>  
  
- <span data-ttu-id="83f56-182">Kayıt defteri anahtarları için <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="83f56-182">The <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class, for registry keys.</span></span>  
  
- <span data-ttu-id="83f56-183">Wait tutamaçları için <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> sınıfı.</span><span class="sxs-lookup"><span data-stu-id="83f56-183">The <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class, for wait handles.</span></span>  
  
<a name="base"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-base-class"></a><span data-ttu-id="83f56-184">Bir temel sınıfa ilişkin olarak dispose deseni uygulamak için güvenli tanıtıcı kullanma</span><span class="sxs-lookup"><span data-stu-id="83f56-184">Using a safe handle to implement the dispose pattern for a base class</span></span>

<span data-ttu-id="83f56-185">Aşağıdaki örnek, yönetilmeyen kaynakları kapsüllemek için güvenli bir tanıtıcı kullanan `DisposableStreamResource`bir temel sınıf için Dispose modelini gösterir.</span><span class="sxs-lookup"><span data-stu-id="83f56-185">The following example illustrates the dispose pattern for a base class, `DisposableStreamResource`, that uses a safe handle to encapsulate unmanaged resources.</span></span> <span data-ttu-id="83f56-186">Açık bir dosyayı temsil eden bir <xref:System.IO.Stream> nesnesini kaydırmak için <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> kullanan bir `DisposableResource` sınıfını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="83f56-186">It defines a `DisposableResource` class that uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> to wrap a <xref:System.IO.Stream> object that represents an open file.</span></span> <span data-ttu-id="83f56-187">`DisposableResource` yöntemi, dosya akışındaki toplam bayt sayısını döndüren `Size`tek bir özelliğini de içerir.</span><span class="sxs-lookup"><span data-stu-id="83f56-187">The `DisposableResource` method also includes a single property, `Size`, that returns the total number of bytes in the file stream.</span></span>  
  
[!code-csharp[Conceptual.Disposable#9](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/base1.cs#9)]
[!code-vb[Conceptual.Disposable#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/base1.vb#9)]  
  
<a name="derived"></a>   
## <a name="using-a-safe-handle-to-implement-the-dispose-pattern-for-a-derived-class"></a><span data-ttu-id="83f56-188">Bir türetilen sınıfa ilişkin olarak dispose deseni uygulamak için güvenli tanıtıcı kullanma</span><span class="sxs-lookup"><span data-stu-id="83f56-188">Using a safe handle to implement the dispose pattern for a derived class</span></span>

<span data-ttu-id="83f56-189">Aşağıdaki örnek, bir önceki örnekte sunulan `DisposableStreamResource` sınıfından devralan `DisposableStreamResource2`türetilmiş bir sınıf için Dispose modelini gösterir.</span><span class="sxs-lookup"><span data-stu-id="83f56-189">The following example illustrates the dispose pattern for a derived class, `DisposableStreamResource2`, that inherits from the `DisposableStreamResource` class presented in the previous example.</span></span> <span data-ttu-id="83f56-190">Sınıfı, `WriteFileInfo`ek bir yöntem ekler ve yazılabilir dosyanın tanıtıcısını kaydırmak için bir <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> nesnesi kullanır.</span><span class="sxs-lookup"><span data-stu-id="83f56-190">The class adds an additional method, `WriteFileInfo`, and uses a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> object to wrap the handle of the writable file.</span></span>  
  
[!code-csharp[Conceptual.Disposable#10](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.disposable/cs/derived1.cs#10)]
[!code-vb[Conceptual.Disposable#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.disposable/vb/derived1.vb#10)]  
  
## <a name="see-also"></a><span data-ttu-id="83f56-191">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="83f56-191">See also</span></span>

- <xref:System.GC.SuppressFinalize%2A>
- <xref:System.IDisposable>
- <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>
- <xref:Microsoft.Win32.SafeHandles>
- <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>
- <xref:System.Object.Finalize%2A?displayProperty=nameWithType>
- [<span data-ttu-id="83f56-192">Nasıl yapılır: Sınıfları ve Yapıları Tanımlama ve Kullanma (C++/CLI)</span><span class="sxs-lookup"><span data-stu-id="83f56-192">How to: Define and Consume Classes and Structs (C++/CLI)</span></span>](/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli)
- [<span data-ttu-id="83f56-193">Dispose Deseni</span><span class="sxs-lookup"><span data-stu-id="83f56-193">Dispose Pattern</span></span>](implementing-dispose.md)
