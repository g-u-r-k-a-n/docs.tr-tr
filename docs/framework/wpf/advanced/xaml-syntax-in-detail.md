---
title: Ayrıntılı XAML Sözdizimi
description: Windows Presentation Foundation XAML sözdizimi öğelerini ve XAML kullanan diğer çerçeveleri anlatmak için kullanılan terimler hakkında bilgi edinin.
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 6ef217a646b14f02c0b812f6316ec84f26d4b660
ms.sourcegitcommit: 87cfeb69226fef01acb17c56c86f978f4f4a13db
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/24/2020
ms.locfileid: "87168340"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="8e33d-103">Ayrıntılı XAML Sözdizimi</span><span class="sxs-lookup"><span data-stu-id="8e33d-103">XAML Syntax In Detail</span></span>
<span data-ttu-id="8e33d-104">Bu konuda, XAML söz dizimi öğelerini tanımlamakta kullanılan terimler tanımlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-104">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="8e33d-105">Bu terimler, hem WPF belgeleri için hem de XAML kullanan diğer çerçeveler veya System. xaml düzeyinde XAML dil desteği tarafından etkinleştirilen temel XAML kavramlarını için bu belgenin geri kalanında sık kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-105">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="8e33d-106">Bu konu, [xaml genel bakış (WPF)](../../../desktop-wpf/fundamentals/xaml.md)konu başlığında sunulan temel terminoloji üzerinde genişletilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-106">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="8e33d-107">XAML dil belirtimi</span><span class="sxs-lookup"><span data-stu-id="8e33d-107">The XAML Language Specification</span></span>  
 <span data-ttu-id="8e33d-108">Burada tanımlanan XAML sözdizimi terimleri XAML dil belirtimi içinde de tanımlanır veya başvurulur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-108">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="8e33d-109">XAML, XML tabanlı bir dildir ve XML yapısal kurallarına göre aşağıdaki veya genişler.</span><span class="sxs-lookup"><span data-stu-id="8e33d-109">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="8e33d-110">Terminolojilerin bazıları, XML dilini veya XML belgesi nesne modelini açıklayarak yaygın olarak kullanılan terimlere göre veya ' dan paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-110">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="8e33d-111">XAML dil belirtimi hakkında daha fazla bilgi için, Microsoft Indirme Merkezi ' nden [ \[ MS-xaml \] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) ' i indirin.</span><span class="sxs-lookup"><span data-stu-id="8e33d-111">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="8e33d-112">XAML ve CLR</span><span class="sxs-lookup"><span data-stu-id="8e33d-112">XAML and CLR</span></span>  
 <span data-ttu-id="8e33d-113">XAML bir biçimlendirme dilidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-113">XAML is a markup language.</span></span> <span data-ttu-id="8e33d-114">Ortak dil çalışma zamanı (CLR), adı tarafından belirtildiği gibi, çalışma zamanı yürütmeyi sunar.</span><span class="sxs-lookup"><span data-stu-id="8e33d-114">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="8e33d-115">XAML, CLR çalışma zamanı tarafından doğrudan tüketilen ortak dillerden birine göre değil.</span><span class="sxs-lookup"><span data-stu-id="8e33d-115">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="8e33d-116">Bunun yerine, XAML 'yi kendi tür sistemini destekleyecek şekilde düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-116">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="8e33d-117">WPF tarafından kullanılan belirli XAML ayrıştırma sistemi CLR ve CLR tür sistemi üzerine kurulmuştur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-117">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="8e33d-118">XAML türleri, WPF için XAML ayrıştırıldığında bir çalışma zamanı gösteriminin örneklemesi için CLR türleriyle eşlenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-118">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="8e33d-119">Bu nedenle, XAML dil belirtiminde denk sözdizimi tartışmaları olmasa dahi, bu belgede söz dizimi tartışması geri kalanı CLR türü sistemine başvurular içerecektir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-119">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="8e33d-120">(XAML dil belirtimi düzeyi için XAML türleri, CLR olmaması gerekmeyen, ancak farklı XAML ayrıştırıcısının oluşturulmasını ve kullanılmasını gerektiren diğer tür sistemleri ile eşleştirilebilir.)</span><span class="sxs-lookup"><span data-stu-id="8e33d-120">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="8e33d-121">Türlerin üyeleri ve sınıf devralma</span><span class="sxs-lookup"><span data-stu-id="8e33d-121">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="8e33d-122">Bir türün XAML üyeleri olarak göründükleri Özellikler ve olaylar [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] genellikle temel türlerden devralınır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-122">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="8e33d-123">Örneğin, şu örneği göz önünde bulundurun: `<Button Background="Blue" .../>` .</span><span class="sxs-lookup"><span data-stu-id="8e33d-123">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="8e33d-124"><xref:System.Windows.Controls.Control.Background%2A> <xref:System.Windows.Controls.Button> Sınıf tanımına, yansıma sonuçlarına veya belgelere bakadıysanız, özelliği sınıfında anında bildirilmemiş bir özellik değildir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-124">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="8e33d-125">Bunun yerine, <xref:System.Windows.Controls.Control.Background%2A> Taban <xref:System.Windows.Controls.Control> sınıftan devralınır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-125">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="8e33d-126">XAML öğelerinin sınıf devralma davranışı, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XML biçimlendirmesinin şema tarafından zorlanan yorumlamasının önemli bir önlamasıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-126">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="8e33d-127">Sınıf devralma karmaşık olabilir, özellikle ara temel sınıflar soyut olduğunda veya arabirimler dahil edildiğinde karmaşık hale gelebilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-127">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="8e33d-128">Bu, XAML öğeleri kümesinin ve izin verilen özniteliklerinin, genellikle DTD veya XSD biçimi gibi XML programlama için kullanılan şema türlerini doğru ve tamamen temsil etmesi zor bir nedenidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-128">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="8e33d-129">Diğer bir nedenden dolayı, XAML dilinin genişletilebilirlik ve tür eşleme özelliklerinin, izin verilen türlerin ve üyelerin herhangi bir sabit gösteriminden daha da karmaşık olmasını sağlamak.</span><span class="sxs-lookup"><span data-stu-id="8e33d-129">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="8e33d-130">Nesne öğesi sözdizimi</span><span class="sxs-lookup"><span data-stu-id="8e33d-130">Object Element Syntax</span></span>  
 <span data-ttu-id="8e33d-131">*Nesne öğesi sözdizimi* , bir XML öğesi BILDIREREK bir clr sınıfı veya yapısını ÖRNEKLEYEN XAML biçimlendirme sözdizimidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-131">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="8e33d-132">Bu söz dizimi, HTML gibi diğer biçimlendirme dillerinin öğe sözdizimine benzer.</span><span class="sxs-lookup"><span data-stu-id="8e33d-132">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="8e33d-133">Nesne öğesi sözdizimi sol açılı köşeli ayraç () ile başlar \< , ardından, örneklendirilmiş sınıf veya yapının tür adı tarafından hemen izlenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-133">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="8e33d-134">Sıfır veya daha fazla boşluk tür adını izleyebilir ve bir veya daha fazla öznitelik, her öznitelik adı = "Value" çiftini ayıran bir veya daha fazla boşluk ile nesne öğesinde de bildirilemez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-134">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="8e33d-135">Son olarak, aşağıdakilerden biri doğru olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="8e33d-135">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="8e33d-136">Öğe ve etiket bir eğik çizgi (/) ile hemen arkasından sağ açılı ayraç (>) ile kapatılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-136">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="8e33d-137">Açma etiketi sağ açılı ayraç (>) ile tamamlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-137">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="8e33d-138">Diğer nesne öğeleri, özellik öğeleri veya iç metin, açma etiketini izleyebilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-138">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="8e33d-139">Burada tam olarak hangi içeriklerin dahil olabileceği, genellikle öğenin nesne modeliyle kısıtlanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-139">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="8e33d-140">Nesne öğesi için eşdeğer kapanış etiketi, doğru iç içe geçme ve diğer açılış ve kapanış etiketi çiftleriyle dengede bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-140">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="8e33d-141">.NET tarafından uygulanan XAML, nesne öğelerini türler, öznitelikler veya olaylar ve XAML ad alanları ile CLR ad alanları ve derleme öğelerine eşleyen bir kurallar kümesine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-141">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="8e33d-142">WPF ve .NET için XAML nesne öğeleri, başvurulan derlemelerde tanımlanan .NET türleriyle eşlenir ve öznitelikler bu türlerin üyeleriyle eşlenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-142">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="8e33d-143">XAML 'de bir CLR türüne başvurduğunuzda, bu türdeki devralınan üyelere de erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-143">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="8e33d-144">Örneğin, aşağıdaki örnek, sınıfının yeni bir örneğini örnekleyen <xref:System.Windows.Controls.Button> ve ayrıca bir <xref:System.Windows.FrameworkElement.Name%2A> özniteliği ve bu öznitelik için bir değer belirten nesne öğesi sözdizimidir:</span><span class="sxs-lookup"><span data-stu-id="8e33d-144">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="8e33d-145">Aşağıdaki örnek, XAML içerik özelliği sözdizimi de içeren nesne öğesi söz dizimine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-145">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="8e33d-146">İçinde yer alan iç metin xaml içerik özelliğini ayarlamak için kullanılacaktır <xref:System.Windows.Controls.TextBox> <xref:System.Windows.Controls.TextBox.Text%2A> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-146">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="8e33d-147">İçerik modelleri</span><span class="sxs-lookup"><span data-stu-id="8e33d-147">Content Models</span></span>  
 <span data-ttu-id="8e33d-148">Bir sınıf, sözdizimi bakımından XAML nesne öğesi olarak kullanımı destekleyebilir, ancak bu öğe, genel içerik modelinin veya öğe ağacının beklenen konumuna yerleştirildiğinde yalnızca bir uygulamada veya sayfada düzgün şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-148">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="8e33d-149">Örneğin, <xref:System.Windows.Controls.MenuItem> genellikle yalnızca gibi türetilmiş bir sınıfın alt öğesi olarak yerleştirilmelidir <xref:System.Windows.Controls.Primitives.MenuBase> <xref:System.Windows.Controls.Menu> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-149">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="8e33d-150">Belirli öğeler için içerik modelleri, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] xaml öğeleri olarak kullanılabilecek denetimler ve diğer sınıflar için sınıf sayfalarında açıklamalarının bir parçası olarak belgelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-150">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="8e33d-151">Nesne öğelerinin özellikleri</span><span class="sxs-lookup"><span data-stu-id="8e33d-151">Properties of Object Elements</span></span>  
 <span data-ttu-id="8e33d-152">XAML 'deki özellikler, çeşitli olası sözdizimleri tarafından ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-152">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="8e33d-153">Belirli bir özellik için hangi sözdizimi kullanılabilecek, ayarladığınız özelliğin temel alınan tür sistemi özelliklerine göre değişiklik gösterecektir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-153">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="8e33d-154">Özelliklerin değerlerini ayarlayarak, nesnelere çalışma zamanı nesne grafiğinde var olan özellikleri veya özellikleri ekleyin.</span><span class="sxs-lookup"><span data-stu-id="8e33d-154">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="8e33d-155">Bir nesne öğesinden oluşturulan nesnenin ilk durumu parametresiz Oluşturucu davranışına göre belirlenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-155">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="8e33d-156">Genellikle, uygulamanız herhangi bir nesne için tamamen varsayılan bir örnek dışında bir şey kullanacaktır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-156">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="8e33d-157">Öznitelik sözdizimi (Özellikler)</span><span class="sxs-lookup"><span data-stu-id="8e33d-157">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="8e33d-158">Öznitelik sözdizimi, varolan bir nesne öğesinde bir özniteliği bildirerek bir özellik için değer ayarlayan XAML biçimlendirme sözdizimidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-158">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="8e33d-159">Öznitelik adı, ilgili nesne öğesini yedekleyen sınıfın özelliğinin CLR üye adı ile aynı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-159">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="8e33d-160">Öznitelik adının ardından bir atama işleci (=) gelir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-160">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="8e33d-161">Öznitelik değeri tırnak içine alınmış bir dize olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-161">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8e33d-162">Bir özniteliğe sabit bir tırnak işareti koymak için alternatif tırnakları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-162">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="8e33d-163">Örneğin, içinde çift tırnak karakteri içeren bir dize bildirmek için tek tırnakları bir yol olarak kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-163">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="8e33d-164">Tek veya çift tırnak işareti kullanıp kullanmayacağınızı, öznitelik değer dizesini açmak ve kapatmak için eşleşen bir çift kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-164">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="8e33d-165">Ayrıca, belirli XAML söz dizimi tarafından uygulanan karakter kısıtlamaları etrafında çalışan kaçış dizileri veya diğer teknikler de mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-165">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="8e33d-166">Bkz. [XML karakter varlıkları ve xaml](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-166">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="8e33d-167">Öznitelik sözdizimi ile ayarlanbilmek için bir özelliğin ortak olması ve yazılabilir olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-167">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="8e33d-168">Yedekleme türü sistemindeki özelliğinin değeri bir değer türü olmalıdır veya ilgili yedekleme türüne erişirken bir XAML işlemcisi tarafından örneklenmiş veya başvurulabilen bir başvuru türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-168">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="8e33d-169">WPF XAML olayları için, öznitelik adı olarak başvurulan olayın ortak olması ve genel bir temsilcisi olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-169">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="8e33d-170">Özellik veya olay, kapsayan nesne öğesi tarafından oluşturulan sınıfın veya yapının bir üyesi olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-170">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="8e33d-171">Öznitelik değerlerini işleme</span><span class="sxs-lookup"><span data-stu-id="8e33d-171">Processing of Attribute Values</span></span>  
 <span data-ttu-id="8e33d-172">Açma ve kapatma tırnak işaretlerinin içinde yer alan dize değeri bir XAML işlemcisi tarafından işlenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-172">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="8e33d-173">Özellikler için, varsayılan işleme davranışı temeldeki CLR özelliğinin türüne göre belirlenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-173">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="8e33d-174">Öznitelik değeri, bu işleme sırası kullanılarak, aşağıdakilerden biri ile doldurulur:</span><span class="sxs-lookup"><span data-stu-id="8e33d-174">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="8e33d-175">XAML işlemcisi bir küme ayracı veya öğesinden türetilen bir nesne öğesi ile karşılaştığında, <xref:System.Windows.Markup.MarkupExtension> başvurulan biçimlendirme uzantısı değeri bir dize olarak işlemek yerine önce değerlendirilir ve biçimlendirme uzantısı tarafından döndürülen nesne değer olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-175">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="8e33d-176">Birçok durumda, bir işaretleme uzantısı tarafından döndürülen nesne varolan bir nesneye ya da çalışma zamanına kadar değerlendirmeyi yapan bir ifadeye veya yeni bir örneklenmiş nesne değil.</span><span class="sxs-lookup"><span data-stu-id="8e33d-176">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="8e33d-177">Özellik öznitelikli ile bildirilirse <xref:System.ComponentModel.TypeConverter> veya özelliğin değer türü öznitelikli ile bildirilirse, <xref:System.ComponentModel.TypeConverter> özniteliğin dize değeri, dönüştürme girişi olarak tür dönüştürücüsüne gönderilir ve dönüştürücü yeni bir nesne örneği döndürür.</span><span class="sxs-lookup"><span data-stu-id="8e33d-177">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="8e33d-178">Hayır ise <xref:System.ComponentModel.TypeConverter> , özellik türüne doğrudan dönüştürme denenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-178">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="8e33d-179">Bu son düzey, XAML dil temel türleri arasındaki ayrıştırıcının yerel değerindeki doğrudan dönüştürmedir veya bir Numaralandırmadaki adlandırılmış sabitlerin adlarını denetler (ayrıştırıcı daha sonra eşleşen değerlere erişir).</span><span class="sxs-lookup"><span data-stu-id="8e33d-179">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="8e33d-180">Sabit Listesi öznitelik değerleri</span><span class="sxs-lookup"><span data-stu-id="8e33d-180">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="8e33d-181">XAML 'deki numaralandırmalar XAML Çözümleyicileri tarafından doğası gereği işlenir ve sabit listesinin adlandırılmış sabitlerinden birinin dize adı belirtilerek bir numaralandırma üyeleri belirtilmelidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-181">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="8e33d-182">Bayrak olmayan numaralandırma değerleri için, yerel davranış bir öznitelik değerinin dizesini işlemek ve sabit listesi değerlerinden birine çözmadır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-182">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="8e33d-183">Sabit listesini biçim *numaralandırmasında*belirtmeyin. *Değer*, kodda yaptığınız gibi.</span><span class="sxs-lookup"><span data-stu-id="8e33d-183">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="8e33d-184">Bunun yerine, yalnızca *değeri*belirtirsiniz ve *sabit listesi* , ayarladığınız özelliğin türü tarafından algılanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-184">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="8e33d-185">*Numaralandırmada*bir özniteliği belirtirseniz. *Değer* formu, doğru çözümlenmeyecektir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-185">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="8e33d-186">Flagwise Numaralandırmalar için davranış yöntemi temel alır <xref:System.Enum.Parse%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-186">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8e33d-187">Her değeri virgülle ayırarak, bir flagwise numaralandırması için birden fazla değer belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-187">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="8e33d-188">Ancak, flagwise olmayan numaralandırma değerlerini birleştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-188">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="8e33d-189">Örneğin, <xref:System.Windows.Trigger> bayrak olmayan bir numaralandırmanın birden çok koşulu üzerinde davranan bir oluşturmak için virgül sözdizimini kullanamazsınız:</span><span class="sxs-lookup"><span data-stu-id="8e33d-189">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="8e33d-190">XAML 'de ayarlanabilir öznitelikleri destekleyen flagwise numaralandırmalar WPF içinde nadir bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-190">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="8e33d-191">Ancak, bu tür bir numaralandırma <xref:System.Windows.Media.StyleSimulations> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-191">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="8e33d-192">Örneğin, sınıf için açıklamalardır belirtilen örneği değiştirmek için virgülle ayrılmış flagwise öznitelik sözdizimini kullanabilirsiniz <xref:System.Windows.Documents.Glyphs> `StyleSimulations = "BoldSimulation"` `StyleSimulations = "BoldSimulation,ItalicSimulation"` .</span><span class="sxs-lookup"><span data-stu-id="8e33d-192">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="8e33d-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>, birden fazla numaralandırma değerinin belirtilebileceği başka bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-193"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="8e33d-194">Ancak, <xref:System.Windows.Input.ModifierKeys> numaralandırma kendi tür dönüştürücüsünü desteklediğinden, bu özellik özel bir durum gibi olur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-194">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="8e33d-195">Değiştiriciler için tür dönüştürücüsü, virgül (,) yerine sınırlayıcı olarak bir artı işareti (+) kullanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-195">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="8e33d-196">Bu dönüştürme, Microsoft Windows programlama 'de "Ctrl + alt" gibi temel bileşimleri temsil eden daha geleneksel sözdizimini destekler.</span><span class="sxs-lookup"><span data-stu-id="8e33d-196">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="8e33d-197">Özellikler ve olay üyesi adı başvuruları</span><span class="sxs-lookup"><span data-stu-id="8e33d-197">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="8e33d-198">Bir öznitelik belirtirken, içeren nesne öğesi için örnekettiğiniz CLR türünün bir üyesi olarak var olan herhangi bir özelliğe veya olaya başvurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-198">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="8e33d-199">Ya da, ekli nesne öğesinden bağımsız olarak iliştirilmiş bir özelliğe veya ekli olaya başvurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-199">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="8e33d-200">(Ekli Özellikler yaklaşan bölümde ele alınmıştır.)</span><span class="sxs-lookup"><span data-stu-id="8e33d-200">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="8e33d-201">Ayrıca, bir *TypeName*kullanarak, varsayılan ad alanı aracılığıyla erişilebilen herhangi bir nesneden herhangi bir olayı da yazabilirsiniz. *olay* kısmen nitelenmiş adı; Bu sözdizimi, işleyicinin alt öğelerinden olay yönlendirmeyi işlemeye yönelik olduğu, ancak üst öğenin üye tablosunda da bu olayı içermediği yönlendirilmiş olaylar için işleyicileri eklemeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="8e33d-201">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="8e33d-202">Bu söz dizimi ekli bir olay sözdizimine benzer, ancak buradaki olay, doğru bir ekli olay değildir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-202">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="8e33d-203">Bunun yerine, nitelikli bir ada sahip bir olaya başvuruyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-203">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="8e33d-204">Daha fazla bilgi için bkz. [yönlendirilmiş olaylara genel bakış](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-204">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="8e33d-205">Bazı senaryolarda, özellik adları bazen öznitelik adı yerine bir özniteliğin değeri olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-205">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="8e33d-206">Bu özellik adı, *OwnerType*biçiminde belirtilen özellik gibi niteleyiciler de içerebilir. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="8e33d-206">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="8e33d-207">Bu senaryo, XAML 'de stil veya şablon yazarken yaygındır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-207">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="8e33d-208">Öznitelik değeri olarak belirtilen özellik adlarına yönelik işleme kuralları farklıdır ve ayarlanan özelliğin türüne veya belirli WPF alt sistemlerinin davranışlarına tabidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-208">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="8e33d-209">Ayrıntılar için bkz. [Stil oluşturma ve şablon](../../../desktop-wpf/fundamentals/styles-templates-overview.md)oluşturma.</span><span class="sxs-lookup"><span data-stu-id="8e33d-209">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="8e33d-210">Özellik adları için başka bir kullanım, bir öznitelik değeri özellik özelliği ilişkisini açıkladığı zaman.</span><span class="sxs-lookup"><span data-stu-id="8e33d-210">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="8e33d-211">Bu özellik veri bağlama ve görsel taslak hedefleri için kullanılır ve <xref:System.Windows.PropertyPath> sınıfı ve tür dönüştürücüsü tarafından etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-211">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="8e33d-212">Arama semantiğinin daha ayrıntılı bir açıklaması için bkz. [PROPERTYPATH XAML sözdizimi](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-212">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="8e33d-213">Özellik öğesi sözdizimi</span><span class="sxs-lookup"><span data-stu-id="8e33d-213">Property Element Syntax</span></span>  
 <span data-ttu-id="8e33d-214">*Özellik öğesi sözdizimi* , öğeleri IÇIN temel XML sözdizimi kurallarından biraz ayrılan bir sözdizimidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-214">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="8e33d-215">XML 'de, bir özniteliğin değeri, tek bir dize kodlama biçiminin kullanıldığı tek bir çeşitle bir dizedir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-215">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="8e33d-216">XAML 'de, diğer nesne öğelerini bir özelliğin değeri olacak şekilde atayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-216">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="8e33d-217">Bu yetenek, özellik öğesi sözdizimi tarafından etkinleştirilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-217">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="8e33d-218">Özelliği, öğe etiketi içindeki bir öznitelik olarak belirtilen özellik yerine, *elementTypeName*içindeki bir açýlýþ element etiketi kullanılarak belirtilir. *PropertyName* formu, özelliğin değeri içinde belirtilir ve sonra Property öğesi kapalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-218">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="8e33d-219">Özellikle, söz dizimi sol açılı köşeli ayraç () ile başlar \<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-219">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="8e33d-220">Öznitelik sözdiziminde olduğu gibi, bu özellik belirtilen türdeki ortak Üyeler içinde bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="8e33d-221">Özelliğe atanacak değer, özellik öğesinin içinde yer alır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="8e33d-222">Genellikle değer bir veya daha fazla nesne öğesi olarak verilir, çünkü nesneleri değer olarak belirtmek, özellik öğesi sözdiziminin ele hazırlandığı senaryodur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="8e33d-223">Son olarak, aynı *elementTypeName*öğesini belirten eşdeğer bir kapanış etiketi. *PropertyName* birleşiminin, doğru iç içe geçme ve diğer öğe etiketleriyle dengelenmesi sağlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="8e33d-224">Örneğin, aşağıdaki, özelliği için özellik öğesi söz dizimine sahiptir <xref:System.Windows.FrameworkElement.ContextMenu%2A> <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="8e33d-225">Bir özellik öğesi içindeki değeri iç metin olarak da verilebilir, çünkü belirtilen özellik türünün, veya gibi bir temel değer türü olduğu durumlarda, <xref:System.String> veya bir adın belirtildiği bir sabit listesi.</span><span class="sxs-lookup"><span data-stu-id="8e33d-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="8e33d-226">Bu iki kullanım çok nadir bir durumdur, çünkü bu durumların her biri daha basit bir öznitelik sözdizimi de kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="8e33d-227">Bir dize ile bir özellik öğesinin doldurulmasıyla ilgili bir senaryo XAML içerik özelliği olmayan, ancak UI metninin temsili için hala kullanılan özellikler içindir ve bu kullanıcı arabirimi metninde satır akışları gibi belirli boşluk öğelerinin görünmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="8e33d-228">Öznitelik sözdizimi, satır beslemelerini koruyamaz, ancak özellik öğesi söz dizimi, önemli beyaz alan koruması etkin olduğu sürece (Ayrıntılar için bkz. [xaml 'de beyaz boşluk işleme](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span><span class="sxs-lookup"><span data-stu-id="8e33d-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="8e33d-229">Başka bir senaryo ise, [X:Uid yönergesinin](../../../desktop-wpf/xaml-services/xuid-directive.md) Özellik öğesine uygulanabilmesi ve bu sayede değeri WPF çıkış BAML 'de veya başka teknikler için yerelleştirilmesi gereken bir değer olarak işaretlemenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="8e33d-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="8e33d-230">Bir özellik öğesi WPF mantıksal ağacında temsil edilmez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="8e33d-231">Özellik öğesi, bir özelliği ayarlamaya yönelik yalnızca belirli bir sözdizimidir ve bir örnek veya nesne çalıştıran bir öğe değildir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="8e33d-232">(Mantıksal ağaç kavramıyla ilgili ayrıntılar için bkz. [WPF 'de ağaçlar](trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="8e33d-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="8e33d-233">Hem öznitelik hem de Özellik öğesi sözdiziminin desteklendiği özellikler için, iki sözdizimi genellikle aynı sonuca sahiptir, ancak beyaz boşluk işleme gibi alt tlelikler sözdizimleri arasında biraz farklılık gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="8e33d-234">Koleksiyon sözdizimi</span><span class="sxs-lookup"><span data-stu-id="8e33d-234">Collection Syntax</span></span>  
 <span data-ttu-id="8e33d-235">XAML belirtimi, XAML işlemci uygulamalarının değer türünün bir koleksiyon olduğu özellikleri belirlemesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="8e33d-236">.NET 'teki Genel XAML işlemci uygulamaları, yönetilen kodu ve CLR 'yi temel alır ve koleksiyon türlerini aşağıdakilerden biri aracılığıyla tanımlar:</span><span class="sxs-lookup"><span data-stu-id="8e33d-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="8e33d-237">Tür uygular <xref:System.Collections.IList> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="8e33d-238">Tür uygular <xref:System.Collections.IDictionary> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="8e33d-239">Tür türetiliyor <xref:System.Array> (XAML 'deki diziler hakkında daha fazla bilgi için bkz. [X:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="8e33d-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="8e33d-240">Bir özelliğin türü bir koleksiyon ise, gösterilen koleksiyon türünün bir nesne öğesi olarak İşaretlemede belirtilmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="8e33d-241">Bunun yerine, koleksiyonda öğeler haline gelmesi amaçlanan öğeler, Property öğesinin bir veya daha fazla alt öğesi olarak belirtilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="8e33d-242">Bu tür öğeler, yükleme sırasında bir nesne olarak değerlendirilir ve `Add` Kapsanan koleksiyonun yöntemi çağırarak koleksiyona eklenir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="8e33d-243">Örneğin, <xref:System.Windows.Style.Triggers%2A> öğesinin özelliği, <xref:System.Windows.Style> uygulayan özel koleksiyon türünü alır <xref:System.Windows.TriggerCollection> <xref:System.Collections.IList> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="8e33d-244">İşaretlemede bir nesne öğesi örneği oluşturmak gerekli değildir <xref:System.Windows.TriggerCollection> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="8e33d-245">Bunun yerine, bir veya daha fazla öğeyi bir veya daha fazla <xref:System.Windows.Trigger> öğe olarak belirtirsiniz `Style.Triggers` , burada <xref:System.Windows.Trigger> (veya türetilmiş bir sınıf) türü kesin belirlenmiş ve örtük olarak öğe türü olarak beklenen türdür <xref:System.Windows.TriggerCollection> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="8e33d-246">Bir özellik, bu konunun sonraki bölümünde ele alınan bu tür ve türetilmiş türler için hem koleksiyon türü hem de XAML içerik özelliği olabilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="8e33d-247">Örtük bir koleksiyon öğesi, İşaretlemede bir öğe olarak görünmese de, mantıksal ağaç gösteriminde bir üye oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="8e33d-248">Genellikle üst türün Oluşturucusu, özelliklerinden biri olan koleksiyon için örnek oluşturmayı gerçekleştirir ve başlangıçta boş koleksiyon, nesne ağacının bir parçası haline gelir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="8e33d-249">Genel liste ve sözlük arabirimleri ( <xref:System.Collections.Generic.IList%601> ve <xref:System.Collections.Generic.IDictionary%602> ), koleksiyon algılama için desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="8e33d-250">Ancak doğrudan uyguladığından <xref:System.Collections.Generic.List%601> <xref:System.Collections.IList> veya <xref:System.Collections.Generic.Dictionary%602> bir temel sınıf olarak, doğrudan uyguladığı için sınıfını temel sınıf olarak kullanabilirsiniz <xref:System.Collections.IDictionary> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="8e33d-251">Koleksiyon türleri için .NET başvuru sayfalarında, bir koleksiyon için nesne öğesinin bilinçli atlanmasına sahip bu sözdizimi zaman zaman örtük koleksiyon sözdizimi olarak XAML sözdizimi bölümlerinde belirtilmiştir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="8e33d-252">Kök öğe hariç, başka bir öğenin alt öğesi olarak iç içe yerleştirilmiş bir XAML dosyasındaki her nesne öğesi gerçekten aşağıdaki durumlardan biri veya her ikisi olan bir öğedir: üst öğesinin örtük bir koleksiyon özelliğinin üyesi veya üst öğe için XAML içerik özelliğinin değerini belirten bir öğe (XAML içerik özellikleri yaklaşan bir bölümde ele alınacaktır).</span><span class="sxs-lookup"><span data-stu-id="8e33d-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="8e33d-253">Diğer bir deyişle, bir biçimlendirme sayfasındaki üst öğe ve alt öğe öğelerinin ilişkisi aslında tek bir nesnedir ve kök altındaki her nesne öğesi, üst öğenin bir özellik değerini sağlayan tek bir örnek ya da üst öğenin koleksiyon türü özellik değeri olan bir koleksiyondaki öğelerden biridir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="8e33d-254">Bu tek köklü kavram XML ile ortaktır ve, gibi XAML yükleyen API 'lerin davranışında genellikle yeniden zorlanır <xref:System.Windows.Markup.XamlReader.Load%2A> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="8e33d-255">Aşağıdaki örnek, açıkça belirtilen bir koleksiyonun () nesne öğesi ile bir sözdizimidir <xref:System.Windows.Media.GradientStopCollection> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="8e33d-256">Koleksiyonu açıkça bildirmek için her zaman mümkün olmadığına unutmayın.</span><span class="sxs-lookup"><span data-stu-id="8e33d-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="8e33d-257">Örneğin, <xref:System.Windows.TriggerCollection> daha önce gösterilen örnekte açıkça bildirilmesini denemek <xref:System.Windows.Style.Triggers%2A> başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="8e33d-258">Koleksiyonu açıkça bildirmek için koleksiyon sınıfının parametresiz bir oluşturucuyu desteklemesi ve <xref:System.Windows.TriggerCollection> parametresiz oluşturucusu olmaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="8e33d-259">XAML Içerik özellikleri</span><span class="sxs-lookup"><span data-stu-id="8e33d-259">XAML Content Properties</span></span>  
 <span data-ttu-id="8e33d-260">XAML içerik sözdizimi, yalnızca <xref:System.Windows.Markup.ContentPropertyAttribute> kendi sınıf bildiriminin parçası olarak belirten sınıflarda etkinleştirilen bir sözdizimidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="8e33d-261">, <xref:System.Windows.Markup.ContentPropertyAttribute> Bu öğe türünün (türetilmiş sınıflar dahil) içerik özelliği olan özellik adına başvurur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="8e33d-262">Bir XAML işlemcisi tarafından işlendiğinde, nesne öğesinin açılış ve kapanış etiketleri arasında bulunan herhangi bir alt öğe veya iç metin, bu nesne için XAML içerik özelliğinin değeri olacak şekilde atanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="8e33d-263">İçerik özelliği için açık özellik öğeleri belirtmenize izin verilir, ancak bu kullanım genellikle .NET başvurusunun XAML söz dizimi bölümlerinde gösterilmez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="8e33d-264">Açık/ayrıntılı teknikte, biçimlendirme netliği için zaman zaman değeri veya biçimlendirme stili olması gerekir, ancak genellikle bir içerik özelliğinin amacı, üst-alt öğe ile ilgili olan öğelerin doğrudan iç içe yerleştirilebilmesi için biçimlendirmeyi kolaylaştırmaktır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="8e33d-265">Bir öğedeki diğer özellikler için özellik öğesi etiketleri, katı bir XAML dil tanımı başına "içerik" olarak atanmaz; daha önce XAML ayrıştırıcısının işleme sırasında işlenir ve "içerik" olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="8e33d-266">XAML Içerik özelliği değerleri bitişik olmalıdır</span><span class="sxs-lookup"><span data-stu-id="8e33d-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="8e33d-267">XAML içerik özelliğinin değeri, nesne öğesindeki diğer herhangi bir özellik öğesinden tamamen önce veya tamamen bir değere verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="8e33d-268">Bu, XAML içerik özelliği değerinin bir dize olarak mı yoksa bir veya daha fazla nesne olarak mı belirtilmeliyse geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="8e33d-269">Örneğin, aşağıdaki biçimlendirme ayrıştırılmadı:</span><span class="sxs-lookup"><span data-stu-id="8e33d-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="8e33d-270">Bu geçersizdir çünkü bu sözdizimi, içerik özelliği için özellik öğesi söz dizimi kullanılarak açık hale getirilmiş olduğundan, içerik özelliği iki kez ayarlanabilir:</span><span class="sxs-lookup"><span data-stu-id="8e33d-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="8e33d-271">Benzer şekilde geçersiz bir örnek, içerik özelliğinin bir koleksiyon olması ve alt öğelerin özellik öğeleriyle birlikte nasıl karışılyadır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="8e33d-272">İçerik özellikleri ve koleksiyon sözdizimi birleştirildi</span><span class="sxs-lookup"><span data-stu-id="8e33d-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="8e33d-273">İçerik olarak birden fazla nesne öğesini kabul etmek için, içerik özelliğinin türü özel olarak bir koleksiyon türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="8e33d-274">Koleksiyon türleri için özellik öğesi söz dizimine benzer şekilde, bir XAML işlemcisi koleksiyon türleri olan türleri tanımmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="8e33d-275">Bir öğenin XAML içerik özelliği varsa ve XAML içerik özelliğinin türü bir koleksiyon ise, kapsanan koleksiyon türünün bir nesne öğesi olarak biçimlendirmesinde belirtilmesi gerekmez ve XAML içerik özelliğinin bir özellik öğesi olarak belirtilmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="8e33d-276">Bu nedenle, biçimlendirmede görünen içerik modeli artık içerik olarak atanmış birden fazla alt öğe içerebilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="8e33d-277">Aşağıdaki, türetilmiş bir sınıfın içerik sözdizimidir <xref:System.Windows.Controls.Panel> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="8e33d-278">Tüm <xref:System.Windows.Controls.Panel> türetilmiş sınıflar <xref:System.Windows.Controls.Panel.Children%2A> , türünde bir değer gerektiren xaml içerik özelliğini sağlar <xref:System.Windows.Controls.UIElementCollection> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="8e33d-279">Biçimlendirme içinde öğesinin için özellik öğesi ne <xref:System.Windows.Controls.Panel.Children%2A> de öğesi için gerekli olduğunu unutmayın <xref:System.Windows.Controls.UIElementCollection> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="8e33d-280">Bu, XAML 'in bir tasarım özelliğidir, bu sayede [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] , bir, ' ı tanımlayan bir iç içe yerleştirilmiş öğelerin, özellik öğesi etiketleri veya koleksiyon nesneleri araya girmeden hemen üst-alt öğe ilişkilerine sahip bir ağaç olarak temsil edildiği daha ıntuıcanlı.</span><span class="sxs-lookup"><span data-stu-id="8e33d-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="8e33d-281">Aslında, <xref:System.Windows.Controls.UIElementCollection> tasarıma göre bir nesne öğesi olarak biçimlendirme içinde açıkça belirtilemez.</span><span class="sxs-lookup"><span data-stu-id="8e33d-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="8e33d-282">Yalnızca amaçlanan kullanım örtük bir koleksiyon olduğundan, <xref:System.Windows.Controls.UIElementCollection> Ortak parametresiz bir Oluşturucu sunmaz ve bu nedenle bir nesne öğesi olarak başlatılamaz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="8e33d-283">Içerik özelliği ile nesne içindeki özellik öğelerini ve nesne öğelerini karıştırma</span><span class="sxs-lookup"><span data-stu-id="8e33d-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="8e33d-284">XAML belirtimi, bir XAML işlemcisinin bir nesne öğesi içindeki XAML içerik özelliğini doldurmakta kullanılan nesne öğelerinin bitişik olması ve karışık olmaması gerektiğini bildirir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="8e33d-285">Özellik öğelerini ve içeriği karıştırmaya yönelik bu kısıtlama [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML işlemcileri tarafından zorlanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="8e33d-286">Bir nesne öğesi içindeki ilk anında biçimlendirme olarak bir alt nesne öğesi olabilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="8e33d-287">Daha sonra özellik öğeleri ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-287">Then you can introduce property elements.</span></span> <span data-ttu-id="8e33d-288">Ya da bir veya daha fazla özellik öğesi, içerik ve daha fazla özellik öğesi de belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="8e33d-289">Ancak, bir özellik öğesi içeriğe ulaştıktan sonra, başka bir içerik getiremezsiniz, ancak özellik öğeleri ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="8e33d-290">Bu içerik/özellik öğesi sırası gereksinimi içerik olarak kullanılan iç metin için uygulanabilir değil.</span><span class="sxs-lookup"><span data-stu-id="8e33d-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="8e33d-291">Ancak, iç metni sürekli tutmak için iyi bir biçimlendirme stilidir, çünkü özellik öğeleri iç metinle birlikte ayarlandığında, biçimlendirme içinde görsel olarak algılanmaları zor olur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="8e33d-292">XAML Ad Uzayları</span><span class="sxs-lookup"><span data-stu-id="8e33d-292">XAML Namespaces</span></span>  
 <span data-ttu-id="8e33d-293">Önceki söz dizimi örneklerinden hiçbiri varsayılan XAML ad alanı dışında bir XAML ad alanı belirtbelirtti.</span><span class="sxs-lookup"><span data-stu-id="8e33d-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="8e33d-294">Tipik [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uygulamalarda, varsayılan xaml ad uzayı [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ad alanı olarak belirtilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="8e33d-295">Varsayılan XAML ad alanı dışında XAML ad alanları belirtebilir ve yine de benzer sözdizimini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="8e33d-296">Ancak, varsayılan XAML ad alanı içinde erişilebilir olmayan bir sınıfın adlandırıldığını her yerde, bu sınıf adı, karşılık gelen CLR ad alanına eşlenmiş şekilde XAML ad alanının öneki olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="8e33d-297">Örneğin, `<custom:Example/>` bir sınıf örneğinin örneğini oluşturmak için kullanılan nesne öğesi sözdizimidir `Example` . burada, bu sınıfı içeren clr ad alanı (ve muhtemelen Yedekleme türlerini içeren dış derleme bilgileri) `custom` ön eke eşleniyordu.</span><span class="sxs-lookup"><span data-stu-id="8e33d-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="8e33d-298">XAML ad alanları hakkında daha fazla bilgi için bkz. [WPF XAML Için xaml ad alanları ve ad alanı eşlemesi](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="8e33d-299">İşaretleme Uzantıları</span><span class="sxs-lookup"><span data-stu-id="8e33d-299">Markup Extensions</span></span>  
 <span data-ttu-id="8e33d-300">XAML, dize özniteliği değerlerinin veya nesne öğelerinin normal XAML işlemci işlemesini sağlayan bir işaretleme uzantısı programlama varlığı tanımlar ve işlemeyi bir yedekleme sınıfına erteler.</span><span class="sxs-lookup"><span data-stu-id="8e33d-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="8e33d-301">Öznitelik sözdizimi kullanılırken bir XAML işlemcisine bir biçimlendirme uzantısı tanımlayan karakter, bir kapanış küme ayracı ({) ve ardından bir kapatma küme ayracı (}) dışında bir karakter.</span><span class="sxs-lookup"><span data-stu-id="8e33d-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="8e33d-302">Açma küme ayracından sonraki ilk dize, söz konusu alt dize doğru sınıf adının bir parçasıysa, başvurunun "Extension" alt dizesini ayırabileceği belirli uzantı davranışını sağlayan sınıfa başvurmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="8e33d-303">Bundan sonra, tek bir boşluk görünebilir ve sonra, kapatma büyük ayraçına ulaşana kadar, her bir sonraki karakter uzantı uygulamasıyla giriş olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="8e33d-304">.NET XAML uygulama, <xref:System.Windows.Markup.MarkupExtension> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] diğer çerçeveler veya teknolojiler tarafından desteklenen tüm biçimlendirme uzantılarının temeli olarak soyut sınıfı kullanır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="8e33d-305">Özellikle uygulanan biçimlendirme uzantıları, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] genellikle diğer varolan nesnelere başvuru yapmak için veya çalışma zamanında değerlendirilecek nesnelere ertelenmiş başvurular yapmak üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="8e33d-306">Örneğin, `{Binding}` belirli bir özelliğin normalde aldığı değerin yerine işaretleme uzantısı belirtilerek basit BIR WPF veri bağlaması gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="8e33d-307">WPF biçimlendirme uzantılarının birçoğu, bir öznitelik sözdiziminin mümkün olmaması için öznitelik sözdizimini etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="8e33d-308">Örneğin, bir <xref:System.Windows.Style> nesnesi, iç içe geçmiş nesne ve özellik serisini içeren görece karmaşık bir türdür.</span><span class="sxs-lookup"><span data-stu-id="8e33d-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="8e33d-309">WPF 'deki stiller genellikle bir kaynak olarak bir kaynak olarak tanımlanır <xref:System.Windows.ResourceDictionary> ve sonra bir kaynak isteyen ıkı WPF biçimlendirme uzantılarından biri ile başvurulur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="8e33d-310">Biçimlendirme uzantısı, özellik değerinin değerlendirmesini bir kaynak aramasına erteler ve <xref:System.Windows.FrameworkElement.Style%2A> <xref:System.Windows.Style> Aşağıdaki örnekte gösterildiği gibi, öznitelik sözdiziminde türü alan özellik değerini sağlar:</span><span class="sxs-lookup"><span data-stu-id="8e33d-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="8e33d-311">Burada, `StaticResource` <xref:System.Windows.StaticResourceExtension> Biçimlendirme Uzantısı uygulamasını sağlayan sınıfı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="8e33d-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="8e33d-312">Sonraki dize, `MyStyle` <xref:System.Windows.StaticResourceExtension> uzantı dizesinden alınan parametrenin istenen isteği bildirdiği varsayılan olmayan oluşturucunun girişi olarak kullanılır <xref:System.Windows.ResourceKey> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="8e33d-313">`MyStyle`kaynak olarak tanımlanmış bir öğesinin [X:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) değeri olması beklenir <xref:System.Windows.Style> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="8e33d-314">[StaticResource biçimlendirme uzantısı](staticresource-markup-extension.md) kullanımı, kaynağın <xref:System.Windows.Style> özellik değerini yükleme zamanında statik kaynak arama mantığı aracılığıyla sağlamak için kullanılmasını ister.</span><span class="sxs-lookup"><span data-stu-id="8e33d-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="8e33d-315">Biçimlendirme uzantıları hakkında daha fazla bilgi için bkz. [Biçimlendirme uzantıları ve WPF XAML](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="8e33d-316">Biçimlendirme uzantıları ve genel .NET XAML uygulamasında etkin olan diğer XAML programlama özellikleri başvurusu için bkz. [xaml ad alanı (x:) Dil özellikleri](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="8e33d-317">WPF 'e özgü biçimlendirme uzantıları için bkz. [WPF XAML uzantıları](wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="8e33d-318">İliştirilmiş Özellikler</span><span class="sxs-lookup"><span data-stu-id="8e33d-318">Attached Properties</span></span>  
 <span data-ttu-id="8e33d-319">İliştirilmiş özellikler XAML 'de sunulan ve belirli bir türe sahip olan, ancak herhangi bir öğe üzerinde öznitelikler veya özellik öğeleri olarak ayarlanan bir programlama kavramıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="8e33d-320">İliştirilmiş özelliklerin için tasarlanan birincil senaryo, bir biçimlendirme yapısındaki alt öğelerin, tüm öğelerde yaygın olarak paylaşılan bir nesne modeli gerekmeden bilgileri bir üst öğeye bildirmektir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="8e33d-321">Buna karşılık, ekli özellikler üst öğeler tarafından, bilgileri alt öğelere raporlamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="8e33d-322">Ekli özelliklerin amacı ve kendi ekli özelliklerinizi oluşturma hakkında daha fazla bilgi için bkz. [ekli özelliklere genel bakış](attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="8e33d-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="8e33d-323">İliştirilmiş özellikler, superficially benzer özellik öğesi sözdizimine sahip bir sözdizimi kullanır, bu da bir *TypeName*de belirtebilirsiniz. *PropertyName* birleşimi.</span><span class="sxs-lookup"><span data-stu-id="8e33d-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="8e33d-324">İki önemli fark vardır:</span><span class="sxs-lookup"><span data-stu-id="8e33d-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="8e33d-325">*TypeName*kullanabilirsiniz. öznitelik söz dizimi aracılığıyla iliştirilmiş bir özelliği ayarlarken bile *PropertyName* birleşimi.</span><span class="sxs-lookup"><span data-stu-id="8e33d-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="8e33d-326">İliştirilmiş özellikler, özellik adının öznitelik sözdiziminde bir gereksinim olması gereken tek durumdur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="8e33d-327">İliştirilmiş özellikler için özellik öğesi sözdizimini de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="8e33d-328">Ancak, tipik özellik öğesi söz dizimi için belirttiğiniz *TypeName* , Property öğesini içeren Object öğesidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="8e33d-329">Ekli bir özelliğe başvuruyorsanız *TypeName* , içerilen nesne öğesi değil, ekli özelliği tanımlayan sınıftır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="8e33d-330">İliştirilmiş Olaylar</span><span class="sxs-lookup"><span data-stu-id="8e33d-330">Attached Events</span></span>  
 <span data-ttu-id="8e33d-331">Ekli olaylar XAML 'de sunulan ve olayların belirli bir tür tarafından tanımlanbildiği, ancak işleyicilerin herhangi bir nesne öğesine eklenmiş olabileceği başka bir programlama kavramıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="8e33d-332">WOF uygulamasında, genellikle ekli olayı tanımlayan tür bir hizmeti tanımlayan statik bir türdür ve bazen bu ekli olaylar, hizmeti kullanıma sunan türlerde bir yönlendirilmiş olay diğer adı tarafından gösterilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="8e33d-333">Ekli olaylara yönelik işleyiciler öznitelik sözdizimi aracılığıyla belirtilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="8e33d-334">Ekli olaylarda olduğu gibi, öznitelik sözdizimi bir *TypeName*'e izin vermek için eklenmiş olaylar için genişletilir. *EventName* kullanımı, *TypeName* , `Add` `Remove` eklenen olay altyapısı için ve olay işleyicisi erişimcileri sağlayan sınıftır ve bu da olay adıdır. *eventName*</span><span class="sxs-lookup"><span data-stu-id="8e33d-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="8e33d-335">XAML kök öğesinin anatomumu</span><span class="sxs-lookup"><span data-stu-id="8e33d-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="8e33d-336">Aşağıdaki tabloda, bir kök öğenin belirli özniteliklerinin gösterildiği tipik bir XAML kök öğe gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="8e33d-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="8e33d-337">Kök öğenin nesne öğesi açılıyor</span><span class="sxs-lookup"><span data-stu-id="8e33d-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="8e33d-338">Default ( [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ) xaml ad alanı</span><span class="sxs-lookup"><span data-stu-id="8e33d-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="8e33d-339">XAML Language XAML ad alanı</span><span class="sxs-lookup"><span data-stu-id="8e33d-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="8e33d-340">Biçimlendirmeyi kısmi sınıf için tanımlanan herhangi bir koda bağlayan kısmi sınıf bildirimi</span><span class="sxs-lookup"><span data-stu-id="8e33d-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="8e33d-341">Kök için nesne öğesi sonu.</span><span class="sxs-lookup"><span data-stu-id="8e33d-341">End of object element for the root.</span></span> <span data-ttu-id="8e33d-342">Öğe, alt öğeler içerdiğinden henüz kapatılmadı</span><span class="sxs-lookup"><span data-stu-id="8e33d-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="8e33d-343">İsteğe bağlı ve önerilmeyen XAML kullanımları</span><span class="sxs-lookup"><span data-stu-id="8e33d-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="8e33d-344">Aşağıdaki bölümlerde, xaml işlemciler tarafından Teknik olarak desteklenen XAML kullanımları açıklanır, ancak XAML kaynakları içeren uygulamalar geliştirirken, daha fazla ayrıntı veya diğer Aesthetic Characteristics sorunları yaşabilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="8e33d-345">İsteğe bağlı özellik öğesi kullanımları</span><span class="sxs-lookup"><span data-stu-id="8e33d-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="8e33d-346">İsteğe bağlı özellik öğesi kullanımları, XAML işlemcisinin örtük olarak niteledüğü öğe içeriği özelliklerinin açıkça yazılmasını içerir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="8e33d-347">Örneğin, bir, içeriğini bildirdiğinizde, bir <xref:System.Windows.Controls.Menu> <xref:System.Windows.Controls.ItemsControl.Items%2A> <xref:System.Windows.Controls.Menu> özellik öğesi etiketi olarak koleksiyonu açıkça tanımlamayı `<Menu.Items>` ve ' <xref:System.Windows.Controls.MenuItem> `<Menu.Items>` nin tüm alt öğelerinin <xref:System.Windows.Controls.Menu> BIR, <xref:System.Windows.Controls.MenuItem> ve koleksiyonuna yerleştirilmesi gereken örtük xaml işlemci davranışını kullanmak yerine içine yerleştirebilirsiniz <xref:System.Windows.Controls.ItemsControl.Items%2A> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="8e33d-348">Bazen isteğe bağlı kullanımlar, biçimlendirme içinde temsil edildiği şekilde nesne yapısını görsel açıdan açıklığa kavuşturmanıza yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="8e33d-349">Ya da bazen bir açık özellik öğesi kullanımı, bir öznitelik değeri içinde iç içe geçmiş biçimlendirme uzantıları gibi teknik olarak işlev gösteren ancak görsel açıdan karmaşık olan işaretlemeleri önleyebilir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="8e33d-350">Tam typeName. memberName nitelenmiş öznitelikler</span><span class="sxs-lookup"><span data-stu-id="8e33d-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="8e33d-351">*TypeName*. bir öznitelik için *ÜyeForm* aslında yalnızca yönlendirilmiş olay durumundan daha fazla evrensel olarak çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="8e33d-352">Ancak, formun gereksiz olduğu ve yalnızca biçimlendirme stili ve okunabilirlik nedenleriyle bu durumda kaçınmalısınız.</span><span class="sxs-lookup"><span data-stu-id="8e33d-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="8e33d-353">Aşağıdaki örnekte, özniteliğe yapılan üç başvuru <xref:System.Windows.Controls.Control.Background%2A> tamamen eşdeğerdir:</span><span class="sxs-lookup"><span data-stu-id="8e33d-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="8e33d-354">`Button.Background`, üzerinde bu özellik için tam arama <xref:System.Windows.Controls.Button> başarılı ( <xref:System.Windows.Controls.Control.Background%2A> denetimden devralınmış) ve <xref:System.Windows.Controls.Button> nesne öğesinin sınıfı ya da bir temel sınıf olduğu için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="8e33d-355">`Control.Background`, <xref:System.Windows.Controls.Control> sınıfı aslında tanımladığından <xref:System.Windows.Controls.Control.Background%2A> ve <xref:System.Windows.Controls.Control> bir temel sınıf olduğundan, geçerlidir <xref:System.Windows.Controls.Button> .</span><span class="sxs-lookup"><span data-stu-id="8e33d-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="8e33d-356">Ancak, aşağıdaki *TypeName*. *MemberName* form örneği çalışmıyor ve bu nedenle açıklama gösteriliyor:</span><span class="sxs-lookup"><span data-stu-id="8e33d-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="8e33d-357"><xref:System.Windows.Controls.Label>, başka bir türetilmiş sınıftır <xref:System.Windows.Controls.Control> ve `Label.Background` bir <xref:System.Windows.Controls.Label> nesne öğesi içinde belirttiyseniz, bu kullanım çalıştık.</span><span class="sxs-lookup"><span data-stu-id="8e33d-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="8e33d-358">Ancak, <xref:System.Windows.Controls.Label> sınıfı veya temel sınıfı olmadığından <xref:System.Windows.Controls.Button> , belirtilen xaml işlemci davranışı daha sonra `Label.Background` iliştirilmiş bir özellik olarak işlenecek.</span><span class="sxs-lookup"><span data-stu-id="8e33d-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="8e33d-359">`Label.Background`kullanılabilir bir iliştirilmiş özellik değildir ve bu kullanım başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="8e33d-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="8e33d-360">baseTypeName. memberName özellik öğeleri</span><span class="sxs-lookup"><span data-stu-id="8e33d-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="8e33d-361">*TypeName*öğesine benzer bir şekilde. *MemberName* formu, *temel bir typeName*olan öznitelik sözdizimi için kullanılır. *MemberName* sözdizimi Özellik öğesi sözdizimi için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="8e33d-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="8e33d-362">Örneğin, aşağıdaki sözdizimi işe yarar:</span><span class="sxs-lookup"><span data-stu-id="8e33d-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="8e33d-363">Burada Property öğesi `Control.Background` içinde içerilmiş olsa da, özelliği öğesi olarak verilmıştı `Button` .</span><span class="sxs-lookup"><span data-stu-id="8e33d-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="8e33d-364">Yalnızca *TypeName*gibi. öznitelikler için *ÜyeForm* , *BaseTypeName*. *MemberName* , biçimlendirmede zayıf bir stil ve bundan kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8e33d-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8e33d-365">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="8e33d-365">See also</span></span>

- [<span data-ttu-id="8e33d-366">XAML'ye Genel Bakış (WPF)</span><span class="sxs-lookup"><span data-stu-id="8e33d-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="8e33d-367">XAML Ad Alanı (x:) Dil Özellikleri</span><span class="sxs-lookup"><span data-stu-id="8e33d-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="8e33d-368">WPF XAML Uzantıları</span><span class="sxs-lookup"><span data-stu-id="8e33d-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="8e33d-369">Bağımlılık Özelliklerine Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="8e33d-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="8e33d-370">TypeConverters ve XAML</span><span class="sxs-lookup"><span data-stu-id="8e33d-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="8e33d-371">WPF için XAML ve Özel Sınıflar</span><span class="sxs-lookup"><span data-stu-id="8e33d-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
