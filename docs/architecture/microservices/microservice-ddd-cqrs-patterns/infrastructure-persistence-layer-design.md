---
title: Altyapı kalıcılık katmanını tasarlama
description: .NET Microservices Mimari Containerized .NET Uygulamaları için | Altyapı kalıcılık katmanının tasarımındaki depo deseni keşfedin.
ms.date: 10/08/2018
ms.openlocfilehash: e10c8c1569089d5c8274df655ad7a12f2ebb7c22
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "78846815"
---
# <a name="design-the-infrastructure-persistence-layer"></a><span data-ttu-id="b4e41-103">Altyapı kalıcılık katmanını tasarlama</span><span class="sxs-lookup"><span data-stu-id="b4e41-103">Design the infrastructure persistence layer</span></span>

<span data-ttu-id="b4e41-104">Veri kalıcılığı bileşenleri, bir microservice(microservice veritabanı) sınırları içinde barındırılan verilere erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="b4e41-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="b4e41-105">Bunlar, özel Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> nesneleri gibi depolar ve Çalışma Birimi sınıfları gibi [bileşenlerin](https://martinfowler.com/eaaCatalog/unitOfWork.html) gerçek uygulamasını içerir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span> <span data-ttu-id="b4e41-106">EF DbContext, Depo ve Çalışma Birimi kalıplarını her ikisini de uygular.</span><span class="sxs-lookup"><span data-stu-id="b4e41-106">EF DbContext implements both, the Repository and the Unit of Work patterns.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="b4e41-107">Depo deseni</span><span class="sxs-lookup"><span data-stu-id="b4e41-107">The Repository pattern</span></span>

<span data-ttu-id="b4e41-108">Depolar, veri kaynaklarına erişmek için gereken mantığı kapsülleyen sınıflar veya bileşenlerdir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="b4e41-109">Ortak veri erişim işlevselliğini merkezileştirerek daha iyi sürdürülebilirlik sağlar ve etki alanı modeli katmanından veritabanlarına erişmek için kullanılan altyapı veya teknolojiyi ayrışturarak.</span><span class="sxs-lookup"><span data-stu-id="b4e41-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="b4e41-110">Varlık Çerçevesi gibi bir Nesne İlişkisel Haritalayıcı (ORM) kullanıyorsanız, LINQ ve güçlü yazma sayesinde uygulanması gereken kod basitleştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-110">If you use an Object-Relational Mapper (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="b4e41-111">Bu, veri erişim tesisatı yerine veri kalıcılığı mantığına odaklanmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="b4e41-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="b4e41-112">Depo deseni, bir veri kaynağıyla çalışmanın iyi belgelenmiş bir yoludur.</span><span class="sxs-lookup"><span data-stu-id="b4e41-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="b4e41-113">[Kitap Patterns kurumsal Uygulama Mimarisi,](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/)Martin Fowler aşağıdaki gibi bir depo açıklar:</span><span class="sxs-lookup"><span data-stu-id="b4e41-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="b4e41-114">Depo, etki alanı modeli katmanları ve veri eşleme arasında bir aracının görevlerini gerçekleştirir ve bellekteki etki alanı nesneleri kümesine benzer şekilde hareket eder.</span><span class="sxs-lookup"><span data-stu-id="b4e41-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="b4e41-115">İstemci nesneleri bildirimsel olarak sorgular oluşturur ve bunları yanıtlar için depolara gönderir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="b4e41-116">Kavramsal olarak, bir depo veritabanında depolanan bir nesne kümesini ve bunlar üzerinde gerçekleştirilebilecek işlemleri kapsülleyerek kalıcılık katmanına daha yakın bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="b4e41-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="b4e41-117">Depolar, aynı zamanda, açıkça ve tek bir yönde, iş etki alanı ve veri ayırma veya eşleme arasındaki bağımlılığı ayırma amacını destekler.</span><span class="sxs-lookup"><span data-stu-id="b4e41-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="b4e41-118">Toplam başına bir depo tanımlama</span><span class="sxs-lookup"><span data-stu-id="b4e41-118">Define one repository per aggregate</span></span>

<span data-ttu-id="b4e41-119">Her bir toplu veya toplam kök için bir depo sınıfı oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="b4e41-120">Etki Alanı Tabanlı Tasarım (DDD) desenlerine dayalı bir mikro hizmette, veritabanını güncelleştirmek için kullanmanız gereken tek kanal depolar olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-120">In a microservice based on Domain-Driven Design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="b4e41-121">Bunun nedeni, agreganın değişmezlerini ve işlem tutarlılığını kontrol eden toplam kökle bire bir ilişki içinde olmalarıdır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="b4e41-122">Sorgular veritabanının durumunu değiştirmedığından, veritabanını diğer kanallar (CQRS yaklaşımını izleyerek yapabileceğiniz gibi) sorgulayabilir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-122">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="b4e41-123">Ancak, işlem alanı (diğer bir başkası güncelleştirmeler) her zaman depolar ve toplam kökler tarafından denetlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-123">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="b4e41-124">Temel olarak, bir depo etki alanı varlıkları şeklinde veritabanından gelen bellekte veri doldurmak için izin verir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="b4e41-125">Varlıklar bellekte bir kez, değiştirilebilir ve daha sonra işlemler yoluyla veritabanına geri kalıcı.</span><span class="sxs-lookup"><span data-stu-id="b4e41-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="b4e41-126">Daha önce de belirtildiği gibi, CQS/CQRS mimari deseni kullanıyorsanız, ilk sorgular etki alanı modelinin dışında yan sorgularla gerçekleştirilir ve Dapper kullanılarak basit SQL deyimleri tarafından gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-126">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="b4e41-127">Bu yaklaşım, gereksinim duyduğunuz tabloları sorgulayıp birleştirebileceğinizden ve bu sorguların toplamlardan gelen kurallarla sınırlandırılamadığından, depolardan çok daha esnektir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="b4e41-128">Bu veriler sunu katmanına veya istemci uygulamasına gider.</span><span class="sxs-lookup"><span data-stu-id="b4e41-128">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="b4e41-129">Kullanıcı değişiklik yaparsa, güncellenecek veriler istemci uygulamasından veya uygulama katmanına sunu katmanından (Web API hizmeti gibi) gelir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-129">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="b4e41-130">Komut işleyicisi bir komut aldığınızda, veritabanından güncelleştirmek istediğiniz verileri almak için depoları kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="b4e41-130">When you receive a command in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="b4e41-131">Komutlarla geçirilen verilerle bellekte güncellersiniz ve ardından bir işlem aracılığıyla veritabanındaki verileri (etki alanı varlıkları) ekler veya güncellersiniz.</span><span class="sxs-lookup"><span data-stu-id="b4e41-131">You update it in memory with the data passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="b4e41-132">Şekil 7-17'de gösterildiği gibi, her bir toplam kök için yalnızca bir depo tanımlamanız gerektiğini tekrar vurgulamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-132">It's important to emphasize again that you should only define one repository for each aggregate root, as shown in Figure 7-17.</span></span> <span data-ttu-id="b4e41-133">Toplam kök hedefine ulaşmak için, toplamdaki tüm nesneler arasında işlem tutarlılığını korumak için, veritabanındaki her tablo için hiçbir zaman bir depo oluşturmamalısınız.</span><span class="sxs-lookup"><span data-stu-id="b4e41-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![Etki alanı ve diğer altyapı ilişkilerini gösteren diyagram.](./media/infrastructure-persistence-layer-design/repository-aggregate-database-table-relationships.png)

<span data-ttu-id="b4e41-135">**Şekil 7-17**.</span><span class="sxs-lookup"><span data-stu-id="b4e41-135">**Figure 7-17**.</span></span> <span data-ttu-id="b4e41-136">Depolar, toplamlar ve veritabanı tabloları arasındaki ilişki</span><span class="sxs-lookup"><span data-stu-id="b4e41-136">The relationship between repositories, aggregates, and database tables</span></span>

<span data-ttu-id="b4e41-137">Yukarıdaki diyagram Etki Alanı ve Altyapı katmanları arasındaki ilişkileri gösterir: Alıcı Toplam IBuyerRepository bağlıdır ve Sipariş Toplam IOrderRepository arayüzleri bağlıdır, bu arayüzler Altyapı katmanında uygulanır UnitOfWork'e bağlı olan ve veri katmanındaki tablolara erişen ilgili depolar tarafından.</span><span class="sxs-lookup"><span data-stu-id="b4e41-137">The above diagram shows the relationships between Domain and Infrastructure layers: Buyer Aggregate depends on the IBuyerRepository and Order Aggregate depends on the IOrderRepository interfaces, these interfaces are implemented in the Infrastructure layer by the corresponding repositories that depend on UnitOfWork, also implemented there, that accesses the tables in the Data tier.</span></span>

### <a name="enforce-one-aggregate-root-per-repository"></a><span data-ttu-id="b4e41-138">Depo başına bir toplam kök uygulayın</span><span class="sxs-lookup"><span data-stu-id="b4e41-138">Enforce one aggregate root per repository</span></span>

<span data-ttu-id="b4e41-139">Depo tasarımınızı, yalnızca toplu köklerin depoları olması gerektiği kuralını zorlar gibi uygulamak değerli olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-139">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="b4e41-140">`IAggregateRoot` İşaretçi arabirimine sahip olduğundan emin olmak için birlikte çalıştığı varlıkların türünü kısıtlayan genel veya temel depo türü oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4e41-140">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="b4e41-141">Böylece, altyapı katmanında uygulanan her depo sınıfı, aşağıdaki kodda gösterildiği gibi kendi sözleşmesini veya arabirimini uygular:</span><span class="sxs-lookup"><span data-stu-id="b4e41-141">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="b4e41-142">Her özel depo arabirimi genel IRepository arabirimini uygular:</span><span class="sxs-lookup"><span data-stu-id="b4e41-142">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="b4e41-143">Ancak, kodun her deponun tek bir toplamla ilişkili olduğu kuralı zorlamasının daha iyi bir yolu genel bir depo türü uygulamaktır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-143">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="b4e41-144">Bu şekilde, belirli bir toplamı hedeflemek için bir depo kullandığınız açıktır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-144">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="b4e41-145">Bu, aşağıdaki kodda olduğu `IRepository` gibi genel bir temel arabirim uygulanarak kolayca yapılabilir:</span><span class="sxs-lookup"><span data-stu-id="b4e41-145">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="b4e41-146">Depo deseni, uygulama mantığınızı test etmeyi kolaylaştırır</span><span class="sxs-lookup"><span data-stu-id="b4e41-146">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="b4e41-147">Depo deseni, ünite testleri ile uygulamanızı kolayca test etmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="b4e41-147">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="b4e41-148">Birim testlerinin altyapıyı değil, yalnızca kodunuzu sınadığını unutmayın, böylece depo soyutlamaları bu amaca ulaşmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-148">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="b4e41-149">Daha önceki bir bölümde belirtildiği gibi, web API mikro hizmetiniz gibi uygulama katmanının doğrudan uyguladığınız altyapı katmanına bağlı olmaması için depo arabirimlerini etki alanı modeli katmanına tanımlamanız ve yerleştirmeniz önerilir gerçek depo sınıfları.</span><span class="sxs-lookup"><span data-stu-id="b4e41-149">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="b4e41-150">Bunu yaparak ve Web API'nızın denetleyicilerinde Bağımlılık Enjeksiyonu'nu kullanarak, veritabanından veri yerine sahte veri döndüren sahte depolar uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4e41-150">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="b4e41-151">Bu ayrılmış yaklaşım, veritabanına bağlantı gerektirmeden uygulamanızın mantığını odaklayan birim testleri oluşturmanıza ve çalıştırmanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-151">This decoupled approach allows you to create and run unit tests that focus the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="b4e41-152">Veritabanlarına bağlantılar başarısız olabilir ve daha da önemlisi, bir veritabanına karşı yüzlerce test çalıştırmak iki nedenden dolayı kötüdür.</span><span class="sxs-lookup"><span data-stu-id="b4e41-152">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="b4e41-153">İlk olarak, testlerin çok sayıda nedeniyle uzun bir zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-153">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="b4e41-154">İkinci olarak, veritabanı kayıtları değişebilir ve testlerinizin sonuçlarını etkileyebilir, böylece tutarlı olmayabilirler.</span><span class="sxs-lookup"><span data-stu-id="b4e41-154">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="b4e41-155">Veritabanına karşı sınama bir birim testi değil, bir tümleştirme testidir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-155">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="b4e41-156">Hızlı çalışan birçok birim testleri, ancak veritabanlarına karşı daha az tümleştirme testleri olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-156">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="b4e41-157">Birim testleri için endişelerin ayrılması açısından, mantığınız bellekteki etki alanı varlıklarında çalışır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-157">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="b4e41-158">Depo sınıfının bunları teslim ettiği varsayar.</span><span class="sxs-lookup"><span data-stu-id="b4e41-158">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="b4e41-159">Mantığınız etki alanı varlıklarını modifiye ettikten sonra, depo sınıfının bunları doğru şekilde depolaacağını varsayar.</span><span class="sxs-lookup"><span data-stu-id="b4e41-159">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="b4e41-160">Burada önemli nokta etki alanı modeli ve etki alanı mantığı karşı birim testleri oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-160">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="b4e41-161">Toplam kökler DDD'deki ana tutarlılık sınırlarıdır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-161">Aggregate roots are the main consistency boundaries in DDD.</span></span>

<span data-ttu-id="b4e41-162">eShopOnContainers'da uygulanan depolar, ef core'un değişim izleyicisini kullanarak Depo ve İş Birimi desenlerinin DbContext uygulamasına dayanır, bu nedenle bu işlevselliği yinelemiyorlar.</span><span class="sxs-lookup"><span data-stu-id="b4e41-162">The repositories implemented in eShopOnContainers rely on EF Core’s DbContext implementation of the Repository and Unit of Work patterns using its change tracker, so they don’t duplicate this functionality.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="b4e41-163">Depo deseni ile eski Veri Erişimi sınıfı (DAL sınıfı) deseni arasındaki fark</span><span class="sxs-lookup"><span data-stu-id="b4e41-163">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="b4e41-164">Veri erişim nesnesi doğrudan depolamaya karşı veri erişimi ve kalıcılık işlemleri gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-164">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="b4e41-165">Depo, verileri bir çalışma nesnesi biriminin belleğinde gerçekleştirmek istediğiniz işlemlerle <xref:Microsoft.EntityFrameworkCore.DbContext> (sınıfı kullanırken EF'de olduğu gibi) işaretler, ancak bu güncelleştirmeler hemen veritabanına gerçekleştirilmez.</span><span class="sxs-lookup"><span data-stu-id="b4e41-165">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately to the database.</span></span>

<span data-ttu-id="b4e41-166">Çalışma birimi, birden çok ekleme, güncelleştirme veya silme işlemi içeren tek bir işlem olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-166">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="b4e41-167">Basit bir ifadeyle, web sitesindeki bir kayıt gibi belirli bir kullanıcı eylemi için, tüm ekleme, güncelleştirme ve silme işlemleri tek bir işlemde işlendiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-167">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete operations are handled in a single transaction.</span></span> <span data-ttu-id="b4e41-168">Bu, birden çok veritabanı işlemini chattier bir şekilde işlemekten daha verimlidir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-168">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="b4e41-169">Bu çoklu kalıcılık işlemleri, uygulama katmanındaki kodunuz bunu emrettiğinde daha sonra tek bir eylemde gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-169">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="b4e41-170">Bellek içi değişiklikleri gerçek veritabanı depolamasına uygulama kararı genellikle Çalışma [Birimi deseni'ne](https://martinfowler.com/eaaCatalog/unitOfWork.html)dayanır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-170">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="b4e41-171">EF'de, Çalışma Birimi deseni <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="b4e41-171">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="b4e41-172">Çoğu durumda, bu desen veya depolamaya karşı işlem uygulama şekli uygulama performansını artırabilir ve tutarsızlık olasılığını azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-172">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="b4e41-173">Tüm amaçlanan işlemler tek bir işlemin parçası olarak işlendiğinden, veritabanı tablolarında işlem engellemeyi de azaltır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-173">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="b4e41-174">Bu, veritabanına karşı birçok yalıtılmış işlemi yürütmeye kıyasla daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-174">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="b4e41-175">Bu nedenle, seçili ORM, birçok küçük ve ayrı işlem yürütmesi yerine, aynı işlem içinde birkaç güncelleştirme eylemi gruplayarak veritabanına karşı yürütme optimize edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4e41-175">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="b4e41-176">Depolar zorunlu olmamalıdır</span><span class="sxs-lookup"><span data-stu-id="b4e41-176">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="b4e41-177">Özel depolar daha önce belirtilen nedenlerle yararlıdır ve bu eShopOnContainers sipariş microservice için bir yaklaşımdır.</span><span class="sxs-lookup"><span data-stu-id="b4e41-177">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="b4e41-178">Ancak, bir DDD tasarımında ve hatta genel olarak .NET geliştirmede uygulanması gereken önemli bir desen değildir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-178">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="b4e41-179">Örneğin, Jimmy Bogard, bu kılavuz için doğrudan geribildirim sağlarken, şunları söyledi:</span><span class="sxs-lookup"><span data-stu-id="b4e41-179">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="b4e41-180">Bu muhtemelen benim en büyük geribildirim olacak.</span><span class="sxs-lookup"><span data-stu-id="b4e41-180">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="b4e41-181">Ben gerçekten depoları hayranı değilim, esas olarak altta yatan kalıcılık mekanizmasının önemli ayrıntılarını gizlemek çünkü.</span><span class="sxs-lookup"><span data-stu-id="b4e41-181">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="b4e41-182">Bu yüzden ben de komutlar için MediatR'a gidiyorum.</span><span class="sxs-lookup"><span data-stu-id="b4e41-182">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="b4e41-183">Kalıcılık katmanının tüm gücünü kullanabilir ve tüm bu etki alanı davranışını toplu köklerime itebilirim.</span><span class="sxs-lookup"><span data-stu-id="b4e41-183">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="b4e41-184">Ben genellikle benim depoları alay etmek istemiyorum - Ben hala gerçek bir şey ile entegrasyon testi olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-184">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="b4e41-185">CQRS'nin olması, artık depolara ihtiyacımız olmadığı anlamına geliyordu.</span><span class="sxs-lookup"><span data-stu-id="b4e41-185">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="b4e41-186">Depolar yararlı olabilir, ancak Toplam desen ve zengin etki alanı modeli gibi, DDD tasarım için kritik değildir.</span><span class="sxs-lookup"><span data-stu-id="b4e41-186">Repositories might be useful, but they are not critical for your DDD design, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="b4e41-187">Bu nedenle, uygun gördüğünüz gibi Depo deseni kullanın veya kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="b4e41-187">Therefore, use the Repository pattern or not, as you see fit.</span></span> <span data-ttu-id="b4e41-188">Her neyse, bu durumda, depo tüm microservice veya sınırlı bağlam kapsar rağmen, bu durumda, EF Core kullandığınızda depo deseni kullanıyor olacaksınız.</span><span class="sxs-lookup"><span data-stu-id="b4e41-188">Anyway, you’ll be using the repository pattern whenever you use EF Core although, in this case, the repository covers the whole microservice or bounded context.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="b4e41-189">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b4e41-189">Additional resources</span></span>

### <a name="repository-pattern"></a><span data-ttu-id="b4e41-190">Depo deseni</span><span class="sxs-lookup"><span data-stu-id="b4e41-190">Repository pattern</span></span>

- <span data-ttu-id="b4e41-191">**Edward Hieatt ve Rob beni. Depo deseni.**</span><span class="sxs-lookup"><span data-stu-id="b4e41-191">**Edward Hieatt and Rob Mee. Repository pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/repository.html>

- <span data-ttu-id="b4e41-192">**Depo deseni** </span><span class="sxs-lookup"><span data-stu-id="b4e41-192">**The Repository pattern** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)>

- <span data-ttu-id="b4e41-193">**Eric Evans' ı. Etki Alanı Odaklı Tasarım: Yazılımın Kalbinde Karmaşıklıkla Mücadele.**</span><span class="sxs-lookup"><span data-stu-id="b4e41-193">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="b4e41-194">(Kitap; Depo deseni bir tartışma içerir) </span><span class="sxs-lookup"><span data-stu-id="b4e41-194">(Book; includes a discussion of the Repository pattern) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="b4e41-195">Çalışma deseni Birimi</span><span class="sxs-lookup"><span data-stu-id="b4e41-195">Unit of Work pattern</span></span>

- <span data-ttu-id="b4e41-196">**Martin Fowler' ı. İş deseni birimi.**</span><span class="sxs-lookup"><span data-stu-id="b4e41-196">**Martin Fowler. Unit of Work pattern.**</span></span> \
  <https://martinfowler.com/eaaCatalog/unitOfWork.html>

- <span data-ttu-id="b4e41-197">**ASP.NET MVC Uygulamasında Çalışma Düzenlerinin Depo ve Biriminin Uygulanması** </span><span class="sxs-lookup"><span data-stu-id="b4e41-197">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application** </span></span>\
  <https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application>

>[!div class="step-by-step"]
><span data-ttu-id="b4e41-198">[Önceki](domain-events-design-implementation.md)
>[Sonraki](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="b4e41-198">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
