---
title: Kısmi hata işleme stratejileri
description: Kısmi hataların işlenmesi için çeşitli stratejileri sorunsuz bir şekilde öğrenin.
ms.date: 10/16/2018
ms.openlocfilehash: 948870aedec7bef4e7db0ed3752fb5185ed134b2
ms.sourcegitcommit: 10e719780594efc781b15295e499c66f316068b8
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/14/2021
ms.locfileid: "100429240"
---
# <a name="strategies-to-handle-partial-failure"></a><span data-ttu-id="8a858-103">Kısmi hata işleme stratejileri</span><span class="sxs-lookup"><span data-stu-id="8a858-103">Strategies to handle partial failure</span></span>

<span data-ttu-id="8a858-104">Kısmi hatalarla ilgilenme stratejileri şunlardır.</span><span class="sxs-lookup"><span data-stu-id="8a858-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="8a858-105">**İç mikro hizmetler arasında zaman uyumsuz iletişim (örneğin, ileti tabanlı iletişim) kullanın**.</span><span class="sxs-lookup"><span data-stu-id="8a858-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="8a858-106">İç mikro hizmetlerde zaman uyumlu HTTP çağrılarının uzun zincirlerinin oluşturulması kesinlikle önerilir, çünkü yanlış bir tasarım sonunda hatalı kesintilerin asıl nedeni olur.</span><span class="sxs-lookup"><span data-stu-id="8a858-106">It's highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="8a858-107">Aksine, istemci uygulamaları ve mikro hizmetlerin ilk düzeyi veya ayrıntılı API ağ geçitleri arasındaki ön uç iletişimleri dışında, iç mikro hizmetlerde ilk istek/yanıt döngüsünü tamamladıktan sonra yalnızca zaman uyumsuz (ileti tabanlı) iletişim kullanılması önerilir.</span><span class="sxs-lookup"><span data-stu-id="8a858-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it's recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="8a858-108">Nihai tutarlılık ve olay odaklı mimariler, Ripple etkilerini en aza indirmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="8a858-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="8a858-109">Bu yaklaşımlar daha yüksek düzeyde mikro hizmet bağımsız çalışma sınırı uygular ve bu nedenle burada belirtilen soruna karşı engeller.</span><span class="sxs-lookup"><span data-stu-id="8a858-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="8a858-110">**Üstel geri alma ile yeniden denemeler kullanın**.</span><span class="sxs-lookup"><span data-stu-id="8a858-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="8a858-111">Bu teknik, hizmetin yalnızca kısa bir süre için kullanılabilir olmaması durumunda, çağrı yeniden denemeleri belirli sayıda kez gerçekleştirerek kısa ve aralıklı hatalardan kaçınmaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="8a858-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="8a858-112">Bu durum aralıklı ağ sorunları veya bir mikro hizmet/kapsayıcının bir kümedeki farklı bir düğüme taşınması nedeniyle ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="8a858-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="8a858-113">Ancak, bu yeniden denemeler devre kesiciler ile düzgün şekilde tasarlanmamışsa, bu, son olarak [hizmet reddine neden olan (DOS)](https://en.wikipedia.org/wiki/Denial-of-service_attack), Ripple efektlerini belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="8a858-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="8a858-114">**Ağ zaman aşımları etrafında çalışın**.</span><span class="sxs-lookup"><span data-stu-id="8a858-114">**Work around network timeouts**.</span></span> <span data-ttu-id="8a858-115">Genel olarak, istemciler süresiz olarak engellenmemelidir ve yanıt beklerken her zaman zaman aşımlarını kullanır.</span><span class="sxs-lookup"><span data-stu-id="8a858-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="8a858-116">Zaman aşımı kullanımı, kaynakların süresiz olarak hiçbir zaman bağlı olmamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="8a858-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="8a858-117">**Devre kesici stilini kullanın**.</span><span class="sxs-lookup"><span data-stu-id="8a858-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="8a858-118">Bu yaklaşımda, istemci işlemi başarısız isteklerin sayısını izler.</span><span class="sxs-lookup"><span data-stu-id="8a858-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="8a858-119">Hata oranı yapılandırılan sınırı aşarsa, daha fazla girişim başarısız olacak şekilde bir "devre kesici" gezileri olur.</span><span class="sxs-lookup"><span data-stu-id="8a858-119">If the error rate exceeds a configured limit, a "circuit breaker" trips so that further attempts fail immediately.</span></span> <span data-ttu-id="8a858-120">(Çok sayıda istek başarısız olursa, hizmetin kullanılamaz olduğunu ve gönderme isteklerinin noktasız olduğunu öneren çok sayıda istek başarısız olursa.) Bir zaman aşımı süresi dolduktan sonra, istemci yeniden denemeli ve yeni istekler başarılı olursa devre kesici ' yı kapatın.</span><span class="sxs-lookup"><span data-stu-id="8a858-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="8a858-121">**Fallyedekler sağlayın**.</span><span class="sxs-lookup"><span data-stu-id="8a858-121">**Provide fallbacks**.</span></span> <span data-ttu-id="8a858-122">Bu yaklaşımda, istemci işlemi, önbellekteki verileri döndürme veya varsayılan bir değer gibi bir istek başarısız olduğunda geri dönüş mantığı gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="8a858-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="8a858-123">Bu, sorgular için uygun bir yaklaşımdır ve güncelleştirmeler veya komutlar için daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="8a858-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="8a858-124">**Sıraya alınan isteklerin sayısını sınırlayın**.</span><span class="sxs-lookup"><span data-stu-id="8a858-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="8a858-125">İstemciler ayrıca bir istemci mikro hizmetinin belirli bir hizmete gönderemediği bekleyen istek sayısına bir üst sınır getirmelidir.</span><span class="sxs-lookup"><span data-stu-id="8a858-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="8a858-126">Sınıra ulaşılırsa, ek istekler yapmak büyük olasılıkla daha az olabilir ve bu denemeler hemen başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="8a858-126">If the limit has been reached, it's probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="8a858-127">Uygulama açısından, bu gereksinimi karşılamak için Polly [Bulkbaş yalıtım](https://github.com/App-vNext/Polly/wiki/Bulkhead) ilkesi kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="8a858-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="8a858-128">Bu yaklaşım temelde uygulamayla aynı şekilde bir paralelleştirme kısıtlaması olur <xref:System.Threading.SemaphoreSlim> .</span><span class="sxs-lookup"><span data-stu-id="8a858-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="8a858-129">Ayrıca, Bulkhead dışında bir "kuyruğa" de izin verir.</span><span class="sxs-lookup"><span data-stu-id="8a858-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="8a858-130">Yürütmeden önce bile daha fazla yük (örneğin, kapasite tam olarak kabul edildiği için).</span><span class="sxs-lookup"><span data-stu-id="8a858-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="8a858-131">Bu, devre kesici hatalara neden olduğundan, bazı hata senaryolarına bir devre kesicinin yanıtını daha hızlı hale getirir.</span><span class="sxs-lookup"><span data-stu-id="8a858-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="8a858-132">Bir bulkthe bulkheadpolicy nesnesi, bölme perdesi 'in ve kuyruğun ne kadar tam olduğunu gösterir ve taşma üzerine [Olaylar sunar ve](https://thepollyproject.azurewebsites.net/) bu sayede otomatik yatay ölçeklendirmeyi açmak için de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="8a858-132">The BulkheadPolicy object in [Polly](https://thepollyproject.azurewebsites.net/) exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="8a858-133">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="8a858-133">Additional resources</span></span>

- <span data-ttu-id="8a858-134">**Dayanıklılık desenleri**</span><span class="sxs-lookup"><span data-stu-id="8a858-134">**Resiliency patterns**</span></span>\
  [https://docs.microsoft.com/azure/architecture/patterns/category/resiliency](/azure/architecture/patterns/category/resiliency)

- <span data-ttu-id="8a858-135">**Esnekliği ve Iyileştirme performansı ekleme**</span><span class="sxs-lookup"><span data-stu-id="8a858-135">**Adding Resilience and Optimizing Performance**</span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591574(v=pandp.10)>

- <span data-ttu-id="8a858-136">**Bölme perdesi.**</span><span class="sxs-lookup"><span data-stu-id="8a858-136">**Bulkhead.**</span></span> <span data-ttu-id="8a858-137">GitHub deposu.</span><span class="sxs-lookup"><span data-stu-id="8a858-137">GitHub repo.</span></span> <span data-ttu-id="8a858-138">Polly ilkesiyle uygulama. </span><span class="sxs-lookup"><span data-stu-id="8a858-138">Implementation with Polly policy.</span></span>\
  <https://github.com/App-vNext/Polly/wiki/Bulkhead>

- <span data-ttu-id="8a858-139">**Azure için dayanıklı uygulamalar tasarlama**</span><span class="sxs-lookup"><span data-stu-id="8a858-139">**Designing resilient applications for Azure**</span></span>\
  [https://docs.microsoft.com/azure/architecture/resiliency/](/azure/architecture/resiliency/)

- <span data-ttu-id="8a858-140">**Geçici hata işleme**</span><span class="sxs-lookup"><span data-stu-id="8a858-140">**Transient fault handling**</span></span>\
  [https://docs.microsoft.com/azure/architecture/best-practices/transient-faults](/azure/architecture/best-practices/transient-faults)

>[!div class="step-by-step"]
><span data-ttu-id="8a858-141">[Önceki](handle-partial-failure.md) 
> [Sonraki](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="8a858-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
