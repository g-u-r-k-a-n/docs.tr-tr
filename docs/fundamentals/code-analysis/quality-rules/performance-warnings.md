---
title: Performans kuralları (kod analizi)
description: Kod Analizi performans kuralları hakkında bilgi edinin.
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- rules, performance
- performance rules
- performance, rules
- managed code analysis rules, performance rules
author: gewarren
ms.author: gewarren
ms.openlocfilehash: 4409cc46eb73f13f8e59d7a51899da27035bb6af
ms.sourcegitcommit: 05d0087dfca85aac9ca2960f86c5efd218bf833f
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/30/2021
ms.locfileid: "96588818"
---
# <a name="performance-rules"></a><span data-ttu-id="8f4fa-103">Performans kuralları</span><span class="sxs-lookup"><span data-stu-id="8f4fa-103">Performance rules</span></span>

<span data-ttu-id="8f4fa-104">Performans kuralları yüksek performanslı kitaplıkları ve uygulamaları destekler.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-104">Performance rules support high-performance libraries and applications.</span></span>

## <a name="in-this-section"></a><span data-ttu-id="8f4fa-105">Bu bölümde</span><span class="sxs-lookup"><span data-stu-id="8f4fa-105">In this section</span></span>

| <span data-ttu-id="8f4fa-106">Kural</span><span class="sxs-lookup"><span data-stu-id="8f4fa-106">Rule</span></span> | <span data-ttu-id="8f4fa-107">Description</span><span class="sxs-lookup"><span data-stu-id="8f4fa-107">Description</span></span> |
| - | - |
| [<span data-ttu-id="8f4fa-108">CA1802: Uygun yerlerde sabitleri kullanın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-108">CA1802: Use Literals Where Appropriate</span></span>](ca1802.md) | <span data-ttu-id="8f4fa-109">Bir alan statik ve salt okunur olarak tanımlanır (Visual Basic paylaşılan ve salt okunur) ve derleme zamanında oluşturulabilir bir değer ile başlatılır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-109">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized with a value that is computable at compile time.</span></span> <span data-ttu-id="8f4fa-110">Hedeflenen alana atanan değer derleme zamanında oluşturulabilir olduğundan, değeri bir const (const Visual Basic) alanı olarak değiştirin, böylece değer çalışma zamanı yerine derleme zamanında hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-110">Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run time.</span></span> |
| [<span data-ttu-id="8f4fa-111">CA1805: Gerekmediği durumlarda başlatmayın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-111">CA1805: Do not initialize unnecessarily</span></span>](ca1805.md) | <span data-ttu-id="8f4fa-112">.NET çalışma zamanı, oluşturucuyu çalıştırmadan önce, başvuru türlerindeki tüm alanları varsayılan değerlerine başlatır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-112">The .NET runtime initializes all fields of reference types to their default values before running the constructor.</span></span> <span data-ttu-id="8f4fa-113">Çoğu durumda, bir alanı varsayılan değerine açıkça başlatmak, bakım maliyetlerine eklenen ve performansı düşürebilir (örneğin, daha fazla derleme boyutuyla).</span><span class="sxs-lookup"><span data-stu-id="8f4fa-113">In most cases, explicitly initializing a field to its default value is redundant, which adds to maintenance costs and may degrade performance (such as with increased assembly size).</span></span> |
| [<span data-ttu-id="8f4fa-114">CA1806: Metot sonuçlarını yoksaymayın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-114">CA1806: Do not ignore method results</span></span>](ca1806.md) | <span data-ttu-id="8f4fa-115">Yeni bir nesne oluşturulur, ancak hiçbir zaman kullanılmaz veya yeni bir dize oluşturan ve döndüren bir yöntem çağrılır ve yeni dize hiçbir zaman kullanılmaz veya bir bileşen nesne modeli (COM) ya da P/Invoke yöntemi hiçbir zaman kullanılmayan bir HRESULT veya hata kodu döndürür.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-115">A new object is created but never used, or a method that creates and returns a new string is called and the new string is never used, or a Component Object Model (COM) or P/Invoke method returns an HRESULT or error code that is never used.</span></span> |
| [<span data-ttu-id="8f4fa-116">CA1810: Başvuru türü statik alanları satır içinden başlatın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-116">CA1810: Initialize reference type static fields inline</span></span>](ca1810.md) | <span data-ttu-id="8f4fa-117">Bir tür açık statik yapıcı bildirdiğinde, JIT derleyici her bir statik yöntemi kontrol ekler ve türün yapıcı örneği statik yapıcının daha önceden çağrıldığından emin olur.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-117">When a type declares an explicit static constructor, the just-in-time (JIT) compiler adds a check to each static method and instance constructor of the type to make sure that the static constructor was previously called.</span></span> <span data-ttu-id="8f4fa-118">Statik oluşturucu denetimleri performansı düşürebilir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-118">Static constructor checks can decrease performance.</span></span> |
| [<span data-ttu-id="8f4fa-119">CA1812: Örneklenmemiş iç sınıflardan kaçının</span><span class="sxs-lookup"><span data-stu-id="8f4fa-119">CA1812: Avoid uninstantiated internal classes</span></span>](ca1812.md) | <span data-ttu-id="8f4fa-120">Bir derleme düzeyi türünün örneği, derleme içindeki kod tarafından oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-120">An instance of an assembly-level type is not created by code in the assembly.</span></span> |
| [<span data-ttu-id="8f4fa-121">CA1813: Mühürsüz özniteliklerden kaçının</span><span class="sxs-lookup"><span data-stu-id="8f4fa-121">CA1813: Avoid unsealed attributes</span></span>](ca1813.md) | <span data-ttu-id="8f4fa-122">.NET özel özniteliklerin alınması için yöntemler sağlar.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-122">.NET provides methods for retrieving custom attributes.</span></span> <span data-ttu-id="8f4fa-123">Varsayılan olarak, bu yöntemleri öznitelik devralma hiyerarşisinde arar.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-123">By default, these methods search the attribute inheritance hierarchy.</span></span> <span data-ttu-id="8f4fa-124">Öznitelik mühürleme kalıtım hiyerarşisi aracılığıyla aramayı ortadan kaldırır ve performansı artırabilir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-124">Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</span></span> |
| [<span data-ttu-id="8f4fa-125">CA1814: Çok boyutlu diziler yerine basit dizileri tercih edin</span><span class="sxs-lookup"><span data-stu-id="8f4fa-125">CA1814: Prefer jagged arrays over multidimensional</span></span>](ca1814.md) | <span data-ttu-id="8f4fa-126">Basit bir dizi, öğeleri dizi olan bir dizidir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-126">A jagged array is an array whose elements are arrays.</span></span> <span data-ttu-id="8f4fa-127">Öğeleri oluşturan diziler farklı boyutlarda olabilir ve bu da bazı veri kümeleri için daha az alana yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-127">The arrays that make up the elements can be of different sizes, which can result in less wasted space for some sets of data.</span></span> |
| [<span data-ttu-id="8f4fa-128">CA1815: Değer türlerinde eşittir ve işleç eşittiri geçersiz kılın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-128">CA1815: Override equals and operator equals on value types</span></span>](ca1815.md) | <span data-ttu-id="8f4fa-129">Değer türleri için, Equals'ın devralınmış uygulaması Reflection kitaplığını kullanır ve türdeki tüm alanların içeriğini karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-129">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields.</span></span> <span data-ttu-id="8f4fa-130">Yansıma hesaplama açısından pahalıdır ve her alan için eşitlik karşılaştırma gereksiz olabilir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-130">Reflection is computationally expensive, and comparing every field for equality might be unnecessary.</span></span> <span data-ttu-id="8f4fa-131">Kullanıcıları karşılaştırmak veya örneklerini sıralamak ya da tablo anahtarlarını karma olarak kullanmayı bekliyorsanız, değer türünüz Equals'ı uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-131">If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</span></span> |
| [<span data-ttu-id="8f4fa-132">CA1819: Özellikler diziler döndürmemelidir</span><span class="sxs-lookup"><span data-stu-id="8f4fa-132">CA1819: Properties should not return arrays</span></span>](ca1819.md) | <span data-ttu-id="8f4fa-133">Özellik salt okunurdur olsa bile, Özellikler tarafından döndürülen diziler yazma korumalı değildir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-133">Arrays that are returned by properties are not write-protected, even if the property is read-only.</span></span> <span data-ttu-id="8f4fa-134">Dizi değiştirilmeye kanıt tutulacak özellik dizisinin bir kopyasını döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-134">To keep the array tamper-proof, the property must return a copy of the array.</span></span> <span data-ttu-id="8f4fa-135">Tipik olarak, kullanıcılar bu tür bir özellik aramanın performans üzerindeki olumsuz etkilerini anlamayacaktır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-135">Typically, users will not understand the adverse performance implications of calling such a property.</span></span> |
| [<span data-ttu-id="8f4fa-136">CA1820: Dize uzunluğunu kullanarak boş dizeleri test edin</span><span class="sxs-lookup"><span data-stu-id="8f4fa-136">CA1820: Test for empty strings using string length</span></span>](ca1820.md) | <span data-ttu-id="8f4fa-137">String.Length özelliği veya String.IsNullOrEmpty yöntemi, Equals kullanılmasından önemli ölçüde daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-137">Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</span></span> |
| [<span data-ttu-id="8f4fa-138">CA1821: Boş sonlandırıcıları kaldırın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-138">CA1821: Remove empty finalizers</span></span>](ca1821.md) | <span data-ttu-id="8f4fa-139">Güncelleştirirken, nesne kullanım süresini izleme söz konusu olduğunda ek performans yükü nedeniyle sonlandırıcılardan kaçının.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-139">Whenever you can, avoid finalizers because of the additional performance overhead that is involved in tracking object lifetime.</span></span> <span data-ttu-id="8f4fa-140">Boş bir Sonlandırıcı, hiçbir avantaj olmadan ek yüke neden olur.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-140">An empty finalizer incurs added overhead without any benefit.</span></span> |
| [<span data-ttu-id="8f4fa-141">CA1822: Üyeleri static olarak işaretleyin</span><span class="sxs-lookup"><span data-stu-id="8f4fa-141">CA1822: Mark members as static</span></span>](ca1822.md) | <span data-ttu-id="8f4fa-142">Örnek verilerine veya çağrı örnek yöntemlerine erişmeyen Üyeler statik olarak işaretlenebilir (Visual Basic içinde paylaşılır).</span><span class="sxs-lookup"><span data-stu-id="8f4fa-142">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic).</span></span> <span data-ttu-id="8f4fa-143">Yöntemleri statik olarak işaretledikten sonra, derleyici sanal olmayan arama sitelerini bu üyelere yayar.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-143">After you mark the methods as static, the compiler will emit nonvirtual call sites to these members.</span></span> <span data-ttu-id="8f4fa-144">Bu, ölçülebilir kazanç performansını performans duyarlı kodunuz için verebilir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-144">This can give you a measurable performance gain for performance-sensitive code.</span></span> |
| [<span data-ttu-id="8f4fa-145">CA1823: Kullanılmayan özel alanlardan kaçının</span><span class="sxs-lookup"><span data-stu-id="8f4fa-145">CA1823: Avoid unused private fields</span></span>](ca1823.md) | <span data-ttu-id="8f4fa-146">Derlemede erişimi görülmeyen özel alanlar algılandı.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-146">Private fields were detected that do not appear to be accessed in the assembly.</span></span> |
| [<span data-ttu-id="8f4fa-147">CA1824: Derlemeleri NeutralResourcesLanguageAttribute ile işaretleyin</span><span class="sxs-lookup"><span data-stu-id="8f4fa-147">CA1824: Mark assemblies with NeutralResourcesLanguageAttribute</span></span>](ca1824.md) | <span data-ttu-id="8f4fa-148">NeutralResourcesLanguage özniteliği, bir derleme için nötr kültürün kaynaklarını göstermek için kullanılan dilin Kaynak Yöneticisi bildirir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-148">The NeutralResourcesLanguage attribute informs the Resource Manager of the language that was used to display the resources of a neutral culture for an assembly.</span></span> <span data-ttu-id="8f4fa-149">Bu ilk yüklediğiniz kaynak için arama performansını artırır ve çalışma kümenizi azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-149">This improves lookup performance for the first resource that you load and can reduce your working set.</span></span> |
| [<span data-ttu-id="8f4fa-150">CA1825: Sıfır uzunluklu dizi ayırmalarından kaçının</span><span class="sxs-lookup"><span data-stu-id="8f4fa-150">CA1825: Avoid zero-length array allocations</span></span>](ca1825.md) | <span data-ttu-id="8f4fa-151">Sıfır uzunluklu bir diziyi başlatmak gereksiz bellek ayırmaya yol açar.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-151">Initializing a zero-length array leads to unnecessary memory allocation.</span></span> <span data-ttu-id="8f4fa-152">Bunun yerine, çağırarak statik olarak ayrılan boş dizi örneğini kullanın <xref:System.Array.Empty%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="8f4fa-152">Instead, use the statically allocated empty array instance by calling <xref:System.Array.Empty%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8f4fa-153">Bellek ayırma, bu yöntemin tüm etkinleştirmeleri genelinde paylaşılır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-153">The memory allocation is shared across all invocations of this method.</span></span> |
| [<span data-ttu-id="8f4fa-154">CA1826: Linq Numaralandırma metodu yerine property kullan</span><span class="sxs-lookup"><span data-stu-id="8f4fa-154">CA1826: Use property instead of Linq Enumerable method</span></span>](ca1826.md) | <span data-ttu-id="8f4fa-155"><xref:System.Linq.Enumerable> LINQ yöntemi eşdeğer, daha verimli bir özelliği destekleyen bir tür üzerinde kullanıldı.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-155"><xref:System.Linq.Enumerable> LINQ method was used on a type that supports an equivalent, more efficient property.</span></span> |
| [<span data-ttu-id="8f4fa-156">CA1827: Any kullanılabiliyorsa Count/LongCount kullanma</span><span class="sxs-lookup"><span data-stu-id="8f4fa-156">CA1827: Do not use Count/LongCount when Any can be used</span></span>](ca1827.md) | <span data-ttu-id="8f4fa-157"><xref:System.Linq.Enumerable.Count%2A> ya da yöntemi <xref:System.Linq.Enumerable.LongCount%2A> , <xref:System.Linq.Enumerable.Any%2A> yöntemin daha verimli olacağı yerde kullanılmıştır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-157"><xref:System.Linq.Enumerable.Count%2A> or <xref:System.Linq.Enumerable.LongCount%2A> method was used where <xref:System.Linq.Enumerable.Any%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="8f4fa-158">CA1828: AnyAsync kullanılabiliyorsa CountAsync/LongCountAsync kullanma</span><span class="sxs-lookup"><span data-stu-id="8f4fa-158">CA1828: Do not use CountAsync/LongCountAsync when AnyAsync can be used</span></span>](ca1828.md) | <span data-ttu-id="8f4fa-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> ya da yöntemi <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> , <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> yöntemin daha verimli olacağı yerde kullanılmıştır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-159"><xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> or <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> method was used where <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> method would be more efficient.</span></span> |
| [<span data-ttu-id="8f4fa-160">CA1829: Enumerable.Count metodu yerine Length/Count özelliğini kullan</span><span class="sxs-lookup"><span data-stu-id="8f4fa-160">CA1829: Use Length/Count property instead of Enumerable.Count method</span></span>](ca1829.md) | <span data-ttu-id="8f4fa-161"><xref:System.Linq.Enumerable.Count%2A> LINQ yöntemi eşdeğer, daha etkin veya özelliği destekleyen bir tür üzerinde kullanıldı `Length` `Count` .</span><span class="sxs-lookup"><span data-stu-id="8f4fa-161"><xref:System.Linq.Enumerable.Count%2A> LINQ method was used on a type that supports an equivalent, more efficient `Length` or `Count` property.</span></span> |
| [<span data-ttu-id="8f4fa-162">CA1830: StringBuilder'da kesin tür belirtilmiş Append ve Insert metodu aşırı yüklemelerini tercih et</span><span class="sxs-lookup"><span data-stu-id="8f4fa-162">CA1830: Prefer strongly-typed Append and Insert method overloads on StringBuilder</span></span>](ca1830.md) | <span data-ttu-id="8f4fa-163"><xref:System.Text.StringBuilder.Append%2A> ve <xref:System.Text.StringBuilder.Insert%2A> System. String 'in ötesinde birden çok tür için aşırı yüklemeler sağlar.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-163"><xref:System.Text.StringBuilder.Append%2A> and <xref:System.Text.StringBuilder.Insert%2A> provide overloads for multiple types beyond System.String.</span></span>  <span data-ttu-id="8f4fa-164">Mümkün olduğunda, ToString () ve dize tabanlı aşırı yüklemeyi kullanarak türü kesin belirlenmiş aşırı yüklemeleri tercih edin.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-164">When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.</span></span> |
| [<span data-ttu-id="8f4fa-165">CA1831: Uygun olduğunda dize için Aralık tabanlı dizin oluşturucular yerine AsSpan kullanın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-165">CA1831: Use AsSpan instead of Range-based indexers for string when appropriate</span></span>](ca1831.md) | <span data-ttu-id="8f4fa-166">Bir dizede Aralık Dizin Oluşturucu kullanırken ve değeri örtük olarak ReadOnlySpan &lt; char &gt; türüne atandığında, yöntemi <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , dizenin istenen bölümünün bir kopyasını üreten yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-166">When using a range-indexer on a string and implicitly assigning the value to a ReadOnlySpan&lt;char&gt; type, the method <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the string.</span></span> |
| [<span data-ttu-id="8f4fa-167">CA1832: Bir dizinin ReadOnlySpan veya ReadOnlyMemory kısmını almak için Aralık tabanlı dizin oluşturucular yerine AsSpan ya da AsMemory kullanın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-167">CA1832: Use AsSpan or AsMemory instead of Range-based indexers for getting ReadOnlySpan or ReadOnlyMemory portion of an array</span></span>](ca1832.md) | <span data-ttu-id="8f4fa-168">Bir dizide Aralık Dizin Oluşturucu kullanırken ve değeri örtük olarak bir <xref:System.ReadOnlySpan%601> veya <xref:System.ReadOnlyMemory%601> türüne atandığında, yöntemi <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , dizinin istenen bölümünün bir kopyasını üreten yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-168">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.ReadOnlySpan%601> or <xref:System.ReadOnlyMemory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="8f4fa-169">CA1833: Bir dizinin Span veya Memory kısmını almak için Aralık tabanlı dizin oluşturucular yerine AsSpan ya da AsMemory kullanın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-169">CA1833: Use AsSpan or AsMemory instead of Range-based indexers for getting Span or Memory portion of an array</span></span>](ca1833.md) | <span data-ttu-id="8f4fa-170">Bir dizide Aralık Dizin Oluşturucu kullanırken ve değeri örtük olarak bir <xref:System.Span%601> veya <xref:System.Memory%601> türüne atandığında, yöntemi <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> , dizinin istenen bölümünün bir kopyasını üreten yerine kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-170">When using a range-indexer on an array and implicitly assigning the value to a <xref:System.Span%601> or <xref:System.Memory%601> type, the method <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> will be used instead of <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_>, which produces a copy of requested portion of the array.</span></span> |
| [<span data-ttu-id="8f4fa-171">CA1834: Tek karakterli dizeler için StringBuilder.Append(char) kullanın</span><span class="sxs-lookup"><span data-stu-id="8f4fa-171">CA1834: Use StringBuilder.Append(char) for single character strings</span></span>](ca1834.md) | <span data-ttu-id="8f4fa-172"><xref:System.Text.StringBuilder> , `Append` bağımsız değişkeni olarak bir olan aşırı yüküne sahiptir `char` .</span><span class="sxs-lookup"><span data-stu-id="8f4fa-172"><xref:System.Text.StringBuilder> has an `Append` overload that takes a `char` as its argument.</span></span> <span data-ttu-id="8f4fa-173">`char`Performansı artırmak için aşırı yüklemeyi çağırmayı tercih edin.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-173">Prefer calling the `char` overload to improve performance.</span></span> |
| [<span data-ttu-id="8f4fa-174">CA1835: ' ReadAsync ' ve ' WriteAsync ' için ' Memory' tabanlı aşırı yüklemeleri tercih et</span><span class="sxs-lookup"><span data-stu-id="8f4fa-174">CA1835: Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync'</span></span>](ca1835.md) | <span data-ttu-id="8f4fa-175">' Stream ', &lt; &gt; ilk bağımsız değişken olarak ' bellek baytı ' ve &lt; &gt; ilk bağımsız değişken olarak ' readonlymemory byte ' olan bir ' WriteAsync ' aşırı yüklemesi olan ' ReadAsync ' aşırı yüklemesine sahip.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-175">'Stream' has a 'ReadAsync' overload that takes a 'Memory&lt;Byte&gt;' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory&lt;Byte&gt;' as the first argument.</span></span> <span data-ttu-id="8f4fa-176">Daha verimli olan bellek tabanlı aşırı yüklemeleri çağırmayı tercih edin.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-176">Prefer calling the memory based overloads, which are more efficient.</span></span> |
| [<span data-ttu-id="8f4fa-177">CA1836: `IsEmpty` `Count` kullanılabilir olduğunda tercih et</span><span class="sxs-lookup"><span data-stu-id="8f4fa-177">CA1836: Prefer `IsEmpty` over `Count` when available</span></span>](ca1836.md) | <span data-ttu-id="8f4fa-178">`IsEmpty` `Count` `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> Nesnenin bir öğe içerip içermediğini ya da olmadığını anlamak için, veya ' den daha verimli bir özellik tercih edin.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-178">Prefer `IsEmpty` property that is more efficient than `Count`, `Length`, <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> or <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> to determine whether the object contains or not any items.</span></span> |
| [<span data-ttu-id="8f4fa-179">CA1837: `Environment.ProcessId` yerine kullanın `Process.GetCurrentProcess().Id`</span><span class="sxs-lookup"><span data-stu-id="8f4fa-179">CA1837: Use `Environment.ProcessId` instead of `Process.GetCurrentProcess().Id`</span></span>](ca1837.md) | <span data-ttu-id="8f4fa-180">`Environment.ProcessId` daha basit ve daha hızlıdır `Process.GetCurrentProcess().Id` .</span><span class="sxs-lookup"><span data-stu-id="8f4fa-180">`Environment.ProcessId` is simpler and faster than `Process.GetCurrentProcess().Id`.</span></span> |
| [<span data-ttu-id="8f4fa-181">CA1838: `StringBuilder` P/Invoke için parametrelerden kaçının</span><span class="sxs-lookup"><span data-stu-id="8f4fa-181">CA1838: Avoid `StringBuilder` parameters for P/Invokes</span></span>](ca1838.md) | <span data-ttu-id="8f4fa-182">' Nin sıralaması `StringBuilder` her zaman bir sıralama işlemi için birden çok ayırmaya neden olan yerel bir arabellek kopyası oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8f4fa-182">Marshaling of `StringBuilder` always creates a native buffer copy, resulting in multiple allocations for one marshaling operation.</span></span> |
