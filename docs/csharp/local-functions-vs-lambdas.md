---
title: Yerel işlevler vs lambda ifadeler
description: Yerel işlevlerin neden lambda ifadelerinden daha iyi bir seçim olabileceğini öğrenin.
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 13cc3fe47bbcd6a465347a6c991b2006586c78fa
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173347"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="b60f9-103">Lambda ifadeleri ile karşılaştırıldığında yerel fonksiyonlar</span><span class="sxs-lookup"><span data-stu-id="b60f9-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="b60f9-104">İlk bakışta, [yerel fonksiyonlar](programming-guide/classes-and-structs/local-functions.md) ve [lambda ifadeler](./programming-guide/statements-expressions-operators/lambda-expressions.md) çok benzer.</span><span class="sxs-lookup"><span data-stu-id="b60f9-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="b60f9-105">Birçok durumda, lambda ifadeleri ve yerel işlevleri kullanarak arasındaki seçim tarzı ve kişisel tercih meselesidir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="b60f9-106">Ancak, farkında olması gereken birini veya diğerini kullanabileceğiniz gerçek farklılıklar vardır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="b60f9-107">Faktöriyel algoritmanın yerel fonksiyon ve lambda ifade uygulamaları arasındaki farkları inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="b60f9-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="b60f9-108">Önce yerel bir işlev kullanarak sürümü:</span><span class="sxs-lookup"><span data-stu-id="b60f9-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="b60f9-109">Bu uygulamanın lambda ifadelerini kullanan bir sürümle karşılatılması:</span><span class="sxs-lookup"><span data-stu-id="b60f9-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="b60f9-110">Yerel işlevlerin adları vardır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-110">The local functions have names.</span></span> <span data-ttu-id="b60f9-111">Lambda ifadeleri, türdeki değişkenlere atanan anonim `Func` yöntemlerdir. `Action`</span><span class="sxs-lookup"><span data-stu-id="b60f9-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="b60f9-112">Yerel bir işlev bildirdiğinizde, bağımsız değişken türleri ve iade türü işlev bildiriminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="b60f9-113">Lambda ifadesinin gövdesinin bir parçası olmak yerine, argüman türleri ve dönüş türü lambda ifadesinin değişken türü deyiminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="b60f9-114">Bu iki fark daha net kod neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="b60f9-115">Yerel işlevlerin kesin atama için lambda ifadelerinden farklı kuralları vardır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="b60f9-116">Yerel işlev bildirimi, kapsamda olduğu herhangi bir kod konumundan başvurulabilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="b60f9-117">Bir lambda ifadesine erişilebilmek için bir temsilci değişkenine atanmalıdır (veya lambda ifadesine başvuran temsilci aracılığıyla çağrılanmalıdır.) Lambda ifadesini kullanan sürümün lambda ifadesini tanımlamadan `nthFactorial` önce beyan etmesi ve başlatması gerektiğine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="b60f9-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="b60f9-118">Bunu yapmamak, atamadan önce başvurmak `nthFactorial` için bir derleme zaman hatasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="b60f9-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="b60f9-119">Bu farklar, özyinelemeli algoritmaların yerel işlevleri kullanarak oluşturulmasının daha kolay olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="b60f9-120">Kendisini çağıran yerel bir işlev bildirebilir ve tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b60f9-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="b60f9-121">Lambda ifadeleri beyan edilmeli ve aynı lambda ifadesine başvuran bir gövdeye yeniden atanabilmeleri için varsayılan bir değer atanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="b60f9-122">Kesin atama kuralları, yerel işlev veya lambda ifadesi tarafından yakalanan değişkenleri de etkiler.</span><span class="sxs-lookup"><span data-stu-id="b60f9-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="b60f9-123">Hem yerel işlevler hem de lambda ifade kuralları, yakalanan değişkenlerin, yerel işlevin veya lambda ifadesinin bir temsilciye dönüştürüldüğü noktada kesinlikle atanmasını ister.</span><span class="sxs-lookup"><span data-stu-id="b60f9-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="b60f9-124">Aradaki fark, lambda ifadeleri beyan edildiğinde delegelere dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="b60f9-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="b60f9-125">Yerel işlevler yalnızca temsilci olarak kullanıldığında temsilciye dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="b60f9-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="b60f9-126">Yerel bir işlev bildirir ve yalnızca bir yöntem gibi çağırarak başvurursanız, bu işlev bir temsilciye dönüştürülmez.</span><span class="sxs-lookup"><span data-stu-id="b60f9-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="b60f9-127">Bu kural, yerel bir işlevi ekkapsamına giren herhangi bir uygun konumda bildirmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="b60f9-128">İade bildirimlerinden sonra, ana yöntemin sonunda yerel işlevleri bildirmek yaygındır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="b60f9-129">Üçüncü olarak, derleyici, yerel işlevlerin yakalanan değişkenleri kesinlikle çevreleyen kapsamda atamasını sağlayan statik çözümleme gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="b60f9-130">Bu örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="b60f9-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="b60f9-131">Derleyici çağrıldığında `LocalFunction` kesinlikle `y` atadığını belirleyebilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="b60f9-132">Çünkü `LocalFunction` ifadeden `return` önce `y` çağrılır, `return` kesinlikle deyimde atanır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="b60f9-133">Örnek çözümlemesini sağlayan çözümleme dördüncü farkı sağlar.</span><span class="sxs-lookup"><span data-stu-id="b60f9-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="b60f9-134">Kullanımlarına bağlı olarak, yerel işlevler lambda ifadeleri için her zaman gerekli olan yığın ayırmalarından kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="b60f9-135">Yerel bir işlev hiçbir zaman temsilciye dönüştürülmezse ve yerel işlev tarafından yakalanan değişkenlerin hiçbiri diğer lambda'lar veya temsilciye dönüştürülen yerel işlevler tarafından yakalanırsa, derleyici yığın ayırmalarından kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span>

<span data-ttu-id="b60f9-136">Bu async örneğini göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="b60f9-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="b60f9-137">Bu lambda ifadesinin `address`kapanışı `index` `name` , ve değişkenleri içerir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="b60f9-138">Yerel işlevler söz konusu olduğunda, kapatmayı uygulayan `struct` nesne bir tür olabilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="b60f9-139">Bu yapı türü yerel işleve atıfta bulunularak geçirilir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="b60f9-140">Uygulamadaki bu fark bir ayırmada tasarruf sağlar.</span><span class="sxs-lookup"><span data-stu-id="b60f9-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="b60f9-141">Lambda ifadeleri için gerekli anlık algılama, zaman açısından kritik kod yollarında bir performans faktörü olabilecek ekstra bellek ayırmaları anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="b60f9-142">Yerel işlevler bu ek yükü tabi değildir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="b60f9-143">Yukarıdaki örnekte, yerel işlevler sürümü lambda ifade sürümünden 2 daha az ayırmaya sahiptir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="b60f9-144">Bu yöntemin yerel işlev eşdeğeri de kapatma için bir sınıf kullanır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="b60f9-145">Yerel bir işlevin kapatılmasının a `class` veya `struct` a olarak uygulanıp uygulanmadığı bir uygulama ayrıntısýr.</span><span class="sxs-lookup"><span data-stu-id="b60f9-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="b60f9-146">Yerel bir `struct` fonksiyon bir lambda her zaman `class`bir .</span><span class="sxs-lookup"><span data-stu-id="b60f9-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="b60f9-147">Bu örnekte gösterilmemiş son bir avantaj, yerel işlevlerin bir değer `yield return` dizisi oluşturmak için sözdizimini kullanarak yineleyici olarak uygulanabiliyor olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="b60f9-148">Lambda `yield return` ifadelerinde ifadeye izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="b60f9-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="b60f9-149">Yerel işlevler lambda ifadeleri için gereksiz görünse de, aslında farklı amaçlara hizmet ve farklı kullanımları vardır.</span><span class="sxs-lookup"><span data-stu-id="b60f9-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="b60f9-150">Yerel işlevler, yalnızca başka bir yöntemin bağlamından çağrılan bir işlev yazmak istediğinizde, servis talebi için daha verimlidir.</span><span class="sxs-lookup"><span data-stu-id="b60f9-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
