---
title: Dağıtılmış veriler
description: Tek parçalı ve bulutta yerel uygulamalardaki veri depolama alanını kontrast.
author: robvet
ms.date: 05/13/2020
ms.openlocfilehash: b7c8c43b16f2f70f9009c4fe4a8d19c52fa7ea2a
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91163940"
---
# <a name="distributed-data"></a><span data-ttu-id="44083-103">Dağıtılmış veriler</span><span class="sxs-lookup"><span data-stu-id="44083-103">Distributed data</span></span>

<span data-ttu-id="44083-104">Bu kitapta gördüğünüze göre, bulutta yerel bir yaklaşım, uygulamaları tasarlama, dağıtma ve yönetme şeklini değiştirir.</span><span class="sxs-lookup"><span data-stu-id="44083-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="44083-105">Ayrıca verileri yönetme ve depolama şeklini de değiştirir.</span><span class="sxs-lookup"><span data-stu-id="44083-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="44083-106">Şekil 5-1, farkları karşıtlıkları.</span><span class="sxs-lookup"><span data-stu-id="44083-106">Figure 5-1 contrasts the differences.</span></span>

![Bulutta yerel uygulamalarda veri depolama](./media/distributed-data.png)

<span data-ttu-id="44083-108">**Şekil 5-1**.</span><span class="sxs-lookup"><span data-stu-id="44083-108">**Figure 5-1**.</span></span> <span data-ttu-id="44083-109">Bulutta yerel uygulamalarda veri yönetimi</span><span class="sxs-lookup"><span data-stu-id="44083-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="44083-110">Deneyimli geliştiriciler, Şekil 5-1 ' nin sol tarafında bulunan mimariyi kolayca tanıyacaktır.</span><span class="sxs-lookup"><span data-stu-id="44083-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="44083-111">Bu *tek parçalı uygulamada*, iş hizmeti bileşenleri, tek bir ilişkisel veritabanından veri paylaşarak paylaşılan bir hizmet katmanında birlikte bir araya sahiptir.</span><span class="sxs-lookup"><span data-stu-id="44083-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="44083-112">Birçok şekilde, tek bir veritabanı veri yönetimini basit tutar.</span><span class="sxs-lookup"><span data-stu-id="44083-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="44083-113">Verileri birden çok tablo genelinde sorgulama basittir.</span><span class="sxs-lookup"><span data-stu-id="44083-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="44083-114">Veri güncelleştirmesiyle birlikte yapılan değişiklikler veya hepsi geri alma.</span><span class="sxs-lookup"><span data-stu-id="44083-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="44083-115">[ACID işlemleri](/windows/desktop/cossdk/acid-properties) güçlü ve anında tutarlılığı garanti eder.</span><span class="sxs-lookup"><span data-stu-id="44083-115">[ACID transactions](/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="44083-116">Bulutta yerel olarak tasarlamak için farklı bir yaklaşım sunuyoruz.</span><span class="sxs-lookup"><span data-stu-id="44083-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="44083-117">Şekil 5-1 ' nin sağ tarafında, iş işlevselliğinin küçük, bağımsız mikro hizmetlere nasıl ayırt edici olduğunu göz önünde ayırın.</span><span class="sxs-lookup"><span data-stu-id="44083-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="44083-118">Her mikro hizmet belirli bir iş özelliğini ve kendi verilerini kapsar.</span><span class="sxs-lookup"><span data-stu-id="44083-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="44083-119">Tek parçalı veritabanı, her biri bir mikro hizmetle hizalanan çok daha küçük veritabanları ile dağıtılmış bir veri modeline sahiptir.</span><span class="sxs-lookup"><span data-stu-id="44083-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="44083-120">Duman temizlediğinde, *mikro hizmet başına bir veritabanı*sunan tasarımla karşılaştık.</span><span class="sxs-lookup"><span data-stu-id="44083-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="database-per-microservice-why"></a><span data-ttu-id="44083-121">Veritabanı başına mikro hizmet, neden?</span><span class="sxs-lookup"><span data-stu-id="44083-121">Database-per-microservice, why?</span></span>

<span data-ttu-id="44083-122">Mikro hizmet başına bu veritabanı, özellikle hızlı bir şekilde gelişen ve büyük ölçekli ölçeklendirmeyi destekleyen sistemler için birçok avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="44083-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="44083-123">Bu modelle...</span><span class="sxs-lookup"><span data-stu-id="44083-123">With this model...</span></span>

- <span data-ttu-id="44083-124">Etki alanı verileri, hizmet içinde kapsüllenir</span><span class="sxs-lookup"><span data-stu-id="44083-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="44083-125">Veri şeması, diğer hizmetleri doğrudan etkilemeden geliştirebilirsiniz</span><span class="sxs-lookup"><span data-stu-id="44083-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="44083-126">Her veri deposu bağımsız olarak ölçeklendirilebilecek</span><span class="sxs-lookup"><span data-stu-id="44083-126">Each data store can independently scale</span></span>
- <span data-ttu-id="44083-127">Bir hizmette veri deposu hatası diğer hizmetleri doğrudan etkilemez</span><span class="sxs-lookup"><span data-stu-id="44083-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="44083-128">Verilerin ayrılması, her mikro hizmetin iş yükü, depolama ihtiyacı ve okuma/yazma desenleri için en iyi duruma getirilmiş veri depolama türünü uygulamasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="44083-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="44083-129">Seçimler ilişkisel, belge, anahtar-değer, hatta grafik tabanlı veri depoları içerir.</span><span class="sxs-lookup"><span data-stu-id="44083-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="44083-130">Şekil 5-2, bulut Yerel sisteminde çok yönlü kalıcılığı ilkesini gösterir.</span><span class="sxs-lookup"><span data-stu-id="44083-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Çok yönlü veri kalıcılığı](./media/polyglot-data-persistence.png)

<span data-ttu-id="44083-132">**Şekil 5-2**.</span><span class="sxs-lookup"><span data-stu-id="44083-132">**Figure 5-2**.</span></span> <span data-ttu-id="44083-133">Çok yönlü veri kalıcılığı</span><span class="sxs-lookup"><span data-stu-id="44083-133">Polyglot data persistence</span></span>

<span data-ttu-id="44083-134">Önceki şekilde, her mikro hizmetin farklı bir veri deposu türünü nasıl desteklediğine göz önünde.</span><span class="sxs-lookup"><span data-stu-id="44083-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="44083-135">Ürün kataloğu mikro hizmeti, temel alınan verilerinin zengin ilişkisel yapısına uyum sağlamak için bir ilişkisel veritabanı kullanır.</span><span class="sxs-lookup"><span data-stu-id="44083-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="44083-136">Alışveriş Sepeti mikro hizmeti, basit, anahtar-değer veri deposunu destekleyen bir dağıtılmış önbellek kullanır.</span><span class="sxs-lookup"><span data-stu-id="44083-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="44083-137">Sıralama mikro hizmeti, yazma işlemleri için hem NoSql belge veritabanını hem de Yüksek hacimlerdeki okuma işlemlerine uyum sağlamak için yüksek hacimli bir anahtar/değer deposu kullanır.</span><span class="sxs-lookup"><span data-stu-id="44083-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="44083-138">İlişkisel veritabanları, karmaşık verilerle mikro hizmetler için uygun olmaya devam ederken, NoSQL veritabanları önemli popülerliği kazanmıştır.</span><span class="sxs-lookup"><span data-stu-id="44083-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="44083-139">Büyük ölçekli ve yüksek kullanılabilirlik sağlarlar.</span><span class="sxs-lookup"><span data-stu-id="44083-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="44083-140">Şeicilerin, veri sınıflarının bir mimarisinden ve ORMs de daha pahalı ve zaman alıcı bir mimariden uzaklaşmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="44083-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="44083-141">Bu bölümün ilerleyen kısımlarında NoSQL veritabanları ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="44083-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="44083-142">Verileri ayrı mikro hizmetlere kapsüllemek, çevikliği, performansı ve ölçeklenebilirliği artırabilir, ayrıca birçok zorluk da sunar.</span><span class="sxs-lookup"><span data-stu-id="44083-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="44083-143">Sonraki bölümde, bu güçlükleri ve bunların üstesinden gelmelerine yardımcı olacak desenler ve uygulamalarla birlikte tartıştık.</span><span class="sxs-lookup"><span data-stu-id="44083-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="44083-144">Çapraz hizmet sorguları</span><span class="sxs-lookup"><span data-stu-id="44083-144">Cross-service queries</span></span>

<span data-ttu-id="44083-145">Mikro hizmetler bağımsızdır ve Inventory, Shipping veya sıralaması gibi belirli işlevsel yeteneklere odaklanırken, genellikle diğer mikro hizmetlerle tümleştirme gerektirir.</span><span class="sxs-lookup"><span data-stu-id="44083-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="44083-146">Genellikle tümleştirme, verileri bir tane *sorgulayan* bir mikro hizmet içerir.</span><span class="sxs-lookup"><span data-stu-id="44083-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="44083-147">Şekil 5-3, senaryoyu gösterir.</span><span class="sxs-lookup"><span data-stu-id="44083-147">Figure 5-3 shows the scenario.</span></span>

![Mikro hizmetler genelinde sorgulama](./media/cross-service-query.png)

<span data-ttu-id="44083-149">**Şekil 5-3**.</span><span class="sxs-lookup"><span data-stu-id="44083-149">**Figure 5-3**.</span></span> <span data-ttu-id="44083-150">Mikro hizmetler genelinde sorgulama</span><span class="sxs-lookup"><span data-stu-id="44083-150">Querying across microservices</span></span>

<span data-ttu-id="44083-151">Yukarıdaki şekilde, bir kullanıcının alışveriş sepetine bir öğe ekleyen bir alışveriş sepeti mikro hizmeti görüyoruz.</span><span class="sxs-lookup"><span data-stu-id="44083-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="44083-152">Bu mikro hizmet için veri deposu sepet ve satır öğesi verileri içerdiğinde, ürün veya fiyatlandırma verilerinin bakımını yapmaz.</span><span class="sxs-lookup"><span data-stu-id="44083-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="44083-153">Bunun yerine, bu veri öğeleri kataloğa ve fiyatlandırma mikro hizmetlerine aittir.</span><span class="sxs-lookup"><span data-stu-id="44083-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="44083-154">Bu bir sorunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="44083-154">This presents a problem.</span></span> <span data-ttu-id="44083-155">Alışveriş Sepeti mikro hizmeti, veritabanında ürün veya fiyatlandırma verileri yoksa kullanıcının alışveriş sepetine bir ürün ekleyebilir mi?</span><span class="sxs-lookup"><span data-stu-id="44083-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="44083-156">Bölüm 4 ' te açıklanan bir seçenek, alışveriş sepetinden kataloğa ve fiyatlandırma mikro hizmetlerine yönelik [doğrudan BIR http çağrıdır](service-to-service-communication.md#queries) .</span><span class="sxs-lookup"><span data-stu-id="44083-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="44083-157">Ancak, Bölüm 4 ' te, zaman uyumlu HTTP her *iki* mikro hizmeti birlikte çağırıyor, bağımsız çalışma sınırı ve bunların mimari avantajlarını azalttık.</span><span class="sxs-lookup"><span data-stu-id="44083-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="44083-158">Ayrıca, her hizmet için ayrı gelen ve giden kuyruklarla bir istek-yanıt modelini uygulayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="44083-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="44083-159">Ancak bu model karmaşıktır ve istek ve yanıt iletilerinin ilişkilendirilmesi için yeniden tesisat gerektirir.</span><span class="sxs-lookup"><span data-stu-id="44083-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="44083-160">Arka uç mikro hizmet çağrılarını ayırdığından, çağıran hizmetin hala zaman uyumlu olarak çağrının tamamlanmasını beklemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="44083-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="44083-161">Ağ tıkanıklığı, geçici hatalar veya aşırı yüklenmiş mikro hizmet, uzun süre çalışan ve hatta başarısız işlemlere neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="44083-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="44083-162">Bunun yerine, çapraz hizmet bağımlılıklarını kaldırmak için yaygın olarak kabul edilen bir model, Şekil 5-4 ' de gösterilen [gerçekleştirilmiş görünüm](/azure/architecture/patterns/materialized-view)düzeninizdir.</span><span class="sxs-lookup"><span data-stu-id="44083-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Gerçekleştirilmiş görünüm deseninin](./media/materialized-view-pattern.png)

<span data-ttu-id="44083-164">**Şekil 5-4**.</span><span class="sxs-lookup"><span data-stu-id="44083-164">**Figure 5-4**.</span></span> <span data-ttu-id="44083-165">Gerçekleştirilmiş Görünüm Düzeni</span><span class="sxs-lookup"><span data-stu-id="44083-165">Materialized View Pattern</span></span>

<span data-ttu-id="44083-166">Bu düzende, alışveriş sepeti hizmetine bir yerel veri tablosu ( *okuma modeli*olarak bilinir) yerleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="44083-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="44083-167">Bu tablo, ürün ve fiyatlandırma mikro hizmetlerinden gereken verilerin yoğun bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="44083-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="44083-168">Verileri doğrudan alışveriş sepeti mikro hizmetine kopyalamak, pahalı çapraz hizmet çağrıları gereksinimini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="44083-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="44083-169">Hizmetin yerel verileri ile hizmetin yanıt süresini ve güvenilirliğini artırırsınız.</span><span class="sxs-lookup"><span data-stu-id="44083-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="44083-170">Ayrıca, kendi verilerinin kopyasına sahip olmak, alışveriş sepeti hizmetini daha dayanıklı hale getirir.</span><span class="sxs-lookup"><span data-stu-id="44083-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="44083-171">Katalog hizmeti kullanılamaz hale gelirse, doğrudan alışveriş sepeti hizmetini etkilemez.</span><span class="sxs-lookup"><span data-stu-id="44083-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="44083-172">Alışveriş sepeti, kendi mağazasındaki verilerle çalışmaya devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="44083-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="44083-173">Bu yaklaşım ile catch, artık sisteminizde Yinelenen veriler olmasını sağlamak.</span><span class="sxs-lookup"><span data-stu-id="44083-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="44083-174">Ancak, bulutta yerel sistemlerdeki verileri *genel* olarak çoğaltmak, yerleşik bir uygulamadır ve bir kenar yumuşatma veya kötü uygulama olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="44083-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="44083-175">Bir *ve yalnızca bir hizmetin* bir veri kümesine sahip olabileceğini ve bu hizmetin üzerinde yetki sahibi olabileceğini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="44083-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="44083-176">Kayıt sistemi güncelleştirilirken okuma modellerini eşitlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="44083-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="44083-177">Eşitleme genellikle Şekil 5,4 ' de gösterildiği gibi, bir [Yayımlama/abonelik düzeniyle](service-to-service-communication.md#events)zaman uyumsuz mesajlaşma yoluyla uygulanır.</span><span class="sxs-lookup"><span data-stu-id="44083-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="44083-178">Dağıtılmış işlemler</span><span class="sxs-lookup"><span data-stu-id="44083-178">Distributed transactions</span></span>

<span data-ttu-id="44083-179">Mikro hizmetler genelinde verileri sorgularken çok sayıda mikro hizmette bir işlem uygulamak daha da karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="44083-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="44083-180">Farklı mikro hizmetlerde bağımsız veri kaynakları arasında veri tutarlılığı sağlamanın devralınmış bir şekilde belirtilmedi.</span><span class="sxs-lookup"><span data-stu-id="44083-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="44083-181">Bulutta yerel uygulamalarda dağıtılmış işlemlerin bulunmaması, dağıtılmış işlemleri programlı bir şekilde yönetmeniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="44083-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="44083-182">*Anında tutarlılık* dünyasının *nihai tutarlılığa*kadar ilerinizden olursunuz.</span><span class="sxs-lookup"><span data-stu-id="44083-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="44083-183">Şekil 5-5 sorunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="44083-183">Figure 5-5 shows the problem.</span></span>

![Saga düzeninde işlem](./media/saga-transaction-operation.png)

<span data-ttu-id="44083-185">**Şekil 5-5**.</span><span class="sxs-lookup"><span data-stu-id="44083-185">**Figure 5-5**.</span></span> <span data-ttu-id="44083-186">Mikro hizmetler genelinde işlem uygulama</span><span class="sxs-lookup"><span data-stu-id="44083-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="44083-187">Yukarıdaki şekilde, beş bağımsız mikro hizmet sipariş oluşturan dağıtılmış bir işleme katılır.</span><span class="sxs-lookup"><span data-stu-id="44083-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="44083-188">Her mikro hizmet kendi veri mağazasını tutar ve kendi deposu için yerel bir işlem uygular.</span><span class="sxs-lookup"><span data-stu-id="44083-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="44083-189">Siparişi oluşturmak için, *her* bir mikro hizmetin yerel işleminin başarılı olması veya *tümünün* iptal edilmesi ve işlemi geri toplaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="44083-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="44083-190">Mikro hizmetlerin her birinde yerleşik işlem desteği kullanılabilir olsa da, verilerin tutarlı tutulması için beş hizmetin tamamına yayılabilen dağıtılmış bir işlem desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="44083-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="44083-191">Bunun yerine, bu dağıtılmış işlemi *programlı olarak*oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="44083-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="44083-192">Dağıtılmış işlem desteği eklemek için popüler bir düzende Saga deseninin olması önerilir.</span><span class="sxs-lookup"><span data-stu-id="44083-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="44083-193">Yerel işlemler programlı bir şekilde gruplanarak ve her birini sırayla çağırarak uygulanır.</span><span class="sxs-lookup"><span data-stu-id="44083-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="44083-194">Herhangi bir yerel işlem başarısız olursa, Saga işlemi iptal eder ve bir [dengeleyici](/azure/architecture/patterns/compensating-transaction)işlem kümesi çağırır.</span><span class="sxs-lookup"><span data-stu-id="44083-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="44083-195">Telafi işlemleri, önceki yerel işlemler tarafından yapılan değişiklikleri geri alır ve veri tutarlılığını geri yükler.</span><span class="sxs-lookup"><span data-stu-id="44083-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="44083-196">Şekil 5-6, Saga düzeniyle başarısız olan bir işlemi gösterir.</span><span class="sxs-lookup"><span data-stu-id="44083-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Saga düzenine geri alma](./media/saga-rollback-operation.png)

<span data-ttu-id="44083-198">**Şekil 5-6**.</span><span class="sxs-lookup"><span data-stu-id="44083-198">**Figure 5-6**.</span></span> <span data-ttu-id="44083-199">Bir işlem geri alınıyor</span><span class="sxs-lookup"><span data-stu-id="44083-199">Rolling back a transaction</span></span>

<span data-ttu-id="44083-200">Önceki şekilde Inventory mikro hizmetinde *Envanter güncelleştirme* işlemi başarısız oldu.</span><span class="sxs-lookup"><span data-stu-id="44083-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="44083-201">Saga, envanter sayılarını ayarlamak için bir dengeleyici işlem kümesi (kırmızı renkte) çağırır, ödemeyi ve siparişi iptal eder ve her bir mikro hizmet için verileri tutarlı bir duruma geri döndürür.</span><span class="sxs-lookup"><span data-stu-id="44083-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="44083-202">Saga desenleri genellikle bir dizi ilgili olay olarak veya bir ilgili komut kümesi olarak düzenlenir.</span><span class="sxs-lookup"><span data-stu-id="44083-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="44083-203">Bölüm 4 ' te, genişletilmiş bir Saga uygulamasının temeli olacak hizmet toplayıcısı modelini tartıştık.</span><span class="sxs-lookup"><span data-stu-id="44083-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="44083-204">Ayrıca, Azure Service Bus ve Azure Event Grid konuları ve bu da, choretik bir Saga uygulamasının bir temeli olacak konular ile de tartışıldık.</span><span class="sxs-lookup"><span data-stu-id="44083-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="44083-205">Yüksek hacimli veriler</span><span class="sxs-lookup"><span data-stu-id="44083-205">High volume data</span></span>

<span data-ttu-id="44083-206">Büyük ölçekli bulutta yerel uygulamalar genellikle yüksek hacimli veri gereksinimlerini destekler.</span><span class="sxs-lookup"><span data-stu-id="44083-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="44083-207">Bu senaryolarda geleneksel veri depolama teknikleri performans sorunlarına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="44083-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="44083-208">Büyük ölçekte dağıtım yapan karmaşık sistemler için Komut ve Sorgu Sorumluluklarının Ayrılığı (CQRS) ve olay kaynağını belirleme uygulama performansını iyileştirebilir.</span><span class="sxs-lookup"><span data-stu-id="44083-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="44083-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="44083-209">CQRS</span></span>

<span data-ttu-id="44083-210">[CQRS](/azure/architecture/patterns/cqrs), performansı, ölçeklenebilirliği ve güvenliği en üst düzeye çıkarmaya yardımcı olabilecek mimari bir modeldir.</span><span class="sxs-lookup"><span data-stu-id="44083-210">[CQRS](/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="44083-211">Model, verileri yazan işlemlerden verileri okuyan işlemleri ayırır.</span><span class="sxs-lookup"><span data-stu-id="44083-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="44083-212">Normal senaryolarda, hem okuma hem *de* yazma işlemleri için aynı varlık modeli ve veri deposu nesnesi kullanılır.</span><span class="sxs-lookup"><span data-stu-id="44083-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="44083-213">Ancak, yüksek hacimli bir veri senaryosu, okuma ve yazma işlemleri için ayrı modellerden ve veri tablolarından faydalanabilir.</span><span class="sxs-lookup"><span data-stu-id="44083-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="44083-214">Performansı artırmak için okuma işlemi, pahalı yinelenen tablo birleştirmeleri ve tablo kilitlerinin önüne geçmek amacıyla verilerin yüksek oranda büyük bir gösterimine karşı sorgulayabilir.</span><span class="sxs-lookup"><span data-stu-id="44083-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="44083-215">*Komut*olarak bilinen *yazma* işlemi, tutarlılığı güvence altına alan verilerin tamamen normalleştirilmiş bir gösterimine karşı güncelleştirilir.</span><span class="sxs-lookup"><span data-stu-id="44083-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="44083-216">Daha sonra her iki gösterimi de eşitlenmiş halde tutmak için bir mekanizma uygulamanız gerekir. Genellikle, yazma tablosu değiştirildiğinde, değişikliği okuma tablosuna çoğaltan bir olay yayınlar.</span><span class="sxs-lookup"><span data-stu-id="44083-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="44083-217">Şekil 5-7, CQRS deseninin bir uygulamasını gösterir.</span><span class="sxs-lookup"><span data-stu-id="44083-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![Komut ve Sorgu Sorumluluklarının Ayrılığı](./media/cqrs-implementation.png)

<span data-ttu-id="44083-219">**Şekil 5-7**.</span><span class="sxs-lookup"><span data-stu-id="44083-219">**Figure 5-7**.</span></span> <span data-ttu-id="44083-220">CQRS uygulama</span><span class="sxs-lookup"><span data-stu-id="44083-220">CQRS implementation</span></span>

<span data-ttu-id="44083-221">Önceki şekilde, ayrı komut ve sorgu modelleri uygulanır.</span><span class="sxs-lookup"><span data-stu-id="44083-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="44083-222">Her veri yazma işlemi, yazma deposuna kaydedilir ve sonra okuma deposuna yayılır.</span><span class="sxs-lookup"><span data-stu-id="44083-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="44083-223">Veri yayma işleminin [nihai tutarlılık](https://www.cloudcomputingpatterns.org/eventual_consistency/)ilkesi üzerinde nasıl çalıştığı hakkında daha fazla dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="44083-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="44083-224">Okuma modeli, sonunda yazma modeliyle eşitlenir, ancak işlemde bazı gecikme olabilir.</span><span class="sxs-lookup"><span data-stu-id="44083-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="44083-225">Sonraki bölümde nihai tutarlılığı tartıştık.</span><span class="sxs-lookup"><span data-stu-id="44083-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="44083-226">Bu ayrım, okuma ve yazma işlemlerini bağımsız olarak ölçeklendirmeye olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="44083-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="44083-227">Okuma işlemleri sorgularda en iyi duruma getirilmiş şemayı kullanır, yazma işlemleri güncelleştirmeler için iyileştirilmiş bir şema kullanır.</span><span class="sxs-lookup"><span data-stu-id="44083-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="44083-228">Okuma sorguları, yoğun verilere karşı, karmaşık iş mantığı ise yazma modeline uygulanabilirler.</span><span class="sxs-lookup"><span data-stu-id="44083-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="44083-229">Ayrıca, yazma işlemlerinde, okumaların açığa çıkarmadan daha sıkı güvenlik sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="44083-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="44083-230">CQRS 'nin uygulanması, bulutta yerel hizmetler için uygulama performansını iyileştirebilir.</span><span class="sxs-lookup"><span data-stu-id="44083-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="44083-231">Ancak, daha karmaşık bir tasarıma neden olur.</span><span class="sxs-lookup"><span data-stu-id="44083-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="44083-232">Bu ilkeyi, buluttan faydalanabilecek bulut Yerel uygulamanızın bölümlerine dikkatle ve stratejik bir şekilde uygulayın.</span><span class="sxs-lookup"><span data-stu-id="44083-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="44083-233">CQRS hakkında daha fazla bilgi için bkz. Microsoft Book [.net mikro hizmetleri: Kapsayıcılı .NET uygulamaları Için mimari](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md).</span><span class="sxs-lookup"><span data-stu-id="44083-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](../microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns.md).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="44083-234">Olay kaynağını belirleme</span><span class="sxs-lookup"><span data-stu-id="44083-234">Event sourcing</span></span>

<span data-ttu-id="44083-235">Yüksek hacimli veri senaryolarını iyileştirmeye yönelik başka bir yaklaşım da [olay](/azure/architecture/patterns/event-sourcing)kaynağını içerir.</span><span class="sxs-lookup"><span data-stu-id="44083-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="44083-236">Bir sistem genellikle bir veri varlığının geçerli durumunu depolar.</span><span class="sxs-lookup"><span data-stu-id="44083-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="44083-237">Kullanıcı telefon numarasını değiştirirse (örneğin, müşteri kaydı yeni sayıyla güncelleştirilir).</span><span class="sxs-lookup"><span data-stu-id="44083-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="44083-238">Her zaman bir veri varlığının geçerli durumunu biliyoruz, ancak her güncelleştirme önceki durumun üzerine yazar.</span><span class="sxs-lookup"><span data-stu-id="44083-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="44083-239">Çoğu durumda bu model sorunsuz bir şekilde çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="44083-239">In most cases, this model works fine.</span></span> <span data-ttu-id="44083-240">Ancak, yüksek hacimli sistemlerde, işlemsel kilitleme ve sık sık güncelleştirme işlemlerinden gelen ek yük veritabanı performansını, yanıt hızını ve sınır ölçeklenebilirliğini etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="44083-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="44083-241">Olay kaynağını belirleme, verileri yakalamaya yönelik farklı bir yaklaşım alır.</span><span class="sxs-lookup"><span data-stu-id="44083-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="44083-242">Verileri etkileyen her işlem, bir olay deposunda kalıcı hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="44083-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="44083-243">Bir veri kaydının durumunu güncelleştirmek yerine, her bir değişikliği geçmiş olayların sıralı listesine (muhasebecinin defterine benzer şekilde) ekler.</span><span class="sxs-lookup"><span data-stu-id="44083-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="44083-244">Olay deposu, verilerin kayıt sistemi haline gelir.</span><span class="sxs-lookup"><span data-stu-id="44083-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="44083-245">Bir mikro hizmetin sınırlanmış bağlamı içinde çeşitli gerçekleştirilmiş görünümler yaymak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="44083-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="44083-246">Şekil 5,8, deseninin gösterildiği.</span><span class="sxs-lookup"><span data-stu-id="44083-246">Figure 5.8 shows the pattern.</span></span>

![Olay Kaynağını Belirleme](./media/event-sourcing.png)

<span data-ttu-id="44083-248">**Şekil 5-8**.</span><span class="sxs-lookup"><span data-stu-id="44083-248">**Figure 5-8**.</span></span> <span data-ttu-id="44083-249">Olay Kaynağını Belirleme</span><span class="sxs-lookup"><span data-stu-id="44083-249">Event Sourcing</span></span>

<span data-ttu-id="44083-250">Önceki şekilde, bir kullanıcının alışveriş sepeti için her girdinin (mavi), temel alınan bir olay deposuna nasıl eklendiği konusunda bir değer olduğunu aklınızda saklayın.</span><span class="sxs-lookup"><span data-stu-id="44083-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="44083-251">Bitişik gerçekleştirilmiş görünümde, sistem, her bir alışveriş sepeti ile ilişkili tüm olayları yeniden kaydederek geçerli durumu projeler halinde gösterir.</span><span class="sxs-lookup"><span data-stu-id="44083-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="44083-252">Bu görünüm veya okuma modeli, daha sonra Kullanıcı arabirimine geri sunulur.</span><span class="sxs-lookup"><span data-stu-id="44083-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="44083-253">Olaylar ayrıca, dış sistemlerle ve uygulamalarla tümleştirilebilir veya bir varlığın geçerli durumunu tespit etmek üzere sorgulanamaz.</span><span class="sxs-lookup"><span data-stu-id="44083-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="44083-254">Bu yaklaşımda geçmişi korursunuz.</span><span class="sxs-lookup"><span data-stu-id="44083-254">With this approach, you maintain history.</span></span> <span data-ttu-id="44083-255">Bir varlığın yalnızca geçerli durumunu değil, Ayrıca bu duruma nasıl erişeceğimizi bilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="44083-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="44083-256">Olayların kaynağını belirleme, olay kaynağını belirleme yazma modelini basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="44083-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="44083-257">Güncelleştirme veya silme yok.</span><span class="sxs-lookup"><span data-stu-id="44083-257">There are no updates or deletes.</span></span> <span data-ttu-id="44083-258">Her veri girişini değişmez bir olay olarak eklemek, çakışma, kilitleme ve ilişkisel veritabanlarıyla ilişkili eşzamanlılık çakışmalarını en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="44083-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="44083-259">Gerçekleştirilmiş görünüm düzeniyle okuma modellerinin oluşturulması, görünümü yazma modelinden ayırarak, uygulama kullanıcı arabirimi ihtiyaçlarını iyileştirmek için en iyi veri deposunu seçmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="44083-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="44083-260">Bu model için doğrudan olay kaynağını destekleyen bir veri deposu düşünün.</span><span class="sxs-lookup"><span data-stu-id="44083-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="44083-261">Azure Cosmos DB, MongoDB, Cassandra, Couşdb ve kvendb iyi adaylardır.</span><span class="sxs-lookup"><span data-stu-id="44083-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="44083-262">Tüm desenlerdeki ve teknolojilerde olduğu gibi, gerekli olduğunda stratejik bir şekilde uygulayın.</span><span class="sxs-lookup"><span data-stu-id="44083-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="44083-263">Olay kaynağını artırmak daha yüksek performans ve ölçeklenebilirlik sağlayabiliyor olsa da karmaşıklık ve öğrenme eğrisinin masrafına gelir.</span><span class="sxs-lookup"><span data-stu-id="44083-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="44083-264">[Önceki](service-mesh-communication-infrastructure.md) 
> [Sonraki](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="44083-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
