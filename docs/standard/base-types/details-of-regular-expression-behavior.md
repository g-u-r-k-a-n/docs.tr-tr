---
title: Normal İfade davranışı
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 0273d16028315452e35f83086dbc134d6fcb66c6
ms.sourcegitcommit: 1c1a1f9ec0bd1efb3040d86a79f7ee94e207cca5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/03/2020
ms.locfileid: "80635983"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="4be26-102">Normal ifade davranışının ayrıntıları</span><span class="sxs-lookup"><span data-stu-id="4be26-102">Details of regular expression behavior</span></span>

<span data-ttu-id="4be26-103">.NET Framework düzenli ifade altyapısı, Perl, Python, Emacs ve Tcl tarafından kullanılan geleneksel Nondeterministic Sonlu Automaton (NFA) motorunu birleştiren bir geri izleme düzenli ifade eşleştirmesidir.</span><span class="sxs-lookup"><span data-stu-id="4be26-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="4be26-104">Bu daha hızlı, ama daha sınırlı, saf düzenli ifade Deterministic Sonlu Automaton (DFA) bu awk, egrep veya lex bulunan gibi motorları ayırır.</span><span class="sxs-lookup"><span data-stu-id="4be26-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="4be26-105">Bu da standart, ama yavaş, POSIX NFAs onu ayırır.</span><span class="sxs-lookup"><span data-stu-id="4be26-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="4be26-106">Aşağıdaki bölümde üç tür normal ifade altyapısı açıklanır ve .NET Framework'deki normal ifadelerin neden geleneksel bir NFA altyapısı kullanılarak uygulandığı açıklanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="4be26-107">NFA motorunun faydaları</span><span class="sxs-lookup"><span data-stu-id="4be26-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="4be26-108">DFA motorları desen eşleştirme gerçekleştirdiğinde, işlem sıraları giriş dizesi tarafından çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="4be26-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="4be26-109">Motor giriş dizesinin başında başlar ve bir sonraki karakterin normal ifade deseniyle eşleşip eşleşmediğini belirlemek için sırayla ilerler.</span><span class="sxs-lookup"><span data-stu-id="4be26-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="4be26-110">Onlar mümkün olan en uzun dize maç için garanti edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4be26-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="4be26-111">Aynı karakteri asla iki kez test etmedikleri için, DFA motorları geri izlemeyi desteklemez.</span><span class="sxs-lookup"><span data-stu-id="4be26-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="4be26-112">Ancak, bir DFA altyapısı yalnızca sonlu durum içerdiğinden, bir deseni geri başvurularla eşleştiremez ve açık bir genişletme oluşturmadığından, alt ifadeleri yakalayamaz.</span><span class="sxs-lookup"><span data-stu-id="4be26-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="4be26-113">DFA motorlarının aksine, geleneksel NFA motorları desen eşleştirme gerçekleştirdiğinde, işleme sırası normal ifade deseni tarafından yönlendirilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="4be26-114">Belirli bir dil öğesini işlerken, motor açgözlü eşleştirme kullanır; diğer bir deyişle, giriş dizesinin mümkün olduğunca çok eşleşir.</span><span class="sxs-lookup"><span data-stu-id="4be26-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="4be26-115">Ama aynı zamanda başarıyla bir alt ifade eşleştirdikten sonra durumunu kaydeder.</span><span class="sxs-lookup"><span data-stu-id="4be26-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="4be26-116">Bir eşleşme sonunda başarısız olursa, ek eşleşmeleri deneyebilmek için motor kaydedilmiş bir duruma dönebilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="4be26-117">Daha sonra normal ifadedeki dil öğelerinin de eşleşebilmesi için başarılı bir alt ifade eşleşmesini terk etme işlemi *geri izleme*olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="4be26-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="4be26-118">NFA motorları, normal bir ifadenin olası tüm açılımlarını belirli bir sırada test etmek ve ilk eşleşmeyi kabul etmek için geri izleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="4be26-119">Geleneksel bir NFA altyapısı başarılı bir eşleşme için normal ifadenin belirli bir genişlemesini oluşturduğundan, alt ifade eşleşmelerini ve eşleşen geri başvuruları yakalayabilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="4be26-120">Ancak, geleneksel bir NFA geri adım attığı için, farklı yollar üzerinden eyalete ulaştığında aynı durumu birden çok kez ziyaret edebilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="4be26-121">Sonuç olarak, en kötü durumda katlanarak yavaş çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4be26-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="4be26-122">Geleneksel bir NFA altyapısı bulduğu ilk eşleşmeyi kabul ettiği için, diğer (muhtemelen daha uzun) eşleşmeleri de keşfedilmemiş olarak bırakabilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="4be26-123">POSIX NFA motorları geleneksel NFA motorları gibidir, ancak mümkün olan en uzun eşleşmeyi bulduklarını garanti edene kadar geri dönmeye devam ederler.</span><span class="sxs-lookup"><span data-stu-id="4be26-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="4be26-124">Sonuç olarak, bir POSIX NFA motoru geleneksel NFA motorundan daha yavaştır ve bir POSIX NFA motoru kullandığınızda, geri izleme aramasının sırasını değiştirerek daha kısa bir eşleşmeyi daha uzun bir eşleşmeye tercih edemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="4be26-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="4be26-125">Geleneksel NFA motorları programcılar tarafından tercih edilir çünkü dize eşleştirme üzerinde DFA veya POSIX NFA motorlarına göre daha fazla kontrol sağlarlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="4be26-126">En kötü durumda, yavaş çalışmasına rağmen, belirsizlikleri azaltan ve geri izlemeyi sınırlayan desenler kullanarak doğrusal veya polinom zamanında kibritleri bulmalarını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4be26-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="4be26-127">Başka bir deyişle, NFA motorları güç ve esneklik için performans ticareti olsa da, çoğu durumda normal bir ifade iyi yazılmışsa ve geri izlemenin performansı katlanarak düşüren durumlardan kaçınırsa, kabul edilebilir performans alameti sunarlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="4be26-128">Aşırı geri izlemenin neden olduğu performans cezası ve bunların etrafında çalışmak için düzenli bir ifade oluşturma yolları hakkında bilgi [için](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)Bkz.</span><span class="sxs-lookup"><span data-stu-id="4be26-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>

## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="4be26-129">.NET Framework motor yetenekleri</span><span class="sxs-lookup"><span data-stu-id="4be26-129">.NET Framework engine capabilities</span></span>

 <span data-ttu-id="4be26-130">Geleneksel bir NFA altyapısının avantajlarından yararlanmak için ,NET Framework normal ifade altyapısı, programcıların geri izleme motorını yönlendirmesini sağlamak için eksiksiz bir yapı kümesi içerir.</span><span class="sxs-lookup"><span data-stu-id="4be26-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="4be26-131">Bu yapılar daha hızlı eşleşmeleri bulmak veya diğerleri ne göre belirli açılımları lehine kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="4be26-132">.NET Framework normal ifade altyapısının diğer özellikleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="4be26-132">Other features of the .NET Framework regular expression engine include the following:</span></span>

- <span data-ttu-id="4be26-133">Tembel ölçütler: `??` `*?`, `+?` `{`, , *n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="4be26-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="4be26-134">Bu yapılar, geri izleme motoruna önce en az tekrar sayısını aramasını söyler.</span><span class="sxs-lookup"><span data-stu-id="4be26-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="4be26-135">Buna karşılık, sıradan açgözlü niceleyiciler ilk tekrarları maksimum sayıda maç deneyin.</span><span class="sxs-lookup"><span data-stu-id="4be26-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="4be26-136">Aşağıdaki örnek, ikisi arasındaki farkı göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="4be26-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="4be26-137">Normal bir ifade, bir sayıyla biten bir cümleyle eşleşir ve yakalama grubu bu sayıyı ayıklamak için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="4be26-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="4be26-138">Normal ifade, `.+(\d+)\.` normal ifade altyapısının `.+`sayının yalnızca son basamağı yakalamasına neden olan açgözlü niceleyiciyi içerir.</span><span class="sxs-lookup"><span data-stu-id="4be26-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="4be26-139">Buna karşılık, normal `.+?(\d+)\.` ifade tembel niceleyici `.+?`içerir , hangi tüm sayı yakalamak için düzenli ifade altyapısı neden olur.</span><span class="sxs-lookup"><span data-stu-id="4be26-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="4be26-140">Bu normal ifadenin açgözlü ve tembel sürümleri aşağıdaki tabloda gösterildiği gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="4be26-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="4be26-141">Desen</span><span class="sxs-lookup"><span data-stu-id="4be26-141">Pattern</span></span>|<span data-ttu-id="4be26-142">Açıklama</span><span class="sxs-lookup"><span data-stu-id="4be26-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="4be26-143">`.+`(açgözlü niceleyici)</span><span class="sxs-lookup"><span data-stu-id="4be26-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="4be26-144">Herhangi bir karakterin en az bir oluşumunu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="4be26-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="4be26-145">Bu, normal ifade altyapısının tüm dizeyle eşleşmesine ve ardından desenin geri kalanını eşleştirmek için gerektiği gibi geri izlemesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="4be26-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="4be26-146">`.+?`(tembel niceleyici)</span><span class="sxs-lookup"><span data-stu-id="4be26-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="4be26-147">Herhangi bir karakterin en az bir oluşumunu eşleştirin, ancak mümkün olduğunca az eşleşme.</span><span class="sxs-lookup"><span data-stu-id="4be26-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="4be26-148">En az bir sayısal karakteri eşleştirin ve ilk yakalama grubuna atayın.</span><span class="sxs-lookup"><span data-stu-id="4be26-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="4be26-149">Bir periyodu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="4be26-149">Match a period.</span></span>|

     <span data-ttu-id="4be26-150">Tembel niceleyiciler hakkında daha fazla bilgi için, [Niceleyiciler](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="4be26-151">Pozitif lookahead: `(?=` *alt ifade*`)`.</span><span class="sxs-lookup"><span data-stu-id="4be26-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="4be26-152">Bu özellik, geri izleme altyapısının bir alt ifadeyi eşleştirdikten sonra metindeki aynı noktaya dönmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="4be26-153">Aynı konumdan başlayan birden çok delemi doğrulayarak metin boyunca arama yapmak yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="4be26-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="4be26-154">Ayrıca, motorun eşleşen metne substring dahil etmeden maçın sonunda bir alt dize olduğunu doğrulamak için izin verir.</span><span class="sxs-lookup"><span data-stu-id="4be26-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="4be26-155">Aşağıdaki örnek, noktalama işaretleri tarafından takip edilmeyen bir cümledeki sözcükleri ayıklamak için pozitif bakış kullanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="4be26-156">Normal ifade `\b[A-Z]+\b(?=\P{P})` aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="4be26-157">Desen</span><span class="sxs-lookup"><span data-stu-id="4be26-157">Pattern</span></span>|<span data-ttu-id="4be26-158">Açıklama</span><span class="sxs-lookup"><span data-stu-id="4be26-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="4be26-159">Bir sözcük sınırında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="4be26-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="4be26-160">Herhangi bir alfabetik karakteri bir veya daha fazla kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="4be26-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="4be26-161"><xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> Yöntem <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> seçeneği ile çağrıldığından, karşılaştırma büyük/küçük harf duyarsız.</span><span class="sxs-lookup"><span data-stu-id="4be26-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="4be26-162">Eşlemeyi bir sözcük sınırında sonlandır.</span><span class="sxs-lookup"><span data-stu-id="4be26-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="4be26-163">Bir sonraki karakterin noktalama işareti simgesi olup olmadığını belirlemek için ileriye bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="4be26-164">Değilse, eşleşme başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="4be26-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="4be26-165">Olumlu ileriye dönük iddialar hakkında daha fazla bilgi için, [Gruplandırma Yapıları'na](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="4be26-166">Negatif lookahead: `(?!` *alt ifade*`)`.</span><span class="sxs-lookup"><span data-stu-id="4be26-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="4be26-167">Bu özellik, yalnızca bir alt ifade eşleşmezse bir ifadeyi eşleştirme özelliği ekler.</span><span class="sxs-lookup"><span data-stu-id="4be26-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="4be26-168">Bu, bir aramayı budama için güçlüdür, çünkü eklenmesi gereken durumlar için bir ifadeden daha ortadan kaldırılması gereken bir servis talebi için ifade sağlamak genellikle daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="4be26-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="4be26-169">Örneğin, "non" ile başlamayan sözcükler için bir ifade yazmak zordur.</span><span class="sxs-lookup"><span data-stu-id="4be26-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="4be26-170">Aşağıdaki örnek, bunları dışlamak için negatif gözcü kullanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="4be26-171">Normal ifade `\b(?!non)\w+\b` deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="4be26-172">Desen</span><span class="sxs-lookup"><span data-stu-id="4be26-172">Pattern</span></span>|<span data-ttu-id="4be26-173">Açıklama</span><span class="sxs-lookup"><span data-stu-id="4be26-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="4be26-174">Bir sözcük sınırında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="4be26-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="4be26-175">Geçerli dize "non" ile başlamadığından emin olmak için ileriye bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="4be26-176">Olursa, eşleşme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="4be26-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="4be26-177">Bir veya daha fazla sözcük karakteri eşleştir.</span><span class="sxs-lookup"><span data-stu-id="4be26-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="4be26-178">Eşlemeyi bir sözcük sınırında sonlandır.</span><span class="sxs-lookup"><span data-stu-id="4be26-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="4be26-179">Negatif ileriye dönük iddialar hakkında daha fazla bilgi için, [Gruplandırma Yapıları'na](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="4be26-180">Koşullu değerlendirme: `(?(` *ifade*`)` `(?(`*evet*`|`*hayır* `)` ve *isim*`)`*evet*`|`*hayır*`)`, *ifade* eşleşecek bir alt ifade olduğu yerde, *adı* bir yakalama grubunun adıdır, *evet* *ifade* eşleşen veya *adı* geçerli, boş olmayan yakalanan grup ise eşleşecek dize ve *hayır* *ifade* eşleşen değilse eşleşen alt ifade veya *ad* geçerli, boş olmayan yakalanan grup değildir.</span><span class="sxs-lookup"><span data-stu-id="4be26-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="4be26-181">Bu özellik, önceki bir alt ifade eşleşmesinin veya sıfır genişlikli bir iddianın sonucuna bağlı olarak, motorun birden fazla alternatif desen kullanarak arama yapmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="4be26-182">Bu, örneğin, önceki bir alt ifadenin eşleşip eşleşmediğine bağlı bir alt ifadeyi eşleştirmeye izin veren daha güçlü bir geri gönderme biçimine izin verir.</span><span class="sxs-lookup"><span data-stu-id="4be26-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="4be26-183">Aşağıdaki örnekteki normal ifade, hem genel hem de dahili kullanım için tasarlanmış paragraflarla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="4be26-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="4be26-184">Yalnızca dahili kullanım için tasarlanan `<PRIVATE>` paragraflar bir etiketle başlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="4be26-185">Normal ifade `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` deseni, genel ve yakalama gruplarını ayırmak için dahili kullanıma yönelik paragrafların içeriğini atamak için koşullu değerlendirme kullanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="4be26-186">Bu paragraflar daha sonra farklı işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="4be26-187">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="4be26-188">Desen</span><span class="sxs-lookup"><span data-stu-id="4be26-188">Pattern</span></span>|<span data-ttu-id="4be26-189">Açıklama</span><span class="sxs-lookup"><span data-stu-id="4be26-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="4be26-190">Maça bir çizginin başında başlayın.</span><span class="sxs-lookup"><span data-stu-id="4be26-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="4be26-191">Bir beyaz boşluk karakteri `<PRIVATE>` ardından dize sıfır veya bir olay maç.</span><span class="sxs-lookup"><span data-stu-id="4be26-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="4be26-192">Eşleşmeyi bir yakalama grubuna `Pvt`ata.</span><span class="sxs-lookup"><span data-stu-id="4be26-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="4be26-193">`Pvt` Yakalama grubu varsa, bir veya daha fazla sözcük karakterinin bir veya daha fazla oluşumunu eşleştirin ve ardından sıfır veya bir noktalama ayırıcısı ve ardından beyaz boşluk karakteri eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="4be26-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="4be26-194">Substring'i ilk yakalama grubuna atayın.</span><span class="sxs-lookup"><span data-stu-id="4be26-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="4be26-195">`Pvt` Yakalama grubu yoksa, bir veya daha fazla sözcük karakterinin bir veya daha fazla oluşumunu eşleştirin ve ardından sıfır veya bir noktalama işaretçisi ve ardından beyaz boşluk karakteri yle eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="4be26-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="4be26-196">Alt dizeyi üçüncü yakalama grubuna atayın.</span><span class="sxs-lookup"><span data-stu-id="4be26-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="4be26-197">Bir çizginin sonu veya dize sonu maç.</span><span class="sxs-lookup"><span data-stu-id="4be26-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="4be26-198">Koşullu değerlendirme hakkında daha fazla bilgi için [alternation Constructs'a](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="4be26-199">Grup tanımlarını `(?<`dengeleme: *name1*`-`*name2* `>` alt *ifadesi*`)`.</span><span class="sxs-lookup"><span data-stu-id="4be26-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="4be26-200">Bu özellik, normal ifade altyapısının parantez veya açma ve kapama ayraçları gibi iç içe yapıları izlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="4be26-201">Örneğin, [yapıoluşturma yı](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)bünyelerine bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="4be26-202">Atomik gruplar: `(?>` *alt ifade*`)`.</span><span class="sxs-lookup"><span data-stu-id="4be26-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="4be26-203">Bu özellik, geri izleme altyapısının, bir alt ifadenin, ifadenin içerdiği ifadeden bağımsız olarak çalışıyormuş gibi, bu alt ifade için bulunan yalnızca ilk eşleşmeyle eşleştiğini garanti etmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="4be26-204">Bu yapıyı kullanmazsanız, aramaları daha büyük ifadeden geri izleme bir alt ifadenin davranışını değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="4be26-205">Örneğin, normal ifade `(a+)\w` bir veya daha fazla "a" karakteriyle eşleşir ve "a" karakterleri dizisini izleyen bir sözcük karakteriyle eşleşir ve ilk yakalama grubuna "a" karakter dizisini atar.</span><span class="sxs-lookup"><span data-stu-id="4be26-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="4be26-206">Ancak, giriş dizesinin son karakteri de "a" ise, `\w` dil öğesiyle eşleşir ve yakalanan gruba dahil edilmez.</span><span class="sxs-lookup"><span data-stu-id="4be26-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="4be26-207">Normal ifade `((?>a+))\w` bu davranışı engeller.</span><span class="sxs-lookup"><span data-stu-id="4be26-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="4be26-208">Ardışık tüm "a" karakterleri geri izleme olmadan eşleştirildiklerinden, ilk yakalama grubu tüm ardışık "a" karakterlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="4be26-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="4be26-209">"A" karakterleri "a" dışında en az bir karakter daha takip edilmezse, eşleşme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="4be26-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="4be26-210">Atomik gruplar hakkında daha fazla bilgi için [bkz.](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)</span><span class="sxs-lookup"><span data-stu-id="4be26-210">For more information about atomic groups, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="4be26-211">Bir <xref:System.Text.RegularExpressions.Regex> sınıf oluşturucu veya statik örnek eşleştirme <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> yöntemi seçeneği sağlayarak belirtilen sağdan sola eşleştirme.</span><span class="sxs-lookup"><span data-stu-id="4be26-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="4be26-212">Bu özellik, soldan sağa yerine sağdan sola arama yaparken veya desenin sol yerine sağ kısmında eşleşmebaşlatmanın daha verimli olduğu durumlarda yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="4be26-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="4be26-213">Aşağıdaki örnekte de gösterildiği gibi, sağdan sola eşleştirme kullanarak açgözlü niceleyicilerin davranışını değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4be26-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="4be26-214">Örnek, bir sayıyla biten bir cümle için iki arama yapar.</span><span class="sxs-lookup"><span data-stu-id="4be26-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="4be26-215">Açgözlü nicel'i kullanan soldan sağa arama, `+` cümledeki altı basamaktan biriyle eşleşirken, sağdan sola arama altı basamakla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="4be26-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="4be26-216">Normal ifade deseninin açıklaması için, bu bölümde daha önce tembel niceleyicileri gösteren örneğe bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="4be26-217">Sağdan sola eşleştirme hakkında daha fazla bilgi için [Normal İfade Seçenekleri'ne](../../../docs/standard/base-types/regular-expression-options.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-217">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>

- <span data-ttu-id="4be26-218">Olumlu ve negatif `(?<=`bakış: pozitif bakış için `(?<!`alt *ifade* `)` ve negatif bakış için alt *ifade.* `)`</span><span class="sxs-lookup"><span data-stu-id="4be26-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="4be26-219">Bu özellik, bu konuda daha önce tartışılan ileriye benzer.</span><span class="sxs-lookup"><span data-stu-id="4be26-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="4be26-220">Normal ifade altyapısı tam sağdan sola eşleştirmeye izin verdiğinden, normal ifadeler sınırsız bakışlara izin verir.</span><span class="sxs-lookup"><span data-stu-id="4be26-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="4be26-221">İç içe geçen alt ifade bir dış ifadenin bir üst kümesi olduğunda, iç içe geçme ölçütlerini önlemek için pozitif ve negatif görünüm de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="4be26-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="4be26-222">Bu tür iç içe niceleyiciler ile düzenli ifadeler genellikle kötü performans sunuyoruz.</span><span class="sxs-lookup"><span data-stu-id="4be26-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="4be26-223">Örneğin, aşağıdaki örnek, bir dize nin alfasayısal bir karakterle başlayıp bittiğini ve dizedeki diğer herhangi bir karakterin daha büyük bir alt kümeden biri olduğunu doğrular.</span><span class="sxs-lookup"><span data-stu-id="4be26-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="4be26-224">E-posta adreslerini doğrulamak için kullanılan normal ifadenin bir bölümünü oluşturur; daha fazla bilgi için [bkz: Dizeleri Geçerli E-posta Biçiminde olduğunu doğrulayın.](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md)</span><span class="sxs-lookup"><span data-stu-id="4be26-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="4be26-225">Normal ifade ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="4be26-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="4be26-226">Desen</span><span class="sxs-lookup"><span data-stu-id="4be26-226">Pattern</span></span>|<span data-ttu-id="4be26-227">Açıklama</span><span class="sxs-lookup"><span data-stu-id="4be26-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="4be26-228">Dize başında maç başlayın.</span><span class="sxs-lookup"><span data-stu-id="4be26-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="4be26-229">Herhangi bir sayısal veya alfanümerik karakteri eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="4be26-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="4be26-230">(Karşılaştırma büyük/küçük harf duyarsızdır.)</span><span class="sxs-lookup"><span data-stu-id="4be26-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="4be26-231">Herhangi bir sözcük karakterinin veya aşağıdaki karakterlerden herhangi birinin sıfır veya daha fazla oluşumlarını \*eşleştirin: -, !, #, $, %, &, ', ., +, /, =, ?, ^, &#96;, {, }, &#124; veya ~.</span><span class="sxs-lookup"><span data-stu-id="4be26-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="4be26-232">Sayısal veya alfanümerik olmalıdır önceki karakter, arkasına bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="4be26-233">(Karşılaştırma büyük/küçük harf duyarsızdır.)</span><span class="sxs-lookup"><span data-stu-id="4be26-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="4be26-234">Dize sonunda maç sona erdirin.</span><span class="sxs-lookup"><span data-stu-id="4be26-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="4be26-235">Olumlu ve olumsuz bakışlar hakkında daha fazla bilgi için, [Gruplandırma Yapıları'na](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="4be26-235">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="4be26-236">İlgili makaleler:</span><span class="sxs-lookup"><span data-stu-id="4be26-236">Related articles</span></span>

|<span data-ttu-id="4be26-237">Başlık</span><span class="sxs-lookup"><span data-stu-id="4be26-237">Title</span></span>|<span data-ttu-id="4be26-238">Açıklama</span><span class="sxs-lookup"><span data-stu-id="4be26-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="4be26-239">Geri Dönüş</span><span class="sxs-lookup"><span data-stu-id="4be26-239">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="4be26-240">Alternatif eşleşmeleri bulmak için düzenli ifade geri izleme dalları hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="4be26-241">Derleme ve Yeniden Kullanma</span><span class="sxs-lookup"><span data-stu-id="4be26-241">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="4be26-242">Performansı artırmak için düzenli ifadeleri derleme ve yeniden kullanma hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="4be26-243">İş Parçacığı Güvenliği</span><span class="sxs-lookup"><span data-stu-id="4be26-243">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="4be26-244">Normal ifade iş parçacığı güvenliği hakkında bilgi sağlar ve normal ifade nesnelerine erişimi ne zaman eşitlemeniz gerektiğini açıklar.</span><span class="sxs-lookup"><span data-stu-id="4be26-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="4be26-245">.NET Framework Normal İfadeleri</span><span class="sxs-lookup"><span data-stu-id="4be26-245">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="4be26-246">Normal ifadelerin programlama dili boyutuna genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="4be26-247">Normal İfade Nesnesi Modeli</span><span class="sxs-lookup"><span data-stu-id="4be26-247">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="4be26-248">Normal ifade sınıflarının nasıl kullanılacağını gösteren bilgi ve kod örnekleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="4be26-249">Normal İfade Dili - Hızlı Başvuru</span><span class="sxs-lookup"><span data-stu-id="4be26-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="4be26-250">Normal ifadeleri tanımlamak için kullanabileceğiniz karakter kümesi, işleçler ve yapılar hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="4be26-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="4be26-251">Başvuru</span><span class="sxs-lookup"><span data-stu-id="4be26-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
