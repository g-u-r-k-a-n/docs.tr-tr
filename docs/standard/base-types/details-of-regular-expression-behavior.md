---
title: Normal İfade Davranışının Ayrıntıları
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: 6a7f29a95cd3042cda1c508ad7472e9378817ebe
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/30/2019
ms.locfileid: "73126431"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="6e838-102">Normal İfade Davranışının Ayrıntıları</span><span class="sxs-lookup"><span data-stu-id="6e838-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="6e838-103">.NET Framework normal ifade altyapısı, Perl, Python, Emacs ve Tcl tarafından kullanılan gibi geleneksel bir belirleyici olmayan sonlu bir Automaton (NFA) altyapısını içeren bir geri izleme normal ifade eşleştirici.</span><span class="sxs-lookup"><span data-stu-id="6e838-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="6e838-104">Bu, onu daha hızlı bir şekilde ayırır, ancak awk, egrep veya Lex içinde bulunanlar gibi daha sınırlı, saf normal ifade belirleyici bir otomasyon (DFA) altyapılarından ayırt edilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="6e838-105">Bu Ayrıca, bunu standartlaştırılmış, ancak daha yavaş, POSIX NFAs olarak da ayırır.</span><span class="sxs-lookup"><span data-stu-id="6e838-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="6e838-106">Aşağıdaki bölümde, normal ifade altyapısının üç türü açıklanmakta ve .NET Framework normal ifadelerin geleneksel bir NFA altyapısı kullanılarak nasıl uygulandığı açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="6e838-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="6e838-107">NFA altyapısının avantajları</span><span class="sxs-lookup"><span data-stu-id="6e838-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="6e838-108">DFA motorları, düzen eşleştirmeyi gerçekleştirirken, işlem sırası giriş dizesi tarafından çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="6e838-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="6e838-109">Motor, giriş dizesinin başlangıcında başlar ve sonraki karakterin normal ifade düzeniyle eşleşip eşleşmediğini tespit etmek için ardışık olarak devam eder.</span><span class="sxs-lookup"><span data-stu-id="6e838-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="6e838-110">Mümkün olan en uzun dizeyi eşleştirmeye garanti edebilirler.</span><span class="sxs-lookup"><span data-stu-id="6e838-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="6e838-111">Aynı karakteri iki kez test etmeyeceğinden, DFA motorları geri izlemeyi desteklemez.</span><span class="sxs-lookup"><span data-stu-id="6e838-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="6e838-112">Ancak, bir DFA altyapısı yalnızca sonlu durum içerdiğinden, geri başvuruları olan bir Düzenle eşleşmez ve açık bir genişletme oluşturmadığından, alt ifadeleri yakalamaz.</span><span class="sxs-lookup"><span data-stu-id="6e838-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="6e838-113">DFA altyapılarından farklı olarak, Geleneksel NFA motorları düzen eşleştirmeyi gerçekleştirirken, işlem sırası normal ifade düzeniyle çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="6e838-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="6e838-114">Belirli bir dil öğesini işlerken, altyapı doyumsuz eşleştirmeyi kullanır; diğer bir deyişle, giriş dizesinin büyük olasılıkla mümkün olduğunca fazla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="6e838-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="6e838-115">Ancak, bir alt ifadeyi başarıyla eşleştirdikten sonra da durumunu kaydeder.</span><span class="sxs-lookup"><span data-stu-id="6e838-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="6e838-116">Bir eşleşme yine başarısız olursa, altyapı daha fazla eşleşme deneyebilmesi için kaydedilmiş bir duruma dönebilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="6e838-117">Bu işlem, normal ifadede daha sonraki dil öğelerinin *geri izleme*olarak bilinmesinin ardından, başarılı bir alt ifadenin eşleşmesi için eşleşir.</span><span class="sxs-lookup"><span data-stu-id="6e838-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="6e838-118">NFA motorları, belirli bir sırada normal bir ifadenin tüm olası genişletmeleri test etmek için geri izlemeyi kullanır ve ilk eşleşmeyi kabul eder.</span><span class="sxs-lookup"><span data-stu-id="6e838-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="6e838-119">Geleneksel bir NFA altyapısı başarılı bir eşleşme için normal ifadenin belirli bir genişletmesinin oluşturulduğundan, alt ifade eşleşmelerini ve eşleşen geri başvuruları yakalayabilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="6e838-120">Bununla birlikte, geleneksel bir NFA geri izlemeleriyle, farklı yollar üzerinde duruma alınırsa aynı durumu birden çok kez ziyaret edebilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="6e838-121">Sonuç olarak, en kötü durumda büyük olasılıkla çok daha yavaş çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="6e838-122">Geleneksel bir NFA motoru bulduğu ilk eşleşmeyi kabul ettiğinden, diğer (muhtemelen uzun) bulunamadan eşleşme de olabilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="6e838-123">POSIX NSK motorları Geleneksel NFA altyapılarına benzer, ancak mümkün olan en uzun eşleşmeyi buldıklarından emin olacakları sürece geri izlemeye devam ederler.</span><span class="sxs-lookup"><span data-stu-id="6e838-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="6e838-124">Sonuç olarak, bir POSIX NFA motoru geleneksel bir NFA altyapısından daha yavaştır ve bir POSIX NFA altyapısı kullandığınızda, geri izleme aramasının sırasını değiştirerek daha kısa bir eşleşmeyi daha uzun bir süre boyunca tercih edilemez.</span><span class="sxs-lookup"><span data-stu-id="6e838-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="6e838-125">Geleneksel nfa motorları, programcılar tarafından daha fazla denetim sağladığından, DFA veya POSIX NSK altyapılarından daha fazla denetim sunduklarında, bu programcılar tarafından sık sık kırmız</span><span class="sxs-lookup"><span data-stu-id="6e838-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="6e838-126">En kötü durumda, yavaş çalışabilse de, belirsizlikleri azaltan ve geri izlemeyi sınırlayan desenler kullanarak bunları doğrusal veya polinom zaman içinde bulmak için onları eğilede yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e838-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="6e838-127">Diğer bir deyişle, NFA motorları güç ve esneklik için performans sunar, ancak çoğu durumda düzenli bir ifade iyi yazılmışsa ve geri izlemenin performansı katlanarak düşürür.</span><span class="sxs-lookup"><span data-stu-id="6e838-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="6e838-128">Aşırı geri izleme ve bir normal ifadeyi geçici olarak çözmek için kullanmanın bir performans cezası hakkında daha fazla bilgi için bkz. [geri izleme](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="6e838-129">.NET Framework motoru özellikleri</span><span class="sxs-lookup"><span data-stu-id="6e838-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="6e838-130">Geleneksel bir NFA altyapısının avantajlarından yararlanmak için, .NET Framework normal ifade altyapısı, programcıların geri izleme altyapısını ele geçirmesine olanak sağlayan bir yapı kümesi içerir.</span><span class="sxs-lookup"><span data-stu-id="6e838-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="6e838-131">Bu yapılar, eşleşmeleri daha hızlı bulmak veya diğerleri üzerinde belirli genişleimler sağlamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="6e838-132">.NET Framework normal ifade altyapısının diğer özellikleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="6e838-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
- <span data-ttu-id="6e838-133">Yavaş nicelik belirteçleri: `??`, `*?`, `+?`, `{`*n*`,`*d*`}?`.</span><span class="sxs-lookup"><span data-stu-id="6e838-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="6e838-134">Bu yapılar geri izleme altyapısından önce en az sayıda tekrarın aramasını söyler.</span><span class="sxs-lookup"><span data-stu-id="6e838-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="6e838-135">Buna karşılık, sıradan doyumsuz nicelik belirteçleri öncelikle en fazla tekrarlık sayısını eşleştirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="6e838-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="6e838-136">Aşağıdaki örnek, iki arasındaki farkı gösterir.</span><span class="sxs-lookup"><span data-stu-id="6e838-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="6e838-137">Normal ifade, bir sayıyla biten bir cümle ile eşleşir ve yakalama grubu bu sayıyı çıkarmaya yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="6e838-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="6e838-138">`.+(\d+)\.` normal ifade, normal ifade altyapısının yalnızca sayının son basamağını yakalamasına neden olan doyumsuz nicelik `.+`içerir.</span><span class="sxs-lookup"><span data-stu-id="6e838-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="6e838-139">Buna karşılık, `.+?(\d+)\.` normal ifade, normal ifade altyapısının tüm sayıyı yakalamasına neden olan `.+?`yavaş nicelik sayısını içerir.</span><span class="sxs-lookup"><span data-stu-id="6e838-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="6e838-140">Bu normal ifadenin doyumsuz ve geç sürümleri, aşağıdaki tabloda gösterildiği gibi tanımlanmıştır:</span><span class="sxs-lookup"><span data-stu-id="6e838-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>
  
    |<span data-ttu-id="6e838-141">Desen</span><span class="sxs-lookup"><span data-stu-id="6e838-141">Pattern</span></span>|<span data-ttu-id="6e838-142">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6e838-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="6e838-143">`.+` (Greedy nicelik belirteci)</span><span class="sxs-lookup"><span data-stu-id="6e838-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="6e838-144">Herhangi bir karakterin en az bir oluşumunu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="6e838-145">Bu, normal ifade altyapısının tüm dizeyi eşleştirmesine ve ardından düzenin geri kalanını eşleştirmek için gerektiğinde geri izlemesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="6e838-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="6e838-146">`.+?` (yavaş nicelik belirteci)</span><span class="sxs-lookup"><span data-stu-id="6e838-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="6e838-147">Herhangi bir karakterin en az bir oluşumunu eşleştirin, ancak mümkün olduğunca az eşleşir.</span><span class="sxs-lookup"><span data-stu-id="6e838-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="6e838-148">En az bir sayısal karakteri eşleştirin ve ilk yakalama grubuna atayın.</span><span class="sxs-lookup"><span data-stu-id="6e838-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="6e838-149">Bir noktayla eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-149">Match a period.</span></span>|  
  
     <span data-ttu-id="6e838-150">Yavaş nicelik belirteçleri hakkında daha fazla bilgi için bkz. [nicelik belirteçleri](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="6e838-151">Pozitif ileri yönlü: `(?=`alt *ifade*`)`.</span><span class="sxs-lookup"><span data-stu-id="6e838-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="6e838-152">Bu özellik geri izleme altyapısının alt ifadeyi eşleştirdikten sonra metinde aynı noktaya dönmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="6e838-153">Aynı konumdan başlayan birden çok deseni doğrulayarak metnin tamamında arama yapmak yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="6e838-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="6e838-154">Ayrıca, altyapının alt dizeyi eşleşen metne dahil etmeden, eşleşmenin sonunda var olduğunu doğrulamasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="6e838-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="6e838-155">Aşağıdaki örnek, noktalama sembolleri tarafından izlenen bir tümcedeki sözcüklerin ayıklanmasına yönelik pozitif ileri yönlü kullanır.</span><span class="sxs-lookup"><span data-stu-id="6e838-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="6e838-156">`\b[A-Z]+\b(?=\P{P})` normal ifade aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="6e838-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="6e838-157">Desen</span><span class="sxs-lookup"><span data-stu-id="6e838-157">Pattern</span></span>|<span data-ttu-id="6e838-158">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6e838-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="6e838-159">Bir sözcük sınırında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="6e838-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="6e838-160">Herhangi bir alfabetik karakterle bir veya daha fazla kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="6e838-161"><xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> yöntemi <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> seçeneği ile çağrıldığı için karşılaştırma büyük/küçük harfe duyarlıdır.</span><span class="sxs-lookup"><span data-stu-id="6e838-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="6e838-162">Eşlemeyi bir sözcük sınırında sonlandır.</span><span class="sxs-lookup"><span data-stu-id="6e838-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="6e838-163">Sonraki karakterin bir noktalama işareti olup olmadığını anlamak için öne bakın.</span><span class="sxs-lookup"><span data-stu-id="6e838-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="6e838-164">Aksi takdirde, eşleşme başarılı olur.</span><span class="sxs-lookup"><span data-stu-id="6e838-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="6e838-165">Olumlu ileri yönlü onaylar hakkında daha fazla bilgi için bkz. [gruplandırma yapıları](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="6e838-166">Negatif ilerleme: `(?!`alt *ifade*`)`.</span><span class="sxs-lookup"><span data-stu-id="6e838-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="6e838-167">Bu özellik, yalnızca bir alt ifade eşleşmediğinde bir ifadeyle eşleşme özelliği ekler.</span><span class="sxs-lookup"><span data-stu-id="6e838-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="6e838-168">Bu, genellikle bir aramayı ayıklama açısından güçlü bir durumdur çünkü dahil olması gereken durumlar için bir ifadeden daha kolay bir ifade sağlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="6e838-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="6e838-169">Örneğin, "olmayan" ile başlamayan sözcükler için bir ifade yazmak zordur.</span><span class="sxs-lookup"><span data-stu-id="6e838-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="6e838-170">Aşağıdaki örnek, hariç tutmak için negatif ilerleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="6e838-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="6e838-171">`\b(?!non)\w+\b` normal ifade deseninin aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="6e838-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="6e838-172">Desen</span><span class="sxs-lookup"><span data-stu-id="6e838-172">Pattern</span></span>|<span data-ttu-id="6e838-173">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6e838-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="6e838-174">Bir sözcük sınırında eşleşmeye başla.</span><span class="sxs-lookup"><span data-stu-id="6e838-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="6e838-175">Geçerli dizenin "olmayan" ile başlamadığından emin olmak için öne bakın.</span><span class="sxs-lookup"><span data-stu-id="6e838-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="6e838-176">Varsa, eşleşme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="6e838-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="6e838-177">Bir veya daha fazla sözcük karakteri eşleştir.</span><span class="sxs-lookup"><span data-stu-id="6e838-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="6e838-178">Eşlemeyi bir sözcük sınırında sonlandır.</span><span class="sxs-lookup"><span data-stu-id="6e838-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="6e838-179">Olumsuz ileri onaylar hakkında daha fazla bilgi için bkz. [gruplandırma yapıları](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="6e838-180">Koşullu değerlendirme: `(?(`*ifade*`)`*Evet*`|` *`)`* ve `(?(`*adı* *`)``|`* *yok* , burada *ifade* bir alt ifade. eşleştirmek için, *ad* bir yakalama grubunun adıdır, *Evet* *ifadesi* eşleştirildiği veya *ad* geçerli, boş olmayan bir yakalanan grup ise eşleştirilecek dize, ancak *Hayır* ifadesi ise eşleştirilecek alt ifadeeşleşmiyor veya *ad* geçerli, boş olmayan bir yakalanan grup değil.</span><span class="sxs-lookup"><span data-stu-id="6e838-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="6e838-181">Bu özellik, bir önceki alt ifadenin veya sıfır genişlikli bir onaylama sonucuna bağlı olarak, altyapının birden fazla alternatif model kullanarak arama yapmasına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="6e838-182">Bu, örneğin, önceki alt ifadenin eşleştirildiği bir alt ifadeyi eşleştirmesine izin veren daha güçlü bir geri başvuru biçimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="6e838-183">Aşağıdaki örnekteki normal ifade, hem genel hem de iç kullanım için tasarlanan paragraflarla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="6e838-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="6e838-184">Yalnızca iç kullanım için tasarlanan paragraflar bir `<PRIVATE>` etiketiyle başlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="6e838-185">Normal ifade deseninin `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$`, genel ve iç kullanım için tasarlanan paragrafların içeriğini ayrı yakalama grupları atamak için koşullu değerlendirme kullanır.</span><span class="sxs-lookup"><span data-stu-id="6e838-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="6e838-186">Bu paragraflar daha sonra farklı işlenebilirler.</span><span class="sxs-lookup"><span data-stu-id="6e838-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="6e838-187">Normal ifade deseninin, aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="6e838-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="6e838-188">Desen</span><span class="sxs-lookup"><span data-stu-id="6e838-188">Pattern</span></span>|<span data-ttu-id="6e838-189">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6e838-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="6e838-190">Bir satırın başlangıcında eşleşmeyi başlatın.</span><span class="sxs-lookup"><span data-stu-id="6e838-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="6e838-191">Dize `<PRIVATE>` ve ardından boşluk karakteri gelen sıfır veya bir oluşumu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="6e838-192">Eşleşmeyi `Pvt`adlı bir yakalama grubuna atayın.</span><span class="sxs-lookup"><span data-stu-id="6e838-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="6e838-193">`Pvt` yakalama grubu varsa, bir ya da daha fazla sözcük karakterinin ardından sıfır veya bir noktalama ayırıcısından sonra bir boşluk karakteri gelen bir veya daha fazla tekrarı eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="6e838-194">Alt dizeyi ilk yakalama grubuna atayın.</span><span class="sxs-lookup"><span data-stu-id="6e838-194">Assign the substring to the first capturing group.</span></span>|  
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="6e838-195">`Pvt` yakalama grubu yoksa, bir veya daha fazla sözcük karakteri ve ardından sıfır veya bir noktalama işareti ve ardından bir boşluk karakteri gelen bir veya daha fazla tekrarı eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="6e838-196">Alt dizeyi üçüncü yakalama grubuna atayın.</span><span class="sxs-lookup"><span data-stu-id="6e838-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="6e838-197">Satırın sonunu veya dizenin sonunu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="6e838-198">Koşullu değerlendirme hakkında daha fazla bilgi için bkz. [değişim yapıları](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="6e838-199">Grup tanımlarını dengeleme: `(?<`*name1*`-`*AD2*`>` alt *ifade*`)`.</span><span class="sxs-lookup"><span data-stu-id="6e838-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="6e838-200">Bu özellik, normal ifade altyapısının parantez ya da açılış ve kapanış ayraçları gibi iç içe yapıları izlemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="6e838-201">Bir örnek için bkz. [gruplandırma yapıları](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="6e838-202">Geri izleme olmayan alt ifadeler (doyumsuz alt ifadeleri olarak da bilinir): `(?>`alt *ifade*`)`.</span><span class="sxs-lookup"><span data-stu-id="6e838-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="6e838-203">Bu özellik geri izleme altyapısının, ifadenin kendisini içeren ifadeden bağımsız olarak çalışıyor gibi, alt ifadenin yalnızca ilk eşleştirmelerle eşleştiğini garanti etmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="6e838-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="6e838-204">Bu yapıyı kullanmazsanız, daha büyük ifadeden geri alma aramaları alt ifadenin davranışını değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="6e838-205">Örneğin, normal `(a+)\w` ifade, bir veya daha fazla "a" karakteriyle eşleşir ve "a" karakterinin dizisini izleyen bir sözcük karakteri ile birlikte ilk yakalama grubuna "a" karakterlerinden oluşan diziyi, ancak son karakteri olarak atar. giriş dizesi aynı zamanda bir "a", `\w` Language öğesiyle eşleştirildiği ve yakalanan gruba dahil değildir.</span><span class="sxs-lookup"><span data-stu-id="6e838-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="6e838-206">`((?>a+))\w` normal ifade bu davranışı engeller.</span><span class="sxs-lookup"><span data-stu-id="6e838-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="6e838-207">Birbirini izleyen tüm "a" karakterleri geri izleme olmadan eşleştirildiği için ilk yakalama grubu tüm ardışık "a" karakterlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="6e838-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="6e838-208">"A" karakterlerinin ardından "a" dışında en az bir karakter daha olmazsa, eşleşme başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="6e838-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="6e838-209">Geri alma olmayan alt ifadeler hakkında daha fazla bilgi için bkz. [gruplandırma yapıları](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="6e838-210"><xref:System.Text.RegularExpressions.Regex> sınıf oluşturucusuna veya statik örnek eşleştirme yöntemine <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> seçeneği sağlanarak belirtilen sağdan sola eşleme.</span><span class="sxs-lookup"><span data-stu-id="6e838-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="6e838-211">Bu özellik soldan sağa yerine sağdan sola doğru arama yaparken veya sol yerine modelin sağ bölümünde bir eşleştirmeye başlamak daha verimli olduğu durumlarda faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="6e838-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="6e838-212">Aşağıdaki örnekte gösterildiği gibi, sağdan sola eşleşme kullanımı, doyumsuz nicelik belirteçleri davranışını değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="6e838-213">Örnek, bir sayıyla biten bir cümle için iki arama yapar.</span><span class="sxs-lookup"><span data-stu-id="6e838-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="6e838-214">Doyumsuz nicelik sayısını kullanan soldan sağa arama `+`, tümcedeki altı basamaktan biriyle eşleşir, ancak sağdan sola arama altı basamakla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="6e838-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="6e838-215">Normal ifade deseninin bir açıklaması için, bu bölümün önceki kısımlarında yer alan yavaş nicelik belirteçleri gösteren örneğe bakın.</span><span class="sxs-lookup"><span data-stu-id="6e838-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="6e838-216">Sağdan sola eşleştirme hakkında daha fazla bilgi için bkz. [normal Ifade seçenekleri](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
- <span data-ttu-id="6e838-217">Pozitif ve negatif geriye yönelik: `(?<=`alt *ifade* pozitif geriye yönelik`)` ve `(?<!`alt *ifadesi* negatif geriye yönelik`)`.</span><span class="sxs-lookup"><span data-stu-id="6e838-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="6e838-218">Bu özellik, bu konuda daha önce bahsedilen ileri yönlü olarak benzerdir.</span><span class="sxs-lookup"><span data-stu-id="6e838-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="6e838-219">Normal ifade altyapısı tam sağdan sola eşleştirmeye izin verdiğinden, normal ifadeler sınırsız lookbehinds izin verir.</span><span class="sxs-lookup"><span data-stu-id="6e838-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="6e838-220">İç içe geçmiş alt ifade bir dış ifadenin üst kümesi olduğunda, nicelik sayısını aşmamak için pozitif ve negatif geriye yönelik Ayrıca kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="6e838-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="6e838-221">İç içe geçmiş nicelik belirteçleri olan normal ifadeler genellikle düşük performans sunar.</span><span class="sxs-lookup"><span data-stu-id="6e838-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="6e838-222">Örneğin, aşağıdaki örnek bir dizenin bir alfasayısal karakterle başladığını ve bittiğini doğrular ve dizedeki diğer tüm karakterler daha büyük bir alt kümeyle biridir.</span><span class="sxs-lookup"><span data-stu-id="6e838-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="6e838-223">E-posta adreslerini doğrulamak için kullanılan normal ifadenin bir bölümünü oluşturur; daha fazla bilgi için bkz. [nasıl yapılır: dizelerin geçerli e-posta biçiminde olduğunu doğrulama](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="6e838-224">``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` normal ifade aşağıdaki tabloda gösterildiği gibi tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="6e838-224">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="6e838-225">Desen</span><span class="sxs-lookup"><span data-stu-id="6e838-225">Pattern</span></span>|<span data-ttu-id="6e838-226">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6e838-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="6e838-227">Dizenin başlangıcında eşleşmeyi başlatın.</span><span class="sxs-lookup"><span data-stu-id="6e838-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="6e838-228">Herhangi bir sayısal veya alfasayısal karakter eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="6e838-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="6e838-229">(Karşılaştırma büyük/küçük harfe duyarlıdır.)</span><span class="sxs-lookup"><span data-stu-id="6e838-229">(The comparison is case-insensitive.)</span></span>|  
    |<span data-ttu-id="6e838-230"><code>([-!#$%&'.\*+/=?^\`{}&#124;~\w])\*</code>| Herhangi bir kelime karakterinin sıfır veya daha fazla tekrarı veya şu karakterlerden herhangi birini eşleştirin:-,!, #, $,%, &, ',., \*, +,/, =,?, ^, \`, {,}, &#124;, veya ~.</span><span class="sxs-lookup"><span data-stu-id="6e838-230"><code>([-!#$%&'.\*+/=?^\`{}&#124;~\w])\*</code>|Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, \`, {, }, &#124;, or ~.</span></span>|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="6e838-231">Sayısal veya alfasayısal olması gereken önceki karakterin arkasına bakın.</span><span class="sxs-lookup"><span data-stu-id="6e838-231">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="6e838-232">(Karşılaştırma büyük/küçük harfe duyarlıdır.)</span><span class="sxs-lookup"><span data-stu-id="6e838-232">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="6e838-233">Dizenin sonundaki eşleşmeyi sonlandırın.</span><span class="sxs-lookup"><span data-stu-id="6e838-233">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="6e838-234">Olumlu ve olumsuz geriye yönelik daha fazla bilgi için bkz. [gruplandırma yapıları](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="6e838-234">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="6e838-235">İlgili Konular</span><span class="sxs-lookup"><span data-stu-id="6e838-235">Related Topics</span></span>  
  
|<span data-ttu-id="6e838-236">Başlık</span><span class="sxs-lookup"><span data-stu-id="6e838-236">Title</span></span>|<span data-ttu-id="6e838-237">Açıklama</span><span class="sxs-lookup"><span data-stu-id="6e838-237">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="6e838-238">Geri Dönüş</span><span class="sxs-lookup"><span data-stu-id="6e838-238">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="6e838-239">Normal ifade izleme dallarının alternatif eşleşmelerin nasıl bulunacağını gösteren bilgiler sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-239">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="6e838-240">Derleme ve Yeniden Kullanma</span><span class="sxs-lookup"><span data-stu-id="6e838-240">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="6e838-241">Performansı artırmak için normal ifadeleri derleme ve yeniden kullanma hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-241">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="6e838-242">İş Parçacığı Güvenliği</span><span class="sxs-lookup"><span data-stu-id="6e838-242">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="6e838-243">Normal ifade iş parçacığı güvenliği hakkında bilgi sağlar ve normal ifade nesnelerine erişimi ne zaman eşitlemeniz gerektiğini açıklar.</span><span class="sxs-lookup"><span data-stu-id="6e838-243">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="6e838-244">Normal Ifadeleri .NET Framework</span><span class="sxs-lookup"><span data-stu-id="6e838-244">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="6e838-245">Normal ifadelerin programlama diline ilişkin bir genel bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-245">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="6e838-246">Normal İfade Nesne Modeli</span><span class="sxs-lookup"><span data-stu-id="6e838-246">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="6e838-247">Normal ifade sınıflarının nasıl kullanılacağını gösteren bilgi ve kod örnekleri sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-247">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="6e838-248">Normal İfade Örnekleri</span><span class="sxs-lookup"><span data-stu-id="6e838-248">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="6e838-249">Ortak uygulamalarda normal ifadelerin kullanımını gösteren kod örnekleri içerir.</span><span class="sxs-lookup"><span data-stu-id="6e838-249">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="6e838-250">Normal İfade Dili - Hızlı Başvuru</span><span class="sxs-lookup"><span data-stu-id="6e838-250">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="6e838-251">Normal ifadeleri tanımlamak için kullanabileceğiniz karakter, işleç ve yapılar kümesi hakkında bilgi sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e838-251">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="6e838-252">Başvuru</span><span class="sxs-lookup"><span data-stu-id="6e838-252">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
