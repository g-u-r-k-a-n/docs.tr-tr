---
title: Kod tabanınızı null yapılabilir başvuru türlerini kullanacak şekilde güncelleştirin
description: Kod tabanınızı, null yapılabilir başvuru türlerini kullanacak şekilde yükseltmek için en iyi stratejiyi seçin.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: 667b31a79df04b3f5af5883e59729c6eac560352
ms.sourcegitcommit: e16315d9f1ff355f55ff8ab84a28915be0a8e42b
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/25/2021
ms.locfileid: "105111327"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="694a8-103">Kitaplıkları null yapılabilir başvuru türleri kullanacak şekilde güncelleştirme ve arayanlara null olabilecek kuralları iletişim kurma</span><span class="sxs-lookup"><span data-stu-id="694a8-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="694a8-104">[Null yapılabilir başvuru türlerinin](nullable-references.md) eklenmesi, `null` her değişken için bir değere izin verilip verilmeyeceğini veya beklenmediğini bildirebilmeniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="694a8-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="694a8-105">Ayrıca, `AllowNull` `DisallowNull` `MaybeNull` `NotNull` `NotNullWhen` `MaybeNullWhen` `NotNullIfNotNull` bağımsız değişkenin ve dönüş değerlerinin null durumlarını tamamen anlatmak için,,,,, ve birçok öznitelik uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="694a8-106">Bu, kod yazarken harika bir deneyim sağlar.</span><span class="sxs-lookup"><span data-stu-id="694a8-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="694a8-107">Null yapılamayan bir değişken olarak ayarlanmayabilir `null` .</span><span class="sxs-lookup"><span data-stu-id="694a8-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="694a8-108">Nullable bir değişken, başvuru yapılmadan önce null olarak işaretli değilse uyarılar alırsınız.</span><span class="sxs-lookup"><span data-stu-id="694a8-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="694a8-109">Kitaplıklarınızın güncelleştirilmesi zaman alabilir, ancak ödeme bu duruma göre yapılır.</span><span class="sxs-lookup"><span data-stu-id="694a8-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="694a8-110">Bir  `null` değere izin verildiğinde veya yasaklanmış olduğunda derleyiciye sağladığınız daha fazla bilgi, API 'nizin Kullanıcı tarafından daha iyi uyarıları alır.</span><span class="sxs-lookup"><span data-stu-id="694a8-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="694a8-111">Tanıdık bir örnekle başlayalım.</span><span class="sxs-lookup"><span data-stu-id="694a8-111">Let's start with a familiar example.</span></span> <span data-ttu-id="694a8-112">Kitaplığınızın bir kaynak dizesini almak için aşağıdaki API 'ye sahip olduğunu düşünün:</span><span class="sxs-lookup"><span data-stu-id="694a8-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="694a8-113">Yukarıdaki örnek, `Try*` .net 'teki tanıdık olan bir model izler.</span><span class="sxs-lookup"><span data-stu-id="694a8-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="694a8-114">Bu API için iki başvuru bağımsız değişkeni vardır: `key` ve `message` parametresi.</span><span class="sxs-lookup"><span data-stu-id="694a8-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="694a8-115">Bu API, bu bağımsız değişkenlerin nulldurumuyla ilgili aşağıdaki kurallara sahiptir:</span><span class="sxs-lookup"><span data-stu-id="694a8-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="694a8-116">Çağıranlar `null` için bağımsız değişken olarak geçmemelidir `key` .</span><span class="sxs-lookup"><span data-stu-id="694a8-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="694a8-117">Çağıranlar, değeri bağımsız değişkeni olan bir değişken geçirebilir `null` `message` .</span><span class="sxs-lookup"><span data-stu-id="694a8-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="694a8-118">`TryGetMessage`Yöntemi döndürürse `true` , değeri `message` null değildir.</span><span class="sxs-lookup"><span data-stu-id="694a8-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="694a8-119">Dönüş değeri `false,` `message` (ve null durumu) değeri null ise.</span><span class="sxs-lookup"><span data-stu-id="694a8-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="694a8-120">Kuralı `key` değişken türü ile tamamen ifade edilebilir: `key` null yapılamayan bir başvuru türü olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="694a8-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="694a8-121">`message`Parametresi daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="694a8-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="694a8-122">`null`Bağımsız değişken olarak izin verir, ancak başarıyı, bu `out` bağımsız değişkenin null olmadığını garanti eder.</span><span class="sxs-lookup"><span data-stu-id="694a8-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="694a8-123">Bu senaryolar için beklentileri betimleyen daha zengin bir sözlük gerekir.</span><span class="sxs-lookup"><span data-stu-id="694a8-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="694a8-124">Boş değer atanabilir başvurular için kitaplığınızın güncelleştirilmesi `?` , bazı değişkenlerde ve tür adlarından daha fazla spreninkini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="694a8-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="694a8-125">Yukarıdaki örnek, API 'lerinizi incelemeniz ve her giriş bağımsız değişkeni için beklentilerinizi göz önünde bulundurmanız gerektiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="694a8-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="694a8-126">Dönüş değeri için garantiyi ve `out` `ref` yöntemin dönüşi üzerinde herhangi bir veya bağımsız değişkeni göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="694a8-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="694a8-127">Sonra bu kuralları derleyiciye iletmeyin ve bu kurallar tarafından çağıranlar olmadığında Derleyici uyarılar sağlar.</span><span class="sxs-lookup"><span data-stu-id="694a8-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="694a8-128">Bu iş zaman alır.</span><span class="sxs-lookup"><span data-stu-id="694a8-128">This work takes time.</span></span> <span data-ttu-id="694a8-129">Daha fazla gereksinimi dengelarken, kitaplığınızı veya uygulamanızı null yapılabilir hale getirme stratejileriyle başlayalım.</span><span class="sxs-lookup"><span data-stu-id="694a8-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements.</span></span> <span data-ttu-id="694a8-130">Devam eden geliştirmeyi nasıl dengeleyebilirsiniz, null yapılabilir başvuru türleri etkinleştiriliyor.</span><span class="sxs-lookup"><span data-stu-id="694a8-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="694a8-131">Genel tür tanımları için zorluk öğrenirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="694a8-132">Tek tek API 'lerde ön ve son koşulları betimleyen öznitelikler uygulamayı öğreneceksiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="694a8-133">Null yapılabilir başvuru türleri için bir strateji seçin</span><span class="sxs-lookup"><span data-stu-id="694a8-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="694a8-134">İlk seçenek, null yapılabilir başvuru türlerinin varsayılan olarak açık veya kapalı olması gerekip gerekmediğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="694a8-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="694a8-135">İki stratejileriniz vardır:</span><span class="sxs-lookup"><span data-stu-id="694a8-135">You have two strategies:</span></span>

- <span data-ttu-id="694a8-136">Tüm proje için null yapılabilir başvuru türlerini etkinleştirin ve devre dışı olan kodda devre dışı bırakın.</span><span class="sxs-lookup"><span data-stu-id="694a8-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="694a8-137">Yalnızca Nullable başvuru türleri için açıklama eklenmiş kod için null yapılabilir başvuru türlerini etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="694a8-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="694a8-138">İlk strateji, null yapılabilir başvuru türleri için güncelleştirdiğinizde, kitaplığa başka özellikler eklerken en iyi şekilde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="694a8-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="694a8-139">Tüm yeni geliştirmeler null yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="694a8-139">All new development is nullable aware.</span></span> <span data-ttu-id="694a8-140">Mevcut kodu güncelleştirdiğinizde bu sınıflarda null yapılabilir başvuru türlerini etkinleştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="694a8-141">Bu ilk stratejiyi izleyerek aşağıdaki adımları uygulayın:</span><span class="sxs-lookup"><span data-stu-id="694a8-141">Following this first strategy, you do the following steps:</span></span>

1. <span data-ttu-id="694a8-142">`<Nullable>enable</Nullable>`Öğeyi *csproj* dosyalarınıza ekleyerek projenin tamamına ait null yapılabilir başvuru türlerini etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="694a8-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="694a8-143">`#nullable disable`Pragmayı projenizdeki her kaynak dosyasına ekleyin.</span><span class="sxs-lookup"><span data-stu-id="694a8-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="694a8-144">Her dosya üzerinde çalışırken, pragmayı kaldırın ve tüm uyarıları çözün.</span><span class="sxs-lookup"><span data-stu-id="694a8-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="694a8-145">Bu ilk stratejide, her dosyaya pragma eklemek için daha fazla yukarı iş vardır.</span><span class="sxs-lookup"><span data-stu-id="694a8-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="694a8-146">Avantajı, projeye eklenen her yeni kod dosyasının null yapılabilir olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="694a8-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="694a8-147">Herhangi bir yeni iş, null yapılabilir. yalnızca var olan kodun güncellenmesi gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="694a8-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="694a8-148">İkinci strateji, kitaplığın kararlı olması ve geliştirmenin ana odağının null yapılabilir başvuru türlerini benimsemeniz durumunda daha iyi sonuç verir.</span><span class="sxs-lookup"><span data-stu-id="694a8-148">The second strategy works better if the library is stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="694a8-149">API 'Leri not yazarken null yapılabilir başvuru türlerini açabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="694a8-150">İşiniz bittiğinde, tüm proje için null yapılabilir başvuru türlerini etkinleştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="694a8-151">Bu ikinci stratejiyi izleyerek aşağıdaki adımları uygulayın:</span><span class="sxs-lookup"><span data-stu-id="694a8-151">Following this second strategy you do the following steps:</span></span>

1. <span data-ttu-id="694a8-152">`#nullable enable`Null yapılabilir olmasını istediğiniz dosyaya pragma ekleyin.</span><span class="sxs-lookup"><span data-stu-id="694a8-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="694a8-153">Tüm uyarıları çözün.</span><span class="sxs-lookup"><span data-stu-id="694a8-153">Address any warnings.</span></span>
1. <span data-ttu-id="694a8-154">Tüm kitaplığı null yapılabilir olarak farkında olana kadar bu ilk iki adıma devam edin.</span><span class="sxs-lookup"><span data-stu-id="694a8-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="694a8-155">`<Nullable>enable</Nullable>`Öğeyi *csproj* dosyalarınıza ekleyerek projenin tamamına ait boş değer atanabilir türleri etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="694a8-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="694a8-156">`#nullable enable`Artık gerekli olmadığından pragmaları kaldırın.</span><span class="sxs-lookup"><span data-stu-id="694a8-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="694a8-157">Bu ikinci stratejinin daha az iş ön ucu vardır.</span><span class="sxs-lookup"><span data-stu-id="694a8-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="694a8-158">Zorunluluğunu getirir, yeni bir dosya oluşturduğunuz ilk görevin pragmasını eklemek ve null yapılabilir olduğunu fark edevidir.</span><span class="sxs-lookup"><span data-stu-id="694a8-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="694a8-159">Takımınızdaki herhangi bir geliştirici unutur, bu yeni kod artık tüm kod Nullable olarak uyumlu hale getirmek için iş kapsamındedir.</span><span class="sxs-lookup"><span data-stu-id="694a8-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="694a8-160">Seçtiğiniz bu Stratejiler, projenizde ne kadar etkin geliştirme gerçekleştireceğinize bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="694a8-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="694a8-161">Projeniz ne kadar fazla olgun ve kararlı, ikinci strateji daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="694a8-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="694a8-162">Daha fazla geliştirmekte olan özellikler, ilk strateji daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="694a8-162">The more features being developed, the better the first strategy.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="694a8-163">Global null yapılabilir bağlam, oluşturulan kod dosyaları için uygulanmaz.</span><span class="sxs-lookup"><span data-stu-id="694a8-163">The global nullable context does not apply for generated code files.</span></span> <span data-ttu-id="694a8-164">Her iki strateji kapsamında, null yapılabilir bağlam, üretilen olarak işaretlenen tüm kaynak dosyaları için *devre dışıdır* .</span><span class="sxs-lookup"><span data-stu-id="694a8-164">Under either strategy, the nullable context is *disabled* for any source file marked as generated.</span></span> <span data-ttu-id="694a8-165">Bu, oluşturulan dosyalardaki tüm API 'Lerin açıklanmadığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="694a8-165">This means any APIs in generated files are not annotated.</span></span> <span data-ttu-id="694a8-166">Bir dosyanın oluşturulduğu şekilde işaretlenmiş dört yolu vardır:</span><span class="sxs-lookup"><span data-stu-id="694a8-166">There are four ways a file is marked as generated:</span></span>
>
> 1. <span data-ttu-id="694a8-167">. Editorconfig dosyasında, `generated_code = true` Bu dosya için geçerli olan bir bölümde belirtin.</span><span class="sxs-lookup"><span data-stu-id="694a8-167">In the .editorconfig, specify `generated_code = true` in a section that applies to that file.</span></span>
> 1. <span data-ttu-id="694a8-168">`<auto-generated>` `<auto-generated/>` Dosyanın üst kısmına bir açıklama koyun.</span><span class="sxs-lookup"><span data-stu-id="694a8-168">Put `<auto-generated>` or `<auto-generated/>` in a comment at the top of the file.</span></span> <span data-ttu-id="694a8-169">Bu, açıklama içindeki herhangi bir satırda olabilir, ancak açıklama bloğu dosyadaki ilk öğe olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="694a8-169">It can be on any line in that comment, but the comment block must be the first element in the file.</span></span>
> 1. <span data-ttu-id="694a8-170">Dosya adını *TemporaryGeneratedFile_* başlatın</span><span class="sxs-lookup"><span data-stu-id="694a8-170">Start the file name with *TemporaryGeneratedFile_*</span></span>
> 1. <span data-ttu-id="694a8-171">Dosya adını *. Designer. cs*, *. generated. cs*, *. g. cs* veya *. g. ı. cs* ile sonlandırın.</span><span class="sxs-lookup"><span data-stu-id="694a8-171">End the file name with *.designer.cs*, *.generated.cs*, *.g.cs*, or *.g.i.cs*.</span></span>
>
> <span data-ttu-id="694a8-172">Oluşturucular, Önişlemci yönergesini kullanarak kabul edebilir [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) .</span><span class="sxs-lookup"><span data-stu-id="694a8-172">Generators can opt-in using the [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md) preprocessor directive.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="694a8-173">Null yapılabilir uyarılar, son değişiklikleri mi göstermelidir?</span><span class="sxs-lookup"><span data-stu-id="694a8-173">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="694a8-174">Null yapılabilir başvuru türlerini etkinleştirmeden önce, değişkenler *null yapılabilir zorunluluvou* olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="694a8-174">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="694a8-175">Null yapılabilir başvuru türlerini etkinleştirdikten sonra, bu değişkenlerin hepsi *null değer atanamaz*.</span><span class="sxs-lookup"><span data-stu-id="694a8-175">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="694a8-176">Bu değişkenler null olmayan değerlere başlatılamıyorsa, derleyici uyarılar verebilir.</span><span class="sxs-lookup"><span data-stu-id="694a8-176">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="694a8-177">Büyük olasılıkla başka bir uyarı kaynağı, değer başlatılmamış olduğunda değerler döndürür.</span><span class="sxs-lookup"><span data-stu-id="694a8-177">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="694a8-178">Derleyici uyarılarını adresleyen ilk adım, `?` parametre ve dönüş türleri üzerinde ek açıklamaların kullanılması ve bağımsız değişkenlerin veya dönüş değerlerinin null olabileceğini göstermek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="694a8-178">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="694a8-179">Başvuru değişkenleri null olmamalı, özgün bildirim doğru olur.</span><span class="sxs-lookup"><span data-stu-id="694a8-179">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="694a8-180">Bu görevi yaparken, hedefiniz yalnızca uyarıları düzeltemedi.</span><span class="sxs-lookup"><span data-stu-id="694a8-180">As you do this task, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="694a8-181">Daha önemli hedef, derleyicinin olası null değerler için amacınızı anlaması sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="694a8-181">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="694a8-182">Uyarıları incelerken, kitaplığınız için bir sonraki önemli kararına ulaşabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-182">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="694a8-183">Tasarım amacınızı daha net bir şekilde iletmek için API imzalarını değiştirmeyi düşünmek istiyor musunuz?</span><span class="sxs-lookup"><span data-stu-id="694a8-183">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="694a8-184">Daha önce incelenen Yöntem için daha iyi bir API imzası `TryGetMessage` Şu olabilir:</span><span class="sxs-lookup"><span data-stu-id="694a8-184">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="694a8-185">Dönüş değeri başarılı veya başarısız olduğunu gösterir ve değer bulunursa değeri taşır.</span><span class="sxs-lookup"><span data-stu-id="694a8-185">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="694a8-186">Çoğu durumda, API imzalarını değiştirmek, null değerleri nasıl ilettikleri iyileştirebilirler.</span><span class="sxs-lookup"><span data-stu-id="694a8-186">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="694a8-187">Ancak, genel kitaplıklar veya büyük Kullanıcı temellerine sahip kitaplıklar için herhangi bir API imza değişikliğine giriş yapmayı tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-187">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="694a8-188">Bu durumlar ve diğer yaygın desenler için, bir bağımsız değişken veya dönüş değeri olabileceği zaman daha net bir şekilde tanımlanacak öznitelikler uygulayabilirsiniz `null` .</span><span class="sxs-lookup"><span data-stu-id="694a8-188">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="694a8-189">API 'nizin yüzeyini değiştirmeyi göz önünde bulundurmayın, büyük olasılıkla tür ek açıklamalarını `null` bağımsız değişkenlerin veya dönüş değerlerinin değerlerini tanımlamak için yeterli olmadığını fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-189">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="694a8-190">Bu örneklerde, bir API 'yi daha net bir şekilde anlatmak için öznitelikler uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-190">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="694a8-191">Öznitelikler tür ek açıklamalarını Genişlet</span><span class="sxs-lookup"><span data-stu-id="694a8-191">Attributes extend type annotations</span></span>

<span data-ttu-id="694a8-192">Değişkenlerin null durumu hakkında ek bilgileri ifade etmek için çeşitli öznitelikler eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="694a8-192">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="694a8-193">C# 8 ' den önce yazdığınız tüm kod null yapılabilir başvuru türleri olarak *null zorunluluvou* idi.</span><span class="sxs-lookup"><span data-stu-id="694a8-193">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="694a8-194">Yani herhangi bir başvuru türü değişkeni null olabilir, ancak null denetimleri gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="694a8-194">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="694a8-195">Kodunuz *Nullable olarak farkında* olduktan sonra bu kurallar değişir.</span><span class="sxs-lookup"><span data-stu-id="694a8-195">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="694a8-196">Başvuru türleri asla `null` değer olmamalı ve null yapılabilir başvuru türleri `null` başvurulmadan önce denetlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="694a8-196">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="694a8-197">API 'si senaryosuyla gördüğünüz gibi API 'lerinizin kuralları büyük olasılıkla daha karmaşıktır `TryGetValue` .</span><span class="sxs-lookup"><span data-stu-id="694a8-197">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="694a8-198">API 'lerinizin birçoğu, değişkenlerin ne zaman veya ne zaman oluşturulabileceğine ilişkin daha karmaşık kurallara sahiptir `null` .</span><span class="sxs-lookup"><span data-stu-id="694a8-198">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="694a8-199">Bu durumlarda, bu kuralları ifade etmek için öznitelikleri kullanacaksınız.</span><span class="sxs-lookup"><span data-stu-id="694a8-199">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="694a8-200">API 'nizin semantiğini tanımlayan öznitelikler, [null yapılabilir Analizi etkileyen öznitelikler](./language-reference/attributes/nullable-analysis.md)hakkında makalesinde bulunur.</span><span class="sxs-lookup"><span data-stu-id="694a8-200">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="694a8-201">Genel tanımlar ve null değer alabilirlik</span><span class="sxs-lookup"><span data-stu-id="694a8-201">Generic definitions and nullability</span></span>

<span data-ttu-id="694a8-202">Genel türlerin ve genel yöntemlerin null durumuna doğru bir şekilde iletişim kurmak için özel bakım yapılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="694a8-202">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="694a8-203">Çok daha fazla bilgi, null olabilen bir değer türü ve null yapılabilir bir başvuru türü temelde farklıdır.</span><span class="sxs-lookup"><span data-stu-id="694a8-203">The extra care stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="694a8-204">`int?`, İçin bir eş anlamlı olur `Nullable<int>` , `string?` ancak `string` derleyici tarafından eklenen bir özniteliktir.</span><span class="sxs-lookup"><span data-stu-id="694a8-204">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="694a8-205">Sonuç, derleyicisinin `T?` `T` bir veya bir olduğunu bilmeksizin doğru kodu oluşturabileceği bir sonucudur `class` `struct` .</span><span class="sxs-lookup"><span data-stu-id="694a8-205">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="694a8-206">Bu olgu, kapalı bir genel türün tür bağımsız değişkeni olarak null yapılabilir bir tür (değer türü veya başvuru türü) kullanmayacağınız anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="694a8-206">This fact doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="694a8-207">Her ikisi de `List<string?>` `List<int?>` geçerli örneklerdir `List<T>` .</span><span class="sxs-lookup"><span data-stu-id="694a8-207">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="694a8-208">Bunun anlamı, `T?` kısıtlama olmadan genel bir sınıfta veya yöntem bildiriminde kullanmayacağınız anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="694a8-208">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="694a8-209">Örneğin, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> döndürülecek şekilde değiştirilmez `T?` .</span><span class="sxs-lookup"><span data-stu-id="694a8-209">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="694a8-210">Ya da kısıtlamasını ekleyerek bu sınırlamayı aşabilirsiniz `struct` `class` .</span><span class="sxs-lookup"><span data-stu-id="694a8-210">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="694a8-211">Bu kısıtlamalardan biri ile derleyici, hem hem de için nasıl kod oluşturulacağını bilir `T` `T?` .</span><span class="sxs-lookup"><span data-stu-id="694a8-211">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="694a8-212">Genel tür bağımsız değişkeni için kullanılan türleri null yapılamayan türler olacak şekilde kısıtlamak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-212">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="694a8-213">Bunu, `notnull` Bu tür bağımsız değişkenine kısıtlama ekleyerek yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-213">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="694a8-214">Bu kısıtlama uygulandığında tür bağımsız değişkeni null yapılabilir bir tür olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="694a8-214">When that constraint is applied, the type argument must not be a nullable type.</span></span>

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a><span data-ttu-id="694a8-215">Geç başlatılan özellikler, Veri Aktarımı nesneler ve null değer düzeyi</span><span class="sxs-lookup"><span data-stu-id="694a8-215">Late-initialized properties, Data Transfer Objects, and nullability</span></span>

<span data-ttu-id="694a8-216">Geç başlatılan özelliklerin null olabilmesini belirten, oluşturulduktan sonra ayarlanan anlamı, sınıfınızın özgün tasarım hedefini doğru bir şekilde ifade etmeye devam ettiğinden emin olmak için özel bir dikkat gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="694a8-216">Indicating the nullability of properties that are late-initialized, meaning set after construction, may require special consideration to ensure that your class continues to correctly express the original design intent.</span></span>

<span data-ttu-id="694a8-217">Veri Aktarımı Objects (DTOs) gibi geç başlatılan özellikler içeren türler genellikle bir veritabanı ORM (nesne Ilişkisel Eşleyici), seri hale getirici veya başka bir kaynaktan özellikleri otomatik olarak dolduran başka bir bileşen gibi bir dış kitaplık tarafından örneklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="694a8-217">Types that contain late-initialized properties, such as Data Transfer Objects (DTOs), are often instantiated by an external library, like a database ORM (Object Relational Mapper), a deserializer, or some other component that automatically populates properties from another source.</span></span>

<span data-ttu-id="694a8-218">Bir öğrenci 'yi temsil eden null yapılabilir başvuru türlerini etkinleştirmeden önce aşağıdaki DTO sınıfını göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="694a8-218">Consider the following DTO class, prior to enabling nullable reference types, that represents a student:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

<span data-ttu-id="694a8-219">Tasarım amacı (Bu durumda özniteliği tarafından belirtilir), `Required` Bu sistemde `FirstName` ve `LastName` Özellikler **zorunludur** ve bu nedenle null değildir.</span><span class="sxs-lookup"><span data-stu-id="694a8-219">The design intent (indicated in this case by the `Required` attribute) suggests that in this system, the `FirstName` and `LastName` properties are **mandatory**, and therefore not null.</span></span>

<span data-ttu-id="694a8-220">`VehicleRegistration`Özellik **zorunlu değil**, null olabilir.</span><span class="sxs-lookup"><span data-stu-id="694a8-220">The `VehicleRegistration` property is **not mandatory**, so may be null.</span></span>

<span data-ttu-id="694a8-221">Null yapılabilir başvuru türlerini etkinleştirdiğinizde, DTO 'inizdeki hangi özelliklerin boş değer atanabilir olabileceğini, özgün amacınızla tutarlı olduğunu belirtmek istersiniz:</span><span class="sxs-lookup"><span data-stu-id="694a8-221">When you enable nullable reference types, you want to indicate which properties on your DTO may be nullable, consistent with your original intent:</span></span>

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="694a8-222">Bu DTO için, null olabilecek tek özellik ``VehicleRegistration`` .</span><span class="sxs-lookup"><span data-stu-id="694a8-222">For this DTO, the only property that may be null is ``VehicleRegistration``.</span></span>

<span data-ttu-id="694a8-223">Ancak, derleyici `CS8618` hem hem de için uyarıları başlatır `FirstName` ve `LastName` null yapılamayan özelliklerin başlatılmamış olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="694a8-223">However, the compiler raises `CS8618` warnings for both `FirstName` and `LastName`, indicating the non-nullable properties are uninitialized.</span></span>

<span data-ttu-id="694a8-224">Derleyici uyarılarını özgün amacınızı sürdüren bir şekilde çözümlemek için kullanabileceğiniz üç seçenek mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="694a8-224">There are three options available to you that resolve the compiler warnings in a way that maintains the original intent.</span></span> <span data-ttu-id="694a8-225">Bu seçeneklerden herhangi biri geçerlidir; kodlama stilinize ve tasarım gereksinimlerinize en uygun olanı seçmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="694a8-225">Any of these options are valid; you should choose the one that best suits your coding style and design requirements.</span></span>

### <a name="initialize-in-the-constructor"></a><span data-ttu-id="694a8-226">Oluşturucuda Başlat</span><span class="sxs-lookup"><span data-stu-id="694a8-226">Initialize in the constructor</span></span>

<span data-ttu-id="694a8-227">Başlatılmamış uyarıları çözümlemek için ideal yol, oluşturucudaki özellikleri başlatmaktır:</span><span class="sxs-lookup"><span data-stu-id="694a8-227">The ideal way to resolve the uninitialized warnings is to initialize the properties in the constructor:</span></span>

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

<span data-ttu-id="694a8-228">Bu yaklaşım yalnızca sınıfı örneğini oluşturmak için kullandığınız kitaplık, kurucudaki parametreleri geçirmeyi destekliyorsa işe yarar.</span><span class="sxs-lookup"><span data-stu-id="694a8-228">This approach only works if the library that you use to instantiate the class supports passing parameters in the constructor.</span></span>

<span data-ttu-id="694a8-229">Bir kitaplık, kurucudaki *bazı* özelliklerin geçirilmesini destekleyebilir, ancak tümünü desteklemez.</span><span class="sxs-lookup"><span data-stu-id="694a8-229">A library may support passing *some* properties in the constructor, but not all.</span></span> <span data-ttu-id="694a8-230">Örneğin, EF Core normal sütun özellikleri için [Oluşturucu bağlamasını](/ef/core/modeling/constructors) destekler, ancak gezinti özellikleri içermez.</span><span class="sxs-lookup"><span data-stu-id="694a8-230">For example, EF Core supports [constructor binding](/ef/core/modeling/constructors) for normal column properties, but not navigation properties.</span></span>

<span data-ttu-id="694a8-231">Oluşturucuyu bağlamayı destekleme kapsamını anlamak için, sınıfınızı örnekleyen kitaplıktaki belgeleri denetleyin.</span><span class="sxs-lookup"><span data-stu-id="694a8-231">Check the documentation on the library that instantiates your class, to understand the extent to which it supports constructor binding.</span></span>

### <a name="property-with-nullable-backing-field"></a><span data-ttu-id="694a8-232">Null yapılabilir destek alanı olan özellik</span><span class="sxs-lookup"><span data-stu-id="694a8-232">Property with nullable backing field</span></span>

<span data-ttu-id="694a8-233">Oluşturucu bağlama sizin için çalışmazsa, bu sorunu gidermek için bir yol null yapılabilir bir yedekleme alanı olan null yapılamayan bir özelliğe sahip olur:</span><span class="sxs-lookup"><span data-stu-id="694a8-233">If constructor binding won't work for you, one way to deal with this problem is to have a non-nullable property with a nullable backing field:</span></span>

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

<span data-ttu-id="694a8-234">Bu senaryoda, `FirstName` özelliği başlatılmadan önce erişiliyorsa, `InvalidOperationException` API sözleşmesi yanlış kullanıldığı için kod bir oluşturur.</span><span class="sxs-lookup"><span data-stu-id="694a8-234">In this scenario, if the `FirstName` property is accessed before it has been initialized, then the code throws an `InvalidOperationException`, because the API contract has been used incorrectly.</span></span>

<span data-ttu-id="694a8-235">Bazı kitaplıkların, yedekleme alanları kullanılırken özel hususlar olabileceğini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="694a8-235">Consider that some libraries may have special considerations when using backing fields.</span></span> <span data-ttu-id="694a8-236">Örneğin, EF Core [alanları](/ef/core/modeling/backing-field) doğru şekilde kullanmak için yapılandırılması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="694a8-236">For example, EF Core may need to be configured to use [backing fields](/ef/core/modeling/backing-field) correctly.</span></span>

### <a name="initialize-the-property-to-null"></a><span data-ttu-id="694a8-237">Özelliği null olarak Başlat</span><span class="sxs-lookup"><span data-stu-id="694a8-237">Initialize the property to null</span></span>

<span data-ttu-id="694a8-238">Null olabilir bir yedekleme alanı kullanmanın bir alternatifi olarak veya sınıfınızı örnekleyen kitaplık Bu yaklaşımla uyumlu değilse, özelliği `null` doğrudan, null-forverme işlecinin () yardımıyla birlikte başlatabilirsiniz `!` :</span><span class="sxs-lookup"><span data-stu-id="694a8-238">As a terser alternative to using a nullable backing field, or if the library that instantiates your class isn't compatible with that approach, you can initialize the property to `null` directly, with the help of the null-forgiving operator (`!`):</span></span>

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

<span data-ttu-id="694a8-239">Çalışma zamanında gerçek bir null değeri, bir programlama hatasının sonucu hariç, özelliği düzgün bir şekilde başlatılmadan önce özelliğe erişerek hiçbir zaman gözlemleyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="694a8-239">You'll never observe an actual null value at runtime except as a result of a programming bug, by accessing the property before it has been properly initialized.</span></span>

## <a name="see-also"></a><span data-ttu-id="694a8-240">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="694a8-240">See also</span></span>

- [<span data-ttu-id="694a8-241">Var olan bir kod temelinin Nullable başvurulara geçirilmesi</span><span class="sxs-lookup"><span data-stu-id="694a8-241">Migrate an existing codebase to nullable references</span></span>](whats-new/tutorials/upgrade-to-nullable-references.md)
- [<span data-ttu-id="694a8-242">EF Core null yapılabilir başvuru türleriyle çalışma</span><span class="sxs-lookup"><span data-stu-id="694a8-242">Working with Nullable Reference Types in EF Core</span></span>](/ef/core/miscellaneous/nullable-reference-types)
