---
title: Atarsa-C# Kılavuzu
description: ", Atanmamış, discardable değişkenleri ve atma 'un kullanılabileceği yollarla ilgili olarak, C# ' nin atma desteğini açıklar."
ms.technology: csharp-fundamentals
ms.date: 09/22/2020
ms.openlocfilehash: 7562da880ff3136dfc04ce4061bafa8ed55f5a23
ms.sourcegitcommit: 38999dc0ec4f7c4404de5ce0951b64c55997d9ab
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/02/2021
ms.locfileid: "99426924"
---
# <a name="discards---c-guide"></a><span data-ttu-id="5c86b-103">Atarsa-C# Kılavuzu</span><span class="sxs-lookup"><span data-stu-id="5c86b-103">Discards - C# Guide</span></span>

<span data-ttu-id="5c86b-104">C# 7,0 ' den itibaren C#, uygulama kodunda kasıtlı olarak kullanılmamış olan yer tutucu değişkenleri olan atma 'yı destekler.</span><span class="sxs-lookup"><span data-stu-id="5c86b-104">Starting with C# 7.0, C# supports discards, which are placeholder variables that are intentionally unused in application code.</span></span> <span data-ttu-id="5c86b-105">Atma, atanmamış değişkenlere eşdeğerdir; Bunlar bir değere sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-105">Discards are equivalent to unassigned variables; they don't have a value.</span></span> <span data-ttu-id="5c86b-106">Bir atma, derleyici ve kodunuzu okuyan diğerleri için amacı iletişim kurar: bir ifadenin sonucunu yok saymayı amaçlıyorsanız.</span><span class="sxs-lookup"><span data-stu-id="5c86b-106">A discard communicates intent to the compiler and others that read your code: You intended to ignore the result of an expression.</span></span> <span data-ttu-id="5c86b-107">Bir ifadenin sonucunu, bir tanımlama grubu ifadesinin bir veya daha fazla üyesini, `out` bir yönteme parametre veya bir model eşleştirme ifadesinin hedefini yok saymanız gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-107">You may want to ignore the result of an expression, one or more members of a tuple expression, an `out` parameter to a method, or the target of a pattern matching expression.</span></span>

<span data-ttu-id="5c86b-108">Yalnızca tek bir atma değişkeni olduğundan, bu değişken, depolama alanı bile ayrılmamış olabilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-108">Because there's only a single discard variable, that variable may not even be allocated storage.</span></span> <span data-ttu-id="5c86b-109">Atma, bellek ayırmalarını azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-109">Discards can reduce memory allocations.</span></span> <span data-ttu-id="5c86b-110">Atarsa, kodunuzun amacını açık hale getirir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-110">Discards make the intent of your code clear.</span></span> <span data-ttu-id="5c86b-111">Okunabilirliği ve bakım ve bakım özelliklerini geliştirir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-111">They enhance its readability and maintainability.</span></span>

<span data-ttu-id="5c86b-112">Bir değişkenin, adı olarak alt çizgi () atayarak bir atma olduğunu belirtirsiniz `_` .</span><span class="sxs-lookup"><span data-stu-id="5c86b-112">You indicate that a variable is a discard by assigning it the underscore (`_`) as its name.</span></span> <span data-ttu-id="5c86b-113">Örneğin, aşağıdaki yöntem çağrısı, birinci ve ikinci değerlerin dıştığı bir tanımlama grubu döndürür.</span><span class="sxs-lookup"><span data-stu-id="5c86b-113">For example, the following method call returns a tuple in which the first and second values are discards.</span></span> <span data-ttu-id="5c86b-114">`area` , önceden tanımlanmış bir değişken tarafından döndürülen üçüncü bileşene ayarlanır `GetCityInformation` :</span><span class="sxs-lookup"><span data-stu-id="5c86b-114">`area` is a previously declared variable set to the third component returned by `GetCityInformation`:</span></span>

```csharp
(_, _, area) = city.GetCityInformation(cityName);
```

<span data-ttu-id="5c86b-115">C# 9,0 ' den başlayarak, bir lambda ifadesinin kullanılmayan giriş parametrelerini belirtmek için atarsa ' u kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5c86b-115">Beginning with C# 9.0, you can use discards to specify unused input parameters of a lambda expression.</span></span> <span data-ttu-id="5c86b-116">Daha fazla bilgi için [lambda ifadeleri](language-reference/operators/lambda-expressions.md) makalesinin [lambda ifadesinin giriş parametreleri](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="5c86b-116">For more information, see the [Input parameters of a lambda expression](language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="5c86b-117">`_`Geçerli bir atma olduğunda, değerini alma veya bir atama işleminde kullanma girişimi, "' \_ ' adı geçerli bağlamda mevcut değil" DERLEYICI hatası CS0301 oluşturur.</span><span class="sxs-lookup"><span data-stu-id="5c86b-117">When `_` is a valid discard, attempting to retrieve its value or use it in an assignment operation generates compiler error CS0301, "The name '\_' doesn't exist in the current context".</span></span> <span data-ttu-id="5c86b-118">Bu hataya `_` bir değer atanmadığından ve bir depolama konumu atanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-118">This error is because `_` isn't assigned a value, and may not even be assigned a storage location.</span></span> <span data-ttu-id="5c86b-119">Gerçek bir değişkense, önceki örnekte olduğu gibi birden fazla değeri atlamadınız.</span><span class="sxs-lookup"><span data-stu-id="5c86b-119">If it were an actual variable, you couldn't discard more than one value, as the previous example did.</span></span>

## <a name="tuple-and-object-deconstruction"></a><span data-ttu-id="5c86b-120">Demet ve nesne oluşturmayı kaldırma</span><span class="sxs-lookup"><span data-stu-id="5c86b-120">Tuple and object deconstruction</span></span>

<span data-ttu-id="5c86b-121">Atma, uygulama kodunuz bazı demet öğeleri kullandığında ancak diğerlerini yoksaytığında tanımlama grupları ile çalışma konusunda faydalıdır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-121">Discards are useful in working with tuples when your application code uses some tuple elements but ignores others.</span></span> <span data-ttu-id="5c86b-122">Örneğin, aşağıdaki yöntem, `QueryCityDataForYears` şehir adı, alanı, yıl, bu yıl için şehir popülasyonu, ikinci yıl ve bu ikinci yıl için şehir popülasyonu döndürür.</span><span class="sxs-lookup"><span data-stu-id="5c86b-122">For example, the following `QueryCityDataForYears` method returns a tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year.</span></span> <span data-ttu-id="5c86b-123">Örnek, bu iki yıl arasındaki popülasyondaki değişikliği gösterir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-123">The example shows the change in population between those two years.</span></span> <span data-ttu-id="5c86b-124">Kayıt kümesinden kullanılabilen veriler, şehir alanıyla ilgilentik ve tasarım zamanında şehir adını ve iki tarihi biliyoruz.</span><span class="sxs-lookup"><span data-stu-id="5c86b-124">Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time.</span></span> <span data-ttu-id="5c86b-125">Sonuç olarak, yalnızca kayıt düzeninde depolanan iki popülasyon değeri ile ilgileniyoruz ve kalan değerlerini atma olarak işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-125">As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.</span></span>  

:::code language="csharp" source="snippets/discards/discard-tuple.cs" ID="DiscardTupleMember" :::

<span data-ttu-id="5c86b-126">Atma ile tanımlama gruplarını kaldırma hakkında daha fazla bilgi için bkz. [tanımlama gruplarını ve diğer türleri kaldırma](deconstruct.md#deconstructing-tuple-elements-with-discards).</span><span class="sxs-lookup"><span data-stu-id="5c86b-126">For more information on deconstructing tuples with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-tuple-elements-with-discards).</span></span>

<span data-ttu-id="5c86b-127">`Deconstruct`Bir sınıf, yapı veya arabirim yöntemi Ayrıca bir nesneden belirli bir veri kümesini almanıza ve oluşturmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="5c86b-127">The `Deconstruct` method of a class, structure, or interface also allows you to retrieve and deconstruct a specific set of data from an object.</span></span> <span data-ttu-id="5c86b-128">Yalnızca ayrıştırılmış değerlerin yalnızca bir alt kümesiyle çalışmayı ilgileniyorsanız, atma ' yı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5c86b-128">You can use discards when you're interested in working with only a subset of the deconstructed values.</span></span> <span data-ttu-id="5c86b-129">Aşağıdaki örnek, bir `Person` nesnesini dört dizeye (ilk ve son adlar, şehir ve eyalet) ayırır, ancak son adı ve durumu atar.</span><span class="sxs-lookup"><span data-stu-id="5c86b-129">The following example deconstructs a `Person` object into four strings (the first and last names, the city, and the state), but discards the last name and the state.</span></span>

:::code language="csharp" source="snippets/discards/discard-class.cs" :::

<span data-ttu-id="5c86b-130">Kullanıcı tanımlı türleri atma ile kaldırma hakkında daha fazla bilgi için bkz. [tanımlama gruplarını ve diğer türleri kaldırma](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span><span class="sxs-lookup"><span data-stu-id="5c86b-130">For more information on deconstructing user-defined types with discards, see [Deconstructing tuples and other types](deconstruct.md#deconstructing-a-user-defined-type-with-discards).</span></span>

## <a name="pattern-matching-with-switch"></a><span data-ttu-id="5c86b-131">' Switch ' ile eşleşen desenler</span><span class="sxs-lookup"><span data-stu-id="5c86b-131">Pattern matching with \`switch</span></span>

<span data-ttu-id="5c86b-132">*Atma stili* , [anahtar](language-reference/keywords/switch.md) anahtar sözcüğüyle birlikte bir model eşleme içinde kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-132">The *discard pattern* can be used in pattern matching with the [switch](language-reference/keywords/switch.md) keyword.</span></span> <span data-ttu-id="5c86b-133">Her ifade her zaman atma düzeniyle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-133">Every expression always matches the discard pattern.</span></span> <span data-ttu-id="5c86b-134">(Bu [,,](language-reference/keywords/is.md) ifadeleriyle birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-134">(It can be used with [is](language-reference/keywords/is.md) expressions.</span></span> <span data-ttu-id="5c86b-135">Bununla birlikte, atma bunun anlamı değiştirilmeden kaldırılabileceğinden, bu kullanım nadir bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="5c86b-135">However, that use is rare because the discard can be removed without changing its meaning).</span></span>

<span data-ttu-id="5c86b-136">Aşağıdaki örnek `ProvidesFormatInfo` , bir nesnenin bir uygulama verip içermediğini ve nesnenin olup olmadığını test etmek için [,,,,](language-reference/keywords/is.md) bir yöntemi tanımlar <xref:System.IFormatProvider> `null` .</span><span class="sxs-lookup"><span data-stu-id="5c86b-136">The following example defines a `ProvidesFormatInfo` method that uses [is](language-reference/keywords/is.md) statements to determine whether an object provides an <xref:System.IFormatProvider> implementation and tests whether the object is `null`.</span></span> <span data-ttu-id="5c86b-137">Ayrıca, başka bir türdeki null olmayan nesneleri işlemek için de atma modelini kullanır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-137">It also uses the discard pattern to handle non-null objects of any other type.</span></span>

:::code language="csharp" source="snippets/discards/discard-pattern2.cs" ID="DiscardSwitchExample" :::

## <a name="calls-to-methods-with-out-parameters"></a><span data-ttu-id="5c86b-138">Parametrelere sahip yöntemlere çağrılar `out`</span><span class="sxs-lookup"><span data-stu-id="5c86b-138">Calls to methods with `out` parameters</span></span>

<span data-ttu-id="5c86b-139">`Deconstruct`Kullanıcı tanımlı bir türü (bir sınıf, yapı veya arabirim örneği) oluşturmak için yöntemini çağırırken bağımsız değişkenlerin değerlerini atabilirsiniz `out` .</span><span class="sxs-lookup"><span data-stu-id="5c86b-139">When calling the `Deconstruct` method to deconstruct a user-defined type (an instance of a class, structure, or interface), you can discard the values of individual `out` arguments.</span></span> <span data-ttu-id="5c86b-140">Ancak `out` parametre ile herhangi bir yöntemi çağırırken bağımsız değişkenlerin değerini de atabilirsiniz `out` .</span><span class="sxs-lookup"><span data-stu-id="5c86b-140">But you can also discard the value of `out` arguments when calling any method with an `out` parameter.</span></span>

<span data-ttu-id="5c86b-141">Aşağıdaki örnek, bir tarihin dize temsilinin geçerli kültür içinde geçerli olup olmadığını belirlemek için [DateTime. Trypari (dize, Out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) yöntemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-141">The following example calls the [DateTime.TryParse(String, out DateTime)](<xref:System.DateTime.TryParse(System.String,System.DateTime@)>) method to determine whether the string representation of a date is valid in the current culture.</span></span> <span data-ttu-id="5c86b-142">Örnek yalnızca tarih dizesini doğrulamaya ve tarihi ayıklamak için ayrıştırılmaya karşı düşünüldüğünde, `out` yöntemin bağımsız değişkeni bir atma işlemi olur.</span><span class="sxs-lookup"><span data-stu-id="5c86b-142">Because the example is concerned only with validating the date string and not with parsing it to extract the date, the `out` argument to the method is a discard.</span></span>

:::code language="csharp" source="snippets/discards/discard-out1.cs" ID="DiscardOutParameter" :::

## <a name="a-standalone-discard"></a><span data-ttu-id="5c86b-143">Tek başına atma</span><span class="sxs-lookup"><span data-stu-id="5c86b-143">A standalone discard</span></span>

<span data-ttu-id="5c86b-144">Yok saymayı seçtiğiniz herhangi bir değişkeni belirtmek için tek başına atmayı kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5c86b-144">You can use a standalone discard to indicate any variable that you choose to ignore.</span></span> <span data-ttu-id="5c86b-145">Bir bağımsız değişkenin null olmamasını sağlamak için bir atama kullanmak tipik bir kullanımdır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-145">One typical use is to use an assignment to ensure that an argument isn't null.</span></span> <span data-ttu-id="5c86b-146">Aşağıdaki kod bir atamayı zorlamak için bir atma kullanır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-146">The following code uses a discard to force an assignment.</span></span> <span data-ttu-id="5c86b-147">Atamanın sağ tarafı, bağımsız değişken olduğunda bir oluşturmak için [null birleştirme işlecini](language-reference/operators/null-coalescing-operator.md) kullanır <xref:System.ArgumentNullException?displayProperty=nameWithType> `null` .</span><span class="sxs-lookup"><span data-stu-id="5c86b-147">The right side of the assignment uses the [null coalescing operator](language-reference/operators/null-coalescing-operator.md) to throw an <xref:System.ArgumentNullException?displayProperty=nameWithType> when the argument is `null`.</span></span> <span data-ttu-id="5c86b-148">Kod, atamanın sonucuna ihtiyaç duymazsa, atılır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-148">The code doesn't need the result of the assignment, so it's discarded.</span></span> <span data-ttu-id="5c86b-149">İfade null denetimi zorlar.</span><span class="sxs-lookup"><span data-stu-id="5c86b-149">The expression forces a null check.</span></span> <span data-ttu-id="5c86b-150">Atma amacınızı belirler: atamanın sonucu gerekli değildir veya kullanılmaz.</span><span class="sxs-lookup"><span data-stu-id="5c86b-150">The discard clarifies your intent: the result of the assignment isn't needed or used.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="ArgNullCheck" :::

<span data-ttu-id="5c86b-151">Aşağıdaki örnek, <xref:System.Threading.Tasks.Task> zaman uyumsuz bir işlem tarafından döndürülen nesneyi yoksaymak için tek başına atmayı kullanır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-151">The following example uses a standalone discard to ignore the <xref:System.Threading.Tasks.Task> object returned by an asynchronous operation.</span></span> <span data-ttu-id="5c86b-152">Görevin atanması, işlemin tamamlanmasında olduğu gibi oluşturduğu özel durumu gizleme etkisine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-152">Assigning the task has the effect of suppressing the exception that the operation throws as it is about to complete.</span></span> <span data-ttu-id="5c86b-153">Amacınızı açık hale getirir: `Task` ' ı atmak ve bu zaman uyumsuz işlemden oluşturulan tüm hataları yoksaymak istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="5c86b-153">It makes your intent clear: You want to discard the `Task`, and ignore any errors generated from that asynchronous operation.</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetDiscardTask" :::

<span data-ttu-id="5c86b-154">Görevi bir atılsın atamadan aşağıdaki kod bir derleyici uyarısı oluşturur:</span><span class="sxs-lookup"><span data-stu-id="5c86b-154">Without assigning the task to a discard, the following code generates a compiler warning:</span></span>

:::code language="csharp" source="snippets/discards/standalone-discard1.cs" ID="SnippetNoDiscardTask" :::

> [!NOTE]
> <span data-ttu-id="5c86b-155">Bir hata ayıklayıcı kullanarak önceki iki örnekten birini çalıştırırsanız, özel durum oluştuğunda hata ayıklayıcı programı durdurur.</span><span class="sxs-lookup"><span data-stu-id="5c86b-155">If you run either of the preceding two samples using a debugger, the debugger will stop the program when the exception is thrown.</span></span> <span data-ttu-id="5c86b-156">Bir hata ayıklayıcı ekli olmadığında, her iki durumda da sessizce yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-156">Without a debugger attached, the exception is silently ignored in both cases.</span></span>

<span data-ttu-id="5c86b-157">`_` aynı zamanda geçerli bir tanımlayıcıdır.</span><span class="sxs-lookup"><span data-stu-id="5c86b-157">`_` is also a valid identifier.</span></span> <span data-ttu-id="5c86b-158">Desteklenen bir bağlam dışında kullanıldığında, `_` atma olarak kabul edilir, ancak geçerli bir değişken olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="5c86b-158">When used outside of a supported context, `_` is treated not as a discard but as a valid variable.</span></span> <span data-ttu-id="5c86b-159">Adlı bir tanımlayıcı `_` zaten kapsamda ise, `_` tek başına atma olarak kullanılması şu şekilde olabilir:</span><span class="sxs-lookup"><span data-stu-id="5c86b-159">If an identifier named `_` is already in scope, the use of `_` as a standalone discard can result in:</span></span>

- <span data-ttu-id="5c86b-160">İstenen atma değeri atanarak kapsam içi değişkenin değerini yanlışlıkla değiştirme `_` .</span><span class="sxs-lookup"><span data-stu-id="5c86b-160">Accidental modification of the value of the in-scope `_` variable by assigning it the value of the intended discard.</span></span> <span data-ttu-id="5c86b-161">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="5c86b-161">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableIdentifier" :::
- <span data-ttu-id="5c86b-162">Tür güvenliğini ihlal eden bir derleyici hatası.</span><span class="sxs-lookup"><span data-stu-id="5c86b-162">A compiler error for violating type safety.</span></span> <span data-ttu-id="5c86b-163">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="5c86b-163">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="VariableTypeInference" :::
- <span data-ttu-id="5c86b-164">Derleyici hatası CS0136, " \_ Bu ad bir yerel veya parametre tanımlamak için kapsayan bir yerel kapsamda kullanıldığı için," ' ' adlı yerel veya parametre bu kapsamda bildirilemez. "</span><span class="sxs-lookup"><span data-stu-id="5c86b-164">Compiler error CS0136, "A local or parameter named '\_' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter."</span></span> <span data-ttu-id="5c86b-165">Örneğin:</span><span class="sxs-lookup"><span data-stu-id="5c86b-165">For example:</span></span>
   :::code language="csharp" source="snippets/discards/standalone-discard2.cs" ID="CannotRedeclare" :::

## <a name="see-also"></a><span data-ttu-id="5c86b-166">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="5c86b-166">See also</span></span>

- [<span data-ttu-id="5c86b-167">Demetleri ve diğer türleri ayrıştırma</span><span class="sxs-lookup"><span data-stu-id="5c86b-167">Deconstructing tuples and other types</span></span>](deconstruct.md)
- [<span data-ttu-id="5c86b-168">`is` sözcükle</span><span class="sxs-lookup"><span data-stu-id="5c86b-168">`is` keyword</span></span>](language-reference/keywords/is.md)
- [<span data-ttu-id="5c86b-169">`switch` sözcükle</span><span class="sxs-lookup"><span data-stu-id="5c86b-169">`switch` keyword</span></span>](language-reference/keywords/switch.md)
