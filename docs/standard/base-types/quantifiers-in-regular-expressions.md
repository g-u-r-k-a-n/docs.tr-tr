---
title: Normal İfadelerdeki Miktar Niceleyiciler
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, quantifiers
- metacharacters, quantifiers
- minimal matching quantifiers
- quantifiers in regular expressions
- .NET Framework regular expressions, quantifiers
- quantifiers
- lazy quantifiers
ms.assetid: 36b81212-6511-49ed-a8f1-ff080415312f
ms.openlocfilehash: f1627248cbed0f03c6fb76ce660f9b2bf7764781
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "78160020"
---
# <a name="quantifiers-in-regular-expressions"></a><span data-ttu-id="5e1bc-102">Normal İfadelerdeki Miktar Niceleyiciler</span><span class="sxs-lookup"><span data-stu-id="5e1bc-102">Quantifiers in Regular Expressions</span></span>
<span data-ttu-id="5e1bc-103">Niceleyiciler, eşleşmenin bulunabilmesi için girişte bir karakter, grup veya karakter sınıfının kaç örneğinin bulunması gerektiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-103">Quantifiers specify how many instances of a character, group, or character class must be present in the input for a match to be found.</span></span>  <span data-ttu-id="5e1bc-104">Aşağıdaki tabloda .NET tarafından desteklenen niceleyiciler listelenir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-104">The following table lists the quantifiers supported by .NET.</span></span>  
  
|<span data-ttu-id="5e1bc-105">Açgözlü niceleyici</span><span class="sxs-lookup"><span data-stu-id="5e1bc-105">Greedy quantifier</span></span>|<span data-ttu-id="5e1bc-106">Tembel niceleyici</span><span class="sxs-lookup"><span data-stu-id="5e1bc-106">Lazy quantifier</span></span>|<span data-ttu-id="5e1bc-107">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-107">Description</span></span>|  
|-----------------------|---------------------|-----------------|  
|`*`|`*?`|<span data-ttu-id="5e1bc-108">Sıfır veya daha fazla kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-108">Match zero or more times.</span></span>|  
|`+`|`+?`|<span data-ttu-id="5e1bc-109">Bir veya daha fazla kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-109">Match one or more times.</span></span>|  
|`?`|`??`|<span data-ttu-id="5e1bc-110">Sıfırı ya da bir kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-110">Match zero or one time.</span></span>|  
|<span data-ttu-id="5e1bc-111">`{`*n*`}`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-111">`{` *n* `}`</span></span>|<span data-ttu-id="5e1bc-112">`{`*n*`}?`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-112">`{` *n* `}?`</span></span>|<span data-ttu-id="5e1bc-113">Tam olarak *n* kez maç.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-113">Match exactly *n* times.</span></span>|  
|<span data-ttu-id="5e1bc-114">`{`*n*`,}`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-114">`{` *n* `,}`</span></span>|<span data-ttu-id="5e1bc-115">`{`*n*`,}?`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-115">`{` *n* `,}?`</span></span>|<span data-ttu-id="5e1bc-116">En az *n* kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-116">Match at least *n* times.</span></span>|  
|<span data-ttu-id="5e1bc-117">`{`*n* `,` *m*`}`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-117">`{` *n* `,` *m* `}`</span></span>|<span data-ttu-id="5e1bc-118">`{`*n* `,` *m*`}?`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-118">`{` *n* `,` *m* `}?`</span></span>|<span data-ttu-id="5e1bc-119">*N'den* *m'ye* kadar olan zamanları eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-119">Match from *n* to *m* times.</span></span>|  
  
 <span data-ttu-id="5e1bc-120">Miktarları `n` `m` ve onsa sabitleri vardır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-120">The quantities `n` and `m` are integer constants.</span></span> <span data-ttu-id="5e1bc-121">Normalde, niceleyiciler açgözlüdür; normal ifade altyapısının belirli desenlerdeki birçok olayla mümkün olduğunca eşleşmesine neden olurlar.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-121">Ordinarily, quantifiers are greedy; they cause the regular expression engine to match as many occurrences of particular patterns as possible.</span></span> <span data-ttu-id="5e1bc-122">`?` Karakteri bir niceleyiciye eklemek onu tembelleştirir; normal ifade altyapısının mümkün olduğunca az olayla eşleşmesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-122">Appending the `?` character to a quantifier makes it lazy; it causes the regular expression engine to match as few occurrences as possible.</span></span> <span data-ttu-id="5e1bc-123">Açgözlü ve tembel niceleyiciler arasındaki farkın tam bir açıklaması için, bu konuda daha sonra bölüm [Açgözlü ve Tembel Quantifiers](#Greedy) bakın.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-123">For a complete description of the difference between greedy and lazy quantifiers, see the section [Greedy and Lazy Quantifiers](#Greedy) later in this topic.</span></span>  
  
> [!IMPORTANT]
> <span data-ttu-id="5e1bc-124">İç içe niceleyiciler (örneğin, normal ifade `(a*)*` deseni gibi) giriş dizesinde karakter sayısının üstel bir işlevi olarak, normal ifade altyapısının gerçekleştirmesi gereken karşılaştırma sayısını artırabilir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-124">Nesting quantifiers (for example, as the regular expression pattern `(a*)*` does) can increase the number of comparisons that the regular expression engine must perform, as an exponential function of the number of characters in the input string.</span></span> <span data-ttu-id="5e1bc-125">Bu davranış ve geçici geçici işleri hakkında daha fazla bilgi için [Geri İzleme'ye](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-125">For more information about this behavior and its workarounds, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="regular-expression-quantifiers"></a><span data-ttu-id="5e1bc-126">Düzenli İfade Niceleyicileri</span><span class="sxs-lookup"><span data-stu-id="5e1bc-126">Regular Expression Quantifiers</span></span>  
 <span data-ttu-id="5e1bc-127">Aşağıdaki bölümlerde .NET düzenli ifadeleri tarafından desteklenen niceleyiciler listelenir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-127">The following sections list the quantifiers supported by .NET regular expressions.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="5e1bc-128">\*, +, ?, {, ve } karakterleri normal bir ifade deseninde karşılaşılırsa, normal ifade altyapısı bunları bir [karakter sınıfına](../../../docs/standard/base-types/character-classes-in-regular-expressions.md)dahil edilmedikçe niceleyici veya niceleyici yapılarının bir parçası olarak yorumlar.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-128">If the \*, +, ?, {, and } characters are encountered in a regular expression pattern, the regular expression engine interprets them as quantifiers or part of quantifier constructs unless they are included in a [character class](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).</span></span> <span data-ttu-id="5e1bc-129">Bunları bir karakter sınıfının dışındaki gerçek karakterler olarak yorumlamak için, onlardan önce bir ters eğik çizgi ile kaçmalısınız.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-129">To interpret these as literal characters outside a character class, you must escape them by preceding them with a backslash.</span></span> <span data-ttu-id="5e1bc-130">Örneğin, normal `\*` bir ifade desenindeki dize, gerçek bir yıldız\*işareti (" ") karakter olarak yorumlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-130">For example, the string `\*` in a regular expression pattern is interpreted as a literal asterisk ("\*") character.</span></span>  
  
### <a name="match-zero-or-more-times-"></a><span data-ttu-id="5e1bc-131">Match Zero veya More Times: \*</span><span class="sxs-lookup"><span data-stu-id="5e1bc-131">Match Zero or More Times: \*</span></span>  
 <span data-ttu-id="5e1bc-132">`*` Niceleyici, önceki öğe sıfır veya daha fazla kez eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-132">The `*` quantifier matches the preceding element zero or more times.</span></span> <span data-ttu-id="5e1bc-133">`{0,}` Niceleyiciye eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-133">It is equivalent to the `{0,}` quantifier.</span></span> <span data-ttu-id="5e1bc-134">`*`tembel eşdeğeri olan açgözlü bir niceleyicidir. `*?`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-134">`*` is a greedy quantifier whose lazy equivalent is `*?`.</span></span>  
  
 <span data-ttu-id="5e1bc-135">Aşağıdaki örnekte bu normal ifade gösteriş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-135">The following example illustrates this regular expression.</span></span> <span data-ttu-id="5e1bc-136">Giriş dizesinde dokuz basamak, beş eşler desen`95`ve `929` `9219`dört `9919`( , , , ve ) yok.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-136">Of the nine digits in the input string, five match the pattern and four (`95`, `929`, `9219`, and `9919`) do not.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#1)]  
  
 <span data-ttu-id="5e1bc-137">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-137">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-138">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-138">Pattern</span></span>|<span data-ttu-id="5e1bc-139">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-139">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-140">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-140">Start at a word boundary.</span></span>|  
|`91*`|<span data-ttu-id="5e1bc-141">Bir "9"u sıfır veya daha fazla "1" karakterle eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-141">Match a "9" followed by zero or more "1" characters.</span></span>|  
|`9*`|<span data-ttu-id="5e1bc-142">Sıfır veya daha fazla "9" karakteri eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-142">Match zero or more "9" characters.</span></span>|  
|`\b`|<span data-ttu-id="5e1bc-143">Bir sözcük sınırında bit.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-143">End at a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-"></a><span data-ttu-id="5e1bc-144">Bir veya Daha Fazla Kez Eşleştir: +</span><span class="sxs-lookup"><span data-stu-id="5e1bc-144">Match One or More Times: +</span></span>  
 <span data-ttu-id="5e1bc-145">`+` Niceleyici, önceki öğeyle bir veya daha fazla kez eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-145">The `+` quantifier matches the preceding element one or more times.</span></span> <span data-ttu-id="5e1bc-146">Bu eşdeğerdir `{1,}`.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-146">It is equivalent to `{1,}`.</span></span> <span data-ttu-id="5e1bc-147">`+`tembel eşdeğeri olan açgözlü bir niceleyicidir. `+?`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-147">`+` is a greedy quantifier whose lazy equivalent is `+?`.</span></span>  
  
 <span data-ttu-id="5e1bc-148">Örneğin, normal ifade `\ban+\w*?\b` harfi `n`bir veya daha fazla `a` örnek ardından harf ile başlayan tüm sözcükleri eşleştirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-148">For example, the regular expression `\ban+\w*?\b` tries to match entire words that begin with the letter `a` followed by one or more instances of the letter `n`.</span></span> <span data-ttu-id="5e1bc-149">Aşağıdaki örnekte bu normal ifade gösteriş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-149">The following example illustrates this regular expression.</span></span> <span data-ttu-id="5e1bc-150">Normal ifade, , `an` `annual`, `announcement`, `antique`ve , kelimeleri `autumn` eşleşir ve doğru bir şekilde eşleşmiyor ve `all`.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-150">The regular expression matches the words `an`, `annual`, `announcement`, and `antique`, and correctly fails to match `autumn` and `all`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#2)]  
  
 <span data-ttu-id="5e1bc-151">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-151">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-152">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-152">Pattern</span></span>|<span data-ttu-id="5e1bc-153">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-153">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-154">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-154">Start at a word boundary.</span></span>|  
|`an+`|<span data-ttu-id="5e1bc-155">Bir "a" ve ardından bir veya daha fazla "n" karakterini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-155">Match an "a" followed by one or more "n" characters.</span></span>|  
|`\w*?`|<span data-ttu-id="5e1bc-156">Bir sözcük karakterini sıfır veya daha fazla kez, ancak mümkün olduğunca az kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-156">Match a word character zero or more times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="5e1bc-157">Bir sözcük sınırında bit.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-157">End at a word boundary.</span></span>|  
  
### <a name="match-zero-or-one-time-"></a><span data-ttu-id="5e1bc-158">Maç Sıfır veya One Time: ?</span><span class="sxs-lookup"><span data-stu-id="5e1bc-158">Match Zero or One Time: ?</span></span>  
 <span data-ttu-id="5e1bc-159">`?` Niceleyici, bir önceki öğe sıfır veya bir kez eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-159">The `?` quantifier matches the preceding element zero or one time.</span></span> <span data-ttu-id="5e1bc-160">Bu eşdeğerdir `{0,1}`.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-160">It is equivalent to `{0,1}`.</span></span> <span data-ttu-id="5e1bc-161">`?`tembel eşdeğeri olan açgözlü bir niceleyicidir. `??`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-161">`?` is a greedy quantifier whose lazy equivalent is `??`.</span></span>  
  
 <span data-ttu-id="5e1bc-162">Örneğin, normal ifade `\ban?\b` harfi sıfır veya harfin `a` `n`bir örneği ardından gelen harfle başlayan tüm sözcükleri eşleştirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-162">For example, the regular expression `\ban?\b` tries to match entire words that begin with the letter `a` followed by zero or one instances of the letter `n`.</span></span> <span data-ttu-id="5e1bc-163">Başka bir deyişle, kelimeleri `a` eşleştirmeye `an`çalışır ve .</span><span class="sxs-lookup"><span data-stu-id="5e1bc-163">In other words, it tries to match the words `a` and `an`.</span></span> <span data-ttu-id="5e1bc-164">Aşağıdaki örnekte bu normal ifade gösteriş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-164">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#3](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#3)]
 [!code-vb[RegularExpressions.Quantifiers#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#3)]  
  
 <span data-ttu-id="5e1bc-165">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-165">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-166">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-166">Pattern</span></span>|<span data-ttu-id="5e1bc-167">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-167">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-168">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-168">Start at a word boundary.</span></span>|  
|`an?`|<span data-ttu-id="5e1bc-169">Bir "a" ve ardından sıfır veya bir "n" karakterini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-169">Match an "a" followed by zero or one "n" character.</span></span>|  
|`\b`|<span data-ttu-id="5e1bc-170">Bir sözcük sınırında bit.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-170">End at a word boundary.</span></span>|  
  
### <a name="match-exactly-n-times-n"></a><span data-ttu-id="5e1bc-171">Tam olarak n Times maç: {n}</span><span class="sxs-lookup"><span data-stu-id="5e1bc-171">Match Exactly n Times: {n}</span></span>  
 <span data-ttu-id="5e1bc-172">`{` *n* n`}` ölçüleyicisi, *n'nin* herhangi bir tamsayı olduğu önceki öğeyle tam olarak *n* kez eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-172">The `{`*n*`}` quantifier matches the preceding element exactly *n* times, where *n* is any integer.</span></span> <span data-ttu-id="5e1bc-173">`{`*n* `}` olan tembel eşdeğer `{` *n*`}?`açgözlü bir niceleyici olduğunu .</span><span class="sxs-lookup"><span data-stu-id="5e1bc-173">`{`*n*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`}?`.</span></span>  
  
 <span data-ttu-id="5e1bc-174">Örneğin, normal ifade `\b\d+\,\d{3}\b` bir sözcük sınırını eşleştirmeye çalışır ve ardından bir veya daha fazla ondalık basamak ve ardından üç ondalık basamak ve ardından bir sözcük sınırı nı takip eder.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-174">For example, the regular expression `\b\d+\,\d{3}\b` tries to match a word boundary followed by one or more decimal digits followed by three decimal digits followed by a word boundary.</span></span> <span data-ttu-id="5e1bc-175">Aşağıdaki örnekte bu normal ifade gösteriş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-175">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#4](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#4)]
 [!code-vb[RegularExpressions.Quantifiers#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#4)]  
  
 <span data-ttu-id="5e1bc-176">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-176">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-177">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-177">Pattern</span></span>|<span data-ttu-id="5e1bc-178">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-178">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-179">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-179">Start at a word boundary.</span></span>|  
|`\d+`|<span data-ttu-id="5e1bc-180">Bir veya daha fazla ondalık basamağı eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-180">Match one or more decimal digits.</span></span>|  
|`\,`|<span data-ttu-id="5e1bc-181">Virgül karakterini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-181">Match a comma character.</span></span>|  
|`\d{3}`|<span data-ttu-id="5e1bc-182">Üç ondalık basamakla eşleş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-182">Match three decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="5e1bc-183">Bir sözcük sınırında bit.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-183">End at a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-n"></a><span data-ttu-id="5e1bc-184">En Az n Kez Maç: {n,}</span><span class="sxs-lookup"><span data-stu-id="5e1bc-184">Match at Least n Times: {n,}</span></span>  
 <span data-ttu-id="5e1bc-185">`{` *n* n`,}` ölçüleyicisi, *n'nin* herhangi bir karşıcı olduğu önceki öğeyle en az *n* kez eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-185">The `{`*n*`,}` quantifier matches the preceding element at least *n* times, where *n* is any integer.</span></span> <span data-ttu-id="5e1bc-186">`{`*n* `,}` olan tembel eşdeğer `{` *n*`,}?`açgözlü bir niceleyici olduğunu .</span><span class="sxs-lookup"><span data-stu-id="5e1bc-186">`{`*n*`,}` is a greedy quantifier whose lazy equivalent is `{`*n*`,}?`.</span></span>  
  
 <span data-ttu-id="5e1bc-187">Örneğin, normal ifade, `\b\d{2,}\b\D+` bir sözcük sınırı ve ardından en az iki basamak la eşleşmeye çalışır ve ardından bir sözcük sınırı ve basamaksız bir karakter.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-187">For example, the regular expression `\b\d{2,}\b\D+` tries to match a word boundary followed by at least two digits followed by a word boundary and a non-digit character.</span></span> <span data-ttu-id="5e1bc-188">Aşağıdaki örnekte bu normal ifade gösteriş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-188">The following example illustrates this regular expression.</span></span> <span data-ttu-id="5e1bc-189">Normal ifade, yalnızca bir `"7 days"` ondalık basamak içerdiğinden tümcecikle eşleşmiyor, ancak tümceciklerle `"10 weeks and 300 years"`başarıyla eşleşiyor.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-189">The regular expression fails to match the phrase `"7 days"` because it contains just one decimal digit, but it successfully matches the phrases `"10 weeks and 300 years"`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#5](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#5)]
 [!code-vb[RegularExpressions.Quantifiers#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#5)]  
  
 <span data-ttu-id="5e1bc-190">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-190">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-191">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-191">Pattern</span></span>|<span data-ttu-id="5e1bc-192">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-192">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-193">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-193">Start at a word boundary.</span></span>|  
|`\d{2,}`|<span data-ttu-id="5e1bc-194">En az iki ondalık basamak eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-194">Match at least two decimal digits.</span></span>|  
|`\b`|<span data-ttu-id="5e1bc-195">Bir sözcük sınırıyla eşleş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-195">Match a word boundary.</span></span>|  
|`\D+`|<span data-ttu-id="5e1bc-196">En az bir ondalık olmayan basamak eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-196">Match at least one non-decimal digit.</span></span>|  
  
### <a name="match-between-n-and-m-times-nm"></a><span data-ttu-id="5e1bc-197">n ve m Saatleri Arasındaki Eşleşme: {n,m}</span><span class="sxs-lookup"><span data-stu-id="5e1bc-197">Match Between n and m Times: {n,m}</span></span>  
 <span data-ttu-id="5e1bc-198">`{` *n*n`,`*m* `}` m niceleyici, bir önceki elemanla en az *n* kez eşleşir, ancak *n* ve *m'nin* sayılattığı *m* kereden fazla olamaz.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-198">The `{`*n*`,`*m*`}` quantifier matches the preceding element at least *n* times, but no more than *m* times, where *n* and *m* are integers.</span></span> <span data-ttu-id="5e1bc-199">`{`*n*`,`*m* `}` olan tembel eşdeğer `{` *n*`,`*m*`}?`olan açgözlü bir niceleyici olduğunu .</span><span class="sxs-lookup"><span data-stu-id="5e1bc-199">`{`*n*`,`*m*`}` is a greedy quantifier whose lazy equivalent is `{`*n*`,`*m*`}?`.</span></span>  
  
 <span data-ttu-id="5e1bc-200">Aşağıdaki örnekte, normal `(00\s){2,4}` ifade iki sıfır basamak iki ve dört oluşumları arasında eşleşmeye çalışır ve ardından bir boşluk.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-200">In the following example, the regular expression `(00\s){2,4}` tries to match between two and four occurrences of two zero digits followed by a space.</span></span> <span data-ttu-id="5e1bc-201">Giriş dizesinin son bölümünün bu deseni en fazla dört yerine beş kez içerdiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-201">Note that the final portion of the input string includes this pattern five times rather than the maximum of four.</span></span> <span data-ttu-id="5e1bc-202">Ancak, bu alt dizenin yalnızca ilk bölümü (boşluk ve beşinci sıfır çifti) normal ifade deseniyle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-202">However, only the initial portion of this substring (up to the space and the fifth pair of zeros) matches the regular expression pattern.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#6](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#6)]
 [!code-vb[RegularExpressions.Quantifiers#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#6)]  
  
### <a name="match-zero-or-more-times-lazy-match-"></a><span data-ttu-id="5e1bc-203">Match Zero or More Times (Lazy Match): \*?</span><span class="sxs-lookup"><span data-stu-id="5e1bc-203">Match Zero or More Times (Lazy Match): \*?</span></span>  
 <span data-ttu-id="5e1bc-204">`*?` Niceleyici, önceki öğe sıfır veya daha fazla kez eşleşir, ancak mümkün olduğunca az kez.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-204">The `*?` quantifier matches the preceding element zero or more times, but as few times as possible.</span></span> <span data-ttu-id="5e1bc-205">Bu açgözlü niceleyici tembel `*`meslektaşıdır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-205">It is the lazy counterpart of the greedy quantifier `*`.</span></span>  
  
 <span data-ttu-id="5e1bc-206">Aşağıdaki örnekte, normal `\b\w*?oo\w*?\b` ifade dize `oo`içeren tüm sözcükleri eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-206">In the following example, the regular expression `\b\w*?oo\w*?\b` matches all words that contain the string `oo`.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#7](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#7)]
 [!code-vb[RegularExpressions.Quantifiers#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#7)]  
  
 <span data-ttu-id="5e1bc-207">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-207">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-208">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-208">Pattern</span></span>|<span data-ttu-id="5e1bc-209">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-209">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-210">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-210">Start at a word boundary.</span></span>|  
|`\w*?`|<span data-ttu-id="5e1bc-211">Sıfır veya daha fazla sözcük karakterini eşleştirin, ancak mümkün olduğunca az karakter.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-211">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`oo`|<span data-ttu-id="5e1bc-212">"oo" dizesini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-212">Match the string "oo".</span></span>|  
|`\w*?`|<span data-ttu-id="5e1bc-213">Sıfır veya daha fazla sözcük karakterini eşleştirin, ancak mümkün olduğunca az karakter.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-213">Match zero or more word characters, but as few characters as possible.</span></span>|  
|`\b`|<span data-ttu-id="5e1bc-214">Bir sözcük sınırında sona erdirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-214">End on a word boundary.</span></span>|  
  
### <a name="match-one-or-more-times-lazy-match-"></a><span data-ttu-id="5e1bc-215">Bir veya Daha Fazla Kez Maç (Lazy Match): +?</span><span class="sxs-lookup"><span data-stu-id="5e1bc-215">Match One or More Times (Lazy Match): +?</span></span>  
 <span data-ttu-id="5e1bc-216">`+?` Niceleyici, önceki öğeyle bir veya daha fazla kez, ancak mümkün olduğunca az kez eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-216">The `+?` quantifier matches the preceding element one or more times, but as few times as possible.</span></span> <span data-ttu-id="5e1bc-217">Bu açgözlü niceleyici tembel `+`meslektaşıdır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-217">It is the lazy counterpart of the greedy quantifier `+`.</span></span>  
  
 <span data-ttu-id="5e1bc-218">Örneğin, normal ifade, `\b\w+?\b` sözcük sınırlarına göre ayrılmış bir veya daha fazla karakterle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-218">For example, the regular expression `\b\w+?\b` matches one or more characters separated by word boundaries.</span></span> <span data-ttu-id="5e1bc-219">Aşağıdaki örnekte bu normal ifade gösteriş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-219">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#8](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#8)]
 [!code-vb[RegularExpressions.Quantifiers#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#8)]  
  
### <a name="match-zero-or-one-time-lazy-match-"></a><span data-ttu-id="5e1bc-220">Maç Sıfır veya Bir Kez (Tembel Maç): ??</span><span class="sxs-lookup"><span data-stu-id="5e1bc-220">Match Zero or One Time (Lazy Match): ??</span></span>  
 <span data-ttu-id="5e1bc-221">`??` Niceleyici, bir önceki öğe sıfır veya bir kez eşleşir, ancak mümkün olduğunca az kez.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-221">The `??` quantifier matches the preceding element zero or one time, but as few times as possible.</span></span> <span data-ttu-id="5e1bc-222">Bu açgözlü niceleyici tembel `?`meslektaşıdır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-222">It is the lazy counterpart of the greedy quantifier `?`.</span></span>  
  
 <span data-ttu-id="5e1bc-223">Örneğin, normal ifade `^\s*(System.)??Console.Write(Line)??\(??` "Console.Write" veya "Console.WriteLine" dizelerini eşleştirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-223">For example, the regular expression `^\s*(System.)??Console.Write(Line)??\(??` attempts to match the strings "Console.Write" or "Console.WriteLine".</span></span> <span data-ttu-id="5e1bc-224">Dize "Sistem" de içerebilir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-224">The string can also include "System."</span></span> <span data-ttu-id="5e1bc-225">önce "Konsol", ve bir açılış parantez tarafından takip edilebilir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-225">before "Console", and it can be followed by an opening parenthesis.</span></span> <span data-ttu-id="5e1bc-226">Dize bir çizginin başında olmalıdır, ancak beyaz boşluk tan önce gelebilir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-226">The string must be at the beginning of a line, although it can be preceded by white space.</span></span> <span data-ttu-id="5e1bc-227">Aşağıdaki örnekte bu normal ifade gösteriş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-227">The following example illustrates this regular expression.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#9](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#9)]
 [!code-vb[RegularExpressions.Quantifiers#9](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#9)]  
  
 <span data-ttu-id="5e1bc-228">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-228">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-229">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-229">Pattern</span></span>|<span data-ttu-id="5e1bc-230">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-230">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="5e1bc-231">Giriş akışının başlangıcını eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-231">Match the start of the input stream.</span></span>|  
|`\s*`|<span data-ttu-id="5e1bc-232">Sıfır veya daha fazla boşluk karakteriyle eşleş.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-232">Match zero or more white-space characters.</span></span>|  
|`(System.)??`|<span data-ttu-id="5e1bc-233">"Sistem" dizesinin sıfır veya bir oluşumunu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-233">Match zero or one occurrence of the string "System.".</span></span>|  
|`Console.Write`|<span data-ttu-id="5e1bc-234">"Console.Write" dizesini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-234">Match the string "Console.Write".</span></span>|  
|`(Line)??`|<span data-ttu-id="5e1bc-235">"Line" dizesinin sıfır veya bir oluşumunu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-235">Match zero or one occurrence of the string "Line".</span></span>|  
|`\(??`|<span data-ttu-id="5e1bc-236">Açılış parantezinin sıfır veya bir oluşumunu eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-236">Match zero or one occurrence of the opening parenthesis.</span></span>|  
  
### <a name="match-exactly-n-times-lazy-match-n"></a><span data-ttu-id="5e1bc-237">Tam olarak n Times (Lazy Match): {n}?</span><span class="sxs-lookup"><span data-stu-id="5e1bc-237">Match Exactly n Times (Lazy Match): {n}?</span></span>  
 <span data-ttu-id="5e1bc-238">`{` *n* n`}?` ölçüleyicisi, n'nin `n` herhangi bir tamsayı *olduğu* önceki öğeyle tam olarak kez eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-238">The `{`*n*`}?` quantifier matches the preceding element exactly `n` times, where *n* is any integer.</span></span> <span data-ttu-id="5e1bc-239">Bu açgözlü niceleyici `{` *n*`}`tembel meslektaşıdır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-239">It is the lazy counterpart of the greedy quantifier `{`*n*`}`.</span></span>  
  
 <span data-ttu-id="5e1bc-240">Aşağıdaki örnekte, normal `\b(\w{3,}?\.){2}?\w{3,}?\b` ifade bir Web sitesi adresini tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-240">In the following example, the regular expression `\b(\w{3,}?\.){2}?\w{3,}?\b` is used to identify a Web site address.</span></span> <span data-ttu-id="5e1bc-241">"www.microsoft.com" ve "msdn.microsoft.com" ile eşleştiğini, ancak "web sitem" veya "mycompany.com" ile eşleşmediğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-241">Note that it matches "www.microsoft.com" and "msdn.microsoft.com", but does not match "mywebsite" or "mycompany.com".</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#10](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#10)]
 [!code-vb[RegularExpressions.Quantifiers#10](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#10)]  
  
 <span data-ttu-id="5e1bc-242">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-242">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-243">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-243">Pattern</span></span>|<span data-ttu-id="5e1bc-244">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-244">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-245">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-245">Start at a word boundary.</span></span>|  
|`(\w{3,}?\.)`|<span data-ttu-id="5e1bc-246">Maç en az 3 kelime karakterleri, ancak mümkün olduğunca az karakter, bir nokta veya nokta karakteri takip.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-246">Match at least 3 word characters, but as few characters as possible, followed by a dot or period character.</span></span> <span data-ttu-id="5e1bc-247">Bu ilk yakalama grubudur.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-247">This is the first capturing group.</span></span>|  
|`(\w{3,}?\.){2}?`|<span data-ttu-id="5e1bc-248">İlk gruptaki deseni iki kez, ancak mümkün olduğunca az kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-248">Match the pattern in the first group two times, but as few times as possible.</span></span>|  
|`\b`|<span data-ttu-id="5e1bc-249">Eşleşmeyi sözcük sınırında sonla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-249">End the match on a word boundary.</span></span>|  
  
### <a name="match-at-least-n-times-lazy-match-n"></a><span data-ttu-id="5e1bc-250">Maç en az n Kez (Tembel Maç): {n,}?</span><span class="sxs-lookup"><span data-stu-id="5e1bc-250">Match at Least n Times (Lazy Match): {n,}?</span></span>  
 <span data-ttu-id="5e1bc-251">`{` *n* n`,}?` nicelleyici, *n'nin* herhangi `n` bir karşıcı olduğu, ancak mümkün olduğunca az kez önceki öğeyle en az eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-251">The `{`*n*`,}?` quantifier matches the preceding element at least `n` times, where *n* is any integer, but as few times as possible.</span></span> <span data-ttu-id="5e1bc-252">Bu açgözlü niceleyici `{` *n*`,}`tembel meslektaşıdır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-252">It is the lazy counterpart of the greedy quantifier `{`*n*`,}`.</span></span>  
  
 <span data-ttu-id="5e1bc-253">Bir resim için `{`önceki bölümdeki *n* `}?` niceleyici örneğine bakın.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-253">See the example for the `{`*n*`}?` quantifier in the previous section for an illustration.</span></span> <span data-ttu-id="5e1bc-254">Bu örnekteki normal ifade, bir dönemin ardından en az üç karaktere sahip bir dizeyle eşleştirmek için `{` *n* `,}` nicelini kullanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-254">The regular expression in that example uses the `{`*n*`,}` quantifier to match a string that has at least three characters followed by a period.</span></span>  
  
### <a name="match-between-n-and-m-times-lazy-match-nm"></a><span data-ttu-id="5e1bc-255">N ve m Times Arasındaki Eşleşme (Tembel Maç): {n,m}?</span><span class="sxs-lookup"><span data-stu-id="5e1bc-255">Match Between n and m Times (Lazy Match): {n,m}?</span></span>  
 <span data-ttu-id="5e1bc-256">`{` *n*`}?` `n` `m` *n* *m* *m* m niceleyici, n ve m'nin hemdemeger olduğu, ancak mümkün olduğunca az kez olduğu zaman ile arasındaki önceki öğeyle eşleşir.`,`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-256">The `{`*n*`,`*m*`}?` quantifier matches the preceding element between `n` and `m` times, where *n* and *m* are integers, but as few times as possible.</span></span> <span data-ttu-id="5e1bc-257">Bu açgözlü `{`niceleyici *n*`,`*m*`}`tembel meslektaşıdır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-257">It is the lazy counterpart of the greedy quantifier `{`*n*`,`*m*`}`.</span></span>  
  
 <span data-ttu-id="5e1bc-258">Aşağıdaki örnekte, normal `\b[A-Z](\w*?\s*?){1,10}[.!?]` ifade, bir ile on arasında sözcük içeren tümcelerle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-258">In the following example, the regular expression `\b[A-Z](\w*?\s*?){1,10}[.!?]` matches sentences that contain between one and ten words.</span></span> <span data-ttu-id="5e1bc-259">18 sözcük içeren bir tümce dışında giriş dizesindeki tüm tüm cümlelerle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-259">It matches all the sentences in the input string except for one sentence that contains 18 words.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers#12](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers/cs/Quantifiers1.cs#12)]
 [!code-vb[RegularExpressions.Quantifiers#12](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers/vb/Quantifiers1.vb#12)]  
  
 <span data-ttu-id="5e1bc-260">Normal ifade deseni aşağıdaki tabloda gösterildiği gibi tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-260">The regular expression pattern is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-261">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-261">Pattern</span></span>|<span data-ttu-id="5e1bc-262">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-262">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="5e1bc-263">Bir sözcük sınırında başla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-263">Start at a word boundary.</span></span>|  
|`[A-Z]`|<span data-ttu-id="5e1bc-264">A'dan Z'ye bir büyük harf karakteri eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-264">Match an uppercase character from A to Z.</span></span>|  
|`(\w*?\s*?)`|<span data-ttu-id="5e1bc-265">Sıfır veya daha fazla sözcük karakterini eşleştirin, ardından bir veya daha fazla boşluk karakteri, ancak mümkün olduğunca az kez.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-265">Match zero or more word characters, followed by one or more white-space characters, but as few times as possible.</span></span> <span data-ttu-id="5e1bc-266">Bu ilk yakalama grubu.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-266">This is the first capture group.</span></span>|  
|`{1,10}`|<span data-ttu-id="5e1bc-267">Önceki deseni 1 ile 10 kez eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-267">Match the previous pattern between 1 and 10 times.</span></span>|  
|`[.!?]`|<span data-ttu-id="5e1bc-268">Noktalama işaretlerinden herhangi birini ".", "!", veya "?".</span><span class="sxs-lookup"><span data-stu-id="5e1bc-268">Match any one of the punctuation characters ".", "!", or "?".</span></span>|  
  
<a name="Greedy"></a>
## <a name="greedy-and-lazy-quantifiers"></a><span data-ttu-id="5e1bc-269">Açgözlü ve Tembel Niceleyiciler</span><span class="sxs-lookup"><span data-stu-id="5e1bc-269">Greedy and Lazy Quantifiers</span></span>  
 <span data-ttu-id="5e1bc-270">Niceleyicilerin bir dizi iki sürümü vardır:</span><span class="sxs-lookup"><span data-stu-id="5e1bc-270">A number of the quantifiers have two versions:</span></span>  
  
- <span data-ttu-id="5e1bc-271">Açgözlü bir versiyonu.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-271">A greedy version.</span></span>  
  
     <span data-ttu-id="5e1bc-272">Açgözlü bir niceleyici mümkün olduğunca çok kez bir öğe eşleşmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-272">A greedy quantifier tries to match an element as many times as possible.</span></span>  
  
- <span data-ttu-id="5e1bc-273">Açgözlü olmayan (veya tembel) bir sürüm.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-273">A non-greedy (or lazy) version.</span></span>  
  
     <span data-ttu-id="5e1bc-274">Açgözlü olmayan bir nicel, bir öğeyi mümkün olduğunca az kez eşleştirmeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-274">A non-greedy quantifier tries to match an element as few times as possible.</span></span> <span data-ttu-id="5e1bc-275">Açgözlü bir niceleyiciyi sadece bir `?`.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-275">You can turn a greedy quantifier into a lazy quantifier by simply adding a `?`.</span></span>  
  
 <span data-ttu-id="5e1bc-276">Kredi kartı numarası gibi bir sayı dizesinden son dört rakamı ayıklamak için tasarlanmış basit bir normal ifade düşünün.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-276">Consider a simple regular expression that is intended to extract the last four digits from a string of numbers such as a credit card number.</span></span> <span data-ttu-id="5e1bc-277">`*` Açgözlü niceleyici kullanan normal ifade sürümü . `\b.*([0-9]{4})\b`</span><span class="sxs-lookup"><span data-stu-id="5e1bc-277">The version of the regular expression that uses the `*` greedy quantifier is `\b.*([0-9]{4})\b`.</span></span> <span data-ttu-id="5e1bc-278">Ancak, bir dize iki sayı içeriyorsa, bu normal ifade aşağıdaki örnekte görüldüğü gibi yalnızca ikinci sayının son dört basamağıyla eşleşir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-278">However, if a string contains two numbers, this regular expression matches the last four digits of the second number only, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#1)]  
  
 <span data-ttu-id="5e1bc-279">`*` Niceleyici önceki öğeyi tüm dizede mümkün olduğunca çok kez eşleştirmeye çalıştığından ve böylece dize sonunda eşleşmesini bulduğundan, normal ifade ilk sayıyla eşleşmez.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-279">The regular expression fails to match the first number because the `*` quantifier tries to match the previous element as many times as possible in the entire string, and so it finds its match at the end of the string.</span></span>  
  
 <span data-ttu-id="5e1bc-280">Bu istenilen davranış değildir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-280">This is not the desired behavior.</span></span> <span data-ttu-id="5e1bc-281">Bunun yerine, aşağıdaki `*?`örnekte görüldüğü gibi, her iki sayıdan da basamak ayıklamak için tembel niceleyiciyi kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-281">Instead, you can use the `*?`lazy quantifier to extract digits from both numbers, as the following example shows.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/csharp/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/cs/Greedy.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.Greedy#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/RegularExpressions.Quantifiers.Greedy/vb/Greedy.vb#2)]  
  
 <span data-ttu-id="5e1bc-282">Çoğu durumda, açgözlü ve tembel niceleyiciler ile düzenli ifadeler aynı eşleşmeleri döndürün.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-282">In most cases, regular expressions with greedy and lazy quantifiers return the same matches.</span></span> <span data-ttu-id="5e1bc-283">Onlar en sık herhangi bir karakter eşleşen joker`.`( ) metakarakter ile kullanıldığında farklı sonuçlar verir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-283">They most commonly return different results when they are used with the wildcard (`.`) metacharacter, which matches any character.</span></span>  
  
## <a name="quantifiers-and-empty-matches"></a><span data-ttu-id="5e1bc-284">Niceleyiciler ve Boş Eşleşmeler</span><span class="sxs-lookup"><span data-stu-id="5e1bc-284">Quantifiers and Empty Matches</span></span>  
 <span data-ttu-id="5e1bc-285">Ölçüleyiciler `*` `+`, ve `{` *n*`,`*m* `}` ve onların tembel meslektaşları yakalamalar minimum sayıda bulunduğunda boş bir maç sonra tekrarlamak asla.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-285">The quantifiers `*`, `+`, and `{`*n*`,`*m*`}` and their lazy counterparts never repeat after an empty match when the minimum number of captures has been found.</span></span> <span data-ttu-id="5e1bc-286">Bu kural, olası grup yakalama sayısı sonsuz veya sonsuza yakın olduğunda, niceleyicilerin boş alt ifade eşleşmelerine sonsuz döngüler girmesini önler.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-286">This rule prevents quantifiers from entering infinite loops on empty subexpression matches when the maximum number of possible group captures is infinite or near infinite.</span></span>  
  
 <span data-ttu-id="5e1bc-287">Örneğin, aşağıdaki kod, sıfır veya bir <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> "a" karakteri `(a?)*`sıfır veya daha fazla kez eşleşen normal ifade deseni ile yönteme yapılan çağrının sonucunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-287">For example, the following code shows the result of a call to the <xref:System.Text.RegularExpressions.Regex.Match%2A?displayProperty=nameWithType> method with the regular expression pattern `(a?)*`, which matches zero or one "a" character zero or more times.</span></span> <span data-ttu-id="5e1bc-288">Tek yakalama grubunun her "a"yı ve <xref:System.String.Empty?displayProperty=nameWithType>ikinci boş eşleşmeyi yakaladığını, çünkü ilk boş eşleşmenin niceleyicinin yinelemeyi durdurmasına neden olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-288">Note that the single capturing group captures each "a" as well as <xref:System.String.Empty?displayProperty=nameWithType>, but that there is no second empty match, because the first empty match causes the quantifier to stop repeating.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch1.cs#1)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch1.vb#1)]  
  
 <span data-ttu-id="5e1bc-289">En az ve maksimum sayıda yakalama yı tanımlayan bir yakalama grubu ile sabit sayıda yakalama tanımlayan grup arasındaki pratik farkı `(a\1|(?(1)\1)){0,2}` `(a\1|(?(1)\1)){2}`görmek için, normal ifade modellerini düşünün ve .</span><span class="sxs-lookup"><span data-stu-id="5e1bc-289">To see the practical difference between a capturing group that defines a minimum and a maximum number of captures and one that defines a fixed number of captures, consider the regular expression patterns `(a\1|(?(1)\1)){0,2}` and `(a\1|(?(1)\1)){2}`.</span></span> <span data-ttu-id="5e1bc-290">Her iki normal ifade de aşağıdaki tabloda gösterildiği gibi tanımlanan tek bir yakalama grubundan oluşur.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-290">Both regular expressions consist of a single capturing group, which is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="5e1bc-291">Desen</span><span class="sxs-lookup"><span data-stu-id="5e1bc-291">Pattern</span></span>|<span data-ttu-id="5e1bc-292">Açıklama</span><span class="sxs-lookup"><span data-stu-id="5e1bc-292">Description</span></span>|  
|-------------|-----------------|  
|`(a\1`|<span data-ttu-id="5e1bc-293">Ya maç "a" ilk yakalanan grubun değeri ile birlikte ...</span><span class="sxs-lookup"><span data-stu-id="5e1bc-293">Either match "a" along with the value of the first captured group …</span></span>|  
|<code>&#124;(?(1)</code>|<span data-ttu-id="5e1bc-294">…</span><span class="sxs-lookup"><span data-stu-id="5e1bc-294">…</span></span> <span data-ttu-id="5e1bc-295">veya yakalanan ilk grubun tanımlanıp tanımlanmadığını test edin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-295">or test whether the first captured group has been defined.</span></span> <span data-ttu-id="5e1bc-296">(Yapının `(?(1)` bir yakalama grubu tanımlamadığını unutmayın.)</span><span class="sxs-lookup"><span data-stu-id="5e1bc-296">(Note that the `(?(1)` construct does not define a capturing group.)</span></span>|  
|`\1))`|<span data-ttu-id="5e1bc-297">Yakalanan ilk grup varsa, değerini eşleştirin.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-297">If the first captured group exists, match its value.</span></span> <span data-ttu-id="5e1bc-298">Grup yoksa, grup eşleşir. <xref:System.String.Empty?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="5e1bc-298">If the group does not exist, the group will match <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="5e1bc-299">İlk normal ifade bu deseni sıfır ile iki kez eşleştirmeye çalışır; ikincisi, tam olarak iki kez.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-299">The first regular expression tries to match this pattern between zero and two times; the second, exactly two times.</span></span> <span data-ttu-id="5e1bc-300">İlk desen ilk yakalama ile yakalama en az <xref:System.String.Empty?displayProperty=nameWithType>sayıda ulaştığından, o maç `a\1`denemek için tekrarasla ; `{0,2}` niceleyici son yinelemede yalnızca boş eşleşmeler sağlar.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-300">Because the first pattern reaches its minimum number of captures with its first capture of <xref:System.String.Empty?displayProperty=nameWithType>, it never repeats to try to match `a\1`; the `{0,2}` quantifier allows only empty matches in the last iteration.</span></span> <span data-ttu-id="5e1bc-301">Buna karşılık, ikinci kez değerlendirir `a\1` çünkü ikinci normal ifade "a" eşleşir; en az yineleme sayısı, 2, motoru boş bir eşleşmeden sonra yinelemeye zorlar.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-301">In contrast, the second regular expression does match "a" because it evaluates `a\1` a second time; the minimum number of iterations, 2, forces the engine to repeat after an empty match.</span></span>  
  
 [!code-csharp[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/csharp/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/cs/emptymatch4.cs#2)]
 [!code-vb[RegularExpressions.Quantifiers.EmptyMatch#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/regularexpressions.quantifiers.emptymatch/vb/emptymatch4.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="5e1bc-302">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="5e1bc-302">See also</span></span>

- [<span data-ttu-id="5e1bc-303">Normal İfade Dili - Hızlı Başvuru</span><span class="sxs-lookup"><span data-stu-id="5e1bc-303">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="5e1bc-304">Geri Dönüş</span><span class="sxs-lookup"><span data-stu-id="5e1bc-304">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)
