---
title: Kısmi hata işleme stratejileri
description: Kısmi hataları incelikle işlemek için çeşitli stratejiler tanıyın.
ms.date: 10/16/2018
ms.openlocfilehash: abf87df5afed02b4d794a1307a0ed943cafb4db3
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988810"
---
# <a name="strategies-to-handle-partial-failure"></a><span data-ttu-id="2be78-103">Kısmi başarısızlığı işlemek için stratejiler</span><span class="sxs-lookup"><span data-stu-id="2be78-103">Strategies to handle partial failure</span></span>

<span data-ttu-id="2be78-104">Kısmi hatalarla başa çıkmak için stratejiler şunlardır.</span><span class="sxs-lookup"><span data-stu-id="2be78-104">Strategies for dealing with partial failures include the following.</span></span>

<span data-ttu-id="2be78-105">**Dahili mikro hizmetler arasında eşzamanlı iletişim (örneğin, ileti tabanlı iletişim) kullanın.**</span><span class="sxs-lookup"><span data-stu-id="2be78-105">**Use asynchronous communication (for example, message-based communication) across internal microservices**.</span></span> <span data-ttu-id="2be78-106">Bu yanlış tasarım sonunda kötü kesintilerin ana nedeni haline gelecektir, çünkü iç mikrohizmetler arasında senkron HTTP aramaları uzun zincirleri oluşturmak için son derece tavsiye edilir.</span><span class="sxs-lookup"><span data-stu-id="2be78-106">It's highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages.</span></span> <span data-ttu-id="2be78-107">Tam tersine, istemci uygulamaları ile ilk mikro hizmetler düzeyi veya ince taneli API Ağ geçitleri arasındaki ön uç iletişimi dışında, ilk istek/yanıt döngüsünü geçtikten sonra, dahili mikro hizmetler arasında yalnızca eşzamanlı (ileti tabanlı) iletişim kullanılması önerilir.</span><span class="sxs-lookup"><span data-stu-id="2be78-107">On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it's recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices.</span></span> <span data-ttu-id="2be78-108">Nihai tutarlılık ve olay odaklı mimariler dalgalanma etkilerini en aza indirmek için yardımcı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="2be78-108">Eventual consistency and event-driven architectures will help to minimize ripple effects.</span></span> <span data-ttu-id="2be78-109">Bu yaklaşımlar daha yüksek düzeyde mikro hizmet özerkliği uygular ve bu nedenle burada belirtilen soruna karşı önlemek.</span><span class="sxs-lookup"><span data-stu-id="2be78-109">These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</span></span>

<span data-ttu-id="2be78-110">**Üstel geri dönüşlü yeniden denemeleri kullanın.**</span><span class="sxs-lookup"><span data-stu-id="2be78-110">**Use retries with exponential backoff**.</span></span> <span data-ttu-id="2be78-111">Bu teknik, hizmetin yalnızca kısa bir süre için kullanılamaması durumunda, çağrı yeniden denemelerini belirli sayıda gerçekleştirerek kısa ve aralıklı hataları önlemeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="2be78-111">This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time.</span></span> <span data-ttu-id="2be78-112">Bu, aralıklı ağ sorunları nedeniyle veya bir microservice/kapsayıcı kümede farklı bir düğüme taşındığında oluşabilir.</span><span class="sxs-lookup"><span data-stu-id="2be78-112">This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster.</span></span> <span data-ttu-id="2be78-113">Ancak, bu yeniden denemeler devre kesicilerle düzgün bir şekilde tasarlanmazsa, dalgalanma etkilerini ağırlaştırabilir ve sonuçta [Hizmet Reddi 'ne (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack)bile neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="2be78-113">However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a [Denial of Service (DoS)](https://en.wikipedia.org/wiki/Denial-of-service_attack).</span></span>

<span data-ttu-id="2be78-114">**Ağ zaman zaman larını geçici olarak çalıştırın.**</span><span class="sxs-lookup"><span data-stu-id="2be78-114">**Work around network timeouts**.</span></span> <span data-ttu-id="2be78-115">Genel olarak, istemciler süresiz olarak engellemek ve bir yanıt beklerken her zaman zaman zaman ekinleri kullanmak için tasarlanmış olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2be78-115">In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response.</span></span> <span data-ttu-id="2be78-116">Zaman zaman zaman larını kullanmak, kaynakların asla sonsuza kadar bağlanmamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="2be78-116">Using timeouts ensures that resources are never tied up indefinitely.</span></span>

<span data-ttu-id="2be78-117">**Devre Kesici deseni kullanın.**</span><span class="sxs-lookup"><span data-stu-id="2be78-117">**Use the Circuit Breaker pattern**.</span></span> <span data-ttu-id="2be78-118">Bu yaklaşımda, istemci işlemi başarısız isteklerin sayısını izler.</span><span class="sxs-lookup"><span data-stu-id="2be78-118">In this approach, the client process tracks the number of failed requests.</span></span> <span data-ttu-id="2be78-119">Hata oranı yapılandırılmış bir sınırı aşarsa, bir "devre kesici" sürükler, böylece daha fazla girişim hemen başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="2be78-119">If the error rate exceeds a configured limit, a "circuit breaker" trips so that further attempts fail immediately.</span></span> <span data-ttu-id="2be78-120">(Çok sayıda istek başarısız oluyorsa, bu hizmetin kullanılmadığını ve istek göndermenin anlamsız olduğunu gösterir.) Bir zaman adabı döneminden sonra istemci yeniden denemeli ve yeni istekler başarılı olursa devre kesiciyi kapatmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2be78-120">(If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</span></span>

<span data-ttu-id="2be78-121">**Geri dönüşler sağlayın.**</span><span class="sxs-lookup"><span data-stu-id="2be78-121">**Provide fallbacks**.</span></span> <span data-ttu-id="2be78-122">Bu yaklaşımda, önbelleğe alınan verileri veya varsayılan değeri döndürme gibi bir istek başarısız olduğunda istemci işlemi geri dönüş mantığı gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="2be78-122">In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value.</span></span> <span data-ttu-id="2be78-123">Bu, sorgular için uygun bir yaklaşımdır ve güncelleştirmeler veya komutlar için daha karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="2be78-123">This is an approach suitable for queries, and is more complex for updates or commands.</span></span>

<span data-ttu-id="2be78-124">**Sıralanmış istek sayısını sınırlayın.**</span><span class="sxs-lookup"><span data-stu-id="2be78-124">**Limit the number of queued requests**.</span></span> <span data-ttu-id="2be78-125">İstemci, istemci mikro hizmetinin belirli bir hizmete gönderebileceği bekleyen istek sayısına da üst sınır koymalı.</span><span class="sxs-lookup"><span data-stu-id="2be78-125">Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service.</span></span> <span data-ttu-id="2be78-126">Sınıra ulaşıldıysa, ek isteklerde bulunmak büyük olasılıkla anlamsızdır ve bu denemeler inhemen başarısız olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="2be78-126">If the limit has been reached, it's probably pointless to make additional requests, and those attempts should fail immediately.</span></span> <span data-ttu-id="2be78-127">Uygulama açısından, Polly [Bulkhead İzolasyon](https://github.com/App-vNext/Polly/wiki/Bulkhead) ilkesi bu gereksinimi karşılamak için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="2be78-127">In terms of implementation, the Polly [Bulkhead Isolation](https://github.com/App-vNext/Polly/wiki/Bulkhead) policy can be used to fulfill this requirement.</span></span> <span data-ttu-id="2be78-128">Bu yaklaşım aslında uygulama olarak paralelleştirme <xref:System.Threading.SemaphoreSlim> azaltmadır.</span><span class="sxs-lookup"><span data-stu-id="2be78-128">This approach is essentially a parallelization throttle with <xref:System.Threading.SemaphoreSlim> as the implementation.</span></span> <span data-ttu-id="2be78-129">Ayrıca bölme dışında bir "kuyruk" izin verir.</span><span class="sxs-lookup"><span data-stu-id="2be78-129">It also permits a "queue" outside the bulkhead.</span></span> <span data-ttu-id="2be78-130">Yürütmeden önce bile proaktif olarak fazla yük dökebilirsiniz (örneğin, kapasite tam olarak kabul edildiği için).</span><span class="sxs-lookup"><span data-stu-id="2be78-130">You can proactively shed excess load even before execution (for example, because capacity is deemed full).</span></span> <span data-ttu-id="2be78-131">Bu, devre kesici hataları beklediğinden, belirli hata senaryolarına yanıtını bir devre kesicinin olabileceğinden daha hızlı yapar.</span><span class="sxs-lookup"><span data-stu-id="2be78-131">This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures.</span></span> <span data-ttu-id="2be78-132">[Polly'deki](http://www.thepollyproject.org/) BulkheadPolicy nesnesi, bölme ve sıranın ne kadar dolu olduğunu ortaya çıkarır ve otomatik yatay ölçekleme sağlamak için kullanılabilen taşma olayları sunar.</span><span class="sxs-lookup"><span data-stu-id="2be78-132">The BulkheadPolicy object in [Polly](http://www.thepollyproject.org/) exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="2be78-133">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="2be78-133">Additional resources</span></span>

- <span data-ttu-id="2be78-134">**Esneklik desenleri**</span><span class="sxs-lookup"><span data-stu-id="2be78-134">**Resiliency patterns**</span></span>\
  [https://docs.microsoft.com/azure/architecture/patterns/category/resiliency](/azure/architecture/patterns/category/resiliency)

- <span data-ttu-id="2be78-135">**Esneklik Ekleme ve Performansı Optimize Etme**</span><span class="sxs-lookup"><span data-stu-id="2be78-135">**Adding Resilience and Optimizing Performance**</span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591574(v=pandp.10)>

- <span data-ttu-id="2be78-136">**Bölme.**</span><span class="sxs-lookup"><span data-stu-id="2be78-136">**Bulkhead.**</span></span> <span data-ttu-id="2be78-137">GitHub deposu.</span><span class="sxs-lookup"><span data-stu-id="2be78-137">GitHub repo.</span></span> <span data-ttu-id="2be78-138">Polly politikası ile uygulama.</span><span class="sxs-lookup"><span data-stu-id="2be78-138">Implementation with Polly policy.</span></span>\
  <https://github.com/App-vNext/Polly/wiki/Bulkhead>

- <span data-ttu-id="2be78-139">**Azure için esnek uygulamalar tasarlama**</span><span class="sxs-lookup"><span data-stu-id="2be78-139">**Designing resilient applications for Azure**</span></span>\
  [https://docs.microsoft.com/azure/architecture/resiliency/](/azure/architecture/resiliency/)

- <span data-ttu-id="2be78-140">**Geçici hata işleme**</span><span class="sxs-lookup"><span data-stu-id="2be78-140">**Transient fault handling**</span></span>\
  [https://docs.microsoft.com/azure/architecture/best-practices/transient-faults](/azure/architecture/best-practices/transient-faults)

>[!div class="step-by-step"]
><span data-ttu-id="2be78-141">[Önceki](handle-partial-failure.md)
>[Sonraki](implement-retries-exponential-backoff.md)</span><span class="sxs-lookup"><span data-stu-id="2be78-141">[Previous](handle-partial-failure.md)
[Next](implement-retries-exponential-backoff.md)</span></span>
