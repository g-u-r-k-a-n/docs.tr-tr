---
title: Güvenilirlik En İyi Yöntemleri
description: SQL Server gibi .NET ana bilgisayar tabanlı sunucu uygulamalarında güvenilirlik için en iyi uygulamalar bölümüne bakın. Kaynakların sızmasını veya alınmasını önleyin.
ms.date: 03/30/2017
helpviewer_keywords:
- marking locks
- rebooting databases
- denial of service attacks
- back-out code
- SQL Server [.NET Framework], reliability
- synchronization, reliability
- single-threaded COM components
- slow leaks
- suspending threads
- asynchronous exception handling
- leaked resources [.NET Framework]
- unmanaged memory
- memory, reliability
- threading [.NET Framework], reliability
- process-wide domain shared states
- shared states
- SafeHandle class, reliability
- reliability contracts [.NET Framework]
- cleanup operations
- constrained execution regions
- CERs
- finalizers, reliability
- reliability [.NET Framework]
- blocks, reliability
- finally clauses
- cross-application domain shared states
- catch blocks
- identifying locks
- writing reliable code
- impersonation
- GC.KeepAlive method
- managed threading
- locks, reliability
- STA-dependent features
- fibers
ms.assetid: cf624c1f-c160-46a1-bb2b-213587688da7
ms.openlocfilehash: 134b71153f95dffd4525f307d291ce4389e0ce60
ms.sourcegitcommit: cf5a800a33de64d0aad6d115ffcc935f32375164
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 07/20/2020
ms.locfileid: "86474247"
---
# <a name="reliability-best-practices"></a><span data-ttu-id="607f6-104">Güvenilirlik En İyi Yöntemleri</span><span class="sxs-lookup"><span data-stu-id="607f6-104">Reliability Best Practices</span></span>

<span data-ttu-id="607f6-105">Aşağıdaki güvenilirlik kuralları SQL Server için yönelimlidir; Ancak, bunlar ana bilgisayar tabanlı sunucu uygulamaları için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-105">The following reliability rules are oriented to SQL Server; however, they also apply to any host-based server application.</span></span> <span data-ttu-id="607f6-106">SQL Server gibi sunucularda kaynakları sızıntı ve bunların yapılmaması çok önemlidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-106">It is extremely important that servers such as SQL Server not leak resources and not be brought down.</span></span>  <span data-ttu-id="607f6-107">Ancak, bir nesnenin durumunu değiştiren her yöntem için geri dönüş kodu yazılarak gerçekleştirilemez.</span><span class="sxs-lookup"><span data-stu-id="607f6-107">However, that cannot be done by writing back-out code for every method that alters an object’s state.</span></span>  <span data-ttu-id="607f6-108">Amaç, her konumdaki herhangi bir hatalardan geri dönüş kodu ile kurtarılacak, yüzde 100 güvenilir yönetilen kod yazmak değildir.</span><span class="sxs-lookup"><span data-stu-id="607f6-108">The goal is not to write 100 percent reliable managed code that will recover from any errors in every location with back-out code.</span></span>  <span data-ttu-id="607f6-109">Bu, kısa bir süre sonra çok düşük bir görev olacaktır.</span><span class="sxs-lookup"><span data-stu-id="607f6-109">That would be a daunting task with little chance of success.</span></span>  <span data-ttu-id="607f6-110">Ortak dil çalışma zamanı (CLR), mükemmel kod yazmayı olanaklı hale getirmek için, yönetilen koda kolayca güçlü bir garanti sağlayamaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-110">The common language runtime (CLR) cannot easily provide strong enough guarantees to managed code to make writing perfect code feasible.</span></span>  <span data-ttu-id="607f6-111">ASP.NET aksine SQL Server, bir veritabanını kabul edilemez bir süre için bir veritabanı kapatılmadan geri dönüştürülmeden yalnızca bir işlem kullandığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-111">Note that unlike ASP.NET, SQL Server uses only one process that cannot be recycled without taking a database down for an unacceptably long time.</span></span>

<span data-ttu-id="607f6-112">Bu daha zayıf garanti ve tek bir işlemde çalışırken, güvenilirlik, gerekli olduğunda iş parçacıklarını sonlandırarak veya uygulama etki alanlarını geri dönüşüme göre yapılır ve işlemler ya da bellek gibi işletim sistemi kaynaklarının sızmasını sağlamak için önlemler alır.</span><span class="sxs-lookup"><span data-stu-id="607f6-112">With these weaker guarantees and running in a single process, reliability is based on terminating threads or recycling application domains when necessary and taking precautions to ensure operating system resources such as handles or memory are not leaked.</span></span>  <span data-ttu-id="607f6-113">Bu daha basit bir güvenilirlik kısıtlaması olsa da, önemli bir güvenilirlik gereksinimi de vardır:</span><span class="sxs-lookup"><span data-stu-id="607f6-113">Even with this simpler reliability constraint, there is still a significant reliability requirement:</span></span>

- <span data-ttu-id="607f6-114">İşletim sistemi kaynaklarını hiçbir şekilde sızıntı.</span><span class="sxs-lookup"><span data-stu-id="607f6-114">Never leak operating system resources.</span></span>

- <span data-ttu-id="607f6-115">Tüm formlardaki tüm yönetilen kilitleri CLR 'ye belirler.</span><span class="sxs-lookup"><span data-stu-id="607f6-115">Identify all managed locks in all forms to the CLR.</span></span>

- <span data-ttu-id="607f6-116">Çapraz uygulama etki alanı paylaşılan durumunu hiçbir şekilde kesmeyin ve <xref:System.AppDomain> geri dönüşüme sorunsuz bir şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="607f6-116">Never break cross-application domain shared state, allowing <xref:System.AppDomain> recycling to function smoothly.</span></span>

<span data-ttu-id="607f6-117">Teorik olarak, yönetilen kodu işlemek, ve özel durumları işlemek üzere yazmak, ancak <xref:System.Threading.ThreadAbortException> <xref:System.StackOverflowException> <xref:System.OutOfMemoryException> geliştiricilerin tüm uygulama genelinde bu tür güçlü kodlar yazması beklenmez.</span><span class="sxs-lookup"><span data-stu-id="607f6-117">Although it is theoretically possible to write managed code to handle <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException> exceptions, expecting developers to write such robust code throughout an entire application is unreasonable.</span></span>  <span data-ttu-id="607f6-118">Bu nedenle, bant dışı özel durumlar, yürütülmekte olan iş parçacığının sonlandırılmasının sonucu olarak sonuçlanır; ve sonlandırılan iş parçacığı paylaşılan durumu düzenleiyorsa, iş parçacığının bir kilit içerip içermediğini tespit ederek, <xref:System.AppDomain> kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="607f6-118">For that reason, out-of-band exceptions result in the executing thread being terminated; and if the terminated thread was editing shared state, which can be determined by whether the thread holds a lock, then the <xref:System.AppDomain> is unloaded.</span></span>  <span data-ttu-id="607f6-119">Paylaşılan durumu düzenleyen bir yöntem sonlandırıldığında, paylaşılan duruma güncelleştirmeler için güvenilir bir geri alma kodu yazılması mümkün olmadığından durum bozuk olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-119">When a method that is editing shared state is terminated, the state will be corrupt because it is not possible to write reliable back-out code for updates to shared state.</span></span>

<span data-ttu-id="607f6-120">.NET Framework sürüm 2,0 ' de, güvenilirlik gerektiren tek konak SQL Server.</span><span class="sxs-lookup"><span data-stu-id="607f6-120">In the .NET Framework version 2.0, the only host that requires reliability is SQL Server.</span></span>  <span data-ttu-id="607f6-121">Derlemeniz üzerinde çalışacağınızı SQL Server, veritabanında çalışırken devre dışı bırakılan belirli özellikler olsa bile, bu derlemenin her bölümü için güvenilirlik işini yapmalısınız.</span><span class="sxs-lookup"><span data-stu-id="607f6-121">If your assembly will be run on SQL Server you should do the reliability work for every part of that assembly, even if there are specific features that are disabled when running in the database.</span></span>  <span data-ttu-id="607f6-122">Kod Analizi altyapısı kodu derleme düzeyinde incelediği ve devre dışı bırakılan kodu ayırt edemediği için bu gereklidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-122">This is required because the code analysis engine examines code at the assembly level and cannot differentiate disabled code.</span></span> <span data-ttu-id="607f6-123">Başka bir SQL Server programlama, SQL Server her şeyi tek bir işlemde çalıştırmasının yanı sıra <xref:System.AppDomain> bellek ve işletim sistemi tanıtıcıları gibi tüm kaynakları temizlemek için de geri dönüşüm kullanılır.</span><span class="sxs-lookup"><span data-stu-id="607f6-123">Another SQL Server programming consideration is that SQL Server runs everything in one process, and <xref:System.AppDomain> recycling is used for cleaning up all resources such as memory and operating system handles.</span></span>

<span data-ttu-id="607f6-124">Sonlandırıcılara veya `try/finally` kod yıkıcılarına veya geri alma kodu bloklarına bağlı olamaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-124">You cannot depend on finalizers or destructors or `try/finally` blocks for back-out code.</span></span> <span data-ttu-id="607f6-125">Bunlar kesintiye uğramış veya çağrılmayabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-125">They might be interrupted or not called.</span></span>

<span data-ttu-id="607f6-126">Zaman uyumsuz özel durumlar beklenmeyen konumlarda, muhtemelen her makine yönergesi: <xref:System.Threading.ThreadAbortException> , ve olur <xref:System.StackOverflowException> <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="607f6-126">Asynchronous exceptions can be thrown in unexpected locations, possibly every machine instruction: <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, and <xref:System.OutOfMemoryException>.</span></span>

<span data-ttu-id="607f6-127">Yönetilen iş parçacıklarının SQL 'de Win32 iş parçacığı olmaması gerekmez; Bunlar fibers olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-127">Managed threads are not necessarily Win32 threads in SQL; they might be fibers.</span></span>

<span data-ttu-id="607f6-128">İşlem genelinde veya çapraz uygulama etki alanı kesilebilir paylaşılan durum güvenli bir şekilde değiştirilebilir ve mümkün olduğunda kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-128">Process-wide or cross-application domain mutable shared state is extremely difficult to alter safely and should be avoided whenever possible.</span></span>

<span data-ttu-id="607f6-129">Yetersiz bellek koşulları SQL Server nadir değildir.</span><span class="sxs-lookup"><span data-stu-id="607f6-129">Out-of-memory conditions are not rare in SQL Server.</span></span>

<span data-ttu-id="607f6-130">SQL Server ' de barındırılan kitaplıklar paylaşılan durumlarını doğru güncelleştirmediğinden, veritabanı yeniden başlatılana kadar kodun kurtarılmaması büyük bir olasılık olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-130">If libraries hosted in SQL Server do not correctly update their shared state, there is a high probability that the code will not recover until the database has been restarted.</span></span>  <span data-ttu-id="607f6-131">Ayrıca, bazı çok büyük durumlarda bu durum SQL Server işleminin başarısız olmasına neden olabilir ve veritabanının yeniden başlatılmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-131">Additionally, in some extreme cases, it is possible this might cause the SQL Server process to fail, causing the database to reboot.</span></span>  <span data-ttu-id="607f6-132">Veritabanının yeniden başlatılması bir Web sitesi alabilir veya şirket işlemlerini, kullanım dışı bir şekilde etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-132">Rebooting the database can take down a Web site or affect company operations, hurting availability.</span></span>  <span data-ttu-id="607f6-133">Bellek veya tanıtıcı gibi işletim sistemi kaynaklarının yavaş sızıntısı, sunucunun, bir kurtarma işlemi olmadan bir veya daha fazla performans düşmesine neden olabilir ve bir müşterinin uygulama kullanılabilirliğini düşürür.</span><span class="sxs-lookup"><span data-stu-id="607f6-133">A slow leak of operating system resources such as memory or handles may cause the server to eventually fail allocating handles with no possibility of recovery, or potentially the server may slowly degrade in performance and reduces a customer’s application availability.</span></span>  <span data-ttu-id="607f6-134">Bu senaryolarınızı açıkça önlemek istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="607f6-134">Clearly we want to avoid these scenarios.</span></span>

## <a name="best-practice-rules"></a><span data-ttu-id="607f6-135">En iyi yöntem kuralları</span><span class="sxs-lookup"><span data-stu-id="607f6-135">Best practice rules</span></span>

<span data-ttu-id="607f6-136">Sunucuda çalışan yönetilen koda yönelik kod incelemesinin, Framework 'ün kararlılığını ve güvenilirliğini artırmak için yakalayabilecekleri tanıtım.</span><span class="sxs-lookup"><span data-stu-id="607f6-136">The introduction focused on what the code review for the managed code that runs in the server would have to catch to increase the stability and reliability of the framework.</span></span> <span data-ttu-id="607f6-137">Tüm bu denetimler, genel olarak iyi bir uygulamadır ve sunucuda bir mutlak olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-137">All these checks are good practice in general and an absolute must on the server.</span></span>

<span data-ttu-id="607f6-138">Kullanılmayan bir kilit veya kaynak kısıtlaması durumunda SQL Server bir iş parçacığını durdurur veya bir alt kümesini yok eder <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-138">In the face of a dead lock or resource constraint, SQL Server will abort a thread or tear down an <xref:System.AppDomain>.</span></span>  <span data-ttu-id="607f6-139">Bu durumda, yalnızca kısıtlı yürütme bölgesindeki (CER) bir yedek kodun çalıştırılması garanti edilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-139">When this happens, only back-out code in a constrained execution region (CER) is guaranteed to be run.</span></span>

### <a name="use-safehandle-to-avoid-resource-leaks"></a><span data-ttu-id="607f6-140">Kaynak sızıntılarını önlemek için SafeHandle kullanın</span><span class="sxs-lookup"><span data-stu-id="607f6-140">Use SafeHandle to avoid resource leaks</span></span>

<span data-ttu-id="607f6-141">Bir kaldırma durumunda, <xref:System.AppDomain> `finally` yürütülen bloklara veya sonlandırıcılara bağlı olamaz, bu nedenle tüm işletim sistemi kaynak erişiminin <xref:System.Runtime.InteropServices.SafeHandle> <xref:System.IntPtr> , veya benzer sınıflar yerine sınıf aracılığıyla soyut olması önemlidir <xref:System.Runtime.InteropServices.HandleRef> .</span><span class="sxs-lookup"><span data-stu-id="607f6-141">In the case of an <xref:System.AppDomain> unload, you cannot depend on `finally` blocks or finalizers being executed, so it is important to abstract all operating system resource access through the <xref:System.Runtime.InteropServices.SafeHandle> class rather than <xref:System.IntPtr>, <xref:System.Runtime.InteropServices.HandleRef>, or similar classes.</span></span> <span data-ttu-id="607f6-142">Bu, CLR 'nin, koparma durumunda bile kullandığınız tutamaçları izlemesine ve kapatılmasına izin verir <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-142">This allows the CLR to track and close the handles you use even in the <xref:System.AppDomain> tear-down case.</span></span>  <span data-ttu-id="607f6-143"><xref:System.Runtime.InteropServices.SafeHandle>, CLR 'nin her zaman çalışacağı kritik bir Sonlandırıcı kullanacaktır.</span><span class="sxs-lookup"><span data-stu-id="607f6-143"><xref:System.Runtime.InteropServices.SafeHandle> will be using a critical finalizer which the CLR will always run.</span></span>

<span data-ttu-id="607f6-144">İşletim sistemi tanıtıcısı, serbest bırakılana kadar, oluşturulduğu andan itibaren güvenli tanıtıcıda depolanır.</span><span class="sxs-lookup"><span data-stu-id="607f6-144">The operating system handle is stored in the safe handle from the moment it is created until the moment it is released.</span></span>  <span data-ttu-id="607f6-145">Bir <xref:System.Threading.ThreadAbortException> tutamacı sızmak için bir pencere meydana gelebilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-145">There is no window during which a <xref:System.Threading.ThreadAbortException> can occur to leak a handle.</span></span>  <span data-ttu-id="607f6-146">Buna ek olarak, platform Invoke, tanıtıcının yaşam süresini izlemeye izin veren tanıtıcıyı sayacaktır. Bu, tanıtıcının yaşam süresinin kapatılmasını sağlar `Dispose`</span><span class="sxs-lookup"><span data-stu-id="607f6-146">Additionally, platform invoke will reference-count the handle, which allows close tracking of the lifetime of the handle, preventing a security issue with a race condition between `Dispose` and a method that is currently using the handle.</span></span>

<span data-ttu-id="607f6-147">Yalnızca bir işletim sistemi işleyicisini temizlemek için bir sonlandırıcısı olan çoğu sınıf artık sonlandırıcıyı gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="607f6-147">Most classes that currently have a finalizer to simply clean up an operating system handle will not need the finalizer anymore.</span></span> <span data-ttu-id="607f6-148">Bunun yerine, Sonlandırıcı <xref:System.Runtime.InteropServices.SafeHandle> türetilmiş sınıfta olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-148">Instead, the finalizer will be on the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span>

<span data-ttu-id="607f6-149">Bunun <xref:System.Runtime.InteropServices.SafeHandle> yerine bir değiştirme değildir <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="607f6-149">Note that <xref:System.Runtime.InteropServices.SafeHandle> is not a replacement for <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>.</span></span>  <span data-ttu-id="607f6-150">İşletim sistemi kaynaklarını açıkça atılırken hala olası kaynak çekişmesi ve performans avantajları vardır.</span><span class="sxs-lookup"><span data-stu-id="607f6-150">There are still potential resource contention and performance advantages to explicitly dispose operating system resources.</span></span>  <span data-ttu-id="607f6-151">`finally`Kaynakları açıkça atma işleminin tamamlamada yürütülemeyebilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-151">Just realize that `finally` blocks that do explicitly dispose of resources may not execute to completion.</span></span>

<span data-ttu-id="607f6-152"><xref:System.Runtime.InteropServices.SafeHandle><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>, bir işletim sistemi tutamacı boşaltma yordamını veya bir döngüde bir dizi tanıtıcıyı boşaltmayı sağlayan, tanıtıcıyı serbest bırakmak için çalışmayı gerçekleştiren kendi yönteminizi uygulamanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="607f6-152"><xref:System.Runtime.InteropServices.SafeHandle> allows you to implement your own <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method that performs the work to free the handle, such as passing state to an operating system handle freeing routine or freeing a set of handles in a loop.</span></span>  <span data-ttu-id="607f6-153">CLR bu yöntemin çalıştırılmasını garanti eder.</span><span class="sxs-lookup"><span data-stu-id="607f6-153">The CLR guarantees that this method is run.</span></span>  <span data-ttu-id="607f6-154">Bu, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> tanıtıcının tüm koşullarda serbest bırakılacağını sağlamak için uygulamanın yazarının sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="607f6-154">It is the responsibility of the author of the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation to ensure that the handle is released in all circumstances.</span></span> <span data-ttu-id="607f6-155">Bunun yapılmaması, tanıtıcının sızmasına neden olur, bu da genellikle tanıtıcıyla ilişkili yerel kaynakların sızıntısını sağlar.</span><span class="sxs-lookup"><span data-stu-id="607f6-155">Failure to do so will cause the handle to be leaked, which often results in the leakage of native resources associated with the handle.</span></span> <span data-ttu-id="607f6-156">Bu nedenle, <xref:System.Runtime.InteropServices.SafeHandle> türetilmiş sınıfların, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> uygulamanın çağrı sırasında kullanılamayan kaynakların ayrılmasını gerektirmeyecek şekilde oluşturulması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-156">Therefore it is critical to structure <xref:System.Runtime.InteropServices.SafeHandle> derived classes such that the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> implementation does not require the allocation of any resources that may not be available at invocation time.</span></span> <span data-ttu-id="607f6-157"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>Kodunuzun, bu tür arızaları işleyebilmesi ve yerel tanıtıcıyı serbest bırakmak için sözleşmeyi tamamlamasıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-157">Note that it is permissible to call methods that may fail within the implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> provided that your code can handle such failures and complete the contract to release the native handle.</span></span> <span data-ttu-id="607f6-158">Hata ayıklama amacıyla, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> <xref:System.Boolean> `false` kaynak serbest bırakmaya engel olan çok zararlı bir hatayla karşılaşıldığında, bir dönüş değeri vardır.</span><span class="sxs-lookup"><span data-stu-id="607f6-158">For debugging purposes, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> has a <xref:System.Boolean> return value which may be set to `false` if a catastrophic error is encountered which prevents release of the resource.</span></span> <span data-ttu-id="607f6-159">Bunun yapılması, sorunu tanımlamaya yardımcı olması için, etkinleştirilirse [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA öğesini etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="607f6-159">Doing so will activate the [releaseHandleFailed](../debug-trace-profile/releasehandlefailed-mda.md) MDA, if enabled, to aid in identifying the problem.</span></span> <span data-ttu-id="607f6-160">Çalışma zamanını başka hiçbir şekilde etkilemez; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>aynı kaynak için yeniden çağrılmayacak ve sonuç olarak tanıtıcı sızacaktır.</span><span class="sxs-lookup"><span data-stu-id="607f6-160">It does not affect the runtime in any other way; <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> will not be called again for the same resource and consequently the handle will be leaked.</span></span>

<span data-ttu-id="607f6-161"><xref:System.Runtime.InteropServices.SafeHandle>belirli bağlamlarda uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="607f6-161"><xref:System.Runtime.InteropServices.SafeHandle> is not appropriate in certain contexts.</span></span>  <span data-ttu-id="607f6-162"><xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>Yöntem bir <xref:System.GC> Sonlandırıcı iş parçacığında çalıştırılabileceğinizden, belirli bir iş parçacığında serbest olması gereken tüm tutamaçlar bir içinde sarmalanmamalıdır <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="607f6-162">Since the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method can be run on a <xref:System.GC> finalizer thread, any handles that are required to be freed on a particular thread should not be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle>.</span></span>

<span data-ttu-id="607f6-163">Çalışma zamanı çağrılabilir sarmalayıcılar (RCWs) ek kod olmadan CLR tarafından temizlenebilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-163">Runtime callable wrappers (RCWs) can be cleaned by the CLR without additional code.</span></span>  <span data-ttu-id="607f6-164">Platform Invoke kullanan ve bir COM nesnesini bir veya olarak karşılayan kod için `IUnknown*` <xref:System.IntPtr> , kodun bir RCW kullanması için yeniden yazılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="607f6-164">For code that uses platform invoke and treats a COM object as an `IUnknown*` or an <xref:System.IntPtr>, the code should be rewritten to use an RCW.</span></span>  <span data-ttu-id="607f6-165"><xref:System.Runtime.InteropServices.SafeHandle>yönetilen koda geri çağıran yönetilmeyen bir yayın yöntemi olma olasılığı nedeniyle bu senaryo için yeterli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-165"><xref:System.Runtime.InteropServices.SafeHandle> may not be adequate for this scenario due to the possibility of an unmanaged release method calling back into managed code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-166">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-166">Code analysis rule</span></span>

<span data-ttu-id="607f6-167"><xref:System.Runtime.InteropServices.SafeHandle>İşletim sistemi kaynaklarını kapsüllemek için kullanın.</span><span class="sxs-lookup"><span data-stu-id="607f6-167">Use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate operating system resources.</span></span> <span data-ttu-id="607f6-168"><xref:System.Runtime.InteropServices.HandleRef>Veya türündeki alanları kullanmayın <xref:System.IntPtr> .</span><span class="sxs-lookup"><span data-stu-id="607f6-168">Do not use <xref:System.Runtime.InteropServices.HandleRef> or fields of type <xref:System.IntPtr>.</span></span>

### <a name="ensure-finalizers-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="607f6-169">İşletim sistemi kaynaklarının sızmasını engellemek için sonlandırıcılardan çalıştırmak zorunda olmadığından emin olun</span><span class="sxs-lookup"><span data-stu-id="607f6-169">Ensure finalizers do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="607f6-170">Sonlandırıcılarınızı dikkatlice inceleyerek, çalıştırılmasa bile önemli bir işletim sistemi kaynağı sızdırılmaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-170">Review your finalizers carefully to ensure that even if they do not run, a critical operating system resource is not leaked.</span></span>  <span data-ttu-id="607f6-171"><xref:System.AppDomain>Uygulama kararlı bir durumda yürütülürken veya SQL Server gibi bir sunucu kapandığında normal bellekten farklı olarak, bir ani kaldırma işlemi sırasında nesneler sonlandırılmaz <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-171">Unlike a normal <xref:System.AppDomain> unload when the application is executing in a steady state or when a server such as SQL Server shuts down, objects are not finalized during an abrupt <xref:System.AppDomain> unload.</span></span>  <span data-ttu-id="607f6-172">Bir uygulamanın doğruluğu garanti edilemez, ancak sunucunun bütünlüğü, kaynak sızıntısı olmadan tutulması gerektiğinden, kaynakların bir ani kaldırma durumunda sızdırılmadığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="607f6-172">Ensure resources are not leaked in the case of an abrupt unload, since an application's correctness cannot be guaranteed, but the integrity of the server must be maintained by not leaking resources.</span></span>  <span data-ttu-id="607f6-173"><xref:System.Runtime.InteropServices.SafeHandle>Tüm işletim sistemi kaynaklarını serbest bırakmak için kullanın.</span><span class="sxs-lookup"><span data-stu-id="607f6-173">Use <xref:System.Runtime.InteropServices.SafeHandle> to free any operating system resources.</span></span>

### <a name="ensure-that-finally-clauses-do-not-have-to-run-to-prevent-leaking-operating-system-resources"></a><span data-ttu-id="607f6-174">İşletim sistemi kaynaklarının sızmasını engellemek için finally yan tümcelerinin çalıştırmak zorunda olmadığından emin olun</span><span class="sxs-lookup"><span data-stu-id="607f6-174">Ensure that finally clauses do not have to run to prevent leaking operating system resources</span></span>

<span data-ttu-id="607f6-175">`finally`yan tümceleri CERs dışında çalışacak şekilde garanti edilmez ve bu, kitaplık geliştiricilerinin `finally` yönetilmeyen kaynakları serbest bırakmak için bir blok içindeki koda dayanmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="607f6-175">`finally` clauses are not guaranteed to run outside of CERs, requiring library developers to not rely on code within a `finally` block to free unmanaged resources.</span></span>  <span data-ttu-id="607f6-176">Kullanılması <xref:System.Runtime.InteropServices.SafeHandle> önerilen çözümdür.</span><span class="sxs-lookup"><span data-stu-id="607f6-176">Using <xref:System.Runtime.InteropServices.SafeHandle> is the recommended solution.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-177">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-177">Code analysis rule</span></span>

<span data-ttu-id="607f6-178"><xref:System.Runtime.InteropServices.SafeHandle>Yerine işletim sistemi kaynaklarını temizlemek için kullanın `Finalize` .</span><span class="sxs-lookup"><span data-stu-id="607f6-178">Use <xref:System.Runtime.InteropServices.SafeHandle> for cleaning up operating system resources instead of `Finalize`.</span></span> <span data-ttu-id="607f6-179">Kullanın <xref:System.IntPtr> ; <xref:System.Runtime.InteropServices.SafeHandle> kaynakları kapsüllemek için kullanın.</span><span class="sxs-lookup"><span data-stu-id="607f6-179">Do not use <xref:System.IntPtr>; use <xref:System.Runtime.InteropServices.SafeHandle> to encapsulate resources.</span></span> <span data-ttu-id="607f6-180">Finally yan tümcesinin çalışması gerekiyorsa, bunu bir CER içine koyun.</span><span class="sxs-lookup"><span data-stu-id="607f6-180">If the finally clause must run, place it in a CER.</span></span>

### <a name="all-locks-should-go-through-existing-managed-locking-code"></a><span data-ttu-id="607f6-181">Tüm kilitler mevcut yönetilen kilitleme kodu ' na gitmelidir</span><span class="sxs-lookup"><span data-stu-id="607f6-181">All locks should go through existing managed locking code</span></span>

<span data-ttu-id="607f6-182">CLR, kod bir kilit içinde olduğunda bilmelidir; böylece iş parçacığını iptal etmek yerine onu kaldırmak için kullanılır <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-182">The CLR must know when code is in a lock so that it will know to tear down the <xref:System.AppDomain> rather than just aborting the thread.</span></span>  <span data-ttu-id="607f6-183">İş parçacığı tarafından çalıştırılan veriler tutarsız bir durumda bırakılmış olduğundan iş parçacığını iptal etmek tehlikeli olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-183">Aborting the thread could be dangerous as the data operated on by the thread could be left in an inconsistent state.</span></span> <span data-ttu-id="607f6-184">Bu nedenle, tamamının <xref:System.AppDomain> geri dönüştürülmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="607f6-184">Therefore, the entire <xref:System.AppDomain> has to be recycled.</span></span>  <span data-ttu-id="607f6-185">Bir kilidi tespit etmek için başarısız olma sonuçları kilitlenmeler veya hatalı sonuçlar olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-185">The consequences of failing to identify a lock can be either deadlocks or incorrect results.</span></span> <span data-ttu-id="607f6-186">Yöntemlerini <xref:System.Threading.Thread.BeginCriticalRegion%2A> ve <xref:System.Threading.Thread.EndCriticalRegion%2A> kilitleme bölgelerini belirlemek için kullanın.</span><span class="sxs-lookup"><span data-stu-id="607f6-186">Use the methods <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> to identify lock regions.</span></span>  <span data-ttu-id="607f6-187"><xref:System.Threading.Thread>Yalnızca geçerli iş parçacığına uygulanan sınıfta statik yöntemlerdir, bir iş parçacığının başka bir iş parçacığının kilit sayısını düzenlemesini önlemeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-187">They are static methods on the <xref:System.Threading.Thread> class that only apply to the current thread, helping to prevent one thread from editing another thread’s lock count.</span></span>

<span data-ttu-id="607f6-188"><xref:System.Threading.Monitor.Enter%2A>ve <xref:System.Threading.Monitor.Exit%2A> Bu clr bildiriminin yerleşik olmasını sağlamak için, bunların kullanımları ve bu yöntemleri kullanan [Lock ifadesinin](../../csharp/language-reference/keywords/lock-statement.md)kullanımı önerilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-188"><xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> have this CLR notification built in, so their usage is recommended as well as the use of the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md), which uses these methods.</span></span>

<span data-ttu-id="607f6-189">Döndürme kilitleri gibi diğer kilitleme mekanizmaları <xref:System.Threading.AutoResetEvent> , clr 'ye kritik bir bölümün girildiğini bildirmek için bu yöntemleri çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-189">Other locking mechanisms such as spin locks and <xref:System.Threading.AutoResetEvent> must call these methods to notify the CLR that a critical section is being entered.</span></span>  <span data-ttu-id="607f6-190">Bu yöntemler herhangi bir kilit almaz; kritik bir bölümde kodun yürütüldüğü CLR 'yi bilgilendirir ve iş parçacığını iptal etmek paylaşılan durumu tutarsız bırakabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-190">These methods do not take any locks; they inform the CLR that code is executing in a critical section and aborting the thread could leave shared state inconsistent.</span></span>  <span data-ttu-id="607f6-191">Özel bir sınıf gibi kendi kilit türünü tanımladıysanız <xref:System.Threading.ReaderWriterLock> , bu kilit sayısı yöntemlerini kullanın.</span><span class="sxs-lookup"><span data-stu-id="607f6-191">If you have defined your own lock type, such as a custom <xref:System.Threading.ReaderWriterLock> class, use these lock count methods.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-192">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-192">Code analysis rule</span></span>

<span data-ttu-id="607f6-193">Ve kullanarak tüm kilitleri işaretleyin ve <xref:System.Threading.Thread.BeginCriticalRegion%2A> belirler <xref:System.Threading.Thread.EndCriticalRegion%2A> .</span><span class="sxs-lookup"><span data-stu-id="607f6-193">Mark and identify all locks using <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A>.</span></span> <span data-ttu-id="607f6-194"><xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A> Ve <xref:System.Threading.Interlocked.Decrement%2A> bir döngüsünde kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-194">Do not use <xref:System.Threading.Interlocked.CompareExchange%2A>, <xref:System.Threading.Interlocked.Increment%2A>, and <xref:System.Threading.Interlocked.Decrement%2A> in a loop.</span></span>  <span data-ttu-id="607f6-195">Bu yöntemlerin Win32 türevleri için platform çağırma kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-195">Do not do a platform invoke of the Win32 variants of these methods.</span></span>  <span data-ttu-id="607f6-196"><xref:System.Threading.Thread.Sleep%2A>Bir döngüde kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-196">Do not use <xref:System.Threading.Thread.Sleep%2A> in a loop.</span></span>  <span data-ttu-id="607f6-197">Geçici alanları kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-197">Do not use volatile fields.</span></span>

### <a name="cleanup-code-must-be-in-a-finally-or-a-catch-block-not-following-a-catch"></a><span data-ttu-id="607f6-198">Temizleme kodu bir catch ve catch bloğunda olmalıdır, catch takip edilmez</span><span class="sxs-lookup"><span data-stu-id="607f6-198">Cleanup code must be in a finally or a catch block, Not following a catch</span></span>

<span data-ttu-id="607f6-199">Temizleme kodu asla bir blok izlemelidir `catch` ; `finally` blok içinde veya `catch` bloğunda olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-199">Cleanup code should never follow a `catch` block; it should be in a `finally` or in the `catch` block itself.</span></span> <span data-ttu-id="607f6-200">Bu, normal bir iyi uygulama olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-200">This should be a normal good practice.</span></span> <span data-ttu-id="607f6-201">Bir `finally` blok genellikle tercih edilir çünkü her ikisi de bir özel durum oluştuğunda ve `try` bloğunun sonuna genellikle rastlamadığında aynı kodu çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="607f6-201">A `finally` block is generally preferred because it runs the same code both when an exception is thrown and when the end of the `try` block is normally encountered.</span></span>  <span data-ttu-id="607f6-202">Oluşan beklenmeyen bir özel durum durumunda, örneğin <xref:System.Threading.ThreadAbortException> , temizlik kodu çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-202">In the event of an unexpected exception being thrown, for example a <xref:System.Threading.ThreadAbortException>, the cleanup code will not run.</span></span>  <span data-ttu-id="607f6-203">Üzerinde temizleyene olan yönetilmeyen tüm kaynaklar, `finally` sızıntıları engellemek için ideal olarak bir öğesine sarmalanmış olmalıdır <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="607f6-203">Any unmanaged resources that you would clean up in a `finally` should ideally be wrapped in a <xref:System.Runtime.InteropServices.SafeHandle> to prevent leaks.</span></span>  <span data-ttu-id="607f6-204">C# `using` anahtar sözcüğünün tutamaçlar dahil olmak üzere nesneleri atmak için etkili bir şekilde kullanılabileceğini aklınızda bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="607f6-204">Note the C# `using` keyword can be used effectively to dispose of objects, including handles.</span></span>

<span data-ttu-id="607f6-205"><xref:System.AppDomain>Geri dönüşüm, Sonlandırıcı iş parçacığında kaynakları temizleyebilse de, temizleme kodunu doğru yere yerleştirmek de önemlidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-205">Although <xref:System.AppDomain> recycling can clean up resources on the finalizer thread, it is still important to put cleanup code in the correct place.</span></span> <span data-ttu-id="607f6-206">Bir iş parçacığı kilidi olmayan bir zaman uyumsuz özel durum alırsa, CLR 'yi geri dönüştürmek zorunda kalmadan iş parçacığını sonlandırmayı dener <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-206">Note that if a thread receives an asynchronous exception without holding a lock, the CLR attempts to end the thread itself without having to recycle the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="607f6-207">Kaynakların daha sonra daha önce temizlenmesini sağlamak yerine daha fazla kaynak kullanılabilir hale getirerek ve yaşam süresini daha iyi yönetebilmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="607f6-207">Ensuring that resources are cleaned up sooner rather than later helps by making more resources available, and by better managing the lifetime.</span></span> <span data-ttu-id="607f6-208">Bazı hata kodu yollarındaki bir dosyayı bir tutamacı açık bir şekilde kapatmadıysanız <xref:System.Runtime.InteropServices.SafeHandle> , bir sonraki kod çalıştırıldığında, sonlandırıcının zaten çalıştırılmamasından sonra tam olarak aynı dosyaya erişme girişimi başarısız olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-208">If you do not explicitly close a handle to a file in some error code path then wait for the <xref:System.Runtime.InteropServices.SafeHandle> finalizer to clean it up, the next time your code runs it may fail trying to access the exact same file if the finalizer has not already run.</span></span>  <span data-ttu-id="607f6-209">Bu nedenle, temizleme kodunun var olduğunu ve düzgün çalışmasını sağlamak, kesin olarak gerekli olmasa bile hatalardan daha düzgün ve hızlı bir şekilde kurtarılmasına yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-209">For this reason, ensuring that cleanup code exists and works correctly will help recover from failures more cleanly and quickly, even though it is not strictly necessary.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-210">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-210">Code analysis rule</span></span>

<span data-ttu-id="607f6-211">Temizleme kodunun `catch` bir blokta olması gerekir `finally` .</span><span class="sxs-lookup"><span data-stu-id="607f6-211">Cleanup code after `catch` needs to be in a `finally` block.</span></span> <span data-ttu-id="607f6-212">Finally bloğunda Dispose için çağrılar yerleştir.</span><span class="sxs-lookup"><span data-stu-id="607f6-212">Place calls to dispose in a finally block.</span></span> <span data-ttu-id="607f6-213">`catch`blokların bir throw veya Rethrow ile bitmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="607f6-213">`catch` blocks should end in a throw or rethrow.</span></span> <span data-ttu-id="607f6-214">Çok sayıda özel durum almanızı sağlayan bir ağ bağlantısının yapılıp yapılmayacağını algılayan kod gibi özel durumlar da olsa da, normal koşullarda bir dizi özel durumun yakalanmasını gerektiren tüm kodlar kodun başarılı olup olmayacağını görmek için kodun test edilip edilmeyeceğini belirten bir bildirim vermelidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-214">While there will be exceptions, such as code detecting whether a network connection can be established where you might get any of a large number of exceptions, any code that requires the catching of a number of exceptions under normal circumstances should give an indication that the code should be tested to see if it will succeed.</span></span>

### <a name="process-wide-mutable-shared-state-between-application-domains-should-be-eliminated-or-use-a-constrained-execution-region"></a><span data-ttu-id="607f6-215">Uygulama etki alanları arasında işlem genelindeki kesilebilir paylaşılan durum, elemeli veya kısıtlı bir yürütme bölgesi kullanmalıdır</span><span class="sxs-lookup"><span data-stu-id="607f6-215">Process-Wide mutable shared state between application domains should be eliminated or use a constrained execution region</span></span>

<span data-ttu-id="607f6-216">Giriş bölümünde açıklandığı gibi, uygulama etki alanları genelinde işlem genelinde paylaşılan durumları güvenli bir şekilde izleyen yönetilen kodu yazmak çok zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-216">As described in the introduction, it can be very difficult to write managed code that monitors process-wide shared state across application domains in a reliable manner.</span></span>  <span data-ttu-id="607f6-217">İşlem genelinde paylaşılan durum, uygulama etki alanları arasında, Win32 kodunda, CLR içinde veya uzaktan iletişim kullanılarak yönetilen kodda paylaşılan bir veri yapısı sıralarından oluşur.</span><span class="sxs-lookup"><span data-stu-id="607f6-217">Process-wide shared state is any sort of data structure shared between application domains, either in Win32 code, inside the CLR, or in managed code using remoting.</span></span>  <span data-ttu-id="607f6-218">Herhangi bir kesilebilir paylaşılan durum, yönetilen kodda doğru şekilde yazılması çok zordur ve statik paylaşılan durum yalnızca harika bir sorun ile yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-218">Any mutable shared state is very difficult to correctly write in managed code, and any static shared state might be done only with great care.</span></span>  <span data-ttu-id="607f6-219">İşlem genelinde veya makine genelinde paylaşılan durumdaysa, bu dosyayı ortadan kaldırmanın veya kısıtlanmış bir yürütme bölgesi (CER) kullanarak paylaşılan durumu korumanın bir yolunu bulun.</span><span class="sxs-lookup"><span data-stu-id="607f6-219">If you have process-wide or machine-wide shared state, find some way to eliminate it or protect the shared state using a constrained execution region (CER).</span></span>  <span data-ttu-id="607f6-220">Tanımlanmayan ve düzeltilen paylaşılan durum içeren herhangi bir kitaplığın, kilitlenme için temiz kaldırma gerektiren SQL Server gibi bir konağa neden olabileceğini unutmayın <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-220">Note that any library with shared state that is not identified and corrected could cause a host, such as SQL Server, that requires clean <xref:System.AppDomain> unloading to crash.</span></span>

<span data-ttu-id="607f6-221">Kod bir COM nesnesi kullanıyorsa, bu COM nesnesinin uygulama etki alanları arasında paylaşılmasını önleyin.</span><span class="sxs-lookup"><span data-stu-id="607f6-221">If code uses a COM object, avoid sharing that COM object between application domains.</span></span>

### <a name="locks-do-not-work-process-wide-or-between-application-domains"></a><span data-ttu-id="607f6-222">Kilitler işlem genelinde veya uygulama etki alanları arasında çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-222">Locks do not work process-wide or between application domains.</span></span>

<span data-ttu-id="607f6-223">Geçmişte <xref:System.Threading.Monitor.Enter%2A> ve [Lock deyimleri](../../csharp/language-reference/keywords/lock-statement.md) genel işlem kilitleri oluşturmak için kullanılmıştır.</span><span class="sxs-lookup"><span data-stu-id="607f6-223">In the past, <xref:System.Threading.Monitor.Enter%2A> and the [lock Statement](../../csharp/language-reference/keywords/lock-statement.md) have been used to create global process locks.</span></span>  <span data-ttu-id="607f6-224">Örneğin, bu durum, <xref:System.AppDomain> <xref:System.Type> paylaşılan olmayan derlemelerin, <xref:System.Threading.Thread> nesnelerin, yerleşik dizelerin ve uzaktan iletişim ile uygulama etki alanları arasında paylaşılan bazı dizelerin örnekleri gibi çevik sınıflarda kilitlenirken meydana gelir.</span><span class="sxs-lookup"><span data-stu-id="607f6-224">For example, this occurs when locking on <xref:System.AppDomain> agile classes, such as <xref:System.Type> instances from non-shared assemblies, <xref:System.Threading.Thread> objects, interned strings, and some strings shared across application domains using remoting.</span></span>  <span data-ttu-id="607f6-225">Bu kilitler artık işlem genelinde değildir.</span><span class="sxs-lookup"><span data-stu-id="607f6-225">These locks are no longer process-wide.</span></span>  <span data-ttu-id="607f6-226">İşlem genelinde bir uygulama etki alanı kilidinin varlığını belirlemek için, kilit içindeki kodun diskteki bir dosya veya muhtemelen bir veritabanı gibi herhangi bir harici, kalıcı kaynak kullanıp kullanmadığını belirler.</span><span class="sxs-lookup"><span data-stu-id="607f6-226">To identify the presence of a process-wide interapplication domain lock, determine if the code within the lock uses any external, persisted resource such as a file on disk or possibly a database.</span></span>

<span data-ttu-id="607f6-227"><xref:System.AppDomain>Bu kod birden çok uygulama etki alanında aynı anda çalıştırılabildiğinden, bir kilit, bir dış kaynak kullanıyorsa, bir kilit alınması sorun oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-227">Note that taking a lock within an <xref:System.AppDomain> might cause problems if the protected code uses an external resource because that code may run simultaneously across multiple application domains.</span></span>  <span data-ttu-id="607f6-228">Bu, bir günlük dosyasına yazarken veya tüm işlem için bir yuvaya bağlamakla ilgili bir sorun olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-228">This can be a problem when writing to one log file or binding to a socket for the entire process.</span></span>  <span data-ttu-id="607f6-229">Bu değişiklikler, adlandırılmış veya örnek kullanmaktan başka bir işlem genel kilidi almak için, yönetilen kod kullanmanın kolay bir yolu olmadığı anlamına gelir <xref:System.Threading.Mutex> <xref:System.Threading.Semaphore> .</span><span class="sxs-lookup"><span data-stu-id="607f6-229">These changes mean there is no easy way, using managed code, to get a process-global lock, other than using a named <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> instance.</span></span>  <span data-ttu-id="607f6-230">Aynı anda iki uygulama etki alanında çalıştırmayan kodu oluşturun veya <xref:System.Threading.Mutex> ya da <xref:System.Threading.Semaphore> sınıflarını kullanın.</span><span class="sxs-lookup"><span data-stu-id="607f6-230">Create code that does not run in two application domains simultaneously, or use the <xref:System.Threading.Mutex> or <xref:System.Threading.Semaphore> classes.</span></span>  <span data-ttu-id="607f6-231">Varolan kod değiştirilemediğinden, bu eşitlemeye ulaşmak için Win32 adlı bir mutex kullanmayın çünkü fiber modda çalıştırmak, aynı işletim sistemi iş parçacığının bir mutex 'i elde edeceğini ve yayınlamadığını garanti edemeyeceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="607f6-231">If existing code cannot be changed, do not use a Win32 named mutex to achieve this synchronization because running in fiber mode means you cannot guarantee the same operating system thread will acquire and release a mutex.</span></span>  <span data-ttu-id="607f6-232"><xref:System.Threading.Mutex> <xref:System.Threading.ManualResetEvent> <xref:System.Threading.AutoResetEvent> <xref:System.Threading.Semaphore> Kod kilidini, yönetilmeyen kod kullanarak kilidi eşitlemek yerine clr 'nin farkında olacak şekilde eşitlemek için, yönetilen sınıf veya bir adlandırılmış, ya da bir adı kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="607f6-232">You must use the managed <xref:System.Threading.Mutex> class, or a named <xref:System.Threading.ManualResetEvent>, <xref:System.Threading.AutoResetEvent>, or a <xref:System.Threading.Semaphore> to synchronize the code lock in a manner that the CLR is aware of instead of synchronizing the lock using unmanaged code.</span></span>

#### <a name="avoid-locktypeofmytype"></a><span data-ttu-id="607f6-233">Kilit kullanmaktan kaçının (typeof (MyType))</span><span class="sxs-lookup"><span data-stu-id="607f6-233">Avoid lock(typeof(MyType))</span></span>

<span data-ttu-id="607f6-234"><xref:System.Type>Paylaşılan derlemelerdeki özel ve ortak nesneler, tüm uygulama etki alanları genelinde paylaşılan kodun yalnızca bir kopyasına sahiptir ve sorunlar da sunar.</span><span class="sxs-lookup"><span data-stu-id="607f6-234">Private and public <xref:System.Type> objects in shared assemblies with only one copy of the code shared across all application domains also present problems.</span></span>  <span data-ttu-id="607f6-235">Paylaşılan derlemeler için, işlem başına yalnızca bir örnek vardır <xref:System.Type> . Bu, birden çok uygulama etki alanının tam aynı örneği paylaştığı anlamına gelir <xref:System.Type> .</span><span class="sxs-lookup"><span data-stu-id="607f6-235">For shared assemblies, there is only one instance of a <xref:System.Type> per process, meaning that multiple application domains share the exact same <xref:System.Type> instance.</span></span>  <span data-ttu-id="607f6-236">Bir örnek üzerinde kilit alınması <xref:System.Type> , yalnızca ' a değil, tüm işlemi etkileyen bir kilit alır <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-236">Taking a lock on a <xref:System.Type> instance takes a lock that affects the entire process, not just the <xref:System.AppDomain>.</span></span>  <span data-ttu-id="607f6-237">Bir <xref:System.AppDomain> nesne üzerinde bir kilit alırsa <xref:System.Type> , bu iş parçacığı aniden iptal edildiğinde kilidi serbest bırakmaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-237">If one <xref:System.AppDomain> takes a lock on a <xref:System.Type> object then that thread gets abruptly aborted, it will not release the lock.</span></span>  <span data-ttu-id="607f6-238">Bu kilit daha sonra diğer uygulama etki alanlarının kilitlenmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-238">This lock then may cause other application domains to deadlock.</span></span>

<span data-ttu-id="607f6-239">Statik yöntemlerde kilit almanın iyi bir yolu, koda statik bir iç eşitleme nesnesi eklemekten oluşur.</span><span class="sxs-lookup"><span data-stu-id="607f6-239">A good way to take locks in static methods involves adding a static internal synchronization object to the code.</span></span>  <span data-ttu-id="607f6-240">Bu, bir tane varsa sınıf oluşturucusunda başlatılabilir, ancak şu şekilde başlatılabilir:</span><span class="sxs-lookup"><span data-stu-id="607f6-240">This could be initialized in the class constructor if one is present, but if not it can be initialized like this:</span></span>

```csharp
private static Object s_InternalSyncObject;
private static Object InternalSyncObject
{
    get
    {
        if (s_InternalSyncObject == null)
        {
            Object o = new Object();
            Interlocked.CompareExchange(
                ref s_InternalSyncObject, o, null);
        }
        return s_InternalSyncObject;
    }
}
```

<span data-ttu-id="607f6-241">Ardından bir kilit alırken, `InternalSyncObject` özelliğini kullanarak kilitlenecek bir nesne elde edin.</span><span class="sxs-lookup"><span data-stu-id="607f6-241">Then when taking a lock, use the `InternalSyncObject` property to obtain an object to lock on.</span></span>  <span data-ttu-id="607f6-242">Sınıf oluşturucuda iç eşitleme nesnesini oluşturduysanız özelliğini kullanmanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="607f6-242">You do not need to use the property if you have initialized the internal synchronization object in your class constructor.</span></span>  <span data-ttu-id="607f6-243">Çift denetim kilidi başlatma kodu şu örnekteki gibi görünmelidir:</span><span class="sxs-lookup"><span data-stu-id="607f6-243">The double checking lock initialization code should look like this example:</span></span>

```csharp
public static MyClass SingletonProperty
{
    get
    {
        if (s_SingletonProperty == null)
        {
            lock(InternalSyncObject)
            {
                // Do not use lock(typeof(MyClass))
                if (s_SingletonProperty == null)
                {
                    MyClass tmp = new MyClass(…);
                    // Do all initialization before publishing
                    s_SingletonProperty = tmp;
                }
            }
        }
        return s_SingletonProperty;
    }
}
```

#### <a name="a-note-about-lockthis"></a><span data-ttu-id="607f6-244">Kilit (Bu) ile ilgili bir nota</span><span class="sxs-lookup"><span data-stu-id="607f6-244">A note about lock(this)</span></span>

<span data-ttu-id="607f6-245">Genel olarak erişilebilen tek bir nesne üzerinde kilit almak için genellikle kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-245">It is generally acceptable to take a lock on an individual object that is publicly accessible.</span></span>  <span data-ttu-id="607f6-246">Ancak nesne, tüm alt sistemin kilitlenmesine neden olabilecek bir tekil nesnedeyse, yukarıdaki tasarım modelini de kullanmayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="607f6-246">However, if the object is a singleton object that might cause an entire subsystem to deadlock, consider using the above design pattern as well.</span></span>  <span data-ttu-id="607f6-247">Örneğin, bir nesne üzerindeki bir kilit, <xref:System.Security.SecurityManager> <xref:System.AppDomain> Tüm kullanılamaz hale getirilmesi sırasında kilitlenmeyle sonuçlanabilir <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-247">For example, a lock on the one <xref:System.Security.SecurityManager> object could cause a deadlock within the <xref:System.AppDomain> making the entire <xref:System.AppDomain> unusable.</span></span> <span data-ttu-id="607f6-248">Bu türden herkese açık erişilebilen bir nesne üzerinde kilit almak iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="607f6-248">It is good practice to not take a lock on a publicly accessible object of this type.</span></span>  <span data-ttu-id="607f6-249">Ancak, tek bir koleksiyon veya dizide bir kilit genellikle bir sorun sunmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-249">However a lock on an individual collection or array should generally not present a problem.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-250">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-250">Code analysis rule</span></span>

<span data-ttu-id="607f6-251">Uygulama etki alanları genelinde kullanılabilecek veya tanımlayıcı bir kimlik tanıma olmayan türler üzerinde kilit almaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-251">Do not take locks on types that might be used across application domains or do not have a strong sense of identity.</span></span> <span data-ttu-id="607f6-252">,,,,, <xref:System.Threading.Monitor.Enter%2A> <xref:System.Type> Veya ' <xref:System.Reflection.MethodInfo> <xref:System.Reflection.PropertyInfo> <xref:System.String> <xref:System.ValueType> <xref:System.Threading.Thread> den türetilen herhangi bir nesneyi <xref:System.MarshalByRefObject> çağırmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-252">Do not call <xref:System.Threading.Monitor.Enter%2A> on a <xref:System.Type>, <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.PropertyInfo>, <xref:System.String>, <xref:System.ValueType>, <xref:System.Threading.Thread>, or any object that derives from <xref:System.MarshalByRefObject>.</span></span>

### <a name="remove-gckeepalive-calls"></a><span data-ttu-id="607f6-253">GC 'yi kaldırın. Canlı tutma çağrıları</span><span class="sxs-lookup"><span data-stu-id="607f6-253">Remove GC.KeepAlive calls</span></span>

<span data-ttu-id="607f6-254">Uygun olmayan, var olan kodun önemli bir miktarı, bunu kullanması <xref:System.GC.KeepAlive%2A> veya kullanması durumunda kullanmaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-254">A significant amount of existing code either does not use <xref:System.GC.KeepAlive%2A> when it should or uses it when it is not appropriate.</span></span>  <span data-ttu-id="607f6-255"><xref:System.Runtime.InteropServices.SafeHandle>' A dönüştürdükten sonra, <xref:System.GC.KeepAlive%2A> bir sonlandırıcısı olmadığı ve <xref:System.Runtime.InteropServices.SafeHandle> işletim sistemi tutamaçlarını sonuçlandırmak için açık olan sınıfların çağrı yapması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="607f6-255">After converting to <xref:System.Runtime.InteropServices.SafeHandle>, classes do not need to call <xref:System.GC.KeepAlive%2A>, assuming they do not have a finalizer but rely on <xref:System.Runtime.InteropServices.SafeHandle> to finalize the operating system handles.</span></span>  <span data-ttu-id="607f6-256">Bir çağrıyı tutmaya yönelik performans maliyeti göz ardı edilebilir olsa da <xref:System.GC.KeepAlive%2A> , bir çağrının, <xref:System.GC.KeepAlive%2A> artık mevcut olmayan bir yaşam süresi sorununu gidermek için gerekli veya yeterli olması, kodun bakımını daha zor hale getirir.</span><span class="sxs-lookup"><span data-stu-id="607f6-256">While the performance cost of retaining a call to <xref:System.GC.KeepAlive%2A> may be negligible, the perception that a call to <xref:System.GC.KeepAlive%2A> is either necessary or sufficient to solve a lifetime issue that may no longer exist makes the code more difficult to maintain.</span></span>  <span data-ttu-id="607f6-257">Ancak, COM birlikte çalışabilirlik CLR çağrılabilir sarmalayıcıları (RCWs) kullanılırken <xref:System.GC.KeepAlive%2A> kod için hala gerekli olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-257">However, when using the COM interop CLR callable wrappers (RCWs), <xref:System.GC.KeepAlive%2A> is still required by code.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-258">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-258">Code analysis rule</span></span>

<span data-ttu-id="607f6-259">Kaldırın <xref:System.GC.KeepAlive%2A> .</span><span class="sxs-lookup"><span data-stu-id="607f6-259">Remove <xref:System.GC.KeepAlive%2A>.</span></span>

### <a name="use-the-hostprotection-attribute"></a><span data-ttu-id="607f6-260">HostProtection özniteliğini kullanma</span><span class="sxs-lookup"><span data-stu-id="607f6-260">Use the HostProtection Attribute</span></span>

<span data-ttu-id="607f6-261"><xref:System.Security.Permissions.HostProtectionAttribute>(HPa), konak koruma gereksinimlerini belirlemede, ana bilgisayarın, örneğin veya SQL Server gibi belirli bir konak için uygun olmayan belirli yöntemleri aramasını engellemesine olanak tanımak için bildirim temelli güvenlik eylemlerinin kullanımını sağlar <xref:System.Environment.Exit%2A> <xref:System.Windows.Forms.MessageBox.Show%2A> .</span><span class="sxs-lookup"><span data-stu-id="607f6-261">The <xref:System.Security.Permissions.HostProtectionAttribute> (HPA) provides the use of declarative security actions to determine host protection requirements, allowing the host to prevent even fully trusted code from calling certain methods which are inappropriate for the given host, such as <xref:System.Environment.Exit%2A> or <xref:System.Windows.Forms.MessageBox.Show%2A> for SQL Server.</span></span>

<span data-ttu-id="607f6-262">HPA yalnızca ortak dil çalışma zamanını barındıran ve SQL Server gibi konak korumasını uygulayan yönetilmeyen uygulamaları etkiler.</span><span class="sxs-lookup"><span data-stu-id="607f6-262">The HPA affects only unmanaged applications that host the common language runtime and implement host protection, such as SQL Server.</span></span> <span data-ttu-id="607f6-263">Uygulandığında, güvenlik eylemi, sınıf veya yöntemin açığa çıkardığı konak kaynaklarına dayalı bir bağlantı talebi oluşturulmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-263">When applied, the security action results in the creation of a link demand based on the host resources the class or method exposes.</span></span> <span data-ttu-id="607f6-264">Kod bir istemci uygulamasında veya konak korumalı olmayan bir sunucuda çalışıyorsa, "oturum" özniteliği algılanmadı ve bu nedenle uygulanmadı.</span><span class="sxs-lookup"><span data-stu-id="607f6-264">If the code is run in a client application or on a server that is not host-protected, the attribute "evaporates"; it is not detected and therefore not applied.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="607f6-265">Bu özniteliğin amacı, güvenlik davranışını değil, konağa özgü programlama modeli kılavuzlarını zorlayasağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="607f6-265">The purpose of this attribute is to enforce host-specific programming model guidelines, not security behavior.</span></span>  <span data-ttu-id="607f6-266">Model gereksinimleri programlama ile uygunluğu denetlemek için bir bağlantı isteği kullanılmasına karşın, <xref:System.Security.Permissions.HostProtectionAttribute> güvenlik izni değildir.</span><span class="sxs-lookup"><span data-stu-id="607f6-266">Although a link demand is used to check for conformance to programming model requirements, the <xref:System.Security.Permissions.HostProtectionAttribute> is not a security permission.</span></span>

<span data-ttu-id="607f6-267">Konağın programlama modeli gereksinimleri yoksa bağlantı talepleri gerçekleşmez.</span><span class="sxs-lookup"><span data-stu-id="607f6-267">If the host does not have programming model requirements, the link demands do not occur.</span></span>

<span data-ttu-id="607f6-268">Bu öznitelik aşağıdakileri tanımlar:</span><span class="sxs-lookup"><span data-stu-id="607f6-268">This attribute identifies the following:</span></span>

- <span data-ttu-id="607f6-269">Konak programlama modeline uymayan, ancak zararsız olan Yöntemler veya sınıflar.</span><span class="sxs-lookup"><span data-stu-id="607f6-269">Methods or classes that do not fit the host programming model, but are otherwise benign.</span></span>

- <span data-ttu-id="607f6-270">Konak programlama modeline uymayan Yöntemler veya sınıflar ve sunucu tarafından yönetilen kullanıcı kodunun sabitleştirilmesi için yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-270">Methods or classes that do not fit the host programming model and could lead to destabilizing server-managed user code.</span></span>

- <span data-ttu-id="607f6-271">Konak programlama modeline uymayan Yöntemler veya sınıflar ve sunucu işleminin sabitinin kararlı hale getirilmesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-271">Methods or classes that do not fit the host programming model and could lead to a destabilization of the server process itself.</span></span>

> [!NOTE]
> <span data-ttu-id="607f6-272">Konak korumalı bir ortamda yürütülebileceği uygulamalar tarafından çağrılacak bir sınıf kitaplığı oluşturuyorsanız, bu özniteliği kaynak kategorilerini açığa çıkaran üyelere uygulamalısınız <xref:System.Security.Permissions.HostProtectionResource> .</span><span class="sxs-lookup"><span data-stu-id="607f6-272">If you are creating a class library that is to be called by applications that may execute in a host protected environment, you should apply this attribute to members that expose <xref:System.Security.Permissions.HostProtectionResource> resource categories.</span></span> <span data-ttu-id="607f6-273">Bu özniteliğe sahip .NET Framework sınıf kitaplığı üyeleri yalnızca hemen çağıranın denetlenmesi için yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-273">The .NET Framework class library members with this attribute cause only the immediate caller to be checked.</span></span>  <span data-ttu-id="607f6-274">Kitaplık üyeüme aynı zamanda kendi arayanın aynı şekilde denetimine neden olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-274">Your library member must also cause a check of its immediate caller in the same manner.</span></span>

<span data-ttu-id="607f6-275">Lütfen HPA hakkında daha fazla bilgi edinin <xref:System.Security.Permissions.HostProtectionAttribute> .</span><span class="sxs-lookup"><span data-stu-id="607f6-275">Please find more information on HPA in <xref:System.Security.Permissions.HostProtectionAttribute>.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-276">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-276">Code analysis rule</span></span>

<span data-ttu-id="607f6-277">SQL Server için, eşitleme veya iş parçacığı tanıtmak için kullanılan tüm yöntemlerin HPA ile tanımlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="607f6-277">For SQL Server, all methods used to introduce synchronization or threading must identified with the HPA.</span></span> <span data-ttu-id="607f6-278">Bu durum, durumu paylaşan, eşitlenen veya dış süreçler yöneten yöntemleri içerir.</span><span class="sxs-lookup"><span data-stu-id="607f6-278">This includes methods that share state, are synchronized, or manage external processes.</span></span> <span data-ttu-id="607f6-279"><xref:System.Security.Permissions.HostProtectionResource>SQL Server etkileyen değerler <xref:System.Security.Permissions.HostProtectionResource.SharedState> , ve ' dir <xref:System.Security.Permissions.HostProtectionResource.Synchronization> <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt> .</span><span class="sxs-lookup"><span data-stu-id="607f6-279">The <xref:System.Security.Permissions.HostProtectionResource> values that impact SQL Server are <xref:System.Security.Permissions.HostProtectionResource.SharedState>, <xref:System.Security.Permissions.HostProtectionResource.Synchronization>, and <xref:System.Security.Permissions.HostProtectionResource.ExternalProcessMgmt>.</span></span> <span data-ttu-id="607f6-280">Ancak, herhangi bir yöntemi ortaya çıkaran herhangi <xref:System.Security.Permissions.HostProtectionResource> bir yöntem yalnızca SQL 'i etkileyen kaynakları kullanan BIR HPA tarafından tanımlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-280">However, any method that exposes any <xref:System.Security.Permissions.HostProtectionResource> should be identified by a HPA, not just those using resources affecting SQL.</span></span>

### <a name="do-not-block-indefinitely-in-unmanaged-code"></a><span data-ttu-id="607f6-281">Yönetilmeyen kodda süresiz olarak engellenmeyin</span><span class="sxs-lookup"><span data-stu-id="607f6-281">Do not block indefinitely in unmanaged code</span></span>

<span data-ttu-id="607f6-282">Yönetilen kod yerine yönetilmeyen kodda engelleme, CLR iş parçacığını durduramadığı için hizmet reddi saldırısına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-282">Blocking in unmanaged code instead of in managed code can cause a denial of service attack because the CLR is not able to abort the thread.</span></span>  <span data-ttu-id="607f6-283">Engellenen bir iş parçacığı, <xref:System.AppDomain> en azından, son derece güvenli olmayan işlemler yapmadan clr 'nin kaldırılmasını engeller.</span><span class="sxs-lookup"><span data-stu-id="607f6-283">A blocked thread prevents the CLR from unloading the <xref:System.AppDomain>, at least without doing some extremely unsafe operations.</span></span>  <span data-ttu-id="607f6-284">Windows eşitleme temel kullanımını engellemek, izin verdiğimiz bir şeyin açık bir örneğidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-284">Blocking using a Windows synchronization primitive is a clear example of something we cannot allow.</span></span>  <span data-ttu-id="607f6-285">`ReadFile`Mümkünse, bir yuva üzerinde yapılan bir çağrıda engelleme yapılabilmelidir — ideal olarak, WINDOWS API bunun zaman aşımı gibi bir işlem için bir mekanizma sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-285">Blocking in a call to `ReadFile` on a socket should be avoided if possible — ideally the Windows API should provide a mechanism for an operation like this to time out.</span></span>

<span data-ttu-id="607f6-286">Doğal olarak çağıran herhangi bir yöntem ideal, sınırlı bir zaman aşımıyla bir Win32 çağrısı kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-286">Any method that calls into native should ideally use a Win32 call with a reasonable, finite timeout.</span></span>  <span data-ttu-id="607f6-287">Kullanıcının zaman aşımını belirtmesini izin veriliyorsa, kullanıcının belirli bir güvenlik izni olmadan sonsuz bir zaman aşımı belirtmemelidir.</span><span class="sxs-lookup"><span data-stu-id="607f6-287">If the user is allowed to specify the timeout, the user should not be allowed to specify an infinite timeout without some specific security permission.</span></span>  <span data-ttu-id="607f6-288">Bir kılavuz olarak, bir yöntem ~ 10 saniyeden uzun bir süre boyunca engellense, zaman aşımlarını destekleyen bir sürüm kullanmanız veya ek CLR desteği almanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="607f6-288">As a guideline, if a method will block for more than ~10 seconds, you need to be using a version that supports timeouts or you need additional CLR support.</span></span>

<span data-ttu-id="607f6-289">Soruna neden olan API 'Ler örnekleri aşağıda verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="607f6-289">Here are some examples of problematic APIs.</span></span>  <span data-ttu-id="607f6-290">Kanallar (hem anonim hem de adlandırılmış), bir zaman aşımı ile oluşturulabilir; Ancak, kod NMPWAIT_WAIT_FOREVER hiçbir şekilde hiçbir şekilde çağrı olmamasını sağlamalıdır `CreateNamedPipe` `WaitNamedPipe` .</span><span class="sxs-lookup"><span data-stu-id="607f6-290">Pipes (both anonymous and named) can be created with a timeout; however, code must ensure it never calls `CreateNamedPipe` nor `WaitNamedPipe` with NMPWAIT_WAIT_FOREVER.</span></span>  <span data-ttu-id="607f6-291">Ayrıca, zaman aşımı belirtilmiş olsa bile beklenmedik engelleme olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-291">Additionally, there can be unexpected blocking even if a timeout is specified.</span></span>  <span data-ttu-id="607f6-292">`WriteFile`Anonim bir kanalda çağırmak, tüm baytlar yazılana kadar engeller, yani arabellekte okunmamış veriler varsa, bu, `WriteFile` okuyucu kanal arabelleğinde alan boşaltana kadar engeller.</span><span class="sxs-lookup"><span data-stu-id="607f6-292">Calling `WriteFile` on an anonymous pipe will block until all bytes are written, meaning if the buffer has unread data in it, the `WriteFile` call will block until the reader has freed up space in the pipe’s buffer.</span></span>  <span data-ttu-id="607f6-293">Yuvalar her zaman bir zaman aşımı mekanizmasını karşılayan bazı API 'leri kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-293">Sockets should always use some API that honors a timeout mechanism.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-294">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-294">Code analysis rule</span></span>

<span data-ttu-id="607f6-295">Yönetilmeyen kodda zaman aşımı olmadan engelleme, bir hizmet reddi saldırıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-295">Blocking without a timeout in unmanaged code is a denial of service attack.</span></span> <span data-ttu-id="607f6-296">,,, Ve için platform çağırma çağrıları gerçekleştirmeyin `WaitForSingleObject` `WaitForSingleObjectEx` `WaitForMultipleObjects` `MsgWaitForMultipleObjects` `MsgWaitForMultipleObjectsEx` .</span><span class="sxs-lookup"><span data-stu-id="607f6-296">Do not perform platform invoke calls to `WaitForSingleObject`, `WaitForSingleObjectEx`, `WaitForMultipleObjects`, `MsgWaitForMultipleObjects`, and `MsgWaitForMultipleObjectsEx`.</span></span>  <span data-ttu-id="607f6-297">NMPWAIT_WAIT_FOREVER kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-297">Do not use NMPWAIT_WAIT_FOREVER.</span></span>

### <a name="identify-any-sta-dependent-features"></a><span data-ttu-id="607f6-298">STA bağımlı tüm özellikleri tanımla</span><span class="sxs-lookup"><span data-stu-id="607f6-298">Identify any STA-Dependent features</span></span>

<span data-ttu-id="607f6-299">COM tek iş parçacıklı apartmanlar (STAs) kullanan herhangi bir kodu belirler.</span><span class="sxs-lookup"><span data-stu-id="607f6-299">Identify any code that uses COM single-threaded apartments (STAs).</span></span>  <span data-ttu-id="607f6-300">SQL Server işleminde STAs devre dışı bırakıldı.</span><span class="sxs-lookup"><span data-stu-id="607f6-300">STAs are disabled in the SQL Server process.</span></span>  <span data-ttu-id="607f6-301">`CoInitialize`Performans sayaçları veya pano gibi temel özellikler, SQL Server içinde devre dışı bırakılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-301">Features that depend on `CoInitialize`, such as performance counters or the clipboard, must be disabled within SQL Server.</span></span>

### <a name="ensure-finalizers-are-free-of-synchronization-problems"></a><span data-ttu-id="607f6-302">Sonlandırıcılar eşitleme sorunlarından muaf olduğundan emin olun</span><span class="sxs-lookup"><span data-stu-id="607f6-302">Ensure finalizers are free of synchronization problems</span></span>

<span data-ttu-id="607f6-303">.NET Framework sonraki sürümlerinde birden çok Sonlandırıcı iş parçacığı bulunabilir, yani aynı türdeki farklı örneklere yönelik sonlandırıcılar aynı anda çalışır.</span><span class="sxs-lookup"><span data-stu-id="607f6-303">Multiple finalizer threads might exist in future versions of the .NET Framework, meaning the finalizers for different instances of the same type run simultaneously.</span></span>  <span data-ttu-id="607f6-304">Tamamen iş parçacığı güvenli olması gerekmez; Çöp toplayıcı, belirli bir nesne örneği için sonlandırıcıyı yalnızca bir iş parçacığının çalıştıracaktır.</span><span class="sxs-lookup"><span data-stu-id="607f6-304">They do not have to be completely thread safe; the garbage collector guarantees that only one thread will run the finalizer for a given object instance.</span></span>  <span data-ttu-id="607f6-305">Ancak, birden çok farklı nesne örneğinde eşzamanlı olarak çalışırken yarış durumlarının ve kilitlenmeleri önlemek için Sonlandırıcıların kodlanmış olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="607f6-305">However, the finalizers must be coded to avoid race conditions and deadlocks when running simultaneously on multiple different object instances.</span></span>  <span data-ttu-id="607f6-306">Bir günlük dosyasına yazma gibi herhangi bir dış durumu kullanırken, bir sonlandırıcının iş parçacığı sorunları ele alınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-306">When using any external state, such as writing to a log file, in a finalizer, threading issues must be handled.</span></span>  <span data-ttu-id="607f6-307">İş parçacığı güvenliği sağlamak için sonlandırmada güvenmeyin.</span><span class="sxs-lookup"><span data-stu-id="607f6-307">Do not rely on finalization to provide thread safety.</span></span> <span data-ttu-id="607f6-308">Sonlandırıcı iş parçacığında durumu depolamak için iş parçacığı yerel depolama, yönetilen veya yerel olarak kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-308">Do not use thread local storage, managed or native, to store state on the finalizer thread.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-309">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-309">Code analysis rule</span></span>

<span data-ttu-id="607f6-310">Sonlandırıcılar, eşitleme sorunlarından muaf olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="607f6-310">Finalizers must be free of synchronization problems.</span></span> <span data-ttu-id="607f6-311">Sonlandırıcıda statik kesilebilir durum kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-311">Do not use a static mutable state in a finalizer.</span></span>

### <a name="avoid-unmanaged-memory-if-possible"></a><span data-ttu-id="607f6-312">Mümkünse yönetilmeyen belleği önleyin</span><span class="sxs-lookup"><span data-stu-id="607f6-312">Avoid unmanaged memory if possible</span></span>

<span data-ttu-id="607f6-313">Yönetilmeyen bellek, tıpkı bir işletim sistemi tutamacı gibi sızmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-313">Unmanaged memory can be leaked, just like an operating system handle.</span></span> <span data-ttu-id="607f6-314">Mümkünse, [stackalloc](../../csharp/language-reference/operators/stackalloc.md) [veya bir](../../csharp/language-reference/keywords/fixed-statement.md) <xref:System.Runtime.InteropServices.GCHandle> Byte [] kullanımı gibi sabitlenmiş bir yönetilen nesne kullanarak yığındaki belleği kullanmayı deneyin.</span><span class="sxs-lookup"><span data-stu-id="607f6-314">If possible, try to use memory on the stack using [stackalloc](../../csharp/language-reference/operators/stackalloc.md) or a pinned managed object such as the [fixed Statement](../../csharp/language-reference/keywords/fixed-statement.md) or a <xref:System.Runtime.InteropServices.GCHandle> using a byte[].</span></span> <span data-ttu-id="607f6-315"><xref:System.GC>Sonuç olarak bunları temizler.</span><span class="sxs-lookup"><span data-stu-id="607f6-315">The <xref:System.GC> eventually cleans these up.</span></span> <span data-ttu-id="607f6-316">Ancak, yönetilmeyen bellek ayırmanız gerekiyorsa, <xref:System.Runtime.InteropServices.SafeHandle> bellek ayırmayı kaydırmak için öğesinden türetilen bir sınıf kullanmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="607f6-316">However, if you must allocate unmanaged memory, consider using a class that derives from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the memory allocation.</span></span>

<span data-ttu-id="607f6-317">Yeterli olmayan en az bir büyük harf olduğunu unutmayın <xref:System.Runtime.InteropServices.SafeHandle> .</span><span class="sxs-lookup"><span data-stu-id="607f6-317">Note that there is at least one case where <xref:System.Runtime.InteropServices.SafeHandle> is not adequate.</span></span> <span data-ttu-id="607f6-318">Bellek ayıran veya boşaltan COM Yöntem çağrıları için, bir DLL 'nin bellek ayırması ve `CoTaskMemAlloc` Bu belleğin ile bir başka dll 'nin serbest olması yaygındır `CoTaskMemFree` .</span><span class="sxs-lookup"><span data-stu-id="607f6-318">For COM method calls that allocate or free memory, it is common for one DLL to allocate memory via `CoTaskMemAlloc` then another DLL frees that memory with `CoTaskMemFree`.</span></span>  <span data-ttu-id="607f6-319"><xref:System.Runtime.InteropServices.SafeHandle>Bu yerlerde kullanılması, yönetilmeyen belleğin yaşam süresini, <xref:System.Runtime.InteropServices.SafeHandle> diğer dll 'nin belleğin yaşam süresini sağlamak yerine, bu süre boyunca kullanım ömrüne bağlamak için uygun olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-319">Using <xref:System.Runtime.InteropServices.SafeHandle> in these places would be inappropriate since it will attempt to tie the lifetime of the unmanaged memory to the lifetime of the <xref:System.Runtime.InteropServices.SafeHandle> instead of allowing the other DLL control the lifetime of the memory.</span></span>

### <a name="review-all-uses-of-catchexception"></a><span data-ttu-id="607f6-320">Tüm catch (özel durum) kullanımlarını gözden geçirin</span><span class="sxs-lookup"><span data-stu-id="607f6-320">Review all uses of catch(Exception)</span></span>

<span data-ttu-id="607f6-321">Belirli bir özel durum yerine tüm özel durumları yakalayacak catch blokları artık zaman uyumsuz özel durumları da yakalar.</span><span class="sxs-lookup"><span data-stu-id="607f6-321">Catch blocks that catch all exceptions instead of one specific exception will now catch the asynchronous exceptions as well.</span></span> <span data-ttu-id="607f6-322">Her catch (özel durum) bloğunu inceleyerek, atlanan önemli bir kaynak bırakma veya geri alma kodu yoksa, ya da bir, veya işlemek için de catch bloğunun kendisi içinde hatalı davranış olup olmadığını araştırın <xref:System.Threading.ThreadAbortException> <xref:System.StackOverflowException> <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="607f6-322">Examine every catch(Exception) block, looking for no important resource releasing or backout code that might be skipped, as well as potentially incorrect behavior within the catch block itself for handling a <xref:System.Threading.ThreadAbortException>, <xref:System.StackOverflowException>, or <xref:System.OutOfMemoryException>.</span></span>  <span data-ttu-id="607f6-323">Bu kodun günlüğe kaydedilmesine veya yalnızca belirli özel durumları görebileceğine veya bir özel durumun tam olarak tek bir nedenden dolayı başarısız olduğu varsayımda olabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-323">Note that it is possible this code might be logging or making some assumptions that it may only see certain exceptions, or that whenever an exception happens it failed for exactly one particular reason.</span></span>  <span data-ttu-id="607f6-324">Bu varsayımlar dahil etmek için güncelleştirilmeleri gerekebilir <xref:System.Threading.ThreadAbortException> .</span><span class="sxs-lookup"><span data-stu-id="607f6-324">These assumptions may need to be updated to include <xref:System.Threading.ThreadAbortException>.</span></span>

<span data-ttu-id="607f6-325">Bir dizi biçimlendirme yöntemi gibi, sizin belirttiğiniz özel durum türünü yakalamak için tüm özel durumları yakalayan tüm yerleri değiştirmeyi göz önünde bulundurun <xref:System.FormatException> .</span><span class="sxs-lookup"><span data-stu-id="607f6-325">Consider changing all places that catch all exceptions to catching a specific type of exception that you expect will be thrown, such as a <xref:System.FormatException> from string formatting methods.</span></span>  <span data-ttu-id="607f6-326">Bu, catch bloğunun beklenmeyen özel durumlar üzerinde çalışmasını önler ve kodun beklenmeyen özel durumları yakalayarak hataları gizlemez olmasını sağlamaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-326">This prevents the catch block from running on unexpected exceptions and will help ensure the code does not hide bugs by catching unexpected exceptions.</span></span>  <span data-ttu-id="607f6-327">Genel bir kural olarak kitaplık kodunda bir özel durumu işlemez (bir özel durum yakalamanızı gerektiren kod, aradığınız kodda bir tasarım kusurunu belirtebilir).</span><span class="sxs-lookup"><span data-stu-id="607f6-327">As a general rule never handle an exception in library code (code that requires you to catch an exception may indicate a design flaw in the code you are calling).</span></span>  <span data-ttu-id="607f6-328">Bazı durumlarda, bir özel durumu yakalamak ve daha fazla veri sağlamak için farklı bir özel durum türü oluşturmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="607f6-328">In some cases you may want to catch an exception and throw a different exception type to provide more data.</span></span>  <span data-ttu-id="607f6-329">Bu durumda iç içe geçmiş özel durumları kullanın ve hatanın gerçek nedenini <xref:System.Exception.InnerException%2A> Yeni özel durumun özelliğinde depolayarak.</span><span class="sxs-lookup"><span data-stu-id="607f6-329">Use nested exceptions in this case, storing the real cause of the failure in the <xref:System.Exception.InnerException%2A> property of the new exception.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-330">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-330">Code analysis rule</span></span>

<span data-ttu-id="607f6-331">Tüm nesneleri yakalar veya tüm özel durumları yakalayacak Yönetilen koddaki tüm catch bloklarını gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="607f6-331">Review all catch blocks in managed code that catch all objects or catch all exceptions.</span></span>  <span data-ttu-id="607f6-332">C# dilinde, bu hem hem de olarak bayrak anlamına gelir `catch` {} `catch(Exception)` {} .</span><span class="sxs-lookup"><span data-stu-id="607f6-332">In C#, this means flagging both `catch` {} and `catch(Exception)` {}.</span></span>  <span data-ttu-id="607f6-333">Özel durum türünü çok özel yapmayı düşünün veya beklenmeyen bir özel durum türünü yakaladığı için hatalı bir şekilde hareket etmemesini sağlamak üzere kodu gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="607f6-333">Consider making the exception type very specific, or review the code to ensure it does not act in a bad way if it catches an unexpected exception type.</span></span>

### <a name="do-not-assume-a-managed-thread-is-a-win32-thread--it-is-a-fiber"></a><span data-ttu-id="607f6-334">Yönetilen bir iş parçacığının bir Win32 iş parçacığı olduğunu varsaymayın; bu bir fiber</span><span class="sxs-lookup"><span data-stu-id="607f6-334">Do not assume a managed thread is a Win32 thread – It is a Fiber</span></span>

<span data-ttu-id="607f6-335">Yönetilen iş parçacığı yerel depolama kullanmak çalışır, ancak yönetilmeyen iş parçacığı yerel depolama birimini veya kodun geçerli işletim sistemi iş parçacığında yeniden çalışacağını varsayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="607f6-335">Using managed thread local storage does work, but you may not use unmanaged thread local storage or assume the code will run on the current operating system thread again.</span></span> <span data-ttu-id="607f6-336">İş parçacığının yerel ayarı gibi ayarları değiştirmeyin.</span><span class="sxs-lookup"><span data-stu-id="607f6-336">Do not change settings like the thread’s locale.</span></span> <span data-ttu-id="607f6-337">`InitializeCriticalSection` `CreateMutex` Bir kilit giren işletim sistemi iş parçacığını gerektirdiğinden ya da kilitden çıkmak için platform Invoke 'ı çağırmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-337">Do not call `InitializeCriticalSection` or `CreateMutex` via platform invoke because they require the operating system thread that enters a lock also exit the lock.</span></span> <span data-ttu-id="607f6-338">Fibers kullanılırken bu durum olmadığı için, Win32 kritik bölümleri ve zaman uyumu sağlayıcılar doğrudan SQL 'de kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="607f6-338">Since this will not be the case when using fibers, Win32 critical sections and mutexes cannot be used in SQL directly.</span></span>  <span data-ttu-id="607f6-339">Yönetilen <xref:System.Threading.Mutex> sınıfın bu iş parçacığı benzeşim sorunlarını işlemediğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-339">Note that the managed <xref:System.Threading.Mutex> class does not handle these thread affinity concerns.</span></span>

<span data-ttu-id="607f6-340"><xref:System.Threading.Thread>Yönetilen iş parçacığı yerel depolama alanı ve iş parçacığının geçerli kullanıcı arabirimi kültürü dahil olmak üzere, yönetilen bir nesne üzerinde durumun büyük bir bölümünü güvenle kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="607f6-340">You can safely use most of the state on a managed <xref:System.Threading.Thread> object, including managed thread local storage and the thread’s current UI culture.</span></span> <span data-ttu-id="607f6-341">Ayrıca, <xref:System.ThreadStaticAttribute> mevcut bir statik değişkenin değerini yalnızca geçerli yönetilen iş parçacığı (clr 'de fiber yerel depolama yapmanın başka bir yolu) ile erişilebilir hale getiren öğesini de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="607f6-341">You can also use the <xref:System.ThreadStaticAttribute>, which makes the value of an existing static variable accessible only by the current managed thread (this is another way of doing fiber local storage in the CLR).</span></span> <span data-ttu-id="607f6-342">Programlama modeli nedenleriyle, SQL 'de çalışırken bir iş parçacığının geçerli kültürünü değiştiremezsiniz.</span><span class="sxs-lookup"><span data-stu-id="607f6-342">For programming model reasons, you can not change the current culture of a thread when running in SQL.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-343">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-343">Code analysis rule</span></span>

<span data-ttu-id="607f6-344">SQL Server, fiber modda çalışır; iş parçacığı yerel depolama kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="607f6-344">SQL Server runs in fiber mode; do not use thread local storage.</span></span> <span data-ttu-id="607f6-345">,, Ve için platform çağırma çağrıları kullanmaktan kaçının `TlsAlloc` `TlsFree` `TlsGetValue``TlsSetValue.`</span><span class="sxs-lookup"><span data-stu-id="607f6-345">Avoid platform invoke calls to `TlsAlloc`, `TlsFree`, `TlsGetValue`, and `TlsSetValue.`</span></span>

### <a name="let-sql-server-handle-impersonation"></a><span data-ttu-id="607f6-346">SQL Server tanıtıcı kimliğe bürünmeye izin ver</span><span class="sxs-lookup"><span data-stu-id="607f6-346">Let SQL Server handle impersonation</span></span>

<span data-ttu-id="607f6-347">Kimliğe bürünme iş parçacığı düzeyinde çalışır ve SQL fiber modda çalışabilir, yönetilen kod kullanıcıları taklit etmez ve çağırmamalıdır `RevertToSelf` .</span><span class="sxs-lookup"><span data-stu-id="607f6-347">Since impersonation operates on the thread level and SQL can run in fiber mode, managed code should not impersonate users, and should not call `RevertToSelf`.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-348">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-348">Code analysis rule</span></span>

<span data-ttu-id="607f6-349">SQL Server tanıtıcı kimliğe bürünmeye izin verin.</span><span class="sxs-lookup"><span data-stu-id="607f6-349">Let SQL Server handle impersonation.</span></span> <span data-ttu-id="607f6-350">,,,,, `RevertToSelf` `ImpersonateAnonymousToken` `DdeImpersonateClient` `ImpersonateDdeClientWindow` `ImpersonateLoggedOnUser` `ImpersonateNamedPipeClient` , `ImpersonateSelf` , `RpcImpersonateClient` , `RpcRevertToSelf` , `RpcRevertToSelfEx` , Veya kullanmayın `SetThreadToken` .</span><span class="sxs-lookup"><span data-stu-id="607f6-350">Do not use `RevertToSelf`, `ImpersonateAnonymousToken`, `DdeImpersonateClient`, `ImpersonateDdeClientWindow`, `ImpersonateLoggedOnUser`, `ImpersonateNamedPipeClient`, `ImpersonateSelf`, `RpcImpersonateClient`, `RpcRevertToSelf`, `RpcRevertToSelfEx`, or `SetThreadToken`.</span></span>

### <a name="do-not-call-threadsuspend"></a><span data-ttu-id="607f6-351">Thread:: Suspend çağrısını çağırma</span><span class="sxs-lookup"><span data-stu-id="607f6-351">Do not call Thread::Suspend</span></span>

<span data-ttu-id="607f6-352">Bir iş parçacığını askıya alma özelliği basit bir işlem görünebilir, ancak kilitlenmeleri neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="607f6-352">The ability to suspend a thread may appear a simple operation, but it can cause deadlocks.</span></span>  <span data-ttu-id="607f6-353">Kilit tutan bir iş parçacığı ikinci bir iş parçacığı tarafından askıya alınırsa ve ikinci iş parçacığı aynı kilidi gerçekleştirmeye çalışırsa, bir kilitlenme oluşur.</span><span class="sxs-lookup"><span data-stu-id="607f6-353">If a thread holding a lock gets suspended by a second thread and then the second thread tries taking the same lock, a deadlock occurs.</span></span>  <span data-ttu-id="607f6-354"><xref:System.Threading.Thread.Suspend%2A>Güvenlik, sınıf yükleme, uzaktan iletişim ve yansıma Şu anda kesintiye uğratabilirler.</span><span class="sxs-lookup"><span data-stu-id="607f6-354"><xref:System.Threading.Thread.Suspend%2A> can interfere with security, class loading, remoting, and reflection currently.</span></span>

#### <a name="code-analysis-rule"></a><span data-ttu-id="607f6-355">Kod Analizi kuralı</span><span class="sxs-lookup"><span data-stu-id="607f6-355">Code analysis rule</span></span>

<span data-ttu-id="607f6-356">' İ çağırmayın <xref:System.Threading.Thread.Suspend%2A> .</span><span class="sxs-lookup"><span data-stu-id="607f6-356">Do not call <xref:System.Threading.Thread.Suspend%2A>.</span></span> <span data-ttu-id="607f6-357">Veya gibi gerçek bir eşitleme temel kullanmayı düşünün <xref:System.Threading.Semaphore> <xref:System.Threading.ManualResetEvent> .</span><span class="sxs-lookup"><span data-stu-id="607f6-357">Consider using a real synchronization primitive instead, such as a <xref:System.Threading.Semaphore> or <xref:System.Threading.ManualResetEvent> .</span></span>

### <a name="protect-critical-operations-with-constrained-execution-regions-and-reliability-contracts"></a><span data-ttu-id="607f6-358">Kısıtlı yürütme bölgeleri ve güvenilirlik sözleşmeleri ile kritik işlemleri koruma</span><span class="sxs-lookup"><span data-stu-id="607f6-358">Protect critical operations with constrained execution regions and reliability contracts</span></span>

<span data-ttu-id="607f6-359">Paylaşılan bir durumu güncelleştiren veya tamamen başarılı ya da tamamen başarısız olması gereken karmaşık bir işlem gerçekleştirirken, kısıtlı bir yürütme bölgesi (CER) tarafından korunduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="607f6-359">When performing a complex operation that updates a shared status or that needs to deterministically either fully succeed or fully fail, be sure that it is protected by a constrained execution region (CER).</span></span> <span data-ttu-id="607f6-360">Bu, kodun her durumda, ani bir iş parçacığı iptali veya ani kaldırmaların kaldırılması durumunda çalışmasını güvence altına alır <xref:System.AppDomain> .</span><span class="sxs-lookup"><span data-stu-id="607f6-360">This guarantees that the code runs in every case, even an abrupt thread abort or an abrupt <xref:System.AppDomain> unload.</span></span>

<span data-ttu-id="607f6-361">Bir CER, bir `try/finally` çağrısıyla hemen önce gelen belirli bir bloğudur <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> .</span><span class="sxs-lookup"><span data-stu-id="607f6-361">A CER is a particular `try/finally` block immediately preceded by a call to <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A>.</span></span>

<span data-ttu-id="607f6-362">Bunu yapmak, tam zamanında derleyiciye bloğunu çalıştırmadan önce finally bloğundaki tüm kodu hazırlamasını söyler `try` .</span><span class="sxs-lookup"><span data-stu-id="607f6-362">Doing so instructs the just-in-time compiler to prepare all the code in the finally block before running the `try` block.</span></span> <span data-ttu-id="607f6-363">Bu, finally bloğundaki kodun oluşturuldığına ve her durumda çalışacak şekilde emin olur.</span><span class="sxs-lookup"><span data-stu-id="607f6-363">This guarantees that the code in the finally block is built and will run in all cases.</span></span> <span data-ttu-id="607f6-364">Bir CER 'de boş bir bloğa sahip olmayan bir çok seyrek değildir `try` .</span><span class="sxs-lookup"><span data-stu-id="607f6-364">It is not uncommon in a CER to have an empty `try` block.</span></span> <span data-ttu-id="607f6-365">Bir CER kullanılması zaman uyumsuz iş parçacığı iptal ve bellek dışı özel durumlara karşı koruma sağlar.</span><span class="sxs-lookup"><span data-stu-id="607f6-365">Using a CER protects against asynchronous thread aborts and out-of-memory exceptions.</span></span> <span data-ttu-id="607f6-366"><xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>Ayrıca, daha fazla derin kod için yığın taşlarının de işlediği BIR cer formu için bkz..</span><span class="sxs-lookup"><span data-stu-id="607f6-366">See <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> for a form of a CER that additionally handles stack overflows for exceedingly deep code.</span></span>

## <a name="see-also"></a><span data-ttu-id="607f6-367">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="607f6-367">See also</span></span>

- <xref:System.Runtime.ConstrainedExecution>
- [<span data-ttu-id="607f6-368">SQL Server Programlama ve Ana Bilgisayar Koruması Öznitelikleri</span><span class="sxs-lookup"><span data-stu-id="607f6-368">SQL Server Programming and Host Protection Attributes</span></span>](sql-server-programming-and-host-protection-attributes.md)
