---
title: SQL Server'da Anlık Görüntü Yalıtımı
description: SQL Server ' de anlık görüntü yalıtımı ve satır sürümü oluşturma hakkında bir genel bakış okuyun ve yalıtım düzeyleriyle eşzamanlılık yönetimi hakkında bilgi edinin.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 4934c031eb9dfb26d60c5233937cbc65ca60d4f7
ms.sourcegitcommit: 5b475c1855b32cf78d2d1bbb4295e4c236f39464
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/24/2020
ms.locfileid: "91183084"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="e7abf-103">SQL Server'da Anlık Görüntü Yalıtımı</span><span class="sxs-lookup"><span data-stu-id="e7abf-103">Snapshot Isolation in SQL Server</span></span>

<span data-ttu-id="e7abf-104">Anlık görüntü yalıtımı OLTP uygulamaları için eşzamanlılık geliştirir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-104">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="e7abf-105">Anlık görüntü yalıtımını ve satır sürüm oluşturmayı anlama</span><span class="sxs-lookup"><span data-stu-id="e7abf-105">Understanding Snapshot Isolation and Row Versioning</span></span>  

 <span data-ttu-id="e7abf-106">Anlık görüntü yalıtımı etkinleştirildikten sonra, her bir işlem için güncelleştirilmiş satır sürümlerinin tutulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-106">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="e7abf-107">SQL Server 2019 ' dan önce bu sürümler **tempdb**'de depolandı.</span><span class="sxs-lookup"><span data-stu-id="e7abf-107">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="e7abf-108">SQL Server 2019, kendi satır sürümleri kümesini gerektiren hızlandırılmış veritabanı kurtarma (ADR) özelliğine sahip yeni bir özellik sunar.</span><span class="sxs-lookup"><span data-stu-id="e7abf-108">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="e7abf-109">Bu nedenle, SQL Server 2019 itibariyle, ADR etkinleştirilmemişse, satır sürümleri **tempdb** 'de her zaman olarak tutulur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-109">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="e7abf-110">ADR etkinse, hem anlık görüntü yalıtımı hem de ADR ile ilgili tüm satır sürümleri, kullanıcının belirttiği bir dosya grubunda bulunan Kullanıcı veritabanında bulunan ADR 'nin kalıcı sürüm deposunda (PVS) tutulur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-110">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="e7abf-111">Benzersiz bir işlem sıra numarası her bir işlemi tanımlar ve bu benzersiz numaralar her bir satır sürümü için kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-111">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="e7abf-112">İşlem, işlemin sıra numarasından önce sıra numarası olan en son satır sürümleriyle birlikte kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-112">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="e7abf-113">İşlem başladıktan sonra oluşturulan daha yeni satır sürümleri işlem tarafından yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-113">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="e7abf-114">"Snapshot" terimi, işlemdeki tüm sorguların, işlem başladığında veritabanının durumuna bağlı olarak veritabanının aynı sürümünü veya anlık görüntüsünü görmesinin gerçeğini yansıtır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-114">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="e7abf-115">Bir anlık görüntü işleminde temel alınan veri satırlarında veya veri sayfalarında hiçbir kilit alınmadı. Bu, diğer işlemlerin önceki bir tamamlanmamış işlem tarafından engellenmeden yürütülmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-115">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="e7abf-116">Verileri değiştiren işlemler, verileri okuyan işlemleri engellemez ve verileri okuyan işlemler, normalde SQL Server ' de varsayılan okuma olarak KAYDEDILMIŞ yalıtım düzeyi altında olacak şekilde veri yazan işlemleri engellemez.</span><span class="sxs-lookup"><span data-stu-id="e7abf-116">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="e7abf-117">Bu engelleyici olmayan davranış, karmaşık işlemler için kilitlenmeleri olasılığını önemli ölçüde azaltır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-117">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="e7abf-118">Anlık görüntü yalıtımı bir iyimser eşzamanlılık modeli kullanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-118">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="e7abf-119">Anlık görüntü işlemi, işlem başlangıcından bu yana değiştirilen verilerde yapılan değişiklikleri kaydetmeye çalışırsa, işlem geri alınacaktır ve bir hata oluşur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-119">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="e7abf-120">Bu, değiştirilecek verilere erişen SELECT deyimleri için UPDLOCK ipuçlarını kullanarak bunu önleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e7abf-120">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="e7abf-121">Daha fazla bilgi için SQL Server Books Online 'da "kilitleme Ipuçları" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="e7abf-121">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="e7abf-122">İşlem sırasında kullanılmadan önce veritabanı seçeneği ALLOW_SNAPSHOT_ISOLATION ayarlanarak anlık görüntü yalıtımının etkinleştirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-122">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="e7abf-123">Bu, satır sürümlerini geçici veritabanında (**tempdb**) depolamaya yönelik mekanizmayı etkinleştirir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-123">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="e7abf-124">Transact-SQL ALTER DATABASE ifadesiyle kullanan her veritabanında anlık görüntü yalıtımını etkinleştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-124">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="e7abf-125">Bu şekilde, anlık görüntü yalıtımı, hiçbir yapılandırma gerektirmeyen READ COMMITTED, YINELENEBILIR READ, SERIALIZABLE ve READ UNCOMMıTTED olan geleneksel yalıtım düzeylerinden farklıdır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-125">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="e7abf-126">Aşağıdaki deyimler anlık görüntü yalıtımını etkinleştirir ve varsayılan okuma KAYDEDILMIŞ davranışını anlık GÖRÜNTÜYLE değiştirir:</span><span class="sxs-lookup"><span data-stu-id="e7abf-126">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="e7abf-127">READ_COMMITTED_SNAPSHOT ON seçeneğinin ayarlanması, varsayılan olarak KAYDEDILMIŞ yalıtım düzeyi altında sürümlü satırlara erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="e7abf-127">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="e7abf-128">READ_COMMITTED_SNAPSHOT seçeneği kapalı olarak ayarlanırsa, sürümlü satırlara erişebilmek için her oturum için anlık görüntü yalıtımı düzeyini açıkça ayarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-128">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="e7abf-129">Yalıtım düzeyleriyle eşzamanlılık yönetimi</span><span class="sxs-lookup"><span data-stu-id="e7abf-129">Managing Concurrency with Isolation Levels</span></span>  

 <span data-ttu-id="e7abf-130">Bir Transact-SQL ifadesinin çalıştırıldığı yalıtım düzeyi, kilitleme ve satır sürümü oluşturma davranışını belirler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-130">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="e7abf-131">Yalıtım düzeyi, bağlantı genelinde kapsama sahiptir ve Işlem yalıtım DÜZEYI ayarla ifadesiyle bir bağlantı için ayarlandıktan sonra bağlantı kapatılana veya başka bir yalıtım düzeyi ayarlanana kadar etkin kalır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-131">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="e7abf-132">Bir bağlantı kapatılıp havuza döndürüldüğünde, son ayarlanan Işlem yalıtım DÜZEYI deyimindeki yalıtım düzeyi korunur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-132">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="e7abf-133">Havuza alınmış bir bağlantıyı yeniden kullanan sonraki bağlantılar, bağlantı havuza alındığı sırada geçerli olan yalıtım düzeyini kullanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-133">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="e7abf-134">Bir bağlantı içinde verilen tekil sorgular, tek bir deyimin veya işlemin yalıtımını değiştiren ancak bağlantının yalıtım düzeyini etkilemeyen kilit ipuçları içerebilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-134">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="e7abf-135">Saklı yordamlarda veya işlevlerde ayarlanan yalıtım düzeyleri veya kilit ipuçları, bunları çağıran bağlantının yalıtım düzeyini değiştirmez ve yalnızca saklı yordamın veya işlev çağrısının süresi boyunca geçerli olur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-135">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="e7abf-136">SQL Server önceki sürümlerinde SQL-92 standardında tanımlanan dört yalıtım düzeyi desteklenmekteydi:</span><span class="sxs-lookup"><span data-stu-id="e7abf-136">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="e7abf-137">Diğer işlemler tarafından verilen kilitleri yoksaydığından, READ UNCOMMıTTED, en az kısıtlayıcı yalıtım düzeyidir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-137">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="e7abf-138">READ UNCOMMıTTED altında yürütülen işlemler, başka işlemler tarafından henüz kaydedilmemiş olan değiştirilmiş veri değerlerini okuyabilir; Bunlar "kirli" okumalar olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-138">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="e7abf-139">OKUMA IŞLENDI, SQL Server için varsayılan yalıtım düzeyidir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-139">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="e7abf-140">Bu ifadeler, değiştirilmiş ancak başka işlemler tarafından henüz kaydedilmemiş olan veri değerlerini okuyamayacağını belirterek kirli okumaları önler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-140">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="e7abf-141">Diğer işlemler, geçerli işlem içindeki tek tek deyimlerin yürütmeleri arasında verileri değiştirebilir, ekleyebilir veya silebilir, bu da yinelenmemiş okuma veya "hayalet" verileri elde eder.</span><span class="sxs-lookup"><span data-stu-id="e7abf-141">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="e7abf-142">YINELENEBILIR okuma, okuma IŞLENDI öğesinden daha kısıtlayıcı bir yalıtım düzeyidir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-142">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="e7abf-143">Bu, okumayı taahhüt eder ve ayrıca, geçerli işlem tamamlanana kadar geçerli işlem tarafından okunan verileri başka hiçbir işlem tarafından değişiklik veya silme işlemini belirtir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-143">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="e7abf-144">Okuma verilerinde paylaşılan kilitler, her deyimin sonunda yayınlanmak yerine işlem süresince tutulduğundan eşzamanlılık, okuma için daha düşüktür.</span><span class="sxs-lookup"><span data-stu-id="e7abf-144">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="e7abf-145">SERI hale GETIRILEBILIR, tüm anahtar aralıklarını kilitlediği ve işlem tamamlanana kadar kilitleri tutan için en kısıtlayıcı yalıtım düzeyidir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-145">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="e7abf-146">YINELENEBILIR okumayı kapsar ve diğer işlemlerin işlem tamamlanana kadar işlem tarafından okunan aralıklara yeni satırlar Ekleyememe kısıtlaması ekler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-146">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="e7abf-147">Daha fazla bilgi için, [Işlem kilitleme ve satır sürümü oluşturma kılavuzuna](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)bakın.</span><span class="sxs-lookup"><span data-stu-id="e7abf-147">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="e7abf-148">Anlık görüntü yalıtım düzeyi uzantıları</span><span class="sxs-lookup"><span data-stu-id="e7abf-148">Snapshot Isolation Level Extensions</span></span>  

 <span data-ttu-id="e7abf-149">SQL Server, SQL-92 yalıtım düzeylerine, anlık görüntü yalıtım düzeyi ve daha fazla READ COMMıTTED bir uygulama ile sunulan uzantıları sunmuştur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-149">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="e7abf-150">READ_COMMITTED_SNAPSHOT yalıtım düzeyi, tüm işlemler için OKUNABILIR olarak IŞLENMIŞ şekilde değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-150">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="e7abf-151">ANLıK görüntü yalıtımı, bir işlem içinde okunan verilerin diğer eşzamanlı işlemler tarafından yapılan değişiklikleri hiçbir şekilde yansıtmayacağını belirtir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-151">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="e7abf-152">İşlem başladığında mevcut olan veri satırı sürümlerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-152">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="e7abf-153">Okuma sırasında verileri hiçbir kilit yerleştirmez, bu nedenle anlık görüntü işlemleri diğer işlemlerin veri yazmasını engellemez.</span><span class="sxs-lookup"><span data-stu-id="e7abf-153">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="e7abf-154">Veri yazan işlemler, anlık görüntü işlemlerini veri okumaktan engellemez.</span><span class="sxs-lookup"><span data-stu-id="e7abf-154">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="e7abf-155">ALLOW_SNAPSHOT_ISOLATION veritabanı seçeneğini kullanmak için ayarlayarak anlık görüntü yalıtımını etkinleştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-155">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="e7abf-156">READ_COMMITTED_SNAPSHOT veritabanı seçeneği, anlık görüntü yalıtımı bir veritabanında etkinleştirildiğinde varsayılan okuma tarafından KAYDEDILMIŞ yalıtım düzeyinin davranışını belirler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-156">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="e7abf-157">Açık olarak READ_COMMITTED_SNAPSHOT açık bir şekilde belirtmezseniz, tüm örtük işlemlere okuma işlemi uygulanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-157">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="e7abf-158">Bu, READ_COMMITTED_SNAPSHOT OFF (varsayılan) ayarıyla aynı davranışı üretir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-158">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="e7abf-159">READ_COMMITTED_SNAPSHOT OFF etkin olduğunda, veritabanı altyapısı varsayılan yalıtım düzeyini zorlamak için paylaşılan kilitler kullanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-159">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="e7abf-160">READ_COMMITTED_SNAPSHOT veritabanı seçeneğini açık olarak ayarlarsanız, veritabanı altyapısı, verileri korumak için kilitler kullanmak yerine varsayılan olarak satır sürümü oluşturma ve anlık görüntü yalıtımı kullanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-160">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="e7abf-161">Anlık görüntü yalıtımı ve satır sürümü oluşturma nasıl çalışır?</span><span class="sxs-lookup"><span data-stu-id="e7abf-161">How Snapshot Isolation and Row Versioning Work</span></span>  

 <span data-ttu-id="e7abf-162">ANLıK görüntü yalıtım düzeyi etkinleştirildiğinde, bir satır her güncelleştirildiği zaman, SQL Server veritabanı altyapısı **tempdb**'de orijinal satırın bir kopyasını depolar ve satıra bir işlem sıra numarası ekler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-162">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="e7abf-163">Oluşan olayların sırası aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="e7abf-163">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="e7abf-164">Yeni bir işlem başlatılır ve bir işlem sıra numarası atanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-164">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="e7abf-165">Veritabanı altyapısı, işlem içindeki bir satırı okur ve sıra numarası en yakın, işlem sırası numarasından daha düşük olan **tempdb** 'den satır sürümünü alır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-165">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="e7abf-166">Veritabanı altyapısı, işlem sırası numarasının, anlık görüntü işlemi başlatıldığında etkin olan kaydedilmemiş işlemlerin işlem sırası numaraları listesinde olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-166">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="e7abf-167">İşlem, işlemin başlangıcı itibariyle geçerli olan **tempdb** 'den satır sürümünü okur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-167">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="e7abf-168">İşlem başlatıldıktan sonra yeni satırları, bu sıra numarası değerleri işlem sırası numarası değerinden yüksek olacak şekilde görmez.</span><span class="sxs-lookup"><span data-stu-id="e7abf-168">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="e7abf-169">Geçerli işlem, **tempdb** 'de daha düşük bir sıra numarası değeri olan bir satır sürümü olacağı için, işlem başladıktan sonra silinen satırları görür.</span><span class="sxs-lookup"><span data-stu-id="e7abf-169">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="e7abf-170">Anlık görüntü yalıtımının net etkisi, işlemin başlangıcında olduğu gibi, temel alınan tablolara herhangi bir kilit oluşturmadan veya yerleştirmeksizin tüm verileri görür.</span><span class="sxs-lookup"><span data-stu-id="e7abf-170">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="e7abf-171">Bu durum, çekişme durumunda performans iyileştirmelerine yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-171">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="e7abf-172">Anlık görüntü işlemi her zaman iyimser eşzamanlılık denetimini kullanır ve diğer işlemlerin satırları güncelleştirmesini engelleyecek herhangi bir kilidi stopajın.</span><span class="sxs-lookup"><span data-stu-id="e7abf-172">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="e7abf-173">Anlık görüntü işlemi, işlem başladıktan sonra değiştirilen bir satıra bir güncelleştirmeyi kaydetmeye çalışırsa, işlem geri alınır ve bir hata oluşur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-173">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="e7abf-174">ADO.NET içinde anlık görüntü yalıtımıyla çalışma</span><span class="sxs-lookup"><span data-stu-id="e7abf-174">Working with Snapshot Isolation in ADO.NET</span></span>  

 <span data-ttu-id="e7abf-175">Anlık görüntü yalıtımı, ADO.NET tarafından sınıfı tarafından desteklenir <xref:System.Data.SqlClient.SqlTransaction> .</span><span class="sxs-lookup"><span data-stu-id="e7abf-175">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="e7abf-176">Bir veritabanı, anlık görüntü yalıtımı için etkinleştirildiyse, ancak ÜZERINDE READ_COMMITTED_SNAPSHOT için yapılandırılmamışsa, <xref:System.Data.SqlClient.SqlTransaction> yöntemi çağırırken **IsolationLevel. Snapshot** numaralandırma değerini kullanarak bir ' u başlatmanız gerekir <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> .</span><span class="sxs-lookup"><span data-stu-id="e7abf-176">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="e7abf-177">Bu kod parçası, bağlantının açık bir nesne olduğunu varsayar <xref:System.Data.SqlClient.SqlConnection> .</span><span class="sxs-lookup"><span data-stu-id="e7abf-177">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="e7abf-178">Örnek</span><span class="sxs-lookup"><span data-stu-id="e7abf-178">Example</span></span>  

 <span data-ttu-id="e7abf-179">Aşağıdaki örnek, kilitli verilere erişmeye çalışan farklı yalıtım düzeylerinin nasıl davrandığını gösterir ve üretim kodunda kullanılmak üzere tasarlanmamıştır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-179">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="e7abf-180">Kod, SQL Server **AdventureWorks** örnek veritabanına bağlanır ve **TestSnapshot** adlı bir tablo oluşturur ve bir veri satırı ekler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-180">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="e7abf-181">Kod ALTER DATABASE Transact-SQL deyimini kullanarak veritabanı için anlık görüntü yalıtımını açabilir, ancak READ_COMMITTED_SNAPSHOT seçeneğini ayarlayıp varsayılan olarak KAYDEDILMIŞ yalıtım düzeyi davranışını etkin halde bırakır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-181">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="e7abf-182">Kod daha sonra aşağıdaki eylemleri gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="e7abf-182">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="e7abf-183">Bir güncelleştirme işlemini başlatmak için, SERI hale GETIRILEBILIR yalıtım düzeyini kullanan, ancak tamamlanmayan, sqlTransaction1.</span><span class="sxs-lookup"><span data-stu-id="e7abf-183">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="e7abf-184">Bu, tabloyu kilitleme etkisine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-184">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="e7abf-185">İkinci bir bağlantı açar ve **TestSnapshot** tablosu içindeki verileri okumak IÇIN anlık görüntü yalıtımı düzeyini kullanarak ikinci bir işlem başlatır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-185">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="e7abf-186">Anlık görüntü yalıtımı etkinleştirildiğinden, bu işlem sqlTransaction1 başlamadan önce var olan verileri okuyabilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-186">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="e7abf-187">Üçüncü bir bağlantı açar ve tablodaki verileri okumayı denemek için READ COMMıTTED yalıtım düzeyini kullanarak bir işlem başlatır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-187">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="e7abf-188">Bu durumda, kod ilk işlem içindeki tabloya yerleştirilmiş kilitleri okuyamadığından ve zaman aşımına uğradığından verileri okuyamıyor. Aynı sonuç, YINELENEBILIR okuma ve SERI hale GETIRILEBILIR yalıtım düzeyleri kullanılmışsa meydana gelir çünkü bu yalıtım düzeyleri ilk işleme yerleştirilmiş kilitleri daha fazla okuyamaz.</span><span class="sxs-lookup"><span data-stu-id="e7abf-188">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="e7abf-189">Dördüncü bir bağlantı açar ve sqlTransaction1 içinde işlenmemiş değerin kirli okunduğunu gerçekleştiren READ UNCOMMıTTED yalıtım düzeyini kullanarak bir işlem başlatır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-189">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="e7abf-190">İlk işlem yürütülmüyorsa, bu değer veritabanında hiçbir şekilde yok olabilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-190">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="e7abf-191">İlk işlemi geri alır ve **TestSnapshot** tablosunu silerek ve **AdventureWorks** veritabanı için anlık görüntü yalıtımını kapatarak temizler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-191">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="e7abf-192">Aşağıdaki örnekler, bağlantı havuzu kapalıyken aynı bağlantı dizesini kullanır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-192">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="e7abf-193">Bir bağlantı havuza alınmış ise, yalıtım düzeyini sıfırlamak sunucudaki yalıtım düzeyini sıfırlamaz.</span><span class="sxs-lookup"><span data-stu-id="e7abf-193">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="e7abf-194">Sonuç olarak, aynı havuza alınmış iç bağlantıyı kullanan sonraki bağlantılar, havuza alınmış bağlantının kendilerine ayarlanan yalıtım düzeyleriyle başlar.</span><span class="sxs-lookup"><span data-stu-id="e7abf-194">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="e7abf-195">Bağlantı havuzunu kapatmak için bir alternatif, yalıtım düzeyini her bağlantı için açıkça ayarlamaya yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-195">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="e7abf-196">Örnek</span><span class="sxs-lookup"><span data-stu-id="e7abf-196">Example</span></span>  

 <span data-ttu-id="e7abf-197">Aşağıdaki örnek, veri değiştirilirken anlık görüntü yalıtımının davranışını gösterir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-197">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="e7abf-198">Kod aşağıdaki eylemleri gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="e7abf-198">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="e7abf-199">**AdventureWorks** örnek veritabanına BAĞLANıR ve anlık görüntü yalıtımına olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="e7abf-199">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="e7abf-200">**TestSnapshotUpdate** adlı bir tablo oluşturur ve üç satır örnek veri ekler.</span><span class="sxs-lookup"><span data-stu-id="e7abf-200">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="e7abf-201">ANLıK görüntü yalıtımı kullanarak sqlTransaction1 başlar ancak tamamlanmaz.</span><span class="sxs-lookup"><span data-stu-id="e7abf-201">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="e7abf-202">İşlemde üç satır veri seçilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-202">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="e7abf-203">**AdventureWorks** 'e Ikinci bir **SqlConnection** oluşturur ve sqlTransaction1 içinde seçilen satırlardan BIRINDEKI BIR değeri güncelleştiren Read commıtted yalıtım düzeyini kullanarak ikinci bir işlem oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-203">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="e7abf-204">Yürütmeler sqlTransaction2.</span><span class="sxs-lookup"><span data-stu-id="e7abf-204">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="e7abf-205">SqlTransaction1 ' e döner ve sqlTransaction1 'in zaten yürütüldüğü satırı güncelleştirme girişiminde bulunur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-205">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="e7abf-206">Hata 3960 tetiklenir ve sqlTransaction1 otomatik olarak geri alınır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-206">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="e7abf-207">**SqlException. Number** ve **SqlException. Message** konsol penceresinde görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-207">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="e7abf-208">**AdventureWorks** 'te anlık görüntü yalıtımını devre dışı bırakmak ve **TestSnapshotUpdate** tablosunu silmek için Temizleme kodunu yürütür.</span><span class="sxs-lookup"><span data-stu-id="e7abf-208">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="e7abf-209">Anlık görüntü yalıtımıyla kilit Ipuçlarını kullanma</span><span class="sxs-lookup"><span data-stu-id="e7abf-209">Using Lock Hints with Snapshot Isolation</span></span>  

 <span data-ttu-id="e7abf-210">Önceki örnekte, ilk işlem verileri seçer ve ikinci bir işlem ilk işlem tamamlanmadan önce verileri güncelleştirir, ilk işlem aynı satırı güncelleştirmeye çalıştığında güncelleştirme çakışmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="e7abf-210">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="e7abf-211">İşlemin başlangıcında kilit ipuçları sağlayarak uzun süre çalışan anlık görüntü işlemlerinde güncelleştirme çakışmalarının olasılığını azaltabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e7abf-211">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="e7abf-212">Aşağıdaki SELECT deyimleri, seçili satırları kilitlemek için UPDLOCK ipucunu kullanır:</span><span class="sxs-lookup"><span data-stu-id="e7abf-212">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="e7abf-213">UPDLOCK kilit ipucu kullanımı, ilk işlem tamamlanmadan önce satırları güncelleştirmeye çalışan tüm satırları engeller.</span><span class="sxs-lookup"><span data-stu-id="e7abf-213">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="e7abf-214">Bu, seçili satırların işlemde daha sonra güncellendiklerinde hiçbir çakışma olmadığından emin olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="e7abf-214">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="e7abf-215">SQL Server Books Online 'da "kilitleme Ipuçları" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="e7abf-215">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="e7abf-216">Uygulamanızda çok fazla çakışma varsa, anlık görüntü yalıtımı en iyi seçim olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="e7abf-216">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="e7abf-217">İpuçları yalnızca gerçekten gerektiğinde kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-217">Hints should only be used when really needed.</span></span> <span data-ttu-id="e7abf-218">Uygulamanız, işlem için kilit ipuçlarına sürekli olarak dayanmasını sağlayacak şekilde tasarlanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="e7abf-218">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e7abf-219">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="e7abf-219">See also</span></span>

- [<span data-ttu-id="e7abf-220">SQL Server ve ADO.NET</span><span class="sxs-lookup"><span data-stu-id="e7abf-220">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="e7abf-221">ADO.NET’e Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="e7abf-221">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="e7abf-222">İşlem kilitleme ve satır sürümü oluşturma kılavuzu</span><span class="sxs-lookup"><span data-stu-id="e7abf-222">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
