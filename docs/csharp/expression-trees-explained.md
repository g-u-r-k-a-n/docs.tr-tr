---
title: İfade Ağaçları Açıklaması
description: İfade ağaçları ve dış yürütmeye yönelik algoritmalarda nasıl yararlı olduğu ve yürütmeden önce kodu İnceleme hakkında bilgi edinin.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73036987"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="6e505-103">İfade Ağaçları Açıklaması</span><span class="sxs-lookup"><span data-stu-id="6e505-103">Expression Trees Explained</span></span>

[<span data-ttu-id="6e505-104">Önceki--genel bakış</span><span class="sxs-lookup"><span data-stu-id="6e505-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="6e505-105">Ifade ağacı kodu tanımlayan bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="6e505-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="6e505-106">Bunlar, bir derleyicinin kodu çözümlemek ve derlenen çıktıyı oluşturmak için kullandığı yapıları temel alırlar.</span><span class="sxs-lookup"><span data-stu-id="6e505-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="6e505-107">Bu öğreticiyi okurken, [çözümleyiciler ve kod düzeltmeleri](https://github.com/dotnet/roslyn-analyzers)oluşturmak Için ifade ağaçları ve Roslyn API 'lerinde kullanılan türler arasında çok sayıda benzerlik olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="6e505-108">(Çözümleyiciler ve kod düzeltmeleri, kodda statik analiz gerçekleştiren ve bir geliştirici için olası düzeltmeler öneren NuGet paketlerdir.) Kavramlar benzerdir ve nihai sonuç, kaynak kodun anlamlı bir şekilde incelemesini sağlayan bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="6e505-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="6e505-109">Ancak, Ifade ağaçları, Roslyn API 'Lerine göre tamamen farklı bir sınıf ve API kümesine dayanır.</span><span class="sxs-lookup"><span data-stu-id="6e505-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="6e505-110">Basit bir örneğe bakalım.</span><span class="sxs-lookup"><span data-stu-id="6e505-110">Let's look at a simple example.</span></span>
<span data-ttu-id="6e505-111">Aşağıda bir kod satırı verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="6e505-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="6e505-112">Bunu bir ifade ağacı olarak çözümlüyorsanız, ağaç birkaç düğüm içerir.</span><span class="sxs-lookup"><span data-stu-id="6e505-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="6e505-113">En dıştaki düğüm, birden çok alt düğüm içeren bir atama (`var sum = 1 + 2;`) olan bir değişken bildirimi deyimidir: değişken bildirimi, atama işleci ve eşittir işaretinin sağ tarafını temsil eden bir ifade.</span><span class="sxs-lookup"><span data-stu-id="6e505-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="6e505-114">Bu ifade, toplama işlemini ve ek olarak sol ve sağ işlenenleri temsil eden ifadelere daha fazla bölünmüştür.</span><span class="sxs-lookup"><span data-stu-id="6e505-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="6e505-115">Eşittir işaretinin sağ tarafını oluşturan ifadelerle biraz daha fazla ayrıntıya bakalım.</span><span class="sxs-lookup"><span data-stu-id="6e505-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="6e505-116">İfade `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="6e505-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="6e505-117">Bu bir ikili ifadedir.</span><span class="sxs-lookup"><span data-stu-id="6e505-117">That's a binary expression.</span></span> <span data-ttu-id="6e505-118">Daha özel olarak, bu bir ikili ekleme ifadesidir.</span><span class="sxs-lookup"><span data-stu-id="6e505-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="6e505-119">İkili ekleme ifadesinde, ek ifadenin sol ve sağ düğümleri temsil eden iki alt öğe vardır.</span><span class="sxs-lookup"><span data-stu-id="6e505-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="6e505-120">Her iki düğüm de sabit ifadelerdir: Sol işlenen `1`değerdir ve sağ işlenen değer `2`.</span><span class="sxs-lookup"><span data-stu-id="6e505-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="6e505-121">Görsel olarak, tüm deyimin bir ağaç olması gerekir: kök düğümden başlayabilir ve bu ifadeyi oluşturan kodu görmek için ağaçtaki her bir düğüme yolculuk yapabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="6e505-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="6e505-122">Atama ile değişken bildirimi ekstresi (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="6e505-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="6e505-123">Örtük değişken türü bildirimi (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="6e505-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="6e505-124">Örtük var anahtar sözcüğü (`var`)</span><span class="sxs-lookup"><span data-stu-id="6e505-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="6e505-125">Değişken adı bildirimi (`sum`)</span><span class="sxs-lookup"><span data-stu-id="6e505-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="6e505-126">Atama işleci (`=`)</span><span class="sxs-lookup"><span data-stu-id="6e505-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="6e505-127">İkili ekleme ifadesi (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="6e505-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="6e505-128">Sol işlenen (`1`)</span><span class="sxs-lookup"><span data-stu-id="6e505-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="6e505-129">Toplama işleci (`+`)</span><span class="sxs-lookup"><span data-stu-id="6e505-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="6e505-130">Sağ işlenen (`2`)</span><span class="sxs-lookup"><span data-stu-id="6e505-130">Right operand (`2`)</span></span>

<span data-ttu-id="6e505-131">Bu karmaşık görünebilir, ancak çok güçlüdür.</span><span class="sxs-lookup"><span data-stu-id="6e505-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="6e505-132">Aynı süreci izleyerek, daha karmaşık ifadeler de oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="6e505-133">Şu ifadeyi göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="6e505-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="6e505-134">Yukarıdaki ifade ayrıca atama içeren bir değişken bildirimidir.</span><span class="sxs-lookup"><span data-stu-id="6e505-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="6e505-135">Bu örnekte, atamanın sağ tarafı çok daha karmaşık bir ağacdır.</span><span class="sxs-lookup"><span data-stu-id="6e505-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="6e505-136">Bu ifadeyi parçalara ayırmayı istemiyorum, ancak farklı düğümlerin ne olabileceğini düşünün.</span><span class="sxs-lookup"><span data-stu-id="6e505-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="6e505-137">Geçerli nesneyi alıcı olarak kullanan ve açık bir `this` alıcısı olan, diğeri olmayan yöntem çağrıları vardır.</span><span class="sxs-lookup"><span data-stu-id="6e505-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="6e505-138">Diğer alıcı nesnelerini kullanan Yöntem çağrıları vardır, farklı türlerde sabit bağımsız değişkenler vardır.</span><span class="sxs-lookup"><span data-stu-id="6e505-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="6e505-139">Son olarak, bir ikili toplama işleci vardır.</span><span class="sxs-lookup"><span data-stu-id="6e505-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="6e505-140">`SecretSauceFunction()` veya `MoreSecretSauce()`dönüş türüne bağlı olarak, bu ikili ek işleç, bir sınıf için tanımlanan ikili toplama işlecine bir statik yöntem çağrısına çözüm olarak, geçersiz kılınan bir toplama işlecine bir yöntem çağrısı olabilir.</span><span class="sxs-lookup"><span data-stu-id="6e505-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="6e505-141">Bu algılanan karmaşıklığa rağmen yukarıdaki ifade, ilk örnek olarak kolayca gezinilede bir ağaç yapısı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="6e505-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="6e505-142">İfadede yaprak düğümleri bulmak için alt düğümlerin geçiş tutulmasını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="6e505-143">Üst düğümlerin alt öğelerine başvuruları olacaktır ve her düğüm, ne tür bir düğüm olduğunu açıklayan bir özelliğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="6e505-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="6e505-144">Bir ifade ağacının yapısı çok tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="6e505-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="6e505-145">Temel bilgileri öğrendikten sonra, bir ifade ağacı olarak temsil edildiğinde en karmaşık kodu bile anlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="6e505-146">Veri yapısındaki inceliğini, C# derleyicinin en karmaşık C# programları nasıl çözümleyebileceğini ve bu karmaşık kaynak kodundan doğru çıktı oluşturmasına nasıl yönelik olduğunu açıklar.</span><span class="sxs-lookup"><span data-stu-id="6e505-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="6e505-147">İfade ağaçları yapısına alışdıktan sonra, elde ettiğiniz bilgileri daha fazla ve daha fazla gelişmiş senaryolarla çalışmanıza olanak tanıcaksınız.</span><span class="sxs-lookup"><span data-stu-id="6e505-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="6e505-148">İfade ağaçları için inanılmaz güç vardır.</span><span class="sxs-lookup"><span data-stu-id="6e505-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="6e505-149">Algoritmaları başka ortamlarda yürütmek üzere çevirmenin yanı sıra, kod yürütmeden önce kodu İnceleme algoritmalarının yazmayı kolaylaştırmak için ifade ağaçları kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="6e505-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="6e505-150">Bağımsız değişkenleri ifade olan bir yöntem yazabilir ve ardından kodu yürütmeden önce bu ifadeleri inceleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="6e505-151">Ifade ağacı kodun tam bir gösterimidir: herhangi bir alt ifadenin değerlerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="6e505-152">Yöntem ve özellik adlarını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-152">You can see method and property names.</span></span> <span data-ttu-id="6e505-153">Herhangi bir sabit ifadenin değerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="6e505-154">Ayrıca, bir ifade ağacını yürütülebilir bir temsilciye dönüştürebilir ve kodu yürütebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6e505-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="6e505-155">Ifade ağaçları için API 'Ler, neredeyse tüm geçerli kod yapısını temsil eden ağaçlar oluşturmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="6e505-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="6e505-156">Ancak, şeyleri mümkün olduğunca basit tutmak için bir ifade ağacında C# bazı ıoms oluşturulamaz.</span><span class="sxs-lookup"><span data-stu-id="6e505-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="6e505-157">Bir örnek, zaman uyumsuz ifadelerdir (`async` ve `await` anahtar kelimeleri kullanılarak).</span><span class="sxs-lookup"><span data-stu-id="6e505-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="6e505-158">Gereksinimleriniz zaman uyumsuz algoritmalar gerektiriyorsa, derleyici desteğine göre değil, `Task` nesnelerini doğrudan değiştirmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="6e505-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="6e505-159">Başka bir döngü de oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="6e505-159">Another is in creating loops.</span></span> <span data-ttu-id="6e505-160">Genellikle, `for`, `foreach`, `while` veya `do` döngülerini kullanarak bunları oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="6e505-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="6e505-161">[Bu serinin ilerleyen kısımlarında](expression-trees-building.md)göreceğiniz gibi, ifade ağaçları Için API 'ler, `break` ve döngüyü yinelemeyi denetleyen `continue` ifadelerle tek bir döngü ifadesi destekler.</span><span class="sxs-lookup"><span data-stu-id="6e505-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="6e505-162">Yapamayacağınız her şey bir ifade ağacını değiştirmektir.</span><span class="sxs-lookup"><span data-stu-id="6e505-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="6e505-163">İfade ağaçları değişmez veri yapılarıdır.</span><span class="sxs-lookup"><span data-stu-id="6e505-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="6e505-164">Bir ifade ağacını bulunmamalıdır (değiştirmek) istiyorsanız, orijinalin bir kopyası olan, ancak istediğiniz değişikliklerle yeni bir ağaç oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6e505-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="6e505-165">Ifade ağaçlarını destekleyen bir sonraki--çerçeve türleri</span><span class="sxs-lookup"><span data-stu-id="6e505-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
