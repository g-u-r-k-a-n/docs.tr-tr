---
title: Veri Sözleşmelerinde Koleksiyon Türleri
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- collection types [WCF], data contracts
- data contracts [WCF], collection types
- collection types [WCF]
ms.assetid: 9b45b28e-0a82-4ea3-8c33-ec0094aff9d5
ms.openlocfilehash: a10b7c5295407cfbb36446581a4b75670e37bc6a
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/09/2020
ms.locfileid: "84579755"
---
# <a name="collection-types-in-data-contracts"></a><span data-ttu-id="6effe-102">Veri Sözleşmelerinde Koleksiyon Türleri</span><span class="sxs-lookup"><span data-stu-id="6effe-102">Collection Types in Data Contracts</span></span>

<span data-ttu-id="6effe-103">*Koleksiyon* , belirli bir türdeki öğelerin listesidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-103">A *collection* is a list of items of a certain type.</span></span> <span data-ttu-id="6effe-104">.NET Framework, bu tür listeler diziler veya diğer çeşitli türler (genel liste, genel <xref:System.ComponentModel.BindingList%601> , veya) kullanılarak temsil edilebilir <xref:System.Collections.Specialized.StringCollection> <xref:System.Collections.ArrayList> .</span><span class="sxs-lookup"><span data-stu-id="6effe-104">In the .NET Framework, such lists can be represented using arrays or a variety of other types (Generic List, Generic <xref:System.ComponentModel.BindingList%601>, <xref:System.Collections.Specialized.StringCollection>, or <xref:System.Collections.ArrayList>).</span></span> <span data-ttu-id="6effe-105">Örneğin, bir koleksiyon belirli bir müşteri için adreslerin listesini tutabilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-105">For example, a collection may hold a list of Addresses for a given Customer.</span></span> <span data-ttu-id="6effe-106">Bu koleksiyonlara, gerçek türlerine bakılmaksızın *liste koleksiyonları*denir.</span><span class="sxs-lookup"><span data-stu-id="6effe-106">These collections are called *list collections*, regardless of their actual type.</span></span>

<span data-ttu-id="6effe-107">Bir öğe ("Key") ve diğeri ("Value") arasındaki ilişkiyi temsil eden özel bir koleksiyon biçimi vardır.</span><span class="sxs-lookup"><span data-stu-id="6effe-107">A special form of collection exists that represents an association between one item (the "key") and another (the "value").</span></span> <span data-ttu-id="6effe-108">.NET Framework, bunlar ve genel sözlük gibi türler tarafından temsil edilir <xref:System.Collections.Hashtable> .</span><span class="sxs-lookup"><span data-stu-id="6effe-108">In the .NET Framework, these are represented by types such as <xref:System.Collections.Hashtable> and the generic dictionary.</span></span> <span data-ttu-id="6effe-109">Örneğin, bir ilişki koleksiyonu bir şehri ("anahtar") kendi popülasyonu ("değer") ile eşleyebilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-109">For example, an association collection may map a city ("key") to its population ("value").</span></span> <span data-ttu-id="6effe-110">Bu koleksiyonlara, gerçek türlerine bakılmaksızın *Sözlük koleksiyonları*denir.</span><span class="sxs-lookup"><span data-stu-id="6effe-110">These collections are called *dictionary collections*, regardless of their actual type.</span></span>

<span data-ttu-id="6effe-111">Koleksiyonlar, veri anlaşması modelinde özel bir işleme alır.</span><span class="sxs-lookup"><span data-stu-id="6effe-111">Collections receive special treatment in the data contract model.</span></span>

<span data-ttu-id="6effe-112"><xref:System.Collections.IEnumerable>Diziler ve genel Koleksiyonlar dahil olmak üzere arabirimi uygulayan türler koleksiyonlar olarak tanınır.</span><span class="sxs-lookup"><span data-stu-id="6effe-112">Types that implement the <xref:System.Collections.IEnumerable> interface, including arrays and generic collections, are recognized as collections.</span></span> <span data-ttu-id="6effe-113">Bunlar, <xref:System.Collections.IDictionary> veya genel arabirimlerini uygulayan türler <xref:System.Collections.Generic.IDictionary%602> Sözlük koleksiyonlarıdır; diğerleri liste koleksiyonlarıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-113">Of those, types that implement the <xref:System.Collections.IDictionary> or Generic <xref:System.Collections.Generic.IDictionary%602> interfaces are dictionary collections; all others are list collections.</span></span>

<span data-ttu-id="6effe-114">Koleksiyon türlerinde, bir yöntemi `Add` ve parametresiz bir oluşturucuyu olması gibi ek gereksinimler, aşağıdaki bölümlerde ayrıntılı olarak ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="6effe-114">Additional requirements on collection types, such as having a method called `Add` and a parameterless constructor, are discussed in detail in the following sections.</span></span> <span data-ttu-id="6effe-115">Bu, koleksiyon türlerinin hem serileştirilmiş hem de seri durumdan çıkarılabilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="6effe-115">This ensures that collection types can be both serialized and deserialized.</span></span> <span data-ttu-id="6effe-116">Bu, bazı koleksiyonların genel (parametresiz oluşturucusu olmadığından) gibi doğrudan desteklenmediği anlamına gelir <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> .</span><span class="sxs-lookup"><span data-stu-id="6effe-116">This means that some collections are not directly supported, such as the Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> (because it has no parameterless constructor).</span></span> <span data-ttu-id="6effe-117">Bununla birlikte, bu kısıtlamaları atlama hakkında daha fazla bilgi için bu konunun devamındaki "koleksiyon arabirim türleri ve salt okuma koleksiyonları kullanma" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-117">However, for information about circumventing these restrictions, see the section "Using Collection Interface Types and Read-Only Collections" later in this topic.</span></span>

<span data-ttu-id="6effe-118">Koleksiyonlarda bulunan türlerin veri sözleşme türleri olması veya başka türlü seri hale getirilebilir olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="6effe-118">The types contained in collections must be data contract types, or be otherwise serializable.</span></span> <span data-ttu-id="6effe-119">Daha fazla bilgi için bkz. [veri sözleşmesi serileştiricisi tarafından desteklenen türler](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="6effe-119">For more information, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span>

<span data-ttu-id="6effe-120">Ne olduğu ve geçerli bir koleksiyon olarak kabul edildiği hakkında daha fazla bilgi için, bu konunun "Gelişmiş koleksiyon kuralları" bölümünde koleksiyonları serileştirme hakkındaki bilgilere bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-120">For more information about what is and what is not considered a valid collection, as well as about how collections are serialized, see the information about serializing collections in the "Advanced Collection Rules" section of this topic.</span></span>

## <a name="interchangeable-collections"></a><span data-ttu-id="6effe-121">Değiştirilebilir Koleksiyonlar</span><span class="sxs-lookup"><span data-stu-id="6effe-121">Interchangeable Collections</span></span>

<span data-ttu-id="6effe-122">Aynı türdeki tüm liste koleksiyonları aynı veri sözleşmesine sahip olacak şekilde değerlendirilir ( <xref:System.Runtime.Serialization.CollectionDataContractAttribute> Bu konunun ilerleyen kısımlarında açıklandığı gibi özniteliği kullanılarak özelleştirilmedikleri sürece).</span><span class="sxs-lookup"><span data-stu-id="6effe-122">All list collections of the same type are considered to have the same data contract (unless they are customized using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, as discussed later in this topic).</span></span> <span data-ttu-id="6effe-123">Bu nedenle, örneğin, aşağıdaki veri sözleşmeleri eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="6effe-123">Thus, for example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#0](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#0)]
[!code-vb[c_collection_types_in_data_contracts#0](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#0)]

<span data-ttu-id="6effe-124">Her iki veri sözleşmesi de aşağıdaki koda benzer şekilde XML ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="6effe-124">Both data contracts result in XML similar to the following code.</span></span>

```xml
<PurchaseOrder>
    <customerName>...</customerName>
    <items>
        <Item>...</Item>
        <Item>...</Item>
        <Item>...</Item>
        ...
    </items>
    <comments>
        <string>...</string>
        <string>...</string>
        <string>...</string>
        ...
    </comments>
</PurchaseOrder>
```

<span data-ttu-id="6effe-125">Koleksiyon interchangeability, örneğin, sunucuda performans için iyileştirilmiş bir koleksiyon türü ve istemcideki Kullanıcı arabirimi bileşenlerine bağlanacak şekilde tasarlanan bir koleksiyon türü kullanmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="6effe-125">Collection interchangeability allows you to use, for example, a collection type optimized for performance on the server and a collection type designed to be bound to user interface components on the client.</span></span>

<span data-ttu-id="6effe-126">Liste koleksiyonlarına benzer şekilde, aynı anahtar ve değer türlerine sahip tüm sözlük koleksiyonları aynı veri sözleşmesine sahip olacak şekilde değerlendirilir (özniteliği tarafından özelleştirilmediği müddetçe <xref:System.Runtime.Serialization.CollectionDataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="6effe-126">Similar to list collections, all dictionary collections that have the same key and value types are considered to have the same data contract (unless customized by the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute).</span></span>

<span data-ttu-id="6effe-127">Yalnızca koleksiyon denklemesiyle ilgili olarak önemli olan veri sözleşmesi türü .NET türleri değildir.</span><span class="sxs-lookup"><span data-stu-id="6effe-127">Only the data contract type matters as far as collection equivalence is concerned, not .NET types.</span></span> <span data-ttu-id="6effe-128">Diğer bir deyişle, type1 koleksiyonu, type1 ve type2 eşdeğer veri sözleşmeleri içeriyorsa bir type2 koleksiyonuna eşdeğer olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-128">That is, a collection of Type1 is considered equivalent to a collection of Type2 if Type1 and Type2 have equivalent data contracts.</span></span>

<span data-ttu-id="6effe-129">Genel olmayan koleksiyonlar, türü genel koleksiyonlarla aynı veri sözleşmesine sahip olarak kabul edilir `Object` .</span><span class="sxs-lookup"><span data-stu-id="6effe-129">Non-generic collections are considered to have the same data contract as generic collections of type `Object`.</span></span> <span data-ttu-id="6effe-130">(Örneğin, ve genel için veri sözleşmeleri <xref:System.Collections.ArrayList> <xref:System.Collections.Generic.List%601> `Object` aynıdır.)</span><span class="sxs-lookup"><span data-stu-id="6effe-130">(For example, the data contracts for <xref:System.Collections.ArrayList> and Generic <xref:System.Collections.Generic.List%601> of `Object` are the same.)</span></span>

## <a name="using-collection-interface-types-and-read-only-collections"></a><span data-ttu-id="6effe-131">Koleksiyon arabirim türleri ve salt okunurdur koleksiyonları kullanma</span><span class="sxs-lookup"><span data-stu-id="6effe-131">Using Collection Interface Types and Read-Only Collections</span></span>

<span data-ttu-id="6effe-132">Koleksiyon arabirim türleri ( <xref:System.Collections.IEnumerable> , <xref:System.Collections.IDictionary> , genel <xref:System.Collections.Generic.IDictionary%602> veya bu arabirimlerden türetilmiş arabirimler), gerçek koleksiyon türleri için koleksiyon veri sözleşmeleri ile eşdeğer olan koleksiyon veri sözleşmeleri olarak da düşünülür.</span><span class="sxs-lookup"><span data-stu-id="6effe-132">Collection interface types (<xref:System.Collections.IEnumerable>, <xref:System.Collections.IDictionary>, generic <xref:System.Collections.Generic.IDictionary%602>, or interfaces derived from these interfaces) are also considered as having collection data contracts, equivalent to collection data contracts for actual collection types.</span></span> <span data-ttu-id="6effe-133">Bu nedenle, bir koleksiyon arabirim türü olarak serileştirilmekte olan türü bildirmek mümkündür ve sonuçlar gerçek bir koleksiyon türü kullanılmış gibi aynı olur.</span><span class="sxs-lookup"><span data-stu-id="6effe-133">Thus, it is possible to declare the type being serialized as a collection interface type and the results are the same as if an actual collection type had been used.</span></span> <span data-ttu-id="6effe-134">Örneğin, aşağıdaki veri sözleşmeleri eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="6effe-134">For example, the following data contracts are equivalent.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#1)]
[!code-vb[c_collection_types_in_data_contracts#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#1)]

<span data-ttu-id="6effe-135">Serileştirme sırasında, belirtilen tür bir arabirim olduğunda, kullanılan gerçek örnek türü bu arabirimi uygulayan herhangi bir tür olabilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-135">During serialization, when the declared type is an interface, the actual instance type used can be any type that implements that interface.</span></span> <span data-ttu-id="6effe-136">Daha önce tartışılan kısıtlamalar (parametresiz bir oluşturucuya ve bir `Add` yönteme sahip) uygulanmaz.</span><span class="sxs-lookup"><span data-stu-id="6effe-136">Restrictions discussed previously (having a parameterless constructor and an `Add` method) do not apply.</span></span> <span data-ttu-id="6effe-137">Örneğin, <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> genel türünde bir veri üyesini doğrudan bildiremeseniz bile Customer2 içindeki adresleri genel bir adres örneğine ayarlayabilirsiniz <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> .</span><span class="sxs-lookup"><span data-stu-id="6effe-137">For example, you can set addresses in Customer2 to an instance of Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> of Address, even though you cannot directly declare a data member of type Generic <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>

<span data-ttu-id="6effe-138">Seri durumdan çıkarma sırasında, belirtilen tür bir arabirim olduğunda, serileştirme altyapısı, belirtilen arabirimi uygulayan bir tür seçer ve tür oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="6effe-138">During deserialization, when the declared type is an interface, the serialization engine chooses a type that implements the declared interface, and the type is instantiated.</span></span> <span data-ttu-id="6effe-139">Bilinen türler mekanizması ( [veri sözleşmesinin bilinen türlerinde](data-contract-known-types.md)açıklanmıştır) burada hiçbir etkiye sahip değildir; tür seçimi WCF 'de yerleşik olarak bulunur.</span><span class="sxs-lookup"><span data-stu-id="6effe-139">The known types mechanism (described in [Data Contract Known Types](data-contract-known-types.md)) has no effect here; the choice of type is built into WCF.</span></span>

## <a name="customizing-collection-types"></a><span data-ttu-id="6effe-140">Koleksiyon türlerini özelleştirme</span><span class="sxs-lookup"><span data-stu-id="6effe-140">Customizing Collection Types</span></span>

<span data-ttu-id="6effe-141">Koleksiyon türlerini <xref:System.Runtime.Serialization.CollectionDataContractAttribute> , birkaç kullanımı bulunan özniteliğini kullanarak özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-141">You can customize collection types by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, which has several uses.</span></span>

<span data-ttu-id="6effe-142">Koleksiyon türlerini özelleştirme interchangeability koleksiyonu, bu nedenle bu özniteliği mümkün olduğunda uygulamaktan kaçınmak için genellikle önerilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-142">Note that customizing collection types compromises collection interchangeability, so it is generally recommended to avoid applying this attribute whenever possible.</span></span> <span data-ttu-id="6effe-143">Bu sorun hakkında daha fazla bilgi için, bu konunun devamındaki "Gelişmiş koleksiyon kuralları" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-143">For more information about this issue, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="collection-data-contract-naming"></a><span data-ttu-id="6effe-144">Koleksiyon veri anlaşması adlandırma</span><span class="sxs-lookup"><span data-stu-id="6effe-144">Collection Data Contract Naming</span></span>

<span data-ttu-id="6effe-145">Ad koleksiyon türlerini adlandırma kuralları, [veri anlaşması adlarında](data-contract-names.md)açıklandığı şekilde, düzenli veri sözleşme türlerini adlandırmakla benzerdir, ancak bazı önemli farklılıklar vardır:</span><span class="sxs-lookup"><span data-stu-id="6effe-145">The rules for naming collection types are similar to those for naming regular data contract types, as described in [Data Contract Names](data-contract-names.md), although some important differences exist:</span></span>

- <span data-ttu-id="6effe-146"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Özniteliği, özniteliği yerine adı özelleştirmek için kullanılır <xref:System.Runtime.Serialization.DataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="6effe-146">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is used to customize the name, instead of the <xref:System.Runtime.Serialization.DataContractAttribute> attribute.</span></span> <span data-ttu-id="6effe-147"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Özniteliği `Name` ve özellikleri de vardır `Namespace` .</span><span class="sxs-lookup"><span data-stu-id="6effe-147">The <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute also has `Name` and `Namespace` properties.</span></span>

- <span data-ttu-id="6effe-148"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Özniteliği uygulandığında, koleksiyon türleri için varsayılan ad ve ad alanı, koleksiyonda bulunan türlerin adlarına ve ad alanlarına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-148">When the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is not applied, the default name and namespace for collection types depend on the names and namespaces of types contained within the collection.</span></span> <span data-ttu-id="6effe-149">Bunlar, koleksiyon türünün adı ve ad alanından etkilenmemektedir.</span><span class="sxs-lookup"><span data-stu-id="6effe-149">They are not affected by the name and namespace of the collection type itself.</span></span> <span data-ttu-id="6effe-150">Bir örnek için, aşağıdaki türlere bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-150">For an example, see the following types.</span></span>

  ```csharp
  public CustomerList1 : Collection<string> {}
  public StringList1 : Collection<string> {}
  ```

<span data-ttu-id="6effe-151">Her iki tür ' veri anlaşması adı "CustomerList1" veya "StringList1" değil "ArrayOfstring".</span><span class="sxs-lookup"><span data-stu-id="6effe-151">Both types’ data contract name is "ArrayOfstring" and not "CustomerList1" or "StringList1".</span></span> <span data-ttu-id="6effe-152">Bu, kök düzeyindeki bu türlerden herhangi birinin serileştirilmesi, aşağıdaki koda benzer bir XML üretir.</span><span class="sxs-lookup"><span data-stu-id="6effe-152">This means that serializing any one of these types at the root level yields XML similar to the following code.</span></span>

```xml
<ArrayOfstring>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</ArrayOfstring>
```

<span data-ttu-id="6effe-153">Bu adlandırma kuralı, bir dize listesini temsil eden özelleştirilmeyen bir türün aynı veri sözleşmesine ve XML gösterimine sahip olduğundan emin olmak için seçilmiştir.</span><span class="sxs-lookup"><span data-stu-id="6effe-153">This naming rule was chosen to ensure that any non-customized type that represents a list of strings has the same data contract and XML representation.</span></span> <span data-ttu-id="6effe-154">Bu, koleksiyonu interchangeability mümkün hale getirir.</span><span class="sxs-lookup"><span data-stu-id="6effe-154">This makes collection interchangeability possible.</span></span> <span data-ttu-id="6effe-155">Bu örnekte, CustomerList1 ve StringList1 tamamen değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-155">In this example, CustomerList1 and StringList1 are completely interchangeable.</span></span>

<span data-ttu-id="6effe-156">Ancak <xref:System.Runtime.Serialization.CollectionDataContractAttribute> Öznitelik uygulandığında, öznitelik üzerinde hiçbir özellik ayarlanmamışsa bile koleksiyon özelleştirilmiş bir koleksiyon veri anlaşması haline gelir.</span><span class="sxs-lookup"><span data-stu-id="6effe-156">However, when the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute is applied, the collection becomes a customized collection data contract, even if no properties are set on the attribute.</span></span> <span data-ttu-id="6effe-157">Koleksiyon veri sözleşmesinin adı ve ad alanı, daha sonra koleksiyon türüne bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-157">The name and namespace of the collection data contract then depend on the collection type itself.</span></span> <span data-ttu-id="6effe-158">Bir örnek için, aşağıdaki türe bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-158">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#2)]
[!code-vb[c_collection_types_in_data_contracts#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#2)]

<span data-ttu-id="6effe-159">Serileştirilmiş olduğunda, elde edilen XML aşağıdakine benzer.</span><span class="sxs-lookup"><span data-stu-id="6effe-159">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CustomerList2>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</CustomerList2>
```

<span data-ttu-id="6effe-160">Bunun artık özelleştirilmemiş türlerin XML gösterimine eşit olmadığına dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="6effe-160">Notice that this is no longer equivalent to the XML representation of the non-customized types.</span></span>

- <span data-ttu-id="6effe-161">`Name`Ve `Namespace` özelliklerini kullanarak adlandırmanın daha fazla özelleştirmesini sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-161">You can use the `Name` and `Namespace` properties to further customize the naming.</span></span> <span data-ttu-id="6effe-162">Aşağıdaki sınıfa bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-162">See the following class.</span></span>

  [!code-csharp[c_collection_types_in_data_contracts#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#3)]
  [!code-vb[c_collection_types_in_data_contracts#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#3)]

<span data-ttu-id="6effe-163">Elde edilen XML aşağıdakine benzer.</span><span class="sxs-lookup"><span data-stu-id="6effe-163">The resulting XML is similar to the following.</span></span>

```xml
<cust_list>
    <string>...</string>
    <string>...</string>
    <string>...</string>
    ...
</cust_list>
```

<span data-ttu-id="6effe-164">Daha fazla bilgi için bu konunun ilerleyen bölümlerindeki "Gelişmiş koleksiyon kuralları" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-164">For more information, see the "Advanced Collection Rules" section later in this topic.</span></span>

### <a name="customizing-the-repeating-element-name-in-list-collections"></a><span data-ttu-id="6effe-165">Liste koleksiyonlarında yinelenen öğe adını özelleştirme</span><span class="sxs-lookup"><span data-stu-id="6effe-165">Customizing the Repeating Element Name in List Collections</span></span>

<span data-ttu-id="6effe-166">Liste koleksiyonları yinelenen girdiler içerir.</span><span class="sxs-lookup"><span data-stu-id="6effe-166">List collections contain repeating entries.</span></span> <span data-ttu-id="6effe-167">Normalde, her bir yinelenen giriş, koleksiyonda bulunan türün veri sözleşmesi adına göre adlı bir öğe olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-167">Normally, each repeating entry is represented as an element named according to the data contract name of the type contained in the collection.</span></span>

<span data-ttu-id="6effe-168">`CustomerList`Örneklerde, Koleksiyonlar dizeler içeriyordu.</span><span class="sxs-lookup"><span data-stu-id="6effe-168">In the `CustomerList` examples, the collections contained strings.</span></span> <span data-ttu-id="6effe-169">Dize temel türü için veri sözleşmesi adı "String" olduğundan, yinelenen öğe " \<string> " idi.</span><span class="sxs-lookup"><span data-stu-id="6effe-169">The data contract name for the string primitive type is "string", so the repeating element was "\<string>".</span></span>

<span data-ttu-id="6effe-170">Ancak, <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> özelliği <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliğinde kullanarak, bu yinelenen öğe adı özelleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-170">However, using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property on the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute, this repeating element name can be customized.</span></span> <span data-ttu-id="6effe-171">Bir örnek için, aşağıdaki türe bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-171">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#4)]
[!code-vb[c_collection_types_in_data_contracts#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#4)]

<span data-ttu-id="6effe-172">Elde edilen XML aşağıdakine benzer.</span><span class="sxs-lookup"><span data-stu-id="6effe-172">The resulting XML is similar to the following.</span></span>

```xml
<CustomerList4>
    <customer>...</customer>
    <customer>...</customer>
    <customer>...</customer>
    ...
</CustomerList4>
```

<span data-ttu-id="6effe-173">Yinelenen öğenin ad alanı her zaman koleksiyon veri sözleşmesinin ad alanıyla aynıdır ve bu, `Namespace` daha önce açıklandığı gibi özelliği kullanılarak özelleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-173">The namespace of the repeating element is always the same as the namespace of the collection data contract, which can be customized using the `Namespace` property, as described previously.</span></span>

### <a name="customizing-dictionary-collections"></a><span data-ttu-id="6effe-174">Sözlük koleksiyonlarını özelleştirme</span><span class="sxs-lookup"><span data-stu-id="6effe-174">Customizing Dictionary Collections</span></span>

<span data-ttu-id="6effe-175">Sözlük koleksiyonları, her girdinin bir anahtara ve ardından bir değere sahip olduğu, temel olarak giriş listesidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-175">Dictionary collections are essentially lists of entries, where each entry has a key followed by a value.</span></span> <span data-ttu-id="6effe-176">Normal listelerle olduğu gibi, özelliğini kullanarak, yinelenen öğeye karşılık gelen öğe adını değiştirebilirsiniz <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> .</span><span class="sxs-lookup"><span data-stu-id="6effe-176">Just as with regular lists, you can change the element name that corresponds to the repeating element by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ItemName%2A> property.</span></span>

<span data-ttu-id="6effe-177">Ayrıca, ve özelliklerini kullanarak anahtar ve değeri temsil eden öğe adlarını değiştirebilirsiniz <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> .</span><span class="sxs-lookup"><span data-stu-id="6effe-177">Additionally, you can change the element names that represent the key and the value by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> and <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> properties.</span></span> <span data-ttu-id="6effe-178">Bu öğelerin ad alanları, koleksiyon veri sözleşmesinin ad alanıyla aynıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-178">The namespaces for these elements are the same as the namespace of the collection data contract.</span></span>

<span data-ttu-id="6effe-179">Bir örnek için, aşağıdaki türe bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-179">For an example, see the following type.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#5](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#5)]
[!code-vb[c_collection_types_in_data_contracts#5](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#5)]

<span data-ttu-id="6effe-180">Serileştirilmiş olduğunda, elde edilen XML aşağıdakine benzer.</span><span class="sxs-lookup"><span data-stu-id="6effe-180">When serialized, the resulting XML is similar to the following.</span></span>

```xml
<CountriesOrRegionsWithCapitals>
    <entry>
        <countryorregion>USA</countryorregion>
        <capital>Washington</capital>
    </entry>
    <entry>
        <countryorregion>France</countryorregion>
        <capital>Paris</capital>
    </entry>
    ...
</CountriesOrRegionsWithCapitals>
```

<span data-ttu-id="6effe-181">Sözlük koleksiyonları hakkında daha fazla bilgi için bu konunun devamındaki "Gelişmiş koleksiyon kuralları" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-181">For more information about dictionary collections, see the "Advanced Collection Rules" section later in this topic.</span></span>

## <a name="collections-and-known-types"></a><span data-ttu-id="6effe-182">Koleksiyonlar ve bilinen türler</span><span class="sxs-lookup"><span data-stu-id="6effe-182">Collections and Known Types</span></span>

<span data-ttu-id="6effe-183">Diğer koleksiyonların veya koleksiyon arabirimlerinin yerine polymorphically kullandığınızda, bilinen türlere koleksiyon türleri eklemeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="6effe-183">You do not need to add collection types to known types when used polymorphically in place of other collections or collection interfaces.</span></span> <span data-ttu-id="6effe-184">Örneğin, türünde bir veri üyesi bildirirseniz <xref:System.Collections.IEnumerable> ve örneğini göndermek için kullanırsanız <xref:System.Collections.ArrayList> , <xref:System.Collections.ArrayList> bilinen türlere eklemeniz gerekmez.</span><span class="sxs-lookup"><span data-stu-id="6effe-184">For example, if you declare a data member of type <xref:System.Collections.IEnumerable> and use it to send an instance of <xref:System.Collections.ArrayList>, you do not need to add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="6effe-185">Koleksiyon olmayan türlerin yerine koleksiyonlar polymorphically kullandığınızda, bunların bilinen türlere eklenmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="6effe-185">When you use collections polymorphically in place of non-collection types, they must be added to known types.</span></span> <span data-ttu-id="6effe-186">Örneğin, türünde bir veri üyesi bildirirseniz `Object` ve örneğini göndermek için kullanıyorsa <xref:System.Collections.ArrayList> , <xref:System.Collections.ArrayList> bilinen türlere ekleyin.</span><span class="sxs-lookup"><span data-stu-id="6effe-186">For example, if you declare a data member of type `Object` and use it to send an instance of <xref:System.Collections.ArrayList>, add <xref:System.Collections.ArrayList> to known types.</span></span>

<span data-ttu-id="6effe-187">Bu, herhangi bir eşdeğer koleksiyon polymorphically seri hale getirme yapmanıza izin vermez.</span><span class="sxs-lookup"><span data-stu-id="6effe-187">This does not allow you to serialize any equivalent collection polymorphically.</span></span> <span data-ttu-id="6effe-188">Örneğin, <xref:System.Collections.ArrayList> önceki örnekteki bilinen türler listesine eklediğinizde, bu, `Array of Object` denk bir veri sözleşmesine sahip olsa bile sınıfı atamanıza izin vermez.</span><span class="sxs-lookup"><span data-stu-id="6effe-188">For example, when you add <xref:System.Collections.ArrayList> to the list of known types in the preceding example, this does not let you assign the `Array of Object` class, even though it has an equivalent data contract.</span></span> <span data-ttu-id="6effe-189">Bu, koleksiyon dışı türler için serileştirme üzerinde düzenli olarak bilinen türler davranışından farklı değildir, ancak koleksiyonların büyük bir olasılıkla daha yaygın olması nedeniyle koleksiyonlar durumunda anlaşılması özellikle önemlidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-189">This is no different from regular known types behavior on serialization for non-collection types, but it is especially important to understand in the case of collections because it is very common for collections to be equivalent.</span></span>

<span data-ttu-id="6effe-190">Serileştirme sırasında, belirli bir veri sözleşmesi için verilen herhangi bir kapsamda yalnızca bir tür tanınverilebilir ve eşdeğer koleksiyonların hepsi aynı veri sözleşmelerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="6effe-190">During serialization, only one type can be known in any given scope for a given data contract, and equivalent collections all have the same data contracts.</span></span> <span data-ttu-id="6effe-191">Bu, önceki örnekte, hem hem de <xref:System.Collections.ArrayList> `Array of Object` bilinen türleri aynı kapsamda ekleyemeyeceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6effe-191">This means that, in the previous example, you cannot add both <xref:System.Collections.ArrayList> and `Array of Object` to known types at the same scope.</span></span> <span data-ttu-id="6effe-192">Bu, koleksiyon olmayan türler için bilinen türler davranışına eşdeğerdir, ancak koleksiyonlar için anlaşılması özellikle önemlidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-192">Again, this is equivalent to known types behavior for non-collection types, but it is especially important to understand for collections.</span></span>

<span data-ttu-id="6effe-193">Bilinen türler, koleksiyonların içerikleri için de gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-193">Known types may also be required for contents of collections.</span></span> <span data-ttu-id="6effe-194">Örneğin, <xref:System.Collections.ArrayList> aslında ve örnekleri içeriyorsa `Type1` `Type2` , bu türlerin her ikisi de bilinen türlere eklenmelidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-194">For example, if an <xref:System.Collections.ArrayList> actually contains instances of `Type1` and `Type2`, both of these types should be added to known types.</span></span>

<span data-ttu-id="6effe-195">Aşağıdaki örnek, koleksiyonlar ve bilinen türler kullanılarak düzgün şekilde oluşturulmuş bir nesne grafiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="6effe-195">The following example shows a properly constructed object graph using collections and known types.</span></span> <span data-ttu-id="6effe-196">Örnek biraz contrived, çünkü gerçek bir uygulamada normalde aşağıdaki veri üyelerini olarak tanımlamaz `Object` ve bu nedenle bilinen tür/çok biçimlilik sorunları yoktur.</span><span class="sxs-lookup"><span data-stu-id="6effe-196">The example is somewhat contrived, because in an actual application you would normally not define the following data members as `Object`, and thus do not have any known type/polymorphism issues.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#6](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#6)]
[!code-vb[c_collection_types_in_data_contracts#6](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#6)]

<span data-ttu-id="6effe-197">Seri durumdan çıkarma sırasında, belirtilen tür bir koleksiyon türüdür, gönderilen tür, gerçekten gönderilen türden bağımsız olarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="6effe-197">On deserialization, if the declared type is a collection type, the declared type is instantiated regardless of the type that was actually sent.</span></span> <span data-ttu-id="6effe-198">Belirtilen tür bir koleksiyon arabirimse, seri hale getirici, bilinen türler açısından, örnek oluşturulacak bir tür seçer.</span><span class="sxs-lookup"><span data-stu-id="6effe-198">If the declared type is a collection interface, the deserializer picks a type to be instantiated with no regard to known types.</span></span>

<span data-ttu-id="6effe-199">Ayrıca, seri durumdan çıkarma sırasında, belirtilen tür bir koleksiyon türü değilse ancak bir koleksiyon türü gönderiliyorsa, bilinen türler listesinden eşleşen bir koleksiyon türü alınır.</span><span class="sxs-lookup"><span data-stu-id="6effe-199">Also on deserialization, if the declared type is not a collection type but a collection type is being sent, a matching collection type is picked out of the known types list.</span></span> <span data-ttu-id="6effe-200">Seri durumdan çıkarma sırasında bilinen türler listesine koleksiyon arabirim türleri eklemek mümkündür.</span><span class="sxs-lookup"><span data-stu-id="6effe-200">It is possible to add collection interface types to the list of known types on deserialization.</span></span> <span data-ttu-id="6effe-201">Bu durumda, seri durumdan çıkarma altyapısı, örnek oluşturulacak bir tür seçer.</span><span class="sxs-lookup"><span data-stu-id="6effe-201">In this case, the deserialization engine again picks a type to be instantiated.</span></span>

## <a name="collections-and-the-netdatacontractserializer-class"></a><span data-ttu-id="6effe-202">Koleksiyonlar ve NetDataContractSerializer sınıfı</span><span class="sxs-lookup"><span data-stu-id="6effe-202">Collections and the NetDataContractSerializer Class</span></span>

<span data-ttu-id="6effe-203"><xref:System.Runtime.Serialization.NetDataContractSerializer>Sınıf kullanımda olduğunda, dizi olmayan özelleştirilmemiş koleksiyon türleri ( <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliği olmadan) özel anlamlarını kaybeder.</span><span class="sxs-lookup"><span data-stu-id="6effe-203">When the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use, non-customized collection types (without the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute) that are not arrays lose their special meaning.</span></span>

<span data-ttu-id="6effe-204">Özniteliği ile işaretlenen özelleştirilmemiş koleksiyon türleri, <xref:System.SerializableAttribute> <xref:System.Runtime.Serialization.NetDataContractSerializer> <xref:System.SerializableAttribute> özniteliğe veya arabirim kurallarına göre sınıf tarafından yine de seri hale getirilebilir <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="6effe-204">Non-customized collection types marked with the <xref:System.SerializableAttribute> attribute can still be serialized by the <xref:System.Runtime.Serialization.NetDataContractSerializer> class according to the <xref:System.SerializableAttribute> attribute or the <xref:System.Runtime.Serialization.ISerializable> interface rules.</span></span>

<span data-ttu-id="6effe-205">Sınıf kullanımda olsa bile, özelleştirilmiş koleksiyon türleri, koleksiyon arabirimleri ve diziler hala koleksiyonlar olarak değerlendirilir <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="6effe-205">Customized collection types, collection interfaces, and arrays are still treated as collections, even when the <xref:System.Runtime.Serialization.NetDataContractSerializer> class is in use.</span></span>

## <a name="collections-and-schema"></a><span data-ttu-id="6effe-206">Koleksiyonlar ve şema</span><span class="sxs-lookup"><span data-stu-id="6effe-206">Collections and Schema</span></span>

<span data-ttu-id="6effe-207">Tüm eşdeğer koleksiyonlar, XML şeması tanım dili (XSD) şemasında aynı temsilde sahiptir.</span><span class="sxs-lookup"><span data-stu-id="6effe-207">All equivalent collections have the same representation in XML Schema definition language (XSD) schema.</span></span> <span data-ttu-id="6effe-208">Bu nedenle, normalde, oluşturulan istemci kodunda, sunucuda bulunan bir koleksiyon türünü almaz.</span><span class="sxs-lookup"><span data-stu-id="6effe-208">Because of this, you normally do not get the same collection type in the generated client code as the one on the server.</span></span> <span data-ttu-id="6effe-209">Örneğin, sunucu bir veri sözleşmesini genel <xref:System.Collections.Generic.List%601> tamsayı veri üyesi ile kullanabilir, ancak oluşturulan istemci kodunda aynı veri üyesi bir tamsayılar dizisi haline gelebilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-209">For example, the server may use a data contract with a Generic <xref:System.Collections.Generic.List%601> of Integer data member, but in the generated client code the same data member may become an array of integers.</span></span>

<span data-ttu-id="6effe-210">Sözlük koleksiyonları, sözlüklerin olduğunu belirten, WCF 'ye özgü bir şema ek açıklaması ile işaretlenir; Aksi takdirde, anahtar ve değer içeren girişleri içeren basit listelerden ayırt edilemez.</span><span class="sxs-lookup"><span data-stu-id="6effe-210">Dictionary collections are marked with a WCF-specific schema annotation that indicate that they are dictionaries; otherwise, they are indistinguishable from simple lists that contain entries with a key and a value.</span></span> <span data-ttu-id="6effe-211">Koleksiyonların veri sözleşmesi şemasında nasıl temsil edildiği hakkında tam bir açıklama için bkz. [veri sözleşmesi şema başvurusu](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="6effe-211">For an exact description of how collections are represented in data contract schema, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>

<span data-ttu-id="6effe-212">Varsayılan olarak, içeri aktarılan koddaki özelleştirilmemiş koleksiyonlar için türler oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="6effe-212">By default, types are not generated for non-customized collections in imported code.</span></span> <span data-ttu-id="6effe-213">Liste koleksiyonu türlerinin veri üyeleri diziler olarak içeri aktarılır ve sözlük toplama türlerinin veri üyeleri genel sözlük olarak içeri aktarılır.</span><span class="sxs-lookup"><span data-stu-id="6effe-213">Data members of list collection types are imported as arrays, and data members of dictionary collection types are imported as Generic Dictionary.</span></span>

<span data-ttu-id="6effe-214">Ancak, özelleştirilmiş koleksiyonlar için, özniteliğiyle işaretlenen ayrı türler oluşturulur <xref:System.Runtime.Serialization.CollectionDataContractAttribute> .</span><span class="sxs-lookup"><span data-stu-id="6effe-214">However, for customized collections, separate types are generated, marked with the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute.</span></span> <span data-ttu-id="6effe-215">(Şemadaki özelleştirilmiş bir koleksiyon türü, varsayılan ad alanı, ad, yinelenen öğe adı veya anahtar/değer öğesi adlarını kullanmayan bir öğedir.) Bu türler, <xref:System.Collections.Generic.List%601> liste türleri ve sözlük türleri Için genel sözlük Için genel 'den türetilen boş türlerdir.</span><span class="sxs-lookup"><span data-stu-id="6effe-215">(A customized collection type in the schema is one that does not use the default namespace, name, repeating element name, or key/value element names.) These types are empty types that derive from Generic <xref:System.Collections.Generic.List%601> for list types and Generic Dictionary for dictionary types.</span></span>

<span data-ttu-id="6effe-216">Örneğin, sunucusunda aşağıdaki türlere sahip olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-216">For example, you may have the following types on the server.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#7](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#7)]
[!code-vb[c_collection_types_in_data_contracts#7](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#7)]

<span data-ttu-id="6effe-217">Şema verildiğinde ve geri aktarıldığında, oluşturulan istemci kodu aşağıdakine benzerdir (okuma kolaylığı için özellikler yerine alanlar gösterilir).</span><span class="sxs-lookup"><span data-stu-id="6effe-217">When the schema is exported and imported back again, the generated client code is similar to the following (fields are shown instead of properties for ease of reading).</span></span>

[!code-csharp[c_collection_types_in_data_contracts#8](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#8)]
[!code-vb[c_collection_types_in_data_contracts#8](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#8)]

<span data-ttu-id="6effe-218">Oluşturulan kodda varsayılan olanlardan farklı türler kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-218">You may want to use different types in generated code than the default ones.</span></span> <span data-ttu-id="6effe-219">Örneğin, <xref:System.ComponentModel.BindingList%601> Kullanıcı arabirimi bileşenlerine bağlamayı kolaylaştırmak için veri üyelerinize ait normal diziler yerine genel ' i kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-219">For example, you may want to use Generic <xref:System.ComponentModel.BindingList%601> instead of regular arrays for your data members to make it easier to bind them to user interface components.</span></span>

<span data-ttu-id="6effe-220">Oluşturulacak koleksiyon türlerini seçmek için <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> <xref:System.Runtime.Serialization.ImportOptions> şemayı içeri aktarırken nesnenin özelliğine kullanmak istediğiniz koleksiyon türlerinin bir listesini geçirin.</span><span class="sxs-lookup"><span data-stu-id="6effe-220">To choose collection types to generate, pass a list of collection types you want to use into the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> property of the <xref:System.Runtime.Serialization.ImportOptions> object when importing schema.</span></span> <span data-ttu-id="6effe-221">Bu türlere *başvurulan koleksiyon türleri*denir.</span><span class="sxs-lookup"><span data-stu-id="6effe-221">These types are called *referenced collection types*.</span></span>

<span data-ttu-id="6effe-222">Genel türlere başvurulduklarında, bunların tamamen açık genel türler veya tam kapalı genel türler olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="6effe-222">When generic types are being referenced, they must either be fully-open generics or fully-closed generics.</span></span>

> [!NOTE]
> <span data-ttu-id="6effe-223">Svcutil. exe aracını kullanırken, bu başvuru **/CollectionType** komut satırı anahtarı kullanılarak gerçekleştirilebilir (kısa biçim: **/CT**).</span><span class="sxs-lookup"><span data-stu-id="6effe-223">When using the Svcutil.exe tool, this reference can be accomplished by using the **/collectionType** command-line switch (short form: **/ct**).</span></span> <span data-ttu-id="6effe-224">Ayrıca, **/Reference** anahtarını kullanarak başvurulan koleksiyon türleri için derlemeyi belirtmeniz gerektiğini unutmayın (kısa biçim: **/r**).</span><span class="sxs-lookup"><span data-stu-id="6effe-224">Keep in mind that you must also specify the assembly for the referenced collection types using the **/reference** switch (short form: **/r**).</span></span> <span data-ttu-id="6effe-225">Tür geneldir ise, arkasından bir geri tırnak işareti ve genel parametre sayısı gelmelidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-225">If the type is generic, it must be followed by a back quote and the number of generic parameters.</span></span> <span data-ttu-id="6effe-226">Arka tırnak ( \` ), tek tırnak (') karakteriyle karıştırılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-226">The back quote (\`) is not to be confused with the single quote (‘) character.</span></span> <span data-ttu-id="6effe-227">**/CollectionType** anahtarını birden çok kez kullanarak, birden fazla başvurulan koleksiyon türünü belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-227">You can specify multiple referenced collection types by using the **/collectionType** switch more than once.</span></span>

<span data-ttu-id="6effe-228">Örneğin, tüm listelerin genel olarak içeri aktarılmasını sağlamak için <xref:System.Collections.Generic.List%601> .</span><span class="sxs-lookup"><span data-stu-id="6effe-228">For example, to cause all lists to be imported as Generic <xref:System.Collections.Generic.List%601>.</span></span>

```console
svcutil.exe MyService.wsdl MyServiceSchema.xsd /r:C:\full_path_to_system_dll\System.dll /ct:System.Collections.Generic.List`1
```

<span data-ttu-id="6effe-229">Herhangi bir koleksiyonu içeri aktarırken, başvurulan koleksiyon türlerinin bu listesi taranır ve bir veri üyesi türü (özelleştirilmemiş koleksiyonlar için) veya türetilmek üzere temel bir tür olarak bulunursa en iyi eşleşen koleksiyon kullanılır (özelleştirilmiş koleksiyonlar için).</span><span class="sxs-lookup"><span data-stu-id="6effe-229">When importing any collection, this list of referenced collection types is scanned, and the best-matching collection is used if one is found, either as a data member type (for non-customized collections) or as a base type to derive from (for customized collections).</span></span> <span data-ttu-id="6effe-230">Sözlükler yalnızca sözlüklere göre eşleşir, ancak listeler listelerle eşleştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-230">Dictionaries are only matched against dictionaries, while lists are matched against lists.</span></span>

<span data-ttu-id="6effe-231">Örneğin, genel <xref:System.ComponentModel.BindingList%601> ve <xref:System.Collections.Hashtable> başvurulan türler listesine eklerseniz, önceki örnek için oluşturulan istemci kodu aşağıdakine benzerdir.</span><span class="sxs-lookup"><span data-stu-id="6effe-231">For example, if you add the Generic <xref:System.ComponentModel.BindingList%601> and <xref:System.Collections.Hashtable> to the list of referenced types, the generated client code for the preceding example is similar to the following.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#9](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#9)]
[!code-vb[c_collection_types_in_data_contracts#9](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#9)]

<span data-ttu-id="6effe-232">Koleksiyon arabirimi türlerini, başvurulan koleksiyon türlerinizin bir parçası olarak belirtebilirsiniz, ancak geçersiz koleksiyon türleri belirtemezsiniz (hiçbir `Add` Yöntem veya ortak Oluşturucu olmayan gibi).</span><span class="sxs-lookup"><span data-stu-id="6effe-232">You can specify collection interface types as part of your referenced collection types, but you cannot specify invalid collection types (such as ones with no `Add` method or public constructor).</span></span>

<span data-ttu-id="6effe-233">Kapalı bir genel, en iyi eşleşme olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-233">A closed generic is considered to be the best match.</span></span> <span data-ttu-id="6effe-234">(Genel olmayan türler kapalı genel türlerine eşdeğer olarak kabul edilir `Object` ).</span><span class="sxs-lookup"><span data-stu-id="6effe-234">(Non-generic types are considered equivalent to closed generics of `Object`).</span></span> <span data-ttu-id="6effe-235">Örneğin, genel türleri genel <xref:System.Collections.Generic.List%601> <xref:System.DateTime> <xref:System.ComponentModel.BindingList%601> (Genel açık) ise ve <xref:System.Collections.ArrayList> başvurulan koleksiyon türse, aşağıdakiler oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="6effe-235">For example, if the types Generic <xref:System.Collections.Generic.List%601> of <xref:System.DateTime>, Generic <xref:System.ComponentModel.BindingList%601> (open generic), and <xref:System.Collections.ArrayList> are the referenced collection types, the following is generated.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#10](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#10)]
[!code-vb[c_collection_types_in_data_contracts#10](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#10)]

<span data-ttu-id="6effe-236">Liste koleksiyonları için yalnızca aşağıdaki tablodaki durumlar desteklenir.</span><span class="sxs-lookup"><span data-stu-id="6effe-236">For list collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="6effe-237">Başvurulan tür</span><span class="sxs-lookup"><span data-stu-id="6effe-237">Referenced type</span></span>|<span data-ttu-id="6effe-238">Başvurulan tür tarafından uygulanan arabirim</span><span class="sxs-lookup"><span data-stu-id="6effe-238">Interface implemented by referenced type</span></span>|<span data-ttu-id="6effe-239">Örnek</span><span class="sxs-lookup"><span data-stu-id="6effe-239">Example</span></span>|<span data-ttu-id="6effe-240">Tür şöyle işlenir:</span><span class="sxs-lookup"><span data-stu-id="6effe-240">Type treated as:</span></span>|
|---------------------|----------------------------------------------|-------------|----------------------|
|<span data-ttu-id="6effe-241">Genel olmayan veya kapalı genel (herhangi bir sayıda parametre)</span><span class="sxs-lookup"><span data-stu-id="6effe-241">Non-generic or closed generic (any number of parameters)</span></span>|<span data-ttu-id="6effe-242">Genel olmayan</span><span class="sxs-lookup"><span data-stu-id="6effe-242">Non-generic</span></span>|`MyType : IList`<br /><br /> <span data-ttu-id="6effe-243">veya</span><span class="sxs-lookup"><span data-stu-id="6effe-243">or</span></span><br /><br /> `MyType<T> : IList`<br /><br /> <span data-ttu-id="6effe-244">Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="6effe-244">where T= `int`</span></span>|<span data-ttu-id="6effe-245">Kapalı genel `Object` (örneğin, `IList<object>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-245">Closed generic of `Object` (for example, `IList<object>`)</span></span>|
|<span data-ttu-id="6effe-246">Genel olmayan veya kapalı genel (koleksiyon türüyle eşleşmesi gerekmeyen parametre sayısı)</span><span class="sxs-lookup"><span data-stu-id="6effe-246">Non-generic or closed generic (any number of parameters that do not necessarily match the collection type)</span></span>|<span data-ttu-id="6effe-247">Kapalı genel</span><span class="sxs-lookup"><span data-stu-id="6effe-247">Closed generic</span></span>|`MyType : IList<string>`<br /><br /> <span data-ttu-id="6effe-248">veya</span><span class="sxs-lookup"><span data-stu-id="6effe-248">or</span></span><br /><br /> <span data-ttu-id="6effe-249">`MyType<T> : IList<string>`Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="6effe-249">`MyType<T> : IList<string>` where T=`int`</span></span>|<span data-ttu-id="6effe-250">Kapalı genel (örneğin, `IList<string>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-250">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="6effe-251">Herhangi bir sayıda parametreyle Genel kapalı</span><span class="sxs-lookup"><span data-stu-id="6effe-251">Closed generic with any number of parameters</span></span>|<span data-ttu-id="6effe-252">Tür parametrelerinden herhangi birini kullanarak genel ' i açın</span><span class="sxs-lookup"><span data-stu-id="6effe-252">Open generic using any one of the type’s parameters</span></span>|`MyType<T,U,V> : IList<U>`<br /><br /> <span data-ttu-id="6effe-253">Burada T = `int` , U = `string` , V =`bool`</span><span class="sxs-lookup"><span data-stu-id="6effe-253">where T=`int`, U=`string`, V=`bool`</span></span>|<span data-ttu-id="6effe-254">Kapalı genel (örneğin, `IList<string>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-254">Closed generic (for example, `IList<string>`)</span></span>|
|<span data-ttu-id="6effe-255">Genel 'i tek bir parametreyle aç</span><span class="sxs-lookup"><span data-stu-id="6effe-255">Open generic with one parameter</span></span>|<span data-ttu-id="6effe-256">Türün parametresini kullanarak genel ' i açın</span><span class="sxs-lookup"><span data-stu-id="6effe-256">Open generic using the type’s parameter</span></span>|<span data-ttu-id="6effe-257">`MyType<T> : IList<T>`, T açık</span><span class="sxs-lookup"><span data-stu-id="6effe-257">`MyType<T> : IList<T>`, T is open</span></span>|<span data-ttu-id="6effe-258">Genel açık (örneğin, `IList<T>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-258">Open generic (for example, `IList<T>`)</span></span>|

<span data-ttu-id="6effe-259">Bir tür birden fazla liste koleksiyonu arabirimi uygularsa, aşağıdaki kısıtlamalar geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="6effe-259">If a type implements more than one list collection interface, the following restrictions apply:</span></span>

- <span data-ttu-id="6effe-260">Tür, <xref:System.Collections.Generic.IEnumerable%601> farklı türlerde genel (veya türetilen arabirimlerini) birden çok kez uygularsa, tür geçerli bir başvurulan koleksiyon türü olarak kabul edilmez ve yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="6effe-260">If the type implements Generic <xref:System.Collections.Generic.IEnumerable%601> (or its derived interfaces) multiple times for different types, the type is not considered a valid referenced collection type and is ignored.</span></span> <span data-ttu-id="6effe-261">Bu, bazı uygulamalar geçersiz olsa bile veya açık genel türler kullanıyorsa geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-261">This is true even if some implementations are invalid or use open generics.</span></span> <span data-ttu-id="6effe-262">Örneğin, genel ' i uygulayan bir tür ya da herhangi bir tür ya da tür bir <xref:System.Collections.Generic.IEnumerable%601> `int` parametre ya <xref:System.Collections.Generic.IEnumerable%601> `int` `Add` `int` `Add` da her ikisi de kabul eden bir yöntem ya da kabul etmeksizin bağımsız olarak, başvurulan bir koleksiyon olarak hiçbir şekilde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="6effe-262">For example, a type that implements Generic <xref:System.Collections.Generic.IEnumerable%601> of `int` and Generic <xref:System.Collections.Generic.IEnumerable%601> of T would never be used as a referenced collection of `int` or any other type, regardless of whether the type has an `Add` method accepting `int` or an `Add` method accepting a parameter of type T, or both.</span></span>

- <span data-ttu-id="6effe-263">Tür bir genel koleksiyon arabirimini de uygularsa <xref:System.Collections.IList> , genel koleksiyon arabirimi türü kapalı bir genel değilse tür hiçbir şekilde başvurulan koleksiyon türü olarak kullanılmaz <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="6effe-263">If the type implements a generic collection interface as well as <xref:System.Collections.IList>, the type is never used as a referenced collection type unless the generic collection interface is a closed generic of type <xref:System.Object>.</span></span>

<span data-ttu-id="6effe-264">Sözlük koleksiyonları için yalnızca aşağıdaki tablodaki durumlar desteklenir.</span><span class="sxs-lookup"><span data-stu-id="6effe-264">For dictionary collections, only the cases in the following table are supported.</span></span>

|<span data-ttu-id="6effe-265">Başvurulan tür</span><span class="sxs-lookup"><span data-stu-id="6effe-265">Referenced type</span></span>|<span data-ttu-id="6effe-266">Başvurulan tür tarafından uygulanan arabirim</span><span class="sxs-lookup"><span data-stu-id="6effe-266">Interface implemented by referenced type</span></span>|<span data-ttu-id="6effe-267">Örnek</span><span class="sxs-lookup"><span data-stu-id="6effe-267">Example</span></span>|<span data-ttu-id="6effe-268">Tür olarak değerlendirildi</span><span class="sxs-lookup"><span data-stu-id="6effe-268">Type treated as</span></span>|
|---------------------|----------------------------------------------|-------------|---------------------|
|<span data-ttu-id="6effe-269">Genel olmayan veya kapalı genel (herhangi bir sayıda parametre)</span><span class="sxs-lookup"><span data-stu-id="6effe-269">Non-generic or closed generic (any number of parameters)</span></span>|<xref:System.Collections.IDictionary>|`MyType : IDictionary`<br /><br /> <span data-ttu-id="6effe-270">veya</span><span class="sxs-lookup"><span data-stu-id="6effe-270">or</span></span><br /><br /> <span data-ttu-id="6effe-271">`MyType<T> : IDictionary`Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="6effe-271">`MyType<T> : IDictionary` where T=`int`</span></span>|<span data-ttu-id="6effe-272">Kapalı genel`IDictionary<object,object>`</span><span class="sxs-lookup"><span data-stu-id="6effe-272">Closed generic `IDictionary<object,object>`</span></span>|
|<span data-ttu-id="6effe-273">Kapalı genel (herhangi bir sayıda parametre)</span><span class="sxs-lookup"><span data-stu-id="6effe-273">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="6effe-274"><xref:System.Collections.Generic.IDictionary%602>, kapalı</span><span class="sxs-lookup"><span data-stu-id="6effe-274"><xref:System.Collections.Generic.IDictionary%602>, closed</span></span>|<span data-ttu-id="6effe-275">`MyType<T> : IDictionary<string, bool>`Burada T =`int`</span><span class="sxs-lookup"><span data-stu-id="6effe-275">`MyType<T> : IDictionary<string, bool>` where T=`int`</span></span>|<span data-ttu-id="6effe-276">Kapalı genel (örneğin, `IDIctionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-276">Closed generic (for example, `IDIctionary<string,bool>`)</span></span>|
|<span data-ttu-id="6effe-277">Kapalı genel (herhangi bir sayıda parametre)</span><span class="sxs-lookup"><span data-stu-id="6effe-277">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="6effe-278">Genel <xref:System.Collections.Generic.IDictionary%602> , herhangi bir anahtar veya değerden biri kapalı, diğeri açık ve türün parametrelerinden birini kullanıyor</span><span class="sxs-lookup"><span data-stu-id="6effe-278">Generic <xref:System.Collections.Generic.IDictionary%602>, one of either key or value is closed, the other is open and uses one of type’s parameters</span></span>|<span data-ttu-id="6effe-279">`MyType<T,U,V> : IDictionary<string,V>`Burada T = `int` , U = `float` , V =`bool`</span><span class="sxs-lookup"><span data-stu-id="6effe-279">`MyType<T,U,V> : IDictionary<string,V>` where T=`int`, U=`float`,V=`bool`</span></span><br /><br /> <span data-ttu-id="6effe-280">veya</span><span class="sxs-lookup"><span data-stu-id="6effe-280">or</span></span><br /><br /> <span data-ttu-id="6effe-281">`MyType<Z> : IDictionary<Z,bool>`Burada Z =`string`</span><span class="sxs-lookup"><span data-stu-id="6effe-281">`MyType<Z> : IDictionary<Z,bool>` where Z=`string`</span></span>|<span data-ttu-id="6effe-282">Kapalı genel (örneğin, `IDictionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-282">Closed generic (For example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="6effe-283">Kapalı genel (herhangi bir sayıda parametre)</span><span class="sxs-lookup"><span data-stu-id="6effe-283">Closed generic (any number of parameters)</span></span>|<span data-ttu-id="6effe-284">Genel <xref:System.Collections.Generic.IDictionary%602> , her iki anahtar ve değer açıktır ve her biri türün parametrelerinden birini kullanır</span><span class="sxs-lookup"><span data-stu-id="6effe-284">Generic <xref:System.Collections.Generic.IDictionary%602>, both key and value are open and each uses one of the type’s parameters</span></span>|<span data-ttu-id="6effe-285">`MyType<T,U,V> : IDictionary<V,U>`Burada T = `int` , U = `bool` , V =`string`</span><span class="sxs-lookup"><span data-stu-id="6effe-285">`MyType<T,U,V> : IDictionary<V,U>` where T=`int`, U=`bool`, V=`string`</span></span>|<span data-ttu-id="6effe-286">Kapalı genel (örneğin, `IDictionary<string,bool>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-286">Closed generic (for example, `IDictionary<string,bool>`)</span></span>|
|<span data-ttu-id="6effe-287">Açık genel (iki parametre)</span><span class="sxs-lookup"><span data-stu-id="6effe-287">Open generic (two parameters)</span></span>|<span data-ttu-id="6effe-288">Genel <xref:System.Collections.Generic.IDictionary%602> , açık, her iki türün genel parametrelerini göründükleri sırada kullanır</span><span class="sxs-lookup"><span data-stu-id="6effe-288">Generic <xref:System.Collections.Generic.IDictionary%602>, open, uses both of the type’s generic parameters in the order they appear</span></span>|<span data-ttu-id="6effe-289">`MyType<K,V> : IDictionary<K,V>`, K ve V her ikisi açık</span><span class="sxs-lookup"><span data-stu-id="6effe-289">`MyType<K,V> : IDictionary<K,V>`, K and V both open</span></span>|<span data-ttu-id="6effe-290">Genel açık (örneğin, `IDictionary<K,V>` )</span><span class="sxs-lookup"><span data-stu-id="6effe-290">Open generic (for example, `IDictionary<K,V>`)</span></span>|

<span data-ttu-id="6effe-291">Tür hem <xref:System.Collections.IDictionary> hem de Generic uygularsa <xref:System.Collections.Generic.IDictionary%602> , yalnızca genel <xref:System.Collections.Generic.IDictionary%602> olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-291">If the type implements both <xref:System.Collections.IDictionary> and Generic <xref:System.Collections.Generic.IDictionary%602>, only Generic <xref:System.Collections.Generic.IDictionary%602> is considered.</span></span>

<span data-ttu-id="6effe-292">Kısmi Genel türlere başvurulması desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="6effe-292">Referencing partial generic types is not supported.</span></span>

<span data-ttu-id="6effe-293">Yinelenen öğelere izin verilmez, örneğin, ' ın hem genel <xref:System.Collections.Generic.List%601> `Integer` hem de genel koleksiyonunu `Integer` <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> ' a ekleyemezsiniz, çünkü bu, şemada bir tamsayılar listesi bulunduğunda hangisini kullanacağınızı belirlemeyi olanaksız hale getirir.</span><span class="sxs-lookup"><span data-stu-id="6effe-293">Duplicates are not allowed, for example, you cannot add both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` to <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, because this makes it impossible to determine which one to use when a list of integers is found in the schema.</span></span> <span data-ttu-id="6effe-294">Yinelemeler, yalnızca şemada yinelenen sorunları ortaya çıkaran bir tür varsa algılanır.</span><span class="sxs-lookup"><span data-stu-id="6effe-294">Duplicates are detected only if there is a type in the schema that exposes the duplicates problem.</span></span> <span data-ttu-id="6effe-295">Örneğin, içeri aktarılan şema tamsayılar listesini içermiyorsa, içinde öğesinin hem genel hem de genel koleksiyonuna sahip olmasına izin verilir, <xref:System.Collections.Generic.List%601> `Integer` `Integer` <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A> ancak hiçbir etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="6effe-295">For example, if the schema being imported does not contain lists of integers, it is allowed to have both the Generic <xref:System.Collections.Generic.List%601> of `Integer` and the Generic Collection of `Integer` in the <xref:System.Runtime.Serialization.ImportOptions.ReferencedCollectionTypes%2A>, but neither has any effect.</span></span>

## <a name="advanced-collection-rules"></a><span data-ttu-id="6effe-296">Gelişmiş koleksiyon kuralları</span><span class="sxs-lookup"><span data-stu-id="6effe-296">Advanced Collection Rules</span></span>

### <a name="serializing-collections"></a><span data-ttu-id="6effe-297">Koleksiyonlar serileştiriliyor</span><span class="sxs-lookup"><span data-stu-id="6effe-297">Serializing Collections</span></span>

<span data-ttu-id="6effe-298">Serileştirme için koleksiyon kurallarının bir listesi aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="6effe-298">The following is a list of collection rules for serialization:</span></span>

- <span data-ttu-id="6effe-299">Koleksiyon türlerini (koleksiyon koleksiyonlarına sahip) birleştirmek için izin verilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-299">Combining collection types (having collections of collections) is allowed.</span></span> <span data-ttu-id="6effe-300">Pürüzlü Diziler koleksiyonların koleksiyonları olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-300">Jagged arrays are treated as collections of collections.</span></span> <span data-ttu-id="6effe-301">Çok boyutlu diziler desteklenmiyor.</span><span class="sxs-lookup"><span data-stu-id="6effe-301">Multidimensional arrays are not supported.</span></span>

- <span data-ttu-id="6effe-302">Bayt ve dizi dizileri <xref:System.Xml.XmlNode> , Koleksiyonlar değil, temel öğeler olarak kabul edilen özel dizi türlerdir.</span><span class="sxs-lookup"><span data-stu-id="6effe-302">Arrays of byte and arrays of <xref:System.Xml.XmlNode> are special array types that are treated as primitives, not collections.</span></span> <span data-ttu-id="6effe-303">Bir bayt dizisini seri hale getirmek, her bayt için ayrı bir öğe yerine Base64 kodlamalı verilerin bir öbeğini içeren tek bir XML öğesinde sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="6effe-303">Serializing an array of byte results in a single XML element that contains a chunk of Base64-encoded data, instead of a separate element for each byte.</span></span> <span data-ttu-id="6effe-304">Dizisinin nasıl işlendiği hakkında daha fazla bilgi için <xref:System.Xml.XmlNode> bkz. [Data Contracts 'de XML ve ADO.net Types](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="6effe-304">For more information about how an array of <xref:System.Xml.XmlNode> is treated, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span> <span data-ttu-id="6effe-305">Tabii ki, bu özel türler kendilerine katılabilirler: bir bayt dizisi dizisi, her biri Base64 kodlamalı verilerin bir öbeğini içeren birden çok XML öğesiyle sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="6effe-305">Of course, these special types can themselves participate in collections: an array of array of byte results in multiple XML elements, with each containing a chunk of Base64-encoded data.</span></span>

- <span data-ttu-id="6effe-306"><xref:System.Runtime.Serialization.DataContractAttribute>Öznitelik bir koleksiyon türüne uygulanırsa, tür bir koleksiyon olarak değil, düzenli bir veri anlaşması türü olarak değerlendirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-306">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a collection type, the type is treated as a regular data contract type, not as a collection.</span></span>

- <span data-ttu-id="6effe-307">Bir koleksiyon türü arabirimini uyguluyorsa <xref:System.Xml.Serialization.IXmlSerializable> , aşağıdaki kurallar bir tür verildiğinde geçerlidir `myType:IList<string>, IXmlSerializable` :</span><span class="sxs-lookup"><span data-stu-id="6effe-307">If a collection type implements the <xref:System.Xml.Serialization.IXmlSerializable> interface, the following rules apply, given a type `myType:IList<string>, IXmlSerializable`:</span></span>

  - <span data-ttu-id="6effe-308">Belirtilen tür ise, `IList<string>` tür bir liste olarak serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-308">If the declared type is `IList<string>`, the type is serialized as a list.</span></span>

  - <span data-ttu-id="6effe-309">Belirtilen tür ise `myType` olarak serileştirilir `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="6effe-309">If the declared type is `myType`, it is serialized as `IXmlSerializable`.</span></span>

  - <span data-ttu-id="6effe-310">Belirtilen tür ise, `IXmlSerializable` `IXmlSerializable` ancak yalnızca bilinen türler listesine eklediğinizde olarak serileştirilir `myType` .</span><span class="sxs-lookup"><span data-stu-id="6effe-310">If the declared type is `IXmlSerializable`, it is serialized as `IXmlSerializable`, but only if you add `myType` to the list of known types.</span></span>

- <span data-ttu-id="6effe-311">Koleksiyonlar serileştirilir ve aşağıdaki tabloda gösterilen yöntemler kullanılarak seri durumdan çıkarılmakta.</span><span class="sxs-lookup"><span data-stu-id="6effe-311">Collections are serialized and deserialized using the methods shown in the following table.</span></span>

|<span data-ttu-id="6effe-312">Koleksiyon türü uygular</span><span class="sxs-lookup"><span data-stu-id="6effe-312">Collection type implements</span></span>|<span data-ttu-id="6effe-313">Serileştirme sırasında çağrılan Yöntem (ler)</span><span class="sxs-lookup"><span data-stu-id="6effe-313">Method(s) called on serialization</span></span>|<span data-ttu-id="6effe-314">Seri durumdan çıkarma sırasında çağrılan metot (ler)</span><span class="sxs-lookup"><span data-stu-id="6effe-314">Method(s) called on deserialization</span></span>|
|--------------------------------|-----------------------------------------|-------------------------------------------|
|<span data-ttu-id="6effe-315">Yorlar<xref:System.Collections.Generic.IDictionary%602></span><span class="sxs-lookup"><span data-stu-id="6effe-315">Generic <xref:System.Collections.Generic.IDictionary%602></span></span>|<span data-ttu-id="6effe-316">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="6effe-316">`get_Keys`, `get_Values`</span></span>|<span data-ttu-id="6effe-317">Genel ekleme</span><span class="sxs-lookup"><span data-stu-id="6effe-317">Generic Add</span></span>|
|<xref:System.Collections.IDictionary>|<span data-ttu-id="6effe-318">`get_Keys`, `get_Values`</span><span class="sxs-lookup"><span data-stu-id="6effe-318">`get_Keys`, `get_Values`</span></span>|`Add`|
|<span data-ttu-id="6effe-319">Yorlar<xref:System.Collections.Generic.IList%601></span><span class="sxs-lookup"><span data-stu-id="6effe-319">Generic <xref:System.Collections.Generic.IList%601></span></span>|<span data-ttu-id="6effe-320">Genel <xref:System.Collections.Generic.IList%601> Dizin Oluşturucu</span><span class="sxs-lookup"><span data-stu-id="6effe-320">Generic <xref:System.Collections.Generic.IList%601> indexer</span></span>|<span data-ttu-id="6effe-321">Genel ekleme</span><span class="sxs-lookup"><span data-stu-id="6effe-321">Generic Add</span></span>|
|<span data-ttu-id="6effe-322">Yorlar<xref:System.Collections.Generic.ICollection%601></span><span class="sxs-lookup"><span data-stu-id="6effe-322">Generic <xref:System.Collections.Generic.ICollection%601></span></span>|<span data-ttu-id="6effe-323">Sının</span><span class="sxs-lookup"><span data-stu-id="6effe-323">Enumerator</span></span>|<span data-ttu-id="6effe-324">Genel ekleme</span><span class="sxs-lookup"><span data-stu-id="6effe-324">Generic Add</span></span>|
|<xref:System.Collections.IList>|<span data-ttu-id="6effe-325"><xref:System.Collections.IList>Dizinleyic</span><span class="sxs-lookup"><span data-stu-id="6effe-325"><xref:System.Collections.IList> Indexer</span></span>|`Add`|
|<span data-ttu-id="6effe-326">Yorlar<xref:System.Collections.Generic.IEnumerable%601></span><span class="sxs-lookup"><span data-stu-id="6effe-326">Generic <xref:System.Collections.Generic.IEnumerable%601></span></span>|`GetEnumerator`|<span data-ttu-id="6effe-327">`Add`Uygun türde (genel parametrenin türü veya temel türlerinden biri) bir parametre alan, statik olmayan bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="6effe-327">A non-static method called `Add` that takes one parameter of the appropriate type (the type of the generic parameter or one of its base types).</span></span> <span data-ttu-id="6effe-328">Seri hale getirici, hem serileştirme hem de seri durumundan çıkarma sırasında koleksiyon türünü bir koleksiyon olarak değerlendirmek için bu tür bir yöntem bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-328">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|
|<span data-ttu-id="6effe-329"><xref:System.Collections.IEnumerable>(ve <xref:System.Collections.ICollection> Bu nedenle ondan türetilen)</span><span class="sxs-lookup"><span data-stu-id="6effe-329"><xref:System.Collections.IEnumerable> (and thus <xref:System.Collections.ICollection>, which derives from it)</span></span>|`GetEnumerator`|<span data-ttu-id="6effe-330">`Add`Türünde bir parametre alan, statik olmayan bir yöntem `Object` .</span><span class="sxs-lookup"><span data-stu-id="6effe-330">A non-static method called `Add` that takes one parameter of type `Object`.</span></span> <span data-ttu-id="6effe-331">Seri hale getirici, hem serileştirme hem de seri durumundan çıkarma sırasında koleksiyon türünü bir koleksiyon olarak değerlendirmek için bu tür bir yöntem bulunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-331">Such a method must exist for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>|

<span data-ttu-id="6effe-332">Yukarıdaki tabloda, koleksiyon arabirimleri azalan öncelik sırasına göre listelenmiştir.</span><span class="sxs-lookup"><span data-stu-id="6effe-332">The preceding table lists collection interfaces in descending order of precedence.</span></span> <span data-ttu-id="6effe-333">Bu, örneğin, bir tür hem hem de Generic uygularsa <xref:System.Collections.IList> <xref:System.Collections.Generic.IEnumerable%601> , koleksiyonun serileştirildiği ve bu kurallara göre seri durumdan çıkarılmasıdır <xref:System.Collections.IList> .</span><span class="sxs-lookup"><span data-stu-id="6effe-333">This means, for example, that if a type implements both <xref:System.Collections.IList> and Generic <xref:System.Collections.Generic.IEnumerable%601>, the collection is serialized and deserialized according to the <xref:System.Collections.IList> rules:</span></span>

- <span data-ttu-id="6effe-334">Seri durumdan çıkarma sırasında, seri hale getiricinin hem serileştirme hem de seri durumundan çıkarma sırasında koleksiyon türünü bir koleksiyon olarak işlemesi için mevcut olması gereken parametresiz oluşturucuyu çağırarak bir türün örneği oluşturularak, tüm koleksiyonların serisi kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="6effe-334">At deserialization, all collections are deserialized by first creating an instance of the type by calling the parameterless constructor, which must be present for the serializer to treat a collection type as a collection during both serialization and deserialization.</span></span>

- <span data-ttu-id="6effe-335">Aynı genel koleksiyon arabirimi birden çok kez uygulanırsa (örneğin, bir tür hem genel hem de genel ' i uygularsa <xref:System.Collections.Generic.ICollection%601> `Integer` <xref:System.Collections.Generic.ICollection%601> <xref:System.String> ) ve daha yüksek öncelikli bir arabirim bulunamazsa, koleksiyon geçerli bir koleksiyon olarak değerlendirilmez.</span><span class="sxs-lookup"><span data-stu-id="6effe-335">If the same generic collection interface is implemented more than once (for example, if a type implements both Generic <xref:System.Collections.Generic.ICollection%601> of `Integer` and Generic <xref:System.Collections.Generic.ICollection%601> of <xref:System.String>) and no higher-precedence interface is found, the collection is not treated as a valid collection.</span></span>

- <span data-ttu-id="6effe-336">Koleksiyon türlerinde, <xref:System.SerializableAttribute> özniteliğe uygulanan özniteliği bulunabilir ve <xref:System.Runtime.Serialization.ISerializable> arabirimi uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-336">Collection types can have the <xref:System.SerializableAttribute> attribute applied to them and can implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span> <span data-ttu-id="6effe-337">Bunların her ikisi de yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="6effe-337">Both of these are ignored.</span></span> <span data-ttu-id="6effe-338">Ancak, tür koleksiyon türü gereksinimlerini tam olarak karşılamıyorsa (örneğin, `Add` yöntemi eksikse), tür bir koleksiyon türü olarak değerlendirilmez ve bu nedenle, <xref:System.SerializableAttribute> <xref:System.Runtime.Serialization.ISerializable> türün seri hale getirilebilir olup olmadığını belirlemekte öznitelik ve arabirim kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6effe-338">However, if the type does not fully meet collection type requirements (for example, the `Add` method is missing), the type is not considered a collection type, and thus the <xref:System.SerializableAttribute> attribute and the <xref:System.Runtime.Serialization.ISerializable> interface are used to determine whether the type can be serialized.</span></span>

- <span data-ttu-id="6effe-339"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Özniteliğini özelleştirmek için bir koleksiyona özniteliği uygulamak, <xref:System.SerializableAttribute> önceki geri dönüş mekanizmasını kaldırır.</span><span class="sxs-lookup"><span data-stu-id="6effe-339">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a collection to customize it removes the <xref:System.SerializableAttribute> preceding fallback mechanism.</span></span> <span data-ttu-id="6effe-340">Bunun yerine, özelleştirilmiş bir koleksiyon koleksiyon türü gereksinimlerini karşılamıyorsa, bir <xref:System.Runtime.Serialization.InvalidDataContractException> özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="6effe-340">Instead, if a customized collection does not meet collection type requirements, an <xref:System.Runtime.Serialization.InvalidDataContractException> exception is thrown.</span></span> <span data-ttu-id="6effe-341">Özel durum dizesi genellikle belirli bir türün geçerli bir koleksiyon (hiçbir yöntem yok, parametresiz Oluşturucu vb.) olarak kabul edilmediğini açıklayan bilgileri içerir `Add` . bu nedenle, genellikle <xref:System.Runtime.Serialization.CollectionDataContractAttribute> hata ayıklama amacıyla özniteliği uygulamak yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="6effe-341">The exception string often contains information that explains why a given type is not considered a valid collection (no `Add` method, no parameterless constructor, and so on), so it is often useful to apply the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute for debugging purposes.</span></span>

### <a name="collection-naming"></a><span data-ttu-id="6effe-342">Koleksiyon adlandırma</span><span class="sxs-lookup"><span data-stu-id="6effe-342">Collection Naming</span></span>

<span data-ttu-id="6effe-343">Aşağıda, koleksiyon adlandırma kurallarının bir listesi verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="6effe-343">The following is a list of collection naming rules:</span></span>

- <span data-ttu-id="6effe-344">Tüm sözlük toplama verileri sözleşmeleri için varsayılan ad alanı ve temel türler içeren liste toplama veri sözleşmeleri için `http://schemas.microsoft.com/2003/10/Serialization/Arrays` ad alanı kullanılarak geçersiz kılınmadığı sürece.</span><span class="sxs-lookup"><span data-stu-id="6effe-344">The default namespace for all dictionary collection data contracts, as well as for list collection data contracts that contain primitive types, is `http://schemas.microsoft.com/2003/10/Serialization/Arrays` unless overridden using Namespace.</span></span> <span data-ttu-id="6effe-345">Yerleşik XSD türlerine `char` `Timespan` ve, ve türlerine eşlenen türler `Guid` , bu amaçla temel elemanlar olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-345">Types that map to built-in XSD types, as well as `char`, `Timespan`, and `Guid` types, are considered primitives for this purpose.</span></span>

- <span data-ttu-id="6effe-346">Ad alanı kullanılarak geçersiz kılınmadığı sürece, ilkel olmayan türler içeren koleksiyon türleri için varsayılan ad alanı, koleksiyonda yer alan türdeki veri sözleşmesi ad alanıyla aynıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-346">The default namespace for collection types that contain non-primitive types, unless it is overridden using Namespace, is the same as the data contract namespace of the type contained in the collection.</span></span>

- <span data-ttu-id="6effe-347">Ad kullanılarak geçersiz kılınmadığı takdirde, liste toplama veri sözleşmeleri için varsayılan ad, koleksiyonda bulunan türün veri sözleşmesi adıyla birlikte "ArrayOf" dizesidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-347">The default name for list collection data contracts, unless overridden using Name, is the string "ArrayOf" combined with the data contract name of the type contained in the collection.</span></span> <span data-ttu-id="6effe-348">Örneğin, genel tamsayılar listesinin veri sözleşme adı "Arrayofınt" ' dir.</span><span class="sxs-lookup"><span data-stu-id="6effe-348">For example, the data contract name for a Generic List of Integers is "ArrayOfint".</span></span> <span data-ttu-id="6effe-349">Veri sözleşmesi adının `Object` "anyType" olduğunu ve bu nedenle genel olmayan listelerin veri sözleşmesi adının <xref:System.Collections.ArrayList> "ArrayOfanyType" olduğunu aklınızda bulundurun.</span><span class="sxs-lookup"><span data-stu-id="6effe-349">Keep in mind that the data contract name of `Object` is "anyType", so the data contract name of non-generic lists like <xref:System.Collections.ArrayList> is "ArrayOfanyType".</span></span>

<span data-ttu-id="6effe-350">Sözlük toplama veri sözleşmeleri için varsayılan ad, kullanılarak geçersiz kılınmamışsa `Name` , anahtar türünün veri sözleşmesi adı ile birleştirilmiş "Arrayofkeyary" dizesidir ve ardından değer türünün veri sözleşmesi adı gelir.</span><span class="sxs-lookup"><span data-stu-id="6effe-350">The default name for dictionary collection data contracts, unless overridden using `Name`, is the string "ArrayOfKeyValueOf" combined with the data contract name of the key type followed by the data contract name of the value type.</span></span> <span data-ttu-id="6effe-351">Örneğin, bir dize ve tamsayı genel sözlüğünün veri sözleşme adı "Arrayofkeyvalueofstringınt" ' dir.</span><span class="sxs-lookup"><span data-stu-id="6effe-351">For example, the data contract name for a Generic Dictionary of String and Integer is "ArrayOfKeyValueOfstringint".</span></span> <span data-ttu-id="6effe-352">Ayrıca, anahtar veya değer türleri basit türler değilse, anahtar ve değer türlerinin veri sözleşmesi ad alanlarının ad alanı karması ada eklenir.</span><span class="sxs-lookup"><span data-stu-id="6effe-352">Additionally, if either the key or the value types are not primitive types, a namespace hash of the data contract namespaces of the key and value types is appended to the name.</span></span> <span data-ttu-id="6effe-353">Ad alanı karmaları hakkında daha fazla bilgi için bkz. [veri sözleşmesi adları](data-contract-names.md).</span><span class="sxs-lookup"><span data-stu-id="6effe-353">For more information about namespace hashes, see [Data Contract Names](data-contract-names.md).</span></span>

<span data-ttu-id="6effe-354">Her sözlük toplama veri sözleşmesinin, Sözlükteki bir girişi temsil eden bir yardımcı veri sözleşmesi vardır.</span><span class="sxs-lookup"><span data-stu-id="6effe-354">Each dictionary collection data contract has a companion data contract that represents one entry in the dictionary.</span></span> <span data-ttu-id="6effe-355">Adı, sözlük veri sözleşmesi ile aynıdır, "ArrayOf" öneki hariç ve ad alanı sözlük veri sözleşmesiyle aynı.</span><span class="sxs-lookup"><span data-stu-id="6effe-355">Its name is the same as for the dictionary data contract, except for the "ArrayOf" prefix, and its namespace is the same as for the dictionary data contract.</span></span> <span data-ttu-id="6effe-356">Örneğin, "Arrayofkeyvalueofstringınt" Sözlük veri sözleşmesi için, "Keyvalueofstringınt" veri sözleşmesi sözlükte bir girişi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="6effe-356">For example, for the "ArrayOfKeyValueOfstringint" dictionary data contract, the "KeyValueofstringint" data contract represents one entry in the dictionary.</span></span> <span data-ttu-id="6effe-357">Bu veri sözleşmesinin adını `ItemName` , sonraki bölümde açıklandığı gibi özelliğini kullanarak özelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-357">You can customize the name of this data contract by using the `ItemName` property, as described in the next section.</span></span>

<span data-ttu-id="6effe-358">Genel tür adlandırma kuralları, [veri anlaşması adlarında](data-contract-names.md)açıklandığı gibi, koleksiyon türlerine tam olarak uygulanır; diğer bir deyişle, genel tür parametrelerini göstermek için ad içinde küme ayraçları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6effe-358">Generic type naming rules, as described in [Data Contract Names](data-contract-names.md), fully apply to collection types; that is, you can use curly braces within Name to indicate generic type parameters.</span></span> <span data-ttu-id="6effe-359">Ancak, küme ayraçları içindeki sayılar, koleksiyonda yer alan türler değil genel parametrelere başvurur.</span><span class="sxs-lookup"><span data-stu-id="6effe-359">However, numbers within the braces refer to generic parameters and not types contained within the collection.</span></span>

## <a name="collection-customization"></a><span data-ttu-id="6effe-360">Koleksiyon özelleştirmesi</span><span class="sxs-lookup"><span data-stu-id="6effe-360">Collection Customization</span></span>

<span data-ttu-id="6effe-361">Aşağıdaki <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliğin kullanımları yasaktır ve bir <xref:System.Runtime.Serialization.InvalidDataContractException> özel durumla sonuçlanır:</span><span class="sxs-lookup"><span data-stu-id="6effe-361">The following uses of the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute are forbidden and result in an <xref:System.Runtime.Serialization.InvalidDataContractException> exception:</span></span>

- <span data-ttu-id="6effe-362">Özniteliği, <xref:System.Runtime.Serialization.DataContractAttribute> <xref:System.Runtime.Serialization.CollectionDataContractAttribute> özniteliğin uygulandığı bir türe veya türetilen türlerden birine uygulama.</span><span class="sxs-lookup"><span data-stu-id="6effe-362">Applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to a type to which the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute has been applied, or to one of its derived types.</span></span>

- <span data-ttu-id="6effe-363"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Özniteliğini arabirimini uygulayan bir türe uygulama <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="6effe-363">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a type that implements the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="6effe-364"><xref:System.Runtime.Serialization.CollectionDataContractAttribute>Öznitelik koleksiyon olmayan bir türe uygulanıyor.</span><span class="sxs-lookup"><span data-stu-id="6effe-364">Applying the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute to a non-collection type.</span></span>

- <span data-ttu-id="6effe-365"><xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> <xref:System.Runtime.Serialization.CollectionDataContractAttribute> Sözlük olmayan bir türe uygulanan bir özniteliği ayarlamaya çalışılıyor.</span><span class="sxs-lookup"><span data-stu-id="6effe-365">Attempting to set <xref:System.Runtime.Serialization.CollectionDataContractAttribute.KeyName%2A> or <xref:System.Runtime.Serialization.CollectionDataContractAttribute.ValueName%2A> on a <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute applied to a non-dictionary type.</span></span>

### <a name="polymorphism-rules"></a><span data-ttu-id="6effe-366">Çok biçimlilik kuralları</span><span class="sxs-lookup"><span data-stu-id="6effe-366">Polymorphism Rules</span></span>

<span data-ttu-id="6effe-367">Daha önce belirtildiği gibi, özniteliği kullanarak koleksiyonları özelleştirmek <xref:System.Runtime.Serialization.CollectionDataContractAttribute> koleksiyon interchangeability etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-367">As previously mentioned, customizing collections by using the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> attribute may interfere with collection interchangeability.</span></span> <span data-ttu-id="6effe-368">İki özelleştirilmiş koleksiyon türü yalnızca ad, ad alanı, öğe adı ve anahtar ve değer adları (sözlük koleksiyonları ise) eşleşiyorsa eşit kabul edilebilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-368">Two customized collection types can only be considered equivalent if their name, namespace, item name, as well as key and value names (if these are dictionary collections) match.</span></span>

<span data-ttu-id="6effe-369">Özelleştirmeler nedeniyle, başka bir koleksiyon veri sözleşmesinin beklenen bir şekilde kullanılması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="6effe-369">Due to customizations, it is possible to inadvertently use one collection data contract where another is expected.</span></span> <span data-ttu-id="6effe-370">Bunun kaçınılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="6effe-370">This should be avoided.</span></span> <span data-ttu-id="6effe-371">Aşağıdaki türlere bakın.</span><span class="sxs-lookup"><span data-stu-id="6effe-371">See the following types.</span></span>

[!code-csharp[c_collection_types_in_data_contracts#11](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_collection_types_in_data_contracts/cs/program.cs#11)]
[!code-vb[c_collection_types_in_data_contracts#11](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_collection_types_in_data_contracts/vb/program.vb#11)]

<span data-ttu-id="6effe-372">Bu durumda, öğesinin bir örneği `Marks1` atanabilir `testMarks` .</span><span class="sxs-lookup"><span data-stu-id="6effe-372">In this case, an instance of `Marks1` can be assigned to `testMarks`.</span></span> <span data-ttu-id="6effe-373">Ancak, veri `Marks2` sözleşmesi veri sözleşmesine eşit kabul edilmediğinden kullanılmamalıdır `IList<int>` .</span><span class="sxs-lookup"><span data-stu-id="6effe-373">However, `Marks2` should not be used because its data contract is not considered equivalent to the `IList<int>` data contract.</span></span> <span data-ttu-id="6effe-374">Veri sözleşmesinin adı "Marks2" ve "Arrayofınt" değil ve yinelenen öğe adı "" ve "" değil \<mark> \<int> .</span><span class="sxs-lookup"><span data-stu-id="6effe-374">The data contract name is "Marks2" and not "ArrayOfint", and the repeating element name is "\<mark>" and not "\<int>".</span></span>

<span data-ttu-id="6effe-375">Aşağıdaki tablodaki kurallar, koleksiyonların çok biçimli atama için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-375">The rules in the following table apply to polymorphic assignment of collections.</span></span>

|<span data-ttu-id="6effe-376">Bildirilmeyen tür</span><span class="sxs-lookup"><span data-stu-id="6effe-376">Declared type</span></span>|<span data-ttu-id="6effe-377">Özelleştirilmemiş bir koleksiyon atama</span><span class="sxs-lookup"><span data-stu-id="6effe-377">Assigning a non-customized collection</span></span>|<span data-ttu-id="6effe-378">Özelleştirilmiş bir koleksiyon atama</span><span class="sxs-lookup"><span data-stu-id="6effe-378">Assigning a customized collection</span></span>|
|-------------------|--------------------------------------------|---------------------------------------|
|<span data-ttu-id="6effe-379">Nesne</span><span class="sxs-lookup"><span data-stu-id="6effe-379">Object</span></span>|<span data-ttu-id="6effe-380">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-380">Contract name is serialized.</span></span>|<span data-ttu-id="6effe-381">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-381">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="6effe-382">Özelleştirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6effe-382">Customization is used.</span></span>|
|<span data-ttu-id="6effe-383">Koleksiyon arabirimi</span><span class="sxs-lookup"><span data-stu-id="6effe-383">Collection interface</span></span>|<span data-ttu-id="6effe-384">Sözleşme adı serileştirilmedi.</span><span class="sxs-lookup"><span data-stu-id="6effe-384">Contract name is not serialized.</span></span>|<span data-ttu-id="6effe-385">Sözleşme adı serileştirilmedi.</span><span class="sxs-lookup"><span data-stu-id="6effe-385">Contract name is not serialized.</span></span><br /><br /> <span data-ttu-id="6effe-386">Özelleştirme kullanılmıyor.\*</span><span class="sxs-lookup"><span data-stu-id="6effe-386">Customization is not used.\*</span></span>|
|<span data-ttu-id="6effe-387">Özelleştirilmeyen koleksiyon</span><span class="sxs-lookup"><span data-stu-id="6effe-387">Non-customized collection</span></span>|<span data-ttu-id="6effe-388">Sözleşme adı serileştirilmedi.</span><span class="sxs-lookup"><span data-stu-id="6effe-388">Contract name is not serialized.</span></span>|<span data-ttu-id="6effe-389">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-389">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="6effe-390">Özelleştirme kullanılıyor. \* \*</span><span class="sxs-lookup"><span data-stu-id="6effe-390">Customization is used.\*\*</span></span>|
|<span data-ttu-id="6effe-391">Özelleştirilmiş koleksiyon</span><span class="sxs-lookup"><span data-stu-id="6effe-391">Customized collection</span></span>|<span data-ttu-id="6effe-392">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-392">Contract name is serialized.</span></span> <span data-ttu-id="6effe-393">Özelleştirme kullanılmıyor.\*\*</span><span class="sxs-lookup"><span data-stu-id="6effe-393">Customization is not used.\*\*</span></span>|<span data-ttu-id="6effe-394">Sözleşme adı serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-394">Contract name is serialized.</span></span><br /><br /> <span data-ttu-id="6effe-395">Atanan tür özelleştirmesi kullanılır.\*\*</span><span class="sxs-lookup"><span data-stu-id="6effe-395">Customization of the assigned type is used.\*\*</span></span>|

<span data-ttu-id="6effe-396">\*Sınıfı ile <xref:System.Runtime.Serialization.NetDataContractSerializer> , bu durumda özelleştirme kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6effe-396">\*With the <xref:System.Runtime.Serialization.NetDataContractSerializer> class, customization is used in this case.</span></span> <span data-ttu-id="6effe-397"><xref:System.Runtime.Serialization.NetDataContractSerializer>Sınıf Ayrıca bu durumda gerçek tür adını serileştirir, bu nedenle seri kaldırma beklendiği gibi çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="6effe-397">The <xref:System.Runtime.Serialization.NetDataContractSerializer> class also serializes the actual type name in this case, so deserialization works as expected.</span></span>

<span data-ttu-id="6effe-398">\*\*Bu durumlar, şema geçersiz örneklerle sonuçlanır ve bu nedenle kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-398">\*\*These cases result in schema-invalid instances and thus should be avoided.</span></span>

<span data-ttu-id="6effe-399">Anlaşma adının seri hale getirilme durumunda, atanan koleksiyon türü bilinen türler listesinde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-399">In the cases where the contract name is serialized, the assigned collection type should be in the known types list.</span></span> <span data-ttu-id="6effe-400">Tersi de geçerlidir: adın seri hale getirilmediği durumlarda, türü bilinen türler listesine eklemek gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="6effe-400">The opposite is also true: in the cases where the name is not serialized, adding the type to the known types list is not required.</span></span>

<span data-ttu-id="6effe-401">Türetilmiş türdeki bir dizi, temel tür dizisine atanabilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-401">An array of a derived type can be assigned to an array of a base type.</span></span> <span data-ttu-id="6effe-402">Bu durumda, türetilmiş türün anlaşma adı her bir yinelenen öğe için serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="6effe-402">In this case, the contract name for the derived type is serialized for each repeating element.</span></span> <span data-ttu-id="6effe-403">Örneğin, bir tür türünden `Book` türetiliyor, dizisine bir `LibraryItem` dizisi atayabilirsiniz `Book` `LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="6effe-403">For example, if a type `Book` derives from the type `LibraryItem`, you can assign an array of `Book` to an array of `LibraryItem`.</span></span> <span data-ttu-id="6effe-404">Bu, diğer koleksiyon türleri için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-404">This does not apply to other collection types.</span></span> <span data-ttu-id="6effe-405">Örneğin, bir `Generic List of Book` öğesine atayamazsınız `Generic List of LibraryItem` .</span><span class="sxs-lookup"><span data-stu-id="6effe-405">For example, you cannot assign a `Generic List of Book` to a `Generic List of LibraryItem`.</span></span> <span data-ttu-id="6effe-406">Bununla birlikte, örnek içeren bir de atayabilirsiniz `Generic List of LibraryItem` `Book` .</span><span class="sxs-lookup"><span data-stu-id="6effe-406">You can, however, assign a `Generic List of LibraryItem` that contains `Book` instances.</span></span> <span data-ttu-id="6effe-407">Hem dizide hem de dizi olmayan durumda, `Book` bilinen türler listesinde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6effe-407">In both the array and the non-array case, `Book` should be in the known types list.</span></span>

## <a name="collections-and-object-reference-preservation"></a><span data-ttu-id="6effe-408">Koleksiyonlar ve nesne başvuru koruması</span><span class="sxs-lookup"><span data-stu-id="6effe-408">Collections and Object Reference Preservation</span></span>

<span data-ttu-id="6effe-409">Seri hale getirici, nesne başvurularını koruyan bir modda işlevler, nesne başvurusu koruması da koleksiyonlar için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="6effe-409">When a serializer functions in a mode where it preserves object references, object reference preservation also applies to collections.</span></span> <span data-ttu-id="6effe-410">Özellikle, nesne kimliği tüm koleksiyonlar ve koleksiyonlarda bulunan bireysel öğeler için korunur.</span><span class="sxs-lookup"><span data-stu-id="6effe-410">Specifically, object identity is preserved for both entire collections and individual items contained in collections.</span></span> <span data-ttu-id="6effe-411">Sözlüklerde, nesne kimliği hem anahtar/değer çifti nesneleri hem de tek anahtar ve değer nesneleri için korunur.</span><span class="sxs-lookup"><span data-stu-id="6effe-411">For dictionaries, object identity is preserved both for the key/value pair objects and the individual key and value objects.</span></span>

## <a name="see-also"></a><span data-ttu-id="6effe-412">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="6effe-412">See also</span></span>

- <xref:System.Runtime.Serialization.CollectionDataContractAttribute>
