---
title: Sunucusuz mimari değerlendirmeleri-sunucusuz uygulamalar
description: Durum yönetiminden ve kalıcı depolamadan, genişleme, günlüğe kaydetme, izleme ve Tanılama için sunucusuz uygulamalar tasarlama sorunlarını anlayın.
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c856683cf6910be98661e634246cd003b93a6d76
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/08/2019
ms.locfileid: "72522429"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="eecd1-103">Sunucusuz mimaride dikkat edilmesi gerekenler</span><span class="sxs-lookup"><span data-stu-id="eecd1-103">Serverless architecture considerations</span></span>

<span data-ttu-id="eecd1-104">Sunucusuz bir mimariyi benimsemek, bazı güçlüklerle birlikte gelir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="eecd1-105">Bu bölümde, dikkat edilmesi gereken bazı yaygın hususlar incelenmektedir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="eecd1-106">Bu güçlüklerin tümünde çözüm vardır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-106">All of these challenges have solutions.</span></span> <span data-ttu-id="eecd1-107">Tüm mimari seçimlerinin yanı sıra, go sunucusuz kararı yalnızca, olumlu ve dezavantajların dikkatle ele alındıktan sonra yapılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="eecd1-108">Uygulamanızın ihtiyaçlarına bağlı olarak, bir sunucusuz uygulamanın belirli bileşenler için doğru çözüm olmadığını belirleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="eecd1-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="eecd1-109">Durumu yönetme</span><span class="sxs-lookup"><span data-stu-id="eecd1-109">Managing state</span></span>

<span data-ttu-id="eecd1-110">Mikro hizmetlerde olduğu gibi sunucusuz işlevler varsayılan olarak durum bilgisiz değildir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="eecd1-111">Önleme durumu sunucusuz 'ın daha kısa olmasını, ölçeğini genişletmek ve merkezi bir hata noktası olmadan dayanıklılık sağlamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="eecd1-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="eecd1-112">Bazı durumlarda, iş süreçlerini durum gerektirir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="eecd1-113">İşleminiz durum gerektiriyorsa, iki seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="eecd1-114">Sunucusuz dışında bir modeli benimseyebilirsiniz veya durum sağlayan ayrı bir hizmetle etkileşim kurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="eecd1-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="eecd1-115">Durum eklemek çözümü karmaşıklaştırır ve ölçeği daha zor hale getirebilir ve tek bir hata noktası oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="eecd1-116">İşlevinizin kesinlikle durum gerektirip gerektirmediğini dikkatle düşünün.</span><span class="sxs-lookup"><span data-stu-id="eecd1-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="eecd1-117">Yanıt "Evet" ise, bunu sunucusuz ile uygulamayı hala mantıklı olup olmadığını saptayın.</span><span class="sxs-lookup"><span data-stu-id="eecd1-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="eecd1-118">Sunucusuz 'ın avantajlarından ödün vermeden, benimseme durumuna yönelik birkaç çözüm vardır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="eecd1-119">Daha popüler çözümlerden bazıları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="eecd1-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="eecd1-120">Geçici bir veri deposu veya dağıtılmış önbellek kullanın, örneğin Redsıs</span><span class="sxs-lookup"><span data-stu-id="eecd1-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="eecd1-121">Durumu SQL veya CosmosDB gibi bir veritabanında depola</span><span class="sxs-lookup"><span data-stu-id="eecd1-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="eecd1-122">Dayanıklı işlevler gibi bir iş akışı altyapısı aracılığıyla durumu işleme</span><span class="sxs-lookup"><span data-stu-id="eecd1-122">Handle state through a workflow engine like durable functions</span></span>

<span data-ttu-id="eecd1-123">En alttaki satır, sunucusuz ile uygulamayı düşündüğünde işlem içinde herhangi bir durum yönetimine gerek duyduğuna dikkat etmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="eecd1-124">Uzun süre çalışan süreçler</span><span class="sxs-lookup"><span data-stu-id="eecd1-124">Long-running processes</span></span>

<span data-ttu-id="eecd1-125">Sunucusuz 'in birçok avantajı, işlemlerin kısa ömürlü olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="eecd1-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="eecd1-126">Kısa çalışma süreleri, sunucusuz sağlayıcının kaynakları boşalttığından ve konaklar genelinde işlevleri paylaştığı ve paylaştığı kaynakları daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="eecd1-127">Çoğu bulut sağlayıcısı, işlevinizin çalışacağı toplam süreyi 10 dakika içinde sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="eecd1-128">İşleminiz daha uzun sürbaşlayabilir, alternatif bir uygulama düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="eecd1-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="eecd1-129">Birkaç özel durum ve çözüm vardır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="eecd1-130">Tek bir çözüm, işleminizi bir kez daha az çalışacak şekilde daha küçük bileşenlere bölmek olabilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="eecd1-131">İşlem bağımlılıkları nedeniyle uzun süre çalışırsa, dayanıklı işlevler gibi bir çözüm kullanarak zaman uyumsuz bir iş akışını da düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="eecd1-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="eecd1-132">Dayanıklı işlevler, bir dış işlemin tamamlanmasını beklerken işleminizin durumunu duraklatır ve korur.</span><span class="sxs-lookup"><span data-stu-id="eecd1-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="eecd1-133">Zaman uyumsuz işleme, gerçek işlemin çalışma süresini azaltır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="eecd1-134">Başlangıç zamanı</span><span class="sxs-lookup"><span data-stu-id="eecd1-134">Startup time</span></span>

<span data-ttu-id="eecd1-135">Sunucusuz uygulamalarla ilgili olası bir sorun başlangıç zamanı.</span><span class="sxs-lookup"><span data-stu-id="eecd1-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="eecd1-136">Kaynakları korumak için, birçok sunucusuz sağlayıcı "isteğe bağlı" altyapıyı oluşturur.</span><span class="sxs-lookup"><span data-stu-id="eecd1-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="eecd1-137">Bir sunucusuz işlev bir süre sonra tetiklendiğinde, işlevi barındıracak kaynakların oluşturulması veya yeniden başlatılması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="eecd1-138">Bazı durumlarda, soğuk başlar birkaç saniyelik gecikmeler oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="eecd1-139">Başlangıç süresi sağlayıcılar ve hizmet düzeyleri arasında farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="eecd1-140">Uygulamanın başarısı için en aza indirmek önemliyse, başlangıç zamanına yönelik birkaç yaklaşım vardır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="eecd1-141">Bazı sağlayıcılar, kullanıcıların altyapının "her zaman açık" olduğunu garanti eden hizmet düzeyleri için ödeme yapmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="eecd1-142">Canlı tutma mekanizması uygulayın ("uyanık" durumunda tutmak için uç noktaya ping yapın).</span><span class="sxs-lookup"><span data-stu-id="eecd1-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="eecd1-143">Kapsayıcılı bir işlev yaklaşımı ile Kubernetes gibi Orchestration kullanın (konak zaten çalışıyor, yeni örneklerin dönmesini son derece hızlıdır).</span><span class="sxs-lookup"><span data-stu-id="eecd1-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="eecd1-144">Veritabanı güncelleştirmeleri ve geçişleri</span><span class="sxs-lookup"><span data-stu-id="eecd1-144">Database updates and migrations</span></span>

<span data-ttu-id="eecd1-145">Sunucusuz kodun avantajı, uygulamanın tamamını yeniden dağıtmaya gerek kalmadan yeni işlevleri serbest bırakabilmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="eecd1-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="eecd1-146">Bu avantaj, ilişkili ilişkisel bir veritabanı olduğunda olumsuz bir hale gelebilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="eecd1-147">Veritabanı şemalarında yapılan değişikliklerin sunucusuz güncelleştirmelerle eşitlenmesi zordur.</span><span class="sxs-lookup"><span data-stu-id="eecd1-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="eecd1-148">Ek sorunlar, şeyler yanlış olduğunda ve değişikliklerin geri alınması gerektiğinde ortaya çıkmıştır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="eecd1-149">Veri bütünlüğü, mikro hizmetler ve sunucusuz işlevler için en iyi uygulama, kendi verilerinin sahibi olmasının bir nedenidir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="eecd1-150">Değişiklikleri tek bir işlem ve veri birimi olarak dağıtmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="eecd1-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="eecd1-151">Gerçeklik, birçok eski sistem sunucusuz mimariyle mutabakatı gereken büyük bir arka uç veritabanı özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="eecd1-152">Şema sürümü oluşturmayı çözmeye yönelik popüler bir yaklaşım, mevcut özellikleri ve sütunları hiçbir şekilde değiştirmemek, bunun yerine yeni bilgiler eklemektir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="eecd1-153">Örneğin, yapılacaklar listesi için Boole "tamamlandı" bayrağını "tamamlanma tarihi" olarak değiştirmek için bir değişikliği göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="eecd1-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="eecd1-154">Eski alanı kaldırmak yerine veritabanı değişikliği şu şekilde olur:</span><span class="sxs-lookup"><span data-stu-id="eecd1-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="eecd1-155">Yeni bir "tamamlanma tarihi" alanı ekleyin.</span><span class="sxs-lookup"><span data-stu-id="eecd1-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="eecd1-156">"Tamamlandı" Boole alanını, tamamlanma tarihinin geçerli tarihten sonra olup olmadığını değerlendiren bir hesaplanan işleve dönüştürün.</span><span class="sxs-lookup"><span data-stu-id="eecd1-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="eecd1-157">Tamamlanan Boole değeri true olarak ayarlandığında tamamlandı tarihini geçerli tarihe ayarlamak için bir tetikleyici ekleyin.</span><span class="sxs-lookup"><span data-stu-id="eecd1-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="eecd1-158">Değişiklik dizisi, eski kodun "olduğu gibi" çalışmaya devam etmesini sağlar ve daha yeni sunucusuz işlevler yeni alandan faydalanabilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="eecd1-159">Sunucusuz mimarilerde bulunan veriler hakkında daha fazla bilgi için bkz. [Dağıtılmış veri yönetimi Için sorunlar ve çözümler](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span><span class="sxs-lookup"><span data-stu-id="eecd1-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="eecd1-160">Ölçeklendirme</span><span class="sxs-lookup"><span data-stu-id="eecd1-160">Scaling</span></span>

<span data-ttu-id="eecd1-161">Sunucusuz "sunucu yok" anlamına gelen yaygın bir yanıltıcı olur.</span><span class="sxs-lookup"><span data-stu-id="eecd1-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="eecd1-162">Aslında "daha az sunucu" gibi.</span><span class="sxs-lookup"><span data-stu-id="eecd1-162">It's in fact "less server."</span></span> <span data-ttu-id="eecd1-163">Bir destek altyapısı, ölçeklendirmenin ne zaman geldiğini anlamak için önemlidir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="eecd1-164">Çoğu sunucusuz platform, olay yoğunluğu arttıkça altyapının ölçeklendirilmesi için bir denetim kümesi sağlar.</span><span class="sxs-lookup"><span data-stu-id="eecd1-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="eecd1-165">Çeşitli seçeneklerden birini seçebilirsiniz, ancak stratejiniz işleve bağlı olarak farklılık gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="eecd1-166">Ayrıca, işlevler genellikle ilgili bir ana bilgisayar altında çalıştırılır, böylece aynı konaktaki işlevler aynı ölçek seçeneklerine sahip olacaktır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="eecd1-167">Bu nedenle, ölçek gereksinimlerine göre hangi işlevlerin birlikte barındırıldığını düzenlemek ve stratejik hale eklemek gereklidir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="eecd1-168">Kurallar, değişen parametrelere bağlı olarak genellikle ölçeği artırma (konak kaynaklarını artırma) ve genişleme (konak örneği sayısını artırma) belirler.</span><span class="sxs-lookup"><span data-stu-id="eecd1-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="eecd1-169">Ölçek Tetikleyicileri için zamanlama, istek hızları, CPU kullanımı ve bellek kullanımı dahil olabilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="eecd1-170">Daha yüksek performans genellikle daha fazla maliyetle gelir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="eecd1-171">Daha ucuz, tüketim tabanlı yaklaşımlar, istek oranı aniden arttıkça hızla ölçeklenmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="eecd1-172">Önde gelen "sigorta maliyeti" ve kesin olarak "gitirken" ödeme yaparak, istek üzerine ani artışlar nedeniyle daha az yanıt vermek arasında bir denge vardır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="eecd1-173">İzleme, izleme ve günlüğe kaydetme</span><span class="sxs-lookup"><span data-stu-id="eecd1-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="eecd1-174">DevOps 'ın genellikle daha fazla bir yönü dağıtıldıktan sonra uygulamaları izlerdir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="eecd1-175">Sunucusuz işlevleri izlemeye yönelik bir stratejinin olması önemlidir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="eecd1-176">En büyük zorluk genellikle bağıntılandır veya bir kullanıcı aynı etkileşimin bir parçası olarak birden çok işlevi çağırdığında, bu şekilde tanınması gerekir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="eecd1-177">Sunucusuz platformların çoğu, üçüncü taraf araçlara aktarılabilecek konsol günlüğüne izin verir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="eecd1-178">Telemetri toplamayı otomatik hale getirmek, bağıntı kimliklerini oluşturmak ve izlemek ve ayrıntılı Öngörüler sağlamak için belirli eylemleri izlemek için de seçenekler vardır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="eecd1-179">Azure, izleme ve analiz için Gelişmiş [Application Insights platformu](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) sağlar.</span><span class="sxs-lookup"><span data-stu-id="eecd1-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="eecd1-180">Hizmetler arası bağımlılıklar</span><span class="sxs-lookup"><span data-stu-id="eecd1-180">Inter-service dependencies</span></span>

<span data-ttu-id="eecd1-181">Sunucusuz bir mimari, diğer işlevlere bağlı olan işlevleri içerebilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="eecd1-182">Aslında, bir etkileşim ya da dağıtılmış işlemin bir parçası olarak birden fazla hizmetin her birini aramasını sağlamak için sunucusuz bir mimaride yaygın olmayan bir durumdur.</span><span class="sxs-lookup"><span data-stu-id="eecd1-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="eecd1-183">Güçlü kuponu önlemek için, hizmetlerin birbirini doğrudan başvurmaması önerilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="eecd1-184">Bir hizmetin uç noktasının değişmesi gerektiğinde, doğrudan başvurular büyük yeniden düzenleme ile sonuçlanabilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="eecd1-185">Önerilen bir çözüm, bir istek türü için uygun uç noktasını sağlayan bir kayıt defteri gibi bir hizmet bulma mekanizması sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="eecd1-186">Farklı bir çözüm, hizmetler arasındaki iletişim için kuyruklar veya konular gibi mesajlaşma hizmetlerinden faydalanmaya yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="eecd1-187">Hatayı yönetme ve dayanıklılık sağlama</span><span class="sxs-lookup"><span data-stu-id="eecd1-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="eecd1-188">*Devre kesici deseninin*göz önünde bulundurulması de önemlidir: bazı nedenlerle bir hizmet başarısız olmaya devam ederse, bu hizmetin tekrar tekrar çağırmasının önerilmez.</span><span class="sxs-lookup"><span data-stu-id="eecd1-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="eecd1-189">Bunun yerine, alternatif bir hizmet çağrılır veya bağımlı hizmetin sistem durumu yeniden oluşturulana kadar bir ileti döndürülür.</span><span class="sxs-lookup"><span data-stu-id="eecd1-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="eecd1-190">Sunucusuz mimarinin, hizmet dışı bağımlılıkların çözümlenmesi ve yönetilmesi için strateji hesabına sahip olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="eecd1-191">Devre kesici düzenine devam etmek için, hizmetlerin hata toleranslı ve dayanıklı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="eecd1-192">Hata toleransı, uygulamanızın beklenmedik özel durumlar veya geçersiz durumlardan sonra bile çalışmaya devam etmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="eecd1-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="eecd1-193">Hata toleransı genellikle kodun kendisinin bir işlevidir ve özel durumları işlemek için nasıl yazıldığı.</span><span class="sxs-lookup"><span data-stu-id="eecd1-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="eecd1-194">Dayanıklılık, uygulamanın hatalardan kurtarılırken ne kadar uyumlu olduğunu ifade eder.</span><span class="sxs-lookup"><span data-stu-id="eecd1-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="eecd1-195">Dayanıklılık genellikle sunucusuz platform tarafından yönetilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="eecd1-196">Mevcut bir hata oluştuğunda platformun yeni bir sunucusuz işlev örneği alabilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="eecd1-197">Her yeni örnek başarısız olduğunda, platformun yeni örnekleri dönmesini durdurmak için de yeterince akıllı olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="eecd1-198">Daha fazla bilgi için bkz. [devre kesici modelini uygulama](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span><span class="sxs-lookup"><span data-stu-id="eecd1-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="eecd1-199">Sürüm oluşturma ve yeşil/mavi dağıtımlar</span><span class="sxs-lookup"><span data-stu-id="eecd1-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="eecd1-200">Sunucusuz 'ın önemli bir avantajı, uygulamanın tamamını yeniden dağıtmaya gerek kalmadan belirli bir işlevi yükseltmeme özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="eecd1-201">Yükseltmelerin başarılı olabilmesi için işlevlerin doğru kod sürümüne yönlendirilmesi için işlevleri sürümlenmiş olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="eecd1-202">Yeni sürümleri dağıtmaya yönelik bir strateji da önemlidir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="eecd1-203">Yaygın bir yaklaşım, "yeşil/mavi dağıtımlar" kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="eecd1-204">Yeşil dağıtım, geçerli işlevdir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-204">The green deployment is the current function.</span></span> <span data-ttu-id="eecd1-205">Yeni bir "mavi" sürümü üretime dağıtılır ve test edilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="eecd1-206">Testler başarılı olduğunda, yeni sürümün canlı olması için yeşil ve mavi sürümler takas edilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="eecd1-207">Herhangi bir sorunla karşılaşıldığında, geri dönebilir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="eecd1-208">Sürüm oluşturma ve yeşil/mavi dağıtımları desteklemek, sürüm değişikliklerini barındırmak ve dağıtımları işlemek için sunucusuz platformla çalışmak üzere işlevleri yazmanın bir birleşimini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="eecd1-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span> <span data-ttu-id="eecd1-209">Olası bir yaklaşım, [Azure sunucusuz platform](azure-functions.md#proxies) bölümünde açıklanan proxy 'leri kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="eecd1-209">One possible approach is to use proxies, which are described in the [Azure serverless platform](azure-functions.md#proxies) chapter.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="eecd1-210">[Önceki](serverless-architecture.md)
>[İleri](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="eecd1-210">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
