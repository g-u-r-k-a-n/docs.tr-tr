---
description: 'Daha fazla bilgi edinin: PLıNQ ve TPL için Özel Bölümleyiciler'
title: PLINQ ve TPL için Özel Bölümleyiciler
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
ms.openlocfilehash: 4971adfbd514d53dbe761566be021b7d280eab39
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99731493"
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="09e70-103">PLINQ ve TPL için Özel Bölümleyiciler</span><span class="sxs-lookup"><span data-stu-id="09e70-103">Custom Partitioners for PLINQ and TPL</span></span>

<span data-ttu-id="09e70-104">Bir veri kaynağındaki bir işlemi paralel hale getirmek için, temel adımlardan biri kaynağı birden çok iş parçacığı tarafından aynı anda erişilebilen birden çok bölüme *bölümlemesidir* .</span><span class="sxs-lookup"><span data-stu-id="09e70-104">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="09e70-105">PLıNQ ve görev paralel kitaplığı (TPL), paralel bir sorgu veya döngü yazdığınızda saydam olarak çalışan varsayılan Bölümleyiciler sağlar <xref:System.Threading.Tasks.Parallel.ForEach%2A> .</span><span class="sxs-lookup"><span data-stu-id="09e70-105">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="09e70-106">Daha gelişmiş senaryolar için kendi bölümleyici 'nizi takabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="09e70-106">For more advanced scenarios, you can plug in your own partitioner.</span></span>

## <a name="kinds-of-partitioning"></a><span data-ttu-id="09e70-107">Bölümleme türleri</span><span class="sxs-lookup"><span data-stu-id="09e70-107">Kinds of Partitioning</span></span>

<span data-ttu-id="09e70-108">Bir veri kaynağını bölümleyerek birçok yol vardır.</span><span class="sxs-lookup"><span data-stu-id="09e70-108">There are many ways to partition a data source.</span></span> <span data-ttu-id="09e70-109">En verimli yaklaşımlar içinde, birden çok iş parçacığı kaynağı fiziksel olarak birden çok subsequences ayırmak yerine, özgün kaynak sırasını işlemek üzere çalışır.</span><span class="sxs-lookup"><span data-stu-id="09e70-109">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="09e70-110">Uzunluğun önceden olduğu Koleksiyonlar gibi diziler ve diğer dizinli kaynaklar için <xref:System.Collections.IList> , *Aralık bölümleme* en basit bölümleme türüdür.</span><span class="sxs-lookup"><span data-stu-id="09e70-110">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="09e70-111">Her iş parçacığı benzersiz başlangıç ve bitiş dizinlerini alır, böylece, başka bir iş parçacığı tarafından üzerine yazmadan veya üzerine yazılmadan kaynak aralığını işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-111">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="09e70-112">Aralık bölümlemeye dahil olan tek ek, aralıkları oluşturmaya yönelik ilk çalışmadır; Bundan sonra ek eşitleme gerekmez.</span><span class="sxs-lookup"><span data-stu-id="09e70-112">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="09e70-113">Bu nedenle, iş yükü eşit olarak bölündüğü sürece iyi bir performans sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-113">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="09e70-114">Aralık bölümlemenin bir dezavantajı, bir iş parçacığının erken sonlandırmasıdır, diğer iş parçacıklarının işlerini bitirmesini yardımcı olamaz.</span><span class="sxs-lookup"><span data-stu-id="09e70-114">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>

<span data-ttu-id="09e70-115">Uzunluğu bilinmeyen bağlantılı listeler veya diğer koleksiyonlar için *öbek bölümleme* kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="09e70-115">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="09e70-116">Öbek bölümlendirme içinde, bir paralel döngü veya sorgudaki her iş parçacığı veya görev, bir öbekte birkaç kaynak öğesi tüketir, bunları işler ve sonra ek öğeleri almaya geri gelir.</span><span class="sxs-lookup"><span data-stu-id="09e70-116">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="09e70-117">Bölümleyici tüm öğelerin dağıtılmasını ve yinelenen değer olmamasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="09e70-117">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="09e70-118">Bir öbek herhangi bir boyutta olabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-118">A chunk may be any size.</span></span> <span data-ttu-id="09e70-119">Örneğin, [nasıl yapılır: dinamik bölümleri uygulama](how-to-implement-dynamic-partitions.md) bölümünde gösterilen bölümleyici yalnızca bir öğe içeren öbekleri oluşturur.</span><span class="sxs-lookup"><span data-stu-id="09e70-119">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="09e70-120">Parçalar çok büyük olmadığı sürece, iş parçacıklarındaki öğelerin atanması önceden belirlenmediğinden, bu tür bir bölümleme, kendiliğinden yük dengedir.</span><span class="sxs-lookup"><span data-stu-id="09e70-120">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="09e70-121">Ancak, bölümleyici, iş parçacığının başka bir öbeği alması gerektiğinde eşitleme ek yüküne neden olur.</span><span class="sxs-lookup"><span data-stu-id="09e70-121">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="09e70-122">Bu durumlarda oluşan eşitleme miktarı, öbeklerin boyutuyla daha seyrek orantılı şekilde yapılır.</span><span class="sxs-lookup"><span data-stu-id="09e70-122">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>

<span data-ttu-id="09e70-123">Genel olarak, Aralık bölümleme yalnızca temsilcinin yürütme süresi küçük ve orta arası olduğunda ve kaynakta çok sayıda öğe varsa ve her bölümün toplam çalışması kabaca eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="09e70-123">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="09e70-124">Çoğu durumda öbek bölümleme genellikle daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="09e70-124">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="09e70-125">Temsilci için az sayıda öğe veya daha uzun yürütme süresi olan kaynaklarda, öbek ve Aralık bölümlemenin performansı eşittir.</span><span class="sxs-lookup"><span data-stu-id="09e70-125">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>

<span data-ttu-id="09e70-126">TPL Bölümleyiciler dinamik sayıda bölümü de destekler.</span><span class="sxs-lookup"><span data-stu-id="09e70-126">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="09e70-127">Bu, örneğin, <xref:System.Threading.Tasks.Parallel.ForEach%2A> döngü yeni bir görev oluştururken bir arada bölüm oluşturbilecekleri anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="09e70-127">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="09e70-128">Bu özellik, bölümleyici 'nin döngüyle birlikte ölçeklenebilmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="09e70-128">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="09e70-129">Dinamik Bölümleyiciler Ayrıca, doğal olarak yük dengedir.</span><span class="sxs-lookup"><span data-stu-id="09e70-129">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="09e70-130">Özel bir bölümleyici oluşturduğunuzda, bir döngüden tüketilebilir olması için dinamik bölümlendirme desteği gerekir <xref:System.Threading.Tasks.Parallel.ForEach%2A> .</span><span class="sxs-lookup"><span data-stu-id="09e70-130">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>

### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="09e70-131">PLıNQ için Yük Dengeleme Bölümleyicilerinin yapılandırılması</span><span class="sxs-lookup"><span data-stu-id="09e70-131">Configuring Load Balancing Partitioners for PLINQ</span></span>

<span data-ttu-id="09e70-132">Metodun bazı aşırı yüklemeleri, bir <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> dizi veya kaynak için bir bölümleyici oluşturmanıza <xref:System.Collections.IList> ve iş yükünü iş parçacıkları arasında dengelemeye çalışıp çalışmadığını belirtmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="09e70-132">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="09e70-133">Bölümleyici, yük dengeleme için yapılandırıldığında, öbek bölümleme kullanılır ve öğeler istenen küçük öbeklerdeki her bölüme dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="09e70-133">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="09e70-134">Bu yaklaşım tüm tüm bölümlerin, tüm döngü veya sorgu tamamlanana kadar işlemek için öğelere sahip olduğundan emin olmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="09e70-134">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="09e70-135">Herhangi bir kaynağın Yük Dengeleme bölümlemesini sağlamak için ek bir aşırı yükleme kullanılabilir <xref:System.Collections.IEnumerable> .</span><span class="sxs-lookup"><span data-stu-id="09e70-135">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>

<span data-ttu-id="09e70-136">Genel olarak, Yük Dengeleme, bölümlerin bölümleyici 'den görece sıklıkta istek istemesine gerek duyar.</span><span class="sxs-lookup"><span data-stu-id="09e70-136">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="09e70-137">Buna karşılık, statik bölümlendirme yapan bir bölümleyici her bir bölümleyici öğesine, her türlü veya öbek bölümlendirme kullanarak öğeleri atayabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-137">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="09e70-138">Bu, yük dengelemeden daha az yük gerektirir, ancak bir iş parçacığının diğer diğerlerinden çok daha fazla iş ile sona ermemesi durumunda yürütülmesi daha uzun sürebilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-138">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="09e70-139">Varsayılan olarak, bir IList veya Array geçirildiğinde, PLıNQ her zaman yük dengeleme olmadan Aralık bölümlendirme kullanır.</span><span class="sxs-lookup"><span data-stu-id="09e70-139">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="09e70-140">PLıNQ için yük dengelemeyi etkinleştirmek üzere, `Partitioner.Create` Aşağıdaki örnekte gösterildiği gibi yöntemini kullanın.</span><span class="sxs-lookup"><span data-stu-id="09e70-140">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>

[!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
[!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]

<span data-ttu-id="09e70-141">Belirli bir senaryoda yük dengelemenin kullanılıp kullanılmayacağını belirlemenin en iyi yolu, temsilci yükleme ve bilgisayar yapılandırması altında işlemin ne kadar sürdüğünü tamamlamaya ve ölçmeye yönelik bir deneymidir.</span><span class="sxs-lookup"><span data-stu-id="09e70-141">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="09e70-142">Örneğin, statik bölümlendirme yalnızca birkaç çekirdeğe sahip olan çok çekirdekli bir bilgisayarda önemli bir hızlı yol sunabilir, ancak nispeten fazla çekirdeğe sahip bilgisayarlarda yavaşlamalara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-142">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>

<span data-ttu-id="09e70-143">Aşağıdaki tabloda, yönteminin kullanılabilir aşırı yüklemeleri listelenmektedir <xref:System.Collections.Concurrent.Partitioner.Create%2A> .</span><span class="sxs-lookup"><span data-stu-id="09e70-143">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="09e70-144">Bu bölümleyicilerin yalnızca PLıNQ veya ile kullanılması sınırlı değildir <xref:System.Threading.Tasks.Task> .</span><span class="sxs-lookup"><span data-stu-id="09e70-144">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="09e70-145">Ayrıca, özel bir paralel yapı ile de kullanılabilirler.</span><span class="sxs-lookup"><span data-stu-id="09e70-145">They can also be used with any custom parallel construct.</span></span>

|<span data-ttu-id="09e70-146">Yüklemek</span><span class="sxs-lookup"><span data-stu-id="09e70-146">Overload</span></span>|<span data-ttu-id="09e70-147">Yük dengelemeyi kullanır</span><span class="sxs-lookup"><span data-stu-id="09e70-147">Uses load balancing</span></span>|
|--------------|-------------------------|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="09e70-148">Her zaman</span><span class="sxs-lookup"><span data-stu-id="09e70-148">Always</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="09e70-149">Boole bağımsız değişkeni true olarak belirtildiğinde</span><span class="sxs-lookup"><span data-stu-id="09e70-149">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="09e70-150">Boole bağımsız değişkeni true olarak belirtildiğinde</span><span class="sxs-lookup"><span data-stu-id="09e70-150">When the Boolean argument is specified as true</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="09e70-151">Asla</span><span class="sxs-lookup"><span data-stu-id="09e70-151">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="09e70-152">Asla</span><span class="sxs-lookup"><span data-stu-id="09e70-152">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="09e70-153">Asla</span><span class="sxs-lookup"><span data-stu-id="09e70-153">Never</span></span>|
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="09e70-154">Asla</span><span class="sxs-lookup"><span data-stu-id="09e70-154">Never</span></span>|

### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="09e70-155">Statik Aralık Bölümleyiciler paralel. ForEach için Yapılandırılıyor</span><span class="sxs-lookup"><span data-stu-id="09e70-155">Configuring Static Range Partitioners for Parallel.ForEach</span></span>

<span data-ttu-id="09e70-156">Bir <xref:System.Threading.Tasks.Parallel.For%2A> döngüde, döngünün gövdesi yönteme bir temsilci olarak sağlanır.</span><span class="sxs-lookup"><span data-stu-id="09e70-156">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="09e70-157">Bu temsilciyi çağırma maliyeti, sanal yöntem çağrısıyla aynı şekilde yapılır.</span><span class="sxs-lookup"><span data-stu-id="09e70-157">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="09e70-158">Bazı senaryolarda, paralel bir döngünün gövdesi, her döngü yinelemesinde temsilci çağrısı maliyetinin önemli hale geldiği kadar küçük olabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-158">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="09e70-159">Bu gibi durumlarda, <xref:System.Collections.Concurrent.Partitioner.Create%2A> <xref:System.Collections.Generic.IEnumerable%601> kaynak öğeler üzerinde Aralık bölümleri oluşturmak için aşırı yüklerden birini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="09e70-159">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="09e70-160">Daha sonra, bu aralıklar koleksiyonunu <xref:System.Threading.Tasks.Parallel.ForEach%2A> gövde düzenli bir döngüden oluşan bir yönteme geçirebilirsiniz `for` .</span><span class="sxs-lookup"><span data-stu-id="09e70-160">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="09e70-161">Bu yaklaşımın avantajı, temsilci çağırma maliyetinin her öğe için bir kez değil, her aralığa yalnızca bir kez tahakkuk etcidir.</span><span class="sxs-lookup"><span data-stu-id="09e70-161">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="09e70-162">Aşağıdaki örnekte temel desenler gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="09e70-162">The following example demonstrates the basic pattern.</span></span>

[!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
[!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]

<span data-ttu-id="09e70-163">Döngüdeki her iş parçacığı, <xref:System.Tuple%602> belirtilen alt aralıktaki başlangıç ve bitiş dizini değerlerini içeren kendisini alır.</span><span class="sxs-lookup"><span data-stu-id="09e70-163">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="09e70-164">İç `for` döngü, `fromInclusive` `toExclusive` dizi üzerinde veya doğrudan döngü yapmak için ve değerlerini kullanır <xref:System.Collections.IList> .</span><span class="sxs-lookup"><span data-stu-id="09e70-164">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>

<span data-ttu-id="09e70-165">Aşırı yüklerden biri <xref:System.Collections.Concurrent.Partitioner.Create%2A> bölümlerin boyutunu ve bölüm sayısını belirtmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="09e70-165">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="09e70-166">Bu aşırı yükleme, her öğe için, her öğe için bir sanal yöntem çağrısı performansa göre belirgin bir etkiye sahip olduğu durumlarda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-166">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>

## <a name="custom-partitioners"></a><span data-ttu-id="09e70-167">Özel Bölümleyiciler</span><span class="sxs-lookup"><span data-stu-id="09e70-167">Custom Partitioners</span></span>

<span data-ttu-id="09e70-168">Bazı senaryolarda, kendi bölümleyici 'nizi uygulamak için de gerekli olabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-168">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="09e70-169">Örneğin, sınıfın iç yapısına bağlı olarak, varsayılan Bölümleyiciler tarafından daha verimli bir şekilde bölümleyebilir bir özel koleksiyon sınıfınız olabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-169">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="09e70-170">Ya da, kaynak koleksiyondaki farklı konumlarda bulunan öğeleri işlemek için ne kadar süreceğine bağlı olarak değişen boyutlarda Aralık bölümleri oluşturmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="09e70-170">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>

<span data-ttu-id="09e70-171">Temel bir özel bölümleyici oluşturmak için, aşağıdaki tabloda açıklandığı gibi, ' dan bir sınıf türetebilir <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> ve sanal yöntemleri geçersiz kılın.</span><span class="sxs-lookup"><span data-stu-id="09e70-171">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="09e70-172">Bu yöntem, ana iş parçacığı tarafından bir kez çağrılır ve bir IList (IEnumerator (TSource)) döndürür.</span><span class="sxs-lookup"><span data-stu-id="09e70-172">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="09e70-173">Döngü veya sorgudaki her çalışan iş parçacığı, farklı bir `GetEnumerator` bölüm üzerinden almak için listeyi çağırabilir <xref:System.Collections.Generic.IEnumerator%601> .</span><span class="sxs-lookup"><span data-stu-id="09e70-173">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="09e70-174">`true`Öğesini uygularsanız, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> Aksi takdirde, döndürün `false` .</span><span class="sxs-lookup"><span data-stu-id="09e70-174">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="09e70-175"><xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>İse `true` , bu yöntem yerine isteğe bağlı olarak çağrılabilir <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> .</span><span class="sxs-lookup"><span data-stu-id="09e70-175">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="09e70-176">Sonuçlar sıralanabilir olmalıdır veya öğelere dizinli erişim istiyorsanız, <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> Aşağıdaki tabloda açıklandığı gibi, sanal yöntemlerini türeten ve geçersiz kılabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="09e70-176">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>

|||
|-|-|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="09e70-177">Bu yöntem, ana iş parçacığı tarafından bir kez çağrılır ve döndürür `IList(IEnumerator(TSource))` .</span><span class="sxs-lookup"><span data-stu-id="09e70-177">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="09e70-178">Döngü veya sorgudaki her çalışan iş parçacığı, farklı bir `GetEnumerator` bölüm üzerinden almak için listeyi çağırabilir <xref:System.Collections.Generic.IEnumerator%601> .</span><span class="sxs-lookup"><span data-stu-id="09e70-178">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="09e70-179">`true`Öğesini uyguladığınızda döndürün <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A> ; Aksi takdirde, false.</span><span class="sxs-lookup"><span data-stu-id="09e70-179">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="09e70-180">Genellikle bu yalnızca çağırır <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> .</span><span class="sxs-lookup"><span data-stu-id="09e70-180">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="09e70-181"><xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>İse `true` , bu yöntem yerine isteğe bağlı olarak çağrılabilir <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> .</span><span class="sxs-lookup"><span data-stu-id="09e70-181">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|

<span data-ttu-id="09e70-182">Aşağıdaki tabloda, üç tür yük dengeleme Bölümleyiciler sınıfının nasıl uygulandığı hakkında ek ayrıntılar verilmektedir <xref:System.Collections.Concurrent.OrderablePartitioner%601> .</span><span class="sxs-lookup"><span data-stu-id="09e70-182">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>

|<span data-ttu-id="09e70-183">Metot/Özellik</span><span class="sxs-lookup"><span data-stu-id="09e70-183">Method/Property</span></span>|<span data-ttu-id="09e70-184">Yük Dengeleme olmadan IList/Array</span><span class="sxs-lookup"><span data-stu-id="09e70-184">IList / Array without Load Balancing</span></span>|<span data-ttu-id="09e70-185">Yük Dengeleme ile IList/Array</span><span class="sxs-lookup"><span data-stu-id="09e70-185">IList / Array with Load Balancing</span></span>|<span data-ttu-id="09e70-186">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="09e70-186">IEnumerable</span></span>|
|----------------------|-------------------------------------------|----------------------------------------|-----------------|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="09e70-187">Aralık bölümleme kullanır</span><span class="sxs-lookup"><span data-stu-id="09e70-187">Uses range partitioning</span></span>|<span data-ttu-id="09e70-188">Belirtilen partitionCount listeleri için en iyi duruma getirilmiş öbek bölümleme kullanır</span><span class="sxs-lookup"><span data-stu-id="09e70-188">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="09e70-189">Statik sayıda bölüm oluşturarak öbek bölümleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="09e70-189">Uses chunk partitioning by creating a static number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="09e70-190">Desteklenmeyen özel durum oluşturur</span><span class="sxs-lookup"><span data-stu-id="09e70-190">Throws not-supported exception</span></span>|<span data-ttu-id="09e70-191">Listeler ve dinamik bölümler için en iyi duruma getirilmiş öbek bölümleme kullanır</span><span class="sxs-lookup"><span data-stu-id="09e70-191">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="09e70-192">Dinamik sayıda bölüm oluşturarak öbek bölümleme kullanır.</span><span class="sxs-lookup"><span data-stu-id="09e70-192">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="09e70-193">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-193">Returns `true`</span></span>|<span data-ttu-id="09e70-194">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-194">Returns `true`</span></span>|<span data-ttu-id="09e70-195">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-195">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="09e70-196">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-196">Returns `true`</span></span>|<span data-ttu-id="09e70-197">Döndürdüğü `false`</span><span class="sxs-lookup"><span data-stu-id="09e70-197">Returns `false`</span></span>|<span data-ttu-id="09e70-198">Döndürdüğü `false`</span><span class="sxs-lookup"><span data-stu-id="09e70-198">Returns `false`</span></span>|
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="09e70-199">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-199">Returns `true`</span></span>|<span data-ttu-id="09e70-200">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-200">Returns `true`</span></span>|<span data-ttu-id="09e70-201">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-201">Returns `true`</span></span>|
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="09e70-202">Döndürdüğü `false`</span><span class="sxs-lookup"><span data-stu-id="09e70-202">Returns `false`</span></span>|<span data-ttu-id="09e70-203">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-203">Returns `true`</span></span>|<span data-ttu-id="09e70-204">Döndürdüğü `true`</span><span class="sxs-lookup"><span data-stu-id="09e70-204">Returns `true`</span></span>|

### <a name="dynamic-partitions"></a><span data-ttu-id="09e70-205">Dinamik bölümler</span><span class="sxs-lookup"><span data-stu-id="09e70-205">Dynamic Partitions</span></span>

<span data-ttu-id="09e70-206">Bir yöntemde kullanılacak olan bölümleyici <xref:System.Threading.Tasks.Parallel.ForEach%2A> 'yi düşünüyorsanız, dinamik sayıda bölüm döndürebilmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="09e70-206">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="09e70-207">Bu, bölümleyici 'nin döngü yürütme sırasında dilediğiniz zaman isteğe bağlı yeni bir bölüm için bir Numaralandırıcı sağlayabileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="09e70-207">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="09e70-208">Temel olarak, döngü yeni bir paralel görev eklediğinde, bu görev için yeni bir bölüm ister.</span><span class="sxs-lookup"><span data-stu-id="09e70-208">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="09e70-209">Verilerin sıralı olmasını istiyorsanız, <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> her bölümdeki her bir öğeye benzersiz bir dizin atanması için öğesinden türetebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="09e70-209">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>

<span data-ttu-id="09e70-210">Daha fazla bilgi ve bir örnek için bkz. [nasıl yapılır: dinamik bölümleri uygulama](how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="09e70-210">For more information, and an example, see [How to: Implement Dynamic Partitions](how-to-implement-dynamic-partitions.md).</span></span>

### <a name="contract-for-partitioners"></a><span data-ttu-id="09e70-211">Bölümleyiciler için sözleşme</span><span class="sxs-lookup"><span data-stu-id="09e70-211">Contract for Partitioners</span></span>

<span data-ttu-id="09e70-212">Özel bir bölümleyici uyguladığınızda, PLıNQ ile ve TPL 'de doğru etkileşimi sağlamaya yardımcı olmak için aşağıdaki yönergeleri izleyin <xref:System.Threading.Tasks.Parallel.ForEach%2A> :</span><span class="sxs-lookup"><span data-stu-id="09e70-212">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>

- <span data-ttu-id="09e70-213"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, İçin sıfır veya daha küçük bir bağımsız değişkenle çağrılırsa `partitionsCount` throw <xref:System.ArgumentOutOfRangeException> .</span><span class="sxs-lookup"><span data-stu-id="09e70-213">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="09e70-214">PLıNQ ve TPL hiçbir şekilde 0 ' a eşit geçmeyecektir `partitionCount` , ancak olasılığa karşı koruma yapmanızı öneririz.</span><span class="sxs-lookup"><span data-stu-id="09e70-214">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>

- <span data-ttu-id="09e70-215"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> ve <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> her zaman `partitionsCount` bölüm sayısını döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="09e70-215"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="09e70-216">Bölümleyici veri tükendiyse ve istenen sayıda bölüm oluşturamaz, bu durumda yöntem kalan bölümlerin her biri için boş bir Numaralandırıcı döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="09e70-216">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="09e70-217">Aksi halde, PLıNQ ve TPL her ikisi de oluşturur <xref:System.InvalidOperationException> .</span><span class="sxs-lookup"><span data-stu-id="09e70-217">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="09e70-218"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>,,, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A> ve <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> asla döndürmemelidir `null` ( `Nothing` Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="09e70-218"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="09e70-219">Yapalarsa PLıNQ/TPL bir oluşturur <xref:System.InvalidOperationException> .</span><span class="sxs-lookup"><span data-stu-id="09e70-219">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>

- <span data-ttu-id="09e70-220">Bölüm döndüren yöntemler her zaman veri kaynağını tam ve benzersiz bir şekilde numaralandırmayan bölümler döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="09e70-220">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="09e70-221">Bölümleyici tasarımının özel olarak gerekmediği müddetçe veri kaynağında yineleme olmaması veya atlanan öğeler olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="09e70-221">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="09e70-222">Bu kurala uyulmazsa çıkış sırası karıştırılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-222">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="09e70-223">Aşağıdaki Boole alıcıları, çıkış sırası karıştırılamamasını sağlayacak şekilde aşağıdaki değerleri her zaman doğru döndürmelidir:</span><span class="sxs-lookup"><span data-stu-id="09e70-223">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>

  - <span data-ttu-id="09e70-224">`KeysOrderedInEachPartition`: Her bölüm, artan anahtar dizinlerini içeren öğeleri döndürür.</span><span class="sxs-lookup"><span data-stu-id="09e70-224">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>

  - <span data-ttu-id="09e70-225">`KeysOrderedAcrossPartitions`: Döndürülen tüm bölümler için *, Bölüm ı* *-1*' deki anahtar dizinlerinden daha yüksek.</span><span class="sxs-lookup"><span data-stu-id="09e70-225">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>

  - <span data-ttu-id="09e70-226">`KeysNormalized`: Tüm anahtar dizinleri, sıfırdan başlayarak boşluklar olmadan tek bir şekilde artıyor.</span><span class="sxs-lookup"><span data-stu-id="09e70-226">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>

- <span data-ttu-id="09e70-227">Tüm dizinler benzersiz olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="09e70-227">All indices must be unique.</span></span> <span data-ttu-id="09e70-228">Yinelenen dizinler bulunmayabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-228">There may not be duplicate indices.</span></span> <span data-ttu-id="09e70-229">Bu kurala uyulmazsa çıkış sırası karıştırılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-229">If this rule is not followed, then the output order may be scrambled.</span></span>

- <span data-ttu-id="09e70-230">Tüm dizinler negatif olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="09e70-230">All indices must be nonnegative.</span></span> <span data-ttu-id="09e70-231">Bu kurala uyulmazsa PLıNQ/TPL özel durumlar oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="09e70-231">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>

## <a name="see-also"></a><span data-ttu-id="09e70-232">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="09e70-232">See also</span></span>

- [<span data-ttu-id="09e70-233">Paralel programlama</span><span class="sxs-lookup"><span data-stu-id="09e70-233">Parallel Programming</span></span>](index.md)
- [<span data-ttu-id="09e70-234">Nasıl yapılır: Dinamik Bölümleri Uygulama</span><span class="sxs-lookup"><span data-stu-id="09e70-234">How to: Implement Dynamic Partitions</span></span>](how-to-implement-dynamic-partitions.md)
- [<span data-ttu-id="09e70-235">Nasıl yapılır: Statik Bölümleme için bir Bölümleyici Uygulama</span><span class="sxs-lookup"><span data-stu-id="09e70-235">How to: Implement a Partitioner for Static Partitioning</span></span>](how-to-implement-a-partitioner-for-static-partitioning.md)
