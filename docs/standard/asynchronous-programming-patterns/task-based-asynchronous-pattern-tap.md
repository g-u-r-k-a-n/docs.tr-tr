---
title: Görev Tabanlı Zaman Uyumsuz Desen (TAP)
ms.date: 02/26/2019
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework, and TAP
- asynchronous design patterns, .NET Framework
- TAP, .NET Framework support for
- Task-based Asynchronous Pattern, .NET Framework support for
- .NET Framework, asynchronous design patterns
ms.assetid: 8cef1fcf-6f9f-417c-b21f-3fd8bac75007
ms.openlocfilehash: 89c486618729c334bf74f0a1f4f9dd1b3cee8b0e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/15/2020
ms.locfileid: "78158174"
---
# <a name="task-based-asynchronous-pattern-tap"></a><span data-ttu-id="282c5-102">Görev tabanlı eşzamanlı desen (TAP)</span><span class="sxs-lookup"><span data-stu-id="282c5-102">Task-based asynchronous pattern (TAP)</span></span>
<span data-ttu-id="282c5-103">Görev tabanlı Eşzamanlı Desen (TAP), rasgele eşzamanlı <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> işlemleri <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> temsil <xref:System.Threading.Tasks?displayProperty=nameWithType> etmek için kullanılan ad alanındaki türleri ve türleri temel alınr.</span><span class="sxs-lookup"><span data-stu-id="282c5-103">The Task-based Asynchronous Pattern (TAP) is based on the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> and <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType> types in the <xref:System.Threading.Tasks?displayProperty=nameWithType> namespace, which are used to represent arbitrary asynchronous operations.</span></span> <span data-ttu-id="282c5-104">TAP yeni geliştirme için önerilen zaman uyumsuz tasarım desenidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-104">TAP is the recommended asynchronous design pattern for new development.</span></span>  
  
## <a name="naming-parameters-and-return-types"></a><span data-ttu-id="282c5-105">Adlandırma, parametreler ve iade türleri</span><span class="sxs-lookup"><span data-stu-id="282c5-105">Naming, parameters, and return types</span></span>

<span data-ttu-id="282c5-106">TAP, bir zaman uyumsuz işlemin başlangıcını ve tamamlanmasını temsil etmek için tek bir yöntem kullanır.</span><span class="sxs-lookup"><span data-stu-id="282c5-106">TAP uses a single method to represent the initiation and completion of an asynchronous operation.</span></span> <span data-ttu-id="282c5-107">Bu, hem Asynchronous Programming Model (APM veya) `IAsyncResult`deseni ile hem de Olay tabanlı Asynchronous Deseni (EAP) ile tezat oluşturuyor.</span><span class="sxs-lookup"><span data-stu-id="282c5-107">This contrasts with both the Asynchronous Programming Model (APM or `IAsyncResult`) pattern and the Event-based Asynchronous Pattern (EAP).</span></span> <span data-ttu-id="282c5-108">APM `Begin` gerektirir `End` ve yöntemleri.</span><span class="sxs-lookup"><span data-stu-id="282c5-108">APM requires `Begin` and `End` methods.</span></span> <span data-ttu-id="282c5-109">EAP, `Async` sonek olan ve bir veya daha fazla olay, olay işleyicisi temsilci türleri ve `EventArg`türetilmiş türleri gerektiren bir yöntem gerektirir.</span><span class="sxs-lookup"><span data-stu-id="282c5-109">EAP requires a method that has the `Async` suffix and also requires one or more events, event handler delegate types, and `EventArg`-derived types.</span></span> <span data-ttu-id="282c5-110">TAP'taki eşsenkronize `Async` yöntemler, işlem adından sonra, , <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>ve <xref:System.Threading.Tasks.ValueTask%601>.</span><span class="sxs-lookup"><span data-stu-id="282c5-110">Asynchronous methods in TAP include the `Async` suffix after the operation name for methods that return awaitable types, such as <xref:System.Threading.Tasks.Task>, <xref:System.Threading.Tasks.Task%601>, <xref:System.Threading.Tasks.ValueTask>, and <xref:System.Threading.Tasks.ValueTask%601>.</span></span> <span data-ttu-id="282c5-111">Örneğin, a döndüren `Get` bir `Task<String>` eşzamanlı işlem `GetAsync`adlandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-111">For example, an asynchronous `Get` operation that returns a `Task<String>` can be named `GetAsync`.</span></span> <span data-ttu-id="282c5-112">`Async` Sonekli bir EAP yöntem adı zaten içeren bir sınıfa TAP yöntemi ekliyorsanız, `TaskAsync` bunun yerine soneki kullanın.</span><span class="sxs-lookup"><span data-stu-id="282c5-112">If you're adding a TAP method to a class that already contains an EAP method name with the `Async` suffix, use the suffix `TaskAsync` instead.</span></span> <span data-ttu-id="282c5-113">Örneğin, sınıfın zaten bir `GetAsync` yöntemi varsa, `GetTaskAsync`adı kullanın.</span><span class="sxs-lookup"><span data-stu-id="282c5-113">For example, if the class already has a `GetAsync` method, use the name `GetTaskAsync`.</span></span> <span data-ttu-id="282c5-114">Bir yöntem bir eşzamanlı işlem başlatır ancak bekleyen bir türü döndürmezse, adı , yani `Begin` `Start`başka bir fiille başlamalıdır ve bu yöntemin işlemin sonucunu döndürmediğini veya atmadığını düşündürmelidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-114">If a method starts an asynchronous operation but does not return an awaitable type, its name should start with `Begin`, `Start`, or some other verb to suggest that this method does not return or throw the result of the operation.</span></span>  
  
 <span data-ttu-id="282c5-115">TAP yöntemi, karşılık <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> gelen <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>senkron yöntemin geçersiz mi yoksa bir `TResult`tür mü döndürüldünse, a veya a döndürür.</span><span class="sxs-lookup"><span data-stu-id="282c5-115">A TAP method returns either a <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> or a <xref:System.Threading.Tasks.Task%601?displayProperty=nameWithType>, based on whether the corresponding synchronous method returns void or a type `TResult`.</span></span>  
  
 <span data-ttu-id="282c5-116">TAP yönteminin parametreleri senkron muadili parametrelerine uymalı ve aynı sırada sağlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-116">The parameters of a TAP method should match the parameters of its synchronous counterpart and should be provided in the same order.</span></span>  <span data-ttu-id="282c5-117">Ancak, `out` `ref` ve parametreler bu kuraldan muaftır ve tamamen kaçınılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-117">However, `out` and `ref` parameters are exempt from this rule and should be avoided entirely.</span></span> <span data-ttu-id="282c5-118">Bir `out` veya `ref` parametre aracılığıyla döndürülecek tüm veriler, bunun yerine `TResult` döndürülen <xref:System.Threading.Tasks.Task%601>verilerin bir parçası olarak döndürülmelidir ve birden çok değeri karşılamak için bir tuple veya özel bir veri yapısı kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-118">Any data that would have been returned through an `out` or `ref` parameter should instead be returned as part of the `TResult` returned by <xref:System.Threading.Tasks.Task%601>, and should use a tuple or a custom data structure to accommodate multiple values.</span></span> <span data-ttu-id="282c5-119">TAP yönteminin eşzamanlı <xref:System.Threading.CancellationToken> muadili bir parametre sunmuyorolsa bile bir parametre eklemeyi de düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="282c5-119">You should also consider adding a <xref:System.Threading.CancellationToken> parameter even if the TAP method's synchronous counterpart does not offer one.</span></span>

 <span data-ttu-id="282c5-120">Yalnızca görevlerin oluşturulmasına, manipülasyonuna veya birleşimine ayrılmış yöntemler (yöntemin ait olduğu yöntemin asenkron amacının yöntem adında veya yöntemin ait olduğu tür deadında açık olduğu durumlarda) bu adlandırma desenini izlemeniz gerekmez; bu tür yöntemler genellikle *kombinatörler*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="282c5-120">Methods that are devoted exclusively to the creation, manipulation, or combination of tasks (where the asynchronous intent of the method is clear in the method name or in the name of the type to which the method belongs) need not follow this naming pattern; such methods are often referred to as *combinators*.</span></span> <span data-ttu-id="282c5-121">Birleştiricilere örnek <xref:System.Threading.Tasks.Task.WhenAll%2A> <xref:System.Threading.Tasks.Task.WhenAny%2A>olarak, Makalenin Görev [Tabanlı Eşzamanlı Deseni Tüketen](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md) [Dahili Görev Tabanlı Birleştirmecileri Kullanma](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) bölümü yer alır ve ve tartışılır.</span><span class="sxs-lookup"><span data-stu-id="282c5-121">Examples of combinators include <xref:System.Threading.Tasks.Task.WhenAll%2A> and <xref:System.Threading.Tasks.Task.WhenAny%2A>, and are discussed in the [Using the Built-in Task-based Combinators](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md#combinators) section of the article [Consuming the Task-based Asynchronous Pattern](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>  
  
 <span data-ttu-id="282c5-122">TAP sözdiziminin, Asynchronous Programlama Modeli (APM) ve Olay Tabanlı Eşzamanlı Desen (EAP) gibi eski asynchronöz programlama desenlerinde kullanılan sözdiziminden nasıl farklı olduğunu örnekler için [bkz.](../../../docs/standard/asynchronous-programming-patterns/index.md)</span><span class="sxs-lookup"><span data-stu-id="282c5-122">For examples of how the TAP syntax differs from the syntax used in legacy asynchronous programming patterns such as the Asynchronous Programming Model (APM) and the Event-based Asynchronous Pattern (EAP), see [Asynchronous Programming Patterns](../../../docs/standard/asynchronous-programming-patterns/index.md).</span></span>  
  
## <a name="initiating-an-asynchronous-operation"></a><span data-ttu-id="282c5-123">Eşzamanlı işlem başlatma</span><span class="sxs-lookup"><span data-stu-id="282c5-123">Initiating an asynchronous operation</span></span>  
 <span data-ttu-id="282c5-124">TAP tabanlı bir zaman uyumsuz yöntem elde edilen görevi döndürmeden önce, az miktarda bir işi (bağımsız değişkenleri doğrulamak ya da zaman uyumsuz işlemi başlatmak gibi) zaman uyumlu olarak yapabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-124">An asynchronous method that is based on TAP can do a small amount of work synchronously, such as validating arguments and initiating the asynchronous operation, before it returns the resulting task.</span></span> <span data-ttu-id="282c5-125">Zaman uyumsuz yöntemin çabuk dönmesini sağlamak için zaman uyumlu iş olabildiğince az tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-125">Synchronous work should be kept to the minimum so the asynchronous method can return quickly.</span></span> <span data-ttu-id="282c5-126">Hızlı dönüş nedenleri şunlardır:</span><span class="sxs-lookup"><span data-stu-id="282c5-126">Reasons for a quick return include the following:</span></span>  
  
- <span data-ttu-id="282c5-127">Zaman uyumsuz yöntemler kullanıcı arabirimi (UI) iş parçacıkları tarafında çağırılabilirler, ve herhangi bir uzun süre çalışan zaman uyumlu iş uygulamanın yanıt verme becerisine zarar verebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-127">Asynchronous methods may be invoked from user interface (UI) threads, and any long-running synchronous work could harm the responsiveness of the application.</span></span>  
  
- <span data-ttu-id="282c5-128">Birden çok zaman uyumsuz yöntem eşzamanlı başlatılabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-128">Multiple asynchronous methods may be launched concurrently.</span></span> <span data-ttu-id="282c5-129">Bu nedenle, bir zaman uyumsuz yöntemin herhangi bir uzun süren zaman uyumlu bölümü diğer zaman uyumsuz işlemlerin başlamasını geciktirerek eşzamanlılığın yararlarını azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-129">Therefore, any long-running work in the synchronous portion of an asynchronous method could delay the initiation of other asynchronous operations, thereby decreasing the benefits of concurrency.</span></span>  
  
 <span data-ttu-id="282c5-130">Bazı durumlarda, işlemi tamamlamak için gereken iş, işlemi zaman uyumsuz olarak başlatmak için gereken işten daha azdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-130">In some cases, the amount of work required to complete the operation is less than the amount of work required to launch the operation asynchronously.</span></span> <span data-ttu-id="282c5-131">Okuma işleminin bellekte zaten arabelleğe alınmış veri ile tamamlanabileceği bir akıştan okumak bu duruma bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="282c5-131">Reading from a stream where the read operation can be satisfied by data that is already buffered in memory is an example of such a scenario.</span></span> <span data-ttu-id="282c5-132">Bu gibi durumlarda, işlem zaman uyumlu olarak tamamlanabilir ve zaten tamamlanmış bir görevi döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-132">In such cases, the operation may complete synchronously, and may return a task that has already been completed.</span></span>  
  
## <a name="exceptions"></a><span data-ttu-id="282c5-133">Özel durumlar</span><span class="sxs-lookup"><span data-stu-id="282c5-133">Exceptions</span></span>  
 <span data-ttu-id="282c5-134">Bir zaman uyumsuz yöntem, zaman uyumsuz yöntem çağrısının dışına atılacak bir özel durumu sadece bir kullanım hatasına yanıt olarak harekete geçirmelidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-134">An asynchronous method should raise an exception to be thrown out of the asynchronous method call only in response to a usage error.</span></span> <span data-ttu-id="282c5-135">Kullanım hataları asla üretim kodunda gerçekleşmemelidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-135">Usage errors should never occur in production code.</span></span> <span data-ttu-id="282c5-136">Örneğin, yöntemin bağımsız değişkenlerinden biri olarak bir null reference 'ı (Visual`Nothing` Basic'te) <xref:System.ArgumentNullException> geçmek bir hata durumuna (genellikle bir özel durumla temsil edilir) neden oluyorsa, null başvurusu asla geçirilmediğinden emin olmak için arama kodunu değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="282c5-136">For example, if passing a null reference (`Nothing` in Visual Basic) as one of the method’s arguments causes an error state (usually represented by an <xref:System.ArgumentNullException> exception), you can modify the calling code to ensure that a null reference is never passed.</span></span> <span data-ttu-id="282c5-137">Diğer bütün hatalar için, görev döndürülene kadar zaman uyumsuz yöntem zaman uyumlu olarak tamamlansa bile, zaman uyumsuz yöntem yürütülüyorken oluşan özel durumlar döndürülen göreve atanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-137">For all other errors, exceptions that occur when an asynchronous method is running should be assigned to the returned task, even if the asynchronous method happens to complete synchronously before the task is returned.</span></span> <span data-ttu-id="282c5-138">Genel olarak, bir görev en fazla bir özel durum içerir.</span><span class="sxs-lookup"><span data-stu-id="282c5-138">Typically, a task contains at most one exception.</span></span> <span data-ttu-id="282c5-139">Ancak, görev birden çok işlemi temsil <xref:System.Threading.Tasks.Task.WhenAll%2A>ediyorsa (örneğin,), birden çok özel durum tek bir görevle ilişkilendirilebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-139">However, if the task represents multiple operations (for example, <xref:System.Threading.Tasks.Task.WhenAll%2A>), multiple exceptions may be associated with a single task.</span></span>  
  
## <a name="target-environment"></a><span data-ttu-id="282c5-140">Hedef çevre</span><span class="sxs-lookup"><span data-stu-id="282c5-140">Target environment</span></span>  
 <span data-ttu-id="282c5-141">Bir TAP yöntemi oluştururken, zaman uyumsuz yürütülmenin nerede olacağını belirleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="282c5-141">When you implement a TAP method, you can determine where asynchronous execution occurs.</span></span> <span data-ttu-id="282c5-142">İş yükünü iş parçacığı havuzunda çalıştırmayı, zaman uyumsuz I/O kullanarak oluşturmayı (işlemin yürütülmesinin çoğunluğunda bir iş parçacığına bağlı kalmayarak), belirli bir iş parçacığında yürütmeyi (örneğin UI iş parçacığı), veya diğer olası bağlamları kullanmayı tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="282c5-142">You may choose to execute the workload on the thread pool, implement it by using asynchronous I/O (without being bound to a thread for the majority of the operation’s execution), run it on a specific thread (such as the UI thread), or use any number of potential contexts.</span></span> <span data-ttu-id="282c5-143">Bir TAP yönteminin yürütülecek hiçbir şeyi <xref:System.Threading.Tasks.Task> olmayabilir ve yalnızca sistemin başka bir yerinde ki bir koşulun oluşumunu temsil eden bir durum döndürebilir (örneğin, sıraya alınan veri yapısına gelen verileri temsil eden bir görev).</span><span class="sxs-lookup"><span data-stu-id="282c5-143">A TAP method may even have nothing to execute, and may just return a <xref:System.Threading.Tasks.Task> that represents the occurrence of a condition elsewhere in the system (for example, a task that represents data arriving at a queued data structure).</span></span>

 <span data-ttu-id="282c5-144">TAP yöntemini arayan kişi, ortaya çıkan görevi eşzamanlı olarak bekleyerek TAP yönteminin tamamlanmasını engelleyebilir veya eşzamanlı işlem tamamlandığında ek (devamı) kodu çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-144">The caller of the TAP method may block waiting for the TAP method to complete by synchronously waiting on the resulting task, or may run additional (continuation) code when the asynchronous operation completes.</span></span> <span data-ttu-id="282c5-145">Devam kodunun yaratıcısı kodun nerede çalışacağına dair denetime sahiptir.</span><span class="sxs-lookup"><span data-stu-id="282c5-145">The creator of the continuation code has control over where that code executes.</span></span> <span data-ttu-id="282c5-146">Devam <xref:System.Threading.Tasks.Task> kodunu, devamların üzerine inşa edilmiş dil desteğini kullanarak <xref:System.Threading.Tasks.Task.ContinueWith%2A>(örneğin, sınıf üzerindeki yöntemlerle (örneğin) veya dolaylı `await` olarak (örneğin, C#, `Await` Visual Basic'te, `AwaitValue` F#'da) kullanarak devam kodunu oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="282c5-146">You may create the continuation code either explicitly, through methods on the <xref:System.Threading.Tasks.Task> class (for example, <xref:System.Threading.Tasks.Task.ContinueWith%2A>) or implicitly, by using language support built on top of continuations (for example, `await` in C#, `Await` in Visual Basic, `AwaitValue` in F#).</span></span>  
  
## <a name="task-status"></a><span data-ttu-id="282c5-147">Görev durumu</span><span class="sxs-lookup"><span data-stu-id="282c5-147">Task status</span></span>  
 <span data-ttu-id="282c5-148">Sınıf, <xref:System.Threading.Tasks.Task> eşzamanlı işlemler için bir yaşam döngüsü sağlar ve bu <xref:System.Threading.Tasks.TaskStatus> döngü numaralandırma ile temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-148">The <xref:System.Threading.Tasks.Task> class provides a life cycle for asynchronous operations, and that cycle is represented by the <xref:System.Threading.Tasks.TaskStatus> enumeration.</span></span> <span data-ttu-id="282c5-149">Türlerden türeyen köşe <xref:System.Threading.Tasks.Task> durumlarını <xref:System.Threading.Tasks.Task%601>desteklemek ve inşaatın zamanlamadan ayrılmasını <xref:System.Threading.Tasks.Task> desteklemek için <xref:System.Threading.Tasks.Task.Start%2A> sınıf bir yöntem ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="282c5-149">To support corner cases of types that derive from <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601>,  and to support the separation of construction from scheduling, the <xref:System.Threading.Tasks.Task> class exposes a <xref:System.Threading.Tasks.Task.Start%2A> method.</span></span> <span data-ttu-id="282c5-150">Genel <xref:System.Threading.Tasks.Task> oluşturucular tarafından oluşturulan *görevler,* zamanlanmamış <xref:System.Threading.Tasks.TaskStatus.Created> durumda yaşam döngülerine başladıkları ve yalnızca bu örneklerde <xref:System.Threading.Tasks.Task.Start%2A> çağrıldığında zamanlandıkları için soğuk görevler olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="282c5-150">Tasks that are created by the public <xref:System.Threading.Tasks.Task> constructors are referred to as *cold tasks*, because they begin their life cycle in the non-scheduled <xref:System.Threading.Tasks.TaskStatus.Created> state and are scheduled only when <xref:System.Threading.Tasks.Task.Start%2A> is called on these instances.</span></span>

 <span data-ttu-id="282c5-151">Diğer tüm görevler yaşam döngülerine sıcak bir durumda başlar, bu da temsil ettikleri eşzamanlı işlemlerin zaten başlatıldığı ve görev <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>durumlarının .</span><span class="sxs-lookup"><span data-stu-id="282c5-151">All other tasks begin their life cycle in a hot state, which means that the asynchronous operations they represent have already been initiated and their task status is an enumeration value other than <xref:System.Threading.Tasks.TaskStatus.Created?displayProperty=nameWithType>.</span></span> <span data-ttu-id="282c5-152">TAP yöntemlerinden döndürülen tüm görevler etkinleştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-152">All tasks that are returned from TAP methods must be activated.</span></span> <span data-ttu-id="282c5-153">**Bir TAP yöntemi, görevin döndürülmesi için bir görevin oluşturucusu dahili olarak <xref:System.Threading.Tasks.Task.Start%2A> kullanıyorsa, TAP yöntemini iade etmeden önce <xref:System.Threading.Tasks.Task> nesneyi çağırmalıdır.**</span><span class="sxs-lookup"><span data-stu-id="282c5-153">**If a TAP method internally uses a task’s constructor to instantiate the task to be returned, the TAP method must call <xref:System.Threading.Tasks.Task.Start%2A> on the <xref:System.Threading.Tasks.Task> object before returning it.**</span></span> <span data-ttu-id="282c5-154">BIR TAP yönteminin tüketicileri, döndürülen görevin etkin olduğunu <xref:System.Threading.Tasks.Task.Start%2A> güvenli <xref:System.Threading.Tasks.Task> bir şekilde varsayabilir ve TAP yönteminden döndürülenleri çağırmaya çalışmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-154">Consumers of a TAP method may safely assume that the returned task is active and should not try to call <xref:System.Threading.Tasks.Task.Start%2A> on any <xref:System.Threading.Tasks.Task> that is returned from a TAP method.</span></span> <span data-ttu-id="282c5-155">Etkin <xref:System.Threading.Tasks.Task.Start%2A> bir görevin çağrılarak bir <xref:System.InvalidOperationException> özel durumla sonuçlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="282c5-155">Calling <xref:System.Threading.Tasks.Task.Start%2A> on an active task results in an <xref:System.InvalidOperationException> exception.</span></span>  
  
## <a name="cancellation-optional"></a><span data-ttu-id="282c5-156">İptal (isteğe bağlı)</span><span class="sxs-lookup"><span data-stu-id="282c5-156">Cancellation (optional)</span></span>  
 <span data-ttu-id="282c5-157">TAP kullanırken, iptal etmek hem zaman uyumsuz yöntem oluşturucuları hem de zaman uyumsuz yöntem tüketicileri için isteğe bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-157">In TAP, cancellation is optional for both asynchronous method implementers and asynchronous method consumers.</span></span> <span data-ttu-id="282c5-158">Bir işlem iptale izin veriyorsa, iptal jetonu (örneğin)<xref:System.Threading.CancellationToken> kabul eden eşzamanlı yöntemin aşırı yüklenmesini ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="282c5-158">If an operation allows cancellation, it exposes an overload of the asynchronous method that accepts a cancellation token (<xref:System.Threading.CancellationToken> instance).</span></span> <span data-ttu-id="282c5-159">Kural olarak, parametre `cancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="282c5-159">By convention, the parameter is named `cancellationToken`.</span></span>  
  
 [!code-csharp[Conceptual.TAP#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#1)]
 [!code-vb[Conceptual.TAP#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#1)]  
  
 <span data-ttu-id="282c5-160">Zaman uyumsuz işlem iptal istekleri için bu belirteci izler.</span><span class="sxs-lookup"><span data-stu-id="282c5-160">The asynchronous operation monitors this token for cancellation requests.</span></span> <span data-ttu-id="282c5-161">Eğer iptal isteği alırsa, bu isteği dikkate alarak işlemi iptal etmeyi seçebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-161">If it receives a cancellation request, it may choose to honor that request and cancel the operation.</span></span> <span data-ttu-id="282c5-162">İptal isteği, çalışmanın zamanından önce sona erdirildiğine neden olursa, TAP yöntemi <xref:System.Threading.Tasks.TaskStatus.Canceled> eyalette sona eren bir görevi döndürür; kullanılabilir bir sonuç yoktur ve özel bir durum atılmaz.</span><span class="sxs-lookup"><span data-stu-id="282c5-162">If the cancellation request results in work being ended prematurely, the TAP method returns a task that ends in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state; there is no available result and no exception is thrown.</span></span>  <span data-ttu-id="282c5-163">Durum, <xref:System.Threading.Tasks.TaskStatus.Canceled> <xref:System.Threading.Tasks.TaskStatus.Faulted> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> bir görev için son (tamamlanmış) durum olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-163">The <xref:System.Threading.Tasks.TaskStatus.Canceled> state is considered to be a final (completed) state for a task, along with the <xref:System.Threading.Tasks.TaskStatus.Faulted> and <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> states.</span></span> <span data-ttu-id="282c5-164">Bu nedenle, bir görev <xref:System.Threading.Tasks.TaskStatus.Canceled> durumdaysa, <xref:System.Threading.Tasks.Task.IsCompleted%2A> `true`özelliği döndürür.</span><span class="sxs-lookup"><span data-stu-id="282c5-164">Therefore, if a task is in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, its <xref:System.Threading.Tasks.Task.IsCompleted%2A> property returns `true`.</span></span> <span data-ttu-id="282c5-165">Bir görev <xref:System.Threading.Tasks.TaskStatus.Canceled> durumda tamamlandığında, devam seçeneğinin devamı devre dışı bırakmak için <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> belirtilmedikçe, göreve kaydedilen devamlar zamanlanır veya yürütülür.</span><span class="sxs-lookup"><span data-stu-id="282c5-165">When a task completes in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state, any continuations registered with the task are scheduled or executed, unless a continuation option such as <xref:System.Threading.Tasks.TaskContinuationOptions.NotOnCanceled> was specified to opt out of continuation.</span></span> <span data-ttu-id="282c5-166">Dil özelliklerini kullanarak iptal edilmiş bir görevi eş senkronize olarak bekleyen tüm <xref:System.OperationCanceledException> kodlar çalıştırmaya devam eder, ancak ondan türetilen bir veya özel durum alır.</span><span class="sxs-lookup"><span data-stu-id="282c5-166">Any code that is asynchronously waiting for a canceled task through use of language features continues to run but receives an <xref:System.OperationCanceledException> or an exception derived from it.</span></span> <span data-ttu-id="282c5-167">Gibi yöntemlerle görevde eşzamanlı olarak bekleyen <xref:System.Threading.Tasks.Task.Wait%2A> ve <xref:System.Threading.Tasks.Task.WaitAll%2A> ayrıca bir özel durum la çalışmaya devam eden kod.</span><span class="sxs-lookup"><span data-stu-id="282c5-167">Code that is blocked synchronously waiting on the task through methods such as <xref:System.Threading.Tasks.Task.Wait%2A> and <xref:System.Threading.Tasks.Task.WaitAll%2A> also continue to run with an exception.</span></span>  
  
 <span data-ttu-id="282c5-168">Bir iptal belirteci, belirteci olarak adlandırılan TAP yönteminden önce iptal talebinde <xref:System.Threading.Tasks.TaskStatus.Canceled> bulunduysa, TAP yöntemi bir görevi döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-168">If a cancellation token has requested cancellation before the TAP method that accepts that token is called, the TAP method should return a <xref:System.Threading.Tasks.TaskStatus.Canceled> task.</span></span>  <span data-ttu-id="282c5-169">Ancak, eğer zaman uyumsuz işlem yürütülüyorken bir iptal istenirse, zaman uyumsuz işlem iptal isteğini kabul etmek zorunda değildir.</span><span class="sxs-lookup"><span data-stu-id="282c5-169">However, if cancellation is requested while the asynchronous operation is running, the asynchronous operation need not accept the cancellation request.</span></span>  <span data-ttu-id="282c5-170">Döndürülen görev, yalnızca <xref:System.Threading.Tasks.TaskStatus.Canceled> iptal isteği sonucunda işlem sona erdiğinde eyalette sona ermelidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-170">The returned task should end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state only if the operation ends as a result of the cancellation request.</span></span> <span data-ttu-id="282c5-171">İptal istenirse, ancak bir sonuç veya özel durum hala <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> üretilirse, görev veya <xref:System.Threading.Tasks.TaskStatus.Faulted> durum sona ermelidir.</span><span class="sxs-lookup"><span data-stu-id="282c5-171">If cancellation is requested but a result or an exception is still produced, the task should end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> or <xref:System.Threading.Tasks.TaskStatus.Faulted> state.</span></span>

 <span data-ttu-id="282c5-172">Her şeyden önce iptal edilme yeteneğini ortaya çıkarmak isteyen eşzamanlı yöntemler için, iptal jetonu kabul etmeyen bir aşırı yükleme sağlamanız gerekmez.</span><span class="sxs-lookup"><span data-stu-id="282c5-172">For asynchronous methods that want to expose the ability to be cancelled first and foremost, you don't have to provide an overload that doesn’t accept a cancellation token.</span></span> <span data-ttu-id="282c5-173">İptal edilemeyen yöntemler için iptal belirteci kabul eden bir aşırı yükleme sağlamayın; bu çağırana hedef yöntemin iptal edilip edilemez olduğunu belirtmeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="282c5-173">For methods that cannot be canceled, do not provide overloads that accept a cancellation token; this helps indicate to the caller whether the target method is actually cancelable.</span></span>  <span data-ttu-id="282c5-174">İptal isteğinde olmayan tüketici kodu, a <xref:System.Threading.CancellationToken> kabul eden <xref:System.Threading.CancellationToken.None%2A> ve bağımsız değişken değeri sağlayan bir yöntem arayabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-174">Consumer code that does not desire cancellation may call a method that accepts a <xref:System.Threading.CancellationToken> and provide <xref:System.Threading.CancellationToken.None%2A> as the argument value.</span></span> <span data-ttu-id="282c5-175"><xref:System.Threading.CancellationToken.None%2A>işlevsel olarak varsayılana <xref:System.Threading.CancellationToken>eşdeğerdir.</span><span class="sxs-lookup"><span data-stu-id="282c5-175"><xref:System.Threading.CancellationToken.None%2A> is functionally equivalent to the default <xref:System.Threading.CancellationToken>.</span></span>  
  
## <a name="progress-reporting-optional"></a><span data-ttu-id="282c5-176">İlerleme raporlaması (isteğe bağlı)</span><span class="sxs-lookup"><span data-stu-id="282c5-176">Progress reporting (optional)</span></span>  
 <span data-ttu-id="282c5-177">Bazı zaman uyumsuz işlemler ilerleme bildirimlerinden faydalanır; bunlar genel olarak kullanıcı arayüzünü zaman uyumsuz işlemin ilerlemesi ile ilgili bilgiyle güncelleştirmekte kullanılır.</span><span class="sxs-lookup"><span data-stu-id="282c5-177">Some asynchronous operations benefit from providing progress notifications; these are typically used to update a user interface with information about the progress of the asynchronous operation.</span></span>

 <span data-ttu-id="282c5-178">TAP'de ilerleme, genellikle <xref:System.IProgress%601> adı verilen `progress`bir parametre olarak asynchronous yöntemine geçirilen bir arabirim aracılığıyla işlenir.</span><span class="sxs-lookup"><span data-stu-id="282c5-178">In TAP, progress is handled through an <xref:System.IProgress%601> interface, which is passed to the asynchronous method as a parameter that is usually named `progress`.</span></span>  <span data-ttu-id="282c5-179">Zaman uyumsuz yöntem çağırıldığında ilerleme arabirimini sağlamak yanlış kullanım nedeniyle ortaya çıkan yarış durumlarını engellemeye yardımcı olur (yanlış kayıt olan olay işleyicilerinin işlem başladıktan sonra güncellemeleri kaçırabilmesi).</span><span class="sxs-lookup"><span data-stu-id="282c5-179">Providing the progress interface when the asynchronous method is called helps eliminate race conditions that result from incorrect usage (that is, when event handlers that are incorrectly registered after the operation starts may miss updates).</span></span>  <span data-ttu-id="282c5-180">Daha da önemlisi, ilerleme arabirimi ilerlemenin tüketici kodunda belirlendiği üzere farklı uygulamalarını destekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-180">More importantly, the progress interface supports varying implementations of progress, as determined by the consuming code.</span></span>  <span data-ttu-id="282c5-181">Örneğin, tüketici kod yalnızca en son ilerleme güncellemesini isteyebilir, ya da tüm güncellemeleri arabelleğe koyabilir, ya da her güncelleme için bir eylem çağırabilir, ya da çağrının belirli bir iş parçacığına yönlendirilip yönlendirilmediğini denetlemek isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-181">For example, the consuming code may only care about the latest progress update, or may want to buffer all updates, or may want to invoke an action for each update, or may want to control whether the invocation is marshaled to a particular thread.</span></span> <span data-ttu-id="282c5-182">Bütün bu seçenekler belirli tüketicinin ihtiyaçlarına göre arabirimin farklı uygulamalarını kullanarak elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-182">All these options may be achieved by using a different implementation of the interface, customized to the particular consumer’s needs.</span></span>  <span data-ttu-id="282c5-183">İptalde olduğu gibi, TAP <xref:System.IProgress%601> uygulamaları yalnızca API ilerleme bildirimlerini destekliyorsa bir parametre sağlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-183">As with cancellation, TAP implementations should provide an <xref:System.IProgress%601> parameter only if the API supports progress notifications.</span></span>

 <span data-ttu-id="282c5-184">Örneğin, bu `ReadAsync` makalede daha önce tartışılan yöntem, şimdiye kadar okunan bayt sayısı şeklinde ara ilerlemeyi bildirebiliyorsa, ilerleme geri araması bir <xref:System.IProgress%601> arabirim olabilir:</span><span class="sxs-lookup"><span data-stu-id="282c5-184">For example, if the `ReadAsync` method discussed earlier in this article is able to report intermediate progress in the form of the number of bytes read thus far, the progress callback could be an <xref:System.IProgress%601> interface:</span></span>  
  
 [!code-csharp[Conceptual.TAP#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#2)]
 [!code-vb[Conceptual.TAP#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#2)]  
  
 <span data-ttu-id="282c5-185">Bir `FindFilesAsync` yöntem belirli bir arama deseni karşılayan tüm dosyaların listesini döndürürse, ilerleme geri araması tamamlanan çalışma yüzdesinin yanı sıra geçerli kısmi sonuç kümesinin bir tahminini sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-185">If a `FindFilesAsync` method returns a list of all files that meet a particular search pattern, the progress callback could provide an estimate of the percentage of work completed as well as the current set of partial results.</span></span>  <span data-ttu-id="282c5-186">Bunu ya bir kayıt düzeni ile yapabilir:</span><span class="sxs-lookup"><span data-stu-id="282c5-186">It could do this either with a tuple:</span></span>  
  
 [!code-csharp[Conceptual.TAP#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#3)]
 [!code-vb[Conceptual.TAP#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#3)]  
  
 <span data-ttu-id="282c5-187">ya da API'ye özel bir veri türü ile yapabilir:</span><span class="sxs-lookup"><span data-stu-id="282c5-187">or with a data type that is specific to the API:</span></span>  
  
 [!code-csharp[Conceptual.TAP#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.tap/cs/examples1.cs#4)]
 [!code-vb[Conceptual.TAP#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.tap/vb/examples1.vb#4)]  
  
 <span data-ttu-id="282c5-188">İkinci durumda, özel veri türü genellikle suffixed olduğunu `ProgressInfo`.</span><span class="sxs-lookup"><span data-stu-id="282c5-188">In the latter case, the special data type is usually suffixed with `ProgressInfo`.</span></span>  
  
 <span data-ttu-id="282c5-189">TAP uygulamaları bir `progress` parametre kabul eden aşırı yüklemeler sağlıyorsa, bağımsız değişkenin (bu durumda hiçbir ilerleme bildirilmeyeceğini) bağımsız değişkene `null`izin vermeleri gerekir.</span><span class="sxs-lookup"><span data-stu-id="282c5-189">If TAP implementations provide overloads that accept a `progress` parameter, they must allow the argument to be `null`, in which case no progress will be reported.</span></span> <span data-ttu-id="282c5-190">TAP uygulamaları, ilerlemeyi <xref:System.Progress%601> nesneye eşzamanlı olarak bildirmelidir, bu da asenkron yöntemin ilerlemeyi hızlı bir şekilde sağlamasına olanak sağlamalı ve ilerlemenin tüketicisinin bilgileri en iyi şekilde nasıl ve nerede işleyeceğini belirlemesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="282c5-190">TAP implementations should report the progress to the <xref:System.Progress%601> object synchronously, which enables the asynchronous method to quickly provide progress, and allow the consumer of the progress to determine how and where best to handle the information.</span></span> <span data-ttu-id="282c5-191">Örneğin, ilerleme örneği geri aramaları yönlendirmeyi ve yakalanan bir eşitleme bağlamında olay çağırmayı seçebilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-191">For example, the progress instance could choose to marshal callbacks and raise events on a captured synchronization context.</span></span>  
  
## <a name="iprogresst-implementations"></a><span data-ttu-id="282c5-192">IProgress\<T> uygulamaları</span><span class="sxs-lookup"><span data-stu-id="282c5-192">IProgress\<T> implementations</span></span>  
 <span data-ttu-id="282c5-193">.NET Framework 4.5 tek <xref:System.IProgress%601> bir <xref:System.Progress%601>uygulama sağlar: .</span><span class="sxs-lookup"><span data-stu-id="282c5-193">The .NET Framework 4.5 provides a single <xref:System.IProgress%601> implementation: <xref:System.Progress%601>.</span></span> <span data-ttu-id="282c5-194">Sınıf <xref:System.Progress%601> aşağıdaki gibi bildirilir:</span><span class="sxs-lookup"><span data-stu-id="282c5-194">The <xref:System.Progress%601> class is declared as follows:</span></span>  
  
```csharp  
public class Progress<T> : IProgress<T>  
{  
    public Progress();  
    public Progress(Action<T> handler);  
    protected virtual void OnReport(T value);  
    public event EventHandler<T> ProgressChanged;  
}  
```  
  
```vb  
Public Class Progress(Of T) : Inherits IProgress(Of T)  
    Public Sub New()  
    Public Sub New(handler As Action(Of T))  
    Protected Overridable Sub OnReport(value As T)  
    Public Event ProgressChanged As EventHandler(Of T>  
End Class  
```  
  
 <span data-ttu-id="282c5-195">Eş zamanlı <xref:System.Progress%601> işlem <xref:System.Progress%601.ProgressChanged> her ilerleme güncelleştirmesi bildirdiğinde ortaya çıkan bir olayı ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="282c5-195">An instance of <xref:System.Progress%601> exposes a <xref:System.Progress%601.ProgressChanged> event, which is raised every time the asynchronous operation reports a progress update.</span></span> <span data-ttu-id="282c5-196">Olay, <xref:System.Progress%601.ProgressChanged> örnek anında <xref:System.Threading.SynchronizationContext> yakalandığında yakalanan <xref:System.Progress%601> nesne üzerinde yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-196">The <xref:System.Progress%601.ProgressChanged> event is raised on the <xref:System.Threading.SynchronizationContext> object that was captured when the <xref:System.Progress%601> instance was instantiated.</span></span> <span data-ttu-id="282c5-197">Eğer hiçbir eşitleme bağlamı kullanılabilir değilse, iş parçacığı havuzunu hedefleyen bir varsayılan bağlam kullanılır.</span><span class="sxs-lookup"><span data-stu-id="282c5-197">If no synchronization context was available, a default context that targets the thread pool is used.</span></span> <span data-ttu-id="282c5-198">İşleyiciler bu olay ile kayıtlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-198">Handlers may be registered with this event.</span></span> <span data-ttu-id="282c5-199">Tek bir işleyici de kolaylık <xref:System.Progress%601> sağlamak için oluşturucuya sağlanabilir ve <xref:System.Progress%601.ProgressChanged> olay için bir olay işleyicisi gibi olur.</span><span class="sxs-lookup"><span data-stu-id="282c5-199">A single handler may also be provided to the <xref:System.Progress%601> constructor for convenience, and behaves just like an event handler for the <xref:System.Progress%601.ProgressChanged> event.</span></span> <span data-ttu-id="282c5-200">İlerleme güncelleştirmeleri zaman uyumsuz işlemi olay işleyicileri yürütülürken geciktirmemek için zaman uyumsuz olarak harekete geçirilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-200">Progress updates are raised asynchronously to avoid delaying the asynchronous operation while event handlers are executing.</span></span> <span data-ttu-id="282c5-201">Başka <xref:System.IProgress%601> bir uygulama farklı semantik uygulamak için seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="282c5-201">Another <xref:System.IProgress%601> implementation could choose to apply different semantics.</span></span>  
  
## <a name="choosing-the-overloads-to-provide"></a><span data-ttu-id="282c5-202">Sağlamak için aşırı yüklemeleri seçme</span><span class="sxs-lookup"><span data-stu-id="282c5-202">Choosing the overloads to provide</span></span>  
 <span data-ttu-id="282c5-203">Bir TAP uygulaması hem <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> isteğe <xref:System.IProgress%601> bağlı hem de isteğe bağlı parametreleri kullanıyorsa, en fazla dört aşırı yükleme gerektirebilir:</span><span class="sxs-lookup"><span data-stu-id="282c5-203">If a TAP implementation uses both the optional <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> and optional <xref:System.IProgress%601> parameters, it could potentially require up to four overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
public Task MethodNameAsync(…, IProgress<T> progress);
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken cancellationToken) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="282c5-204">Ancak, birçok TAP uygulaması ne iptal ne de ilerleme olanakları sağlar, bu nedenle tek bir yöntem gerektirirler:</span><span class="sxs-lookup"><span data-stu-id="282c5-204">However, many TAP implementations provide neither cancellation or progress capabilities, so they require a single method:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
```  
  
 <span data-ttu-id="282c5-205">Eğer bir TAP uygulaması ya iptal ya da ilerleme destekliyorsa ama ikisini birden desteklemiyorsa, iki aşırı yükleme sağlayabilir:</span><span class="sxs-lookup"><span data-stu-id="282c5-205">If a TAP implementation supports either cancellation or progress but not both, it may provide two overloads:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, CancellationToken cancellationToken);  
  
// … or …  
  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken) As Task  
  
' … or …  
  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="282c5-206">Eğer bir TAP uygulaması hem iptal hem de ilerleme destekliyorsa, tüm dört aşırı yüklemeyi ortaya çıkarabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-206">If a TAP implementation supports both cancellation and progress, it may expose all four overloads.</span></span> <span data-ttu-id="282c5-207">Ancak, yalnızca aşağıdaki ikisini sağlayabilir:</span><span class="sxs-lookup"><span data-stu-id="282c5-207">However, it may provide only the following two:</span></span>  
  
```csharp  
public Task MethodNameAsync(…);  
public Task MethodNameAsync(…,
    CancellationToken cancellationToken, IProgress<T> progress);  
```  
  
```vb  
Public MethodNameAsync(…) As Task  
Public MethodNameAsync(…, cancellationToken As CancellationToken,
                       progress As IProgress(Of T)) As Task  
```  
  
 <span data-ttu-id="282c5-208">İki eksik ara birleşimi telafi etmek için, <xref:System.Threading.CancellationToken.None%2A> geliştiriciler <xref:System.Threading.CancellationToken> parametre ve `null` `progress` parametre için `cancellationToken` varsayılan geçiş yapabilir.</span><span class="sxs-lookup"><span data-stu-id="282c5-208">To compensate for the two missing intermediate combinations, developers may pass <xref:System.Threading.CancellationToken.None%2A> or a default <xref:System.Threading.CancellationToken> for the `cancellationToken` parameter and `null` for the `progress` parameter.</span></span>  
  
 <span data-ttu-id="282c5-209">Eğer TAP yönteminin her kullanımının iptal veya ilerleme desteklemesini istiyorsanız, ilgili parametreyi kabul etmeyen aşırı yüklemeleri çıkarabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="282c5-209">If you expect every usage of the TAP method to support cancellation or progress, you may omit the overloads that don’t accept the relevant parameter.</span></span>  
  
 <span data-ttu-id="282c5-210">İptal veya ilerlemeyi isteğe bağlı hale getirmek için birden fazla aşırı yükleme yi ortaya çıkarmaya karar <xref:System.Threading.CancellationToken.None%2A> verirseniz, iptal veya ilerlemeyi desteklemeyen aşırı yükler, iptal için geçmiş `null` gibi veya bunları destekleyen aşırı yüke ilerleme için geçmiş gibi kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="282c5-210">If you decide to expose multiple overloads to make cancellation or progress optional, the overloads that don’t support cancellation or progress should behave as if they passed <xref:System.Threading.CancellationToken.None%2A> for cancellation or `null` for progress to the overload that does support these.</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="282c5-211">İlgili konular</span><span class="sxs-lookup"><span data-stu-id="282c5-211">Related topics</span></span>  
  
|<span data-ttu-id="282c5-212">Başlık</span><span class="sxs-lookup"><span data-stu-id="282c5-212">Title</span></span>|<span data-ttu-id="282c5-213">Açıklama</span><span class="sxs-lookup"><span data-stu-id="282c5-213">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="282c5-214">Asynchronous Programlama Desenleri</span><span class="sxs-lookup"><span data-stu-id="282c5-214">Asynchronous Programming Patterns</span></span>](../../../docs/standard/asynchronous-programming-patterns/index.md)|<span data-ttu-id="282c5-215">Zaman uyumsuz işlemler gerçekleştirmek için üç desen tanıtır: Görev-tabanlı Zaman Uyumsuz Desen (TAP), Zaman Uyumsuz Programlama Modeli (APM) ve Olay-tabanlı Uyumsuz Desen (EAP).</span><span class="sxs-lookup"><span data-stu-id="282c5-215">Introduces the three patterns for performing asynchronous operations: the Task-based Asynchronous Pattern (TAP), the Asynchronous Programming Model (APM), and the Event-based Asynchronous Pattern (EAP).</span></span>|  
|[<span data-ttu-id="282c5-216">Görev Tabanlı Zaman Uyumsuz Deseni Uygulama</span><span class="sxs-lookup"><span data-stu-id="282c5-216">Implementing the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/implementing-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="282c5-217">Görev-tabanlı Zaman Uyumsuz Desen (TAP) uygulamak için üç yol açıklar: Visual Studio içindeki C# ve Visual Basic derleyicilerini kullanarak, el yöntemi ile, veya derleyici ve el yönteminin bir kombinasyonu ile.</span><span class="sxs-lookup"><span data-stu-id="282c5-217">Describes how to implement the Task-based Asynchronous Pattern (TAP) in three ways: by using the C# and Visual Basic compilers in Visual Studio, manually, or through a combination of the compiler and manual methods.</span></span>|  
|[<span data-ttu-id="282c5-218">Görev Tabanlı Zaman Uyumsuz Desen Kullanma</span><span class="sxs-lookup"><span data-stu-id="282c5-218">Consuming the Task-based Asynchronous Pattern</span></span>](../../../docs/standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md)|<span data-ttu-id="282c5-219">Engellemeden beklemeyi görevler ve geri aramalar kullanarak nasıl kullanacağınızı açıklar.</span><span class="sxs-lookup"><span data-stu-id="282c5-219">Describes how you can use tasks and callbacks to achieve waiting without blocking.</span></span>|  
|[<span data-ttu-id="282c5-220">Diğer Zaman Uyumsuz Desen ve Türlerle Birlikte Çalışma</span><span class="sxs-lookup"><span data-stu-id="282c5-220">Interop with Other Asynchronous Patterns and Types</span></span>](../../../docs/standard/asynchronous-programming-patterns/interop-with-other-asynchronous-patterns-and-types.md)|<span data-ttu-id="282c5-221">Zaman Uyumsuz Programlama Modeli (APM) ve Olay-tabanlı Zaman Uyumsuz Model (EAP) uygulamak için Görev-tabanlı Zaman Uyumsuz Model'in nasıl kullanılacağını açıklar.</span><span class="sxs-lookup"><span data-stu-id="282c5-221">Describes how to use the Task-based Asynchronous Pattern (TAP) to implement the Asynchronous Programming Model (APM) and Event-based Asynchronous Pattern (EAP).</span></span>|
