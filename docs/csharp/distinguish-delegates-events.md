---
title: Temsilcileri ve Olayları Ayırt Etme
description: Temsilciler ve olaylar arasındaki farkı ve .NET Core 'un bu özelliklerinin her birini ne zaman kullanacağınızı öğrenin.
ms.date: 06/20/2016
ms.technology: csharp-fundamentals
ms.assetid: 0fdc8629-2fdb-4a7c-a433-5b9d04eaf911
ms.openlocfilehash: ff90af1d2b1a92f06eed58228f8e8ca5ff6b93ca
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73037315"
---
# <a name="distinguishing-delegates-and-events"></a><span data-ttu-id="c9007-103">Temsilcileri ve Olayları Ayırt Etme</span><span class="sxs-lookup"><span data-stu-id="c9007-103">Distinguishing Delegates and Events</span></span>

[<span data-ttu-id="c9007-104">Öncekini</span><span class="sxs-lookup"><span data-stu-id="c9007-104">Previous</span></span>](modern-events.md)

<span data-ttu-id="c9007-105">.NET Core platformunda yeni olan geliştiriciler, `events`dayalı bir tasarıma `delegates` ve tasarımı temel alan bir tasarım arasında karar verirken çok daha fazla zaman harcamaya uğraşır.</span><span class="sxs-lookup"><span data-stu-id="c9007-105">Developers that are new to the .NET Core platform often struggle when deciding between a design based on `delegates` and a design based on `events`.</span></span> <span data-ttu-id="c9007-106">Bu zor bir kavramdır, çünkü iki dil özelliği çok benzerdir.</span><span class="sxs-lookup"><span data-stu-id="c9007-106">This is a difficult concept, because the two language features are very similar.</span></span> <span data-ttu-id="c9007-107">Olaylar, temsilciler için dil desteği kullanılarak bile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="c9007-107">Events are even built using the language support for delegates.</span></span> 

<span data-ttu-id="c9007-108">Her ikisi de bir geç bağlama senaryosu sunar: yalnızca çalışma zamanında bilinen bir yöntemi çağırarak bir bileşenin iletişim kurduğu senaryolara olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="c9007-108">They both offer a late binding scenario: they enable scenarios where a component communicates by calling a method that is only known at runtime.</span></span> <span data-ttu-id="c9007-109">Her ikisi de tek ve birden çok abone yöntemini destekler.</span><span class="sxs-lookup"><span data-stu-id="c9007-109">They both support single and multiple subscriber methods.</span></span> <span data-ttu-id="c9007-110">Bu şekilde, tekcast ve çok noktaya yayın desteği olarak adlandırılan bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c9007-110">You may find this referred to as singlecast and multicast support.</span></span> <span data-ttu-id="c9007-111">Bunlar her ikisi de işleyicileri eklemek ve kaldırmak için benzer sözdizimini destekler.</span><span class="sxs-lookup"><span data-stu-id="c9007-111">They both support similar syntax for adding and removing handlers.</span></span> <span data-ttu-id="c9007-112">Son olarak, bir olayı oluşturup bir temsilciyi çağırmak, tam olarak aynı yöntem çağrısı söz dizimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="c9007-112">Finally, raising an event and calling a delegate use exactly the same method call syntax.</span></span> <span data-ttu-id="c9007-113">Her ikisi de `?.` işleci ile kullanmak için aynı `Invoke()` yöntemi sözdizimini destekler.</span><span class="sxs-lookup"><span data-stu-id="c9007-113">They even both support the same `Invoke()` method syntax for use with the `?.` operator.</span></span>

<span data-ttu-id="c9007-114">Bu benzerlikler sayesinde ne zaman kullanacağınızı belirlemek oldukça kolaydır.</span><span class="sxs-lookup"><span data-stu-id="c9007-114">With all those similarities, it is easy to have trouble determining when to use which.</span></span>

## <a name="listening-to-events-is-optional"></a><span data-ttu-id="c9007-115">Olayları dinlemek Isteğe bağlıdır</span><span class="sxs-lookup"><span data-stu-id="c9007-115">Listening to Events is Optional</span></span>

<span data-ttu-id="c9007-116">Hangi dil özelliğinin kullanılacağını belirlemede en önemli nokta, eklenen bir abone olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c9007-116">The most important consideration in determining which language feature to use is whether or not there must be an attached subscriber.</span></span> <span data-ttu-id="c9007-117">Kodunuzun abone tarafından sağlanan kodu çağırması gerekiyorsa, temsilcileri temel alan bir tasarım kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c9007-117">If your code must call the code supplied by the subscriber, you should use a design based on delegates.</span></span> <span data-ttu-id="c9007-118">Kodunuz herhangi bir abone çağrılmadan tüm işlerini tamamlayabiliyorsanız, olaylara dayalı bir tasarım kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c9007-118">If your code can complete all its work without calling any subscribers, you should use a design based on events.</span></span> 

<span data-ttu-id="c9007-119">Bu bölüm sırasında oluşturulan örnekleri göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="c9007-119">Consider the examples built during this section.</span></span> <span data-ttu-id="c9007-120">`List.Sort()` kullanarak oluşturduğunuz koda, öğeleri doğru bir şekilde sıralamak için bir karşılaştırıcı işlevi verilmelidir.</span><span class="sxs-lookup"><span data-stu-id="c9007-120">The code you built using `List.Sort()` must be given a comparer function in order to properly sort the elements.</span></span> <span data-ttu-id="c9007-121">Hangi öğelerin döneceğini belirlemek için temsilcilerle LINQ sorgularının sağlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="c9007-121">LINQ queries must be supplied with delegates in order to determine what elements to return.</span></span> <span data-ttu-id="c9007-122">Her ikisi de temsilcilerle oluşturulmuş bir tasarım kullandı.</span><span class="sxs-lookup"><span data-stu-id="c9007-122">Both used a design built with delegates.</span></span>

<span data-ttu-id="c9007-123">`Progress` olayını göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="c9007-123">Consider the `Progress` event.</span></span> <span data-ttu-id="c9007-124">Bir görevde ilerlemeyi raporlar.</span><span class="sxs-lookup"><span data-stu-id="c9007-124">It reports progress on a task.</span></span>
<span data-ttu-id="c9007-125">Görev, herhangi bir dinleyici olup olmadığına bakılmaksızın devam etmeye devam eder.</span><span class="sxs-lookup"><span data-stu-id="c9007-125">The task continues to proceed whether or not there are any listeners.</span></span>
<span data-ttu-id="c9007-126">`FileSearcher` başka bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="c9007-126">The `FileSearcher` is another example.</span></span> <span data-ttu-id="c9007-127">Hiçbir olay abonesi ekli olmasa bile, aranan tüm dosyaları arayabilir ve bulur.</span><span class="sxs-lookup"><span data-stu-id="c9007-127">It would still search and find all the files that were sought, even with no event subscribers attached.</span></span>
<span data-ttu-id="c9007-128">UX denetimleri, olayları dinleyen bir abone olmadığında bile hala düzgün çalışır.</span><span class="sxs-lookup"><span data-stu-id="c9007-128">UX controls still work correctly, even when there are no subscribers listening to the events.</span></span> <span data-ttu-id="c9007-129">Bunlar her ikisi de olayları temel alan tasarımlar kullanır.</span><span class="sxs-lookup"><span data-stu-id="c9007-129">They both use designs based on events.</span></span>

## <a name="return-values-require-delegates"></a><span data-ttu-id="c9007-130">Dönüş değerleri temsilciler gerektiriyor</span><span class="sxs-lookup"><span data-stu-id="c9007-130">Return Values Require Delegates</span></span>

<span data-ttu-id="c9007-131">Temsilci yönteminiz için istediğiniz yöntem prototipi başka bir noktadır.</span><span class="sxs-lookup"><span data-stu-id="c9007-131">Another consideration is the method prototype you would want for your delegate method.</span></span> <span data-ttu-id="c9007-132">Gördüğünüz gibi, olaylar için kullanılan temsilcilerin void dönüş türü vardır.</span><span class="sxs-lookup"><span data-stu-id="c9007-132">As you've seen, the delegates used for events all have a void return type.</span></span> <span data-ttu-id="c9007-133">Ayrıca, olay bağımsız değişkeni nesnesinin özelliklerini değiştirerek olayları olay kaynaklarına geri geçiren olay işleyicileri oluşturmak için ıoms olduğunu da gördünüz.</span><span class="sxs-lookup"><span data-stu-id="c9007-133">You've also seen that there are idioms to create event handlers that do pass information back to event sources through modifying properties of the event argument object.</span></span> <span data-ttu-id="c9007-134">Bu IBU deyimler çalışırken, bir yöntemden değer döndürürken doğal olarak değildir.</span><span class="sxs-lookup"><span data-stu-id="c9007-134">While these idioms do work, they are not as natural as returning a value from a method.</span></span>

<span data-ttu-id="c9007-135">Bu iki buluşsal yöntemin her ikisi de mevcut olabilir: temsilci yönteminiz bir değer döndürürse, bu durum büyük olasılıkla algoritmayı bir şekilde etkiler.</span><span class="sxs-lookup"><span data-stu-id="c9007-135">Notice that these two heuristics may often both be present: If your delegate method returns a value, it will likely impact the algorithm in some way.</span></span>

## <a name="event-listeners-often-have-longer-lifetimes"></a><span data-ttu-id="c9007-136">Olay dinleyicileri genellikle daha uzun ömürleri vardır</span><span class="sxs-lookup"><span data-stu-id="c9007-136">Event Listeners Often Have Longer Lifetimes</span></span> 

<span data-ttu-id="c9007-137">Bu biraz daha zayıf bir gerekçe.</span><span class="sxs-lookup"><span data-stu-id="c9007-137">This is a slightly weaker justification.</span></span> <span data-ttu-id="c9007-138">Ancak olay tabanlı tasarımların olay kaynağı uzun bir süre boyunca olayları oluştururken daha doğal olduğunu fark edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c9007-138">However, you may find that event-based designs are more natural when the event source will be raising events over a long period of time.</span></span> <span data-ttu-id="c9007-139">Birçok sistemde UX denetimleri için bunun örneklerini görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c9007-139">You can see examples of this for UX controls on many systems.</span></span> <span data-ttu-id="c9007-140">Bir olaya abone olduktan sonra olay kaynağı, programın kullanım ömrü boyunca olayları oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="c9007-140">Once you subscribe to an event, the event source may raise events throughout the lifetime of the program.</span></span>
<span data-ttu-id="c9007-141">(Artık ihtiyaç kalmadığında olayları abonelikten kaldırabilirsiniz.)</span><span class="sxs-lookup"><span data-stu-id="c9007-141">(You can unsubscribe from events when you no longer need them.)</span></span>

<span data-ttu-id="c9007-142">Bir temsilcinin bir yönteme bağımsız değişken olarak kullanıldığı birçok temsilci tabanlı tasarım ile, bu yöntem, bu yöntemin döndürdüğü süre dolduktan sonra kullanılmlarından farklıdır.</span><span class="sxs-lookup"><span data-stu-id="c9007-142">Contrast that with many delegate-based designs, where a delegate is used as an argument to a method, and the delegate is not used after that method returns.</span></span>

## <a name="evaluate-carefully"></a><span data-ttu-id="c9007-143">Dikkatle değerlendirin</span><span class="sxs-lookup"><span data-stu-id="c9007-143">Evaluate Carefully</span></span>

<span data-ttu-id="c9007-144">Yukarıdaki konular sabit ve hızlı kurallar değildir.</span><span class="sxs-lookup"><span data-stu-id="c9007-144">The above considerations are not hard and fast rules.</span></span> <span data-ttu-id="c9007-145">Bunun yerine, belirli kullanımınız için en uygun seçeneği belirlemenize yardımcı olabilecek Kılavuzu temsil ederler.</span><span class="sxs-lookup"><span data-stu-id="c9007-145">Instead, they represent guidance that can help you decide which choice is best for your particular usage.</span></span> <span data-ttu-id="c9007-146">Benzer olduklarından, her ikisini de prototip yapabilir ve bununla birlikte çalışmak için ne kadar doğal olacağını düşünün.</span><span class="sxs-lookup"><span data-stu-id="c9007-146">Because they are similar, you can even prototype both, and consider which would be more natural to work with.</span></span> <span data-ttu-id="c9007-147">Bunlar her ikisi de geç bağlama senaryolarını de işler.</span><span class="sxs-lookup"><span data-stu-id="c9007-147">They both handle late binding scenarios well.</span></span> <span data-ttu-id="c9007-148">Tasarımınızı en iyi şekilde iletişim kuran birini kullanın.</span><span class="sxs-lookup"><span data-stu-id="c9007-148">Use the one that communicates your design the best.</span></span>
