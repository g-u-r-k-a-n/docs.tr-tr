---
title: 'CA5388: zayıf anahtar türetme işlevini kullanırken yeterli yineleme sayısı sağlayın (kod analizi)'
description: Kod Analizi kuralı CA5388, nedenler, ihlallerin nasıl düzeltileceğini ve ne zaman bastıralınacağını içeren bilgiler sağlar.
ms.date: 05/08/2020
ms.topic: reference
author: LLLXXXCCC
ms.author: linche
f1_keywords:
- CA5388
ms.openlocfilehash: a4bbea2fb5bdc2860deedefaa73c197cd2458bd6
ms.sourcegitcommit: 2e4adc490c1d2a705a0592b295d606b10b9f51f1
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/25/2020
ms.locfileid: "96589269"
---
# <a name="ca5388-ensure-sufficient-iteration-count-when-using-weak-key-derivation-function"></a>CA5388: Zayıf anahtar türetme işlevini kullanırken yeterli sayıda yineleme sağla

| | Değer |
|-|-|
| **Kural Kimliği** |CA5388|
| **Kategori** |Microsoft.Security|
| **Düzeltilme veya kırılmamış** |Kırılmamış|

## <a name="cause"></a>Nedeni

Yineleme sayısı, tarafından şifreleme anahtarı türetmede 100.000 'den daha küçük olabilir <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A?displayProperty=fullName> .

## <a name="rule-description"></a>Kural açıklaması

Bu kural, tarafından <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 100.000 ' den küçük olabilecek bir yineleme sayısıyla bir şifreleme anahtarının oluşturulup oluşturulmadığını denetler. Daha yüksek bir yineleme sayısı, oluşturulan şifreleme anahtarını tahmin etmeye çalışan sözlük saldırılarına karşı hafifletmek için yardımcı olabilir.

Bu kural [CA5387](ca5387.md)ile benzerdir, ancak analiz yineleme sayısının 100.000 değerinden küçük olup olmadığını belirleyemiyor.

## <a name="how-to-fix-violations"></a>İhlalleri çözme

Açık olarak çağrılmadan önce döngü sayısını 100.000 ile eşit veya daha büyük <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> olarak ayarlayın.

## <a name="when-to-suppress-warnings"></a>Uyarıların ne zaman bastırılamıyor

Bu kuraldan gelen uyarıları gizlemek güvenlidir:

- Mevcut verilerle uyumluluk için daha küçük bir yineleme sayısı kullanmanız gerekir.
- Yineleme sayısının 100.000 üzerinde ayarlandığından emin olursunuz.

## <a name="configurability"></a>Yapılandırılabilirlik

Kod tabanınızın hangi bölümlerinin analizden dışlanacağını yapılandırabilirsiniz. Örneğin, kuralın adlı tür içindeki herhangi bir kodda çalıştırılmamalıdır `MyType` , aşağıdaki anahtar-değer çiftini projenizdeki bir *. editorconfig* dosyasına ekleyin:

```ini
dotnet_code_quality.CA5388.excluded_symbol_names = MyType
```

Seçenek değerindeki izin verilen sembol adı biçimleri (ile ayrılmış `|` ):

- Yalnızca sembol adı (kapsayan tür veya ad alanından bağımsız olarak ada sahip tüm semboller dahil)
- Simgenin [belge kimliği biçimindeki](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)tam adlar. Her sembol adı, "d:" metotları için önek, `T:` türler için önek, "N:" ad alanları için önek vb. gibi bir sembol türü öneki gerektirir.
- `.ctor` oluşturucular ve `.cctor` statik oluşturucular için

Örnekler:

| Seçenek değeri | Özet |
| --- | --- |
|`dotnet_code_quality.CA5388.excluded_symbol_names = MyType` | Derlemede ' MyType ' adlı tüm simgeleri eşleştirir
|`dotnet_code_quality.CA5388.excluded_symbol_names = MyType1|MyType2` | Derlemede ' MyType1 ' ya da ' MyType2 ' adlı tüm simgeleri eşleştirir
|`dotnet_code_quality.CA5388.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Verilen tam imzaya sahip ' MyMethod ' özel yöntemiyle eşleşir
|`dotnet_code_quality.CA5388.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | ' MyMethod1 ' ve ' MyMethod2 ' belirli yöntemleriyle ilgili tam imzayla eşleşir

Bu seçeneklerin tümünü yalnızca bu kural için, tüm kurallar için veya bu kategorideki tüm kurallar (güvenlik) için yapılandırabilirsiniz. Daha fazla bilgi için bkz. [kod kalitesi kural yapılandırma seçenekleri](../code-quality-rule-options.md).

## <a name="pseudo-code-examples"></a>Sözde kod örnekleri

### <a name="violation"></a>Edildiği

```csharp
using System;
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var iterations = 100;
        Random r = new Random();

        if (r.Next(6) == 4)
        {
            iterations = 100000;
        }

        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt, iterations);
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```

### <a name="solution"></a>Çözüm

```csharp
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt);
        rfc2898DeriveBytes.IterationCount = 100000;
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```
