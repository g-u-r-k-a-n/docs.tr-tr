---
title: C# 9,0 ' deki yenilikler-C# Kılavuzu
description: C# 9,0 ' de bulunan yeni özelliklere genel bakış alın.
ms.date: 09/04/2020
ms.openlocfilehash: dbc104cb0bbfc965b0cc055429713538f62ed0e8
ms.sourcegitcommit: 34968a61e9bac0f6be23ed6ffb837f52d2390c85
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/17/2020
ms.locfileid: "94687366"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="f6d4d-103">C# 9.0 sürümündeki yenilikler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-103">What's new in C# 9.0</span></span>

<span data-ttu-id="f6d4d-104">C# 9,0, C# diline aşağıdaki özellikleri ve geliştirmeleri ekler:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="f6d4d-105">Kayıtlar</span><span class="sxs-lookup"><span data-stu-id="f6d4d-105">Records</span></span>](#record-types)
- [<span data-ttu-id="f6d4d-106">Yalnızca init ayarlayıcılar</span><span class="sxs-lookup"><span data-stu-id="f6d4d-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="f6d4d-107">Üst düzey deyimler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="f6d4d-108">Desen eşleştirme geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="f6d4d-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="f6d4d-109">Yerel boyutlu tamsayılar</span><span class="sxs-lookup"><span data-stu-id="f6d4d-109">Native sized integers</span></span>
- <span data-ttu-id="f6d4d-110">İşlev işaretçileri</span><span class="sxs-lookup"><span data-stu-id="f6d4d-110">Function pointers</span></span>
- <span data-ttu-id="f6d4d-111">Yaymayı localsinit bayrağını gösterme</span><span class="sxs-lookup"><span data-stu-id="f6d4d-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="f6d4d-112">Hedef türü belirtilmiş yeni ifadeler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-112">Target-typed new expressions</span></span>
- <span data-ttu-id="f6d4d-113">statik anonim işlevler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-113">static anonymous functions</span></span>
- <span data-ttu-id="f6d4d-114">Hedef türü belirlenmiş Koşullu ifadeler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="f6d4d-115">Birlikte değişken dönüş türleri</span><span class="sxs-lookup"><span data-stu-id="f6d4d-115">Covariant return types</span></span>
- <span data-ttu-id="f6d4d-116">`GetEnumerator`Döngüler için uzantı desteği `foreach`</span><span class="sxs-lookup"><span data-stu-id="f6d4d-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="f6d4d-117">Lambda atma parametreleri</span><span class="sxs-lookup"><span data-stu-id="f6d4d-117">Lambda discard parameters</span></span>
- <span data-ttu-id="f6d4d-118">Yerel işlevlerlerde öznitelikler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-118">Attributes on local functions</span></span>
- <span data-ttu-id="f6d4d-119">Modül başlatıcılar</span><span class="sxs-lookup"><span data-stu-id="f6d4d-119">Module initializers</span></span>
- <span data-ttu-id="f6d4d-120">Kısmi yöntemlere yönelik yeni özellikler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-120">New features for partial methods</span></span>

<span data-ttu-id="f6d4d-121">C# 9,0, **.NET 5**' te desteklenir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="f6d4d-122">Daha fazla bilgi için bkz. [C# dil sürümü oluşturma](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="f6d4d-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="f6d4d-123">[.Net İndirmeleri sayfasından](https://dotnet.microsoft.com/download)en son .NET SDK 'sını indirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-123">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="f6d4d-124">Kayıt türleri</span><span class="sxs-lookup"><span data-stu-id="f6d4d-124">Record types</span></span>

<span data-ttu-id="f6d4d-125">C# 9,0, eşitlik için değer semantiğini sağlamak üzere birleştirilmiş Yöntemler sağlayan bir başvuru türü olan \**_kayıt türlerini_* tanıtır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-125">C# 9.0 introduces \**_record types_* _, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="f6d4d-126">Kayıtlar varsayılan olarak sabittir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-126">Records are immutable by default.</span></span>

<span data-ttu-id="f6d4d-127">Kayıt türleri, .NET 'te değişmez başvuru türleri oluşturmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-127">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="f6d4d-128">Geçmişte, .NET türleri büyük ölçüde başvuru türleri olarak sınıflandırılır (sınıflar ve anonim türler dahil) ve değer türleri (yapılar ve tanımlama birimleri dahil).</span><span class="sxs-lookup"><span data-stu-id="f6d4d-128">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="f6d4d-129">Değişmez değer türleri önerilirken, değişebilir değer türleri genellikle hata sunmaz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-129">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="f6d4d-130">Değer tür değişkenleri değerleri tutar, böylece değer türleri yöntemlere geçirildiğinde orijinal verilerin bir kopyasına değişiklikler yapılır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-130">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="f6d4d-131">Değişmez başvuru türleri için de birçok avantaj vardır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-131">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="f6d4d-132">Bu avantajlar, paylaşılan verilerle eşzamanlı programlarda daha fazla yer sunar.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-132">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="f6d4d-133">Ne yazık ki C#, sabit başvuru türleri oluşturmak için size çok sayıda ek kod yazmanızı zordu.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-133">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="f6d4d-134">Kayıtlar, eşitlik için değer semantiğini kullanan sabit bir başvuru türü için bir tür bildirimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-134">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="f6d4d-135">Eşitlik ve karma kodları için birleştirilmiş Yöntemler, özelliklerinin hepsi eşit olduğunda iki kaydı kabul ettir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-135">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="f6d4d-136">Bu tanımı göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-136">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="f6d4d-137">Kayıt tanımı `Person` iki ReadOnly özelliği içeren bir tür oluşturur: `FirstName` ve `LastName` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-137">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="f6d4d-138">`Person`Tür bir başvuru türüdür.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-138">The `Person` type is a reference type.</span></span> <span data-ttu-id="f6d4d-139">Il 'ye bakdıysanız, bu bir sınıftır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-139">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="f6d4d-140">Özelliklerden hiçbirinin, oluşturulduktan sonra değiştirilemediği için bu sabittir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-140">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="f6d4d-141">Bir kayıt türü tanımladığınızda, derleyici sizin için birkaç başka yöntem de birleştirir:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-141">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="f6d4d-142">Değer tabanlı eşitlik karşılaştırmaları için Yöntemler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-142">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="f6d4d-143">Geçersiz kıl <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="f6d4d-143">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="f6d4d-144">Üyeleri Kopyala ve Kopyala</span><span class="sxs-lookup"><span data-stu-id="f6d4d-144">Copy and Clone members</span></span>
- <span data-ttu-id="f6d4d-145">`PrintMembers` ve <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="f6d4d-145">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="f6d4d-146">Kayıtları devralmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-146">Records support inheritance.</span></span> <span data-ttu-id="f6d4d-147">Öğesinden türetilmiş yeni bir kaydı `Person` aşağıdaki gibi bildirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-147">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="f6d4d-148">Ayrıca, daha fazla türetmeyi engellemek için kayıtları mühürleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-148">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="f6d4d-149">Derleyici Yukarıdaki yöntemlerin farklı sürümlerini birleştirir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-149">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="f6d4d-150">Yöntem imzaları, kayıt türü korumalı ise ve doğrudan temel sınıf nesne ise öğesine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-150">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="f6d4d-151">Kayıtlar aşağıdaki yeteneklere sahip olmalıdır:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-151">Records should have the following capabilities:</span></span>

- <span data-ttu-id="f6d4d-152">Eşitlik değer tabanlıdır ve türlerin eşleşip eşleşeceğini bir denetim içerir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-152">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="f6d4d-153">Örneğin, `Student` `Person` iki kayıt aynı adı paylaşsa bile, a 'ya eşit olamaz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-153">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="f6d4d-154">Kayıtlar sizin için oluşturulmuş tutarlı bir dize gösterimine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-154">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="f6d4d-155">Kayıtlar kopyalama oluşturmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-155">Records support copy construction.</span></span> <span data-ttu-id="f6d4d-156">Doğru kopya oluşturma, devralma hiyerarşilerini ve geliştiriciler tarafından eklenen özellikleri içermelidir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-156">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="f6d4d-157">Kayıtlar değiştirilmek üzere kopyalanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-157">Records can be copied with modification.</span></span> <span data-ttu-id="f6d4d-158">Bu kopyalama ve değiştirme işlemleri, bozucu olmayan mutasyon 'yi destekler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-158">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="f6d4d-159">, Ve tanıdık aşırı yüklemelerin yanı sıra, `Equals` `operator ==` `operator !=` derleyici yeni bir özelliği birleştirir `EqualityContract` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="f6d4d-160">Özelliği, `Type` kaydın türüyle eşleşen bir nesne döndürür.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="f6d4d-161">Temel tür ise, `object` özelliği olur `virtual` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="f6d4d-162">Temel tür başka bir kayıt türü ise, özelliği bir olur `override` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="f6d4d-163">Kayıt türü ise, `sealed` özelliği olur `sealed` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="f6d4d-164">`GetHashCode` `GetHashCode` Sentezte, temel türde ve kayıt türünde belirtilen tüm özellikleri ve alanları kullanır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="f6d4d-165">Bu birleştirilmiş Yöntemler, devralma hiyerarşisi boyunca değer tabanlı eşitlik uygular.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="f6d4d-166">Diğer bir deyişle `Student` , hiçbir şekilde `Person` aynı ada sahip bir ile eşit kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="f6d4d-167">İki kaydın türleri aynı ve aynı zamanda eşit olan kayıt türleri arasında paylaşılan tüm özellikler eşleşmelidir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="f6d4d-168">Kayıtlar Ayrıca, kopya oluşturmak için birleştirilmiş bir oluşturucuya ve bir "Clone" yöntemine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="f6d4d-169">Sentezlenmiş oluşturucunun, kayıt türünde tek bir parametresi vardır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-169">The synthesized constructor has a single parameter of the record type.</span></span> <span data-ttu-id="f6d4d-170">Kaydın tüm özellikleri için aynı değerlere sahip yeni bir kayıt oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="f6d4d-171">Bu Oluşturucu, kayıt mühürlense, aksi takdirde korunmuşsa özel olur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="f6d4d-172">Sentezlenmiş "kopya" yöntemi, kayıt hiyerarşileri için kopyalama oluşturmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="f6d4d-173">Gerçek ad derleyici tarafından oluşturulduğundan "kopya" terimi tırnak içine alınmış.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="f6d4d-174">Kayıt türünde adlı bir yöntem oluşturamazsınız `Clone` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="f6d4d-175">Sentezlenmiş "kopya" yöntemi, sanal dağıtım kullanılarak Kopyalanmakta olan kaydın türünü döndürür.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="f6d4d-176">Derleyici, "Kopyala" yöntemi için, içindeki erişim değiştiricilerine bağlı olarak farklı değiştiriciler ekler `record` :</span><span class="sxs-lookup"><span data-stu-id="f6d4d-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="f6d4d-177">Kayıt türü ise `abstract` , "Clone" yöntemi de vardır `abstract` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="f6d4d-178">Temel tür değilse `object` , yöntemi de olur `override` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="f6d4d-179">`abstract`Temel tür şu olduğunda olmayan kayıt türleri için `object` :</span><span class="sxs-lookup"><span data-stu-id="f6d4d-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="f6d4d-180">Kayıt ise `sealed` , "kopya" yöntemine ek değiştiriciler eklenmez (anlamı yoktur `virtual` ).</span><span class="sxs-lookup"><span data-stu-id="f6d4d-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="f6d4d-181">Kayıt değilse `sealed` , "Clone" yöntemi olur `virtual` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="f6d4d-182">Temel tür olmadığında olmayan kayıt türleri için `abstract` `object` :</span><span class="sxs-lookup"><span data-stu-id="f6d4d-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="f6d4d-183">Kayıt ise `sealed` , "Clone" yöntemi de vardır `sealed` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="f6d4d-184">Kayıt değilse `sealed` , "Clone" yöntemi olur `override` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="f6d4d-185">Bu kuralların sonucu, eşitlik her türlü kayıt türü hiyerarşisinde tutarlı bir şekilde uygulanır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="f6d4d-186">Aşağıdaki örnekte gösterildiği gibi, özellikleri eşitse iki kayıt birbirlerine eşittir ve türleri aynıdır:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="f6d4d-187">Derleyici, yazdırılan çıktıyı destekleyen iki yöntemi birleştirir: bir <xref:System.Object.ToString> geçersiz kılma ve `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="f6d4d-188">, `PrintMembers` <xref:System.Text.StringBuilder?displayProperty=nameWithType> Bağımsız değişkeni olarak bir alır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="f6d4d-189">Kayıt türündeki tüm özellikler için özellik adlarının ve değerlerinin virgülle ayrılmış bir listesini ekler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="f6d4d-190">`PrintMembers` diğer kayıtlardan türetilmiş tüm kayıtlar için temel uygulamayı çağırır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="f6d4d-191"><xref:System.Object.ToString>Geçersiz kılma tarafından üretilen `PrintMembers` , ve ile çevrili dizeyi `{` döndürür `}` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="f6d4d-192">Örneğin, <xref:System.Object.ToString> için yöntemi `Student` `string` Aşağıdaki kod gibi döndürür:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="f6d4d-193">Şu ana kadar gösterilen örnekler, özellikleri bildirmek için Geleneksel söz dizimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="f6d4d-194">_*_Konumsal kayıtlar_*_ adlı daha kısa bir form vardır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-194">There's a more concise form called _*_positional records_*_.</span></span>  <span data-ttu-id="f6d4d-195">Daha önce konumsal kayıtlar olarak tanımlanan üç kayıt türü şunlardır:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="f6d4d-196">Bu bildirimler, önceki sürümle aynı işlevleri oluşturur (aşağıdaki bölümde ele alınan birkaç ek özellik ile).</span><span class="sxs-lookup"><span data-stu-id="f6d4d-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="f6d4d-197">Bu kayıtlar başka yöntemler eklemediğinden, bu bildirimler köşeli ayraç yerine noktalı virgül ile biter.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="f6d4d-198">Bir gövde ekleyebilir ve başka yöntemler de ekleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="f6d4d-199">Derleyici `Deconstruct` konumsal kayıtlar için bir yöntem oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="f6d4d-200">`Deconstruct`Yönteminde, kayıt türündeki tüm ortak özelliklerin adlarıyla eşleşen parametreler bulunur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="f6d4d-201">`Deconstruct`Yöntemi, kayıt bileşenin özelliklerine göre oluşturmak için kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="f6d4d-202">Son olarak, destek [ `with` ifadelerini](../language-reference/operators/with-expression.md)kaydeder.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-202">Finally, records support [`with` expressions](../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="f6d4d-203">A _\*_ `with` expression_ *_ derleyiciye bir kaydın kopyasını oluşturmasını söyler, ancak* belirtilen özellikleri _with.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-203">A _\*_`with` expression_ *_ instructs the compiler to create a copy of a record, but _with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="f6d4d-204">Önceki satır `Person` `LastName` , özelliğinin bir kopyası olduğu `person` ve olduğu yeni bir kayıt oluşturur `FirstName` `"Paul"` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-204">The previous line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is `"Paul"`.</span></span> <span data-ttu-id="f6d4d-205">Bir ifadede dilediğiniz sayıda özelliği ayarlayabilirsiniz `with` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-205">You can set any number of properties in a `with` expression.</span></span> <span data-ttu-id="f6d4d-206">Ayrıca, `with` tam bir kopya oluşturmak için ifadeleri de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-206">You can also use `with` expressions to create an exact copy.</span></span> <span data-ttu-id="f6d4d-207">Değiştirilecek özellikler için boş kümesi belirtirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-207">You specify the empty set for the properties to modify:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="WithCopy":::

<span data-ttu-id="f6d4d-208">"Clone" yöntemi dışındaki birleştirilmiş üyelerin herhangi biri sizin tarafınızdan yazılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-208">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="f6d4d-209">Bir kayıt türünün herhangi bir sentezlenmiş yöntemin imzasıyla eşleşen bir yöntemi varsa, derleyici bu yöntemi birleştirmez.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-209">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="f6d4d-210">Önceki `Dog` kayıt örneği örnek olarak bir el kodlu <xref:System.String.ToString> yöntem içerir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-210">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

<span data-ttu-id="f6d4d-211">Kayıt türleri hakkında daha fazla bilgi için bkz. kayıtlar öğreticisinde bu [araştırma](../tutorials/exploration/records.md) .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-211">Learn more about record types in this [exploration of records](../tutorials/exploration/records.md) tutorial.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="f6d4d-212">Yalnızca init ayarlayıcılar</span><span class="sxs-lookup"><span data-stu-id="f6d4d-212">Init only setters</span></span>

<span data-ttu-id="f6d4d-213">\***Init Only Setter** _ bir nesnenin üyelerini başlatmak için tutarlı bir sözdizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-213">\***Init only setters** _ provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="f6d4d-214">Özellik başlatıcıları, hangi değerin hangi özelliğin ayarlanmasını temizlesin.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-214">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="f6d4d-215">Downsıde, bu özelliklerin ayarlanabilir olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-215">The downside is that those properties must be settable.</span></span> <span data-ttu-id="f6d4d-216">C# 9,0 ' den başlayarak, `init` `set` Özellikler ve Dizin oluşturucular için erişimciler yerine erişimciler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-216">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="f6d4d-217">Çağıranlar, oluşturma ifadelerinde bu değerleri ayarlamak için özellik başlatıcısı sözdizimini kullanabilir, ancak oluşturma işlemi tamamlandıktan sonra bu özellikler salt okunur yapılır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-217">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="f6d4d-218">Init Only ayarlayıcıları, durumu değiştirecek bir pencere sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-218">Init only setters provide a window to change state.</span></span> <span data-ttu-id="f6d4d-219">Bu pencere, oluşturma aşaması sona erdiğinde kapanır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-219">That window closes when the construction phase ends.</span></span> <span data-ttu-id="f6d4d-220">Özellik başlatıcıları ve WITH ifadeleri dahil olmak üzere, oluşturma aşaması, tüm başlatma sonrasında etkili bir şekilde sona erer.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-220">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="f6d4d-221">`init`Yalnızca yazdığınız herhangi bir tür için ayarlayıcıları bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-221">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="f6d4d-222">Örneğin, aşağıdaki yapı bir hava durumu izleme yapısını tanımlar:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-222">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="f6d4d-223">Çağıranlar, değerleri ayarlamak için özellik başlatıcısı sözdizimini kullanabilir, ancak yine de dengesizin kullanılabilirliği korunur:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-223">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="f6d4d-224">Ancak başlatma sonrasında bir gözlemyi değiştirmek, başlatma dışında yalnızca bir init özelliğine atanarak bir hatadır:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-224">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="f6d4d-225">Yalnızca Init ayarlayıcıları, türetilmiş sınıflardan temel sınıf özellikleri ayarlamak için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-225">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="f6d4d-226">Ayrıca, bir temel sınıftaki yardımcılar aracılığıyla türetilmiş özellikleri de ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-226">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="f6d4d-227">Konumsal kayıtlar yalnızca init ayarlayıcıları kullanarak özellikleri bildirir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-227">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="f6d4d-228">Bu ayarlayıcılar,-ifadelerinde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-228">Those setters are used in with-expressions.</span></span> <span data-ttu-id="f6d4d-229">Her türlü veya tanımladığınız için init Only ayarlayıcıları bildirebilirsiniz `class` `struct` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-229">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="f6d4d-230">Üst düzey deyimler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-230">Top-level statements</span></span>

<span data-ttu-id="f6d4d-231">_\*_Üst düzey deyimler_\*_ pek çok uygulamadan gereksiz seremonony 'yi kaldırır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-231">_*_Top-level statements_*_ remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="f6d4d-232">"Merhaba Dünya!" kurallı öğesini düşünün</span><span class="sxs-lookup"><span data-stu-id="f6d4d-232">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="f6d4d-233">programda</span><span class="sxs-lookup"><span data-stu-id="f6d4d-233">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="f6d4d-234">Her şeyi yapan tek bir kod satırı vardır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-234">There’s only one line of code that does anything.</span></span> <span data-ttu-id="f6d4d-235">En üst düzey deyimlerle, tüm bu demirbaş `using` ve iş yapan tek satır ile değiştirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-235">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="f6d4d-236">Tek satırlık bir program istediyseniz, `using` yönergeyi kaldırabilir ve tam nitelikli tür adını kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-236">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="f6d4d-237">Uygulamanızdaki yalnızca bir dosya en üst düzey deyimleri kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-237">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="f6d4d-238">Derleyici birden çok kaynak dosyasında en üst düzey deyimler bulursa, bu bir hatadır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-238">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="f6d4d-239">En üst düzey deyimleri, genellikle bir yöntemi olan, belirtilen bir program giriş noktası yöntemiyle birleştirirseniz de bir hatadır `Main` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-239">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="f6d4d-240">Bir anlamda, bir dosyanın normalde bir sınıf yönteminde olacak deyimleri içerdiğini düşünebilirsiniz `Main` `Program` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-240">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="f6d4d-241">Bu özellik için en yaygın kullanımdan biri eğitim malzemeleri oluşturuyor.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-241">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="f6d4d-242">Başlangıç C# geliştiricileri kurallı "Merhaba Dünya!" yazabilir</span><span class="sxs-lookup"><span data-stu-id="f6d4d-242">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="f6d4d-243">kodda bir veya iki satırda.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-243">in one or two lines of code.</span></span> <span data-ttu-id="f6d4d-244">Ek sertifika gerekmez.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-244">None of the extra ceremony is needed.</span></span> <span data-ttu-id="f6d4d-245">Bununla birlikte, deneyimli geliştiriciler bu özellik için birçok kullanım de bulacaktır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-245">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="f6d4d-246">En üst düzey deyimler, Jupneter Not defterlerinin sağladığı deneme için bir komut dosyası benzeri deneyim sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-246">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="f6d4d-247">En üst düzey deyimler, küçük konsol programları ve yardımcı programlar için harika.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-247">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="f6d4d-248">Azure Işlevleri, en üst düzey deyimler için ideal bir kullanım durumdur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-248">Azure Functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="f6d4d-249">En önemlisi, üst düzey deyimler uygulamanızın kapsamını veya karmaşıklığını sınırlamaz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-249">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="f6d4d-250">Bu deyimler, herhangi bir .NET sınıfına erişebilir veya kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-250">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="f6d4d-251">Ayrıca, komut satırı bağımsız değişkenlerinin veya dönüş değerlerinin kullanımını sınırlamaz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-251">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="f6d4d-252">Üst düzey deyimler, args adlı dizeler dizisine erişebilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-252">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="f6d4d-253">En üst düzey deyimler bir tamsayı değeri döndürirse, bu değer sentezlenmiş bir yöntemden tamsayı dönüş kodu olur `Main` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-253">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="f6d4d-254">En üst düzey deyimler zaman uyumsuz ifadeler içerebilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-254">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="f6d4d-255">Bu durumda, birleştirilmiş giriş noktası bir `Task` veya döndürür `Task<int>` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-255">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="f6d4d-256">Desen eşleştirme geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="f6d4d-256">Pattern matching enhancements</span></span>

<span data-ttu-id="f6d4d-257">C# 9, yeni bir model eşleşme geliştirmeleri içerir:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-257">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="f6d4d-258">_*_Tür desenleri_*_ bir değişkenle eşleşiyor tür</span><span class="sxs-lookup"><span data-stu-id="f6d4d-258">_*_Type patterns_*_ match a variable is a type</span></span>
- <span data-ttu-id="f6d4d-259">_*_Parantez Içine alınmış desenler_*_ , desen birleşimlerinin önceliğini uygular veya vurgular</span><span class="sxs-lookup"><span data-stu-id="f6d4d-259">_*_Parenthesized patterns_*_ enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="f6d4d-260">_*_Ayırt edici `and` desenler_*_ , her iki desen de eşleşmesini gerektirir</span><span class="sxs-lookup"><span data-stu-id="f6d4d-260">_*_Conjunctive `and` patterns_*_ require both patterns to match</span></span>
- <span data-ttu-id="f6d4d-261">Ayırt edici _\*_`or` desenler_\*_ eşleşmesi gereken her iki model</span><span class="sxs-lookup"><span data-stu-id="f6d4d-261">_*_Disjunctive `or` patterns_*_ require either pattern to match</span></span>
- <span data-ttu-id="f6d4d-262">_*_Değillenmiş `not` desenler_*_ bir düzenin eşleşmemesi gerekir</span><span class="sxs-lookup"><span data-stu-id="f6d4d-262">_*_Negated `not` patterns_*_ require that a pattern doesn’t match</span></span>
- <span data-ttu-id="f6d4d-263">_\*_İlişkisel desenler_\*_ , girişin küçüktür, büyüktür, küçüktür veya eşittir veya belirtilen bir sabitten büyük veya eşit olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-263">_*_Relational patterns_*_ require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="f6d4d-264">Bu desenler, desenlerin sözdizimini zenginleştirin.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-264">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="f6d4d-265">Aşağıdaki örnekleri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-265">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="f6d4d-266">Alternatif olarak, `and` daha yüksek önceliğe sahip olması için isteğe bağlı parantezle `or` :</span><span class="sxs-lookup"><span data-stu-id="f6d4d-266">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="f6d4d-267">En yaygın kullanımdan biri null denetimi için yeni bir sözdizimidir:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-267">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="f6d4d-268">Bu desenlerden herhangi biri desenleri izin verilen herhangi bir bağlamda kullanılabilir: `is` desen ifadeleri, `switch` ifadeler, iç içe desenler ve bir `switch` deyimin `case` etiketinin deseni.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-268">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="f6d4d-269">Performans ve birlikte çalışma</span><span class="sxs-lookup"><span data-stu-id="f6d4d-269">Performance and interop</span></span>

<span data-ttu-id="f6d4d-270">Üç yeni özellik, yüksek performans gerektiren yerel birlikte çalışma ve alt düzey kitaplıklar desteğini geliştirir: yerel boyutlu tamsayılar, işlev işaretçileri ve `localsinit` bayrağı atlama.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-270">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="f6d4d-271">Yerel boyutlu tamsayılar `nint` ve `nuint` , tamsayı türleridir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-271">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="f6d4d-272">Bunlar, temel alınan türler ve ile ifade edilir <xref:System.IntPtr?displayProperty=nameWithType> <xref:System.UIntPtr?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-272">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f6d4d-273">Derleyici, bu türler için ek dönüştürmeler ve işlemleri yerel olarak gösterir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-273">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="f6d4d-274">Yerel boyutlu tamsayılar veya özelliklerini tanımlar `MaxValue` `MinValue` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-274">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="f6d4d-275">Bu değerler, Hedef makinedeki bir tamsayının yerel boyutuna bağlı olduğundan, derleme zamanı sabitleri olarak ifade edilemez.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-275">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="f6d4d-276">Çalışma zamanında bu değerler salt okunur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-276">Those values are readonly at runtime.</span></span> <span data-ttu-id="f6d4d-277">`nint`[.. Aralığında için sabit değerler kullanabilirsiniz. `int.MinValue`</span><span class="sxs-lookup"><span data-stu-id="f6d4d-277">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="f6d4d-278">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="f6d4d-278">`int.MaxValue`].</span></span> <span data-ttu-id="f6d4d-279">`nuint`[.. Aralığında için sabit değerler kullanabilirsiniz. `uint.MinValue`</span><span class="sxs-lookup"><span data-stu-id="f6d4d-279">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="f6d4d-280">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="f6d4d-280">`uint.MaxValue`].</span></span> <span data-ttu-id="f6d4d-281">Derleyici ve türlerini kullanarak tüm birli ve ikili işleçler için sabit katlama gerçekleştirir <xref:System.Int32?displayProperty=nameWithType> <xref:System.UInt32?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-281">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="f6d4d-282">Sonuç 32 bite sığmazsa, işlem çalışma zamanında yürütülür ve bir sabit kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-282">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="f6d4d-283">Yerel boyutlu tamsayılar, tamsayı matematiğinin yaygın olarak kullanıldığı ve en yüksek performansa sahip olması gereken senaryolarda performansı artırabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-283">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="f6d4d-284">İşlev işaretçileri, Il işlem kodları ve ' a erişmek için kolay bir sözdizimi sağlar `ldftn` `calli` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-284">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="f6d4d-285">Yeni sözdizimini kullanarak işlev işaretçileri bildirebilirsiniz `delegate_` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-285">You can declare function pointers using new `delegate_` syntax.</span></span> <span data-ttu-id="f6d4d-286">`delegate*`Tür bir işaretçi türüdür.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-286">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="f6d4d-287">Yöntemi, `delegate*` yöntemini kullanan `calli` bir temsilcinin aksine, türünü çağırır `callvirt` `Invoke()` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-287">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="f6d4d-288">Sözdizimi, çağırma aynıdır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-288">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="f6d4d-289">İşlev işaretçisi çağrısı, `managed` çağırma kuralını kullanır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-289">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="f6d4d-290">`unmanaged` `delegate*` Çağırma kuralına istediğinizi bildirmek için sözdiziminden sonra anahtar sözcüğünü eklersiniz `unmanaged` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-290">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="f6d4d-291">Diğer çağırma kuralları, bildirimde öznitelikler kullanılarak belirtilebilir `delegate*` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-291">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="f6d4d-292">Son olarak, <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> derleyicinin bayrağı yaymamasını sağlamak için öğesini ekleyebilirsiniz `localsinit` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-292">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="f6d4d-293">Bu bayrak, CLR 'ye tüm yerel değişkenleri sıfıra başlatmasını söyler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-293">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="f6d4d-294">`localsinit`Bayrak, 1,0 sonrasındaki C# için varsayılan davranıştır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-294">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="f6d4d-295">Ancak, ek sıfır başlatma bazı senaryolarda ölçülebilir performans etkisine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-295">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="f6d4d-296">Özellikle, kullandığınızda `stackalloc` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-296">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="f6d4d-297">Bu gibi durumlarda, ekleyebilirsiniz <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-297">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="f6d4d-298">Tek bir yönteme veya özelliğe veya bir `class` ,, `struct` `interface` veya hatta bir modüle ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-298">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="f6d4d-299">Bu öznitelik yöntemleri etkilemez `abstract` ; uygulama için oluşturulan kodu etkiler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-299">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="f6d4d-300">Bu özellikler, bazı senaryolarda performansı iyileştirebilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-300">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="f6d4d-301">Bunlar yalnızca, benimseme öncesinde ve sonrasında eklendikten sonra kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-301">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="f6d4d-302">Yerel boyutlu tamsayılar içeren kodun, farklı tamsayı boyutlarına sahip birden çok hedef platformda test olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-302">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="f6d4d-303">Diğer özellikler güvenli olmayan kod gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-303">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="f6d4d-304">Sığdırma ve son özellikler</span><span class="sxs-lookup"><span data-stu-id="f6d4d-304">Fit and finish features</span></span>

<span data-ttu-id="f6d4d-305">Diğer özelliklerin çoğu, daha verimli bir şekilde kod yazmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-305">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="f6d4d-306">C# 9,0 ' de, oluşturulan nesnenin türü zaten biliniyorsa bir [ `new` ifadede](../language-reference/operators/new-operator.md) türü atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-306">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="f6d4d-307">En yaygın kullanım, alan bildirimlerinde bulunur:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-307">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="f6d4d-308">`new`Bir yönteme bağımsız değişken olarak geçirmek için yeni bir nesne oluşturmanız gerektiğinde, target türü de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-308">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="f6d4d-309">`ForecastFor()`Aşağıdaki imzaya sahip bir yöntem düşünün:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-309">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="f6d4d-310">Bunu şu şekilde çağırabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-310">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="f6d4d-311">Bu özellik için bir diğer iyi kullanım, yeni bir nesneyi başlatmak için yalnızca init özellikleriyle birlikte birleştirilmenize yöneliktir:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-311">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="f6d4d-312">Bir ifadesini kullanarak varsayılan Oluşturucu tarafından oluşturulan bir örnek döndürebilirsiniz `return new();` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-312">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="f6d4d-313">Benzer bir özellik, [koşullu ifadelerin](../language-reference/operators/conditional-operator.md)hedef tür çözümlemesini geliştirir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-313">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="f6d4d-314">Bu değişiklik ile, iki ifadenin bir öğesinden diğerine örtük dönüştürmesi gerekmez, ancak her ikisi de hedef tür için örtük Dönüştürmelere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-314">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="f6d4d-315">Büyük olasılıkla bu değişikliği fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-315">You likely won’t notice this change.</span></span> <span data-ttu-id="f6d4d-316">Ne fark edeceksiniz, daha önce gerekli olan veya derlenmeyen bazı Koşullu ifadeler artık çalışır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-316">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="f6d4d-317">C# 9,0 ' den başlayarak `static` [lambda ifadelerine](../language-reference/operators/lambda-expressions.md) veya [anonim yöntemlere](../language-reference/operators/delegate-operator.md)değiştiricisini ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-317">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="f6d4d-318">Statik lambda ifadeleri `static` Yerel işlevlere benzerdir: statik lambda veya anonim yöntem yerel değişkenleri veya örnek durumunu yakalayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-318">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="f6d4d-319">`static`Değiştirici yanlışlıkla diğer değişkenleri yakalamaya engel olur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-319">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="f6d4d-320">Covaryant dönüş türleri, [geçersiz kılma](../language-reference/keywords/override.md) yöntemlerinin dönüş türleri için esneklik sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-320">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="f6d4d-321">Geçersiz kılma yöntemi, geçersiz kılınan temel yöntemin dönüş türünden türetilmiş bir tür döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-321">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="f6d4d-322">Bu, kayıtlar ve sanal kopya ya da fabrika yöntemlerini destekleyen diğer türler için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-322">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="f6d4d-323">Buna ek olarak, [ `foreach` döngü](../language-reference/keywords/foreach-in.md) , başka bir şekilde onu karşılayan bir genişletme yöntemi tanır ve kullanır `GetEnumerator` `foreach` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-323">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="f6d4d-324">Bu değişiklik, `foreach` zaman uyumsuz model ve model tabanlı ayrıştırma gibi diğer model tabanlı kurulumlarını ile tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-324">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="f6d4d-325">Uygulamada, bu değişiklik `foreach` herhangi bir türe destek ekleyebileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-325">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="f6d4d-326">Bir nesne Numaralandırırken tasarımınızda anlamlı hale geldiğinde kullanımını sınırlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-326">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="f6d4d-327">Sonra, Lambda ifadelerinde parametre olarak atar ' i kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-327">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="f6d4d-328">Bu kolaylık, bağımsız değişkeni adlandırmayı önlemenize olanak sağlar ve derleyici bunu kullanmaktan kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-328">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="f6d4d-329">`_`Herhangi bir bağımsız değişken için öğesini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-329">You use the `_` for any argument.</span></span> <span data-ttu-id="f6d4d-330">Daha fazla bilgi için [lambda ifadeleri](../language-reference/operators/lambda-expressions.md) makalesinin [lambda ifadesinin giriş parametreleri](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-330">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="f6d4d-331">Son olarak, artık [Yerel işlevlere](../programming-guide/classes-and-structs/local-functions.md)öznitelikler uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-331">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="f6d4d-332">Örneğin, yerel işlevlere [null yapılabilir öznitelik ek açıklamaları](../language-reference/attributes/nullable-analysis.md) uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-332">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="f6d4d-333">Kod oluşturucuları için destek</span><span class="sxs-lookup"><span data-stu-id="f6d4d-333">Support for code generators</span></span>

<span data-ttu-id="f6d4d-334">İki son özellik C# kod üreteçleri destekler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-334">Two final features support C# code generators.</span></span> <span data-ttu-id="f6d4d-335">C# kod oluşturucuları, bir Roslyn çözümleyicisine veya kod düzeltmesine benzer şekilde yazabileceğiniz bir bileşendir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-335">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="f6d4d-336">Fark, kod oluşturucuların kodu çözümlemelerine ve derleme sürecinin bir parçası olarak yeni kaynak kodu dosyaları yazmanızdır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-336">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="f6d4d-337">Tipik bir kod üreticisi öznitelikleri veya diğer kuralları arar.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-337">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="f6d4d-338">Kod Oluşturucu, Roslyn Analysis API 'Lerini kullanarak öznitelikleri veya diğer kod öğelerini okur.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-338">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="f6d4d-339">Bu bilgilerden, derlemeye yeni kod ekler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-339">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="f6d4d-340">Kaynak oluşturucuları yalnızca kod ekleyebilir; Bu kişiler, derlemede var olan herhangi bir kodu değiştirmesine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-340">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="f6d4d-341">Kod üreticileri için eklenen iki özellik, ***kısmi Yöntem sözdizimi** _ ve _*_Modül başlatıcıları_\*_ için uzantılardır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-341">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*_.</span></span> <span data-ttu-id="f6d4d-342">Birincisi, kısmi metotlarda yapılan değişiklikler.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-342">First, the changes to partial methods.</span></span> <span data-ttu-id="f6d4d-343">C# 9,0 öncesi, kısmi Yöntemler, bir `private` erişim değiştiricisi `void` belirtmemelidir, geri dönemeyebilir ve parametrelere sahip olamaz `out` .</span><span class="sxs-lookup"><span data-stu-id="f6d4d-343">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="f6d4d-344">Bu kısıtlamalar, hiçbir yöntem uygulama sağlanmazsa, derleyicinin kısmi yönteme yapılan tüm çağrıları kaldırmasının anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-344">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="f6d4d-345">C# 9,0 bu kısıtlamaları ortadan kaldırır, ancak kısmi Yöntem bildirimlerinin bir uygulamaya sahip olmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-345">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="f6d4d-346">Kod oluşturucuları, bu uygulamayı sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-346">Code generators can provide that implementation.</span></span> <span data-ttu-id="f6d4d-347">Yeni bir değişiklik yapmaktan kaçınmak için, derleyici eski kuralları takip etmek üzere bir erişim değiştiricisi olmadan herhangi bir kısmi yöntemi dikkate alır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-347">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="f6d4d-348">Kısmi Yöntem `private` erişim değiştiricisini içeriyorsa, yeni kurallar bu kısmi yöntemi yönetir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-348">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="f6d4d-349">Kod üreticileri için ikinci yeni özellik _ *_Modül başlatıcıları_* \*.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-349">The second new feature for code generators is _\*_module initializers_\*\*.</span></span> <span data-ttu-id="f6d4d-350">Modül başlatıcıları, <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> kendisine eklenmiş özniteliği olan yöntemlerdir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-350">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="f6d4d-351">Bu yöntemler, tüm modülün içindeki başka bir alan erişimi veya yöntem çağrısından önce çalışma zamanı tarafından çağırılır.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-351">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="f6d4d-352">Modül başlatıcısı yöntemi:</span><span class="sxs-lookup"><span data-stu-id="f6d4d-352">A module initializer method:</span></span>

- <span data-ttu-id="f6d4d-353">Statik olmalıdır</span><span class="sxs-lookup"><span data-stu-id="f6d4d-353">Must be static</span></span>
- <span data-ttu-id="f6d4d-354">Parametresiz olmalıdır</span><span class="sxs-lookup"><span data-stu-id="f6d4d-354">Must be parameterless</span></span>
- <span data-ttu-id="f6d4d-355">Void döndürmelidir</span><span class="sxs-lookup"><span data-stu-id="f6d4d-355">Must return void</span></span>
- <span data-ttu-id="f6d4d-356">Genel bir yöntem olmamalıdır</span><span class="sxs-lookup"><span data-stu-id="f6d4d-356">Must not be a generic method</span></span>
- <span data-ttu-id="f6d4d-357">Genel bir sınıfta içerilmemelidir</span><span class="sxs-lookup"><span data-stu-id="f6d4d-357">Must not be contained in a generic class</span></span>
- <span data-ttu-id="f6d4d-358">Kapsayan modülden erişilebilir olmalıdır</span><span class="sxs-lookup"><span data-stu-id="f6d4d-358">Must be accessible from the containing module</span></span>

<span data-ttu-id="f6d4d-359">Bu son madde işareti noktası, yöntemin ve kapsayan sınıfın iç veya genel olması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-359">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="f6d4d-360">Yöntem yerel bir işlev olamaz.</span><span class="sxs-lookup"><span data-stu-id="f6d4d-360">The method can't be a local function.</span></span>
