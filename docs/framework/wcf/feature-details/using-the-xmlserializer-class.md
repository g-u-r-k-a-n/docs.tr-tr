---
title: XmlSerializer Sınıfını Kullanma
description: WCF 'nin uygulamanızdaki verileri, istemciler ve hizmetler arasında aktarılan XML olarak serileştirmek için kullandığı XmlSerializer 'ı öğrenin.
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- XmlSerializer [WCF], using
ms.assetid: c680602d-39d3-44f1-bf22-8e6654ad5069
ms.openlocfilehash: f7473de3f34ba543b4fabfe93167ea267f16dda5
ms.sourcegitcommit: 358a28048f36a8dca39a9fe6e6ac1f1913acadd5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85246394"
---
# <a name="using-the-xmlserializer-class"></a><span data-ttu-id="f0402-103">XmlSerializer Sınıfını Kullanma</span><span class="sxs-lookup"><span data-stu-id="f0402-103">Using the XmlSerializer Class</span></span>

<span data-ttu-id="f0402-104">Windows Communication Foundation (WCF), uygulamanızdaki verileri, serileştirme adlı bir işlem olan istemciler ve hizmetler arasında aktarılan XML 'ye dönüştürmek için iki farklı serileştirme teknolojisini kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-104">Windows Communication Foundation (WCF) can use two different serialization technologies to turn the data in your application into XML that is transmitted between clients and services, a process called serialization.</span></span>

## <a name="datacontractserializer-as-the-default"></a><span data-ttu-id="f0402-105">Varsayılan olarak DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="f0402-105">DataContractSerializer as the Default</span></span>

<span data-ttu-id="f0402-106">Varsayılan olarak WCF, <xref:System.Runtime.Serialization.DataContractSerializer> veri türlerini seri hale getirmek için sınıfını kullanır.</span><span class="sxs-lookup"><span data-stu-id="f0402-106">By default WCF uses the <xref:System.Runtime.Serialization.DataContractSerializer> class to serialize data types.</span></span> <span data-ttu-id="f0402-107">Bu serileştirici aşağıdaki türleri destekler:</span><span class="sxs-lookup"><span data-stu-id="f0402-107">This serializer supports the following types:</span></span>

- <span data-ttu-id="f0402-108">İlkel türler (örneğin, tamsayılar, dizeler ve bayt dizileri), ve gibi bazı özel türler <xref:System.Xml.XmlElement> ve <xref:System.DateTime> temel öğeler olarak kabul edilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-108">Primitive types (for example, integers, strings, and byte arrays), as well as some special types, such as <xref:System.Xml.XmlElement> and <xref:System.DateTime>, which are treated as primitives.</span></span>

- <span data-ttu-id="f0402-109">Veri anlaşması türleri (özniteliğiyle işaretlenmiş türler <xref:System.Runtime.Serialization.DataContractAttribute> ).</span><span class="sxs-lookup"><span data-stu-id="f0402-109">Data contract types (types marked with the <xref:System.Runtime.Serialization.DataContractAttribute> attribute).</span></span>

- <span data-ttu-id="f0402-110"><xref:System.SerializableAttribute>Arabirimini uygulayan türler dahil olmak üzere, özniteliğiyle işaretlenmiş türler <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="f0402-110">Types marked with the <xref:System.SerializableAttribute> attribute, which include types that implement the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>

- <span data-ttu-id="f0402-111">Arabirimi uygulayan türler <xref:System.Xml.Serialization.IXmlSerializable> .</span><span class="sxs-lookup"><span data-stu-id="f0402-111">Types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface.</span></span>

- <span data-ttu-id="f0402-112">Birçok genel koleksiyon türü içeren birçok ortak koleksiyon türü.</span><span class="sxs-lookup"><span data-stu-id="f0402-112">Many common collection types, which include many generic collection types.</span></span>

<span data-ttu-id="f0402-113">Birçok .NET Framework türü, son iki kategoriye girer ve bu nedenle seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-113">Many .NET Framework types fall into the latter two categories and are thus serializable.</span></span> <span data-ttu-id="f0402-114">Serileştirilebilir türlerin dizileri de seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-114">Arrays of serializable types are also serializable.</span></span> <span data-ttu-id="f0402-115">Tüm liste için bkz. [hizmet sözleşmeleri içinde veri aktarımı belirtme](specifying-data-transfer-in-service-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="f0402-115">For a complete list, see [Specifying Data Transfer in Service Contracts](specifying-data-transfer-in-service-contracts.md).</span></span>

<span data-ttu-id="f0402-116"><xref:System.Runtime.Serialization.DataContractSerializer>Veri sözleşme türleriyle birlikte kullanılan, yenı WCF Hizmetleri yazmak için önerilen yoldur.</span><span class="sxs-lookup"><span data-stu-id="f0402-116">The <xref:System.Runtime.Serialization.DataContractSerializer>, used together with data contract types, is the recommended way to write new WCF services.</span></span> <span data-ttu-id="f0402-117">Daha fazla bilgi için bkz. [Veri Sözleşmelerini Kullanma](using-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="f0402-117">For more information, see [Using Data Contracts](using-data-contracts.md).</span></span>

## <a name="when-to-use-the-xmlserializer-class"></a><span data-ttu-id="f0402-118">XmlSerializer sınıfının ne zaman kullanılacağı</span><span class="sxs-lookup"><span data-stu-id="f0402-118">When to Use the XmlSerializer Class</span></span>

<span data-ttu-id="f0402-119">WCF Ayrıca sınıfını da destekler <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f0402-119">WCF also supports the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="f0402-120"><xref:System.Xml.Serialization.XmlSerializer>Sınıf WCF için benzersiz değil.</span><span class="sxs-lookup"><span data-stu-id="f0402-120">The <xref:System.Xml.Serialization.XmlSerializer> class is not unique to WCF.</span></span> <span data-ttu-id="f0402-121">Bu, ASP.NET Web hizmetlerinin kullandığı serileştirme altyapısının aynısıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-121">It is the same serialization engine that ASP.NET Web services use.</span></span> <span data-ttu-id="f0402-122"><xref:System.Xml.Serialization.XmlSerializer>Sınıfı, sınıftan çok daha dar bir tür kümesini destekler <xref:System.Runtime.Serialization.DataContractSerializer> , ancak sonuçta elde edilen XML üzerinde çok daha fazla denetime izin verır ve XML şeması tanım DILI (xsd) standardının çok daha fazlasını destekler.</span><span class="sxs-lookup"><span data-stu-id="f0402-122">The <xref:System.Xml.Serialization.XmlSerializer> class supports a much narrower set of types than the <xref:System.Runtime.Serialization.DataContractSerializer> class, but allows much more control over the resulting XML and supports much more of the XML Schema definition language (XSD) standard.</span></span> <span data-ttu-id="f0402-123">Ayrıca, seri hale getirilebilir türlerde hiçbir bildirime dayalı öznitelik gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="f0402-123">It also does not require any declarative attributes on the serializable types.</span></span> <span data-ttu-id="f0402-124">Daha fazla bilgi için .NET Framework belgelerindeki XML serileştirme konusuna bakın.</span><span class="sxs-lookup"><span data-stu-id="f0402-124">For more information, see the XML Serialization topic in the .NET Framework documentation.</span></span> <span data-ttu-id="f0402-125"><xref:System.Xml.Serialization.XmlSerializer>Sınıf, veri anlaşması türlerini desteklemiyor.</span><span class="sxs-lookup"><span data-stu-id="f0402-125">The <xref:System.Xml.Serialization.XmlSerializer> class does not support data contract types.</span></span>

<span data-ttu-id="f0402-126">Visual Studio 'da Svcutil.exe veya üçüncü taraf bir hizmet için istemci kodu oluşturmak üzere **hizmet başvurusu Ekle** özelliğini kullanırken veya bir üçüncü taraf şemasına erişmek için, uygun bir seri hale getirici sizin için otomatik olarak seçilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-126">When using Svcutil.exe or the **Add Service Reference** feature in Visual Studio to generate client code for a third-party service, or to access a third-party schema, an appropriate serializer is automatically selected for you.</span></span> <span data-ttu-id="f0402-127">Şema ile uyumlu değilse, <xref:System.Runtime.Serialization.DataContractSerializer> <xref:System.Xml.Serialization.XmlSerializer> seçilidir.</span><span class="sxs-lookup"><span data-stu-id="f0402-127">If the schema is not compatible with the <xref:System.Runtime.Serialization.DataContractSerializer>, the <xref:System.Xml.Serialization.XmlSerializer> is selected.</span></span>

## <a name="manually-switching-to-the-xmlserializer"></a><span data-ttu-id="f0402-128">XmlSerializer 'a el ile geçiş</span><span class="sxs-lookup"><span data-stu-id="f0402-128">Manually Switching to the XmlSerializer</span></span>

<span data-ttu-id="f0402-129">Her zaman, el ile geçiş yapmanız gerekebilir <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f0402-129">At times, you may have to manually switch to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="f0402-130">Bu durum örneğin, aşağıdaki durumlarda oluşur:</span><span class="sxs-lookup"><span data-stu-id="f0402-130">This happens, for example, in the following cases:</span></span>

- <span data-ttu-id="f0402-131">Bir uygulamayı ASP.NET Web hizmetlerinden WCF 'ye geçirirken, <xref:System.Xml.Serialization.XmlSerializer> Yeni veri anlaşması türleri oluşturmak yerine mevcut, uyumlu türleri yeniden kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f0402-131">When migrating an application from ASP.NET Web services to WCF, you may want to reuse existing, <xref:System.Xml.Serialization.XmlSerializer>-compatible types instead of creating new data contract types.</span></span>

- <span data-ttu-id="f0402-132">İletilerde görüntülenen XML üzerinde kesin denetim önemli olduğunda, ancak bir Web Hizmetleri Açıklama Dili (WSDL) belgesi yoksa, örneğin, DataContractSerializer ile uyumlu olan belirli standartlaştırılmış, yayımlanmış bir şemaya uyum sağlamak için gereken türlere sahip bir hizmet oluştururken.</span><span class="sxs-lookup"><span data-stu-id="f0402-132">When precise control over the XML that appears in messages is important, but a Web Services Description Language (WSDL) document is not available, for example, when creating a service with types that have to comply to a certain standardized, published schema that is not compatible with the DataContractSerializer.</span></span>

- <span data-ttu-id="f0402-133">Eski SOAP kodlama standardını izleyen hizmetler oluştururken.</span><span class="sxs-lookup"><span data-stu-id="f0402-133">When creating services that follow the legacy SOAP Encoding standard.</span></span>

<span data-ttu-id="f0402-134">Bu ve diğer durumlarda, <xref:System.Xml.Serialization.XmlSerializer> `XmlSerializerFormatAttribute` aşağıdaki kodda gösterildiği gibi, özniteliğini hizmetinize uygulayarak sınıfa el ile geçiş yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f0402-134">In these and other cases, you can manually switch to the <xref:System.Xml.Serialization.XmlSerializer> class by applying the `XmlSerializerFormatAttribute` attribute to your service, as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#1)]
[!code-vb[c_XmlSerializer#1](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#1)]

## <a name="security-considerations"></a><span data-ttu-id="f0402-135">Güvenlikle İlgili Dikkat Edilmesi Gerekenler</span><span class="sxs-lookup"><span data-stu-id="f0402-135">Security Considerations</span></span>

> [!NOTE]
> <span data-ttu-id="f0402-136">Serileştirme altyapılarını değiştirirken dikkatli olmanız önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f0402-136">It is important to be careful when switching serialization engines.</span></span> <span data-ttu-id="f0402-137">Aynı tür, kullanılmakta olan seri hale getiriciye göre farklı şekilde XML 'e serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-137">The same type can serialize to XML differently depending on the serializer being used.</span></span> <span data-ttu-id="f0402-138">Yanlışlıkla yanlış seri hale getirici kullanıyorsanız, bu bilgilerin açığa çıkarmamasını istemediğiniz türden bilgileri kapatıyorsunuz olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f0402-138">If you accidentally use the wrong serializer, you might be disclosing information from the type that you did not intend to disclose.</span></span>

<span data-ttu-id="f0402-139">Örneğin, <xref:System.Runtime.Serialization.DataContractSerializer> sınıfı yalnızca <xref:System.Runtime.Serialization.DataMemberAttribute> veri anlaşması türlerini serileştirilirken özniteliği ile işaretlenmiş üyeleri seri hale getirir.</span><span class="sxs-lookup"><span data-stu-id="f0402-139">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> class only serializes members marked with the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute when serializing data contract types.</span></span> <span data-ttu-id="f0402-140"><xref:System.Xml.Serialization.XmlSerializer>Sınıfı herhangi bir genel üyeyi seri hale getirir.</span><span class="sxs-lookup"><span data-stu-id="f0402-140">The <xref:System.Xml.Serialization.XmlSerializer> class serializes any public member.</span></span> <span data-ttu-id="f0402-141">Aşağıdaki kodda bulunan türe bakın.</span><span class="sxs-lookup"><span data-stu-id="f0402-141">See the type in the following code.</span></span>

[!code-csharp[c_XmlSerializer#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#2)]
[!code-vb[c_XmlSerializer#2](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#2)]

<span data-ttu-id="f0402-142">Tür, sınıfın seçildiği bir hizmet sözleşmesinde yanlışlıkla kullanılırsa, <xref:System.Xml.Serialization.XmlSerializer> `creditCardNumber` üye serileştirilir, büyük olasılıkla hedeflenmemiştir.</span><span class="sxs-lookup"><span data-stu-id="f0402-142">If the type is inadvertently used in a service contract where the <xref:System.Xml.Serialization.XmlSerializer> class is selected, the `creditCardNumber` member is serialized, which is probably not intended.</span></span>

<span data-ttu-id="f0402-143"><xref:System.Runtime.Serialization.DataContractSerializer>Sınıf varsayılan olsa da, <xref:System.ServiceModel.DataContractFormatAttribute> özelliği hizmet sözleşmesi türüne uygulayarak hizmeti için açıkça seçebilirsiniz (bunu yapmanız hiçbir şekilde yapmanız gerekmese de).</span><span class="sxs-lookup"><span data-stu-id="f0402-143">Even though the <xref:System.Runtime.Serialization.DataContractSerializer> class is the default, you can explicitly select it for your service (although doing this should never be required) by applying the <xref:System.ServiceModel.DataContractFormatAttribute> attribute to the service contract type.</span></span>

<span data-ttu-id="f0402-144">Hizmet için kullanılan serileştirici, sözleşmenin ayrılmaz bir parçasıdır ve farklı bir bağlama seçilerek veya diğer yapılandırma ayarları değiştirilerek değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="f0402-144">The serializer used for the service is an integral part of the contract and cannot be changed by selecting a different binding or by changing other configuration settings.</span></span>

<span data-ttu-id="f0402-145">Sınıfına yönelik diğer önemli güvenlik konuları geçerlidir <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f0402-145">Other important security considerations apply to the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="f0402-146">İlk olarak, sınıfını kullanan tüm WCF uygulamalarının <xref:System.Xml.Serialization.XmlSerializer> , açıklanmasından korunmuş bir anahtarla imzalanmış olması önemle tavsiye edilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-146">First, it is strongly recommended that any WCF application that uses the <xref:System.Xml.Serialization.XmlSerializer> class is signed with a key that is safeguarded from disclosure.</span></span> <span data-ttu-id="f0402-147">Bu öneri her ikisi de için el ile yapılan bir geçiş gerçekleştirildiğinde <xref:System.Xml.Serialization.XmlSerializer> ve bir otomatik anahtar gerçekleştirildiğinde (Svcutil.exe, hizmet başvurusu Ekle veya benzer bir araçla) geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f0402-147">This recommendation applies both when a manual switch to the <xref:System.Xml.Serialization.XmlSerializer> is performed and when an automatic switch is performed (by Svcutil.exe, Add Service Reference, or a similar tool).</span></span> <span data-ttu-id="f0402-148">Bunun nedeni, <xref:System.Xml.Serialization.XmlSerializer> serileştirme altyapısının uygulamayla aynı anahtarla İmzalandıkları sürece *önceden oluşturulmuş serileştirme derlemelerinin* yüklenmesini desteklemesinden kaynaklanır.</span><span class="sxs-lookup"><span data-stu-id="f0402-148">This is because the <xref:System.Xml.Serialization.XmlSerializer> serialization engine supports the loading of *pre-generated serialization assemblies* as long as they are signed with the same key as the application.</span></span> <span data-ttu-id="f0402-149">İmzasız bir uygulama, uygulama klasörüne veya genel derleme önbelleğine yerleştirilmiş önceden oluşturulmuş serileştirme derlemesinin beklenen adıyla eşleşen kötü amaçlı bir derleme olasılığa karşı tamamen korumasız olur.</span><span class="sxs-lookup"><span data-stu-id="f0402-149">An unsigned application is completely unprotected from the possibility of a malicious assembly matching the expected name of the pre-generated serialization assembly being placed in the application folder or the global assembly cache.</span></span> <span data-ttu-id="f0402-150">Tabii ki, bu eylemi denemek için bir saldırganın öncelikle bu iki konumdan birine yazma erişimi edinilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0402-150">Of course, an attacker must first gain write access to one of these two locations to attempt this action.</span></span>

<span data-ttu-id="f0402-151">Her kullanışınızda <xref:System.Xml.Serialization.XmlSerializer> , sistem geçici klasörüne yazma erişimiyle ilgili olan başka bir tehdit vardır.</span><span class="sxs-lookup"><span data-stu-id="f0402-151">Another threat that exists whenever you use <xref:System.Xml.Serialization.XmlSerializer> is related to write access to the system temporary folder.</span></span> <span data-ttu-id="f0402-152"><xref:System.Xml.Serialization.XmlSerializer>Serileştirme altyapısı, bu klasörde geçici *serileştirme derlemeleri* oluşturur ve kullanır.</span><span class="sxs-lookup"><span data-stu-id="f0402-152">The <xref:System.Xml.Serialization.XmlSerializer> serialization engine creates and uses temporary *serialization assemblies* in this folder.</span></span> <span data-ttu-id="f0402-153">Geçici klasöre yazma erişimi olan herhangi bir işlemin, bu serileştirme derlemelerinin kötü amaçlı kodla üzerine yazamayacağını bilmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="f0402-153">You should be aware that any process with write access to the temporary folder may overwrite these serialization assemblies with malicious code.</span></span>

## <a name="rules-for-xmlserializer-support"></a><span data-ttu-id="f0402-154">XmlSerializer desteği için kurallar</span><span class="sxs-lookup"><span data-stu-id="f0402-154">Rules for XmlSerializer support</span></span>

<span data-ttu-id="f0402-155"><xref:System.Xml.Serialization.XmlSerializer>Anlaşma işlemi parametrelerine veya dönüş değerlerine doğrudan uyumlu öznitelikleri uygulayamazsınız.</span><span class="sxs-lookup"><span data-stu-id="f0402-155">You cannot directly apply <xref:System.Xml.Serialization.XmlSerializer>-compatible attributes to contract operation parameters or return values.</span></span> <span data-ttu-id="f0402-156">Ancak, aşağıdaki kodda gösterildiği gibi, yazılı iletilere (ileti sözleşmesi gövde parçaları) uygulanabilirler.</span><span class="sxs-lookup"><span data-stu-id="f0402-156">However, they can be applied to typed messages (message contract body parts), as shown in the following code.</span></span>

[!code-csharp[c_XmlSerializer#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#3)]
[!code-vb[c_XmlSerializer#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#3)]

<span data-ttu-id="f0402-157">Yazılı ileti üyelerine uygulandığında, bu öznitelikler yazılan ileti özniteliklerinde çakışan özellikleri geçersiz kılar.</span><span class="sxs-lookup"><span data-stu-id="f0402-157">When applied to typed message members, these attributes override properties that conflict on the typed message attributes.</span></span> <span data-ttu-id="f0402-158">Örneğin, aşağıdaki kodda `ElementName` geçersiz kılmalar `Name` .</span><span class="sxs-lookup"><span data-stu-id="f0402-158">For example, in the following code, `ElementName` overrides `Name`.</span></span>

[!code-csharp[c_XmlSerializer#4](../../../../samples/snippets/csharp/VS_Snippets_CFX/c_xmlserializer/cs/source.cs#4)]
[!code-vb[c_XmlSerializer#4](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/c_xmlserializer/vb/source.vb#4)]

<span data-ttu-id="f0402-159"><xref:System.ServiceModel.MessageHeaderArrayAttribute>Özelliği kullanılırken özniteliği desteklenmez <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f0402-159">The <xref:System.ServiceModel.MessageHeaderArrayAttribute> attribute is not supported when using the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

> [!NOTE]
> <span data-ttu-id="f0402-160">Bu durumda, WCF 'den <xref:System.Xml.Serialization.XmlSerializer> önce yayınlanan aşağıdaki özel durumu oluşturur: "şemanın en üst düzeyinde bildirildiği bir öğe `maxOccurs` > 1 olamaz.</span><span class="sxs-lookup"><span data-stu-id="f0402-160">In this case, the <xref:System.Xml.Serialization.XmlSerializer> throws the following exception, which is released prior to WCF: "An element declared at the top level of a schema cannot have `maxOccurs` > 1.</span></span> <span data-ttu-id="f0402-161">' More ' için veya `XmlArray` `XmlArrayItem` yerine ya `XmlElementAttribute` da Sarmalanan parametre stilini kullanarak ' More ' için bir sarmalayıcı öğesi sağlayın. "</span><span class="sxs-lookup"><span data-stu-id="f0402-161">Provide a wrapper element for 'more' by using `XmlArray` or `XmlArrayItem` instead of `XmlElementAttribute`, or by using the Wrapped parameter style."</span></span>
>
> <span data-ttu-id="f0402-162">Böyle bir özel durum alırsanız, bu durumun uygulanıp uygulanmadığını araştırın.</span><span class="sxs-lookup"><span data-stu-id="f0402-162">If you receive such an exception, investigate whether this situation applies.</span></span>

<span data-ttu-id="f0402-163">WCF, <xref:System.Xml.Serialization.SoapIncludeAttribute> <xref:System.Xml.Serialization.XmlIncludeAttribute> İleti sözleşmeleri ve işlem sözleşmeleri içindeki ve özniteliklerini desteklemez; <xref:System.Runtime.Serialization.KnownTypeAttribute> bunun yerine özniteliğini kullanın.</span><span class="sxs-lookup"><span data-stu-id="f0402-163">WCF does not support the <xref:System.Xml.Serialization.SoapIncludeAttribute> and <xref:System.Xml.Serialization.XmlIncludeAttribute> attributes in message contracts and operation contracts; use the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute instead.</span></span>

## <a name="types-that-implement-the-ixmlserializable-interface"></a><span data-ttu-id="f0402-164">IXmlSerializable arabirimini uygulayan türler</span><span class="sxs-lookup"><span data-stu-id="f0402-164">Types that Implement the IXmlSerializable Interface</span></span>

<span data-ttu-id="f0402-165">Arabirimini uygulayan türler `IXmlSerializable` tarafından tamamen desteklenir `DataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="f0402-165">Types that implement the `IXmlSerializable` interface are fully supported by the `DataContractSerializer`.</span></span> <span data-ttu-id="f0402-166"><xref:System.Xml.Serialization.XmlSchemaProviderAttribute>Bu türlerin şemasını denetlemek için özniteliği her zaman bu türlere uygulanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-166">The <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute should always be applied to these types to control their schema.</span></span>

> [!WARNING]
> <span data-ttu-id="f0402-167">Polimorfik türler serileştirilmiş olmanız durumunda <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> doğru türün serileştirildiğinden emin olmak için türünü türüne uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0402-167">If you are serializing polymorphic types you must apply the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> to the type to ensure the correct type is serialized.</span></span>

<span data-ttu-id="f0402-168">Şunları uygulayan tür üç değişken vardır `IXmlSerializable` : rastgele içeriği temsil eden türler, tek bir öğeyi temsil eden türler ve eski <xref:System.Data.DataSet> türler.</span><span class="sxs-lookup"><span data-stu-id="f0402-168">There are three varieties of types that implement `IXmlSerializable`: types that represent arbitrary content, types that represent a single element, and legacy <xref:System.Data.DataSet> types.</span></span>

- <span data-ttu-id="f0402-169">İçerik türleri özniteliği tarafından belirtilen bir şema sağlayıcısı yöntemini kullanır `XmlSchemaProviderAttribute` .</span><span class="sxs-lookup"><span data-stu-id="f0402-169">Content types use a schema provider method specified by the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="f0402-170">Yöntemi döndürmez `null` ve <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> özniteliğinde özelliği varsayılan değerinde bırakılır `false` .</span><span class="sxs-lookup"><span data-stu-id="f0402-170">The method does not return `null` and the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the attribute is left at its default value of `false`.</span></span> <span data-ttu-id="f0402-171">Bu, türlerin en yaygın kullanımdır `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="f0402-171">This is the most common usage of `IXmlSerializable` types.</span></span>

- <span data-ttu-id="f0402-172">Öğe türleri, bir `IXmlSerializable` türün kendi kök öğe adını denetlemesini gerektiğinde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f0402-172">Element types are used when an `IXmlSerializable` type must control its own root element name.</span></span> <span data-ttu-id="f0402-173">Bir türü öğe türü olarak işaretlemek için, <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> öznitelik üzerinde özelliğini, <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> `true` şema sağlayıcısı yönteminden veya geri dönüş olarak ayarlayın `null` .</span><span class="sxs-lookup"><span data-stu-id="f0402-173">To mark a type as an element type, either set the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute.IsAny%2A> property on the <xref:System.Xml.Serialization.XmlSchemaProviderAttribute> attribute to `true` or return `null` from the schema provider method.</span></span> <span data-ttu-id="f0402-174">Bir şema sağlayıcısı yönteminin olması, öğe türleri için isteğe bağlıdır `null` ; içinde Yöntem adı yerine belirtebilirsiniz `XmlSchemaProviderAttribute` .</span><span class="sxs-lookup"><span data-stu-id="f0402-174">Having a schema provider method is optional for element types – you may specify `null` instead of the method name in the `XmlSchemaProviderAttribute`.</span></span> <span data-ttu-id="f0402-175">Ancak, `IsAny` `true` ve bir şema sağlayıcısı yöntemi belirtilmişse, Yöntemi döndürmelidir `null` .</span><span class="sxs-lookup"><span data-stu-id="f0402-175">However, if `IsAny` is `true` and a schema provider method is specified, the method must return `null`.</span></span>

- <span data-ttu-id="f0402-176">Eski <xref:System.Data.DataSet> türler `IXmlSerializable` , özniteliğiyle işaretlenmemiş türlerdir `XmlSchemaProviderAttribute` .</span><span class="sxs-lookup"><span data-stu-id="f0402-176">Legacy <xref:System.Data.DataSet> types are `IXmlSerializable` types that are not marked with the `XmlSchemaProviderAttribute` attribute.</span></span> <span data-ttu-id="f0402-177">Bunun yerine, <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> şema oluşturma yöntemine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-177">Instead, they rely on the <xref:System.Xml.Serialization.IXmlSerializable.GetSchema%2A> method for schema generation.</span></span> <span data-ttu-id="f0402-178">Bu model, türü için kullanılır `DataSet` ve türü belirtilmiş veri kümesi .NET Framework önceki sürümlerinde bir sınıf türetiliyor, ancak artık kullanılmıyor ve yalnızca eski nedenlerden dolayı destekleniyor.</span><span class="sxs-lookup"><span data-stu-id="f0402-178">This pattern is used for the `DataSet` type and its typed dataset derives a class in earlier versions of the .NET Framework, but is now obsolete and is supported only for legacy reasons.</span></span> <span data-ttu-id="f0402-179">Bu modele güvenmeyin ve her zaman `XmlSchemaProviderAttribute` `IXmlSerializable` türlerinizi uygulayın.</span><span class="sxs-lookup"><span data-stu-id="f0402-179">Do not rely on this pattern and always apply the `XmlSchemaProviderAttribute` to your `IXmlSerializable` types.</span></span>

### <a name="ixmlserializable-content-types"></a><span data-ttu-id="f0402-180">IXmlSerializable Içerik türleri</span><span class="sxs-lookup"><span data-stu-id="f0402-180">IXmlSerializable Content Types</span></span>

<span data-ttu-id="f0402-181">, Uygulayan `IXmlSerializable` ve daha önce tanımlanan bir içerik türü olan bir veri üyesini serileştirilirken, serileştirici veri üyesine yönelik sarmalayıcı öğesini yazar ve denetimi <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> yöntemine geçirir.</span><span class="sxs-lookup"><span data-stu-id="f0402-181">When serializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the serializer writes the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> method.</span></span> <span data-ttu-id="f0402-182"><xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A>Uygulama, sarmalayıcı öğesine öznitelik eklemeyi içeren herhangi BIR XML yazabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-182">The <xref:System.Xml.Serialization.IXmlSerializable.WriteXml%2A> implementation can write any XML, which includes adding attributes to the wrapper element.</span></span> <span data-ttu-id="f0402-183">İşlem tamamlandıktan sonra `WriteXml` seri hale getirici öğeyi kapatır.</span><span class="sxs-lookup"><span data-stu-id="f0402-183">After `WriteXml` is done, the serializer closes the element.</span></span>

<span data-ttu-id="f0402-184">Uygulayan `IXmlSerializable` ve daha önce tanımlanan bir içerik türü olan bir veri üyesinin serisi kaldırılırken, seri hale getirici veri üyesine yönelik sarmalayıcı ÖĞESINDE XML okuyucuyu konumlandırır ve denetimi <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> yöntemine geçirir.</span><span class="sxs-lookup"><span data-stu-id="f0402-184">When deserializing a data member of a type that implements `IXmlSerializable` and is a content type as defined previously, the deserializer positions the XML reader on the wrapper element for the data member and passes control to the <xref:System.Xml.Serialization.IXmlSerializable.ReadXml%2A> method.</span></span> <span data-ttu-id="f0402-185">Yöntemi, başlangıç ve bitiş etiketleri dahil olmak üzere tüm öğeyi okumalı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-185">The method must read the entire element, including the start and end tags.</span></span> <span data-ttu-id="f0402-186">`ReadXml`Kodunuzun, öğenin boş olduğu durumu işlediğinizden emin olun.</span><span class="sxs-lookup"><span data-stu-id="f0402-186">Make sure your `ReadXml` code handles the case where the element is empty.</span></span> <span data-ttu-id="f0402-187">Ayrıca, `ReadXml` uygulamanız belirli bir şekilde adlandırılan sarmalayıcı öğesine dayanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-187">Additionally, your `ReadXml` implementation should not rely on the wrapper element being named a particular way.</span></span> <span data-ttu-id="f0402-188">Seri hale getirici tarafından seçilen ad değişiklik gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-188">The name is chosen by the serializer can vary.</span></span>

<span data-ttu-id="f0402-189">`IXmlSerializable`Örneğin, türündeki veri üyelerine polymorphically içerik türleri atama izni verilir <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="f0402-189">It is permitted to assign `IXmlSerializable` content types polymorphically, for example, to data members of type <xref:System.Object>.</span></span> <span data-ttu-id="f0402-190">Tür örneklerinin null olması de buna izin verilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-190">It is also permitted for the type instances to be null.</span></span> <span data-ttu-id="f0402-191">Son olarak, `IXmlSerializable` türleri nesne Graph koruması etkin ve ile birlikte kullanmak mümkündür <xref:System.Runtime.Serialization.NetDataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f0402-191">Finally, it is possible to use `IXmlSerializable` types with object graph preservation enabled and with the <xref:System.Runtime.Serialization.NetDataContractSerializer>.</span></span> <span data-ttu-id="f0402-192">Tüm bu özellikler, WCF serileştiricinin belirli öznitelikleri sarmalayıcı öğesine ("Nil" ve "tür" i XML şema örneği ad alanında ve "ID", "ref", "Type" ve "Assembly" adlı WCF 'ye özgü bir ad alanında) iliştirmesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f0402-192">All these features require the WCF serializer to attach certain attributes into the wrapper element ("nil" and "type" in the XML Schema Instance namespace and "Id", "Ref", "Type" and "Assembly" in a WCF-specific namespace).</span></span>

#### <a name="attributes-to-ignore-when-implementing-readxml"></a><span data-ttu-id="f0402-193">ReadXml 'i uygularken yoksayılacak öznitelikler</span><span class="sxs-lookup"><span data-stu-id="f0402-193">Attributes to Ignore when Implementing ReadXml</span></span>

<span data-ttu-id="f0402-194">`ReadXml`Kodu kodunuza geçirmeden önce seri hale GETIRICI XML öğesini inceler, bu özel XML özniteliklerini algılar ve üzerinde davranır.</span><span class="sxs-lookup"><span data-stu-id="f0402-194">Before passing control to your `ReadXml` code, the deserializer examines the XML element, detects these special XML attributes, and acts on them.</span></span> <span data-ttu-id="f0402-195">Örneğin, "Nil" ise, `true` null değeri seri durumdan çıkarılmış olur ve `ReadXml` çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="f0402-195">For example, if "nil" is `true`, a null value is deserialized and `ReadXml` is not called.</span></span> <span data-ttu-id="f0402-196">Çok biçimlilik algılanırsa, öğesinin içeriği farklı türde gibi seri durumdan çıkarılacak.</span><span class="sxs-lookup"><span data-stu-id="f0402-196">If polymorphism is detected, the contents of the element are deserialized as if it was a different type.</span></span> <span data-ttu-id="f0402-197">Polymorphically tarafından atanan türün uygulamasının uygulamasına `ReadXml` denir.</span><span class="sxs-lookup"><span data-stu-id="f0402-197">The polymorphically-assigned type’s implementation of `ReadXml` is called.</span></span> <span data-ttu-id="f0402-198">Herhangi bir durumda, bir `ReadXml` uygulama, seri hale getirici tarafından işlendiği için bu özel öznitelikleri yoksaymalıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-198">In any case, a `ReadXml` implementation should ignore these special attributes because they are handled by the deserializer.</span></span>

### <a name="schema-considerations-for-ixmlserializable-content-types"></a><span data-ttu-id="f0402-199">IXmlSerializable Içerik türleri için şema konuları</span><span class="sxs-lookup"><span data-stu-id="f0402-199">Schema Considerations for IXmlSerializable Content Types</span></span>

<span data-ttu-id="f0402-200">Şema ve `IXmlSerializable` içerik türü dışarı aktarılırken, şema sağlayıcısı yöntemi çağırılır.</span><span class="sxs-lookup"><span data-stu-id="f0402-200">When exporting schema and an `IXmlSerializable` content type, the schema provider method is called.</span></span> <span data-ttu-id="f0402-201"><xref:System.Xml.Schema.XmlSchemaSet>Şema sağlayıcısı yöntemine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-201">An <xref:System.Xml.Schema.XmlSchemaSet> is passed to the schema provider method.</span></span> <span data-ttu-id="f0402-202">Yöntemi, şema kümesine geçerli bir şema ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-202">The method can add any valid schema to the schema set.</span></span> <span data-ttu-id="f0402-203">Şema kümesi, şema dışa aktarma gerçekleştiği sırada zaten bilinen şemayı içerir.</span><span class="sxs-lookup"><span data-stu-id="f0402-203">The schema set contains the schema that is already known at the time when schema export occurs.</span></span> <span data-ttu-id="f0402-204">Şema sağlayıcısı yönteminin şema kümesine bir öğe eklemesi gerektiğinde, <xref:System.Xml.Schema.XmlSchema> uygun ad alanı ile birlikte bir öğesinin küme içinde olup olmadığını belirlemesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="f0402-204">When the schema provider method must add an item to the schema set, it must determine whether an <xref:System.Xml.Schema.XmlSchema> with the appropriate namespace already exists in the set.</span></span> <span data-ttu-id="f0402-205">Varsa, şema sağlayıcısı yönteminin yeni öğeyi mevcut öğesine eklemesi gerekir `XmlSchema` .</span><span class="sxs-lookup"><span data-stu-id="f0402-205">If it does, the schema provider method must add the new item to the existing `XmlSchema`.</span></span> <span data-ttu-id="f0402-206">Aksi halde, yeni bir örnek oluşturması gerekir `XmlSchema` .</span><span class="sxs-lookup"><span data-stu-id="f0402-206">Otherwise, it must create a new `XmlSchema` instance.</span></span> <span data-ttu-id="f0402-207">Bu, tür dizileri kullanılıyorsa önemlidir `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="f0402-207">This is important if arrays of `IXmlSerializable` types are being used.</span></span> <span data-ttu-id="f0402-208">Örneğin, " `IXmlSerializable` b" ad alanında "A" türü olarak verilen bir tür varsa, şema sağlayıcısı yönteminin adı, şema kümesi "b" için "ArrayOfA" türünü tutmak için şemayı zaten içeriyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-208">For example, if you have an `IXmlSerializable` type that gets exported as type "A" in namespace "B", it is possible that by the time the schema provider method is called the schema set already contains the schema for "B" to hold the "ArrayOfA" type.</span></span>

<span data-ttu-id="f0402-209">Türüne tür eklemenin yanı sıra <xref:System.Xml.Schema.XmlSchemaSet> , içerik türleri için şema sağlayıcısı yöntemi null olmayan bir değer döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="f0402-209">In addition to adding types to the <xref:System.Xml.Schema.XmlSchemaSet>, the schema provider method for content types must return a non-null value.</span></span> <span data-ttu-id="f0402-210"><xref:System.Xml.XmlQualifiedName>Verilen tür için kullanılacak şema türünün adını belirten bir döndürebilir `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="f0402-210">It can return an <xref:System.Xml.XmlQualifiedName> that specifies the name of the schema type to use for the given `IXmlSerializable` type.</span></span> <span data-ttu-id="f0402-211">Bu tam ad ayrıca tür için veri anlaşması adı ve ad alanı olarak da kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f0402-211">This qualified name also serves as the data contract name and namespace for the type.</span></span> <span data-ttu-id="f0402-212">Şema sağlayıcısı yöntemi döndürüldüğünde, şema kümesinde varolmayan bir tür döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-212">It is permitted to return a type that does not exist in the schema set immediately when the schema provider method returns.</span></span> <span data-ttu-id="f0402-213">Ancak, tüm ilişkili türlerin verildiği zaman tarafından ( <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> yöntemi ' de tüm ilgili türler için çağrılır <xref:System.Runtime.Serialization.XsdDataContractExporter> ve <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> özelliğine erişilir), tür şema kümesinde bulunur.</span><span class="sxs-lookup"><span data-stu-id="f0402-213">However, it is expected that by the time all related types are exported (the <xref:System.Runtime.Serialization.XsdDataContractExporter.Export%2A> method is called for all relevant types on the <xref:System.Runtime.Serialization.XsdDataContractExporter> and the <xref:System.Runtime.Serialization.XsdDataContractExporter.Schemas%2A> property is accessed), the type exists in the schema set.</span></span> <span data-ttu-id="f0402-214">`Schemas`Tüm ilgili çağrılar yapılmadan önce özelliğe erişilmesi `Export` bir ile sonuçlanabilir <xref:System.Xml.Schema.XmlSchemaException> .</span><span class="sxs-lookup"><span data-stu-id="f0402-214">Accessing the `Schemas` property before all relevant `Export` calls have been made can result in an <xref:System.Xml.Schema.XmlSchemaException>.</span></span> <span data-ttu-id="f0402-215">Dışarı aktarma işlemi hakkında daha fazla bilgi için bkz. [sınıflardan şemaları dışarı aktarma](exporting-schemas-from-classes.md).</span><span class="sxs-lookup"><span data-stu-id="f0402-215">For more information about the export process, see [Exporting Schemas from Classes](exporting-schemas-from-classes.md).</span></span>

<span data-ttu-id="f0402-216">Şema sağlayıcısı yöntemi kullanmak için ' i de döndürebilir <xref:System.Xml.Schema.XmlSchemaType> .</span><span class="sxs-lookup"><span data-stu-id="f0402-216">The schema provider method can also return the <xref:System.Xml.Schema.XmlSchemaType> to use.</span></span> <span data-ttu-id="f0402-217">Tür anonim olmayabilir veya olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-217">The type may or may not be anonymous.</span></span> <span data-ttu-id="f0402-218">Anonim ise, tür şeması `IXmlSerializable` `IXmlSerializable` bir veri üyesi olarak her kullanıldığında anonim bir tür olarak verilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-218">If it is anonymous, the schema for the `IXmlSerializable` type is exported as an anonymous type every time the `IXmlSerializable` type is used as a data member.</span></span> <span data-ttu-id="f0402-219">`IXmlSerializable`Türün hala bir veri anlaşması adı ve ad alanı vardır.</span><span class="sxs-lookup"><span data-stu-id="f0402-219">The `IXmlSerializable` type still has a data contract name and namespace.</span></span> <span data-ttu-id="f0402-220">(Bu, ad özelleştirmek için özniteliğin kullanılamaz olması dışında, [veri anlaşması adlarında](data-contract-names.md) açıklandığı şekilde belirlenir <xref:System.Runtime.Serialization.DataContractAttribute> .) Anonim değilse, içindeki türlerden biri olmalıdır `XmlSchemaSet` .</span><span class="sxs-lookup"><span data-stu-id="f0402-220">(This is determined as described in [Data Contract Names](data-contract-names.md) except that the <xref:System.Runtime.Serialization.DataContractAttribute> attribute cannot be used to customize the name.) If it is not anonymous, it must be one of the types in the `XmlSchemaSet`.</span></span> <span data-ttu-id="f0402-221">Bu durum, türünün döndürülmesi ile eşdeğerdir `XmlQualifiedName` .</span><span class="sxs-lookup"><span data-stu-id="f0402-221">This case is equivalent to returning the `XmlQualifiedName` of the type.</span></span>

<span data-ttu-id="f0402-222">Ayrıca, genel bir öğe bildirimi tür için verilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-222">Additionally, a global element declaration is exported for the type.</span></span> <span data-ttu-id="f0402-223">Türün <xref:System.Xml.Serialization.XmlRootAttribute> kendisine uygulanan özniteliği yoksa, öğesi veri sözleşmesiyle aynı ada ve ad alanına sahiptir ve "boş bırakılabilir" özelliği olur `true` .</span><span class="sxs-lookup"><span data-stu-id="f0402-223">If the type does not have the <xref:System.Xml.Serialization.XmlRootAttribute> attribute applied to it, the element has the same name and namespace as the data contract, and its "nillable" property is `true`.</span></span> <span data-ttu-id="f0402-224">Bunun tek istisnası şema ad alanıdır ( `http://www.w3.org/2001/XMLSchema` ): türün veri sözleşmesi bu ad alanında yer alıyorsa, ilgili genel öğe, şema ad alanına yeni öğeler eklemek yasak olduğundan boş ad alanıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-224">The only exception to this is the schema namespace (`http://www.w3.org/2001/XMLSchema`) – if the type’s data contract is in this namespace, the corresponding global element is in the blank namespace because it is forbidden to add new elements to the schema namespace.</span></span> <span data-ttu-id="f0402-225">Türe `XmlRootAttribute` uygulanmış özniteliği varsa, genel öğe bildirimi aşağıdaki: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A> <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> ve özellikleri kullanılarak verilir <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> .</span><span class="sxs-lookup"><span data-stu-id="f0402-225">If the type has the `XmlRootAttribute` attribute applied to it, the global element declaration is exported using the following: <xref:System.Xml.Serialization.XmlRootAttribute.ElementName%2A>, <xref:System.Xml.Serialization.XmlRootAttribute.Namespace%2A> and <xref:System.Xml.Serialization.XmlRootAttribute.IsNullable%2A> properties.</span></span> <span data-ttu-id="f0402-226">`XmlRootAttribute`Uygulanan varsayılanlar, veri sözleşmesinin adı, boş bir ad alanı ve "boş bırakılabilir" olur `true` .</span><span class="sxs-lookup"><span data-stu-id="f0402-226">The defaults with `XmlRootAttribute` applied are the data contract name, a blank namespace and "nillable" being `true`.</span></span>

<span data-ttu-id="f0402-227">Aynı genel öğe bildirimi kuralları eski veri kümesi türleri için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f0402-227">The same global element declaration rules apply to legacy dataset types.</span></span> <span data-ttu-id="f0402-228">`XmlRootAttribute`Özel kod aracılığıyla eklenen genel öğe bildirimlerinin geçersiz kılınmadığını, `XmlSchemaSet` şema sağlayıcısı yöntemi kullanılarak veya `GetSchema` eski veri kümesi türleri için aracılığıyla geçersiz kılabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f0402-228">Note that the `XmlRootAttribute` cannot override global element declarations added through custom code, either added to the `XmlSchemaSet` using the schema provider method or through `GetSchema` for legacy dataset types.</span></span>

### <a name="ixmlserializable-element-types"></a><span data-ttu-id="f0402-229">IXmlSerializable öğe türleri</span><span class="sxs-lookup"><span data-stu-id="f0402-229">IXmlSerializable Element Types</span></span>

<span data-ttu-id="f0402-230">`IXmlSerializable`öğe türlerinde, `IsAny` özelliği olarak ayarlanmış ya da `true` şema sağlayıcısı yöntemi döndürüyor `null` .</span><span class="sxs-lookup"><span data-stu-id="f0402-230">`IXmlSerializable` element types have either the `IsAny` property set to `true` or have their schema provider method return `null`.</span></span>

<span data-ttu-id="f0402-231">Öğe türünü serileştirmek ve serisini kaldırma, içerik türünü serileştirmek ve seri durumdan çıkarmak için çok benzerdir.</span><span class="sxs-lookup"><span data-stu-id="f0402-231">Serializing and deserializing an element type is very similar to serializing and deserializing a content type.</span></span> <span data-ttu-id="f0402-232">Ancak bazı önemli farklılıklar vardır:</span><span class="sxs-lookup"><span data-stu-id="f0402-232">However, there are some important differences:</span></span>

- <span data-ttu-id="f0402-233">`WriteXml`Uygulamanın tam olarak bir öğe yazması bekleniyordu (kuşkusuz birden çok alt öğe içerebilir).</span><span class="sxs-lookup"><span data-stu-id="f0402-233">The `WriteXml` implementation is expected to write exactly one element (which could of course contain multiple child elements).</span></span> <span data-ttu-id="f0402-234">Bu tek öğe, birden çok eşdüzey öğe veya karışık içerik dışında öznitelikleri yazmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-234">It should not be writing attributes outside of this single element, multiple sibling elements or mixed content.</span></span> <span data-ttu-id="f0402-235">Öğe boş olabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-235">The element may be empty.</span></span>

- <span data-ttu-id="f0402-236">`ReadXml`Uygulama sarmalayıcı öğesini okumalı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-236">The `ReadXml` implementation should not read the wrapper element.</span></span> <span data-ttu-id="f0402-237">Üreten bir öğeyi okuması beklenmektedir `WriteXml` .</span><span class="sxs-lookup"><span data-stu-id="f0402-237">It is expected to read the one element that `WriteXml` produces.</span></span>

- <span data-ttu-id="f0402-238">Öğe türü düzenli olarak serileştirilirken (örneğin, bir veri sözleşmesindeki veri üyesi olarak), seri hale getirici, `WriteXml` içerik türlerinde olduğu gibi çağrılmadan önce bir sarmalayıcı öğesi verir.</span><span class="sxs-lookup"><span data-stu-id="f0402-238">When serializing an element type regularly (for example, as a data member in a data contract), the serializer outputs a wrapper element before calling `WriteXml`, as with content types.</span></span> <span data-ttu-id="f0402-239">Ancak, en üst düzeyde bir öğe türü serileştirilirken, seri hale getirici, `WriteXml` `DataContractSerializer` veya oluşturucularda serileştirici oluşturulurken bir kök ad ve ad alanı açıkça belirtilmediği takdirde, normalde bir sarmalayıcı öğesi yazar `NetDataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="f0402-239">However, when serializing an element type at the top level, the serializer does not normally output a wrapper element at all around the element that `WriteXml` writes, unless a root name and namespace are explicitly specified when constructing the serializer in the `DataContractSerializer` or `NetDataContractSerializer` constructors.</span></span> <span data-ttu-id="f0402-240">Daha fazla bilgi için bkz. [serileştirme ve seri durumundan çıkarma](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="f0402-240">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

- <span data-ttu-id="f0402-241">Yapılandırma zamanında kök adı ve ad alanını belirtmeden en üst düzeyde bir öğe türü serileştirilirken <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> ve <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> temelde hiçbir şey ve çağrı yapmaksızın <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> `WriteXml` .</span><span class="sxs-lookup"><span data-stu-id="f0402-241">When serializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteStartObject%2A> and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteEndObject%2A> essentially do nothing and <xref:System.Runtime.Serialization.XmlObjectSerializer.WriteObjectContent%2A> calls `WriteXml`.</span></span> <span data-ttu-id="f0402-242">Bu modda, serileştirilmekte olan nesne olamaz `null` ve polymorphically atanamaz.</span><span class="sxs-lookup"><span data-stu-id="f0402-242">In this mode, the object being serialized cannot be `null` and cannot be polymorphically assigned.</span></span> <span data-ttu-id="f0402-243">Ayrıca, nesne grafiği koruması etkinleştirilemez ve kullanılamaz `NetDataContractSerializer` .</span><span class="sxs-lookup"><span data-stu-id="f0402-243">Also, object graph preservation cannot enabled and the `NetDataContractSerializer` cannot be used.</span></span>

- <span data-ttu-id="f0402-244">Yapılandırma sırasında kök adı ve ad alanını belirtmeden en üst düzeyde bir öğe türü seri durumdan çıkarılırken, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> `true` herhangi bir öğenin başlangıcını bulabiliyorsanız ' ı döndürür.</span><span class="sxs-lookup"><span data-stu-id="f0402-244">When deserializing an element type at the top level without specifying the root name and namespace at construction time, <xref:System.Runtime.Serialization.XmlObjectSerializer.IsStartObject%2A> returns `true` if it can find the start of any element.</span></span> <span data-ttu-id="f0402-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A>parametresi, `verifyObjectName` `true` `IsStartObject` nesne gerçekten okunmadan önce ile aynı şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="f0402-245"><xref:System.Runtime.Serialization.XmlObjectSerializer.ReadObject%2A> with the `verifyObjectName` parameter set to `true` behaves in the same way as `IsStartObject` before actually reading the object.</span></span> <span data-ttu-id="f0402-246">`ReadObject`sonra denetimi yöntemine geçirir `ReadXml` .</span><span class="sxs-lookup"><span data-stu-id="f0402-246">`ReadObject` then passes control to `ReadXml` method.</span></span>

<span data-ttu-id="f0402-247">Öğe türleri için aktarılmış şema, `XmlElement` şema sağlayıcısı yönteminin <xref:System.Xml.Schema.XmlSchemaSet> içerik türleriyle olduğu gibi ek bir şema ekleyebildiğinden, daha önceki bir bölümde açıklanan tür ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-247">The schema exported for element types is the same as for the `XmlElement` type as described in an earlier section, except that the schema provider method can add any additional schema to the <xref:System.Xml.Schema.XmlSchemaSet> as with content types.</span></span> <span data-ttu-id="f0402-248">`XmlRootAttribute`Özniteliğin öğe türleriyle kullanılmasına izin verilmez ve genel öğe bildirimleri bu türler için hiçbir şekilde yayılmaz.</span><span class="sxs-lookup"><span data-stu-id="f0402-248">Using the `XmlRootAttribute` attribute with element types is not allowed, and global element declarations are never emitted for these types.</span></span>

### <a name="differences-from-the-xmlserializer"></a><span data-ttu-id="f0402-249">XmlSerializer 'ın farkları</span><span class="sxs-lookup"><span data-stu-id="f0402-249">Differences from the XmlSerializer</span></span>

<span data-ttu-id="f0402-250">`IXmlSerializable`Arabirimi ve `XmlSchemaProviderAttribute` ve `XmlRootAttribute` öznitelikleri de tarafından anlaşılamalıdır <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f0402-250">The `IXmlSerializable` interface and the `XmlSchemaProviderAttribute` and `XmlRootAttribute` attributes are also understood by the <xref:System.Xml.Serialization.XmlSerializer> .</span></span> <span data-ttu-id="f0402-251">Bununla birlikte, bunların veri anlaşması modelinde nasıl ele alınların bazı farklılıkları vardır.</span><span class="sxs-lookup"><span data-stu-id="f0402-251">However, there are some differences in how these are treated in the data contract model.</span></span> <span data-ttu-id="f0402-252">Önemli farklılıklar aşağıdaki listede özetlenmiştir:</span><span class="sxs-lookup"><span data-stu-id="f0402-252">The important differences are summarized in the following list:</span></span>

- <span data-ttu-id="f0402-253">Şema sağlayıcısı yönteminin ' de kullanılabilmesi için genel olması gerekir `XmlSerializer` , ancak veri sözleşmesi modelinde kullanılabilmesi için genel olması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="f0402-253">The schema provider method must be public to be used in the `XmlSerializer`, but does not have to be public to be used in the data contract model.</span></span>

- <span data-ttu-id="f0402-254">Şema sağlayıcısı yöntemi `IsAny` `true` , veri anlaşması modelinde olduğunda çağrılır, ancak ile değil `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="f0402-254">The schema provider method is called when `IsAny` is `true` in the data contract model but not with the `XmlSerializer`.</span></span>

- <span data-ttu-id="f0402-255">`XmlRootAttribute`İçerik veya eski veri kümesi türleri için öznitelik mevcut olmadığında, `XmlSerializer` boş ad alanında genel bir öğe bildirimini dışarı aktarır.</span><span class="sxs-lookup"><span data-stu-id="f0402-255">When the `XmlRootAttribute` attribute is not present for content or legacy dataset types, the `XmlSerializer` exports a global element declaration in the blank namespace.</span></span> <span data-ttu-id="f0402-256">Veri anlaşması modelinde, kullanılan ad alanı normalde daha önce açıklandığı gibi veri sözleşmesi ad alanıdır.</span><span class="sxs-lookup"><span data-stu-id="f0402-256">In the data contract model, the namespace used is normally the data contract namespace as described earlier.</span></span>

<span data-ttu-id="f0402-257">Serileştirme teknolojileriyle birlikte kullanılan türler oluşturulurken bu farklılıklara dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="f0402-257">Be aware of these differences when creating types that are used with both serialization technologies.</span></span>

### <a name="importing-ixmlserializable-schema"></a><span data-ttu-id="f0402-258">IXmlSerializable şeması içeri aktarılıyor</span><span class="sxs-lookup"><span data-stu-id="f0402-258">Importing IXmlSerializable Schema</span></span>

<span data-ttu-id="f0402-259">Türlerden oluşturulan bir şemayı içeri aktarırken `IXmlSerializable` birkaç olasılık vardır:</span><span class="sxs-lookup"><span data-stu-id="f0402-259">When importing a schema generated from `IXmlSerializable` types, there are a few possibilities:</span></span>

- <span data-ttu-id="f0402-260">Oluşturulan şema, [veri sözleşmesi şema başvurusunda](data-contract-schema-reference.md)açıklandığı gibi geçerli bir veri anlaşması şeması olabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-260">The generated schema may be a valid data contract schema as described in [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span> <span data-ttu-id="f0402-261">Bu durumda, her zamanki gibi şema içeri aktarılabilir ve normal veri anlaşması türleri oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f0402-261">In this case, schema can be imported as usual and regular data contract types are generated.</span></span>

- <span data-ttu-id="f0402-262">Oluşturulan şema geçerli bir veri anlaşması şeması olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-262">The generated schema may not be a valid data contract schema.</span></span> <span data-ttu-id="f0402-263">Örneğin, şema sağlayıcınız yönteminiz, veri anlaşması modelinde desteklenmeyen XML özniteliklerini içeren bir şema üretebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-263">For example, your schema provider method may generate schema that involves XML attributes that are not supported in the data contract model.</span></span> <span data-ttu-id="f0402-264">Bu durumda, şemayı türler olarak içeri aktarabilirsiniz `IXmlSerializable` .</span><span class="sxs-lookup"><span data-stu-id="f0402-264">In this case, you can import the schema as `IXmlSerializable` types.</span></span> <span data-ttu-id="f0402-265">Bu içeri aktarma modu varsayılan olarak açık değildir ancak örneğin, `/importXmlTypes` [ServiceModel meta veri yardımcı programı aracına (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md)komut satırı anahtarı ile birlikte kolayca etkinleştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-265">This import mode is not on by default but can easily be enabled – for example, with the `/importXmlTypes` command-line switch to the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md).</span></span> <span data-ttu-id="f0402-266">Bu, [sınıfları oluşturmak Için Içeri aktarma şemasında](importing-schema-to-generate-classes.md)ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f0402-266">This is described in detail in the [Importing Schema to Generate Classes](importing-schema-to-generate-classes.md).</span></span> <span data-ttu-id="f0402-267">Doğrudan tür örneklerinizin XML ile birlikte çalışmanız gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f0402-267">Note that you must work directly with the XML for your type instances.</span></span> <span data-ttu-id="f0402-268">Ayrıca, daha geniş bir şema aralığını destekleyen farklı bir serileştirme teknolojisi kullanmayı da düşünebilirsiniz; bkz. kullanma konusu `XmlSerializer` .</span><span class="sxs-lookup"><span data-stu-id="f0402-268">You may also consider using a different serialization technology that supports a wider range of schema – see the topic on using the `XmlSerializer`.</span></span>

- <span data-ttu-id="f0402-269">Mevcut `IXmlSerializable` türlerinizi yeni bir oluşturma yerine proxy 'de yeniden kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f0402-269">You may want to reuse your existing `IXmlSerializable` types in the proxy instead of generating new ones.</span></span> <span data-ttu-id="f0402-270">Bu durumda, tür oluşturmak için şemayı Içeri aktarma konu başlığı altında açıklanan Başvurulmuş türler özelliği, yeniden kullanılacak türü belirtmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-270">In this case, the referenced types feature described in the Importing Schema to Generate Types topic can be used to indicate the type to reuse.</span></span> <span data-ttu-id="f0402-271">Bu, `/reference` yeniden kullanılacak türleri içeren derlemeyi belirten svcutil.exe üzerinde anahtarı kullanmaya karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="f0402-271">This corresponds to using the `/reference` switch on svcutil.exe, which specifies the assembly that contains the types to reuse.</span></span>

### <a name="xmlserializer-legacy-behavior"></a><span data-ttu-id="f0402-272">XmlSerializer eski davranışı</span><span class="sxs-lookup"><span data-stu-id="f0402-272">XmlSerializer Legacy Behavior</span></span>

<span data-ttu-id="f0402-273">.NET Framework 4,0 ve önceki sürümlerde XmlSerializer, C# kodunu bir dosyaya yazarak geçici serileştirme derlemeleri oluşturdu.</span><span class="sxs-lookup"><span data-stu-id="f0402-273">In the .NET Framework 4.0 and earlier, the XmlSerializer generated temporary serialization assemblies by writing C# code to a file.</span></span> <span data-ttu-id="f0402-274">Dosya daha sonra bir derlemeye derlendi.</span><span class="sxs-lookup"><span data-stu-id="f0402-274">The file was then compiled into an assembly.</span></span>  <span data-ttu-id="f0402-275">Bu davranış, serileştiricinin başlama süresini yavaşlatarak bazı istenmeyen sonuçlara sahipti.</span><span class="sxs-lookup"><span data-stu-id="f0402-275">This behavior had some undesirable consequences like slowing the startup time for the serializer.</span></span> <span data-ttu-id="f0402-276">.NET Framework 4,5 ' de, bu davranış derleyicinin kullanılmasına gerek kalmadan derlemeleri oluşturmak üzere değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="f0402-276">In .NET Framework 4.5, this behavior was changed to generate the assemblies without requiring use of the compiler.</span></span> <span data-ttu-id="f0402-277">Bazı geliştiriciler oluşturulan C# kodunu görmek isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="f0402-277">Some developers may wish to see the generated C# code.</span></span> <span data-ttu-id="f0402-278">Aşağıdaki yapılandırmayla bu eski davranışı kullanmayı belirtebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f0402-278">You can specify to use this legacy behavior by the following configuration:</span></span>

```xml
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <system.xml.serialization>
    <xmlSerializer tempFilesLocation='e:\temp\XmlSerializerBug' useLegacySerializerGeneration="true" />
  </system.xml.serialization>
  <system.diagnostics>
    <switches>
      <add name="XmlSerialization.Compilation" value="1" />
    </switches>
  </system.diagnostics>
</configuration>
```

<span data-ttu-id="f0402-279">`XmlSerializer`Türetilmiş bir sınıfı genel olmayan yeni bir geçersiz kılma ile seri hale getirmek başarısız gibi uyumluluk sorunları yaşıyorsanız, `XMLSerializer` aşağıdaki yapılandırmayı kullanarak eski davranışa geri dönebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f0402-279">If you run into compatibility issues,  such as the `XmlSerializer` failing to serialize a derived class with a non-public new override, you can switch back to the  `XMLSerializer` legacy behavior by using the following configuration:</span></span>

```xml
<configuration>
  <appSettings>
    <add key="System:Xml:Serialization:UseLegacySerializerGeneration" value="true" />
  </appSettings>
</configuration>
```

<span data-ttu-id="f0402-280">Yukarıdaki yapılandırmaya alternatif olarak, aşağıdaki yapılandırmayı .NET Framework 4,5 veya sonraki bir sürümü çalıştıran bir makinede kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f0402-280">As an alternative to the above configuration, you can use the following configuration on a machine running .NET Framework 4.5 or later version:</span></span>

```xml
<configuration>
  <system.xml.serialization>
    <xmlSerializer useLegacySerializerGeneration="true"/>
  </system.xml.serialization>
</configuration>
```

> [!NOTE]
> <span data-ttu-id="f0402-281">`<xmlSerializer useLegacySerializerGeneration="true"/>`Anahtar yalnızca .NET Framework 4,5 veya üzeri bir sürümü çalıştıran bir makinede çalışır.</span><span class="sxs-lookup"><span data-stu-id="f0402-281">The `<xmlSerializer useLegacySerializerGeneration="true"/>` switch only works on a machine running .NET Framework 4.5 or later version.</span></span> <span data-ttu-id="f0402-282">Yukarıdaki `appSettings` yaklaşım tüm .NET Framework sürümlerinde geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f0402-282">The above `appSettings` approach works on all .NET Framework versions.</span></span>

## <a name="see-also"></a><span data-ttu-id="f0402-283">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="f0402-283">See also</span></span>

- <xref:System.ServiceModel.DataContractFormatAttribute>
- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.Serialization.XmlSerializer>
- <xref:System.ServiceModel.MessageHeaderArrayAttribute>
- [<span data-ttu-id="f0402-284">Hizmet Anlaşmalarında Veri Aktarımını Belirtme</span><span class="sxs-lookup"><span data-stu-id="f0402-284">Specifying Data Transfer in Service Contracts</span></span>](specifying-data-transfer-in-service-contracts.md)
- [<span data-ttu-id="f0402-285">Veri Anlaşmalarını Kullanma</span><span class="sxs-lookup"><span data-stu-id="f0402-285">Using Data Contracts</span></span>](using-data-contracts.md)
- [<span data-ttu-id="f0402-286">Nasıl yapılır: XmlSerializer Kullanarak WCF İstemci Uygulamalarının Başlangıç Zamanlarını İyileştirme</span><span class="sxs-lookup"><span data-stu-id="f0402-286">How to: Improve the Startup Time of WCF Client Applications using the XmlSerializer</span></span>](startup-time-of-wcf-client-applications-using-the-xmlserializer.md)
