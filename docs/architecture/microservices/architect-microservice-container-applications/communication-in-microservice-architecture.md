---
title: Mikro hizmet mimarisinde iletişim
description: Mikro hizmetler arasındaki farklı iletişim yollarını keşfedin, senkron ve eşzamanlı yöntemlerin etkilerini anlayın.
ms.date: 01/30/2020
ms.openlocfilehash: f2d6e78966bb7d5f481de6db0ab1dcfe2812a1b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401657"
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="37c14-103">Mikro hizmet mimarisinde iletişim</span><span class="sxs-lookup"><span data-stu-id="37c14-103">Communication in a microservice architecture</span></span>

<span data-ttu-id="37c14-104">Tek bir işlemüzerinde çalışan yekpare bir uygulamada, bileşenler dil düzeyinde yöntem veya işlev çağrıları kullanarak birbirlerini çağırır.</span><span class="sxs-lookup"><span data-stu-id="37c14-104">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="37c14-105">Bunlar, kodlu nesneler oluşturuyorsanız (örneğin,) `new ClassName()`güçlü bir şekilde birleşebilir veya somut nesne örnekleri yerine soyutlamalara başvurarak Bağımlılık Enjeksiyonu kullanıyorsanız, ayrılmış bir şekilde çağrılabilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-105">These can be strongly coupled if you're creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you're using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="37c14-106">Her iki durumda da, nesneler aynı işlem içinde çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="37c14-106">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="37c14-107">Yekpare bir uygulamadan mikrohizmet tabanlı bir uygulamaya geçerken en büyük zorluk iletişim mekanizmasının değiştirilmesidir.</span><span class="sxs-lookup"><span data-stu-id="37c14-107">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="37c14-108">İşlem içi yöntem çağrılarından rpc çağrılarına doğrudan dönüşüm, dağıtılmış ortamlarda iyi performans göstermeyen geveze ve verimli olmayan bir iletişime neden olur.</span><span class="sxs-lookup"><span data-stu-id="37c14-108">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that won't perform well in distributed environments.</span></span> <span data-ttu-id="37c14-109">Dağıtılmış sistemi düzgün bir şekilde tasarlamanın zorlukları, geliştiricilerin yekpare tasarımlardan dağıtılmış tasarımlara geçiş yaparken sıklıkla yaptıkları varsayımları listeleyen [dağıtılmış bilgi işlemin Fallacies'i](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) olarak bilinen bir kanon bile olduğu yeterince iyi bilinmektedir.</span><span class="sxs-lookup"><span data-stu-id="37c14-109">The challenges of designing distributed system properly are well enough known that there's even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="37c14-110">Tek bir çözüm değil, birkaç tane var.</span><span class="sxs-lookup"><span data-stu-id="37c14-110">There isn't one solution, but several.</span></span> <span data-ttu-id="37c14-111">Bir çözüm mümkün olduğunca iş mikrohizmetleri izole içerir.</span><span class="sxs-lookup"><span data-stu-id="37c14-111">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="37c14-112">Daha sonra dahili mikro hizmetler arasında eşzamanlı iletişim kullanır ve nesneler arasındaki işlem içi iletişimde tipik olan ince taneli iletişimi kaba taneli iletişimle değiştirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-112">You then use asynchronous communication between the internal microservices and replace fine-grained communication that's typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="37c14-113">Bunu, çağrıları gruplandırma kılarak ve birden çok dahili aramanın sonuçlarını istemciye toplayan verileri döndürerek yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-113">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="37c14-114">Mikro hizmetler tabanlı bir uygulama, genellikle birden çok sunucu veya ana bilgisayarda bile birden çok işlem veya hizmet üzerinde çalışan dağıtılmış bir sistemdir.</span><span class="sxs-lookup"><span data-stu-id="37c14-114">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="37c14-115">Her hizmet örneği genellikle bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="37c14-115">Each service instance is typically a process.</span></span> <span data-ttu-id="37c14-116">Bu nedenle, hizmetlerin her hizmetin yapısına bağlı olarak HTTP, AMQP veya TCP gibi ikili bir iletişim protokolü gibi bir işlem içi iletişim protokolü kullanarak etkileşimde kullanılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="37c14-116">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="37c14-117">Microservice topluluk felsefesi teşvik "[akıllı uç noktaları ve aptal borular](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" Bu slogan mikro hizmetler arasında mümkün olduğunca ayrılmış bir tasarım teşvik, ve tek bir microservice içinde mümkün olduğunca uyumlu.</span><span class="sxs-lookup"><span data-stu-id="37c14-117">The microservice community promotes the philosophy of "[smart endpoints and dumb pipes](https://simplicable.com/new/smart-endpoints-and-dumb-pipes)" This slogan encourages a design that's as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="37c14-118">Daha önce açıklandığı gibi, her microservice kendi veri ve kendi etki alanı mantığı na sahip.</span><span class="sxs-lookup"><span data-stu-id="37c14-118">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="37c14-119">Ancak uçtan uca bir uygulama oluşturan mikro hizmetler genellikle merkezi iş-süreç-orkestratörleri yerine\* WS gibi karmaşık protokoller ve esnek olay odaklı iletişimler yerine REST iletişimi kullanılarak koreografisini yapılır.</span><span class="sxs-lookup"><span data-stu-id="37c14-119">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="37c14-120">Sık kullanılan iki protokol, kaynak API'leri ile HTTP isteği/yanıtı (en çok sorgulanırken) ve güncelleştirmeleri birden çok mikro hizmet üzerinden iletirken hafif asynchronous iletileridir.</span><span class="sxs-lookup"><span data-stu-id="37c14-120">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="37c14-121">Bunlar aşağıdaki bölümlerde daha ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="37c14-121">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="37c14-122">İletişim türleri</span><span class="sxs-lookup"><span data-stu-id="37c14-122">Communication types</span></span>

<span data-ttu-id="37c14-123">İstemci ve hizmetler, her biri farklı bir senaryo ve hedefi hedefleyen birçok farklı iletişim türü aracılığıyla iletişim kurabilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-123">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="37c14-124">Başlangıçta, bu tür iletişimler iki eksen halinde sınıflandırılabilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-124">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="37c14-125">İlk eksen, protokolün senkron veya eşzamanlı olup olmadığını tanımlar:</span><span class="sxs-lookup"><span data-stu-id="37c14-125">The first axis defines if the protocol is synchronous or asynchronous:</span></span>

- <span data-ttu-id="37c14-126">Senkron protokol.</span><span class="sxs-lookup"><span data-stu-id="37c14-126">Synchronous protocol.</span></span> <span data-ttu-id="37c14-127">HTTP eşzamanlı bir protokoldür.</span><span class="sxs-lookup"><span data-stu-id="37c14-127">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="37c14-128">İstemci bir istek gönderir ve hizmetten yanıt bekler.</span><span class="sxs-lookup"><span data-stu-id="37c14-128">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="37c14-129">Bu, senkron (iş parçacığı engellenmiş) veya eşzamanlı (iş parçacığı engellenmez ve yanıt sonunda bir geri arama ulaşacaktır) olabilir istemci kodu yürütme bağımsızdır.</span><span class="sxs-lookup"><span data-stu-id="37c14-129">That's independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread isn't blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="37c14-130">Burada önemli olan nokta, protokolün (HTTP/HTTPS) senkron olması ve istemci kodunun yalnızca HTTP sunucu yanıtını aldığında görevine devam edebildiğidir.</span><span class="sxs-lookup"><span data-stu-id="37c14-130">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

- <span data-ttu-id="37c14-131">Asynchronous protokolü.</span><span class="sxs-lookup"><span data-stu-id="37c14-131">Asynchronous protocol.</span></span> <span data-ttu-id="37c14-132">AMQP (birçok işletim sistemi ve bulut ortamları tarafından desteklenen bir protokol) gibi diğer protokoller eşzamanlı iletiler kullanır.</span><span class="sxs-lookup"><span data-stu-id="37c14-132">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="37c14-133">İstemci kodu veya ileti gönderen genellikle bir yanıt beklemez.</span><span class="sxs-lookup"><span data-stu-id="37c14-133">The client code or message sender usually doesn't wait for a response.</span></span> <span data-ttu-id="37c14-134">Sadece bir RabbitMQ kuyruk veya başka bir ileti aracısı bir mesaj gönderir gibi ileti gönderir.</span><span class="sxs-lookup"><span data-stu-id="37c14-134">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="37c14-135">İkinci eksen, iletişimin tek bir alıcısı veya birden çok alıcısı olup olmadığını tanımlar:</span><span class="sxs-lookup"><span data-stu-id="37c14-135">The second axis defines if the communication has a single receiver or multiple receivers:</span></span>

- <span data-ttu-id="37c14-136">Tek alıcı.</span><span class="sxs-lookup"><span data-stu-id="37c14-136">Single receiver.</span></span> <span data-ttu-id="37c14-137">Her istek tam olarak bir alıcı veya hizmet tarafından işlenmelidir.</span><span class="sxs-lookup"><span data-stu-id="37c14-137">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="37c14-138">Bu iletişimin bir örneği [Komut desenidir.](https://en.wikipedia.org/wiki/Command_pattern)</span><span class="sxs-lookup"><span data-stu-id="37c14-138">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

- <span data-ttu-id="37c14-139">Birden fazla alıcı.</span><span class="sxs-lookup"><span data-stu-id="37c14-139">Multiple receivers.</span></span> <span data-ttu-id="37c14-140">Her istek sıfırile birden çok alıcıya işlenebilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-140">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="37c14-141">Bu tür bir iletişim eşzamanlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="37c14-141">This type of communication must be asynchronous.</span></span> <span data-ttu-id="37c14-142">Olay [odaklı mimari](https://microservices.io/patterns/data/event-driven-architecture.html)gibi desenlerde kullanılan [yayımlama/abone etme](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mekanizması buna bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="37c14-142">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](https://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="37c14-143">Bu, olaylar aracılığıyla birden çok mikro hizmet arasında veri güncelleştirmeleri yayılırken bir olay-veri birimi arabirimi veya ileti aracısı dayanmaktadır; genellikle [konular ve abonelikler](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)kullanılarak Bir servis veri kurumu veya [Azure Servis Veri Servisi](https://azure.microsoft.com/services/service-bus/) gibi benzer bir yapı aracılığıyla uygulanır.</span><span class="sxs-lookup"><span data-stu-id="37c14-143">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it's usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="37c14-144">Mikro hizmet tabanlı bir uygulama genellikle bu iletişim stillerinin bir birleşimini kullanır.</span><span class="sxs-lookup"><span data-stu-id="37c14-144">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="37c14-145">En yaygın tür, normal bir Web API HTTP hizmetini çağırırken HTTP/HTTPS gibi eşzamanlı bir protokoliçeren tek alıcılı iletişimdir.</span><span class="sxs-lookup"><span data-stu-id="37c14-145">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="37c14-146">Mikro hizmetler, genellikle mikro hizmetler arasındaki eşzamanlı iletişim için mesajlaşma protokollerini de kullanır.</span><span class="sxs-lookup"><span data-stu-id="37c14-146">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="37c14-147">Bu eksenler, olası iletişim mekanizmaları üzerinde netlik var, ancak mikro hizmetler inşa ederken önemli endişeleri değil bilmek iyidir.</span><span class="sxs-lookup"><span data-stu-id="37c14-147">These axes are good to know so you have clarity on the possible communication mechanisms, but they're not the important concerns when building microservices.</span></span> <span data-ttu-id="37c14-148">Ne istemci iş parçacığı yürütmenin eşzamanlı doğası ne de seçilen protokolün eşzamanlı yapısı mikro hizmetleri tümleştirirken önemli noktalar dır.</span><span class="sxs-lookup"><span data-stu-id="37c14-148">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="37c14-149">Önemli *olan,* aşağıdaki bölümde açıklandığı gibi, mikro hizmetlerin bağımsızlığını korurken mikro hizmetlerinizi senkronize bir şekilde entegre edebilmektir.</span><span class="sxs-lookup"><span data-stu-id="37c14-149">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="37c14-150">Asynchronous microservice entegrasyonu microservice'in özerkliğini zorlar</span><span class="sxs-lookup"><span data-stu-id="37c14-150">Asynchronous microservice integration enforces microservice's autonomy</span></span>

<span data-ttu-id="37c14-151">Belirtildiği gibi, mikro hizmet tabanlı bir uygulama kurarken önemli olan nokta, mikro hizmetlerinizi entegre etme şeklinizdir.</span><span class="sxs-lookup"><span data-stu-id="37c14-151">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="37c14-152">İdeal olarak, dahili mikro hizmetler arasındaki iletişimi en aza indirmeye çalışmalısınız.</span><span class="sxs-lookup"><span data-stu-id="37c14-152">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="37c14-153">Mikro hizmetler arasındaki iletişim ne kadar azsa o kadar iyi.</span><span class="sxs-lookup"><span data-stu-id="37c14-153">The fewer communications between microservices, the better.</span></span> <span data-ttu-id="37c14-154">Ama birçok durumda, bir şekilde mikro hizmetleri entegre etmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="37c14-154">But in many cases, you'll have to somehow integrate the microservices.</span></span> <span data-ttu-id="37c14-155">Bunu yapmanız gerektiğinde, buradaki kritik kural, mikro hizmetler arasındaki iletişimin eşzamanlı olması gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="37c14-155">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="37c14-156">Bu, belirli bir protokol kullanmanız gerektiği anlamına gelmez (örneğin, senkron http'ye karşı eşzamanlı mesajlaşma).</span><span class="sxs-lookup"><span data-stu-id="37c14-156">That doesn't mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="37c14-157">Bu sadece mikro hizmetler arasındaki iletişimin yalnızca verileri eşzamanlı olarak yayılarak yapılması gerektiği, ancak ilk hizmetin HTTP istek/yanıt işleminin bir parçası olarak diğer dahili mikro hizmetlere bağımlı olmamak anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="37c14-157">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service's HTTP request/response operation.</span></span>

<span data-ttu-id="37c14-158">Mümkünse, sorgular için bile birden çok mikro hizmet arasında eşzamanlı iletişim (istek/yanıt) asla bağlı değildir.</span><span class="sxs-lookup"><span data-stu-id="37c14-158">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="37c14-159">Her microservice'in amacı, uçtan uca uygulamanın bir parçası olan diğer hizmetler aşağı veya sağlıksız olsa bile, özerk ve istemci tüketiciiçin kullanılabilir olmaktır.</span><span class="sxs-lookup"><span data-stu-id="37c14-159">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="37c14-160">Bir istemci uygulamasına yanıt verebilmek için bir mikro hizmetten diğer mikro hizmetlere (örneğin, veri sorgusu için HTTP isteği gerçekleştirmek gibi) bir arama yapmanız gerektiğini düşünüyorsanız, bazı mikro hizmetler başarısız olduğunda esnek olmayacak bir mimariye sahipsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-160">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) to be able to provide a response to a client application, you have an architecture that won't be resilient when some microservices fail.</span></span>

<span data-ttu-id="37c14-161">Ayrıca, Şekil 4-15'in ilk bölümünde gösterildiği gibi, HTTP istek zincirleriyle uzun istek/yanıt döngüleri oluştururken olduğu gibi mikro hizmetler arasındaki HTTP bağımlılıklarına sahip olmak, yalnızca mikro hizmetlerinizi özerk hale getirmiyor, aynı zamanda bu zincirdeki hizmetlerden biri iyi performans göstermez etkide de etkiliyor.</span><span class="sxs-lookup"><span data-stu-id="37c14-161">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain isn't performing well.</span></span>

<span data-ttu-id="37c14-162">Sorgu istekleri gibi mikro hizmetler arasında eşzamanlı bağımlılıklar ne kadar eklerseniz, istemci uygulamaları için genel yanıt süresi o kadar kötü olur.</span><span class="sxs-lookup"><span data-stu-id="37c14-162">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![Mikro hizmetler arasında üç tür iletişimgösteren diyagram.](./media/communication-in-microservice-architecture/sync-vs-async-patterns-across-microservices.png)

<span data-ttu-id="37c14-164">**Şekil 4-15**.</span><span class="sxs-lookup"><span data-stu-id="37c14-164">**Figure 4-15**.</span></span> <span data-ttu-id="37c14-165">Mikro hizmetler arasındaki iletişimde anti-desen ve desenler</span><span class="sxs-lookup"><span data-stu-id="37c14-165">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="37c14-166">Yukarıdaki diyagramda gösterildiği gibi, senkron iletişimde istemci isteğine hizmet verirken mikro hizmetler arasında bir "istek zinciri" oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="37c14-166">As shown in the above diagram, in synchronous communication a "chain" of requests is created between microservices while serving the client request.</span></span> <span data-ttu-id="37c14-167">Bu bir anti-desen.</span><span class="sxs-lookup"><span data-stu-id="37c14-167">This is an anti-pattern.</span></span> <span data-ttu-id="37c14-168">Asynchronous iletişim mikroservices diğer mikro hizmetler ile iletişim kurmak için asynchronous mesajları veya http yoklama kullanın, ancak istemci isteği hemen servis edilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-168">In asynchronous communication microservices use asynchronous messages or http polling to communicate with other microservices, but the client request is served right away.</span></span>

<span data-ttu-id="37c14-169">Microservice'inizin başka bir microservice'te ek bir eylem yükseltmesi gerekiyorsa, mümkünse, bu eylemi eşzamanlı olarak ve orijinal microservice isteği ve yanıtlama işleminin bir parçası olarak gerçekleştirin.</span><span class="sxs-lookup"><span data-stu-id="37c14-169">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="37c14-170">Bunun yerine, eşzamanlı olarak yapın (eşzamanlı mesajlaşma veya tümleştirme olayları, kuyruklar, vb. kullanarak).</span><span class="sxs-lookup"><span data-stu-id="37c14-170">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="37c14-171">Ancak, mümkün olduğunca, özgün senkron istek ve yanıt işleminin bir parçası olarak eylemi eşzamanlı olarak çağırmayın.</span><span class="sxs-lookup"><span data-stu-id="37c14-171">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="37c14-172">Ve son olarak (ve bu sorunların çoğu mikro hizmetler inşa ederken ortaya çıkar), ilk microservice aslında diğer mikro hizmetler tarafından sahip olunan veri ihtiyacı varsa, bu veriler için eşzamanlı istekte bulunmaya güvenmeyin.</span><span class="sxs-lookup"><span data-stu-id="37c14-172">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that's originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="37c14-173">Bunun yerine, nihai tutarlılık kullanarak (genellikle gelecek bölümlerde açıklandığı gibi tümleştirme olaylarını kullanarak) bu verileri (yalnızca ihtiyacınız olan öznitelikler) ilk hizmetin veritabanına çoğaltın veya çoğaltın.</span><span class="sxs-lookup"><span data-stu-id="37c14-173">Instead, replicate or propagate that data (only the attributes you need) into the initial service's database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="37c14-174">Daha önce her mikro hizmet bölümü [için etki alanı modeli sınırlarını tanımlamada](identify-microservice-domain-model-boundaries.md) belirtildiği gibi, bazı verileri çeşitli mikro hizmetler arasında çoğaltmak yanlış bir tasarım değildir— tam tersine, verileri belirli bir etki alanı nın veya Bağlı Bağlamın belirli bir dile veya koşullarına çevirebileceğinizi yaparken.</span><span class="sxs-lookup"><span data-stu-id="37c14-174">As noted earlier in the [Identifying domain-model boundaries for each microservice](identify-microservice-domain-model-boundaries.md) section, duplicating some data across several microservices isn't an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="37c14-175">Örneğin, [eShopOnContainers uygulamasında,](https://github.com/dotnet-architecture/eShopOnContainers) kullanıcıverilerinin çoğundan sorumlu `identity-api` olan ve adlı `User`bir kuruluşa sahip bir microservice'invar.</span><span class="sxs-lookup"><span data-stu-id="37c14-175">For instance, in the [eShopOnContainers application](https://github.com/dotnet-architecture/eShopOnContainers) you have a microservice named `identity-api` that's in charge of most of the user's data with an entity named `User`.</span></span> <span data-ttu-id="37c14-176">Ancak, `Ordering` kullanıcı hakkındaki verileri mikro hizmet içinde depolamanız gerektiğinde, bu verileri `Buyer`başka bir varlık olarak depolarsınız.</span><span class="sxs-lookup"><span data-stu-id="37c14-176">However, when you need to store data about the user within the `Ordering` microservice, you store it as a different entity named `Buyer`.</span></span> <span data-ttu-id="37c14-177">Varlık `Buyer` özgün `User` varlıkla aynı kimliği paylaşır, ancak tüm kullanıcı profilinideğil, etki alanının `Ordering` gerektirdiği yalnızca birkaç özniteliği olabilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-177">The `Buyer` entity shares the same identity with the original `User` entity, but it might have only the few attributes needed by the `Ordering` domain, and not the whole user profile.</span></span>

<span data-ttu-id="37c14-178">Nihai tutarlılığa sahip olmak için verileri mikro hizmetler arasında eşit bir şekilde iletmek ve yaymak için herhangi bir protokol kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-178">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="37c14-179">Belirtildiği gibi, bir olay veri meseni veya ileti aracısı kullanarak entegrasyon olayları kullanabilirsiniz veya hatta yerine diğer hizmetleri yoklama tarafından HTTP kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-179">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="37c14-180">Fark etmez.</span><span class="sxs-lookup"><span data-stu-id="37c14-180">It doesn't matter.</span></span> <span data-ttu-id="37c14-181">Önemli kural, mikro hizmetleriniz arasında eşzamanlı bağımlılıklar oluşturmamaktır.</span><span class="sxs-lookup"><span data-stu-id="37c14-181">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="37c14-182">Aşağıdaki bölümlerde, mikrohizmet tabanlı bir uygulamada kullanmayı düşünebileceğiniz birden çok iletişim stili açıklanabilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-182">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="37c14-183">İletişim stilleri</span><span class="sxs-lookup"><span data-stu-id="37c14-183">Communication styles</span></span>

<span data-ttu-id="37c14-184">Kullanmak istediğiniz iletişim türüne bağlı olarak iletişim için kullanabileceğiniz birçok protokol ve seçenek vardır.</span><span class="sxs-lookup"><span data-stu-id="37c14-184">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="37c14-185">Eşzamanlı istek/yanıt tabanlı iletişim mekanizması kullanıyorsanız, özellikle hizmetlerinizi Docker ana bilgisayarı veya mikro hizmet kümesi dışında yayınlıyorsanız, HTTP ve REST yaklaşımları gibi protokoller en yaygın olanıdır.</span><span class="sxs-lookup"><span data-stu-id="37c14-185">If you're using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you're publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="37c14-186">Hizmetler arasında dahili olarak iletişim kuruyorsanız (Docker ana bilgisayarveya mikro hizmetler kümenizde), ikili biçimli iletişim mekanizmalarını da (TCP ve ikili biçim kullanarak WCF gibi) kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-186">If you're communicating between services internally (within your Docker host or microservices cluster), you might also want to use binary format communication mechanisms (like WCF using TCP and binary format).</span></span> <span data-ttu-id="37c14-187">Alternatif olarak, AMQP gibi asynchronous, ileti tabanlı iletişim mekanizmaları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-187">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="37c14-188">JSON veya XML gibi birden çok ileti biçimi, hatta ikili biçimler de vardır, bunlar daha verimli olabilir.</span><span class="sxs-lookup"><span data-stu-id="37c14-188">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="37c14-189">Seçtiğiniz ikili biçim bir standart değilse, bu biçimi kullanarak hizmetlerinizi herkese açık olarak yayımlamak büyük olasılıkla iyi bir fikir değildir.</span><span class="sxs-lookup"><span data-stu-id="37c14-189">If your chosen binary format isn't a standard, it's probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="37c14-190">Mikro hizmetleriniz arasındaki dahili iletişim için standart olmayan bir biçim kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-190">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="37c14-191">Bunu, Docker ana bilgisayarınızdaki veya mikro hizmet kümenizdeki mikro hizmetler (örneğin, Docker orchestrators) veya mikro hizmetlerle konuşan özel istemci uygulamaları arasında iletişim kurarken yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-191">You might do this when communicating between microservices within your Docker host or microservice cluster (for example, Docker orchestrators), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="37c14-192">HTTP ve REST ile istek/yanıt iletişimi</span><span class="sxs-lookup"><span data-stu-id="37c14-192">Request/response communication with HTTP and REST</span></span>

<span data-ttu-id="37c14-193">İstemci istek/yanıt iletişimini kullandığında, bir hizmete istek gönderir, ardından hizmet isteği işler ve bir yanıtı geri gönderir.</span><span class="sxs-lookup"><span data-stu-id="37c14-193">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="37c14-194">İstek/yanıt iletişimi, istemci uygulamalarından gerçek zamanlı bir kullanıcı arabirimi (canlı kullanıcı arabirimi) için veri sorgulamak için özellikle uygundur.</span><span class="sxs-lookup"><span data-stu-id="37c14-194">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="37c14-195">Bu nedenle, bir microservice mimarisinde, şekil 4-16'da gösterildiği gibi, büyük olasılıkla çoğu sorgu için bu iletişim mekanizmasını kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="37c14-195">Therefore, in a microservice architecture you'll probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![Canlı sorgular ve güncelleştirmeler için istek/yanıt iletişimini gösteren diyagram.](./media/communication-in-microservice-architecture/request-response-comms-live-queries-updates.png)

<span data-ttu-id="37c14-197">**Şekil 4-16**.</span><span class="sxs-lookup"><span data-stu-id="37c14-197">**Figure 4-16**.</span></span> <span data-ttu-id="37c14-198">HTTP istek/yanıt iletişimini kullanma (senkron veya eşzamanlı)</span><span class="sxs-lookup"><span data-stu-id="37c14-198">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="37c14-199">İstemci istek/yanıt iletişimini kullandığında, yanıtın genellikle bir saniyeden kısa veya en fazla birkaç saniye içinde kısa bir süre içinde geleceğini varsayar.</span><span class="sxs-lookup"><span data-stu-id="37c14-199">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="37c14-200">Gecikmiş yanıtlar için, bir sonraki bölümde açıkladığımız farklı bir yaklaşım olan [mesajlaşma modellerine](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) ve [mesajlaşma teknolojilerine](https://en.wikipedia.org/wiki/Message-oriented_middleware)dayalı eşzamanlı iletişim uygulamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="37c14-200">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="37c14-201">İstek/yanıt iletişimi için popüler bir mimari stil [REST](https://en.wikipedia.org/wiki/Representational_state_transfer)olduğunu.</span><span class="sxs-lookup"><span data-stu-id="37c14-201">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="37c14-202">Bu yaklaşım, [GET,](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) POST ve PUT gibi HTTP fiillerini kucaklayan HTTP protokolüne dayanır ve sıkıca birleştiğinde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="37c14-202">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="37c14-203">REST, hizmet oluştururken en sık kullanılan mimari iletişim yaklaşımıdır.</span><span class="sxs-lookup"><span data-stu-id="37c14-203">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="37c14-204">Core Web API hizmetlerini ASP.NET geliştirdiğinizde REST hizmetlerini uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-204">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="37c14-205">ARAYÜZ tanım diliniz olarak HTTP REST hizmetlerini kullanırken ek bir değer vardır.</span><span class="sxs-lookup"><span data-stu-id="37c14-205">There's additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="37c14-206">Örneğin, hizmet API'nizi açıklamak için [Swagger meta verilerini](https://swagger.io/) kullanırsanız, hizmetlerinizi doğrudan keşfedebilen ve tüketebilen istemci saplamaları oluşturan araçları kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="37c14-206">For instance, if you use [Swagger metadata](https://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="37c14-207">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="37c14-207">Additional resources</span></span>

- <span data-ttu-id="37c14-208">**Martin Fowler' ı. Richardson Olgunluk Modeli** REST modelinin açıklaması.</span><span class="sxs-lookup"><span data-stu-id="37c14-208">**Martin Fowler. Richardson Maturity Model** A description of the REST model.</span></span> \
  <https://martinfowler.com/articles/richardsonMaturityModel.html>

- <span data-ttu-id="37c14-209">**Swagger** Resmi site.</span><span class="sxs-lookup"><span data-stu-id="37c14-209">**Swagger** The official site.</span></span> \
  <https://swagger.io/>

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="37c14-210">HTTP'ye dayalı push ve gerçek zamanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="37c14-210">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="37c14-211">Başka bir olasılık (genellikle REST daha farklı amaçlar için) [ASP.NET SignalR](https://www.asp.net/signalr) ve [WebSockets](https://en.wikipedia.org/wiki/WebSocket)gibi protokoller gibi üst düzey çerçeveler ile gerçek zamanlı ve bir-çok iletişim.</span><span class="sxs-lookup"><span data-stu-id="37c14-211">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="37c14-212">Şekil 4-17'nin de gösterdiği gibi, gerçek zamanlı HTTP iletişimi, sunucunun istemcinin yeni veri istemesini beklemek yerine, veriler kullanılabilir hale geldikçe içeriği bağlı istemcilere itmesini sağlayan sunucu kodunun olması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="37c14-212">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![SignalR'a dayalı itme ve gerçek zamanlı iletişimleri gösteren diyagram.](./media/communication-in-microservice-architecture/one-to-many-communication.png)

<span data-ttu-id="37c14-214">**Şekil 4-17**.</span><span class="sxs-lookup"><span data-stu-id="37c14-214">**Figure 4-17**.</span></span> <span data-ttu-id="37c14-215">Bire bir gerçek zamanlı asynchronous ileti iletişimi</span><span class="sxs-lookup"><span data-stu-id="37c14-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="37c14-216">SignalR, içeriği arka uç sunucudan istemcilere itmek için gerçek zamanlı iletişim elde etmenin iyi bir yoludur.</span><span class="sxs-lookup"><span data-stu-id="37c14-216">SignalR is a good way to achieve real-time communication for pushing content to the clients from a back-end server.</span></span> <span data-ttu-id="37c14-217">İletişim gerçek zamanlı olduğundan, istemci uygulamaları değişiklikleri neredeyse anında gösterir.</span><span class="sxs-lookup"><span data-stu-id="37c14-217">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="37c14-218">Bu genellikle websockets gibi bir protokol tarafından, birçok WebSockets bağlantıları (istemci başına bir) kullanılarak işlenir.</span><span class="sxs-lookup"><span data-stu-id="37c14-218">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="37c14-219">Tipik bir örnek, bir hizmetin bir spor oyununun skorundaki bir değişikliği aynı anda birçok istemci web uygulamasına iletmesidir.</span><span class="sxs-lookup"><span data-stu-id="37c14-219">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="37c14-220">[Önceki](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
>[Sonraki](asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="37c14-220">[Previous](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)
[Next](asynchronous-message-based-communication.md)</span></span>
