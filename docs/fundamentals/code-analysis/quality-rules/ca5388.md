---
title: 'CA5388: zayıf anahtar türetme işlevini kullanırken yeterli yineleme sayısı sağlayın (kod analizi)'
description: Kod Analizi kuralı CA5388, nedenler, ihlallerin nasıl düzeltileceğini ve ne zaman bastıralınacağını içeren bilgiler sağlar.
ms.date: 05/08/2020
ms.topic: reference
author: LLLXXXCCC
ms.author: linche
f1_keywords:
- CA5388
ms.openlocfilehash: 961c39208ba130db12e7aafc14b868ab4b84a30f
ms.sourcegitcommit: e301979e3049ce412d19b094c60ed95b316a8f8c
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 12/16/2020
ms.locfileid: "97594429"
---
# <a name="ca5388-ensure-sufficient-iteration-count-when-using-weak-key-derivation-function"></a>CA5388: Zayıf anahtar türetme işlevini kullanırken yeterli sayıda yineleme sağla

| | Değer |
|-|-|
| **Kural Kimliği** |CA5388|
| **Kategori** |Microsoft.Security|
| **Düzeltilme veya kırılmamış** |Kırılmamış|

## <a name="cause"></a>Nedeni

Yineleme sayısı, tarafından şifreleme anahtarı türetmede 100.000 'den daha küçük olabilir <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A?displayProperty=fullName> .

Varsayılan olarak, bu kural codebase 'in tamamını analiz eder, ancak bu [yapılandırılabilir](#configure-code-to-analyze).

## <a name="rule-description"></a>Kural açıklaması

Bu kural, tarafından <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 100.000 ' den küçük olabilecek bir yineleme sayısıyla bir şifreleme anahtarının oluşturulup oluşturulmadığını denetler. Daha yüksek bir yineleme sayısı, oluşturulan şifreleme anahtarını tahmin etmeye çalışan sözlük saldırılarına karşı hafifletmek için yardımcı olabilir.

Bu kural [CA5387](ca5387.md)ile benzerdir, ancak analiz yineleme sayısının 100.000 değerinden küçük olup olmadığını belirleyemiyor.

## <a name="how-to-fix-violations"></a>İhlalleri çözme

Açık olarak çağrılmadan önce döngü sayısını 100.000 ile eşit veya daha büyük <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> olarak ayarlayın.

## <a name="when-to-suppress-warnings"></a>Uyarıların ne zaman bastırılamıyor

Bu kuraldan gelen uyarıları gizlemek güvenlidir:

- Mevcut verilerle uyumluluk için daha küçük bir yineleme sayısı kullanmanız gerekir.
- Yineleme sayısının 100.000 üzerinde ayarlandığından emin olursunuz.

## <a name="configure-code-to-analyze"></a>Analiz etmek için kodu Yapılandır

Kod tabanınızın hangi bölümlerinin bu kuralı çalıştıracağınızı yapılandırmak için aşağıdaki seçenekleri kullanın.

- [Belirli sembolleri Dışla](#exclude-specific-symbols)
- [Belirli türleri ve bunların türetilmiş türlerini Dışla](#exclude-specific-types-and-their-derived-types)

Bu seçenekleri yalnızca bu kural için, tüm kurallar için veya bu kategorideki tüm kurallar (güvenlik) için yapılandırabilirsiniz. Daha fazla bilgi için bkz. [kod kalitesi kural yapılandırma seçenekleri](../code-quality-rule-options.md).

[!INCLUDE[excluded-symbol-names](~/includes/code-analysis/excluded-symbol-names.md)]

[!INCLUDE[excluded-type-names-with-derived-types](~/includes/code-analysis/excluded-type-names-with-derived-types.md)]

## <a name="pseudo-code-examples"></a>Sözde kod örnekleri

### <a name="violation"></a>Edildiği

```csharp
using System;
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var iterations = 100;
        Random r = new Random();

        if (r.Next(6) == 4)
        {
            iterations = 100000;
        }

        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt, iterations);
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```

### <a name="solution"></a>Çözüm

```csharp
using System.Security.Cryptography;

class ExampleClass
{
    public void ExampleMethod(string password, byte[] salt, int cb)
    {
        var rfc2898DeriveBytes = new Rfc2898DeriveBytes(password, salt);
        rfc2898DeriveBytes.IterationCount = 100000;
        rfc2898DeriveBytes.GetBytes(cb);
    }
}
```
