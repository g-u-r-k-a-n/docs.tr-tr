---
title: Fonksiyonel Programlama ve Zorunlu Programlama (C#)
ms.date: 07/20/2015
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
ms.openlocfilehash: a163a62912ed2a44d6ea8cad5bc536f03343f15c
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "69594319"
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="02a26-102">Fonksiyonel Programlama ve Zorunlu Programlama (C#)</span><span class="sxs-lookup"><span data-stu-id="02a26-102">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="02a26-103">Bu konu, işlevsel programlamayı daha geleneksel zorunlu (yordamsal) programlama ile karşılaştırır ve karşılaştırır.</span><span class="sxs-lookup"><span data-stu-id="02a26-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="02a26-104">Fonksiyonel Programlama ve Zorunlu Programlama</span><span class="sxs-lookup"><span data-stu-id="02a26-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="02a26-105">*İşlevsel programlama* paradigması, problem çözmeye saf işlevsel bir yaklaşımı desteklemek için açıkça oluşturulmuştur.</span><span class="sxs-lookup"><span data-stu-id="02a26-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="02a26-106">Fonksiyonel programlama *bildirimsel programlama*biçimidir.</span><span class="sxs-lookup"><span data-stu-id="02a26-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="02a26-107">Buna karşılık, C#, Visual Basic, C++ve Java gibi nesne yönelimli programlama (OOP) dilleri de dahil olmak üzere çoğu ana dil, öncelikle *zorunlu* (yordamsal) programlamayı destekleyecek şekilde tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="02a26-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="02a26-108">Zorunlu bir yaklaşımla, geliştirici, bilgisayarın hedefi gerçekleştirmek için atması gereken adımları ayrıntılı olarak açıklayan kod yazar.</span><span class="sxs-lookup"><span data-stu-id="02a26-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="02a26-109">Bu bazen *algoritmik* programlama olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="02a26-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="02a26-110">Buna karşılık, işlevsel bir yaklaşım yürütülecek işlevler kümesi olarak sorun oluşturma içerir.</span><span class="sxs-lookup"><span data-stu-id="02a26-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="02a26-111">Her işlevin girişini ve her işlevin ne döndürür olduğunu dikkatle tanımlarsınız.</span><span class="sxs-lookup"><span data-stu-id="02a26-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="02a26-112">Aşağıdaki tabloda, bu iki yaklaşım arasındaki genel farklardan bazıları açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="02a26-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="02a26-113">Özellik</span><span class="sxs-lookup"><span data-stu-id="02a26-113">Characteristic</span></span>|<span data-ttu-id="02a26-114">Zorunlu yaklaşım</span><span class="sxs-lookup"><span data-stu-id="02a26-114">Imperative approach</span></span>|<span data-ttu-id="02a26-115">Fonksiyonel yaklaşım</span><span class="sxs-lookup"><span data-stu-id="02a26-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="02a26-116">Programcı odak</span><span class="sxs-lookup"><span data-stu-id="02a26-116">Programmer focus</span></span>|<span data-ttu-id="02a26-117">Görevlerin (algoritmaların) nasıl gerçekleştirildirilen ve durum daki değişikliklerin nasıl izlenir.</span><span class="sxs-lookup"><span data-stu-id="02a26-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="02a26-118">Hangi bilgilerin istendiği ve hangi dönüşümlerin gerekli olduğu.</span><span class="sxs-lookup"><span data-stu-id="02a26-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="02a26-119">Durum değişiklikleri</span><span class="sxs-lookup"><span data-stu-id="02a26-119">State changes</span></span>|<span data-ttu-id="02a26-120">Önemli.</span><span class="sxs-lookup"><span data-stu-id="02a26-120">Important.</span></span>|<span data-ttu-id="02a26-121">Var olmayan bir şey.</span><span class="sxs-lookup"><span data-stu-id="02a26-121">Non-existent.</span></span>|  
|<span data-ttu-id="02a26-122">Yürütme emri</span><span class="sxs-lookup"><span data-stu-id="02a26-122">Order of execution</span></span>|<span data-ttu-id="02a26-123">Önemli.</span><span class="sxs-lookup"><span data-stu-id="02a26-123">Important.</span></span>|<span data-ttu-id="02a26-124">Düşük öneme sahip.</span><span class="sxs-lookup"><span data-stu-id="02a26-124">Low importance.</span></span>|  
|<span data-ttu-id="02a26-125">Birincil akış kontrolü</span><span class="sxs-lookup"><span data-stu-id="02a26-125">Primary flow control</span></span>|<span data-ttu-id="02a26-126">Döngüler, koşullular ve işlev (yöntem) çağrıları.</span><span class="sxs-lookup"><span data-stu-id="02a26-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="02a26-127">Özyineleme de dahil olmak üzere işlev çağrıları.</span><span class="sxs-lookup"><span data-stu-id="02a26-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="02a26-128">Birincil manipülasyon ünitesi</span><span class="sxs-lookup"><span data-stu-id="02a26-128">Primary manipulation unit</span></span>|<span data-ttu-id="02a26-129">Yapı veya sınıf örnekleri.</span><span class="sxs-lookup"><span data-stu-id="02a26-129">Instances of structures or classes.</span></span>|<span data-ttu-id="02a26-130">Birinci sınıf nesneler ve veri koleksiyonları olarak işlev görür.</span><span class="sxs-lookup"><span data-stu-id="02a26-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="02a26-131">Çoğu dil belirli bir programlama paradigmasını destekleyecek şekilde tasarlanmış olsa da, birçok genel dil birden çok paradigmayı destekleyecek kadar esnektir.</span><span class="sxs-lookup"><span data-stu-id="02a26-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="02a26-132">Örneğin, işlev işaretçileri içeren çoğu dil işlevsel programlamayı güvenilir bir şekilde desteklemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="02a26-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="02a26-133">Ayrıca, C# lambda ifadeleri ve tür çıkarımı da dahil olmak üzere işlevsel programlamayı desteklemek için açık dil uzantıları içerir.</span><span class="sxs-lookup"><span data-stu-id="02a26-133">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="02a26-134">LINQ teknolojisi bildirimsel, işlevsel programlama biçimidir.</span><span class="sxs-lookup"><span data-stu-id="02a26-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="02a26-135">XSLT Kullanarak Fonksiyonel Programlama</span><span class="sxs-lookup"><span data-stu-id="02a26-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="02a26-136">Birçok XSLT geliştiricisi saf işlevsel yaklaşıma aşinadır.</span><span class="sxs-lookup"><span data-stu-id="02a26-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="02a26-137">Bir XSLT stil sayfası geliştirmenin en etkili yolu, her şablonu yalıtılmış, birleştirilebilir dönüşüm olarak ele almaktır.</span><span class="sxs-lookup"><span data-stu-id="02a26-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="02a26-138">İdam emri tamamen vurgulanır.</span><span class="sxs-lookup"><span data-stu-id="02a26-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="02a26-139">XSLT yan etkilere izin vermez (prosedür kodunun yürütülmesi için mekanizmaların kaçış işlevsel kirlilik neden yan etkileri tanıtmak dışında).</span><span class="sxs-lookup"><span data-stu-id="02a26-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="02a26-140">Ancak, XSLT etkili bir araç olmasına rağmen, bazı özellikleri en iyi değildir.</span><span class="sxs-lookup"><span data-stu-id="02a26-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="02a26-141">Örneğin, XML programlama yapıları ifade kodu nispeten ayrıntılı hale getirir ve bu nedenle bakımı zor.</span><span class="sxs-lookup"><span data-stu-id="02a26-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="02a26-142">Ayrıca, akış denetimi için özyinelemeye duyulan ağır güven, okunması zor bir kodla sonuçlanabilir.</span><span class="sxs-lookup"><span data-stu-id="02a26-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="02a26-143">XSLT hakkında daha fazla bilgi için [Bkz. XSLT Dönüşümleri.](../../../../standard/data/xml/xslt-transformations.md)</span><span class="sxs-lookup"><span data-stu-id="02a26-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="02a26-144">Ancak XSLT, XML'i bir şekilden diğerine dönüştürmek için saf işlevsel bir yaklaşım kullanmanın değerini kanıtlamıştır.</span><span class="sxs-lookup"><span data-stu-id="02a26-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="02a26-145">LINQ ile XML arasında saf işlevsel programlama birçok yönden XSLT'ye benzer.</span><span class="sxs-lookup"><span data-stu-id="02a26-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="02a26-146">Ancak, LINQ tarafından XML ve C# ile tanıtılan programlama yapıları, XSLT'den daha okunabilir ve korunabilen saf işlevsel dönüşümler yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="02a26-146">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="02a26-147">Saf Fonksiyonların Avantajları</span><span class="sxs-lookup"><span data-stu-id="02a26-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="02a26-148">İşlevsel dönüşümleri saf işlevler olarak uygulamanın temel nedeni, saf işlevlerin birleştirilebilir olmasıdır: yani, bağımsız ve devletsiz.</span><span class="sxs-lookup"><span data-stu-id="02a26-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="02a26-149">Bu özellikler, aşağıdakiler de dahil olmak üzere bir dizi avantaj sağlar:</span><span class="sxs-lookup"><span data-stu-id="02a26-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
- <span data-ttu-id="02a26-150">Artırılabilirlik ve bakım.</span><span class="sxs-lookup"><span data-stu-id="02a26-150">Increased readability and maintainability.</span></span> <span data-ttu-id="02a26-151">Bunun nedeni, her işlevin bağımsız değişkenleri göz önüne alındığında belirli bir görevi gerçekleştirmek üzere tasarlanmış olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="02a26-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="02a26-152">İşlev herhangi bir dış duruma dayanmaz.</span><span class="sxs-lookup"><span data-stu-id="02a26-152">The function does not rely on any external state.</span></span>  
  
- <span data-ttu-id="02a26-153">Daha kolay yinelemeli geliştirme.</span><span class="sxs-lookup"><span data-stu-id="02a26-153">Easier reiterative development.</span></span> <span data-ttu-id="02a26-154">Kodu yeniden düzenlemek daha kolay olduğundan, tasarım değişiklikleri genellikle uygulanması daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="02a26-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="02a26-155">Örneğin, karmaşık bir dönüşüm yazdığınızı ve dönüşümde bazı kodların birkaç kez yinelediğini fark ettiğinizi varsayalım.</span><span class="sxs-lookup"><span data-stu-id="02a26-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="02a26-156">Eğer saf bir yöntem ile refactor, yan etkileri hakkında endişelenmeden istediğiniz saf yöntemi arayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="02a26-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
- <span data-ttu-id="02a26-157">Daha kolay test ve hata ayıklama.</span><span class="sxs-lookup"><span data-stu-id="02a26-157">Easier testing and debugging.</span></span> <span data-ttu-id="02a26-158">Saf işlevler daha kolay yalıtımda sınanabileceğinden, saf işlevi tipik değerler, geçerli kenar örnekleri ve geçersiz kenar durumlarıyla çağıran test kodu yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="02a26-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="02a26-159">OOP Geliştiricileri için Geçiş</span><span class="sxs-lookup"><span data-stu-id="02a26-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="02a26-160">Geleneksel nesne yönelimli programlamada (OOP), çoğu geliştirici zorunlu/yordam tarzında programlamaya alışkındır.</span><span class="sxs-lookup"><span data-stu-id="02a26-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="02a26-161">Saf işlevsel bir tarzda gelişmeye geçmek için, onların düşünce ve gelişim e yaklaşımlarında bir geçiş yapmak zorunda.</span><span class="sxs-lookup"><span data-stu-id="02a26-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="02a26-162">Sorunları çözmek için, OOP geliştiricileri sınıf hiyerarşileri tasarlar, uygun kapsülleme üzerine odaklanır ve sınıf sözleşmeleri açısından düşünür.</span><span class="sxs-lookup"><span data-stu-id="02a26-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="02a26-163">Nesne türlerinin davranışı ve durumu çok önemlidir ve bu endişeleri gidermek için sınıflar, arabirimler, kalıtım ve çok biçimlilik gibi dil özellikleri sağlanır.</span><span class="sxs-lookup"><span data-stu-id="02a26-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="02a26-164">Buna karşılık, fonksiyonel programlama veri koleksiyonlarının saf işlevsel dönüşümlerinin değerlendirilmesinde bir alıştırma olarak hesaplama lı sorunlara yaklaşır.</span><span class="sxs-lookup"><span data-stu-id="02a26-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="02a26-165">İşlevsel programlama durum ve mutable verileri önler ve bunun yerine işlevlerin uygulanmasını vurgular.</span><span class="sxs-lookup"><span data-stu-id="02a26-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="02a26-166">Neyse ki, C# işlevsel programlamaya tam sıçrama gerektirmez, çünkü hem zorunlu hem de işlevsel programlama yaklaşımlarını destekler.</span><span class="sxs-lookup"><span data-stu-id="02a26-166">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="02a26-167">Geliştirici, belirli bir senaryo için en uygun yaklaşımı seçebilir.</span><span class="sxs-lookup"><span data-stu-id="02a26-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="02a26-168">Aslında, programlar genellikle her iki yaklaşımı birleştirir.</span><span class="sxs-lookup"><span data-stu-id="02a26-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="02a26-169">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="02a26-169">See also</span></span>

- [<span data-ttu-id="02a26-170">Saf İşlevsel Dönüşümlere Giriş (C#)</span><span class="sxs-lookup"><span data-stu-id="02a26-170">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="02a26-171">XSLT Dönüşümleri</span><span class="sxs-lookup"><span data-stu-id="02a26-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="02a26-172">Saf Fonksiyonlara Yeniden Düzenleme (C#)</span><span class="sxs-lookup"><span data-stu-id="02a26-172">Refactoring Into Pure Functions (C#)</span></span>](./refactoring-into-pure-functions.md)
