---
title: Özellikler
description: Doğrulama, hesaplanan değerler, tembel değerlendirme ve özellik değiştirilen bildirimler için özellikler içeren C# özellikleri hakkında bilgi edinin.
ms.technology: csharp-fundamentals
ms.date: 04/25/2018
ms.openlocfilehash: bda8a4f58f71b57248296dd4ba9f9bf4cbed40d4
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "79399415"
---
# <a name="properties"></a><span data-ttu-id="e3976-103">Özellikler</span><span class="sxs-lookup"><span data-stu-id="e3976-103">Properties</span></span>

<span data-ttu-id="e3976-104">Mülkler C#'daki birinci sınıf vatandaşlardır.</span><span class="sxs-lookup"><span data-stu-id="e3976-104">Properties are first class citizens in C#.</span></span> <span data-ttu-id="e3976-105">Dil, geliştiricilerin tasarım amaçlarını doğru bir şekilde ifade eden kod yazmalarını sağlayan sözdizimini tanımlar.</span><span class="sxs-lookup"><span data-stu-id="e3976-105">The language defines syntax that enables developers to write code that accurately expresses their design intent.</span></span>

<span data-ttu-id="e3976-106">Özellikler erişildiğinde alanlar gibi olur.</span><span class="sxs-lookup"><span data-stu-id="e3976-106">Properties behave like fields when they are accessed.</span></span>
<span data-ttu-id="e3976-107">Ancak, alanların aksine, özellikler, bir özelliğe erişildiğinde veya atandığında yürütülen deyimleri tanımlayan erişimcilerle birlikte uygulanır.</span><span class="sxs-lookup"><span data-stu-id="e3976-107">However, unlike fields, properties are implemented with accessors that define the statements executed when a property is accessed or assigned.</span></span>

## <a name="property-syntax"></a><span data-ttu-id="e3976-108">Özellik sözdizimi</span><span class="sxs-lookup"><span data-stu-id="e3976-108">Property syntax</span></span>

<span data-ttu-id="e3976-109">Özellikler için sözdizimi alanlara doğal bir uzantısıdır.</span><span class="sxs-lookup"><span data-stu-id="e3976-109">The syntax for properties is a natural extension to fields.</span></span> <span data-ttu-id="e3976-110">Alan bir depolama konumunu tanımlar:</span><span class="sxs-lookup"><span data-stu-id="e3976-110">A field defines a storage location:</span></span>

[!code-csharp[Person class with public fields](../../samples/snippets/csharp/properties/Person.cs#1)]

<span data-ttu-id="e3976-111">Özellik tanımı, bu özelliğin değerini alan ve atayan bir `get` ve `set` erişimcinin bildirimlerini içerir:</span><span class="sxs-lookup"><span data-stu-id="e3976-111">A property definition contains declarations for a `get` and `set` accessor that retrieves and assigns the value of that property:</span></span>

[!code-csharp[Person class with public properties](../../samples/snippets/csharp/properties/Person.cs#2)]

<span data-ttu-id="e3976-112">Yukarıda gösterilen sözdizimi *otomatik özellik* sözdizimidir.</span><span class="sxs-lookup"><span data-stu-id="e3976-112">The syntax shown above is the *auto property* syntax.</span></span> <span data-ttu-id="e3976-113">Derleyici, özelliği destekleyen alanın depolama konumunu oluşturur.</span><span class="sxs-lookup"><span data-stu-id="e3976-113">The compiler generates the storage location for the field that backs up the property.</span></span> <span data-ttu-id="e3976-114">Derleyici aynı zamanda ve `get` `set` erişenelerin gövdesini de uygular.</span><span class="sxs-lookup"><span data-stu-id="e3976-114">The compiler also implements the body of the `get` and `set` accessors.</span></span>

<span data-ttu-id="e3976-115">Bazen, bir özelliği türü için varsayılan değer den başka bir değere başlatmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="e3976-115">Sometimes, you need to initialize a property to a value other than the default for its type.</span></span>  <span data-ttu-id="e3976-116">C# özelliği için kapanış ayraç sonra bir değer ayarlayarak sağlar.</span><span class="sxs-lookup"><span data-stu-id="e3976-116">C# enables that by setting a value after the closing brace for the property.</span></span> <span data-ttu-id="e3976-117">`FirstName` Özelliğin ilk değerinin `null`boş dize yerine boş dize olmasını tercih edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-117">You may prefer the initial value for the `FirstName` property to be the empty string rather than `null`.</span></span> <span data-ttu-id="e3976-118">Aşağıda gösterildiği gibi belirtebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-118">You would specify that as shown below:</span></span>

[!code-csharp[Person class with properties and initializer](../../samples/snippets/csharp/properties/Person.cs#3)]

<span data-ttu-id="e3976-119">Bu makalede daha sonra göreceğiniz gibi, özel başlatma en çok salt okunur özellikler için yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="e3976-119">Specific initialization is most useful for read-only properties, as you'll see later in this article.</span></span>

<span data-ttu-id="e3976-120">Ayrıca, aşağıda gösterildiği gibi depolama yı kendiniz de tanımlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-120">You can also define the storage yourself, as shown below:</span></span>

[!code-csharp[Person class with properties and backing field](../../samples/snippets/csharp/properties/Person.cs#4)]

<span data-ttu-id="e3976-121">Özellik uygulaması tek bir ifade olduğunda, gelen veya ayarlayıcı için *ifade gövdeli üyeleri* kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-121">When a property implementation is a single expression, you can use *expression-bodied members* for the getter or setter:</span></span>

[!code-csharp[Person class with properties and expression bodied getters and setters](../../samples/snippets/csharp/properties/Person.cs#5)]

<span data-ttu-id="e3976-122">Bu basitleştirilmiş sözdizimi, bu makale boyunca geçerli olduğu durumlarda kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="e3976-122">This simplified syntax will be used where applicable throughout this article.</span></span>

<span data-ttu-id="e3976-123">Yukarıda gösterilen özellik tanımı bir okuma-yazma özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="e3976-123">The property definition shown above is a read-write property.</span></span> <span data-ttu-id="e3976-124">Ayarlanan erişimdeki anahtar kelimeye `value` dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="e3976-124">Notice the keyword `value` in the set accessor.</span></span> <span data-ttu-id="e3976-125">Erişimcinin `set` her zaman adı `value`tek bir parametre vardır.</span><span class="sxs-lookup"><span data-stu-id="e3976-125">The `set` accessor always has a single parameter named `value`.</span></span> <span data-ttu-id="e3976-126">Erişimci, `get` özelliğin türüne dönüştürülebilir bir değer döndürmelidir (bu`string` örnekte).</span><span class="sxs-lookup"><span data-stu-id="e3976-126">The `get` accessor must return a value that is convertible to the type of the property (`string` in this example).</span></span>

<span data-ttu-id="e3976-127">Sözdiziminin temelleri bu.</span><span class="sxs-lookup"><span data-stu-id="e3976-127">That's the basics of the syntax.</span></span> <span data-ttu-id="e3976-128">Farklı tasarım deyimleri çeşitli destekleyen birçok farklı varyasyonları vardır.</span><span class="sxs-lookup"><span data-stu-id="e3976-128">There are many different variations that support a variety of different design idioms.</span></span> <span data-ttu-id="e3976-129">Her biri için sözdizimi seçeneklerini inceleyelim ve öğrenelim.</span><span class="sxs-lookup"><span data-stu-id="e3976-129">Let's explore, and learn the syntax options for each.</span></span>

## <a name="scenarios"></a><span data-ttu-id="e3976-130">Senaryolar</span><span class="sxs-lookup"><span data-stu-id="e3976-130">Scenarios</span></span>

<span data-ttu-id="e3976-131">Yukarıdaki örnekler özellik tanımının en basit örneklerinden birini gösterdi: doğrulama olmayan bir okuma-yazma özelliği.</span><span class="sxs-lookup"><span data-stu-id="e3976-131">The examples above showed one of the simplest cases of property definition: a read-write property with no validation.</span></span> <span data-ttu-id="e3976-132">İstediğiniz kodu `get` ve `set` erişimcileri yazarak, birçok farklı senaryo oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-132">By writing the code you want in the `get` and `set` accessors, you can create many different scenarios.</span></span>

### <a name="validation"></a><span data-ttu-id="e3976-133">Doğrulama</span><span class="sxs-lookup"><span data-stu-id="e3976-133">Validation</span></span>

<span data-ttu-id="e3976-134">Bir özellik tarafından `set` temsil edilen değerlerin her zaman geçerli olduğundan emin olmak için erişime erişime kod yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-134">You can write code in the `set` accessor to ensure that the values represented by a property are always valid.</span></span> <span data-ttu-id="e3976-135">Örneğin, `Person` sınıf için bir kural, adın boş veya beyaz boşluk olamaz olduğunu varsayalım.</span><span class="sxs-lookup"><span data-stu-id="e3976-135">For example, suppose one rule for the `Person` class is that the name cannot be blank or white space.</span></span> <span data-ttu-id="e3976-136">Bunu şöyle yazacaktın:</span><span class="sxs-lookup"><span data-stu-id="e3976-136">You would write that as follows:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#6)]

<span data-ttu-id="e3976-137">Önceki örnek, özellik ayarlayıcı doğrulamasının bir parçası olarak bir`throw` ifade kullanılarak basitleştirilmiş olabilir:</span><span class="sxs-lookup"><span data-stu-id="e3976-137">The preceding example can be simplified by using a`throw` expression as part of the property setter validation:</span></span>

[!code-csharp[Validating property setters](../../samples/snippets/csharp/properties/Person.cs#7)]

<span data-ttu-id="e3976-138">Yukarıdaki örnek, ilk adın boş veya beyaz boşluk olmaması gerektiği kuralını zorlar.</span><span class="sxs-lookup"><span data-stu-id="e3976-138">The example above enforces the rule that the first name must not be blank or white space.</span></span> <span data-ttu-id="e3976-139">Bir geliştirici yazarsa</span><span class="sxs-lookup"><span data-stu-id="e3976-139">If a developer writes</span></span>

```csharp
hero.FirstName = "";
```

<span data-ttu-id="e3976-140">Bu atama bir `ArgumentException`.</span><span class="sxs-lookup"><span data-stu-id="e3976-140">That assignment throws an `ArgumentException`.</span></span> <span data-ttu-id="e3976-141">Özellik kümesi aksesuarı geçersiz bir iade türüne sahip olduğundan, bir özel durum oluşturarak ayarlanan erişimcideki hataları bildirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-141">Because a property set accessor must have a void return type, you report errors in the set accessor by throwing an exception.</span></span>

<span data-ttu-id="e3976-142">Aynı sözdizimini senaryonuzda gereken her şeye genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-142">You can extend this same syntax to anything needed in your scenario.</span></span> <span data-ttu-id="e3976-143">Farklı özellikler arasındaki ilişkileri denetleyebilir veya dış koşullara karşı doğrulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-143">You can check the relationships between different properties, or validate against any external conditions.</span></span> <span data-ttu-id="e3976-144">Geçerli C# ifadeleri bir özellik aksesuarında geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="e3976-144">Any valid C# statements are valid in a property accessor.</span></span>

### <a name="read-only"></a><span data-ttu-id="e3976-145">Salt okunur</span><span class="sxs-lookup"><span data-stu-id="e3976-145">Read-only</span></span>

<span data-ttu-id="e3976-146">Bu noktaya kadar, gördüğünüz tüm özellik tanımları ortak erişime sahip okuma/yazma özellikleridir.</span><span class="sxs-lookup"><span data-stu-id="e3976-146">Up to this point, all the property definitions you have seen are read/write properties with public accessors.</span></span> <span data-ttu-id="e3976-147">Özellikler için tek geçerli erişilebilirlik bu değildir.</span><span class="sxs-lookup"><span data-stu-id="e3976-147">That's not the only valid accessibility for properties.</span></span>
<span data-ttu-id="e3976-148">Salt okunur özellikler oluşturabilir veya kümeye farklı erişilebilirlik verebilir ve erişimsağlayanlar elde edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-148">You can create read-only properties, or give different accessibility to the set and get accessors.</span></span> <span data-ttu-id="e3976-149">Sınıfınızın `Person` yalnızca `FirstName` özelliğin değerini o sınıftaki diğer yöntemlerden değiştirmeyi etkinleştirmesi gerektiğini varsayalım.</span><span class="sxs-lookup"><span data-stu-id="e3976-149">Suppose that your `Person` class should only enable changing the value of the `FirstName` property from other methods in that class.</span></span> <span data-ttu-id="e3976-150">Aşağıdakiler yerine ayarlanan `private` erişime erişim `public`sağlayabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-150">You could give the set accessor `private` accessibility instead of `public`:</span></span>

[!code-csharp[Using a private setter for a publicly readonly property](../../samples/snippets/csharp/properties/Person.cs#8)]

<span data-ttu-id="e3976-151">Şimdi, `FirstName` özellik herhangi bir koddan erişilebilir, ancak yalnızca sınıftaki `Person` diğer kodlardan atanabilir.</span><span class="sxs-lookup"><span data-stu-id="e3976-151">Now, the `FirstName` property can be accessed from any code, but it can only be assigned from other code in the `Person` class.</span></span>

<span data-ttu-id="e3976-152">Herhangi bir kısıtlayıcı erişim değiştiricisini kümeye ekleyebilir veya erişimcilere ulaşabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-152">You can add any restrictive access modifier to either the set or get accessors.</span></span> <span data-ttu-id="e3976-153">Tek tek erişime yerleştirdiğiniz herhangi bir erişim değiştirici, özellik tanımındaki erişim değiştiricisinden daha sınırlı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="e3976-153">Any access modifier you place on the individual accessor must be more limited than the access modifier on the property definition.</span></span> <span data-ttu-id="e3976-154">Özellik olduğu `FirstName` `public`için yukarıdaki yasal , ancak ayarlanan erişimci . `private`</span><span class="sxs-lookup"><span data-stu-id="e3976-154">The above is legal because the `FirstName` property is `public`, but the set accessor is `private`.</span></span> <span data-ttu-id="e3976-155">Bir aksesuarı `private` olan bir `public` mülkü bildiremediniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-155">You could not declare a `private` property with a `public` accessor.</span></span> <span data-ttu-id="e3976-156">Özellik beyanları da `protected`ilan `internal` `protected internal`edilebilir , `private`, , , hatta .</span><span class="sxs-lookup"><span data-stu-id="e3976-156">Property declarations can also be declared `protected`, `internal`, `protected internal`, or, even `private`.</span></span>

<span data-ttu-id="e3976-157">`get` Ayrıca, daha kısıtlayıcı değiştiricinin aksesuara yerlefı yapmak da yasaldır.</span><span class="sxs-lookup"><span data-stu-id="e3976-157">It is also legal to place the more restrictive modifier on the `get` accessor.</span></span> <span data-ttu-id="e3976-158">Örneğin, bir `public` özelliğiniz olabilir, ancak `get` erişime `private`gireni .</span><span class="sxs-lookup"><span data-stu-id="e3976-158">For example, you could have a `public` property, but restrict the `get` accessor to `private`.</span></span> <span data-ttu-id="e3976-159">Bu senaryo pratikte nadiren yapılır.</span><span class="sxs-lookup"><span data-stu-id="e3976-159">That scenario is rarely done in practice.</span></span>

<span data-ttu-id="e3976-160">Bir özellik için yapılan değişiklikleri, yalnızca bir oluşturucu veya özellik başlatılmasında ayarlanabilmesi için de kısıtlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-160">You can also restrict modifications to a property so that it can only be set in a constructor or a property initializer.</span></span> <span data-ttu-id="e3976-161">`Person` Sınıfı aşağıdaki şekilde değiştirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-161">You can modify the `Person` class so as follows:</span></span>

[!code-csharp[A readonly auto implemented property](../../samples/snippets/csharp/properties/Person.cs#9)]

<span data-ttu-id="e3976-162">Bu özellik en sık salt okunur özellikleri olarak ortaya çıkarılan koleksiyonları n için başlatmaiçin kullanılır:</span><span class="sxs-lookup"><span data-stu-id="e3976-162">This feature is most commonly used for initializing collections that are exposed as read-only properties:</span></span>

```csharp
public class Measurements
{
    public ICollection<DataPoint> points { get; } = new List<DataPoint>();
}
```

### <a name="computed-properties"></a><span data-ttu-id="e3976-163">Hesaplanmış özellikler</span><span class="sxs-lookup"><span data-stu-id="e3976-163">Computed properties</span></span>

<span data-ttu-id="e3976-164">Bir özelliğin yalnızca üye alanın değerini döndürmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="e3976-164">A property does not need to simply return the value of a member field.</span></span> <span data-ttu-id="e3976-165">Hesaplanan bir değer döndüren özellikler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-165">You can create properties that return a computed value.</span></span> <span data-ttu-id="e3976-166">Nesneyi, `Person` ad ve soyadlarını biraraya getirerek hesaplanan tam adı döndürmek için genişletelim:</span><span class="sxs-lookup"><span data-stu-id="e3976-166">Let's expand the `Person` object to return the full name, computed by concatenating the first and last names:</span></span>

[!code-csharp[A computed property](../../samples/snippets/csharp/properties/Person.cs#10)]

<span data-ttu-id="e3976-167">Yukarıdaki örnekte, tam ad için biçimlendirilmiş dize oluşturmak için [dize enterpolasyon](./language-reference/tokens/interpolated.md) özelliği ni kullanır.</span><span class="sxs-lookup"><span data-stu-id="e3976-167">The example above uses the [string interpolation](./language-reference/tokens/interpolated.md) feature to create the formatted string for the full name.</span></span>

<span data-ttu-id="e3976-168">Ayrıca, hesaplanan `FullName` özelliği oluşturmak için daha kısa bir yol sağlayan *ifade gövdeli*bir üye de kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-168">You can also use an *expression-bodied member*, which provides a more succinct way to create the computed `FullName` property:</span></span>

[!code-csharp[A computed property using an expression bodied member](../../samples/snippets/csharp/properties/Person.cs#11)]

<span data-ttu-id="e3976-169">*İfade gövdeli üyeler,* tek bir ifade içeren yöntemleri tanımlamak için *lambda ifade* sözdizimini kullanırlar.</span><span class="sxs-lookup"><span data-stu-id="e3976-169">*Expression-bodied members* use the *lambda expression* syntax to define methods that contain a single expression.</span></span> <span data-ttu-id="e3976-170">Burada, bu ifade kişi nesnesinin tam adını döndürür.</span><span class="sxs-lookup"><span data-stu-id="e3976-170">Here, that expression returns the full name for the person object.</span></span>

### <a name="cached-evaluated-properties"></a><span data-ttu-id="e3976-171">Önbelleğe alınmış değerlendirilen özellikler</span><span class="sxs-lookup"><span data-stu-id="e3976-171">Cached evaluated properties</span></span>

<span data-ttu-id="e3976-172">Hesaplanmış bir özellik kavramını depolama yla karıştırabilir ve *önbelleğe alınmış bir özellik*oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-172">You can mix the concept of a computed property with storage and create a *cached evaluated property*.</span></span>  <span data-ttu-id="e3976-173">Örneğin, `FullName` özelliği, dize biçimlendirmesinin yalnızca ilk erişilen de olması için güncelleştirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-173">For example, you could update the `FullName` property so that the string formatting only happened the first time it was accessed:</span></span>

[!code-csharp[Caching the value of a computed property](../../samples/snippets/csharp/properties/Person.cs#12)]

<span data-ttu-id="e3976-174">Yukarıdaki kod olsa bir hata içerir.</span><span class="sxs-lookup"><span data-stu-id="e3976-174">The above code contains a bug though.</span></span> <span data-ttu-id="e3976-175">Kod, özelliğin `FirstName` veya `LastName` özelliğin değerini güncelleştirirse, daha önce değerlendirilen `fullName` alan geçersizdir.</span><span class="sxs-lookup"><span data-stu-id="e3976-175">If code updates the value of either the `FirstName` or `LastName` property, the previously evaluated `fullName` field is invalid.</span></span> <span data-ttu-id="e3976-176">Alanın yeniden `set` hesaplanacak şekilde `FirstName` `LastName` erişimci lerini ve özelliğini değiştirirsiniz: `fullName`</span><span class="sxs-lookup"><span data-stu-id="e3976-176">You modify the `set` accessors of the `FirstName` and `LastName` property so that the `fullName` field is calculated again:</span></span>

[!code-csharp[Invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#13)]

<span data-ttu-id="e3976-177">Bu son sürüm `FullName` özelliği yalnızca gerektiğinde değerlendirir.</span><span class="sxs-lookup"><span data-stu-id="e3976-177">This final version evaluates the `FullName` property only when needed.</span></span>
<span data-ttu-id="e3976-178">Önceden hesaplanan sürüm geçerliyse, kullanılır.</span><span class="sxs-lookup"><span data-stu-id="e3976-178">If the previously calculated version is valid, it's used.</span></span> <span data-ttu-id="e3976-179">Başka bir durum değişikliği önceden hesaplanan sürümü geçersiz kılınıyorsa, yeniden hesaplanır.</span><span class="sxs-lookup"><span data-stu-id="e3976-179">If another state change invalidates the previously calculated version, it will be recalculated.</span></span> <span data-ttu-id="e3976-180">Bu sınıfı kullanan geliştiricilerin uygulamanın ayrıntılarını bilmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="e3976-180">Developers that use this class do not need to know the details of the implementation.</span></span> <span data-ttu-id="e3976-181">Bu iç değişikliklerin hiçbiri Kişi nesnesinin kullanımını etkilemez.</span><span class="sxs-lookup"><span data-stu-id="e3976-181">None of these internal changes affect the use of the Person object.</span></span> <span data-ttu-id="e3976-182">Bir nesnenin veri üyelerini ortaya çıkarmak için Özellikler'i kullanmanın temel nedeni budur.</span><span class="sxs-lookup"><span data-stu-id="e3976-182">That's the key reason for using Properties to expose data members of an object.</span></span>

### <a name="attaching-attributes-to-auto-implemented-properties"></a><span data-ttu-id="e3976-183">Öznitelikleri otomatik olarak uygulanan özelliklere ekleme</span><span class="sxs-lookup"><span data-stu-id="e3976-183">Attaching attributes to auto-implemented properties</span></span>

<span data-ttu-id="e3976-184">C# 7.3 ile başlayarak, alan öznitelikleri otomatik uygulanan özelliklerde derleyici oluşturulan destek alanına eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="e3976-184">Beginning with C# 7.3, field attributes can be attached to the compiler generated backing field in auto-implemented properties.</span></span> <span data-ttu-id="e3976-185">Örneğin, benzersiz bir tamsayı `Person` `Id` özelliği ekleyen sınıfa bir düzeltme düşünün.</span><span class="sxs-lookup"><span data-stu-id="e3976-185">For example, consider a revision to the `Person` class that adds a unique integer `Id` property.</span></span>
<span data-ttu-id="e3976-186">`Id` Özelliği otomatik olarak uygulanan bir özelliği kullanarak yazarsınız, ancak tasarımınız `Id` özelliğin kalıcı olarak kullanılmasını gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="e3976-186">You write the`Id` property using an auto-implemented property, but your design does not call for persisting the `Id` property.</span></span> <span data-ttu-id="e3976-187">Yalnızca <xref:System.NonSerializedAttribute> alanlara bağlanabilir, özelliklere değil.</span><span class="sxs-lookup"><span data-stu-id="e3976-187">The <xref:System.NonSerializedAttribute> can only be attached to fields, not properties.</span></span> <span data-ttu-id="e3976-188">Aşağıdaki örnekte <xref:System.NonSerializedAttribute> gösterildiği gibi, `Id` öznitelik üzerinde `field:` belirtici kullanarak özelliğin destek alanına ekleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="e3976-188">You can attach the <xref:System.NonSerializedAttribute> to the backing field for the `Id` property by using the `field:` specifier on the attribute, as shown in the following example:</span></span>

[!code-csharp[Attaching attributes to a backing field](../../samples/snippets/csharp/properties/Person.cs#14)]

<span data-ttu-id="e3976-189">Bu teknik, otomatik olarak uygulanan özellik üzerinde destek alanına eklediğiniz herhangi bir öznitelik için çalışır.</span><span class="sxs-lookup"><span data-stu-id="e3976-189">This technique works for any attribute you attach to the backing field on the auto-implemented property.</span></span>

### <a name="implementing-inotifypropertychanged"></a><span data-ttu-id="e3976-190">INotifyPropertyChanged uygulanması</span><span class="sxs-lookup"><span data-stu-id="e3976-190">Implementing INotifyPropertyChanged</span></span>

<span data-ttu-id="e3976-191">Bir özellik erişimcisine kod yazmanız gereken son senaryo, veri bağlama istemcilerine bir değerin değiştiğini bildirmek için kullanılan <xref:System.ComponentModel.INotifyPropertyChanged> arabirimi desteklemektir.</span><span class="sxs-lookup"><span data-stu-id="e3976-191">A final scenario where you need to write code in a property accessor is to support the <xref:System.ComponentModel.INotifyPropertyChanged> interface used to notify data binding clients that a value has changed.</span></span> <span data-ttu-id="e3976-192">Bir özelliğin değeri değiştiğinde, nesne <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> değişikliği göstermek için olayı yükseltir.</span><span class="sxs-lookup"><span data-stu-id="e3976-192">When the value of a property changes, the object raises the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged?displayProperty=nameWithType> event to indicate the change.</span></span> <span data-ttu-id="e3976-193">Veri bağlama kitaplıkları, sırayla, bu değişikliği temel alan görüntü öğelerini günceller.</span><span class="sxs-lookup"><span data-stu-id="e3976-193">The data binding libraries, in turn, update display elements based on that change.</span></span> <span data-ttu-id="e3976-194">Aşağıdaki kod, bu kişi `INotifyPropertyChanged` sınıfının `FirstName` özelliği için nasıl uygulayacağınızı gösterir.</span><span class="sxs-lookup"><span data-stu-id="e3976-194">The code below shows how you would implement `INotifyPropertyChanged` for the `FirstName` property of this person class.</span></span>

[!code-csharp[invalidating the cache correctly](../../samples/snippets/csharp/properties/Person.cs#15)]

<span data-ttu-id="e3976-195">İşleç `?.` *null koşullu işleci*denir.</span><span class="sxs-lookup"><span data-stu-id="e3976-195">The `?.` operator is called the *null conditional operator*.</span></span> <span data-ttu-id="e3976-196">Operatörün sağ tarafını değerlendirmeden önce null başvurusu kontrol eder.</span><span class="sxs-lookup"><span data-stu-id="e3976-196">It checks for a null reference before evaluating the right side of the operator.</span></span> <span data-ttu-id="e3976-197">Sonuç olarak, `PropertyChanged` olaya abone yoksa, olayı yükseltmek için kod yürütülmüyor.</span><span class="sxs-lookup"><span data-stu-id="e3976-197">The end result is that if there are no subscribers to the `PropertyChanged` event, the code to raise the event doesn't execute.</span></span> <span data-ttu-id="e3976-198">Bu durumda `NullReferenceException` bu çek olmadan bir atmak olacaktır.</span><span class="sxs-lookup"><span data-stu-id="e3976-198">It would throw a `NullReferenceException` without this check in that case.</span></span> <span data-ttu-id="e3976-199">Daha fazla bilgi [`events`](events-overview.md)için bkz.</span><span class="sxs-lookup"><span data-stu-id="e3976-199">For more information, see [`events`](events-overview.md).</span></span> <span data-ttu-id="e3976-200">Bu örnek, özellik `nameof` adı simgesinden metin gösterimine dönüştürmek için yeni işleci de kullanır.</span><span class="sxs-lookup"><span data-stu-id="e3976-200">This example also uses the new `nameof` operator to convert from the property name symbol to its text representation.</span></span>
<span data-ttu-id="e3976-201">Kullanma `nameof` özelliğinin adını yanlış yazdığınız hataları azaltabilir.</span><span class="sxs-lookup"><span data-stu-id="e3976-201">Using `nameof` can reduce errors where you have mistyped the name of the property.</span></span>

<span data-ttu-id="e3976-202">Yine, uygulama, <xref:System.ComponentModel.INotifyPropertyChanged> ihtiyacınız olan senaryoları desteklemek için erişime girenlere kod yazabileceğiniz bir örnektir.</span><span class="sxs-lookup"><span data-stu-id="e3976-202">Again, implementing <xref:System.ComponentModel.INotifyPropertyChanged> is an example of a case where you can write code in your accessors to support the scenarios you need.</span></span>

## <a name="summing-up"></a><span data-ttu-id="e3976-203">Özetleme</span><span class="sxs-lookup"><span data-stu-id="e3976-203">Summing up</span></span>

<span data-ttu-id="e3976-204">Özellikler, bir sınıf veya nesnedeki akıllı alanların biçimidir.</span><span class="sxs-lookup"><span data-stu-id="e3976-204">Properties are a form of smart fields in a class or object.</span></span> <span data-ttu-id="e3976-205">Nesnenin dışından, nesnedeki alanlar gibi görünürler.</span><span class="sxs-lookup"><span data-stu-id="e3976-205">From outside the object, they appear like fields in the object.</span></span> <span data-ttu-id="e3976-206">Ancak, özellikler C# işlevselliğinin tam paleti kullanılarak uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="e3976-206">However, properties can be implemented using the full palette of C# functionality.</span></span>
<span data-ttu-id="e3976-207">Doğrulama, farklı erişilebilirlik, tembel değerlendirme veya senaryolarınızın gereksinim duyduğu gereksinimleri sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="e3976-207">You can provide validation, different accessibility, lazy evaluation, or any requirements your scenarios need.</span></span>
