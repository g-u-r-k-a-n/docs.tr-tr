---
title: C# 9,0 ' deki yenilikler-C# Kılavuzu
description: C# 9,0 ' de bulunan yeni özelliklere genel bakış alın.
ms.date: 04/07/2021
ms.openlocfilehash: c2189d2db175a40c24d6a41d20f2ae2d9384513b
ms.sourcegitcommit: e7e0921d0a10f85e9cb12f8b87cc1639a6c8d3fe
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/09/2021
ms.locfileid: "107255343"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="f18f2-103">C# 9.0 sürümündeki yenilikler</span><span class="sxs-lookup"><span data-stu-id="f18f2-103">What's new in C# 9.0</span></span>

<span data-ttu-id="f18f2-104">C# 9,0, C# diline aşağıdaki özellikleri ve geliştirmeleri ekler:</span><span class="sxs-lookup"><span data-stu-id="f18f2-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="f18f2-105">Kayıtlar</span><span class="sxs-lookup"><span data-stu-id="f18f2-105">Records</span></span>](#record-types)
- [<span data-ttu-id="f18f2-106">Yalnızca init ayarlayıcılar</span><span class="sxs-lookup"><span data-stu-id="f18f2-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="f18f2-107">Üst düzey deyimler</span><span class="sxs-lookup"><span data-stu-id="f18f2-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="f18f2-108">Desen eşleştirme geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="f18f2-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- [<span data-ttu-id="f18f2-109">Performans ve birlikte çalışma</span><span class="sxs-lookup"><span data-stu-id="f18f2-109">Performance and interop</span></span>](#performance-and-interop)
  - <span data-ttu-id="f18f2-110">Yerel boyutlu tamsayılar</span><span class="sxs-lookup"><span data-stu-id="f18f2-110">Native sized integers</span></span>
  - <span data-ttu-id="f18f2-111">İşlev işaretçileri</span><span class="sxs-lookup"><span data-stu-id="f18f2-111">Function pointers</span></span>
  - <span data-ttu-id="f18f2-112">Yaymayı localsinit bayrağını gösterme</span><span class="sxs-lookup"><span data-stu-id="f18f2-112">Suppress emitting localsinit flag</span></span>
- [<span data-ttu-id="f18f2-113">Sığdırma ve son özellikler</span><span class="sxs-lookup"><span data-stu-id="f18f2-113">Fit and finish features</span></span>](#fit-and-finish-features)
  - <span data-ttu-id="f18f2-114">Hedef türü belirtilmiş `new` ifadeler</span><span class="sxs-lookup"><span data-stu-id="f18f2-114">Target-typed `new` expressions</span></span>
  - <span data-ttu-id="f18f2-115">statik anonim işlevler</span><span class="sxs-lookup"><span data-stu-id="f18f2-115">static anonymous functions</span></span>
  - <span data-ttu-id="f18f2-116">Hedef türü belirlenmiş Koşullu ifadeler</span><span class="sxs-lookup"><span data-stu-id="f18f2-116">Target-typed conditional expressions</span></span>
  - <span data-ttu-id="f18f2-117">Birlikte değişken dönüş türleri</span><span class="sxs-lookup"><span data-stu-id="f18f2-117">Covariant return types</span></span>
  - <span data-ttu-id="f18f2-118">`GetEnumerator`Döngüler için uzantı desteği `foreach`</span><span class="sxs-lookup"><span data-stu-id="f18f2-118">Extension `GetEnumerator` support for `foreach` loops</span></span>
  - <span data-ttu-id="f18f2-119">Lambda atma parametreleri</span><span class="sxs-lookup"><span data-stu-id="f18f2-119">Lambda discard parameters</span></span>
  - <span data-ttu-id="f18f2-120">Yerel işlevlerlerde öznitelikler</span><span class="sxs-lookup"><span data-stu-id="f18f2-120">Attributes on local functions</span></span>
- [<span data-ttu-id="f18f2-121">Kod oluşturucuları için destek</span><span class="sxs-lookup"><span data-stu-id="f18f2-121">Support for code generators</span></span>](#support-for-code-generators)
  - <span data-ttu-id="f18f2-122">Modül başlatıcılar</span><span class="sxs-lookup"><span data-stu-id="f18f2-122">Module initializers</span></span>
  - <span data-ttu-id="f18f2-123">Kısmi yöntemlere yönelik yeni özellikler</span><span class="sxs-lookup"><span data-stu-id="f18f2-123">New features for partial methods</span></span>

<span data-ttu-id="f18f2-124">C# 9,0, **.NET 5**' te desteklenir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-124">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="f18f2-125">Daha fazla bilgi için bkz. [C# dil sürümü oluşturma](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="f18f2-125">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="f18f2-126">[.Net İndirmeleri sayfasından](https://dotnet.microsoft.com/download)en son .NET SDK 'sını indirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-126">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="f18f2-127">Kayıt türleri</span><span class="sxs-lookup"><span data-stu-id="f18f2-127">Record types</span></span>

<span data-ttu-id="f18f2-128">C# 9,0 ***kayıt türlerini*** tanıtır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-128">C# 9.0 introduces ***record types***.</span></span> <span data-ttu-id="f18f2-129">`record`Verileri kapsüllemek için yerleşik işlevsellik sağlayan bir başvuru türü tanımlamak için anahtar sözcüğünü kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="f18f2-129">You use the `record` keyword to define a reference type that provides built-in functionality for encapsulating data.</span></span> <span data-ttu-id="f18f2-130">Konumsal parametreleri veya standart özellik sözdizimini kullanarak, değişmez özelliklerle kayıt türleri oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f18f2-130">You can create record types with immutable properties by using positional parameters or standard property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ImmutableRecord":::

<span data-ttu-id="f18f2-131">Ayrıca, değişebilir Özellikler ve alanlarla kayıt türleri de oluşturabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f18f2-131">You can also create record types with mutable properties and fields:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="MutableRecord":::

<span data-ttu-id="f18f2-132">Kayıtlar değişebilir olsa da, Bunlar öncelikle sabit veri modellerini desteklemeye yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-132">While records can be mutable, they are primarily intended for supporting immutable data models.</span></span> <span data-ttu-id="f18f2-133">Kayıt türü aşağıdaki özellikleri sunar:</span><span class="sxs-lookup"><span data-stu-id="f18f2-133">The record type offers the following features:</span></span>

* [<span data-ttu-id="f18f2-134">Sabit özelliklerle başvuru türü oluşturmak için kısa sözdizimi</span><span class="sxs-lookup"><span data-stu-id="f18f2-134">Concise syntax for creating a reference type with immutable properties</span></span>](#positional-syntax-for-property-definition)
* <span data-ttu-id="f18f2-135">Davranış, veri merkezli bir başvuru türü için yararlıdır:</span><span class="sxs-lookup"><span data-stu-id="f18f2-135">Behavior useful for a data-centric reference type:</span></span>
  * [<span data-ttu-id="f18f2-136">Değer eşitlik</span><span class="sxs-lookup"><span data-stu-id="f18f2-136">Value equality</span></span>](#value-equality)
  * [<span data-ttu-id="f18f2-137">Geri dönüşlü mutasyon için kısa sözdizimi</span><span class="sxs-lookup"><span data-stu-id="f18f2-137">Concise syntax for nondestructive mutation</span></span>](#nondestructive-mutation)
  * [<span data-ttu-id="f18f2-138">Görüntüleme için yerleşik biçimlendirme</span><span class="sxs-lookup"><span data-stu-id="f18f2-138">Built-in formatting for display</span></span>](#built-in-formatting-for-display)
* [<span data-ttu-id="f18f2-139">Devralma hiyerarşileri için destek</span><span class="sxs-lookup"><span data-stu-id="f18f2-139">Support for inheritance hierarchies</span></span>](#inheritance)

<span data-ttu-id="f18f2-140">Değer eşitlik ve çok az davranış sağlayan veri merkezli türler tasarlamak için [yapı türlerini](../language-reference/builtin-types/struct.md) kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-140">You can use [structure types](../language-reference/builtin-types/struct.md) to design data-centric types that provide value equality and little or no behavior.</span></span> <span data-ttu-id="f18f2-141">Ancak görece büyük veri modelleri için yapı türlerinin bazı dezavantajları vardır:</span><span class="sxs-lookup"><span data-stu-id="f18f2-141">But for relatively large data models, structure types have some disadvantages:</span></span>

* <span data-ttu-id="f18f2-142">Devralma desteği yoktur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-142">They don't support inheritance.</span></span>
* <span data-ttu-id="f18f2-143">Değer eşitliğini belirlemede daha az verimlidir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-143">They're less efficient at determining value equality.</span></span> <span data-ttu-id="f18f2-144">Değer türlerinde, <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> yöntemi tüm alanları bulmak için yansıma kullanır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-144">For value types, the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method uses reflection to find all fields.</span></span> <span data-ttu-id="f18f2-145">Kayıtlar için derleyici `Equals` yöntemini oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-145">For records, the compiler generates the `Equals` method.</span></span> <span data-ttu-id="f18f2-146">Uygulamada, kayıtlardaki değer eşitlik uygulaması yaşamları daha hızlıdır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-146">In practice, the implementation of value equality in records is measurably faster.</span></span>
* <span data-ttu-id="f18f2-147">Her örnek tüm verilerin tamamen bir kopyasına sahip olduğundan, bazı senaryolarda daha fazla bellek kullanırlar.</span><span class="sxs-lookup"><span data-stu-id="f18f2-147">They use more memory in some scenarios, since every instance has a complete copy of all of the data.</span></span> <span data-ttu-id="f18f2-148">Kayıt türleri [başvuru türlerdir](../language-reference/builtin-types/reference-types.md), bu nedenle bir kayıt örneği yalnızca verilerin bir başvurusunu içerir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-148">Record types are [reference types](../language-reference/builtin-types/reference-types.md), so a record instance contains only a reference to the data.</span></span>

### <a name="positional-syntax-for-property-definition"></a><span data-ttu-id="f18f2-149">Özellik tanımı için Konumsal sözdizimi</span><span class="sxs-lookup"><span data-stu-id="f18f2-149">Positional syntax for property definition</span></span>

<span data-ttu-id="f18f2-150">Bir kaydın özelliklerini bildirmek ve bir örnek oluştururken özellik değerlerini başlatmak için Konumsal parametreleri kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f18f2-150">You can use positional parameters to declare properties of a record and to initialize the property values when you create an instance:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InstantiatePositional":::

<span data-ttu-id="f18f2-151">Özellik tanımı için Konumsal sözdizimini kullandığınızda, derleyici şunları oluşturur:</span><span class="sxs-lookup"><span data-stu-id="f18f2-151">When you use the positional syntax for property definition, the compiler creates:</span></span>

* <span data-ttu-id="f18f2-152">Kayıt bildiriminde belirtilen her Konumsal parametre için genel bir init-tek otomatik uygulanan özellik.</span><span class="sxs-lookup"><span data-stu-id="f18f2-152">A public init-only auto-implemented property for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="f18f2-153">[Yalnızca bir init](../language-reference/keywords/init.md) özelliği, oluşturucuda veya bir özellik başlatıcısı kullanılarak ayarlanabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-153">An [init-only](../language-reference/keywords/init.md) property can only be set in the constructor or by using a property initializer.</span></span>
* <span data-ttu-id="f18f2-154">Parametreleri, kayıt bildiriminde konumsal parametrelerle eşleşen bir birincil Oluşturucu.</span><span class="sxs-lookup"><span data-stu-id="f18f2-154">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
* <span data-ttu-id="f18f2-155">`Deconstruct` `out` Kayıt bildiriminde belirtilen her Konumsal parametre için parametreye sahip bir yöntem.</span><span class="sxs-lookup"><span data-stu-id="f18f2-155">A `Deconstruct` method with an `out` parameter for each positional parameter provided in the record declaration.</span></span>

<span data-ttu-id="f18f2-156">Daha fazla bilgi için bkz. kayıtlar hakkında C# dil başvurusu makalesindeki [konumsal sözdizimi](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition) .</span><span class="sxs-lookup"><span data-stu-id="f18f2-156">For more information, see [Positional syntax](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition) in the C# language reference article about records.</span></span>

### <a name="immutability"></a><span data-ttu-id="f18f2-157">Değiştirilemezlik</span><span class="sxs-lookup"><span data-stu-id="f18f2-157">Immutability</span></span>

<span data-ttu-id="f18f2-158">Kayıt türü sabit değildir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-158">A record type is not necessarily immutable.</span></span> <span data-ttu-id="f18f2-159">Özellikleri, `set` erişimciler ve olmayan alanlarla bildirebilirsiniz `readonly` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-159">You can declare properties with `set` accessors and fields that aren't `readonly`.</span></span> <span data-ttu-id="f18f2-160">Ancak kayıtlar değişebilir, ancak değişmez veri modelleri oluşturmayı kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-160">But while records can be mutable, they make it easier to create immutable data models.</span></span> <span data-ttu-id="f18f2-161">Konumsal sözdizimi kullanarak oluşturduğunuz özellikler sabittir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-161">Properties that you create by using positional syntax are immutable.</span></span>

<span data-ttu-id="f18f2-162">Bir karma tabloda, veri merkezli bir türün iş parçacığı açısından güvenli olmasını veya karma kodun aynı kalmasını istediğinizde yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-162">Immutability can be useful when you want a data-centric type to be thread-safe or a hash code to remain the same in a hash table.</span></span> <span data-ttu-id="f18f2-163">Bir bağımsız değişkeni bir yönteme başvuruya göre geçirdiğinizde meydana gelen hataları önleyebilir ve Yöntem bağımsız değişken değerini beklenmedik şekilde değiştirir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-163">It can prevent bugs that happen when you pass an argument by reference to a method, and the method unexpectedly changes the argument value.</span></span>

<span data-ttu-id="f18f2-164">Kayıt türlerine özgü özellikler derleyici birleştirilmemiş yöntemler tarafından uygulanır ve bu yöntemlerin hiçbiri, nesne durumunu değiştirerek değişiklik imkanlarını önler.</span><span class="sxs-lookup"><span data-stu-id="f18f2-164">The features unique to record types are implemented by compiler-synthesized methods, and none of these methods compromises immutability by modifying object state.</span></span>

### <a name="value-equality"></a><span data-ttu-id="f18f2-165">Değer eşitlik</span><span class="sxs-lookup"><span data-stu-id="f18f2-165">Value equality</span></span>

<span data-ttu-id="f18f2-166">Değer eşitliği, türlerin eşleşmesi ve tüm özellik ve alan değerleri eşleşiyorsa bir kayıt türünün iki değişkeninin eşit olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-166">Value equality means that two variables of a record type are equal if the types match and all property and field values match.</span></span> <span data-ttu-id="f18f2-167">Diğer başvuru türleri için eşitlik, kimlik anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-167">For other reference types, equality means identity.</span></span> <span data-ttu-id="f18f2-168">Diğer bir deyişle, bir başvuru türünün iki değişkeni aynı nesneye başvurduklarında eşittir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-168">That is, two variables of a reference type are equal if they refer to the same object.</span></span>

<span data-ttu-id="f18f2-169">Aşağıdaki örnek, kayıt türlerinin değer eşitliğini gösterir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-169">The following example illustrates value equality of record types:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="Equality":::

<span data-ttu-id="f18f2-170">Türler ' de `class` , eşitlik yöntemlerini ve işleçleri değer eşitlik elde etmek için el ile geçersiz kılabilirsiniz, ancak bu kodun geliştirilmesi ve test edilmesi zaman alabilir ve hataya açıktır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-170">In `class` types, you could manually override equality methods and operators to achieve value equality, but developing and testing that code would be time-consuming and error-prone.</span></span> <span data-ttu-id="f18f2-171">Bu işlevin yerleşik olması, özellikler veya alanlar eklendiğinde veya değiştirildiğinde özel geçersiz kılma kodunu güncelleştirmeye neden olan hataları önler.</span><span class="sxs-lookup"><span data-stu-id="f18f2-171">Having this functionality built-in prevents bugs that would result from forgetting to update custom override code when properties or fields are added or changed.</span></span>

<span data-ttu-id="f18f2-172">Daha fazla bilgi için bkz. kayıtlar hakkında C# dil başvurusu makalesindeki [değer eşitlik](../language-reference/builtin-types/record.md#value-equality) .</span><span class="sxs-lookup"><span data-stu-id="f18f2-172">For more information, see [Value equality](../language-reference/builtin-types/record.md#value-equality) in the C# language reference article about records.</span></span>

### <a name="nondestructive-mutation"></a><span data-ttu-id="f18f2-173">Geri dönüşlü mutasyon</span><span class="sxs-lookup"><span data-stu-id="f18f2-173">Nondestructive mutation</span></span>

<span data-ttu-id="f18f2-174">Bir kayıt örneğinin sabit özelliklerini mukumanız gerekirse, geri dönüşlü bir zaman `with` elde etmek için bir ifade kullanabilirsiniz .</span><span class="sxs-lookup"><span data-stu-id="f18f2-174">If you need to mutate immutable properties of a record instance, you can use a `with` expression to achieve *nondestructive mutation*.</span></span> <span data-ttu-id="f18f2-175">Bir `with` ifade, belirtilen özellikler ve alanlarla değiştirilen mevcut bir kayıt örneğinin kopyası olan yeni bir kayıt örneği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-175">A `with` expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.</span></span> <span data-ttu-id="f18f2-176">Aşağıdaki örnekte gösterildiği gibi, değiştirilecek değerleri belirtmek için [nesne Başlatıcısı](../programming-guide/classes-and-structs/object-and-collection-initializers.md) sözdizimini kullanın:</span><span class="sxs-lookup"><span data-stu-id="f18f2-176">You use [object initializer](../programming-guide/classes-and-structs/object-and-collection-initializers.md) syntax to specify the values to be changed, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="WithExpressions":::

<span data-ttu-id="f18f2-177">Daha fazla bilgi için bkz. kayıtlar hakkında C# dil başvurusu makalesindeki geri [dönüşlü bir mutasyon](../language-reference/builtin-types/record.md#nondestructive-mutation) .</span><span class="sxs-lookup"><span data-stu-id="f18f2-177">For more information, see [Nondestructive mutation](../language-reference/builtin-types/record.md#nondestructive-mutation) in the C# language reference article about records.</span></span>

### <a name="built-in-formatting-for-display"></a><span data-ttu-id="f18f2-178">Görüntüleme için yerleşik biçimlendirme</span><span class="sxs-lookup"><span data-stu-id="f18f2-178">Built-in formatting for display</span></span>

<span data-ttu-id="f18f2-179">Kayıt türlerinde <xref:System.Object.ToString%2A> , ortak özelliklerin ve alanların adlarını ve değerlerini görüntüleyen bir derleyici tarafından oluşturulan yöntem vardır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-179">Record types have a compiler-generated <xref:System.Object.ToString%2A> method that displays the names and values of public properties and fields.</span></span> <span data-ttu-id="f18f2-180">`ToString`Yöntemi aşağıdaki biçimde bir dize döndürür:</span><span class="sxs-lookup"><span data-stu-id="f18f2-180">The `ToString` method returns a string of the following format:</span></span>

> <span data-ttu-id="f18f2-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span><span class="sxs-lookup"><span data-stu-id="f18f2-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span></span>

<span data-ttu-id="f18f2-182">Başvuru türleri için, özelliğin başvurduğu nesnenin tür adı, özellik değeri yerine görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-182">For reference types, the type name of the object that the property refers to is displayed instead of the property value.</span></span> <span data-ttu-id="f18f2-183">Aşağıdaki örnekte, dizi bir başvuru türüdür, bu nedenle `System.String[]` gerçek dizi öğesi değerleri yerine görüntülenir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-183">In the following example, the array is a reference type, so `System.String[]` is displayed instead of the actual array element values:</span></span>

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

<span data-ttu-id="f18f2-184">Daha fazla bilgi için bkz. kayıtlar hakkında C# dil başvurusu makalesindeki [yerleşik biçimlendirme](../language-reference/builtin-types/record.md#built-in-formatting-for-display) .</span><span class="sxs-lookup"><span data-stu-id="f18f2-184">For more information, see [Built-in formatting](../language-reference/builtin-types/record.md#built-in-formatting-for-display) in the C# language reference article about records.</span></span>

### <a name="inheritance"></a><span data-ttu-id="f18f2-185">Devralma</span><span class="sxs-lookup"><span data-stu-id="f18f2-185">Inheritance</span></span>

<span data-ttu-id="f18f2-186">Bir kayıt, başka bir kayıttan devralınabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-186">A record can inherit from another record.</span></span> <span data-ttu-id="f18f2-187">Ancak, bir kayıt bir sınıftan devralınabilir ve bir sınıf bir kayıttan devralınabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-187">However, a record can't inherit from a class, and a class can't inherit from a record.</span></span>

<span data-ttu-id="f18f2-188">Aşağıdaki örnek, konumsal Özellik söz dizimi ile devralmayı göstermektedir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-188">The following example illustrates inheritance with positional property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalInheritance":::

<span data-ttu-id="f18f2-189">İki kayıt değişkeninin eşit olması için, çalışma zamanı türünün eşit olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-189">For two record variables to be equal, the run-time type must be equal.</span></span> <span data-ttu-id="f18f2-190">Kapsayan değişkenlerin türleri farklı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-190">The types of the containing variables might be different.</span></span> <span data-ttu-id="f18f2-191">Bu, aşağıdaki kod örneğinde gösterilmektedir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-191">This is illustrated in the following code example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InheritanceEquality":::

<span data-ttu-id="f18f2-192">Örnekte, tüm örnekler aynı özelliklere ve aynı özellik değerlerine sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-192">In the example, all instances have the same properties and the same property values.</span></span> <span data-ttu-id="f18f2-193">`student == teacher`, Ancak `False` her iki `Person` tür değişken de döndürür.</span><span class="sxs-lookup"><span data-stu-id="f18f2-193">But `student == teacher` returns `False` although both are `Person`-type variables.</span></span> <span data-ttu-id="f18f2-194">Ve `student == student2` `True` biri değişken, diğeri ise bir `Person` `Student` değişkendir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-194">And `student == student2` returns `True` although one is a `Person` variable and one is a `Student` variable.</span></span>

<span data-ttu-id="f18f2-195">Türetilmiş ve temel türlerin tüm ortak özellikleri ve alanları `ToString` , aşağıdaki örnekte gösterildiği gibi çıkışa dahil edilmiştir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-195">All public properties and fields of both derived and base types are included in the `ToString` output, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ToStringInheritance":::

<span data-ttu-id="f18f2-196">Daha fazla bilgi için bkz. kayıtlar hakkında C# dil başvurusu makalesindeki [Devralma](../language-reference/builtin-types/record.md#inheritance) .</span><span class="sxs-lookup"><span data-stu-id="f18f2-196">For more information, see [Inheritance](../language-reference/builtin-types/record.md#inheritance) in the C# language reference article about records.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="f18f2-197">Yalnızca init ayarlayıcılar</span><span class="sxs-lookup"><span data-stu-id="f18f2-197">Init only setters</span></span>

<span data-ttu-id="f18f2-198">***Init Only Setter*** bir nesnenin üyelerini başlatmak için tutarlı sözdizimi sağlar.</span><span class="sxs-lookup"><span data-stu-id="f18f2-198">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="f18f2-199">Özellik başlatıcıları, hangi değerin hangi özelliğin ayarlanmasını temizlesin.</span><span class="sxs-lookup"><span data-stu-id="f18f2-199">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="f18f2-200">Downsıde, bu özelliklerin ayarlanabilir olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-200">The downside is that those properties must be settable.</span></span> <span data-ttu-id="f18f2-201">C# 9,0 ' den başlayarak, `init` `set` Özellikler ve Dizin oluşturucular için erişimciler yerine erişimciler oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-201">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="f18f2-202">Çağıranlar, oluşturma ifadelerinde bu değerleri ayarlamak için özellik başlatıcısı sözdizimini kullanabilir, ancak oluşturma işlemi tamamlandıktan sonra bu özellikler salt okunur yapılır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-202">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="f18f2-203">Init Only ayarlayıcıları, durumu değiştirecek bir pencere sağlar.</span><span class="sxs-lookup"><span data-stu-id="f18f2-203">Init only setters provide a window to change state.</span></span> <span data-ttu-id="f18f2-204">Bu pencere, oluşturma aşaması sona erdiğinde kapanır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-204">That window closes when the construction phase ends.</span></span> <span data-ttu-id="f18f2-205">Özellik başlatıcıları ve WITH ifadeleri dahil olmak üzere, oluşturma aşaması, tüm başlatma sonrasında etkili bir şekilde sona erer.</span><span class="sxs-lookup"><span data-stu-id="f18f2-205">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="f18f2-206">`init`Yalnızca yazdığınız herhangi bir tür için ayarlayıcıları bildirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-206">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="f18f2-207">Örneğin, aşağıdaki yapı bir hava durumu izleme yapısını tanımlar:</span><span class="sxs-lookup"><span data-stu-id="f18f2-207">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="f18f2-208">Çağıranlar, değerleri ayarlamak için özellik başlatıcısı sözdizimini kullanabilir, ancak yine de dengesizin kullanılabilirliği korunur:</span><span class="sxs-lookup"><span data-stu-id="f18f2-208">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="f18f2-209">Başlatma sonrasında bir gözlemden sonra bir izleme değişikliği girişimi bir derleyici hatası ile sonuçlanır:</span><span class="sxs-lookup"><span data-stu-id="f18f2-209">An attempt to change an observation after initialization results in a compiler error:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="f18f2-210">Yalnızca Init ayarlayıcıları, türetilmiş sınıflardan temel sınıf özellikleri ayarlamak için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-210">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="f18f2-211">Ayrıca, bir temel sınıftaki yardımcılar aracılığıyla türetilmiş özellikleri de ayarlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-211">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="f18f2-212">Konumsal kayıtlar yalnızca init ayarlayıcıları kullanarak özellikleri bildirir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-212">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="f18f2-213">Bu ayarlayıcılar,-ifadelerinde kullanılır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-213">Those setters are used in with-expressions.</span></span> <span data-ttu-id="f18f2-214">Herhangi bir `class` , veya tanımladığınız için init Only ayarlayıcıları bildirebilirsiniz `struct` `record` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-214">You can declare init only setters for any `class`, `struct`, or `record` you define.</span></span>

<span data-ttu-id="f18f2-215">Daha fazla bilgi için bkz. [init (C# Başvurusu)](../language-reference/keywords/init.md).</span><span class="sxs-lookup"><span data-stu-id="f18f2-215">For more information, see [init (C# Reference)](../language-reference/keywords/init.md).</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="f18f2-216">Üst düzey deyimler</span><span class="sxs-lookup"><span data-stu-id="f18f2-216">Top-level statements</span></span>

<span data-ttu-id="f18f2-217">***Üst düzey deyimler*** pek çok uygulamadan gereksiz seremonony 'yi kaldırır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-217">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="f18f2-218">"Merhaba Dünya!" kurallı öğesini düşünün</span><span class="sxs-lookup"><span data-stu-id="f18f2-218">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="f18f2-219">programda</span><span class="sxs-lookup"><span data-stu-id="f18f2-219">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="f18f2-220">Her şeyi yapan tek bir kod satırı vardır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-220">There's only one line of code that does anything.</span></span> <span data-ttu-id="f18f2-221">En üst düzey deyimlerle, bu ortak olan tüm ortak, `using` yönergeyi ve işi yapan tek satırı değiştirebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f18f2-221">With top-level statements, you can replace all that boilerplate with the `using` directive and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="f18f2-222">Tek satırlık bir program istediyseniz, `using` yönergeyi kaldırabilir ve tam nitelikli tür adını kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f18f2-222">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="f18f2-223">Uygulamanızdaki yalnızca bir dosya en üst düzey deyimleri kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-223">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="f18f2-224">Derleyici birden çok kaynak dosyasında en üst düzey deyimler bulursa, bu bir hatadır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-224">If the compiler finds top-level statements in multiple source files, it's an error.</span></span> <span data-ttu-id="f18f2-225">En üst düzey deyimleri, genellikle bir yöntemi olan, belirtilen bir program giriş noktası yöntemiyle birleştirirseniz de bir hatadır `Main` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-225">It's also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="f18f2-226">Bir anlamda, bir dosyanın normalde bir sınıf yönteminde olacak deyimleri içerdiğini düşünebilirsiniz `Main` `Program` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-226">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="f18f2-227">Bu özellik için en yaygın kullanımdan biri eğitim malzemeleri oluşturuyor.</span><span class="sxs-lookup"><span data-stu-id="f18f2-227">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="f18f2-228">Başlangıç C# geliştiricileri kurallı "Merhaba Dünya!" yazabilir</span><span class="sxs-lookup"><span data-stu-id="f18f2-228">Beginner C# developers can write the canonical "Hello World!"</span></span> <span data-ttu-id="f18f2-229">kodda bir veya iki satırda.</span><span class="sxs-lookup"><span data-stu-id="f18f2-229">in one or two lines of code.</span></span> <span data-ttu-id="f18f2-230">Ek sertifika gerekmez.</span><span class="sxs-lookup"><span data-stu-id="f18f2-230">None of the extra ceremony is needed.</span></span> <span data-ttu-id="f18f2-231">Bununla birlikte, deneyimli geliştiriciler bu özellik için birçok kullanım de bulacaktır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-231">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="f18f2-232">En üst düzey deyimler, Jupneter Not defterlerinin sağladığı deneme için bir komut dosyası benzeri deneyim sağlar.</span><span class="sxs-lookup"><span data-stu-id="f18f2-232">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="f18f2-233">En üst düzey deyimler, küçük konsol programları ve yardımcı programlar için harika.</span><span class="sxs-lookup"><span data-stu-id="f18f2-233">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="f18f2-234">[Azure işlevleri](/azure/azure-functions/) , en üst düzey deyimler için ideal bir kullanım durumdur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-234">[Azure Functions](/azure/azure-functions/) is an ideal use case for top-level statements.</span></span>

<span data-ttu-id="f18f2-235">En önemlisi, üst düzey deyimler uygulamanızın kapsamını veya karmaşıklığını sınırlamaz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-235">Most importantly, top-level statements don't limit your application's scope or complexity.</span></span> <span data-ttu-id="f18f2-236">Bu deyimler, herhangi bir .NET sınıfına erişebilir veya kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-236">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="f18f2-237">Ayrıca, komut satırı bağımsız değişkenlerinin veya dönüş değerlerinin kullanımını sınırlamaz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-237">They also don't limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="f18f2-238">Üst düzey deyimler, adlı bir dizeler dizisine erişebilir `args` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-238">Top-level statements can access an array of strings named `args`.</span></span> <span data-ttu-id="f18f2-239">En üst düzey deyimler bir tamsayı değeri döndürirse, bu değer sentezlenmiş bir yöntemden tamsayı dönüş kodu olur `Main` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-239">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="f18f2-240">En üst düzey deyimler zaman uyumsuz ifadeler içerebilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-240">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="f18f2-241">Bu durumda, birleştirilmiş giriş noktası bir `Task` veya döndürür `Task<int>` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-241">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

<span data-ttu-id="f18f2-242">Daha fazla bilgi için C# programlama kılavuzundaki [en üst düzey deyimler](../programming-guide/main-and-command-args/top-level-statements.md) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="f18f2-242">For more information, see [Top-level statements](../programming-guide/main-and-command-args/top-level-statements.md) in the C# Programming Guide.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="f18f2-243">Desen eşleştirme geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="f18f2-243">Pattern matching enhancements</span></span>

<span data-ttu-id="f18f2-244">C# 9, yeni bir model eşleşme geliştirmeleri içerir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-244">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="f18f2-245">***Tür desenleri*** bir değişkenle eşleşiyor tür</span><span class="sxs-lookup"><span data-stu-id="f18f2-245">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="f18f2-246">***Parantez Içine alınmış desenler*** , desen birleşimlerinin önceliğini uygular veya vurgular</span><span class="sxs-lookup"><span data-stu-id="f18f2-246">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="f18f2-247">***Ayırt edici `and` desenler*** , her iki desen de eşleşmesini gerektirir</span><span class="sxs-lookup"><span data-stu-id="f18f2-247">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="f18f2-248">Ayırt edici ***`or` desenler*** eşleşmesi gereken her iki model</span><span class="sxs-lookup"><span data-stu-id="f18f2-248">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="f18f2-249">***Değillenmiş `not` desenler*** bir düzenin eşleşmemesi gerekir</span><span class="sxs-lookup"><span data-stu-id="f18f2-249">***Negated `not` patterns*** require that a pattern doesn't match</span></span>
- <span data-ttu-id="f18f2-250">***İlişkisel desenler*** , girişin küçüktür, büyüktür, küçüktür veya eşittir veya belirtilen bir sabitten büyük veya eşit olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-250">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="f18f2-251">Bu desenler, desenlerin sözdizimini zenginleştirin.</span><span class="sxs-lookup"><span data-stu-id="f18f2-251">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="f18f2-252">Aşağıdaki örnekleri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f18f2-252">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="f18f2-253">Daha yüksek önceliğe sahip olması için isteğe bağlı parantezle `and` `or` :</span><span class="sxs-lookup"><span data-stu-id="f18f2-253">With optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="f18f2-254">En yaygın kullanımdan biri null denetimi için yeni bir sözdizimidir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-254">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="f18f2-255">Bu desenlerden herhangi biri desenleri izin verilen herhangi bir bağlamda kullanılabilir: `is` desen ifadeleri, `switch` ifadeler, iç içe desenler ve bir `switch` deyimin `case` etiketinin deseni.</span><span class="sxs-lookup"><span data-stu-id="f18f2-255">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement's `case` label.</span></span>

<span data-ttu-id="f18f2-256">Daha fazla bilgi için bkz. [desenler (C# Başvurusu)](../language-reference/operators/patterns.md).</span><span class="sxs-lookup"><span data-stu-id="f18f2-256">For more information, see [Patterns (C# reference)](../language-reference/operators/patterns.md).</span></span>

<span data-ttu-id="f18f2-257">Daha fazla bilgi için, [desenler](../language-reference/operators/patterns.md) makalesinin [Ilişkisel desenleri](../language-reference/operators/patterns.md#relational-patterns) ve [mantıksal desenler](../language-reference/operators/patterns.md#logical-patterns) bölümlerine bakın.</span><span class="sxs-lookup"><span data-stu-id="f18f2-257">For more information, see the [Relational patterns](../language-reference/operators/patterns.md#relational-patterns) and [Logical patterns](../language-reference/operators/patterns.md#logical-patterns) sections of the [Patterns](../language-reference/operators/patterns.md) article.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="f18f2-258">Performans ve birlikte çalışma</span><span class="sxs-lookup"><span data-stu-id="f18f2-258">Performance and interop</span></span>

<span data-ttu-id="f18f2-259">Üç yeni özellik, yüksek performans gerektiren yerel birlikte çalışma ve alt düzey kitaplıklar desteğini geliştirir: yerel boyutlu tamsayılar, işlev işaretçileri ve `localsinit` bayrağı atlama.</span><span class="sxs-lookup"><span data-stu-id="f18f2-259">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="f18f2-260">Yerel boyutlu tamsayılar `nint` ve `nuint` , tamsayı türleridir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-260">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="f18f2-261">Bunlar, temel alınan türler ve ile ifade edilir <xref:System.IntPtr?displayProperty=nameWithType> <xref:System.UIntPtr?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="f18f2-261">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="f18f2-262">Derleyici, bu türler için ek dönüştürmeler ve işlemleri yerel olarak gösterir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-262">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="f18f2-263">Yerel boyutlu tamsayılar veya özelliklerini tanımlar `MaxValue` `MinValue` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-263">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="f18f2-264">Bu değerler, Hedef makinedeki bir tamsayının yerel boyutuna bağlı olduğundan, derleme zamanı sabitleri olarak ifade edilemez.</span><span class="sxs-lookup"><span data-stu-id="f18f2-264">These values can't be expressed as compile-time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="f18f2-265">Çalışma zamanında bu değerler salt okunur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-265">Those values are readonly at runtime.</span></span> <span data-ttu-id="f18f2-266">`nint`[.. Aralığında için sabit değerler kullanabilirsiniz. `int.MinValue`</span><span class="sxs-lookup"><span data-stu-id="f18f2-266">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="f18f2-267">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="f18f2-267">`int.MaxValue`].</span></span> <span data-ttu-id="f18f2-268">`nuint`[.. Aralığında için sabit değerler kullanabilirsiniz. `uint.MinValue`</span><span class="sxs-lookup"><span data-stu-id="f18f2-268">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="f18f2-269">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="f18f2-269">`uint.MaxValue`].</span></span> <span data-ttu-id="f18f2-270">Derleyici ve türlerini kullanarak tüm birli ve ikili işleçler için sabit katlama gerçekleştirir <xref:System.Int32?displayProperty=nameWithType> <xref:System.UInt32?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="f18f2-270">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="f18f2-271">Sonuç 32 bite sığmazsa, işlem çalışma zamanında yürütülür ve bir sabit kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="f18f2-271">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="f18f2-272">Yerel boyutlu tamsayılar, tamsayı matematiğinin yaygın olarak kullanıldığı ve en yüksek performansa sahip olması gereken senaryolarda performansı artırabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-272">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span> <span data-ttu-id="f18f2-273">Daha fazla bilgi için bkz. [ `nint` ve `nuint` türleri](../language-reference/builtin-types/nint-nuint.md)</span><span class="sxs-lookup"><span data-stu-id="f18f2-273">For more information, see [`nint` and `nuint` types](../language-reference/builtin-types/nint-nuint.md)</span></span>

<span data-ttu-id="f18f2-274">İşlev işaretçileri, Il işlem kodları ve ' a erişmek için kolay bir sözdizimi sağlar `ldftn` `calli` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-274">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="f18f2-275">Yeni sözdizimini kullanarak işlev işaretçileri bildirebilirsiniz `delegate*` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-275">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="f18f2-276">`delegate*`Tür bir işaretçi türüdür.</span><span class="sxs-lookup"><span data-stu-id="f18f2-276">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="f18f2-277">Yöntemi, `delegate*` yöntemini kullanan `calli` bir temsilcinin aksine, türünü çağırır `callvirt` `Invoke()` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-277">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="f18f2-278">Sözdizimi, çağırma aynıdır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-278">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="f18f2-279">İşlev işaretçisi çağrısı, `managed` çağırma kuralını kullanır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-279">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="f18f2-280">`unmanaged` `delegate*` Çağırma kuralına istediğinizi bildirmek için sözdiziminden sonra anahtar sözcüğünü eklersiniz `unmanaged` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-280">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="f18f2-281">Diğer çağırma kuralları, bildirimde öznitelikler kullanılarak belirtilebilir `delegate*` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-281">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span> <span data-ttu-id="f18f2-282">Daha fazla bilgi için bkz. [güvenli olmayan kod ve işaretçi türleri](../language-reference/unsafe-code.md).</span><span class="sxs-lookup"><span data-stu-id="f18f2-282">For more information, see [Unsafe code and pointer types](../language-reference/unsafe-code.md).</span></span>

<span data-ttu-id="f18f2-283">Son olarak, <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> derleyicinin bayrağı yaymamasını sağlamak için öğesini ekleyebilirsiniz `localsinit` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-283">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="f18f2-284">Bu bayrak, CLR 'ye tüm yerel değişkenleri sıfıra başlatmasını söyler.</span><span class="sxs-lookup"><span data-stu-id="f18f2-284">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="f18f2-285">`localsinit`Bayrak, 1,0 sonrasındaki C# için varsayılan davranıştır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-285">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="f18f2-286">Ancak, ek sıfır başlatma bazı senaryolarda ölçülebilir performans etkisine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-286">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="f18f2-287">Özellikle, kullandığınızda `stackalloc` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-287">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="f18f2-288">Bu gibi durumlarda, ekleyebilirsiniz <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> .</span><span class="sxs-lookup"><span data-stu-id="f18f2-288">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="f18f2-289">Tek bir yönteme veya özelliğe veya bir `class` ,, `struct` `interface` veya hatta bir modüle ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-289">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="f18f2-290">Bu öznitelik yöntemleri etkilemez `abstract` ; uygulama için oluşturulan kodu etkiler.</span><span class="sxs-lookup"><span data-stu-id="f18f2-290">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span> <span data-ttu-id="f18f2-291">Daha fazla bilgi için bkz. [ `SkipLocalsInit` özniteliği](../language-reference/attributes/general.md#skiplocalsinit-attribute).</span><span class="sxs-lookup"><span data-stu-id="f18f2-291">For more information, see [`SkipLocalsInit` attribute](../language-reference/attributes/general.md#skiplocalsinit-attribute).</span></span>

<span data-ttu-id="f18f2-292">Bu özellikler, bazı senaryolarda performansı iyileştirebilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-292">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="f18f2-293">Bunlar yalnızca, benimseme öncesinde ve sonrasında eklendikten sonra kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-293">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="f18f2-294">Yerel boyutlu tamsayılar içeren kodun, farklı tamsayı boyutlarına sahip birden çok hedef platformda test olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-294">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="f18f2-295">Diğer özellikler güvenli olmayan kod gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-295">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="f18f2-296">Sığdırma ve son özellikler</span><span class="sxs-lookup"><span data-stu-id="f18f2-296">Fit and finish features</span></span>

<span data-ttu-id="f18f2-297">Diğer özelliklerin çoğu, daha verimli bir şekilde kod yazmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-297">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="f18f2-298">C# 9,0 ' de, oluşturulan nesnenin türü zaten biliniyorsa bir [ `new` ifadede](../language-reference/operators/new-operator.md) türü atlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-298">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="f18f2-299">En yaygın kullanım, alan bildirimlerinde bulunur:</span><span class="sxs-lookup"><span data-stu-id="f18f2-299">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="f18f2-300">`new`Bir yönteme bağımsız değişken olarak geçirmek için yeni bir nesne oluşturmanız gerektiğinde, target türü de kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-300">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="f18f2-301">`ForecastFor()`Aşağıdaki imzaya sahip bir yöntem düşünün:</span><span class="sxs-lookup"><span data-stu-id="f18f2-301">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="f18f2-302">Bunu şu şekilde çağırabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="f18f2-302">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="f18f2-303">Bu özellik için bir diğer iyi kullanım, yeni bir nesneyi başlatmak için yalnızca init özellikleriyle birlikte birleştirilmenize yöneliktir:</span><span class="sxs-lookup"><span data-stu-id="f18f2-303">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="f18f2-304">Bir ifadesini kullanarak varsayılan Oluşturucu tarafından oluşturulan bir örnek döndürebilirsiniz `return new();` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-304">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="f18f2-305">Benzer bir özellik, [koşullu ifadelerin](../language-reference/operators/conditional-operator.md)hedef tür çözümlemesini geliştirir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-305">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="f18f2-306">Bu değişiklik ile, iki ifadenin bir öğesinden diğerine örtük dönüştürmesi gerekmez, ancak her ikisi de hedef tür için örtük Dönüştürmelere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-306">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="f18f2-307">Büyük olasılıkla bu değişikliği fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-307">You likely won't notice this change.</span></span> <span data-ttu-id="f18f2-308">Ne fark edeceksiniz, daha önce gerekli olan veya derlenmeyen bazı Koşullu ifadeler artık çalışır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-308">What you will notice is that some conditional expressions that previously required casts or wouldn't compile now just work.</span></span>

<span data-ttu-id="f18f2-309">C# 9,0 ' den başlayarak `static` [lambda ifadelerine](../language-reference/operators/lambda-expressions.md) veya [anonim yöntemlere](../language-reference/operators/delegate-operator.md)değiştiricisini ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-309">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="f18f2-310">Statik lambda ifadeleri `static` Yerel işlevlere benzerdir: statik lambda veya anonim yöntem yerel değişkenleri veya örnek durumunu yakalayabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-310">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="f18f2-311">`static`Değiştirici yanlışlıkla diğer değişkenleri yakalamaya engel olur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-311">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="f18f2-312">Covaryant dönüş türleri, [geçersiz kılma](../language-reference/keywords/override.md) yöntemlerinin dönüş türleri için esneklik sağlar.</span><span class="sxs-lookup"><span data-stu-id="f18f2-312">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="f18f2-313">Geçersiz kılma yöntemi, geçersiz kılınan temel yöntemin dönüş türünden türetilmiş bir tür döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-313">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="f18f2-314">Bu, kayıtlar ve sanal kopya ya da fabrika yöntemlerini destekleyen diğer türler için yararlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-314">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="f18f2-315">Buna ek olarak, [ `foreach` döngü](../language-reference/keywords/foreach-in.md) , başka bir şekilde onu karşılayan bir genişletme yöntemi tanır ve kullanır `GetEnumerator` `foreach` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-315">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="f18f2-316">Bu değişiklik, `foreach` zaman uyumsuz model ve model tabanlı ayrıştırma gibi diğer model tabanlı kurulumlarını ile tutarlıdır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-316">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="f18f2-317">Uygulamada, bu değişiklik `foreach` herhangi bir türe destek ekleyebileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-317">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="f18f2-318">Bir nesne Numaralandırırken tasarımınızda anlamlı hale geldiğinde kullanımını sınırlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-318">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="f18f2-319">Sonra, Lambda ifadelerinde parametre olarak atar ' i kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-319">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="f18f2-320">Bu kolaylık, bağımsız değişkeni adlandırmayı önlemenize olanak sağlar ve derleyici bunu kullanmaktan kaçınabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-320">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="f18f2-321">`_`Herhangi bir bağımsız değişken için öğesini kullanırsınız.</span><span class="sxs-lookup"><span data-stu-id="f18f2-321">You use the `_` for any argument.</span></span> <span data-ttu-id="f18f2-322">Daha fazla bilgi için [lambda ifadeleri](../language-reference/operators/lambda-expressions.md) makalesinin [lambda ifadesinin giriş parametreleri](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="f18f2-322">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="f18f2-323">Son olarak, artık [Yerel işlevlere](../programming-guide/classes-and-structs/local-functions.md)öznitelikler uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-323">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="f18f2-324">Örneğin, yerel işlevlere [null yapılabilir öznitelik ek açıklamaları](../language-reference/attributes/nullable-analysis.md) uygulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-324">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="f18f2-325">Kod oluşturucuları için destek</span><span class="sxs-lookup"><span data-stu-id="f18f2-325">Support for code generators</span></span>

<span data-ttu-id="f18f2-326">İki son özellik C# kod üreteçleri destekler.</span><span class="sxs-lookup"><span data-stu-id="f18f2-326">Two final features support C# code generators.</span></span> <span data-ttu-id="f18f2-327">C# kod oluşturucuları, bir Roslyn çözümleyicisine veya kod düzeltmesine benzer şekilde yazabileceğiniz bir bileşendir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-327">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="f18f2-328">Fark, kod oluşturucuların kodu çözümlemelerine ve derleme sürecinin bir parçası olarak yeni kaynak kodu dosyaları yazmanızdır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-328">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="f18f2-329">Tipik bir kod üreticisi öznitelikleri veya diğer kuralları arar.</span><span class="sxs-lookup"><span data-stu-id="f18f2-329">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="f18f2-330">Kod Oluşturucu, Roslyn Analysis API 'Lerini kullanarak öznitelikleri veya diğer kod öğelerini okur.</span><span class="sxs-lookup"><span data-stu-id="f18f2-330">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="f18f2-331">Bu bilgilerden, derlemeye yeni kod ekler.</span><span class="sxs-lookup"><span data-stu-id="f18f2-331">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="f18f2-332">Kaynak oluşturucuları yalnızca kod ekleyebilir; Bu kişiler, derlemede var olan herhangi bir kodu değiştirmesine izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="f18f2-332">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="f18f2-333">Kod üreticileri için eklenen iki özellik, \***kısmi Yöntem sözdizimi** _ ve _ *_Modül başlatıcıları_* \* için uzantılardır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-333">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*\*.</span></span> <span data-ttu-id="f18f2-334">Birincisi, kısmi metotlarda yapılan değişiklikler.</span><span class="sxs-lookup"><span data-stu-id="f18f2-334">First, the changes to partial methods.</span></span> <span data-ttu-id="f18f2-335">C# 9,0 öncesi, kısmi Yöntemler, bir `private` erişim değiştiricisi `void` belirtmemelidir, geri dönemeyebilir ve parametrelere sahip olamaz `out` .</span><span class="sxs-lookup"><span data-stu-id="f18f2-335">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="f18f2-336">Bu kısıtlamalar, hiçbir yöntem uygulama sağlanmazsa, derleyicinin kısmi yönteme yapılan tüm çağrıları kaldırmasının anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-336">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="f18f2-337">C# 9,0 bu kısıtlamaları ortadan kaldırır, ancak kısmi Yöntem bildirimlerinin bir uygulamaya sahip olmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-337">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="f18f2-338">Kod oluşturucuları, bu uygulamayı sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-338">Code generators can provide that implementation.</span></span> <span data-ttu-id="f18f2-339">Yeni bir değişiklik yapmaktan kaçınmak için, derleyici eski kuralları takip etmek üzere bir erişim değiştiricisi olmadan herhangi bir kısmi yöntemi dikkate alır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-339">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="f18f2-340">Kısmi Yöntem `private` erişim değiştiricisini içeriyorsa, yeni kurallar bu kısmi yöntemi yönetir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-340">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span> <span data-ttu-id="f18f2-341">Daha fazla bilgi için bkz. [kısmi Yöntem (C# Başvurusu)](../language-reference/keywords/partial-method.md).</span><span class="sxs-lookup"><span data-stu-id="f18f2-341">For more information, see [partial method (C# Reference)](../language-reference/keywords/partial-method.md).</span></span>

<span data-ttu-id="f18f2-342">Kod üreticileri için ikinci yeni özellik ***Modül başlatıcılarına*** yöneliktir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-342">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="f18f2-343">Modül başlatıcıları, <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> kendisine eklenmiş özniteliği olan yöntemlerdir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-343">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="f18f2-344">Bu yöntemler, tüm modülün içindeki başka bir alan erişimi veya yöntem çağrısından önce çalışma zamanı tarafından çağırılır.</span><span class="sxs-lookup"><span data-stu-id="f18f2-344">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="f18f2-345">Modül başlatıcısı yöntemi:</span><span class="sxs-lookup"><span data-stu-id="f18f2-345">A module initializer method:</span></span>

- <span data-ttu-id="f18f2-346">Statik olmalıdır</span><span class="sxs-lookup"><span data-stu-id="f18f2-346">Must be static</span></span>
- <span data-ttu-id="f18f2-347">Parametresiz olmalıdır</span><span class="sxs-lookup"><span data-stu-id="f18f2-347">Must be parameterless</span></span>
- <span data-ttu-id="f18f2-348">Void döndürmelidir</span><span class="sxs-lookup"><span data-stu-id="f18f2-348">Must return void</span></span>
- <span data-ttu-id="f18f2-349">Genel bir yöntem olmamalıdır</span><span class="sxs-lookup"><span data-stu-id="f18f2-349">Must not be a generic method</span></span>
- <span data-ttu-id="f18f2-350">Genel bir sınıfta içerilmemelidir</span><span class="sxs-lookup"><span data-stu-id="f18f2-350">Must not be contained in a generic class</span></span>
- <span data-ttu-id="f18f2-351">Kapsayan modülden erişilebilir olmalıdır</span><span class="sxs-lookup"><span data-stu-id="f18f2-351">Must be accessible from the containing module</span></span>

<span data-ttu-id="f18f2-352">Bu son madde işareti noktası, yöntemin ve kapsayan sınıfın iç veya genel olması gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f18f2-352">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="f18f2-353">Yöntem yerel bir işlev olamaz.</span><span class="sxs-lookup"><span data-stu-id="f18f2-353">The method can't be a local function.</span></span> <span data-ttu-id="f18f2-354">Daha fazla bilgi için bkz. [ `ModuleInitializer` özniteliği](../language-reference/attributes/general.md#moduleinitializer-attribute).</span><span class="sxs-lookup"><span data-stu-id="f18f2-354">For more information, see [`ModuleInitializer` attribute](../language-reference/attributes/general.md#moduleinitializer-attribute).</span></span>
