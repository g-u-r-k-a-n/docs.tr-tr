---
title: WPF Uygulamalarını .NET Core 3.0'a geçirme
description: Bir Windows Presentation Foundation (WPF) uygulamasını .NET Core 3.0'a nasıl geçirteceklerini öğrenin.
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071313"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="c7e7f-103">WPF uygulamalarını .NET Core'a geçirme</span><span class="sxs-lookup"><span data-stu-id="c7e7f-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="c7e7f-104">Bu makale, bir Windows Presentation Foundation (WPF) uygulamasını .NET Framework'den .NET Core 3.0'a geçirmek için gereken adımları kapsar.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="c7e7f-105">Bağlantı noktasına elinizde bir WPF uygulamanız yoksa, ancak işlemi denemek istiyorsanız, [GitHub'da](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)bulunan **Bean Trader** örnek uygulamasını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="c7e7f-106">Orijinal uygulama (hedefleme .NET Framework 4.7.2) NetFx\BeanTraderClient klasöründe mevcuttur.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="c7e7f-107">Önce uygulamaları genel olarak taşımanız için gerekli adımları açıklayacağız ve ardından **Bean Trader** örneğine uygulanan belirli değişiklikleri gözden geçireceğiz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="c7e7f-108">.NET Core'a geçiş yapmak için önce şunları belirtmelisiniz:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="c7e7f-109">NuGet bağımlılıklarını anlayın ve güncelleyin:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="c7e7f-110">Biçimi kullanmak için NuGet `<PackageReference>` bağımlılıklarını yükseltin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="c7e7f-111">.NET Core veya .NET Standart uyumluluğu için üst düzey NuGet bağımlılıklarını gözden geçirin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="c7e7f-112">NuGet paketlerini yeni sürümlere yükseltin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="c7e7f-113">.NET bağımlılıklarını anlamak için [.NET Taşınabilirlik Çözümleyicisini](../../standard/analyzers/portability-analyzer.md) kullanın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="c7e7f-114">Proje dosyasını yeni SDK stili biçimine geçirin:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="c7e7f-115">Hem .NET Core hem de .NET Framework'u mi yoksa yalnızca .NET Core'u mu hedefleyeceğinizi seçin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="c7e7f-116">İlgili proje dosyası özelliklerini ve öğelerini yeni proje dosyasına kopyalayın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="c7e7f-117">Yapı sorunlarını giderin:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-117">Fix build issues:</span></span>

    01. <span data-ttu-id="c7e7f-118">[Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) paketine bir başvuru ekleyin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="c7e7f-119">API düzeyindeki farklılıkları bulun ve düzeltin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="c7e7f-120">*App.config* bölümlerini `appSettings` kaldırın `connectionStrings`veya .</span><span class="sxs-lookup"><span data-stu-id="c7e7f-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="c7e7f-121">Gerekirse oluşturulan kodu yeniden oluşturun.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="c7e7f-122">Çalışma zamanı testi:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-122">Runtime testing:</span></span>

    01. <span data-ttu-id="c7e7f-123">Taşınan uygulamanın beklendiği gibi çalıştığını doğrulayın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="c7e7f-124">İstisnalara dikkat edin. <xref:System.NotSupportedException></span><span class="sxs-lookup"><span data-stu-id="c7e7f-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="c7e7f-125">Örnek hakkında</span><span class="sxs-lookup"><span data-stu-id="c7e7f-125">About the sample</span></span>

<span data-ttu-id="c7e7f-126">Bu makalede, gerçek dünya WPF uygulamalarının sahip olabileceği ne benzer çeşitli bağımlılıklar kullandığından [Bean Trader örnek uygulamasına](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) başvurur.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="c7e7f-127">Uygulama büyük değildir, ancak karmaşıklık açısından 'Hello World' bir adım olması gerekiyordu.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="c7e7f-128">Uygulama, kullanıcıların gerçek uygulamaları taşıma sırasında karşılaşabilecekleri bazı sorunları gösteriyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="c7e7f-129">Uygulama bir WCF hizmeti ile iletişim kurar, bu nedenle düzgün çalışması için, ayrıca BeanTraderServer proje (aynı GitHub deposunda mevcuttur) çalıştırmak ve beanTraderClient yapılandırma doğru bitiş noktasına puan emin olmak gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="c7e7f-130">(Varsayılan olarak, örnek sunucu aynı makineüzerinde çalışıyor *http://localhost:8090*varsayar , yerel BeanTraderServer başlattığınızda doğru olacaktır.)</span><span class="sxs-lookup"><span data-stu-id="c7e7f-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="c7e7f-131">Bu örnek uygulamanın .NET Core taşıma zorluklarını ve çözümlerini göstermeyi amaçladığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="c7e7f-132">Bu WPF en iyi uygulamaları göstermek için değil.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="c7e7f-133">Aslında, kasıtlı olarak bazı anti-desenler ilerlerken en az birkaç ilginç zorlukla karşılaştığınızı emin olmak için.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="c7e7f-134">Hazırlanma</span><span class="sxs-lookup"><span data-stu-id="c7e7f-134">Getting ready</span></span>

<span data-ttu-id="c7e7f-135">Bir .NET Framework uygulamasını .NET Core'a geçirmenin temel zorluğu, bağımlılıklarının farklı veya hiç çalışmamasıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="c7e7f-136">Geçiş eskisinden çok daha kolaydır; birçok NuGet paketi artık .NET Standard'ı hedef alıyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="c7e7f-137">.NET Core 2.0 ile başlayarak ,NET Framework ve .NET Core yüzey alanları benzer hale gelmiştir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="c7e7f-138">Buna rağmen, bazı farklılıklar (nuget paketleri ve mevcut .NET API'ler hem destek) kalır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="c7e7f-139">Geçişteki ilk adım, uygulamanın bağımlılıklarını gözden geçirmek ve başvuruların .NET Core'a kolayca geçirilen bir biçimde olduğundan emin olmaktır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="c7e7f-140">NuGet `<PackageReference>` referanslarına yükseltme</span><span class="sxs-lookup"><span data-stu-id="c7e7f-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="c7e7f-141">Eski .NET Framework projeleri genellikle NuGet bağımlılıklarını bir *packages.config* dosyasında listeler.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="c7e7f-142">Yeni SDK tarzı proje dosya biçimi, [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) NuGet paketlerini ayrı bir config dosyasıyerine csproj dosyasındaki öğeler olarak başvurur.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="c7e7f-143">Geçiş yaparken, -stil başvuruları `<PackageReference>`kullanmanın iki avantajı vardır:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="c7e7f-144">Bu, yeni .NET Core proje dosyası için gerekli olan NuGet başvuru stilidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="c7e7f-145">Zaten kullanıyorsanız, `<PackageReference>`bu proje dosyası öğeleri kopyalanabilir ve doğrudan yeni projeye yapıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="c7e7f-146">Packages.config dosyasının `<PackageReference>` aksine, öğeler yalnızca projenizin doğrudan bağlı olduğu üst düzey bağımlılıkları ifade eder.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="c7e7f-147">Diğer tüm geçişli NuGet paketleri geri yükleme zamanında belirlenecek ve otomatik olarak üretilen obj\project.assets.json dosyasına kaydedilecektir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="c7e7f-148">Bu, projenizin hangi bağımlılıklara sahip olduğunu belirlemeyi çok daha kolay hale getirir ve bu da gerekli bağımlılıkların .NET Core'da çalışıp çalışmayacağını belirlerken yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="c7e7f-149">Bir .NET Framework uygulamasını .NET Core'a geçirmenin ilk `<PackageReference>` adımı NuGet başvurularını kullanmak üzere güncelleştirmektir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="c7e7f-150">Visual Studio bunu basitleştiriyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="c7e7f-151">Visual Studio'nun **Solution Explorer'ında**projenin *paketleri.config* dosyasına sağ tıklayın ve ardından **PackageReference'a geçir packages.config'i**seçin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![PackageReference'a yükseltme](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="c7e7f-153">Hesaplanan üst düzey NuGet bağımlılıklarını gösteren ve hangi diğer NuGet paketlerinin üst düzeye yükseltilmesi gerektiğini soran bir iletişim kutusu görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="c7e7f-154">Bu diğer paketlerin hiçbiri Bean Trader örnek için üst düzey olması gerekir, böylece tüm bu kutuların kontrolden çekebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="c7e7f-155">Daha sonra **Tamam'ı** tıklatın ve *packages.config* dosyası kaldırılır ve `<PackageReference>` öğeler proje dosyasına eklenir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="c7e7f-156">`<PackageReference>`-stil başvuruları NuGet paketlerini bir paket klasöründe yerel olarak saklamaz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="c7e7f-157">Bunun yerine, bir optimizasyon olarak küresel olarak saklanır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="c7e7f-158">Geçiş tamamlandıktan sonra, csproj dosyasını edin ve daha önce gelen çözümleyicilere atıfta bulunan öğeleri `<Analyzer>` *kaldırın. \paketleri* dizini.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="c7e7f-159">Merak etme; NuGet paket başvurularıhala sizde olduğundan, çözümleyiciler projeye dahil edilecektir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="c7e7f-160">Sadece eski paketleri temizlemen gerekiyor. `<Analyzer>`</span><span class="sxs-lookup"><span data-stu-id="c7e7f-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="c7e7f-161">NuGet paketlerini inceleyin</span><span class="sxs-lookup"><span data-stu-id="c7e7f-161">Review NuGet packages</span></span>

<span data-ttu-id="c7e7f-162">Artık projenin bağlı olduğu üst düzey NuGet paketlerini görebildiğinize göre, bu paketlerin .NET Core'da kullanılabilir olup olmadığını gözden geçirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="c7e7f-163">Bir paketin .NET Core'u destekleyip desteklemediğini [nuget.org](https://www.nuget.org/)bağımlılıklarına bakarak belirleyebilirsiniz. Topluluk tarafından oluşturulan [fuget.org](https://www.fuget.org/) sitesi, bu bilgileri paket bilgileri sayfasının en üstünde belirgin bir şekilde gösterir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="c7e7f-164">.NET Core 3.0 hedeflediğinde,.NET Core veya .NET Standard'ı hedefleyen paketler çalışmalıdır (.NET Core .NET Standart yüzey alanını uyguladığından).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="c7e7f-165">Bazı durumlarda, kullanılan bir paketin belirli sürümü .NET Core veya .NET Standard'ı hedeflemez, ancak yeni sürümler hedeflenecektir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="c7e7f-166">Bu durumda, paketin en son sürümüne yükseltmeyi düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="c7e7f-167">.NET Framework'u hedefleyen paketleri de kullanabilirsiniz, ancak bu bazı riskler sunar.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="c7e7f-168">.NET Core to .NET Framework bağımlılıklarına izin verilir, çünkü .NET Core ve .NET Framework yüzey alanları bu tür bağımlılıkların *genellikle* çalıştığı kadar benzerdir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="c7e7f-169">Ancak, paket .NET Core'da bulunmayan bir .NET API kullanmaya çalışırsa, çalışma zamanı özel bir durumla karşılaşırsınız.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="c7e7f-170">Bu nedenle, sadece .NET Framework paketlerine başka seçenek olmadığında başvurmalı ve bunu yapmanın bir test yükü yüklediğini anlamalısınız.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="c7e7f-171">.NET Core veya .NET Standard'ı hedeflememeyen başvurulan paketler varsa, diğer alternatifleri düşünmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="c7e7f-172">Bunun yerine kullanılabilecek başka benzer paketler var mı?</span><span class="sxs-lookup"><span data-stu-id="c7e7f-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="c7e7f-173">Bazen NuGet yazarları ayrı 'yayınlamak. Özellikle .NET Core hedefleyen kendi kütüphanelerinin Core sürümleri.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="c7e7f-174">Kurumsal Kütüphane paketleri topluluk yayıncılık bir örnektir ". NetCore" alternatifleri.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="c7e7f-175">Diğer durumlarda, .NET Standard için belirli bir hizmet için daha yeni SDK'lar (bazen farklı paket adlarıyla) kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="c7e7f-176">Herhangi bir alternatif yoksa, .NET Framework hedefli paketleri kullanarak ,NET Core'da çalışırken iyice test etmeniz gerektiğini göz önünde bulundurarak devam edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="c7e7f-177">Bean Trader örneği aşağıdaki üst düzey NuGet bağımlılıklarına sahiptir:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="c7e7f-178">**Castle.Windsor, sürüm 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="c7e7f-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="c7e7f-179">Bu paket .NET Standart 1.6'yı hedefler, bu nedenle .NET Core'da çalışır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="c7e7f-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, sürüm 2.6.3**</span><span class="sxs-lookup"><span data-stu-id="c7e7f-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="c7e7f-181">Bu bir meta paketidir, bu nedenle hangi platformları desteklediği hemen belli değildir, ancak [belgeler](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) en yeni sürümünün (2.9.2) hem .NET Framework hem de .NET Core için çalışacağını gösterir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="c7e7f-182">**Nito.AsyncEx, sürüm 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="c7e7f-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="c7e7f-183">Bu paket .NET Core'u hedeflemez, ancak yeni 5.0 sürümü hedeflemektedir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="c7e7f-184">Birçok NuGet paketi son zamanlarda .NET Standard desteği eklence, ancak eski proje sürümleri yalnızca .NET Framework'u hedeflediğiiçin, bu geçiş yaparken yaygındır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="c7e7f-185">Sürüm farkı yalnızca küçük bir sürüm farkıysa, yeni sürüme yükseltmek genellikle kolaydır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="c7e7f-186">Bu önemli bir sürüm değişikliği olduğundan, pakette değişiklikler kırılabileceğinden, dikkatli yükseltme niz gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="c7e7f-187">Ama ileriye giden bir yol var, ki bu iyi bir şey.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="c7e7f-188">**MahApps.Metro, sürüm 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="c7e7f-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="c7e7f-189">Bu paket aynı zamanda .NET Core'u da hedeflemez, ancak daha yeni bir ön sürüm (2.0-alfa) vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="c7e7f-190">Yine, değişiklikleri kırma için dikkat etmek zorunda, ama yeni paket cesaret verici.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="c7e7f-191">Bean Trader örneğinin NuGet bağımlılıkları ya .NET Standard/.NET Core'u hedef alır ya da yeni sürümleri vardır, bu nedenle burada herhangi bir engelleme sorunu olması olası değildir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="c7e7f-192">NuGet paketlerini yükseltin</span><span class="sxs-lookup"><span data-stu-id="c7e7f-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="c7e7f-193">Mümkünse, herhangi bir kırılma değişikliğini erken keşfetmek ve gidermek için bu noktada (proje hala .NET Framework'ü hedefleyen projeyle) yalnızca .NET Core veya .NET Standard'ı hedefleyen paketlerin sürümlerini yükseltmek iyi olacaktır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="c7e7f-194">Uygulamanın varolan .NET Framework sürümünde herhangi bir önemli değişiklik yapmak istemiyorsanız, bu işlem .NET Core'u hedefleyen yeni bir proje dosyanız olana kadar bekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="c7e7f-195">Ancak, NuGet paketlerini .NET Core uyumlu sürümlere önceden yükseltmek, yeni proje dosyasını oluşturduğunuzda geçiş işlemini daha da kolaylaştırır ve uygulamanın .NET Framework ve .NET Core sürümleri arasındaki fark sayısını azaltır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="c7e7f-196">Bean Trader örneği ile, gerekli tüm yükseltmeleri kolayca yapılabilir (Visual Studio's NuGet paket yöneticisi kullanılarak) bir istisna dışında: **MahApps.Metro 1.6.5** den **2.0** yükseltme tema ve aksan yönetimi API'ler ile ilgili kırılma değişiklikleri ortaya koymaktadır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="c7e7f-197">İdeal olarak, uygulama paketin yeni sürümünü kullanmak üzere güncellenir (bu daha fazla .NET Core üzerinde çalışmak olasıdır).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="c7e7f-198">Ancak bazı durumlarda bu mümkün olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="c7e7f-199">Bu gibi durumlarda, gerekli değişiklikler önemsiz olmadığından ve bu öğretici **MahApps.Metro 2'ye** değil ,.NET Core 3'e geçiş yapmaya odaklandığından **MahApps.Metro'yu** yükseltmeyin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="c7e7f-200">Ayrıca, bu düşük riskli .NET Framework bağımlılığı çünkü Bean Trader uygulaması sadece **MahApps.Metro**küçük bir kısmını egzersizleri.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="c7e7f-201">Tabii ki, geçiş tamamlandıktan sonra her şeyin çalıştığından emin olmak için test edilmesi gerekecek.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="c7e7f-202">Bu gerçek bir senaryo olsaydı, şimdi bazı teknik borç geride bırakır göç yapmadığıiçin **MahApps.Metro** sürümü 2.0 taşımak için iş izlemek için bir sorun dosya iyi olurdu.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="c7e7f-203">NuGet paketleri son sürümlere güncelleştirildikten sonra, Bean Trader örneğinin proje dosyasındaki `<PackageReference>` madde grubu bu şekilde görünmelidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="c7e7f-204">.NET Çerçeve taşınabilirlik analizi</span><span class="sxs-lookup"><span data-stu-id="c7e7f-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="c7e7f-205">Projenizin NuGet bağımlılıklarının durumunu anladığınızda, göz önünde bulundurulması gereken bir sonraki şey .NET Framework API bağımlılıklarıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="c7e7f-206">[.NET Taşınabilirlik Çözümleyicisi](../../standard/analyzers/portability-analyzer.md) aracı, projenizin hangi .NET API'lerinin diğer .NET platformlarında kullanılabildiği konusunda yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="c7e7f-207">Araç bir [Visual Studio eklentisi](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer)olarak geliyor , bir [komut satırı aracı](https://github.com/Microsoft/dotnet-apiport/releases), ya da basit bir [GUI](https://github.com/Microsoft/dotnet-apiport-ui)sarılmış , hangi seçeneklerini kolaylaştırır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="c7e7f-208">Porting masaüstü uygulamalarındaki GUI'yi kullanarak .NET Taşınabilirlik Çözümleyicisini (API Bağlantı Noktası) kullanarak [.NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog gönderisine ilişkin daha fazla bilgi edinebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="c7e7f-209">Komut satırını kullanmayı tercih ederseniz, gerekli adımlar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="c7e7f-210">Zaten yoksa [.NET Taşınabilirlik Çözümleyicisini](https://github.com/Microsoft/dotnet-apiport/releases) indirin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="c7e7f-211">Taşınabilir .NET Framework uygulamasının başarıyla oluşturduğundan emin olun (bu, geçişten önce iyi bir fikirdir).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="c7e7f-212">API Bağlantı Noktasını böyle bir komut satırıyla çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="c7e7f-213">Bağımsız `-f` değişken, çözümlemek için ikilileri içeren yolu belirtir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="c7e7f-214">Bağımsız `-r` değişken, istediğiniz çıktı dosya biçimini belirtir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="c7e7f-215">Bağımsız `-t` değişken, API kullanımını analiz etmek için hangi .NET platformuna karşı olduğunu belirtir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="c7e7f-216">Bu durumda, .NET Core'u istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="c7e7f-217">HTML raporunu açtığınızda, ilk bölümde analiz edilen tüm ikililer ve kullandıkları .NET API'lerinin yüzde kaçının hedeflenen platformda kullanılabilir olduğu listelenir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="c7e7f-218">Yüzde tek başına anlamlı değildir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="c7e7f-219">Daha yararlı olan, eksik olan belirli API'leri görmektir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="c7e7f-220">Bunu yapmak için, bir derleme adı seçin veya tek tek derlemeler için raporlara gidin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="c7e7f-221">Kaynak kodun sahibi olduğunuz derlemelere odaklanın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="c7e7f-222">Bean Trader ApiPort raporunda, örneğin, listelenen birçok ikili vardır, ancak bunların çoğu NuGet paketleriaittir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="c7e7f-223">`Castle.Windsor`.NET Core'da eksik olan bazı System.Web API'lerine bağlı olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="c7e7f-224">Bu bir sorun değildir, çünkü daha `Castle.Windsor` önce .NET Core'u destekleyen leri doğruladığınız için.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="c7e7f-225">NuGet paketlerinin farklı .NET platformlarında kullanılmak üzere farklı ikili lere sahip olması `Castle.Windsor` yaygındır, bu nedenle System.Web API'lerinin .NET Framework sürümünün .NET Standard veya .NET Core'u da hedeflediği sürece .NET Standard veya .NET Core'u (ki öyle) kullanması önemsizdir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="c7e7f-226">Bean Trader örnek ile, dikkate almanız gereken tek ikili **BeanTraderClient** ve rapor sadece iki .NET API eksik olduğunu gösterir: `System.ServiceModel.ClientBase<T>.Close` ve `System.ServiceModel.ClientBase<T>.Open`.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![BeanTraderClient taşınabilirlik raporu](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="c7e7f-228">WCF İstemci API'leri (çoğunlukla) .NET Core'da desteklendirildik, bu nedenle bu merkezi API'ler için alternatifler olması gerektiğinden, bu sorunların engellenmesi olası değildir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="c7e7f-229">`System.ServiceModel`Aslında,'ın .NET Core yüzey alanına <https://apisof.net>(kullanarak) baktığınızda,.NET Core'da async alternatifleri olduğunu görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="c7e7f-230">Bu rapor ve önceki NuGet bağımlılık analizine dayanarak, Bean Trader örneğini .NET Core'a geçiren önemli bir sorun olmaması gerekir gibi görünüyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="c7e7f-231">Göçü başlatacağınız bir sonraki adımiçin hazırsınız.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="c7e7f-232">Proje dosyasını geçirme</span><span class="sxs-lookup"><span data-stu-id="c7e7f-232">Migrating the project file</span></span>

<span data-ttu-id="c7e7f-233">Uygulamanız yeni [SDK tarzı proje dosya biçimini](../../core/tools/csproj.md)kullanmıyorsa, .NET Core'u hedeflemek için yeni bir proje dosyasına ihtiyacınız vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="c7e7f-234">Varolan csproj dosyasını değiştirebilir veya varolan projeyi geçerli durumunda el değmemiş olarak tutmayı tercih ederseniz, .NET Core'u hedefleyen yeni bir csproj dosyası ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="c7e7f-235">Uygulamanın .NET Framework ve .NET Core sürümlerini, [çok hedeflemeli](../../standard/library-guidance/cross-platform-targeting.md) tek bir SDK tarzı `<TargetFrameworks>` proje dosyasıyla (birden çok hedef belirterek) oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="c7e7f-236">Yeni proje dosyasını oluşturmak için Visual Studio'da yeni bir `dotnet new wpf` WPF projesi oluşturabilir veya proje dosyasını oluşturmak ve sonra doğru konuma kopyalamak/yeniden adlandırmak için komutu geçici bir dizinde kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="c7e7f-237">Ayrıca topluluk tarafından oluşturulan bir araç, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), bazı proje dosyası geçiş otomatikleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="c7e7f-238">Araç yararlıdır, ancak yine de geçişin tüm ayrıntılarının doğru olduğundan emin olmak için sonuçları gözden geçirmek için bir insana ihtiyaç duyar.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="c7e7f-239">Aracın en iyi şekilde işlemediği belirli bir alan, NuGet paketlerini *packages.config* dosyalarından geçirmektir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="c7e7f-240">Araç, NuGet paketlerine başvurmak için hala bir *packages.config* dosyası kullanan bir `<PackageReference>` proje dosyasında çalışıyorsa, otomatik olarak öğelere geçiş yapacaktır, ancak yalnızca üst düzey paketler yerine `<PackageReference>` *tüm* paketler için öğeler ekler.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="c7e7f-241">Visual Studio ile öğelere`<PackageReference>` zaten geçiş yaptıysanız (bu örnekte yaptığınız gibi), araç dönüşümün geri kalanında yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="c7e7f-242">Scott Hanselman [csproj dosyaları göç yaptığı blog yazısı](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx)önerir gibi, elle taşıma eğitim ve sadece limana birkaç proje varsa daha iyi sonuçlar verecektir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="c7e7f-243">Ancak düzinelerce veya yüzlerce proje dosyası taşımanız durumunda, [CsprojToVs2017] gibi bir araç yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="c7e7f-244">Bean Trader örneği için yeni bir proje `dotnet new wpf` dosyası oluşturmak için, geçici bir dizinde çalıştırın ve oluşturulan *.csproj* dosyasını *BeanTraderClient* klasörüne taşıyın ve **beanTraderClient.Core.csproj**adını yeniden adlandırın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="c7e7f-245">Yeni proje dosyası biçimi otomatik olarak C# dosyalarını, *resx* dosyalarını ve dizininin altında bulduğu XAML dosyalarını içerdiğinden, proje dosyası zaten neredeyse tamamlandı!</span><span class="sxs-lookup"><span data-stu-id="c7e7f-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="c7e7f-246">Geçişi tamamlamak için, eski ve yeni proje dosyalarını yan yana açın ve içerdiği herhangi bir bilginin geçirilip geçirilmeihtiyacı olup olmadığını görmek için eskidosyaya bakın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="c7e7f-247">Bean Trader örnek durumda, aşağıdaki öğeler yeni projeye kopyalanmalıdır:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="c7e7f-248">, `<RootNamespace>` `<AssemblyName>`ve `<ApplicationIcon>` özellikleritüm kopyalanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="c7e7f-249">Bean Trader örneği `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` AssemblyInfo.cs bir dosyadaki montaj düzeyinde öznitelikleri (beğen) `[AssemblyTitle]`içerdiğinden, yeni proje dosyasına bir özellik eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="c7e7f-250">Varsayılan olarak, yeni SDK tarzı projeler bu öznitelikleri csproj dosyasındaki özelliklere göre otomatik olarak oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="c7e7f-251">Bu durumda bunun olmasını istemediğiniz için (otomatik oluşturulan öznitelikler AssemblyInfo.cs gelenlerle çakışacak), otomatik `<GenerateAssemblyInfo>`olarak oluşturulan öznitelikleri .</span><span class="sxs-lookup"><span data-stu-id="c7e7f-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="c7e7f-252">*resx* dosyaları otomatik olarak katıştırılmış `<Resource>` kaynaklar olarak dahil edilebilse de, görüntüler gibi diğer öğeler dahil edilmez.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="c7e7f-253">Bu nedenle, `<Resource>` görüntü ve simge dosyalarını katıştırma öğelerini kopyalayın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="c7e7f-254">Globbing desenleri için yeni proje dosya biçiminin desteğini kullanarak tek bir satıra png başvurularını basitleştirebilirsiniz: `<Resource Include="**\*.png" />`.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="c7e7f-255">Benzer şekilde, `<None>` öğeler otomatik olarak dahil edilir, ancak varsayılan olarak çıktı dizinine kopyalanmıyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="c7e7f-256">Bean Trader projesi çıktı `<None>` dizinine *kopyalanan* bir öğe içerdiğinden (davranışları kullanarak), `PreserveNewest` bu dosya `<None>` için otomatik olarak doldurulan öğeyi güncelleştirmeniz gerekir, bu gibi.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="c7e7f-257">Bean Trader örneği, bu dosyada tanımlanan temalar ve aksanlar uygulamanın `Page`kendisine gömülmek yerine dosyanın XAML'sinden yüklendiğinden, bir XAML dosyası (Default.Accent.xaml) `Content` (yerine) içerir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="c7e7f-258">Yeni proje sistemi otomatik olarak bir `<Page>`XAML dosyası olduğundan, bir , ancak bu dosyayı içerir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="c7e7f-259">Bu nedenle, XAML dosyasını hem sayfa`<Page Remove="**\Default.Accent.xaml" />`olarak kaldırmanız hem de içerik olarak eklemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="c7e7f-260">Son olarak, tüm öğeleri `<ItemGroup>` ile kopyalayarak `<PackageReference>` NuGet referansları ekleyin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="c7e7f-261">NuGet paketlerini daha önce .NET Core uyumlu sürümlere yükseltmemiş olsaydınız, paket başvuruları .NET Core'a özgü bir projede olduğu için bunu şimdi yapabilirdiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="c7e7f-262">Bu noktada, BeanTrader çözümüne yeni proje eklemek ve Visual Studio açmak mümkün olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="c7e7f-263">Proje **Solution Explorer'da**doğru `dotnet restore BeanTraderClient.Core.csproj` görünmeli ve paketleri başarıyla geri yüklemeli (.NET Framework'ü hedeflemek için kullandığınız MahApps.Metro sürümüyle ilgili iki beklenen uyarıyla).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="c7e7f-264">Her iki proje dosyasını yan yana tutmak mümkün olsa da (ve eski projeyi tam olarak oluşturmaya devam etmek istiyorsanız bile istenebilir), geçiş işlemini karmaşıklaştırır (iki proje aynı bin ve obj klasörlerini kullanmaya çalışır) ve genellikle gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="c7e7f-265">Hem .NET Core hem de .NET Framework hedefleri için `<TargetFramework>netcoreapp3.0</TargetFramework>` oluşturmak istiyorsanız, yeni `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` proje dosyasındaki özelliği yerine değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="c7e7f-266">Bean Trader örnek için, artık gerekli olduğundan eski proje dosyası (BeanTraderClient.csproj) silin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="c7e7f-267">Her iki proje dosyasını da saklamayı tercih ederseniz, farklı çıktı ve ara çıktı yollarına oluşturmalarını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="c7e7f-268">Yapı sorunlarını düzeltme</span><span class="sxs-lookup"><span data-stu-id="c7e7f-268">Fix build issues</span></span>

<span data-ttu-id="c7e7f-269">Taşıma işleminin üçüncü adımı, projenin oluşturulmasını sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="c7e7f-270">Proje dosyası SDK tarzı bir projeye dönüştürüldükten sonra bazı uygulamalar zaten başarılı bir şekilde oluşturur.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="c7e7f-271">Uygulamanız için durum buysa, tebrikler!</span><span class="sxs-lookup"><span data-stu-id="c7e7f-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="c7e7f-272">Adım 4'e gidebilirsin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-272">You can go on to Step 4.</span></span> <span data-ttu-id="c7e7f-273">Diğer uygulamaların .NET Core için bina almak için bazı güncelleştirmelere ihtiyacı vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="c7e7f-274">Örneğin, (veya `dotnet build` Visual Studio'da inşa etmek) şimdi Bean Trader örnek proje üzerinde çalıştırmaya çalışırsanız, birçok hata olacaktır, ancak bunları hızlı bir şekilde sabit alırsınız.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="c7e7f-275">System.ServiceModel referansları ve Microsoft.Windows.Compatibility</span><span class="sxs-lookup"><span data-stu-id="c7e7f-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="c7e7f-276">.NET Core için kullanılabilen ancak otomatik olarak .NET Core uygulama meta paketine dahil olmayan API'ler için yaygın bir hata kaynağı olan başvurular eksiktir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="c7e7f-277">Bu sorunu gidermek için `Microsoft.Windows.Compatibility` pakete başvurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="c7e7f-278">Uyumluluk paketi, WCF istemcisi, dizin hizmetleri, kayıt defteri, yapılandırma, APC'ler API'leri ve daha fazlası gibi Windows masaüstü uygulamalarında yaygın olan geniş bir API kümesi içerir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="c7e7f-279">Bean Trader örneği ile, yapı hatalarının çoğu <xref:System.ServiceModel> eksik türleri kaynaklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="c7e7f-280">Bunlar, gerekli WCF NuGet paketlerine başvurarak ele alınabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="c7e7f-281">WCF istemci API'leri `Microsoft.Windows.Compatibility` pakette bulunanlar arasındadır, bu nedenle uyumluluk paketine başvurmak daha da iyi bir çözümdür (çünkü API'lerle ilgili tüm sorunları ve uyumluluk paketinin kullanıma sunduğu WCF sorunlarına yönelik çözümleri de ele alıyor).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="c7e7f-282">Paket, `Microsoft.Windows.Compatibility` .NET Core 3.0 WPF ve WinForms taşıma senaryolarının çoğunda yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="c7e7f-283">NuGet referansını ekledikten `Microsoft.Windows.Compatibility`sonra, yalnızca bir yapı hatası kalır!</span><span class="sxs-lookup"><span data-stu-id="c7e7f-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="c7e7f-284">Kullanılmayan dosyaları temizleme</span><span class="sxs-lookup"><span data-stu-id="c7e7f-284">Cleaning up unused files</span></span>

<span data-ttu-id="c7e7f-285">Sık sık gelen bir geçiş sorunu, *tüm* kaynağı otomatik olarak içeren yeni SDK tarzı projeler tarafından alınan yapıya daha önce dahil edilmeyen C# ve XAML dosyalarıyla ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="c7e7f-286">Bean Trader örneğinde gördüğünüz bir sonraki yapı hatası *OldUnusedViewModel.cs*kötü bir arayüz uygulaması anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="c7e7f-287">Dosya adı bir ipucudur, ancak denetimde bu kaynak dosyanın yanlış olduğunu göreceksiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="c7e7f-288">Orijinal .NET Framework projesine dahil edilmediği için daha önce sorunlara neden olmadı.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="c7e7f-289">Diskte bulunan ancak eski *csproj'a* dahil olmayan kaynak dosyalar artık otomatik olarak eklenmiştir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="c7e7f-290">Bu gibi tek seferlik sorunlar için, dosyanın gerekli olmadığını onaylamak için önceki *csproj* ile `<Compile Remove="" />` karşılaştırmak kolaydır ve sonra ya o ya da, kaynak dosya artık herhangi bir yerde gerekli değilse, silin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="c7e7f-291">Bu durumda, sadece *OldUnusedViewModel.cs*silmek güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="c7e7f-292">Bu şekilde dışlanması gereken çok sayıda kaynak dosyanız varsa, `<EnableDefaultCompileItems>` özelliği proje dosyasında false olarak ayarlayarak C# dosyalarının otomatik olarak eklenmesini devre dışı bırakabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="c7e7f-293">Ardından, yalnızca `<Compile Include>` eklemeyi planladığınız kaynakları oluşturmak için öğeleri eski proje dosyasındaki öğeleri yenisine kopyalayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="c7e7f-294">Benzer şekilde, `<EnableDefaultPageItems>` XAML sayfalarının otomatik olarak eklenmesini `<EnableDefaultItems>` kapatmak için kullanılabilir ve her ikisini de tek bir özellik ile denetleyebilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="c7e7f-295">Çok geçişli derleyiciler hakkında kısa bir kenara</span><span class="sxs-lookup"><span data-stu-id="c7e7f-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="c7e7f-296">Sorunlu dosyayı Bean Trader örneğinden çıkardıktan sonra yeniden oluşturabilirsiniz ve dört hata alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="c7e7f-297">Daha önce de yok muydu?</span><span class="sxs-lookup"><span data-stu-id="c7e7f-297">Didn't you have one before?</span></span> <span data-ttu-id="c7e7f-298">Hata sayısı neden arttı?</span><span class="sxs-lookup"><span data-stu-id="c7e7f-298">Why did the number of errors go up?</span></span> <span data-ttu-id="c7e7f-299">C# derleyicisi çok geçişli bir [derleyicidir.](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)</span><span class="sxs-lookup"><span data-stu-id="c7e7f-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="c7e7f-300">Bu, her kaynak dosyayı iki kez geçtiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="c7e7f-301">İlk olarak, derleyici yalnızca her kaynak dosyadaki meta verilere ve bildirimlere bakar ve bildirim düzeyi sorunlarını tanımlar.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="c7e7f-302">Bunlar düzelttin hatalar.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="c7e7f-303">Sonra c# kaynağını IL'ye dönüştürmek için kodu tekrar gözden geçirir; bunlar şu anda gördüğünüz ikinci hata kümesidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="c7e7f-304">C# derleyicisi [sadece iki geçer daha](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)fazlasını yapar, ancak sonuç bu gibi büyük kod değişiklikleri için derleyici hataları iki dalga gelme eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="c7e7f-305">Üçüncü taraf bağımlılık düzeltmeleri (Castle.Windsor)</span><span class="sxs-lookup"><span data-stu-id="c7e7f-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="c7e7f-306">Bazı geçiş senaryolarında ortaya çıkan bir diğer sorun sınıfı da .NET Framework ve .NET Çekirdek sürümleri arasındaki API farklarıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="c7e7f-307">Bir NuGet paketi hem .NET Framework'u hem de .NET Standard'ı veya .NET Core'u hedef alsa bile, farklı .NET hedefleri ile kullanılmak üzere farklı kitaplıklar olabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="c7e7f-308">Bu, paketlerin farklı uygulamalar gerektirebilecek birçok farklı .NET platformlarını desteklemesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="c7e7f-309">Ayrıca, farklı .NET platformlarını hedefalırken kitaplıklarda küçük API farklılıkları olabileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="c7e7f-310">Bean Trader örneğinde göreceğiniz bir sonraki hata kümesi `Castle.Windsor` API'larla ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="c7e7f-311">.NET Core Bean Trader projesi ,NET Framework hedefli proje (4.1.1) `Castle.Windsor` ile aynı sürümü kullanır, ancak bu iki platform için uygulamalar biraz farklıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="c7e7f-312">Bu durumda, düzeltilmesi gereken aşağıdaki sorunları görürsünüz:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="c7e7f-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`.NET Core'da kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="c7e7f-314">Ancak, `Classes.FromAssemblyContaining` mevcut benzer API, bu nedenle aramaların `Classes.FromThisAssembly()` her iki `Classes.FromAssemblyContaining(t)`kullanım `t` ları değiştirebilirsiniz , arama yapan türü nerede.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="c7e7f-315">Benzer şekilde, *Bootstrapper.cs*Bootstrapper.cs `Castle.Windsor.Installer.FromAssembly`, . Bu ,NET Core'da kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="c7e7f-316">Bunun yerine, bu çağrı `FromAssembly.Containing(typeof(Bootstrapper))`' ile değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="c7e7f-317">WCF istemci kullanımını güncelleme</span><span class="sxs-lookup"><span data-stu-id="c7e7f-317">Updating WCF client usage</span></span>

<span data-ttu-id="c7e7f-318">`Castle.Windsor` Farkları giderdikten sonra, .NET Core Bean Trader projesinde `BeanTraderServiceClient` kalan son yapı `DuplexClientBase`hatası (türetilmiştir) bir `Open` yöntem emamasıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="c7e7f-319">Bu, bu geçiş işleminin başında .NET Taşınabilirlik Çözümleyicisi tarafından vurgulanan bir API olduğundan bu şaşırtıcı değildir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="c7e7f-320">Baktığımızda `BeanTraderServiceClient` daha büyük bir soruna dikkatimizi çekiyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="c7e7f-321">Bu WCF istemcisi [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) aracı tarafından otomatik olarak oluşturuldu.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="c7e7f-322">**Svcutil tarafından oluşturulan WCF istemcileri .NET Framework'de kullanılmak üzere hazırdır.**</span><span class="sxs-lookup"><span data-stu-id="c7e7f-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="c7e7f-323">Svcutil tarafından oluşturulan WCF istemcilerini kullanan çözümlerin .NET Core ile kullanılmak üzere .NET Standart uyumlu istemcileri yeniden oluşturması gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="c7e7f-324">Eski istemcilerin çalışmamalarının başlıca nedenlerinden biri, WCF bağlamalarını ve uç noktalarını tanımlamak için uygulama yapılandırmalarına bağımlı olmalarıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="c7e7f-325">.NET Standart WCF API'leri çapraz platformda (System.Configuration API'lerinin bulunmadığı yerlerde) çalışabildiği için, .NET Core ve .NET Standart senaryoları için WCF istemcileri yapılandırma yerine programlamak üzere bağlamaları ve uç noktaları tanımlamalıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="c7e7f-326">Aslında, app.config bölümüne `<system.serviceModel>` (Svcutil ile veya el ile oluşturulmuş olsun) bağlı herhangi bir WCF istemci kullanımı .NET Core üzerinde çalışmak için değiştirilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="c7e7f-327">.NET Standart uyumlu WCF istemcilerini otomatik olarak oluşturmanın iki yolu vardır:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="c7e7f-328">Araç, `dotnet-svcutil` WCF istemcilerini Svcutil'in daha önce çalıştığı şekilde oluşturan bir .NET aracıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="c7e7f-329">Visual Studio, Bağlı Hizmetler özelliğinin [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) seçeneğini kullanarak WCF istemcileri oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="c7e7f-330">Her iki yaklaşım da iyi çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-330">Either approach works well.</span></span> <span data-ttu-id="c7e7f-331">Alternatif olarak, tabii ki, WCF istemci kodunu kendiniz yazabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="c7e7f-332">Bu örnek için Visual Studio Connected Service özelliğini kullanmayı seçtim.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="c7e7f-333">Bunu yapmak için Visual Studio'nun çözüm kaşifindeki *BeanTraderClient.Core* projesine sağ tıklayın ve**Bağlı Hizmet** **Ekle'yi** > seçin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="c7e7f-334">Ardından, WCF Web Servis Başvuru Sağlayıcısı'nı seçin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="c7e7f-335">Bu arka uç Bean Trader web hizmetinin adresini belirtebilirsiniz bir`localhost:8080` iletişim getirecek (eğer yerel sunucu çalıştırıyorsanız) ve oluşturulan türleri kullanmanız gereken ad alanı **(BeanTrader.Service**, örneğin).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web Hizmeti Referans Bağlı Hizmet İletişim](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="c7e7f-337">**Bitiş** düğmesini seçtikten sonra projeye yeni bir Bağlı Hizmetler düğümü eklenir ve Bean Trader hizmetine erişmek için yeni .NET Standart WCF istemcisini içeren düğümün altına bir Reference.cs dosyası eklenir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="c7e7f-338">Bu dosyadaki `GetEndpointAddress` veya `GetBindingForEndpoint` yöntemlere bakarsanız, bağlamaların ve uç noktaların artık programlı olarak oluşturulduğunu görürsünüz (uygulama config yerine).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="c7e7f-339">'Bağlı Hizmetler Ekle' özelliği, gerekli tüm WCF paketleri Microsoft.Windows.Compatibility üzerinden dahil edildiği için gerekli olmayan proje dosyasındaki bazı System.ServiceModel paketlerine de referanslar ekleyebilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="c7e7f-340">Ek bir System.ServiceModel `<PackageReference>` öğesi ekleyip eklemedigini görmek için csproj' u kontrol edin ve eğer öyleyse kaldırın.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="c7e7f-341">Projemiz şimdi yeni WCF istemci sınıfları *(Reference.cs),* ama yine de eskileri (BeanTrader.cs) vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="c7e7f-342">Bu noktada iki seçenek vardır:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-342">There are two options at this point:</span></span>

- <span data-ttu-id="c7e7f-343">Orijinal .NET Framework projesini (yeni .NET Core hedefli projeyle birlikte) oluşturmak istiyorsanız, `<Compile Remove="BeanTrader.cs" />` .NET Core projesinin csproj dosyasındaki bir öğeyi kullanarak uygulamanın .NET Framework ve .NET Core sürümlerinin farklı WCF istemcilerini kullanmasını sağlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="c7e7f-344">Bu, varolan .NET Framework projesini değiştirmeden bırakma avantajına sahiptir, ancak oluşturulan WCF istemcilerini kullanan kodun .NET Core durumunda .NET Framework projesinde olduğundan biraz `#if` farklı olması gerekebilir, bu nedenle ,.NET Framework için inşa edildiğinde bir şekilde çalışmak için bazı WCF istemci kullanımını (örneğin istemci oluşturma) koşullu olarak derlemek için yönergeleri kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="c7e7f-345">Diğer taraftan, varolan .NET Framework projesinde bazı kod karmaşası kabul edilebilirse, *BeanTrader.cs* hep birlikte kaldırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="c7e7f-346">Yeni WCF istemcisi .NET Standard için üretilmiştir, hem .NET Core hem de .NET Framework senaryolarında çalışır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="c7e7f-347">.NET Core'a ek olarak .NET Framework için (çok hedefleme veya iki csproj dosyasına sahip olarak) oluşturuyorsanız, bu yeni *Reference.cs* dosyasını her iki hedef için de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="c7e7f-348">Bu yaklaşım, kodun iki farklı WCF istemcisini desteklemek için ikiye ayırmasına gerek kalmayacağı avantajına sahiptir; aynı kod her yerde kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="c7e7f-349">Dezavantajı (muhtemelen kararlı) .NET Framework proje değiştirme içerir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="c7e7f-350">Bean Trader örneğinde, geçişi kolaylaştırıyorsa orijinal projede küçük değişiklikler yapabilirsiniz, bu nedenle WCF istemci kullanımını uzlaştırmak için aşağıdaki adımları uygulayın:</span><span class="sxs-lookup"><span data-stu-id="c7e7f-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="c7e7f-351">Çözüm gezgininden 'Varolan öğeekle' bağlam menüsünü kullanarak yeni Reference.cs dosyasını .NET Framework *BeanTraderClient.csproj* projesine ekleyin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="c7e7f-352">Aynı dosyanın her iki proje tarafından da kullanılması için 'bağlantı olarak' eklediğinizden emin olun (C# dosyasını kopyalamanın aksine).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="c7e7f-353">Eğer tek bir csproj (çoklu hedefleme kullanarak) ile hem .NET Core ve .NET Framework için oluşturuyorsanız, bu adım gerekli değildir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="c7e7f-354">*BeanTrader.cs*silin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="c7e7f-355">Yeni WCF istemcisi eskisine benzer, ancak oluşturulan koddaki birkaç ad alanı farklıdır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="c7e7f-356">Bu nedenle, WCF istemci türleri BeanTrader.Service (ya da seçtiğiniz ne olursa olsun namespace adı) yerine BeanTrader.Model veya bir isim alanı olmadan kullanılan proje güncellemek için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="c7e7f-357">Bina *BeanTraderClient.Core.csproj* nerede bu değişikliklerin yapılması gerektiğini belirlemek için yardımcı olacaktır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="c7e7f-358">Hem C# hem de XAML kaynak dosyalarında düzeltmeler gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="c7e7f-359">Son olarak, `BeanTraderServiceClient` tür için kullanılabilir oluşturucular değiştiğinden *BeanTraderServiceClientFactory.cs* bir hata olduğunu keşfedeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="c7e7f-360">Bir `InstanceContext` bağımsız değişken `CallbackHandler` `Castle.Windsor` (IoC konteyner bir kullanılarak oluşturulan) sağlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="c7e7f-361">Yeni yapıcılar yeni `CallbackHandler`s oluştururlar.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="c7e7f-362">Ancak, 'temel türünde `BeanTraderServiceClient`istediğinizle eşleşen yapıcılar vardır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="c7e7f-363">Otomatik oluşturulan WCF istemci kodunun tümü kısmi sınıflarda bulunduğundan, kolayca genişletebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="c7e7f-364">Bunu yapmak *için, BeanTraderServiceClient.cs* adında yeni bir dosya oluşturun ve ardından aynı ada sahip kısmi bir sınıf oluşturun (BeanTrader.Service ad alanını kullanarak).</span><span class="sxs-lookup"><span data-stu-id="c7e7f-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="c7e7f-365">Daha sonra, burada gösterildiği gibi kısmi türüne bir oluşturucu ekleyin.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="c7e7f-366">Yapılan bu değişikliklerle, Bean Trader örneği artık yeni bir .NET Standart uyumlu WCF istemcisi `Open` kullanacak ve `await OpenAsync` bunun yerine kullanmak için *TradingService.cs* aramayı değiştirmenin son düzeltmesini yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="c7e7f-367">WCF sorunları ele ile, Bean Trader örnek .NET Core sürümü şimdi temiz oluşturur!</span><span class="sxs-lookup"><span data-stu-id="c7e7f-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="c7e7f-368">Çalışma zamanı testi</span><span class="sxs-lookup"><span data-stu-id="c7e7f-368">Runtime testing</span></span>

<span data-ttu-id="c7e7f-369">Proje .NET Core'a karşı temiz bir şekilde inşa olur olmaz geçiş çalışmalarının yapılmadığını unutmak kolaydır.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="c7e7f-370">Taşınan uygulamayı test etmek için de zaman bırakmak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="c7e7f-371">İşler başarılı bir şekilde inşa olduktan sonra, özellikle .NET Framework'u hedefleyen herhangi bir paket kullanıyorsanız, uygulamanın beklendiği gibi çalıştığından ve çalıştığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="c7e7f-372">Portlu Bean Trader uygulamasını başlatmayı deneyelim ve neler olacağını görelim.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="c7e7f-373">Uygulama aşağıdaki istisna dışında başarısız olmadan önce çok uzak almaz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="c7e7f-374">Bu mantıklı, tabii ki.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-374">This makes sense, of course.</span></span> <span data-ttu-id="c7e7f-375">WCF'nin artık uygulama yapılandırmasını kullanmadığını unutmayın, bu nedenle app.config dosyasının eski system.serviceModel bölümünün kaldırılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="c7e7f-376">Güncelleştirilmiş WCF istemcisi kodunda aynı bilgilerin tümünü içerir, bu nedenle config bölümüne artık gerek yoktur.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="c7e7f-377">WCF bitiş noktasının app.config'de yapılandırılabilir olmasını istiyorsanız, bunu bir uygulama ayarı olarak ekleyebilir ve WCF hizmet bitiş noktasını yapılandırmadan almak için WCF istemci kodunu güncelleştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="c7e7f-378">*app.config*system.serviceModel bölümünü kaldırdıktan sonra, uygulama başlatıyor ancak kullanıcı girdiğinde başka bir istisna dışında başarısız oluyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="c7e7f-379">Desteklenmeyen API. `Func<T>.BeginInvoke`</span><span class="sxs-lookup"><span data-stu-id="c7e7f-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="c7e7f-380">[dotnet/corefx#5940'da](https://github.com/dotnet/corefx/issues/5940)açıklandığı gibi ,NET Core, `BeginInvoke` `EndInvoke` temel remoting bağımlılıkları nedeniyle temsilci türlerine ilişkin yöntemleri ve yöntemleri desteklemez.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="c7e7f-381">Bu sorun ve düzeltmesi,.NET Core blog gönderisi [için Gelen Temsilci.BeginInvoke](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) Çağrıları'nda `BeginInvoke` `EndInvoke` daha ayrıntılı olarak `Task.Run` açıklanır, ancak özü şudur ve aramalar (veya mümkünse eşitleme alternatifleri) ile değiştirilmelidir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="c7e7f-382">Genel çözümü burada uygulayarak, `BeginInvoke` arama tarafından `Invoke` `Task.Run`başlatılan bir çağrı ile değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="c7e7f-383">`BeginInvoke` Bean Trader uygulaması kullanımı kaldırdıktan sonra .NET Core'da başarıyla çalışır!</span><span class="sxs-lookup"><span data-stu-id="c7e7f-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![.NET Core üzerinde çalışan Fasulye Trader](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="c7e7f-385">Tüm uygulamalar farklıdır, bu nedenle kendi uygulamalarınızı .NET Core'a geçirmek için gereken belirli adımlar değişir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="c7e7f-386">Ama umarım Bean Trader örnek genel iş akışı ve beklenebilir sorunların türleri gösterir.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="c7e7f-387">Ve, bu makalenin uzunluğuna rağmen, .NET Core üzerinde çalışması için Bean Trader örneğinde gerekli olan gerçek değişiklikler oldukça sınırlıydı.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="c7e7f-388">Birçok uygulama .NET Core'a aynı şekilde geçiş yapar; sınırlı veya hiç kod değişikliği gerektirmiyor.</span><span class="sxs-lookup"><span data-stu-id="c7e7f-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
