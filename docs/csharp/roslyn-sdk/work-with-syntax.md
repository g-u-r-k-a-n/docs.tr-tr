---
title: .NET Derleyici Platformu SDK sözdizimi modelini kullanın
description: Bu genel bakış, sözdizimi düğümlerini anlamak ve işlemek için kullandığınız türlerin anlaşılmasını sağlar.
ms.date: 10/15/2017
ms.custom: mvc
ms.openlocfilehash: fc1b1f5ae5ec985425c8d6aec49ef7f830ea9162
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "75740479"
---
# <a name="work-with-syntax"></a><span data-ttu-id="d851c-103">Söz dizimi ile çalışma</span><span class="sxs-lookup"><span data-stu-id="d851c-103">Work with syntax</span></span>

<span data-ttu-id="d851c-104">**Sözdizimi ağacı** derleyici API'leri tarafından maruz kalan temel bir veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="d851c-104">The **syntax tree** is a fundamental data structure exposed by the compiler APIs.</span></span> <span data-ttu-id="d851c-105">Bu ağaçlar kaynak kodun sözlü ve sözdizimsel yapısını temsil ediyor.</span><span class="sxs-lookup"><span data-stu-id="d851c-105">These trees represent the lexical and syntactic structure of source code.</span></span> <span data-ttu-id="d851c-106">İki önemli amac için kullanılırlar:</span><span class="sxs-lookup"><span data-stu-id="d851c-106">They serve two important purposes:</span></span>

1. <span data-ttu-id="d851c-107">IDE, eklentiler, kod çözümleme araçları ve refactorings gibi araçların bir kullanıcının projesinde kaynak kodun sözdizimi yapısını görmesine ve işlemesine izin vermek için.</span><span class="sxs-lookup"><span data-stu-id="d851c-107">To allow tools - such as an IDE, add-ins, code analysis tools, and refactorings - to see and process the syntactic structure of source code in a user’s project.</span></span>
2. <span data-ttu-id="d851c-108">Doğrudan metin düzenlemeleri kullanmadan kaynak kodu doğal bir şekilde oluşturmak, değiştirmek ve yeniden düzenlemek için yeniden düzenleme ler gibi araçları etkinleştirmek için.</span><span class="sxs-lookup"><span data-stu-id="d851c-108">To enable tools - such as refactorings and an IDE - to create, modify, and rearrange source code in a natural manner without having use direct text edits.</span></span> <span data-ttu-id="d851c-109">Ağaçlar oluşturup manipüle ederek, araçlar kaynak kodu kolayca oluşturabilir ve yeniden düzenleyebilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-109">By creating and manipulating trees, tools can easily create and rearrange source code.</span></span>

## <a name="syntax-trees"></a><span data-ttu-id="d851c-110">Sözdizimi ağaçları</span><span class="sxs-lookup"><span data-stu-id="d851c-110">Syntax trees</span></span>

<span data-ttu-id="d851c-111">Sözdizimi ağaçları derleme, kod analizi, bağlama, yeniden düzenleme, IDE özellikleri ve kod oluşturma için kullanılan birincil yapıdır.</span><span class="sxs-lookup"><span data-stu-id="d851c-111">Syntax trees are the primary structure used for compilation, code analysis, binding, refactoring, IDE features, and code generation.</span></span> <span data-ttu-id="d851c-112">Kaynak kodun hiçbir bölümü, ilk olarak tanımlanmadan ve birçok tanınmış yapısal dil öğesinden biri olarak sınıflandırılmadan anlaşılmaz.</span><span class="sxs-lookup"><span data-stu-id="d851c-112">No part of the source code is understood without it first being identified and categorized into one of many well-known structural language elements.</span></span>

<span data-ttu-id="d851c-113">Sözdizimi ağaçlarının üç temel özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="d851c-113">Syntax trees have three key attributes.</span></span> <span data-ttu-id="d851c-114">İlk öznitelik sözdizimi ağaçları tam sadakat tüm kaynak bilgileri tutmak olduğunu.</span><span class="sxs-lookup"><span data-stu-id="d851c-114">The first attribute is that syntax trees hold all the source information in full fidelity.</span></span> <span data-ttu-id="d851c-115">Bu, sözdizimi ağacının kaynak metinde bulunan her bilgi parçasını, her dilbilgisi yapısını, her sözlü belirteci ve beyaz boşluk, yorumlar ve önişlemci yönergeleri de dahil olmak üzere aradaki her şeyi içerdiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d851c-115">This means that the syntax tree contains every piece of information found in the source text, every grammatical construct, every lexical token, and everything else in between, including white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="d851c-116">Örneğin, kaynakta belirtilen her bir edebi tam olarak yazılmış olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-116">For example, each literal mentioned in the source is represented exactly as it was typed.</span></span> <span data-ttu-id="d851c-117">Sözdizimi ağaçları, program tamamlanmamış veya sözdizimi ağacında atlanan veya eksik belirteçleri temsil ederek eksik olduğunda kaynak kodundaki hataları da temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d851c-117">The syntax trees also represent errors in source code when the program is incomplete or malformed by representing skipped or missing tokens in the syntax tree.</span></span>

<span data-ttu-id="d851c-118">Bu sözdizimi ağaçlarının ikinci özniteliğini sağlar.</span><span class="sxs-lookup"><span data-stu-id="d851c-118">This enables the second attribute of syntax trees.</span></span> <span data-ttu-id="d851c-119">Ayrıştırıcıdan elde edilen bir sözdizimi ağacı, ayrıştırılmış olduğu metni üretebilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-119">A syntax tree obtained from the parser can produce the exact text it was parsed from.</span></span> <span data-ttu-id="d851c-120">Herhangi bir sözdizimi düğümünden, bu düğümde köklü alt ağacın metin gösterimini almak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="d851c-120">From any syntax node, it is possible to get the text representation of the sub-tree rooted at that node.</span></span> <span data-ttu-id="d851c-121">Bu, sözdizimi ağaçlarının kaynak metni oluşturma ve bunları yeniden oluşturmanın bir yolu olarak kullanabileceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d851c-121">This means that syntax trees can be used as a way to construct and edit source text.</span></span> <span data-ttu-id="d851c-122">Eşdeğer metni oluşturduğunuz bir ağaç oluşturarak ve sözdizimi ağacıdüzenleyerek, varolan bir ağaçta yapılan değişikliklerden yeni bir ağaç oluşturarak metni etkili bir şekilde düzenlemiş olursunuz.</span><span class="sxs-lookup"><span data-stu-id="d851c-122">By creating a tree you have by implication created the equivalent text, and by editing a syntax tree, making a new tree out of changes to an existing tree, you have effectively edited the text.</span></span>

<span data-ttu-id="d851c-123">Sözdizimi ağaçlarının üçüncü özniteliği, değişmez ve iş parçacığı güvenli olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="d851c-123">The third attribute of syntax trees is that they are immutable and thread-safe.</span></span>  <span data-ttu-id="d851c-124">Bu, bir ağaç alındıktan sonra, kodun geçerli durumunun anlık görüntüsü olduğu ve hiçbir zaman değişmeyiş anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d851c-124">This means that after a tree is obtained, it is a snapshot of the current state of the code, and never changes.</span></span> <span data-ttu-id="d851c-125">Bu, birden çok kullanıcının kilitleme veya yineleme olmadan farklı iş parçacıklarında aynı anda aynı sözdizimi ağacıyla etkileşimkurmasına olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="d851c-125">This allows multiple users to interact with the same syntax tree at the same time in different threads without locking or duplication.</span></span> <span data-ttu-id="d851c-126">Ağaçlar değişmez olduğundan ve doğrudan bir ağaca değişiklik yapılamadığından, fabrika yöntemleri ağacın ek anlık görüntülerini oluşturarak sözdizimi ağaçlarının oluşturulmasına ve değiştirilmesine yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="d851c-126">Because the trees are immutable and no modifications can be made directly to a tree, factory methods help create and modify syntax trees by creating additional snapshots of the tree.</span></span> <span data-ttu-id="d851c-127">Ağaçlar altta yatan düğümleri yeniden kullanma şeklinde etkilidir, böylece yeni bir sürüm hızlı ve çok az ekstra bellekle yeniden oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-127">The trees are efficient in the way they reuse underlying nodes, so a new version can be rebuilt fast and with little extra memory.</span></span>

<span data-ttu-id="d851c-128">Sözdizimi ağacı, terminal olmayan yapısal öğelerin diğer öğelerin üst düzey eki olduğu bir ağaç veri yapısıdır.</span><span class="sxs-lookup"><span data-stu-id="d851c-128">A syntax tree is literally a tree data structure, where non-terminal structural elements parent other elements.</span></span> <span data-ttu-id="d851c-129">Her sözdizimi ağacı düğümlerden, belirteçlerden ve ıvır zıvırdan oluşur.</span><span class="sxs-lookup"><span data-stu-id="d851c-129">Each syntax tree is made up of nodes, tokens, and trivia.</span></span>

## <a name="syntax-nodes"></a><span data-ttu-id="d851c-130">Sözdizimi düğümleri</span><span class="sxs-lookup"><span data-stu-id="d851c-130">Syntax nodes</span></span>

<span data-ttu-id="d851c-131">Sözdizimi düğümleri sözdizimi ağaçlarının birincil öğelerinden biridir.</span><span class="sxs-lookup"><span data-stu-id="d851c-131">Syntax nodes are one of the primary elements of syntax trees.</span></span> <span data-ttu-id="d851c-132">Bu düğümler deyimler, deyimler, yan tümceler ve ifadeler gibi sözdizim yapıları temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d851c-132">These nodes represent syntactic constructs such as declarations, statements, clauses, and expressions.</span></span> <span data-ttu-id="d851c-133">Sözdizimi düğümlerinin her kategorisi, .'dan <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>türetilen ayrı bir sınıfla temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-133">Each category of syntax nodes is represented by a separate class derived from <xref:Microsoft.CodeAnalysis.SyntaxNode?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d851c-134">Düğüm sınıfları kümesi genişletilebilir değildir.</span><span class="sxs-lookup"><span data-stu-id="d851c-134">The set of node classes is not extensible.</span></span>

<span data-ttu-id="d851c-135">Tüm sözdizimi düğümleri sözdizimi ağacındaki terminal olmayan düğümlerdir, bu da çocuk olarak her zaman başka düğümleri ve belirteçleri olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="d851c-135">All syntax nodes are non-terminal nodes in the syntax tree, which means they always have other nodes and tokens as children.</span></span> <span data-ttu-id="d851c-136">Başka bir düğümün alt öğesi olarak, her düğümün <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> özelliği nden erişilebilen bir üst düğüm vardır.</span><span class="sxs-lookup"><span data-stu-id="d851c-136">As a child of another node, each node has a parent node that can be accessed through the <xref:Microsoft.CodeAnalysis.SyntaxNode.Parent?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="d851c-137">Düğümler ve ağaçlar değişmez olduğundan, düğümün üst öğesi asla değişmez.</span><span class="sxs-lookup"><span data-stu-id="d851c-137">Because nodes and trees are immutable, the parent of a node never changes.</span></span> <span data-ttu-id="d851c-138">Ağacın kökünde boş bir ebeveyn vardır.</span><span class="sxs-lookup"><span data-stu-id="d851c-138">The root of the tree has a null parent.</span></span>

<span data-ttu-id="d851c-139">Her düğüm, <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> kaynak metindeki konumlarına göre alt düğümlerin listesini sıralı sırayla döndüren bir yönteme sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d851c-139">Each node has a <xref:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes?displayProperty=nameWithType> method, which returns a list of child nodes in sequential order based on their position in the source text.</span></span> <span data-ttu-id="d851c-140">Bu liste belirteçleri içermez.</span><span class="sxs-lookup"><span data-stu-id="d851c-140">This list does not contain tokens.</span></span> <span data-ttu-id="d851c-141">Her düğüm, bu düğüm tarafından köksünün <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>köklediği alt ağaçta bulunan tüm düğümlerin, belirteçlerin veya ıvır zıvırLarın listesini temsil eden Torunlar'ı <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>inceleme yöntemlerine de sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d851c-141">Each node also has methods to examine Descendants, such as <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes%2A>, <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens%2A>, or <xref:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia%2A> - that represent a list of all the nodes, tokens, or trivia that exist in the sub-tree rooted by that node.</span></span>

<span data-ttu-id="d851c-142">Buna ek olarak, her sözdizimi düğümü alt sınıfı, güçlü bir şekilde yazılan özellikler aracılığıyla aynı alt tüm alt sınıfları ortaya çıkarır.</span><span class="sxs-lookup"><span data-stu-id="d851c-142">In addition, each syntax node subclass exposes all the same children through strongly typed properties.</span></span> <span data-ttu-id="d851c-143">Örneğin, bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> düğüm sınıfının ikili işleçlere <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>özgü <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>üç <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>ek özelliği vardır: , , ve .</span><span class="sxs-lookup"><span data-stu-id="d851c-143">For example, a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> node class has three additional properties specific to binary operators: <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right>.</span></span> <span data-ttu-id="d851c-144">Türü <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> türüdür <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, ve <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> türüdür <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span><span class="sxs-lookup"><span data-stu-id="d851c-144">The type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left> and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> is <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax>, and the type of <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken> is <xref:Microsoft.CodeAnalysis.SyntaxToken>.</span></span>

<span data-ttu-id="d851c-145">Bazı sözdizimi düğümlerinin isteğe bağlı çocukları vardır.</span><span class="sxs-lookup"><span data-stu-id="d851c-145">Some syntax nodes have optional children.</span></span> <span data-ttu-id="d851c-146">Örneğin, isteğe <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> bağlı <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>bir .</span><span class="sxs-lookup"><span data-stu-id="d851c-146">For example, an <xref:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax> has an optional <xref:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax>.</span></span> <span data-ttu-id="d851c-147">Çocuk yoksa, özellik null döndürür.</span><span class="sxs-lookup"><span data-stu-id="d851c-147">If the child is not present, the property returns null.</span></span>

## <a name="syntax-tokens"></a><span data-ttu-id="d851c-148">Sözdizimi belirteçleri</span><span class="sxs-lookup"><span data-stu-id="d851c-148">Syntax tokens</span></span>

<span data-ttu-id="d851c-149">Sözdizimi belirteçleri, kodun en küçük sözdizimi parçalarını temsil eden dil dilbilgisinin terminalleridir.</span><span class="sxs-lookup"><span data-stu-id="d851c-149">Syntax tokens are the terminals of the language grammar, representing the smallest syntactic fragments of the code.</span></span> <span data-ttu-id="d851c-150">Onlar asla diğer düğümlerin veya belirteçlerin ebeveynleri değildir.</span><span class="sxs-lookup"><span data-stu-id="d851c-150">They are never parents of other nodes or tokens.</span></span> <span data-ttu-id="d851c-151">Sözdizimi belirteçleri anahtar kelimeler, tanımlayıcılar, literals ve noktalama oluşur.</span><span class="sxs-lookup"><span data-stu-id="d851c-151">Syntax tokens consist of keywords, identifiers, literals, and punctuation.</span></span>

<span data-ttu-id="d851c-152">Verimlilik amacıyla, <xref:Microsoft.CodeAnalysis.SyntaxToken> tür bir CLR değer türüdür.</span><span class="sxs-lookup"><span data-stu-id="d851c-152">For efficiency purposes, the <xref:Microsoft.CodeAnalysis.SyntaxToken> type is a CLR value type.</span></span> <span data-ttu-id="d851c-153">Bu nedenle, sözdizimi düğümlerinin aksine, temsil edilen belirteç türüne bağlı olarak anlamı olan özelliklerin bir karışımı ile belirteçleri her türlü için tek bir yapı vardır.</span><span class="sxs-lookup"><span data-stu-id="d851c-153">Therefore, unlike syntax nodes, there is only one structure for all kinds of tokens with a mix of properties that have meaning depending on the kind of token that is being represented.</span></span>

<span data-ttu-id="d851c-154">Örneğin, tamsayı gerçek belirteci sayısal bir değeri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d851c-154">For example, an integer literal token represents a numeric value.</span></span> <span data-ttu-id="d851c-155">Belirteç yayılma lı ham kaynak metne ek olarak, <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> gerçek belirteç tam olarak çözülmüş tamsayı değerini söyleyen bir özelliğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d851c-155">In addition to the raw source text the token spans, the literal token has a <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property that tells you the exact decoded integer value.</span></span> <span data-ttu-id="d851c-156">Bu özellik, birçok <xref:System.Object> ilkel türden biri olabileceği nden olarak yazılır.</span><span class="sxs-lookup"><span data-stu-id="d851c-156">This property is typed as <xref:System.Object> because it may be one of many primitive types.</span></span>

<span data-ttu-id="d851c-157">Özellik, <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> özellik ile aynı bilgileri söyler; ancak bu özellik her <xref:System.String>zaman .</span><span class="sxs-lookup"><span data-stu-id="d851c-157">The <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property tells you the same information as the <xref:Microsoft.CodeAnalysis.SyntaxToken.Value> property; however this property is always typed as <xref:System.String>.</span></span> <span data-ttu-id="d851c-158">C# kaynak metindeki bir tanımlayıcı Unicode kaçış karakterlerini içerebilir, ancak kaçış dizisinin sözdizimi tanımlayıcı adının bir parçası olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="d851c-158">An identifier in C# source text may include Unicode escape characters, yet the syntax of the escape sequence itself is not considered part of the identifier name.</span></span> <span data-ttu-id="d851c-159">Yani belirteç tarafından yayılan ham metin kaçış sırasını <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> içerse de, özellik içermez.</span><span class="sxs-lookup"><span data-stu-id="d851c-159">So although the raw text spanned by the token does include the escape sequence, the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property does not.</span></span> <span data-ttu-id="d851c-160">Bunun yerine, kaçış tarafından tanımlanan Unicode karakterleri içerir.</span><span class="sxs-lookup"><span data-stu-id="d851c-160">Instead, it includes the Unicode characters identified by the escape.</span></span> <span data-ttu-id="d851c-161">Örneğin, kaynak metin , `\u03C0`olarak yazılmış bir tanımlayıcı içeriyorsa, bu belirteç için <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> özellik döndürecek. `π`</span><span class="sxs-lookup"><span data-stu-id="d851c-161">For example, if the source text contains an identifier written as `\u03C0`, then the <xref:Microsoft.CodeAnalysis.SyntaxToken.ValueText> property for this token will return `π`.</span></span>

## <a name="syntax-trivia"></a><span data-ttu-id="d851c-162">Sözdizimi ıvır zıvırı</span><span class="sxs-lookup"><span data-stu-id="d851c-162">Syntax trivia</span></span>

<span data-ttu-id="d851c-163">Sözdizimi trivia, kaynak metnin beyaz alan, açıklamalar ve önişlemci yönergeleri gibi kodun normal anlaşılması için büyük ölçüde önemsiz olan bölümlerini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="d851c-163">Syntax trivia represent the parts of the source text that are largely insignificant for normal understanding of the code, such as white space, comments, and preprocessor directives.</span></span> <span data-ttu-id="d851c-164">Sözdizimi belirteçleri gibi, ıvır zıvır da değer türleridir.</span><span class="sxs-lookup"><span data-stu-id="d851c-164">Like syntax tokens, trivia are value types.</span></span> <span data-ttu-id="d851c-165">Tek <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> tip ıvır zıvır her türlü tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="d851c-165">The single <xref:Microsoft.CodeAnalysis.SyntaxTrivia?displayProperty=nameWithType> type is used to describe all kinds of trivia.</span></span>

<span data-ttu-id="d851c-166">Trivia normal dil sözdiziminin bir parçası olmadığından ve herhangi iki belirteç arasında herhangi bir yerde görünebildiği için, düğüm bir alt ad olarak sözdizimi ağacına dahil edilmez.</span><span class="sxs-lookup"><span data-stu-id="d851c-166">Because trivia are not part of the normal language syntax and can appear anywhere between any two tokens, they are not included in the syntax tree as a child of a node.</span></span> <span data-ttu-id="d851c-167">Ancak, yeniden düzenleme gibi bir özelliği uygularken ve kaynak metinle tam sadakati korurken önemli olduklarından, sözdizimi ağacının bir parçası olarak bulunurlar.</span><span class="sxs-lookup"><span data-stu-id="d851c-167">Yet, because they are important when implementing a feature like refactoring and to maintain full fidelity with the source text, they do exist as part of the syntax tree.</span></span>

<span data-ttu-id="d851c-168">Bir jetonun <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> veya <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> koleksiyonları inceleyerek ıvır zıvıra erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d851c-168">You can access trivia by inspecting a token’s <xref:Microsoft.CodeAnalysis.SyntaxToken.LeadingTrivia?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.SyntaxToken.TrailingTrivia?displayProperty=nameWithType> collections.</span></span> <span data-ttu-id="d851c-169">Kaynak metin ayrıştırıldığında, önemsiz diziler belirteçlerle ilişkilendirilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-169">When source text is parsed, sequences of trivia are associated with tokens.</span></span> <span data-ttu-id="d851c-170">Genel olarak, bir belirteç sonraki belirteç kadar aynı satırda sonra herhangi bir ıvır zıvır sahibi.</span><span class="sxs-lookup"><span data-stu-id="d851c-170">In general, a token owns any trivia after it on the same line up to the next token.</span></span> <span data-ttu-id="d851c-171">Bu satırdan sonra herhangi bir ıvır zıvır aşağıdaki belirteç ile ilişkilidir.</span><span class="sxs-lookup"><span data-stu-id="d851c-171">Any trivia after that line is associated with the following token.</span></span> <span data-ttu-id="d851c-172">Kaynak dosyadaki ilk belirteç tüm ilk ıvır zıvırı alır ve dosyadaki son ıvır zıvır dizisi dosya sonu belirteciüzerine yapıştırılır, aksi takdirde sıfır genişliğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d851c-172">The first token in the source file gets all the initial trivia, and the last sequence of trivia in the file is tacked onto the end-of-file token, which otherwise has zero width.</span></span>

<span data-ttu-id="d851c-173">Sözdizimi düğümleri ve belirteçleri aksine, sözdizimi trivia anne yok.</span><span class="sxs-lookup"><span data-stu-id="d851c-173">Unlike syntax nodes and tokens, syntax trivia do not have parents.</span></span> <span data-ttu-id="d851c-174">Ancak, ağacın bir parçası oldukları ve her biri tek bir belirteçle ilişkili olduğundan, <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> özelliği kullanmakla ilişkili olan belirtecine erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d851c-174">Yet, because they are part of the tree and each is associated with a single token, you may access the token it is associated with using the <xref:Microsoft.CodeAnalysis.SyntaxTrivia.Token?displayProperty=nameWithType> property.</span></span>

## <a name="spans"></a><span data-ttu-id="d851c-175">Yayılan</span><span class="sxs-lookup"><span data-stu-id="d851c-175">Spans</span></span>

<span data-ttu-id="d851c-176">Her düğüm, belirteç veya trivia kaynak metin içindeki konumunu ve oluştuğu karakter sayısını bilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-176">Each node, token, or trivia knows its position within the source text and the number of characters it consists of.</span></span> <span data-ttu-id="d851c-177">Metin konumu, sıfır tabanlı `char` bir dizin olan 32 bittamsedi olarak gösterilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-177">A text position is represented as a 32-bit integer, which is a zero-based `char` index.</span></span> <span data-ttu-id="d851c-178">Nesne, <xref:Microsoft.CodeAnalysis.Text.TextSpan> her ikisi de tamsayılar olarak temsil edilen başlangıç konumu ve karakter sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="d851c-178">A <xref:Microsoft.CodeAnalysis.Text.TextSpan> object is the beginning position and a count of characters, both represented as integers.</span></span> <span data-ttu-id="d851c-179">Uzunluğu <xref:Microsoft.CodeAnalysis.Text.TextSpan> sıfırsa, iki karakter arasındaki konumu ifade eder.</span><span class="sxs-lookup"><span data-stu-id="d851c-179">If <xref:Microsoft.CodeAnalysis.Text.TextSpan> has a zero length, it refers to a location between two characters.</span></span>

<span data-ttu-id="d851c-180">Her düğümün <xref:Microsoft.CodeAnalysis.Text.TextSpan> iki <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> özelliği <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>vardır: ve.</span><span class="sxs-lookup"><span data-stu-id="d851c-180">Each node has two <xref:Microsoft.CodeAnalysis.Text.TextSpan> properties: <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> and <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A>.</span></span>

<span data-ttu-id="d851c-181">Özellik, <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> düğümün alt ağacındaki ilk belirteç başlangıcından son belirteci sonuna kadar olan metin aralığıdır.</span><span class="sxs-lookup"><span data-stu-id="d851c-181">The <xref:Microsoft.CodeAnalysis.SyntaxNode.Span%2A> property is the text span from the start of the first token in the node’s sub-tree to the end of the last token.</span></span> <span data-ttu-id="d851c-182">Bu açıklık, herhangi bir öncü veya izbırakan ıvır zıvır içermez.</span><span class="sxs-lookup"><span data-stu-id="d851c-182">This span does not include any leading or trailing trivia.</span></span>

<span data-ttu-id="d851c-183">Özellik <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> düğüm normal açıklığı, artı herhangi bir satır veya iz civarı açıklığı içeren metin açıklığıdır.</span><span class="sxs-lookup"><span data-stu-id="d851c-183">The <xref:Microsoft.CodeAnalysis.SyntaxNode.FullSpan%2A> property is the text span that includes the node’s normal span, plus the span of any leading or trailing trivia.</span></span>

<span data-ttu-id="d851c-184">Örnek:</span><span class="sxs-lookup"><span data-stu-id="d851c-184">For example:</span></span>

``` csharp
      if (x > 3)
      {
||        // this is bad
          |throw new Exception("Not right.");|  // better exception?||
      }
```

<span data-ttu-id="d851c-185">Bloğun içindeki deyim düğümü, tek dikey çubuklarla (|) gösterilen bir açıklığa sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d851c-185">The statement node inside the block has a span indicated by the single vertical bars (|).</span></span> <span data-ttu-id="d851c-186">Karakterleri `throw new Exception("Not right.");`içerir.</span><span class="sxs-lookup"><span data-stu-id="d851c-186">It includes the characters `throw new Exception("Not right.");`.</span></span> <span data-ttu-id="d851c-187">Tam açıklık çift dikey çubuklarla (||) gösterilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-187">The full span is indicated by the double vertical bars (||).</span></span> <span data-ttu-id="d851c-188">Bu açıklık ve önde gelen ve izleyen ıvır zıvır ile ilişkili karakterler olarak aynı karakterleri içerir.</span><span class="sxs-lookup"><span data-stu-id="d851c-188">It includes the same characters as the span and the characters associated with the leading and trailing trivia.</span></span>

## <a name="kinds"></a><span data-ttu-id="d851c-189">Her türlü</span><span class="sxs-lookup"><span data-stu-id="d851c-189">Kinds</span></span>

<span data-ttu-id="d851c-190">Her düğüm, belirteç veya trivia temsil <xref:System.Int32?displayProperty=nameWithType>edilen tam sözdizimi öğesini tanımlayan türü, bir <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="d851c-190">Each node, token, or trivia has a <xref:Microsoft.CodeAnalysis.SyntaxNode.RawKind?displayProperty=nameWithType> property, of type <xref:System.Int32?displayProperty=nameWithType>, that identifies the exact syntax element represented.</span></span> <span data-ttu-id="d851c-191">Bu değer, dile özgü numaralandırmaya kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-191">This value can be cast to a language-specific enumeration.</span></span> <span data-ttu-id="d851c-192">Her dil, C# veya Visual `SyntaxKind` Basic, dilbilgisindeki<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>tüm olası düğümleri, belirteçleri ve önemsiz öğeleri listeleyen tek bir numaralandırmaya (ve sırasıyla) sahiptir.</span><span class="sxs-lookup"><span data-stu-id="d851c-192">Each language, C# or Visual Basic, has a single `SyntaxKind` enumeration  (<xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind?displayProperty=nameWithType> and <xref:Microsoft.CodeAnalysis.VisualBasic.SyntaxKind?displayProperty=nameWithType>, respectively) that lists all the possible nodes, tokens, and trivia elements in the grammar.</span></span> <span data-ttu-id="d851c-193">Bu dönüştürme, uzantı yöntemlerine <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> erişerek otomatik olarak yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-193">This conversion can be done automatically by accessing the <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A?displayProperty=nameWithType> or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicExtensions.Kind%2A?displayProperty=nameWithType> extension methods.</span></span>

<span data-ttu-id="d851c-194">Özellik, <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> aynı düğüm sınıfını paylaşan sözdizimi düğümü türlerinin kolayca yok edilmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="d851c-194">The <xref:Microsoft.CodeAnalysis.SyntaxToken.RawKind> property allows for easy disambiguation of syntax node types that share the same node class.</span></span> <span data-ttu-id="d851c-195">Belirteçler ve ıvır zıvır için bu özellik, bir öğe türünü diğerinden ayırmanın tek yoludur.</span><span class="sxs-lookup"><span data-stu-id="d851c-195">For tokens and trivia, this property is the only way to distinguish one type of element from another.</span></span>

<span data-ttu-id="d851c-196">Örneğin, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> tek bir <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>sınıf <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>vardır <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> , ve çocuk olarak.</span><span class="sxs-lookup"><span data-stu-id="d851c-196">For example, a single <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax> class has <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left>, <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken>, and <xref:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right> as children.</span></span> <span data-ttu-id="d851c-197"><xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> Özellik, sözdizimi düğümü <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression> <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>nün <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> bir , veya tür olup olmadığını ayırt eder.</span><span class="sxs-lookup"><span data-stu-id="d851c-197">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Kind%2A> property distinguishes whether it is an <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.AddExpression>, <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SubtractExpression>, or <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.MultiplyExpression> kind of syntax node.</span></span>

## <a name="errors"></a><span data-ttu-id="d851c-198">Hatalar</span><span class="sxs-lookup"><span data-stu-id="d851c-198">Errors</span></span>

<span data-ttu-id="d851c-199">Kaynak metin sözdizimi hataları içerse bile, kaynak için çift yönlü eşzamanlı olan tam bir sözdizimi ağacı açığa çıkarır.</span><span class="sxs-lookup"><span data-stu-id="d851c-199">Even when the source text contains syntax errors, a full syntax tree that is round-trippable to the source is exposed.</span></span> <span data-ttu-id="d851c-200">Parser, dilin tanımlı sözdizimine uymayan kodla karşılaştığında, sözdizimi ağacı oluşturmak için iki teknikten birini kullanır.</span><span class="sxs-lookup"><span data-stu-id="d851c-200">When the parser encounters code that does not conform to the defined syntax of the language, it uses one of two techniques to create a syntax tree.</span></span>

<span data-ttu-id="d851c-201">İlk olarak, parser belirli bir tür belirteç bekliyor ancak bulamazsa, belirteç beklenen konumda sözdizimi ağacına eksik bir belirteç ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="d851c-201">First, if the parser expects a particular kind of token but does not find it, it may insert a missing token into the syntax tree in the location that the token was expected.</span></span> <span data-ttu-id="d851c-202">Eksik bir belirteç beklenen gerçek belirteci temsil eder, ancak <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> boş `true`bir açıklığı vardır ve özelliği döndürür.</span><span class="sxs-lookup"><span data-stu-id="d851c-202">A missing token represents the actual token that was expected, but it has an empty span, and its <xref:Microsoft.CodeAnalysis.SyntaxNode.IsMissing?displayProperty=nameWithType> property returns `true`.</span></span>

<span data-ttu-id="d851c-203">İkinci olarak, ayrıştırmaya devam edebileceği bir belirteç ler bulana kadar parser belirteçleri atlayabilir.</span><span class="sxs-lookup"><span data-stu-id="d851c-203">Second, the parser may skip tokens until it finds one where it can continue parsing.</span></span> <span data-ttu-id="d851c-204">Bu durumda, atlanan belirteçleri tür <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>ile bir trivia düğüm olarak eklenir.</span><span class="sxs-lookup"><span data-stu-id="d851c-204">In this case, the skipped tokens are attached as a trivia node with the kind <xref:Microsoft.CodeAnalysis.CSharp.SyntaxKind.SkippedTokensTrivia>.</span></span>
