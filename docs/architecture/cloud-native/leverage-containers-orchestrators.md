---
title: Kapsayıcılardan ve düzenleyicilerden yararlanma
description: Azure 'da Docker kapsayıcılarını ve Kubernetes düzenleyicilerinden yararlanın
ms.date: 05/31/2020
ms.openlocfilehash: b4bdbe5c6b3946658e6c11a40cbbb2feb07cc951
ms.sourcegitcommit: a8a205034eeffc7c3e1bdd6f506a75b0f7099ebf
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/06/2020
ms.locfileid: "91755915"
---
# <a name="leveraging-containers-and-orchestrators"></a><span data-ttu-id="a0174-103">Kapsayıcılardan ve düzenleyicilerden yararlanma</span><span class="sxs-lookup"><span data-stu-id="a0174-103">Leveraging containers and orchestrators</span></span>

<span data-ttu-id="a0174-104">Kapsayıcılar ve düzenleyiciler, tek parçalı dağıtım yaklaşımları için ortak olan sorunları çözmeye yönelik olarak tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a0174-104">Containers and orchestrators are designed to solve problems common to monolithic deployment approaches.</span></span>

## <a name="challenges-with-monolithic-deployments"></a><span data-ttu-id="a0174-105">Tek parçalı dağıtımlar ile ilgili sorunlar</span><span class="sxs-lookup"><span data-stu-id="a0174-105">Challenges with monolithic deployments</span></span>

<span data-ttu-id="a0174-106">Geleneksel olarak, çoğu uygulama tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-106">Traditionally, most applications have been deployed as a single unit.</span></span> <span data-ttu-id="a0174-107">Bu tür uygulamalar tek bir olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-107">Such applications are referred to as a monolith.</span></span> <span data-ttu-id="a0174-108">Bu genel yaklaşım, birden çok modülden oluşsa bile veya derlemeler şekil 3-1 ' de gösterildiği gibi tek parçalı mimari olarak bilinir.</span><span class="sxs-lookup"><span data-stu-id="a0174-108">This general approach of deploying applications as single units even if they're composed of multiple modules or assemblies is known as monolithic architecture, as shown in Figure 3-1.</span></span>

![Tek parçalı mimari.](./media/monolithic-design.png)

<span data-ttu-id="a0174-110">**Şekil 3-1**.</span><span class="sxs-lookup"><span data-stu-id="a0174-110">**Figure 3-1**.</span></span> <span data-ttu-id="a0174-111">Tek parçalı mimari.</span><span class="sxs-lookup"><span data-stu-id="a0174-111">Monolithic architecture.</span></span>

<span data-ttu-id="a0174-112">Basitlik avantajlarına sahip olsalar da tek parçalı mimarilerin bir dizi zorluk yüzü vardır:</span><span class="sxs-lookup"><span data-stu-id="a0174-112">Although they have the benefit of simplicity, monolithic architectures face a number of challenges:</span></span>

### <a name="deployment"></a><span data-ttu-id="a0174-113">Dağıtım</span><span class="sxs-lookup"><span data-stu-id="a0174-113">Deployment</span></span>

<span data-ttu-id="a0174-114">Tek parçalı uygulamalar, yalnızca küçük bir değişiklik yapılmış olsa bile tüm uygulamanın tam dağıtımını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a0174-114">Monolithic applications require a full deployment of the entire application, even if only a small change has been made.</span></span> <span data-ttu-id="a0174-115">Tam dağıtımlar pahalı ve hataya açık olabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-115">Full deployments can be expensive and error prone.</span></span> <span data-ttu-id="a0174-116">Ayrıca, uygulamanın yeniden başlatılması gerekir ve bu, kullanım dışı olarak geçici olarak etkiler.</span><span class="sxs-lookup"><span data-stu-id="a0174-116">Additionally, they require a restart of the application, which temporarily impacts unavailability.</span></span>

### <a name="scaling"></a><span data-ttu-id="a0174-117">Ölçeklendirme</span><span class="sxs-lookup"><span data-stu-id="a0174-117">Scaling</span></span>

<span data-ttu-id="a0174-118">Tek parçalı bir uygulama, genellikle yüksek yetenek donanımlar gerektiren tek bir makine örneğinde barındırılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-118">A monolithic application is hosted entirely on a single machine instance, often requiring high-capability hardware.</span></span> <span data-ttu-id="a0174-119">Tekinin herhangi bir bölümü ölçeklendirmeyi gerektiriyorsa, uygulamanın tamamının başka bir kopyasının başka bir makineye dağıtılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="a0174-119">If any part of the monolith requires scaling, another copy of the entire application must be deployed to another machine.</span></span> <span data-ttu-id="a0174-120">Tek tek, uygulama bileşenlerini ayrı ayrı ölçeklendiremez. Bu, hepsi veya hiçbir şey değildir.</span><span class="sxs-lookup"><span data-stu-id="a0174-120">With a monolith, you can't scale application components individually - it's all or nothing.</span></span> <span data-ttu-id="a0174-121">Ölçeklendirme gerektirmeyen bileşenleri ölçeklendirme, verimsiz ve maliyetli kaynak kullanımı ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="a0174-121">Scaling components that don't require scaling results in inefficient and costly resource usage.</span></span>

### <a name="environment"></a><span data-ttu-id="a0174-122">Ortam</span><span class="sxs-lookup"><span data-stu-id="a0174-122">Environment</span></span>

<span data-ttu-id="a0174-123">Tek parçalı uygulamalar, genellikle önceden yüklenmiş bir işletim sistemi, çalışma zamanı ve kitaplık bağımlılıkları olan bir barındırma ortamına dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-123">Monolithic applications are typically deployed to a hosting environment with a pre-installed operating system, runtime, and library dependencies.</span></span> <span data-ttu-id="a0174-124">Bu ortam, uygulamanın geliştirildiğini veya test edildiğini eşleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-124">This environment may not match that upon which the application was developed or tested.</span></span> <span data-ttu-id="a0174-125">Uygulama ortamları genelinde tutarsızlıklar, tek parçalı dağıtımlar için ortak bir sorun kaynağıdır.</span><span class="sxs-lookup"><span data-stu-id="a0174-125">Inconsistencies across application environments are a common source of problems for monolithic deployments.</span></span>

### <a name="coupling"></a><span data-ttu-id="a0174-126">Bağlantısı</span><span class="sxs-lookup"><span data-stu-id="a0174-126">Coupling</span></span>

<span data-ttu-id="a0174-127">Tek parçalı bir uygulama, işlevsel bileşenleri arasında yüksek bir bağ deneyimlidir.</span><span class="sxs-lookup"><span data-stu-id="a0174-127">A monolithic application is likely to experience high coupling across its functional components.</span></span> <span data-ttu-id="a0174-128">Sabit sınır olmadan sistem değişiklikleri genellikle istenmeden ve pahalı yan etkilere neden olur.</span><span class="sxs-lookup"><span data-stu-id="a0174-128">Without hard boundaries, system changes often result in unintended and costly side effects.</span></span> <span data-ttu-id="a0174-129">Yeni özellikler/düzeltmeler, uygulama için karmaşık, zaman alan ve pahalı hale gelir.</span><span class="sxs-lookup"><span data-stu-id="a0174-129">New features/fixes become tricky, time-consuming, and expensive to implement.</span></span> <span data-ttu-id="a0174-130">Güncelleştirmeler kapsamlı test gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a0174-130">Updates require extensive testing.</span></span> <span data-ttu-id="a0174-131">Ayrıca, geçiş, bileşenleri yeniden düzenleme veya alternatif uygulamalarda değiştirme olanağı da zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="a0174-131">Coupling also makes it difficult to refactor components or swap in alternative implementations.</span></span> <span data-ttu-id="a0174-132">Sıkı bir sorun ayrımı ile oluşturulduğunda bile, tek parçalı kod tabanı olarak ' deki mimari liflik kümeleri, hiçbir zaman sonlandırma "özel durumlar" ile birlikte oluşur.</span><span class="sxs-lookup"><span data-stu-id="a0174-132">Even when constructed with a strict separation of concerns, architectural erosion sets in as the monolithic code base deteriorates with never-ending "special cases."</span></span>

### <a name="platform-lock-in"></a><span data-ttu-id="a0174-133">Platform kilidi-ın</span><span class="sxs-lookup"><span data-stu-id="a0174-133">Platform lock-in</span></span>

<span data-ttu-id="a0174-134">Tek parçalı bir uygulama tek bir teknoloji yığını ile oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a0174-134">A monolithic application is constructed with a single technology stack.</span></span> <span data-ttu-id="a0174-135">Bu taahhüt, bir yeniliği sunarken, yeniliklere bir engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-135">While offering uniformity, this commitment can become a barrier to innovation.</span></span> <span data-ttu-id="a0174-136">Yeni özellikler ve bileşenler, daha modern teknolojiler daha iyi bir seçim olabileceği halde uygulamanın geçerli yığını kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a0174-136">New features and components will be built using the application's current stack - even when more modern technologies may be a better choice.</span></span> <span data-ttu-id="a0174-137">Daha uzun süreli bir risk, teknoloji yığınınızın süresi geçmiş ve kullanım dışı olma sürecinde.</span><span class="sxs-lookup"><span data-stu-id="a0174-137">A longer-term risk is your technology stack becoming outdated and obsolete.</span></span> <span data-ttu-id="a0174-138">Tüm uygulamayı yeni, daha modern bir platforma yeniden tasarlama en iyi maliyetli ve riskli bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="a0174-138">Rearchitecting an entire application to a new, more modern platform is at best expensive and risky.</span></span>

## <a name="what-are-the-benefits-of-containers-and-orchestrators"></a><span data-ttu-id="a0174-139">Kapsayıcıların ve düzenleyicilerinin avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="a0174-139">What are the benefits of containers and orchestrators?</span></span>

<span data-ttu-id="a0174-140">Bölüm 1 ' de kapsayıcılar tanıtıldık.</span><span class="sxs-lookup"><span data-stu-id="a0174-140">We introduced containers in Chapter 1.</span></span> <span data-ttu-id="a0174-141">Cloud Native Bilgi Işlem altyapısı 'nın (CNCF) kapsayıcının bulut Yerel [Izleme haritalarındaki](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) ilk adım olarak nasıl derecelendirmiş olduğunu vurgularız.</span><span class="sxs-lookup"><span data-stu-id="a0174-141">We highlighted how the Cloud Native Computing Foundation (CNCF) ranks containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span> <span data-ttu-id="a0174-142">Bu bölümde, kapsayıcıların avantajları tartışıyoruz.</span><span class="sxs-lookup"><span data-stu-id="a0174-142">In this section, we discuss the benefits of containers.</span></span>

<span data-ttu-id="a0174-143">Docker en popüler kapsayıcı yönetimi platformudur.</span><span class="sxs-lookup"><span data-stu-id="a0174-143">Docker is the most popular container management platform.</span></span> <span data-ttu-id="a0174-144">Hem Linux hem de Windows üzerinde kapsayıcılarla birlikte çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="a0174-144">It works with containers on both Linux or Windows.</span></span> <span data-ttu-id="a0174-145">Kapsayıcılar, her sistemde aynı şekilde çalışan ayrı ancak tekrarlanabilir uygulama ortamları sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-145">Containers provide separate but reproducible application environments that run the same way on any system.</span></span> <span data-ttu-id="a0174-146">Bu boyut, bulutta yerel hizmetler geliştirmek ve barındırmak için ideal hale getirir.</span><span class="sxs-lookup"><span data-stu-id="a0174-146">This aspect makes them perfect for developing and hosting cloud-native services.</span></span> <span data-ttu-id="a0174-147">Kapsayıcılar bir diğerinden yalıtılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a0174-147">Containers are isolated from one another.</span></span> <span data-ttu-id="a0174-148">Aynı konak donanımında iki kapsayıcı, çakışmalara neden olmadan farklı yazılım sürümlerine sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-148">Two containers on the same host hardware can have different versions of software, without causing conflicts.</span></span>

<span data-ttu-id="a0174-149">Kapsayıcılar, proje yapıtları haline gelen ve kaynak denetimine işaretlenmiş basit metin tabanlı dosyalar tarafından tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="a0174-149">Containers are defined by simple text-based files that become project artifacts and are checked into source control.</span></span> <span data-ttu-id="a0174-150">Tam sunucular ve sanal makinelerin güncelleştirilmesi için el ile çaba gerektirmesi durumunda, kapsayıcılar kolayca sürüm denetlenir.</span><span class="sxs-lookup"><span data-stu-id="a0174-150">While full servers and virtual machines require manual effort to update, containers are easily version-controlled.</span></span> <span data-ttu-id="a0174-151">Kapsayıcılarda çalışmak üzere oluşturulan uygulamalar, derleme işlem hattının parçası olarak otomatikleştirilmiş araçlar kullanılarak geliştirilebilir, test edilebilir ve dağıtılabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-151">Apps built to run in containers can be developed, tested, and deployed using automated tools as part of a build pipeline.</span></span>

<span data-ttu-id="a0174-152">Kapsayıcılar sabittir.</span><span class="sxs-lookup"><span data-stu-id="a0174-152">Containers are immutable.</span></span> <span data-ttu-id="a0174-153">Bir kapsayıcı tanımladıktan sonra, tam olarak aynı şekilde yeniden oluşturabilir ve çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-153">Once you define a container, you can recreate and run it exactly the same way.</span></span> <span data-ttu-id="a0174-154">Bu, bu şekilde bileşen tabanlı tasarıma yönelik olarak kullanılabilirlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-154">This immutability lends itself to component-based design.</span></span> <span data-ttu-id="a0174-155">Bir uygulamanın bazı bölümleri diğerlerinden farklı şekilde geliştikçe, en sık değiştiren parçaları yalnızca dağıtırken uygulamanın tamamını yeniden dağıtmanız gerekir mi?</span><span class="sxs-lookup"><span data-stu-id="a0174-155">If some parts of an application evolve differently than others, why redeploy the entire app when you can just deploy the parts that change most frequently?</span></span> <span data-ttu-id="a0174-156">Bir uygulamanın farklı özellikleri ve çapraz kesme sorunları ayrı birimlere ayrılabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-156">Different features and cross-cutting concerns of an app can be broken up into separate units.</span></span> <span data-ttu-id="a0174-157">Şekil 3-2, tek parçalı bir uygulamanın belirli özellikler veya işlevler için kapsayıcılardan ve mikro hizmetlerden nasıl yararlanabileceğiz gösterir.</span><span class="sxs-lookup"><span data-stu-id="a0174-157">Figure 3-2 shows how a monolithic app can take advantage of containers and microservices by delegating certain features or functionality.</span></span> <span data-ttu-id="a0174-158">Uygulamanın kendisindeki diğer işlevsellik de Kapsayıcılı hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-158">The remaining functionality in the app itself has also been containerized.</span></span>

![Arka uçta mikro hizmetleri kullanmak için tek parçalı bir uygulamayı bölmek.](./media/cloud-native-design.png)

<span data-ttu-id="a0174-160">**Şekil 3-2**.</span><span class="sxs-lookup"><span data-stu-id="a0174-160">**Figure 3-2**.</span></span> <span data-ttu-id="a0174-161">Tek parçalı bir uygulamayı, mikro hizmetlere çok parçalı bir uygulama oluşturmayı kaldırma.</span><span class="sxs-lookup"><span data-stu-id="a0174-161">Decomposing a monolithic app to embrace microservices.</span></span>

<span data-ttu-id="a0174-162">Her bulut Yerel hizmeti ayrı bir kapsayıcıda oluşturulup dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-162">Each cloud-native service is built and deployed in a separate container.</span></span> <span data-ttu-id="a0174-163">Her biri gerektiğinde güncelleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-163">Each can update as needed.</span></span> <span data-ttu-id="a0174-164">Her hizmet için uygun kaynakları olan düğümlerde tek tek hizmetler barındırılabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-164">Individual services can be hosted on nodes with resources appropriate to each service.</span></span> <span data-ttu-id="a0174-165">Her hizmetin çalıştığı ortam, geliştirme, test ve üretim ortamlarında paylaşılan ve kolayca sürümlü bir sabittir.</span><span class="sxs-lookup"><span data-stu-id="a0174-165">The environment each service runs in is immutable, shared across dev, test, and production environments, and easily versioned.</span></span> <span data-ttu-id="a0174-166">Uygulamanın farklı alanlarında, tek başına derleme zamanı bağımlılıkları değil, hizmetler arasında doğrudan çağrı veya ileti olarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-166">Coupling between different areas of the application occurs explicitly as calls or messages between services, not compile-time dependencies within the monolith.</span></span> <span data-ttu-id="a0174-167">Ayrıca, uygulamanın geri kalanında değişiklik gerektirmeden belirli bir özelliği en iyi şekilde sunan teknolojiyi de seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-167">You can also choose the technology that best suites a given capability without requiring changes to the rest of the app.</span></span>

<span data-ttu-id="a0174-168">Kapsayıcılı hizmetler otomatik yönetim gerektirir.</span><span class="sxs-lookup"><span data-stu-id="a0174-168">Containerized services require automated management.</span></span> <span data-ttu-id="a0174-169">Bağımsız olarak dağıtılan kapsayıcıların büyük bir kümesini el ile yönetmek mümkün değildir.</span><span class="sxs-lookup"><span data-stu-id="a0174-169">It wouldn't be feasible to manually administer a large set of independently deployed containers.</span></span> <span data-ttu-id="a0174-170">Örneğin, aşağıdaki görevleri göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="a0174-170">For example, consider the following tasks:</span></span>

- <span data-ttu-id="a0174-171">Kapsayıcı örnekleri birçok makinenin bir kümesi arasında nasıl sağlanacak?</span><span class="sxs-lookup"><span data-stu-id="a0174-171">How will container instances be provisioned across a cluster of many machines?</span></span>
- <span data-ttu-id="a0174-172">Dağıtıldıktan sonra kapsayıcılar birbirleriyle nasıl keşfedilir ve birbirleriyle iletişim kurar?</span><span class="sxs-lookup"><span data-stu-id="a0174-172">Once deployed, how will containers discover and communicate with each other?</span></span>
- <span data-ttu-id="a0174-173">Kapsayıcılar isteğe bağlı olarak nasıl ölçeklenebilen veya kullanıma hazır?</span><span class="sxs-lookup"><span data-stu-id="a0174-173">How can containers scale in or out on-demand?</span></span>
- <span data-ttu-id="a0174-174">Her kapsayıcının durumunu nasıl izleyebilirim?</span><span class="sxs-lookup"><span data-stu-id="a0174-174">How do you monitor the health of each container?</span></span>
- <span data-ttu-id="a0174-175">Bir kapsayıcıyı donanım ve yazılım hatalarıyla nasıl koruyabilirim?</span><span class="sxs-lookup"><span data-stu-id="a0174-175">How do you protect a container against hardware and software failures?</span></span>
- <span data-ttu-id="a0174-176">Canlı bir uygulama için kapsayıcıları sıfır kapalı kalma süresiyle nasıl yükseltebilirim?</span><span class="sxs-lookup"><span data-stu-id="a0174-176">How do upgrade containers for a live application with zero downtime?</span></span>

<span data-ttu-id="a0174-177">Kapsayıcı yöneticileri bu ve diğer kaygıları ele alır ve otomatikleştirin.</span><span class="sxs-lookup"><span data-stu-id="a0174-177">Container orchestrators address and automate these and other concerns.</span></span>

<span data-ttu-id="a0174-178">Bulut Yerel ekonomik sistemde, Kubernetes, kapsayıcı Orchestrator ' ı d haline geldi.</span><span class="sxs-lookup"><span data-stu-id="a0174-178">In the cloud-native eco-system, Kubernetes has become the de facto container orchestrator.</span></span> <span data-ttu-id="a0174-179">Bu, bulut Yerel Bilgi Işlem altyapısı (CNCF) tarafından yönetilen açık kaynaklı bir platformdur.</span><span class="sxs-lookup"><span data-stu-id="a0174-179">It's an open-source platform managed by the Cloud Native Computing Foundation (CNCF).</span></span> <span data-ttu-id="a0174-180">Kubernetes, bir makine kümesi içindeki Kapsayıcılı iş yüklerinin dağıtım, ölçeklendirme ve işlevsel sorunlarını otomatikleştirir.</span><span class="sxs-lookup"><span data-stu-id="a0174-180">Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads across a machine cluster.</span></span> <span data-ttu-id="a0174-181">Ancak, Kubernetes 'nin yüklenmesi ve yönetilmesi, önemli bir karmaşıkdır.</span><span class="sxs-lookup"><span data-stu-id="a0174-181">However, installing and managing Kubernetes is notoriously complex.</span></span>

<span data-ttu-id="a0174-182">Daha iyi bir yaklaşım, Kubernetes 'in bir bulut satıcısından yönetilen hizmet olarak faydalanmasıdır.</span><span class="sxs-lookup"><span data-stu-id="a0174-182">A much better approach is to leverage Kubernetes as a managed service from a cloud vendor.</span></span> <span data-ttu-id="a0174-183">Azure bulut, [Azure Kubernetes hizmeti (AKS)](https://azure.microsoft.com/services/kubernetes-service/)ile tam olarak yönetilen bir Kubernetes platformu sunar.</span><span class="sxs-lookup"><span data-stu-id="a0174-183">The Azure cloud features a fully managed Kubernetes platform entitled [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="a0174-184">AKS, Kubernetes yönetiminin karmaşıklık ve operasyonel yükünü soyutlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-184">AKS abstracts the complexity and operational overhead of managing Kubernetes.</span></span> <span data-ttu-id="a0174-185">Kubernetes 'i bir bulut hizmeti olarak kullanırsınız; Microsoft, yönetim ve destekleme sorumluluğunu kullanır.</span><span class="sxs-lookup"><span data-stu-id="a0174-185">You consume Kubernetes as a cloud service; Microsoft takes responsibility for managing and supporting it.</span></span> <span data-ttu-id="a0174-186">AKS, diğer Azure hizmetleri ve geliştirme araçlarıyla da sıkı bir şekilde tümleşir.</span><span class="sxs-lookup"><span data-stu-id="a0174-186">AKS also tightly integrates with other Azure services and dev tools.</span></span>

<span data-ttu-id="a0174-187">AKS, küme temelli bir teknolojidir.</span><span class="sxs-lookup"><span data-stu-id="a0174-187">AKS is a cluster-based technology.</span></span> <span data-ttu-id="a0174-188">Federasyon sanal makineleri veya düğümleri havuzu Azure bulutuna dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-188">A pool of federated virtual machines, or nodes, is deployed to the Azure cloud.</span></span> <span data-ttu-id="a0174-189">Bunlar, yüksek oranda kullanılabilir bir ortam veya küme oluşturur.</span><span class="sxs-lookup"><span data-stu-id="a0174-189">Together they form a highly available environment, or cluster.</span></span> <span data-ttu-id="a0174-190">Küme, bulutta yerel uygulamanıza sorunsuz, tek bir varlık olarak görünür.</span><span class="sxs-lookup"><span data-stu-id="a0174-190">The cluster appears as a seamless, single entity to your cloud-native application.</span></span> <span data-ttu-id="a0174-191">Bu şekilde, AKS 'ler, yükü eşit bir şekilde dağıtan önceden tanımlanmış bir stratejiye göre Kapsayıcılı hizmetlerinizi bu düğümler arasında dağıtır.</span><span class="sxs-lookup"><span data-stu-id="a0174-191">Under the hood, AKS deploys your containerized services across these nodes following a predefined strategy that evenly distributes the load.</span></span>

## <a name="what-are-the-scaling-benefits"></a><span data-ttu-id="a0174-192">Ölçeklendirme avantajları nelerdir?</span><span class="sxs-lookup"><span data-stu-id="a0174-192">What are the scaling benefits?</span></span>

<span data-ttu-id="a0174-193">Kapsayıcılarda oluşturulan hizmetler, Kubernetes gibi Orchestration araçları tarafından sunulan ölçeklendirme avantajlarından yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-193">Services built on containers can leverage scaling benefits provided by orchestration tools like Kubernetes.</span></span> <span data-ttu-id="a0174-194">Tasarım kapsayıcıları tarafından yalnızca kendileri hakkında bilgi sahibi.</span><span class="sxs-lookup"><span data-stu-id="a0174-194">By design containers only know about themselves.</span></span> <span data-ttu-id="a0174-195">Birlikte çalışması gereken birden çok kapsayıcınız varsa, bunları daha yüksek bir düzeyde düzenlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="a0174-195">Once you have multiple containers that need to work together, you should organize them at a higher level.</span></span> <span data-ttu-id="a0174-196">Çok sayıda kapsayıcıyı ve ağ yapılandırması gibi paylaşılan bağımlılıklarını organize etmek, düzenleme araçlarının günü kaydetmek için nereden geldiği yerdir!</span><span class="sxs-lookup"><span data-stu-id="a0174-196">Organizing large numbers of containers and their shared dependencies, such as network configuration, is where orchestration tools come in to save the day!</span></span> <span data-ttu-id="a0174-197">Kubernetes kapsayıcı grupları üzerinde bir soyutlama katmanı oluşturur ve bunları *Pod*olarak düzenler.</span><span class="sxs-lookup"><span data-stu-id="a0174-197">Kubernetes creates an abstraction layer over groups of containers and organizes them into *pods*.</span></span> <span data-ttu-id="a0174-198">*Düğüm*olarak adlandırılan çalışan makinelerdeki pods çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-198">Pods run on worker machines referred to as *nodes*.</span></span> <span data-ttu-id="a0174-199">Bu düzenlenmiş yapı, *küme*olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-199">This organized structure is referred to as a *cluster*.</span></span> <span data-ttu-id="a0174-200">Şekil 3-3, bir Kubernetes kümesinin farklı bileşenlerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="a0174-200">Figure 3-3 shows the different components of a Kubernetes cluster.</span></span>

<span data-ttu-id="a0174-201">![Kubernetes kümesi bileşenleri. ](./media/kubernetes-cluster-components.png)
 **Şekil 3-3**.</span><span class="sxs-lookup"><span data-stu-id="a0174-201">![Kubernetes cluster components.](./media/kubernetes-cluster-components.png)
**Figure 3-3**.</span></span> <span data-ttu-id="a0174-202">Kubernetes kümesi bileşenleri.</span><span class="sxs-lookup"><span data-stu-id="a0174-202">Kubernetes cluster components.</span></span>

<span data-ttu-id="a0174-203">Kapsayıcılı iş yüklerinin ölçeklendirilmesi, kapsayıcı düzenleyicilerinin temel bir özelliğidir.</span><span class="sxs-lookup"><span data-stu-id="a0174-203">Scaling containerized workloads is a key feature of container orchestrators.</span></span> <span data-ttu-id="a0174-204">AKS iki boyut genelinde otomatik ölçeklendirmeyi destekler: kapsayıcı örnekleri ve işlem düğümleri.</span><span class="sxs-lookup"><span data-stu-id="a0174-204">AKS supports automatic scaling across two dimensions: Container instances and compute nodes.</span></span> <span data-ttu-id="a0174-205">Birlikte, isteğe bağlı olarak ani artışları hızla ve verimli bir şekilde yanıtlama ve ek kaynaklar ekleme olanağı sunar.</span><span class="sxs-lookup"><span data-stu-id="a0174-205">Together they give AKS the ability to quickly and efficiently respond to spikes in demand and add additional resources.</span></span> <span data-ttu-id="a0174-206">Bu bölümün ilerleyen kısımlarında, ölçeklendirilirken ölçeklendirmeyi tartıştık.</span><span class="sxs-lookup"><span data-stu-id="a0174-206">We discuss scaling in AKS later in this chapter.</span></span>

### <a name="declarative-versus-imperative"></a><span data-ttu-id="a0174-207">Bildirime dayalı ve kesinlik</span><span class="sxs-lookup"><span data-stu-id="a0174-207">Declarative versus imperative</span></span>

<span data-ttu-id="a0174-208">Kubernetes hem bildirime dayalı hem de kesinlik temelli yapılandırmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="a0174-208">Kubernetes supports both declarative and imperative configuration.</span></span> <span data-ttu-id="a0174-209">Zorunlu yaklaşım, Kubernetes 'in her adımın nasıl yapılacağını söyleyen çeşitli komutları çalıştırmayı içerir.</span><span class="sxs-lookup"><span data-stu-id="a0174-209">The imperative approach involves running various commands that tell Kubernetes what to do each step of the way.</span></span> <span data-ttu-id="a0174-210">Bu görüntüyü çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="a0174-210">Run this image.</span></span> <span data-ttu-id="a0174-211">Bu Pod öğesini silin.</span><span class="sxs-lookup"><span data-stu-id="a0174-211">Delete this pod.</span></span> <span data-ttu-id="a0174-212">Bu bağlantı noktasını kullanıma sunun.</span><span class="sxs-lookup"><span data-stu-id="a0174-212">Expose this port.</span></span> <span data-ttu-id="a0174-213">Bildirim temelli yaklaşımla, ne yapmak istediğinizi belirlemek için bildirim olarak adlandırılan bir yapılandırma dosyası oluşturursunuz.</span><span class="sxs-lookup"><span data-stu-id="a0174-213">With the declarative approach, you create a configuration file, called a manifest, to describe what you want instead of what to do.</span></span> <span data-ttu-id="a0174-214">Kubernetes bildirimi okur ve istediğiniz bitiş durumunu gerçek bitiş durumuna dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="a0174-214">Kubernetes reads the manifest and transforms your desired end state into actual end state.</span></span>

<span data-ttu-id="a0174-215">Zorunlu komutların öğrenimi ve etkileşimli deneme için harika olması.</span><span class="sxs-lookup"><span data-stu-id="a0174-215">Imperative commands are great for learning and interactive experimentation.</span></span> <span data-ttu-id="a0174-216">Ancak, güvenilir ve tekrarlanabilir dağıtımlar sağlayan bir altyapıyı kod yaklaşımı olarak ayraç içine almak için, bildirimli olarak Kubernetes bildirim dosyalarını oluşturmak isteyeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-216">However, you'll want to declaratively create Kubernetes manifest files to embrace an infrastructure as code approach, providing for reliable and repeatable deployments.</span></span> <span data-ttu-id="a0174-217">Bildirim dosyası bir proje yapıtı haline gelir ve Kubernetes dağıtımlarını otomatikleştirmek için CI/CD işlem hattınızda kullanılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-217">The manifest file becomes a project artifact and is used in your CI/CD pipeline for automating Kubernetes deployments.</span></span>

<span data-ttu-id="a0174-218">Kümenizi tanımlayıcı komutları kullanarak zaten yapılandırdıysanız, kullanarak bildirim temelli bir bildirimi dışarı aktarabilirsiniz `kubectl get svc SERVICENAME -o yaml > service.yaml` .</span><span class="sxs-lookup"><span data-stu-id="a0174-218">If you've already configured your cluster using imperative commands, you can export a declarative manifest by using `kubectl get svc SERVICENAME -o yaml > service.yaml`.</span></span> <span data-ttu-id="a0174-219">Bu komut aşağıda gösterilene benzer bir bildirim üretir:</span><span class="sxs-lookup"><span data-stu-id="a0174-219">This command produces a manifest similar to one shown below:</span></span>

```yaml
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: "2019-09-13T13:58:47Z"
  labels:
    component: apiserver
    provider: kubernetes
  name: kubernetes
  namespace: default
  resourceVersion: "153"
  selfLink: /api/v1/namespaces/default/services/kubernetes
  uid: 9b1fac62-d62e-11e9-8968-00155d38010d
spec:
  clusterIP: 10.96.0.1
  ports:
  - name: https
    port: 443
    protocol: TCP
    targetPort: 6443
  sessionAffinity: None
  type: ClusterIP
status:
  loadBalancer: {}
```

<span data-ttu-id="a0174-220">Bildirim temelli yapılandırma kullanırken, `kubectl diff -f FOLDERNAME` yapılandırma dosyalarınızın bulunduğu klasöre karşı uygulamadan önce yapılacak değişikliklerin önizlemesini yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-220">When using declarative configuration, you can preview the changes that will be made before committing them by using `kubectl diff -f FOLDERNAME` against the folder where your configuration files are located.</span></span> <span data-ttu-id="a0174-221">Değişiklikleri uygulamak istediğinize emin olduktan sonra çalıştırın `kubectl apply -f FOLDERNAME` .</span><span class="sxs-lookup"><span data-stu-id="a0174-221">Once you're sure you want to apply the changes, run `kubectl apply -f FOLDERNAME`.</span></span> <span data-ttu-id="a0174-222">`-R`Bir klasör hiyerarşisini yinelemeli olarak işlemeye ekleyin.</span><span class="sxs-lookup"><span data-stu-id="a0174-222">Add `-R` to recursively process a folder hierarchy.</span></span>

<span data-ttu-id="a0174-223">Ayrıca, biri dağıtımları olan diğer Kubernetes özellikleriyle bildirim temelli yapılandırma de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-223">You can also use declarative configuration with other Kubernetes features, one of which being deployments.</span></span> <span data-ttu-id="a0174-224">Bildirim temelli dağıtımlar, yayınları, güncelleştirmeleri ve ölçeklendirmeyi yönetmeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="a0174-224">Declarative deployments help manage releases, updates, and scaling.</span></span> <span data-ttu-id="a0174-225">Bu kişiler, Kubernetes dağıtım denetleyicisine yeni değişiklikler dağıtma, yük genişletme veya önceki bir düzeltmeye geri dönme işlemlerini yönlendirir.</span><span class="sxs-lookup"><span data-stu-id="a0174-225">They instruct the Kubernetes deployment controller on how to deploy new changes, scale out load, or roll back to a previous revision.</span></span> <span data-ttu-id="a0174-226">Bir küme kararsız durumdaysa, bildirime dayalı bir dağıtım otomatik olarak kümeyi istenen duruma geri döndürür.</span><span class="sxs-lookup"><span data-stu-id="a0174-226">If a cluster is unstable, a declarative deployment will automatically return the cluster back to a desired state.</span></span> <span data-ttu-id="a0174-227">Örneğin, bir düğüm kilitlenmelidir, dağıtım mekanizması istediğiniz duruma ulaşmak için bir değişikliği yeniden dağıtırsınız</span><span class="sxs-lookup"><span data-stu-id="a0174-227">For example, if a node should crash, the deployment mechanism will redeploy a replacement to achieve your desired state</span></span>

<span data-ttu-id="a0174-228">Bildirim temelli yapılandırma kullanmak, altyapının uygulama kodu ile birlikte denetlenebilen ve sürümü oluşturulmuş bir kod olarak temsil etmesine olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="a0174-228">Using declarative configuration allows infrastructure to be represented as code that can be checked in and versioned alongside the application code.</span></span> <span data-ttu-id="a0174-229">Yapı ve dağıtım işlem hattı kullanarak sürekli dağıtım için geliştirilmiş değişiklik denetimi ve daha iyi destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-229">It provides improved change control and better support for continuous deployment using a build and deploy pipeline.</span></span>

## <a name="what-scenarios-are-ideal-for-containers-and-orchestrators"></a><span data-ttu-id="a0174-230">Kapsayıcılar ve düzenleyiciler için hangi senaryolar idealdir?</span><span class="sxs-lookup"><span data-stu-id="a0174-230">What scenarios are ideal for containers and orchestrators?</span></span>

<span data-ttu-id="a0174-231">Aşağıdaki senaryolar kapsayıcıları ve düzenlemeleri kullanmak için idealdir.</span><span class="sxs-lookup"><span data-stu-id="a0174-231">The following scenarios are ideal for using containers and orchestrators.</span></span>

### <a name="applications-requiring-high-uptime-and-scalability"></a><span data-ttu-id="a0174-232">Yüksek çalışma süresi ve ölçeklenebilirlik gerektiren uygulamalar</span><span class="sxs-lookup"><span data-stu-id="a0174-232">Applications requiring high uptime and scalability</span></span>

<span data-ttu-id="a0174-233">Yüksek çalışma süresi ve ölçeklenebilirlik gereksinimleri olan bireysel uygulamalar, mikro hizmetler, kapsayıcılar ve düzenleyicilerin kullanıldığı bulutta yerel mimariler için ideal adaylardır.</span><span class="sxs-lookup"><span data-stu-id="a0174-233">Individual applications that have high uptime and scalability requirements are ideal candidates for cloud-native architectures using microservices, containers, and orchestrators.</span></span> <span data-ttu-id="a0174-234">Bunlar kapsayıcılarda geliştirilir, sürümlü ortamlar arasında test edilebilir ve sıfır kapalı kalma süresiyle üretime dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="a0174-234">They can be developed in containers, tested across versioned environments, and deployed into production with zero downtime.</span></span> <span data-ttu-id="a0174-235">Kubernetes kümelerinin kullanımı, bu tür uygulamaların talep üzerine ölçeklenmesini ve düğüm hatalarından otomatik olarak kurtarılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-235">The use of Kubernetes clusters ensures such apps can also scale on demand and recover automatically from node failures.</span></span>

### <a name="large-numbers-of-applications"></a><span data-ttu-id="a0174-236">Çok sayıda uygulama</span><span class="sxs-lookup"><span data-stu-id="a0174-236">Large numbers of applications</span></span>

<span data-ttu-id="a0174-237">Çok sayıda uygulamayı dağıtan ve bunları yöneten kuruluşlar, kapsayıcılardan ve düzenleyicilerinden faydalanır.</span><span class="sxs-lookup"><span data-stu-id="a0174-237">Organizations that deploy and maintain large numbers of applications benefit from containers and orchestrators.</span></span> <span data-ttu-id="a0174-238">Kapsayıcılı ortamları ve Kubernetes kümelerini ayarlamanın en ön çabası, birincil olarak sabit bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="a0174-238">The up front effort of setting up containerized environments and Kubernetes clusters is primarily a fixed cost.</span></span> <span data-ttu-id="a0174-239">Bireysel uygulamaların dağıtımı, sürdürülmesi ve güncelleştirilmesi, uygulama sayısıyla değişen bir maliyettir.</span><span class="sxs-lookup"><span data-stu-id="a0174-239">Deploying, maintaining, and updating individual applications has a cost that varies with the number of applications.</span></span> <span data-ttu-id="a0174-240">Az sayıda uygulamanın ötesinde, özel uygulamaları korumanın karmaşıklığı kapsayıcıları ve düzenlemeleri kullanarak bir çözüm uygulama masrafını daha da aşıyor.</span><span class="sxs-lookup"><span data-stu-id="a0174-240">Beyond a small number of applications, the complexity of maintaining custom applications manually exceeds the cost of implementing a solution using containers and orchestrators.</span></span>

## <a name="when-should-you-avoid-using-containers-and-orchestrators"></a><span data-ttu-id="a0174-241">Kapsayıcıları ve düzenlemeleri kullanmaktan ne zaman kaçınmalısınız?</span><span class="sxs-lookup"><span data-stu-id="a0174-241">When should you avoid using containers and orchestrators?</span></span>

<span data-ttu-id="a0174-242">Uygulamanızı on Iki öğeli uygulama ilkelerine göre derlemenize izin verirseniz kapsayıcılardan ve düzenleyicilerinin önlenmemesini göz önünde bulundurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="a0174-242">If you're unable to build your application following the Twelve-Factor App principles, you should consider avoiding containers and orchestrators.</span></span> <span data-ttu-id="a0174-243">Bu durumlarda, VM tabanlı bir barındırma platformunu veya büyük olasılıkla bazı karma sistemleri göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="a0174-243">In these cases, consider a VM-based hosting platform, or possibly some hybrid system.</span></span> <span data-ttu-id="a0174-244">Bununla birlikte, belirli işlevsellik parçalarını her zaman ayrı kapsayıcılara veya hatta sunucusuz işlevlere ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-244">With it, you can always spin off certain pieces of functionality into separate containers or even serverless functions.</span></span>

## <a name="development-resources"></a><span data-ttu-id="a0174-245">Geliştirme kaynakları</span><span class="sxs-lookup"><span data-stu-id="a0174-245">Development resources</span></span>

<span data-ttu-id="a0174-246">Bu bölümde, bir sonraki uygulamanız için kapsayıcıları ve düzenlemeleri kullanmaya başlamanıza yardımcı olabilecek geliştirme kaynaklarının kısa bir listesi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="a0174-246">This section shows a short list of development resources that may help you get started using containers and orchestrators for your next application.</span></span> <span data-ttu-id="a0174-247">Bulut Yerel mikro hizmetleri mimari uygulamanızı nasıl tasarlayacağımızı öğrenmek istiyorsanız bu kitabın yardımcı, [.net mikro hizmetleri: Kapsayıcılı .NET uygulamaları Için mimari](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook)makalesini okuyun.</span><span class="sxs-lookup"><span data-stu-id="a0174-247">If you're looking for guidance on how to design your cloud-native microservices architecture app, read this book's companion, [.NET Microservices: Architecture for Containerized .NET Applications](https://dotnet.microsoft.com/download/thank-you/microservices-architecture-ebook).</span></span>

### <a name="local-kubernetes-development"></a><span data-ttu-id="a0174-248">Yerel Kubernetes geliştirme</span><span class="sxs-lookup"><span data-stu-id="a0174-248">Local Kubernetes Development</span></span>

<span data-ttu-id="a0174-249">Kubernetes dağıtımları üretim ortamlarında harika bir değer sağlar, ancak geliştirme makinenizde yerel olarak da çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-249">Kubernetes deployments provide great value in production environments, but can also run locally on your development machine.</span></span> <span data-ttu-id="a0174-250">Bağımsız mikro hizmetlerde bağımsız olarak çalışabilir, ancak üretime dağıtıldığında çalıştırılacak şekilde tüm sistemi yerel olarak çalıştırmanız gereken zamanlar olabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-250">While you may work on individual microservices independently, there may be times when you'll need to run the entire system locally - just as it will run when deployed to production.</span></span> <span data-ttu-id="a0174-251">Yardımcı olabilecek çeşitli araçlar vardır: Minikube ve Docker Desktop.</span><span class="sxs-lookup"><span data-stu-id="a0174-251">There are several tools that can help: Minikube and Docker Desktop.</span></span> <span data-ttu-id="a0174-252">Visual Studio, Docker geliştirmesi için de araç sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-252">Visual Studio also provides tooling for Docker development.</span></span>

### <a name="minikube"></a><span data-ttu-id="a0174-253">Minikube</span><span class="sxs-lookup"><span data-stu-id="a0174-253">Minikube</span></span>

<span data-ttu-id="a0174-254">Minikube nedir?</span><span class="sxs-lookup"><span data-stu-id="a0174-254">What is Minikube?</span></span> <span data-ttu-id="a0174-255">Minikube projesi, "Minikube macOS, Linux ve Windows üzerinde yerel bir Kubernetes kümesi uygular" diyor.</span><span class="sxs-lookup"><span data-stu-id="a0174-255">The Minikube project says "Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows."</span></span> <span data-ttu-id="a0174-256">Birincil hedefleri, "yerel Kubernetes uygulama geliştirmesi için en iyi araç olacak ve sığan Kubernetes özelliklerini desteklemeye yöneliktir."</span><span class="sxs-lookup"><span data-stu-id="a0174-256">Its primary goals are "to be the best tool for local Kubernetes application development and to support all Kubernetes features that fit."</span></span> <span data-ttu-id="a0174-257">Minikube yükleme Docker 'dan ayrıdır, ancak Minikube, Docker Desktop 'ın desteklediğinden farklı hiper yöneticileri destekler.</span><span class="sxs-lookup"><span data-stu-id="a0174-257">Installing Minikube is separate from Docker, but Minikube supports different hypervisors than Docker Desktop supports.</span></span> <span data-ttu-id="a0174-258">Aşağıdaki Kubernetes özellikleri şu anda Minikube tarafından desteklenmektedir:</span><span class="sxs-lookup"><span data-stu-id="a0174-258">The following Kubernetes features are currently supported by Minikube:</span></span>

- <span data-ttu-id="a0174-259">DNS</span><span class="sxs-lookup"><span data-stu-id="a0174-259">DNS</span></span>
- <span data-ttu-id="a0174-260">NodePorts</span><span class="sxs-lookup"><span data-stu-id="a0174-260">NodePorts</span></span>
- <span data-ttu-id="a0174-261">ConfigMaps ve gizlilikler</span><span class="sxs-lookup"><span data-stu-id="a0174-261">ConfigMaps and secrets</span></span>
- <span data-ttu-id="a0174-262">Panolar</span><span class="sxs-lookup"><span data-stu-id="a0174-262">Dashboards</span></span>
- <span data-ttu-id="a0174-263">Kapsayıcı çalışma zamanları: Docker, RKT, CRı-O ve containerd</span><span class="sxs-lookup"><span data-stu-id="a0174-263">Container runtimes: Docker, rkt, CRI-O, and containerd</span></span>
- <span data-ttu-id="a0174-264">Kapsayıcı ağ arabirimini etkinleştirme (CNı)</span><span class="sxs-lookup"><span data-stu-id="a0174-264">Enabling Container Network Interface (CNI)</span></span>
- <span data-ttu-id="a0174-265">Giriş</span><span class="sxs-lookup"><span data-stu-id="a0174-265">Ingress</span></span>

<span data-ttu-id="a0174-266">Minikube yükledikten sonra, `minikube start` bir görüntüyü yükleyen ve yerel Kubernetes kümesini Başlatan komutunu çalıştırarak hızlı bir şekilde kullanmaya başlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-266">After installing Minikube, you can quickly start using it by running the `minikube start` command, which downloads an image and start the local Kubernetes cluster.</span></span> <span data-ttu-id="a0174-267">Küme başlatıldıktan sonra, standart Kubernetes komutlarını kullanarak onunla etkileşime geçin `kubectl` .</span><span class="sxs-lookup"><span data-stu-id="a0174-267">Once the cluster is started, you interact with it using the standard Kubernetes `kubectl` commands.</span></span>

### <a name="docker-desktop"></a><span data-ttu-id="a0174-268">Docker Masaüstü</span><span class="sxs-lookup"><span data-stu-id="a0174-268">Docker Desktop</span></span>

<span data-ttu-id="a0174-269">Ayrıca, Kubernetes ile doğrudan Windows 'daki Docker Desktop 'tan da çalışabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-269">You can also work with Kubernetes directly from Docker Desktop on Windows.</span></span> <span data-ttu-id="a0174-270">Windows kapsayıcıları kullanıyorsanız tek seçeneğiniz vardır ve Windows dışı kapsayıcılar için harika bir seçimdir.</span><span class="sxs-lookup"><span data-stu-id="a0174-270">It is your only option if you're using Windows Containers, and is a great choice for non-Windows containers as well.</span></span> <span data-ttu-id="a0174-271">Şekil 3-4, Docker Desktop çalıştırılırken yerel Kubernetes desteğinin nasıl etkinleştirileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="a0174-271">Figure 3-4 shows how to enable local Kubernetes support when running Docker Desktop.</span></span>

![Docker Desktop 'ta Kubernetes 'i yapılandırma](./media/docker-desktop-kubernetes.png)

<span data-ttu-id="a0174-273">**Şekil 3-4**.</span><span class="sxs-lookup"><span data-stu-id="a0174-273">**Figure 3-4**.</span></span> <span data-ttu-id="a0174-274">Docker Desktop 'ta Kubernetes 'i yapılandırma.</span><span class="sxs-lookup"><span data-stu-id="a0174-274">Configuring Kubernetes in Docker Desktop.</span></span>

<span data-ttu-id="a0174-275">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak yapılandırmaya ve çalıştırmaya yönelik en popüler araçtır.</span><span class="sxs-lookup"><span data-stu-id="a0174-275">Docker Desktop is the most popular tool for configuring and running containerized apps locally.</span></span> <span data-ttu-id="a0174-276">Docker Desktop ile çalışırken, üretime dağıtacağınız Docker kapsayıcı görüntüleri kümesine göre yerel olarak geliştirme yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-276">When you work with Docker Desktop, you can develop locally against the exact same set of Docker container images that you'll deploy to production.</span></span> <span data-ttu-id="a0174-277">Docker Desktop, Kapsayıcılı uygulamaları yerel olarak derlemek, test etmek ve teslim etmek üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="a0174-277">Docker Desktop is designed to "build, test, and ship" containerized apps locally.</span></span> <span data-ttu-id="a0174-278">Hem Linux hem de Windows kapsayıcılarını destekler.</span><span class="sxs-lookup"><span data-stu-id="a0174-278">It supports both Linux and Windows containers.</span></span> <span data-ttu-id="a0174-279">Görüntülerinizi Azure Container Registry veya Docker Hub gibi bir görüntü kayıt defterine gönderdikten sonra AKS 'ler onları üretime çekebilir ve bunları dağıtabilir.</span><span class="sxs-lookup"><span data-stu-id="a0174-279">Once you push your images to an image registry, like Azure Container Registry or Docker Hub, AKS can pull and deploy them to production.</span></span>

### <a name="visual-studio-docker-tooling"></a><span data-ttu-id="a0174-280">Visual Studio Docker Araçları</span><span class="sxs-lookup"><span data-stu-id="a0174-280">Visual Studio Docker Tooling</span></span>

<span data-ttu-id="a0174-281">Visual Studio, Web tabanlı uygulamalar için Docker geliştirmeyi destekler.</span><span class="sxs-lookup"><span data-stu-id="a0174-281">Visual Studio supports Docker development for web-based applications.</span></span> <span data-ttu-id="a0174-282">Yeni bir ASP.NET Core uygulaması oluşturduğunuzda, Şekil 3-5 ' de gösterildiği gibi, Docker desteğiyle yapılandırma seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="a0174-282">When you create a new ASP.NET Core application, you have an option to configure it with Docker support, as shown in Figure 3-5.</span></span>

![Visual Studio Docker desteğini etkinleştir](./media/visual-studio-enable-docker-support.png)

<span data-ttu-id="a0174-284">**Şekil 3-5**.</span><span class="sxs-lookup"><span data-stu-id="a0174-284">**Figure 3-5**.</span></span> <span data-ttu-id="a0174-285">Visual Studio Docker desteğini etkinleştir</span><span class="sxs-lookup"><span data-stu-id="a0174-285">Visual Studio Enable Docker Support</span></span>

<span data-ttu-id="a0174-286">Bu seçenek belirlendiğinde proje, bir `Dockerfile` Docker kapsayıcısında uygulamayı derlemek ve barındırmak için kullanılabilen bir kökünde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="a0174-286">When this option is selected, the project is created with a `Dockerfile` in its root, which can be used to build and host the app in a Docker container.</span></span> <span data-ttu-id="a0174-287">Şekil 3 -6. git 'de örnek bir Dockerfile gösterilmektedir</span><span class="sxs-lookup"><span data-stu-id="a0174-287">An example Dockerfile is shown in Figure 3-6.git</span></span>

```dockerfile
FROM mcr.microsoft.com/dotnet/core/aspnet:3.1-buster-slim AS base
WORKDIR /app
EXPOSE 80
EXPOSE 443

FROM mcr.microsoft.com/dotnet/core/sdk:3.1-buster AS build
WORKDIR /src
COPY ["eShopWeb/eShopWeb.csproj", "eShopWeb/"]
RUN dotnet restore "eShopWeb/eShopWeb.csproj"
COPY . .
WORKDIR "/src/eShopWeb"
RUN dotnet build "eShopWeb.csproj" -c Release -o /app/build

FROM build AS publish
RUN dotnet publish "eShopWeb.csproj" -c Release -o /app/publish

FROM base AS final
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "eShopWeb.dll"]
```

<span data-ttu-id="a0174-288">**Şekil 3-6**.</span><span class="sxs-lookup"><span data-stu-id="a0174-288">**Figure 3-6**.</span></span> <span data-ttu-id="a0174-289">Visual Studio tarafından oluşturulan Dockerfile</span><span class="sxs-lookup"><span data-stu-id="a0174-289">Visual Studio generated Dockerfile</span></span>

<span data-ttu-id="a0174-290">Uygulamanın çalışması için varsayılan davranış, Docker 'ı kullanmak üzere yapılandırılmıştır.</span><span class="sxs-lookup"><span data-stu-id="a0174-290">The default behavior when the app runs is configured to use Docker as well.</span></span> <span data-ttu-id="a0174-291">Şekil 3-7, Docker desteği eklenmiş şekilde oluşturulan yeni bir ASP.NET Core projesinden kullanılabilir farklı çalıştırma seçeneklerini gösterir.</span><span class="sxs-lookup"><span data-stu-id="a0174-291">Figure 3-7 shows the different run options available from a new ASP.NET Core project created with Docker support added.</span></span>

![Visual Studio Docker çalıştırma seçenekleri](./media/visual-studio-docker-run-options.png)

<span data-ttu-id="a0174-293">**Şekil 3-7**.</span><span class="sxs-lookup"><span data-stu-id="a0174-293">**Figure 3-7**.</span></span> <span data-ttu-id="a0174-294">Visual Studio Docker çalıştırma seçenekleri</span><span class="sxs-lookup"><span data-stu-id="a0174-294">Visual Studio Docker Run Options</span></span>

<span data-ttu-id="a0174-295">[Azure dev Spaces](/azure/dev-spaces/) , yerel geliştirmeye ek olarak, birden çok geliştiricinin Azure 'Da kendi Kubernetes yapılandırmalarına göre çalışması için kullanışlı bir yol sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-295">In addition to local development, [Azure Dev Spaces](/azure/dev-spaces/) provides a convenient way for multiple developers to work with their own Kubernetes configurations within Azure.</span></span> <span data-ttu-id="a0174-296">Şekil 3-7 ' de görebileceğiniz gibi, uygulamayı Azure Dev Spaces de çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-296">As you can see in Figure 3-7, you can also run the application in Azure Dev Spaces.</span></span>

<span data-ttu-id="a0174-297">Ayrıca, dilediğiniz zaman mevcut bir ASP.NET Core uygulamasına Docker desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-297">Also, at any time you can add Docker support to an existing ASP.NET Core application.</span></span> <span data-ttu-id="a0174-298">Visual Studio Çözüm Gezgini, Şekil 3-8 ' de gösterildiği gibi projeye sağ tıklayın ve **Add**  >  **Docker desteği**Ekle ' yi seçin.</span><span class="sxs-lookup"><span data-stu-id="a0174-298">From the Visual Studio Solution Explorer, right-click on the project and select **Add** > **Docker Support**, as shown in Figure 3-8.</span></span>

![Visual Studio Docker desteği ekle](./media/visual-studio-add-docker-support.png)

<span data-ttu-id="a0174-300">**Şekil 3-8**.</span><span class="sxs-lookup"><span data-stu-id="a0174-300">**Figure 3-8**.</span></span> <span data-ttu-id="a0174-301">Visual Studio 'ya Docker desteği ekleme</span><span class="sxs-lookup"><span data-stu-id="a0174-301">Adding Docker support to Visual Studio</span></span>

<span data-ttu-id="a0174-302">Ayrıca şekil 3-8 ' de gösterilen kapsayıcı düzenleme desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="a0174-302">You can also add Container Orchestration Support, also shown in Figure 3-8.</span></span> <span data-ttu-id="a0174-303">Varsayılan olarak Orchestrator, Kubernetes ve Held kullanır.</span><span class="sxs-lookup"><span data-stu-id="a0174-303">By default, the orchestrator uses Kubernetes and Helm.</span></span> <span data-ttu-id="a0174-304">Orchestrator 'ı seçtikten sonra `azds.yaml` Proje köküne bir dosya eklenir ve `charts` uygulamayı yapılandırmak ve Kubernetes 'e dağıtmak Için kullanılan helk grafiklerini içeren bir klasör eklenir.</span><span class="sxs-lookup"><span data-stu-id="a0174-304">Once you've chosen the orchestrator, a `azds.yaml` file is added to the project root and a `charts` folder is added containing the Helm charts used to configure and deploy the application to Kubernetes.</span></span> <span data-ttu-id="a0174-305">Şekil 3-9 yeni bir projedeki sonuç dosyalarını gösterir.</span><span class="sxs-lookup"><span data-stu-id="a0174-305">Figure 3-9 shows the resulting files in a new project.</span></span>

![Visual Studio Orchestrator desteği ekle](./media/visual-studio-add-orchestrator-support.png)

<span data-ttu-id="a0174-307">**Şekil 3-9**.</span><span class="sxs-lookup"><span data-stu-id="a0174-307">**Figure 3-9**.</span></span> <span data-ttu-id="a0174-308">Visual Studio 'ya düzenleme desteği ekleme</span><span class="sxs-lookup"><span data-stu-id="a0174-308">Adding orchestration support to Visual Studio</span></span>

### <a name="visual-studio-code-docker-tooling"></a><span data-ttu-id="a0174-309">Docker Tooling Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="a0174-309">Visual Studio Code Docker Tooling</span></span>

<span data-ttu-id="a0174-310">Docker geliştirmeyi destekleyen Visual Studio Code için kullanılabilen birçok uzantı vardır.</span><span class="sxs-lookup"><span data-stu-id="a0174-310">There are a number of extensions available for Visual Studio Code that support Docker development.</span></span>

<span data-ttu-id="a0174-311">Microsoft, [Visual Studio Code uzantısı Için Docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker)sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-311">Microsoft provides the [Docker for Visual Studio Code extension](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).</span></span> <span data-ttu-id="a0174-312">Bu uzantı, uygulamalara kapsayıcı desteği ekleme sürecini basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="a0174-312">This extension simplifies the process of adding container support to applications.</span></span> <span data-ttu-id="a0174-313">Gerekli dosyaları, Docker görüntülerini oluşturur ve bir kapsayıcı içinde uygulamanızın hatalarını ayıklamanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="a0174-313">It scaffolds required files, builds Docker images, and enables you to debug your app inside a container.</span></span> <span data-ttu-id="a0174-314">Uzantı; başlatma, durdurma, İnceleme, kaldırma ve daha fazlasını içeren kapsayıcılar ve görüntüler üzerinde işlem yapmayı kolaylaştıran bir görsel gezgin sunar.</span><span class="sxs-lookup"><span data-stu-id="a0174-314">The extension features a visual explorer that makes it easy to take actions on containers and images such as start, stop, inspect, remove, and more.</span></span> <span data-ttu-id="a0174-315">Uzantı Ayrıca birden çok çalışan kapsayıcıyı tek bir birim olarak yönetmenizi sağlayan Docker Compose destekler.</span><span class="sxs-lookup"><span data-stu-id="a0174-315">The extension also supports Docker Compose enabling you to manage multiple running containers as a single unit.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a0174-316">[Önceki](scale-applications.md) 
> [Sonraki](leverage-serverless-functions.md)</span><span class="sxs-lookup"><span data-stu-id="a0174-316">[Previous](scale-applications.md)
[Next](leverage-serverless-functions.md)</span></span>
