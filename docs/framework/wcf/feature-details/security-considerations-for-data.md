---
description: 'Hakkında daha fazla bilgi edinin: veriler için güvenlik konuları'
title: Veriler için Güvenlik Konuları
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: a7eb98da-4a93-4692-8b59-9d670c79ffb2
ms.openlocfilehash: 6e0bf681ad8dd141ad030ef850c3e50c1d6e65c8
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99632626"
---
# <a name="security-considerations-for-data"></a><span data-ttu-id="f6ecb-103">Veriler için Güvenlik Konuları</span><span class="sxs-lookup"><span data-stu-id="f6ecb-103">Security Considerations for Data</span></span>

<span data-ttu-id="f6ecb-104">Windows Communication Foundation (WCF) içindeki verilerle ilgilenirken, bir dizi tehdit kategorisini göz önünde bulundurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-104">When dealing with data in Windows Communication Foundation (WCF), you must consider a number of threat categories.</span></span> <span data-ttu-id="f6ecb-105">Aşağıdaki listede, veri işlemeyle ilgili en önemli tehdit sınıfları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-105">The following list shows the most important threat classes that relate to data processing.</span></span> <span data-ttu-id="f6ecb-106">WCF, bu tehditleri hafifletmek için araçlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-106">WCF provides tools to mitigate these threats.</span></span>

* <span data-ttu-id="f6ecb-107">Hizmet reddi</span><span class="sxs-lookup"><span data-stu-id="f6ecb-107">Denial of service</span></span>

  <span data-ttu-id="f6ecb-108">Güvenilmeyen veriler alınırken, veriler, alıcı tarafın bellek, iş parçacıkları, kullanılabilir bağlantılar veya işlemci döngüleri gibi uzun hesaplamalar oluşmasına neden olacak şekilde orantısız miktarına erişmesini sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-108">When receiving untrusted data, the data may cause the receiving side to access a disproportionate amount of various resources, such as memory, threads, available connections, or processor cycles by causing lengthy computations.</span></span> <span data-ttu-id="f6ecb-109">Bir sunucuya yönelik bir hizmet reddi saldırısı, çökmesine ve diğer, meşru istemcilerden gelen iletileri işleyememesine neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-109">A denial-of-service attack against a server may cause it to crash and be unable to process messages from other, legitimate clients.</span></span>

* <span data-ttu-id="f6ecb-110">Kötü amaçlı kod yürütme</span><span class="sxs-lookup"><span data-stu-id="f6ecb-110">Malicious code execution</span></span>

  <span data-ttu-id="f6ecb-111">Gelen güvenilmeyen veriler, alıcı tarafın, planlamadıkları kodu çalıştırmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-111">Incoming untrusted data causes the receiving side to run code it did not intend to.</span></span>

* <span data-ttu-id="f6ecb-112">Bilgilerin açığa çıkması</span><span class="sxs-lookup"><span data-stu-id="f6ecb-112">Information disclosure</span></span>

  <span data-ttu-id="f6ecb-113">Uzak saldırgan, alma işlemini amaçlarından daha fazla bilgi açığa çıkarmaya benzer şekilde, isteklerine yanıt vermeye zorlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-113">The remote attacker forces the receiving party to respond to its requests in such a way as to disclose more information than it intends to.</span></span>

## <a name="user-provided-code-and-code-access-security"></a><span data-ttu-id="f6ecb-114">User-Provided kodu ve kod erişim güvenliği</span><span class="sxs-lookup"><span data-stu-id="f6ecb-114">User-Provided Code and Code Access Security</span></span>

<span data-ttu-id="f6ecb-115">Kullanıcı tarafından temin edilen Windows Communication Foundation (WCF) altyapı çalıştırma kodu içindeki çeşitli konumlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-115">A number of places in the Windows Communication Foundation (WCF) infrastructure run code that is provided by the user.</span></span> <span data-ttu-id="f6ecb-116">Örneğin, <xref:System.Runtime.Serialization.DataContractSerializer> serileştirme altyapısı Kullanıcı tarafından belirtilen özellik `set` erişimcileri ve `get` erişimcileri çağırabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-116">For example, the <xref:System.Runtime.Serialization.DataContractSerializer> serialization engine may call user-provided property `set` accessors and `get` accessors.</span></span> <span data-ttu-id="f6ecb-117">WCF kanal altyapısı, sınıfının Kullanıcı tarafından sağlanmış türetilmiş sınıflarına da çağrı gösterebilir <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-117">The WCF channel infrastructure may also call into user-provided derived classes of the <xref:System.ServiceModel.Channels.Message> class.</span></span>

<span data-ttu-id="f6ecb-118">Bu, herhangi bir güvenlik açığının mevcut olmadığından emin olmak için kod yazarının sorumluluğundadır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-118">It is the responsibility of the code author to ensure that no security vulnerabilities exist.</span></span> <span data-ttu-id="f6ecb-119">Örneğin, tamsayı türünde bir veri üyesi özelliği olan bir veri sözleşmesi türü oluşturursanız ve `set` erişimci uygulamasında özellik değerini temel alan bir dizi ayırdıysanız, kötü amaçlı bir ileti bu veri üyesine yönelik son derece büyük bir değer içeriyorsa hizmet reddi saldırısı olasılığını açığa çıkarır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-119">For example, if you create a data contract type with a data member property of type integer, and in the `set` accessor implementation allocate an array based on the property value, you expose the possibility of a denial-of-service attack if a malicious message contains an extremely large value for this data member.</span></span> <span data-ttu-id="f6ecb-120">Genel olarak, gelen verileri temel alan veya Kullanıcı tarafından belirtilen koddaki uzun işleme dayalı herhangi bir ayırmaktan kaçının (özellikle uzun işleme, daha az sayıda gelen veri olabilir).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-120">In general, avoid any allocations based on incoming data or lengthy processing in user-provided code (especially if lengthy processing can be caused by a small amount of incoming data).</span></span> <span data-ttu-id="f6ecb-121">Kullanıcı tarafından sağlanmış kodun güvenlik analizini gerçekleştirirken, tüm hata durumlarını (yani, özel durumların oluşturulduğu tüm kod dallarını) göz önünde bulundurduğunuzdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-121">When performing security analysis of user-provided code, make sure to also consider all failure cases (that is, all code branches where exceptions are thrown).</span></span>

<span data-ttu-id="f6ecb-122">Kullanıcı tarafından sağlanmış kodun en son örneği, her işlem için hizmet uygulamanızın içindeki koddur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-122">The ultimate example of user-provided code is the code inside your service implementation for each operation.</span></span> <span data-ttu-id="f6ecb-123">Hizmet uygulamanızın güvenliği sizin sorumluluğunuzdadır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-123">The security of your service implementation is your responsibility.</span></span> <span data-ttu-id="f6ecb-124">Yanlışlıkla hizmet reddi açıklarına neden olabilecek güvenli olmayan bir işlem uygulamaları oluşturmak kolaydır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-124">It is easy to inadvertently create insecure operation implementations that may result in denial-of-service vulnerabilities.</span></span> <span data-ttu-id="f6ecb-125">Örneğin, bir dize alan ve adı bu dizeyle başlayan bir veritabanındaki müşterilerin listesini döndüren bir işlem.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-125">For example, an operation that takes a string and returns the list of customers from a database whose name starts with that string.</span></span> <span data-ttu-id="f6ecb-126">Büyük bir veritabanıyla çalışıyorsanız ve geçirilmekte olan dize yalnızca tek bir harfle fazlaysa, kodunuz tüm kullanılabilir bellekten daha büyük bir ileti oluşturmayı deneyebilir ve tüm hizmetin başarısız olmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-126">If you are working with a large database and the string being passed is just a single letter, your code may attempt to create a message larger than all available memory, causing the entire service to fail.</span></span> <span data-ttu-id="f6ecb-127">( <xref:System.OutOfMemoryException> .NET Framework bir kurtarılabilir değildir ve her zaman uygulamanızın sonlandırmasına neden olur.)</span><span class="sxs-lookup"><span data-stu-id="f6ecb-127">(An <xref:System.OutOfMemoryException> is not recoverable in the .NET Framework and always results in the termination of your application.)</span></span>

<span data-ttu-id="f6ecb-128">Çeşitli genişletilebilirlik noktalarına hiçbir kötü amaçlı kod takılı olmadığından emin olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-128">You should ensure that no malicious code is plugged in to the various extensibility points.</span></span> <span data-ttu-id="f6ecb-129">Bu durum özellikle kısmi güven altında çalışırken, kısmen güvenilen derlemelerin türleriyle ilgilenirken veya kısmen güvenilen kod tarafından kullanılabilir bileşenleri oluştururken ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-129">This is especially relevant when running under partial trust, dealing with types from partially-trusted assemblies, or creating components usable by partially-trusted code.</span></span> <span data-ttu-id="f6ecb-130">Daha fazla bilgi için sonraki bölümde "kısmi güven tehditleri" bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-130">For more information, see "Partial Trust Threats" in a later section.</span></span>

<span data-ttu-id="f6ecb-131">Kısmi güvende çalışırken, veri sözleşmesi serileştirme altyapısının yalnızca veri sözleşmesi programlama modelinin sınırlı bir alt kümesini desteklediğini unutmayın; Örneğin, özel veri üyeleri veya özniteliğini kullanan türler <xref:System.SerializableAttribute> desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-131">Note that when running in partial trust, the data contract serialization infrastructure supports only a limited subset of the data contract programming model - for example, private data members or types using the <xref:System.SerializableAttribute> attribute are not supported.</span></span> <span data-ttu-id="f6ecb-132">Daha fazla bilgi için bkz. [kısmi güven](partial-trust.md).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-132">For more information, see [Partial Trust](partial-trust.md).</span></span>

## <a name="avoiding-unintentional-information-disclosure"></a><span data-ttu-id="f6ecb-133">Yanlışlıkla bilginin açıklanmasını önleme</span><span class="sxs-lookup"><span data-stu-id="f6ecb-133">Avoiding Unintentional Information Disclosure</span></span>

<span data-ttu-id="f6ecb-134">Güvenliği göz önünde bulundurularak serileştirilebilir türler tasarlarken, bilgilerin açıklanması olası bir konudur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-134">When designing serializable types with security in mind, information disclosure is a possible concern.</span></span>

<span data-ttu-id="f6ecb-135">Aşağıdaki noktaları göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-135">Consider the following points:</span></span>

- <span data-ttu-id="f6ecb-136"><xref:System.Runtime.Serialization.DataContractSerializer>Programlama modeli, serileştirme sırasında tür veya derleme dışındaki özel ve iç verilerin açığa çıkmasına izin verir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-136">The <xref:System.Runtime.Serialization.DataContractSerializer> programming model allows the exposure of private and internal data outside of the type or assembly during serialization.</span></span> <span data-ttu-id="f6ecb-137">Ek olarak, bir türün şekli, şema dışarı aktarma işlemi sırasında açığa çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-137">Additionally, the shape of a type can be exposed during schema export.</span></span> <span data-ttu-id="f6ecb-138">Türün serileştirme projeksiyonunu anladığınızdan emin olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-138">Be sure to understand your type's serialization projection.</span></span> <span data-ttu-id="f6ecb-139">Ortaya çıkmayı istemiyorsanız, (örneğin, <xref:System.Runtime.Serialization.DataMemberAttribute> bir veri sözleşmesi durumunda özniteliği uygulamadan) serileştirilmesi devre dışı bırakın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-139">If you do not want anything exposed, disable serializing it (for example, by not applying the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute in the case of a data contract).</span></span>

- <span data-ttu-id="f6ecb-140">Aynı türde birden çok serileştirme projeksiyonuna sahip olabileceğini ve kullanımda olan serileştiriciye bağlı olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-140">Be aware that the same type may have multiple serialization projections, depending on the serializer in use.</span></span> <span data-ttu-id="f6ecb-141">Aynı tür, ile <xref:System.Runtime.Serialization.DataContractSerializer> birlikte kullanıldığında ve başka bir veri kümesiyle birlikte kullanıldığında bir veri kümesini açığa çıkabilir <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-141">The same type may expose one set of data when used with the <xref:System.Runtime.Serialization.DataContractSerializer> and another set of data when used with the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="f6ecb-142">Yanlışlıkla yanlış serileştirici kullanılması bilgilerin açığa çıkmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-142">Accidentally using the wrong serializer may lead to information disclosure.</span></span>

- <span data-ttu-id="f6ecb-143"><xref:System.Xml.Serialization.XmlSerializer>Eski uzak yordam çağrısı (RPC)/Encoded modunun kullanımı, gönderme tarafındaki nesne grafiğinin şeklini istenmeden alma tarafına gösterebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-143">Using the <xref:System.Xml.Serialization.XmlSerializer> in legacy remote procedure call (RPC)/encoded mode may unintentionally expose the shape of the object graph on the sending side to the receiving side.</span></span>

## <a name="preventing-denial-of-service-attacks"></a><span data-ttu-id="f6ecb-144">Hizmet reddi saldırılarını engelleme</span><span class="sxs-lookup"><span data-stu-id="f6ecb-144">Preventing Denial-of-Service Attacks</span></span>

### <a name="quotas"></a><span data-ttu-id="f6ecb-145">Kotalar</span><span class="sxs-lookup"><span data-stu-id="f6ecb-145">Quotas</span></span>

<span data-ttu-id="f6ecb-146">Alıcı tarafın önemli miktarda bellek ayırmasına neden olma olasılığı, olası bir hizmet reddi saldırıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-146">Causing the receiving side to allocate a significant amount of memory is a potential denial-of-service attack.</span></span> <span data-ttu-id="f6ecb-147">Bu bölüm, büyük iletilerden kaynaklanan bellek tüketimi sorunlarını ele alırken diğer saldırılar meydana gelebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-147">While this section concentrates on memory consumption issues arising from large messages, other attacks may occur.</span></span> <span data-ttu-id="f6ecb-148">Örneğin, iletiler bir orantısız miktarı işlem süresi kullanıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-148">For example, messages may use a disproportionate amount of processing time.</span></span>

<span data-ttu-id="f6ecb-149">Hizmet reddi saldırıları genellikle kotalar kullanılarak azaltılmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-149">Denial-of-service attacks are usually mitigated using quotas.</span></span> <span data-ttu-id="f6ecb-150">Bir kota aşıldığında, <xref:System.ServiceModel.QuotaExceededException> normalde bir özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-150">When a quota is exceeded, a <xref:System.ServiceModel.QuotaExceededException> exception is normally thrown.</span></span> <span data-ttu-id="f6ecb-151">Kota olmadan kötü amaçlı bir ileti, kullanılabilir tüm belleğe erişilmesine, bir <xref:System.OutOfMemoryException> özel duruma veya tüm kullanılabilir yığınlara erişilmesine neden olabilir ve buna yol açar <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-151">Without the quota, a malicious message may cause all available memory to be accessed, resulting in an <xref:System.OutOfMemoryException> exception, or all available stacks to be accessed, resulting in a <xref:System.StackOverflowException>.</span></span>

<span data-ttu-id="f6ecb-152">Kota aşıldı senaryosu kurtarılabilir; çalışan bir hizmette karşılaşılırsa, şu anda işlenen ileti atılır ve hizmet çalışmaya devam eder ve daha fazla ileti işler.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-152">The quota exceeded scenario is recoverable; if encountered in a running service, the message currently being processed is discarded and the service keeps running and processes further messages.</span></span> <span data-ttu-id="f6ecb-153">Ancak, bellek dışı ve yığın taşması senaryoları, .NET Framework her yerde kurtarılamaz; hizmet böyle özel durumlarla karşılaşırsa sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-153">The out-of-memory and stack overflow scenarios, however, are not recoverable anywhere in the .NET Framework; the service terminates if it encounters such exceptions.</span></span>

<span data-ttu-id="f6ecb-154">WCF 'de kotalar ön tahsisi içermez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-154">Quotas in WCF do not involve any pre-allocation.</span></span> <span data-ttu-id="f6ecb-155">Örneğin, <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> Kota (çeşitli sınıflarda bulunan) 128 KB olarak ayarlandıysa, her ileti için 128 KB 'nin otomatik olarak ayrıldığı anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-155">For example, if the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota (found on various classes) is set to 128 KB, it does not mean that 128 KB is automatically allocated for each message.</span></span> <span data-ttu-id="f6ecb-156">Ayrılan gerçek miktar, gerçek gelen ileti boyutuna bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-156">The actual amount allocated depends on the actual incoming message size.</span></span>

<span data-ttu-id="f6ecb-157">Birçok kota, aktarım katmanında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-157">Many quotas are available at the transport layer.</span></span> <span data-ttu-id="f6ecb-158">Bunlar, kullanımdaki belirli aktarım kanalı tarafından zorlanan kotalardır (HTTP, TCP, vb.).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-158">These are quotas enforced by the specific transport channel in use (HTTP, TCP, and so on).</span></span> <span data-ttu-id="f6ecb-159">Bu konu, bu kotaların bazılarını ele alırken, bu kotalar [Aktarım kotalarıyla](transport-quotas.md)ayrıntılı olarak açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-159">While this topic discusses some of these quotas, these quotas are described in detail in [Transport Quotas](transport-quotas.md).</span></span>

### <a name="hashtable-vulnerability"></a><span data-ttu-id="f6ecb-160">Hashtable güvenlik açığı</span><span class="sxs-lookup"><span data-stu-id="f6ecb-160">Hashtable Vulnerability</span></span>

<span data-ttu-id="f6ecb-161">Veri sözleşmeleri diyez tabloları veya koleksiyonlar içerdiğinde bir güvenlik açığı oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-161">A vulnerability exists when data contracts contain hashtables or collections.</span></span> <span data-ttu-id="f6ecb-162">Bu sorun, çok sayıda değerin aynı karma değeri oluşturabileceği bir Hashtable 'a çok sayıda değer eklenirse oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-162">The problem occurs if a large number of values are inserted into a hashtable where a large number of those values generate the same hash value.</span></span> <span data-ttu-id="f6ecb-163">Bu, DOS saldırısı olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-163">This can be used as a DOS attack.</span></span>  <span data-ttu-id="f6ecb-164">Bu güvenlik açığı, MaxReceivedMessageSize bağlama kotasının ayarlanarak azaltılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-164">This vulnerability can be mitigated by setting the MaxReceivedMessageSize binding quota.</span></span> <span data-ttu-id="f6ecb-165">Bu tür saldırıları engellemek için bu kota ayarlanırken dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-165">Care must be taken while setting this quota in order to prevent such attacks.</span></span> <span data-ttu-id="f6ecb-166">Bu kota, WCF iletisi boyutunun üst sınırını koyar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-166">This quota puts an upper limit on the size of WCF message.</span></span> <span data-ttu-id="f6ecb-167">Ayrıca, veri sözleşmelerinizi kullanarak tablolularıyla veya koleksiyonlar kullanmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-167">Additionally, avoid using hashtables or collections in your data contracts.</span></span>

## <a name="limiting-memory-consumption-without-streaming"></a><span data-ttu-id="f6ecb-168">Bellek tüketimini akış olmadan sınırlandırma</span><span class="sxs-lookup"><span data-stu-id="f6ecb-168">Limiting Memory Consumption Without Streaming</span></span>

<span data-ttu-id="f6ecb-169">Büyük iletiler etrafında güvenlik modeli, akışın kullanımda olup olmamasına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-169">The security model around large messages depends on whether streaming is in use.</span></span> <span data-ttu-id="f6ecb-170">Temel, akışlı olmayan bir durumda, mesajların belleği arabelleğe alınır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-170">In the basic, non-streamed case, messages are buffered into memory.</span></span> <span data-ttu-id="f6ecb-171">Bu durumda, <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> <xref:System.ServiceModel.Channels.TransportBindingElement> en büyük ileti boyutunu erişecek şekilde sınırlayarak büyük iletilere karşı korumak için sistem tarafından belirtilen bağlamalarda veya üzerinde bulunan kotayı kullanın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-171">In this case, use the <xref:System.ServiceModel.Channels.TransportBindingElement.MaxReceivedMessageSize%2A> quota on the <xref:System.ServiceModel.Channels.TransportBindingElement> or on the system-provided bindings to protect against large messages by limiting the maximum message size to access.</span></span> <span data-ttu-id="f6ecb-172">Bir hizmetin aynı anda birden çok ileti işliyor olabileceğini ve bu durumda bunların hepsi bellekte olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-172">Note that a service may be processing multiple messages at the same time, in which case they are all in memory.</span></span> <span data-ttu-id="f6ecb-173">Bu tehdidi azaltmak için daraltma özelliğini kullanın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-173">Use the throttling feature to mitigate this threat.</span></span>

<span data-ttu-id="f6ecb-174">Ayrıca `MaxReceivedMessageSize` , ileti başına bellek tüketimine bir üst sınır yerleştirmediğini, ancak bunu sabit bir faktör içinde sınırlandırmadığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-174">Also note that `MaxReceivedMessageSize` does not place an upper bound on per-message memory consumption, but limits it to within a constant factor.</span></span> <span data-ttu-id="f6ecb-175">Örneğin, `MaxReceivedMessageSize` 1 MB ve 1 MB 'lık bir ileti alınıp sonra seri durumdan çıkarılmışsa, seri durumdan çıkarılan nesne grafiğini içermesi için ek bellek gerekir ve bu da 1 MB 'tan fazla toplam bellek tüketimi elde edilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-175">For example, if the `MaxReceivedMessageSize` is 1 MB and a 1-MB message is received and then deserialized, additional memory is required to contain the deserialized object graph, resulting in total memory consumption well over 1 MB.</span></span> <span data-ttu-id="f6ecb-176">Bu nedenle, çok fazla gelen veriler olmadan önemli miktarda bellek tüketimine neden olabilecek serileştirilebilir türler oluşturmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-176">For this reason, avoid creating serializable types that could result in significant memory consumption without much incoming data.</span></span> <span data-ttu-id="f6ecb-177">Örneğin, 50 isteğe bağlı veri üyesi alanları ve ek 100 özel alanları olan "MyContract" veri sözleşmesi "" XML yapımı ile oluşturulabilir \<MyContract/> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-177">For example, a data contract "MyContract" with 50 optional data member fields and an additional 100 private fields could be instantiated with the XML construction "\<MyContract/>".</span></span> <span data-ttu-id="f6ecb-178">Bu XML, 150 alanları için belleğe erişilmeye sonuçlanıyor.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-178">This XML results in memory being accessed for 150 fields.</span></span> <span data-ttu-id="f6ecb-179">Veri üyelerinin varsayılan olarak isteğe bağlı olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-179">Note that data members are optional by default.</span></span> <span data-ttu-id="f6ecb-180">Böyle bir tür bir dizinin parçasıysa sorun oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-180">The problem is compounded when such a type is part of an array.</span></span>

<span data-ttu-id="f6ecb-181">`MaxReceivedMessageSize` Tüm hizmet reddi saldırılarını engellemek için tek başına yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-181">`MaxReceivedMessageSize` alone is not enough to prevent all denial-of-service attacks.</span></span> <span data-ttu-id="f6ecb-182">Örneğin, seri hale getirici, iç içe geçmiş bir nesne grafiğinin serisini kaldırmak için (bir başka nesne içeren bir nesne, ancak başka bir nesneyi içeren bir nesne) gelen bir ileti tarafından kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-182">For example, the deserializer may be forced to deserialize a deeply-nested object graph (an object that contains another object that contains yet another one, and so on) by an incoming message.</span></span> <span data-ttu-id="f6ecb-183">Hem <xref:System.Runtime.Serialization.DataContractSerializer> hem de <xref:System.Xml.Serialization.XmlSerializer> çağrı yöntemleri, bu tür grafiklerin serisini kaldırmak için iç içe bir yoldur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-183">Both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer> call methods in a nested way to deserialize such graphs.</span></span> <span data-ttu-id="f6ecb-184">Yöntem çağrılarının derin iç içe geçirilmesi kurtarılamaz bir sonuç verebilir <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-184">Deep nesting of method calls may result in an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="f6ecb-185">Bu tehdit, <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> konusunun devamındaki "XML güvenli kullanımı" bölümünde açıklandığı gibi, XML iç içe geçme düzeyini sınırlamak üzere kota ayarlanarak azalmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-185">This threat is mitigated by setting the <xref:System.ServiceModel.Configuration.XmlDictionaryReaderQuotasElement.MaxDepth%2A> quota to limit the level of XML nesting, as discussed in the "Using XML Safely" section later in the topic.</span></span>

<span data-ttu-id="f6ecb-186">Ek kotalar `MaxReceivedMessageSize` , IKILI XML kodlaması kullanılırken özellikle önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-186">Setting additional quotas to `MaxReceivedMessageSize` is especially important when using binary XML encoding.</span></span> <span data-ttu-id="f6ecb-187">İkili kodlamanın kullanılması, sıkıştırmaya biraz eşdeğerdir: gelen iletideki küçük bir bayt grubu çok fazla veri temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-187">Using binary encoding is somewhat equivalent to compression: a small group of bytes in the incoming message may represent a lot of data.</span></span> <span data-ttu-id="f6ecb-188">Bu nedenle, sınıra bir ileti ekleme bile `MaxReceivedMessageSize` tam genişletilmiş biçimde daha fazla bellek alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-188">Thus, even a message fitting into the `MaxReceivedMessageSize` limit may take up much more memory in fully expanded form.</span></span> <span data-ttu-id="f6ecb-189">XML 'e özgü bu tehditleri azaltmak için, bu konunun devamındaki "XML güvenli kullanımı" bölümünde anlatıldığı gibi tüm XML okuyucu kotaları doğru ayarlanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-189">To mitigate such XML-specific threats, all of the XML reader quotas must be set correctly, as discussed in the "Using XML Safely" section later in this topic.</span></span>

## <a name="limiting-memory-consumption-with-streaming"></a><span data-ttu-id="f6ecb-190">Bellek tüketimini akış ile sınırlama</span><span class="sxs-lookup"><span data-stu-id="f6ecb-190">Limiting Memory Consumption with Streaming</span></span>

<span data-ttu-id="f6ecb-191">Akış sırasında `MaxReceivedMessageSize` hizmet reddi saldırılarına karşı korumak için küçük bir ayar kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-191">When streaming, you may use a small `MaxReceivedMessageSize` setting to protect against denial-of-service attacks.</span></span> <span data-ttu-id="f6ecb-192">Ancak, akışta daha karmaşık senaryolar mümkündür.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-192">However, more complicated scenarios are possible with streaming.</span></span> <span data-ttu-id="f6ecb-193">Örneğin, bir dosya karşıya yükleme hizmeti kullanılabilir tüm bellekten daha büyük dosyaları kabul eder.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-193">For example, a file upload service accepts files larger than all available memory.</span></span> <span data-ttu-id="f6ecb-194">Bu durumda, ' yi `MaxReceivedMessageSize` son derece büyük bir değere ayarlayın, neredeyse hiçbir verinin bellekte arabelleğe alınmadığını ve ileti doğrudan diske akışını bekliyor.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-194">In this case, set the `MaxReceivedMessageSize` to an extremely large value, expecting that almost no data is buffered in memory and the message streams directly to disk.</span></span> <span data-ttu-id="f6ecb-195">Kötü amaçlı bir ileti, WCF 'yi bu durumda akışa almak yerine bu verileri arabelleğe alarak zorlayabilir `MaxReceivedMessageSize`</span><span class="sxs-lookup"><span data-stu-id="f6ecb-195">If a malicious message can somehow force WCF to buffer data instead of streaming it in this case, `MaxReceivedMessageSize` no longer protects against the message accessing all available memory.</span></span>

<span data-ttu-id="f6ecb-196">Bu tehdidi azaltmak için, arabelleğe almayı sınırlayan çeşitli WCF veri işleme bileşenlerinde belirli Kota ayarları vardır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-196">To mitigate this threat, specific quota settings exist on various WCF data-processing components that limit buffering.</span></span> <span data-ttu-id="f6ecb-197">Bunların en önemlisi, `MaxBufferSize` çeşitli taşıma bağlama öğelerinde ve standart bağlamalarda bulunan özelliktir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-197">The most important of these is the `MaxBufferSize` property on various transport binding elements and standard bindings.</span></span> <span data-ttu-id="f6ecb-198">Akışta, bu kotanın ileti başına ayırmak istediğiniz en fazla bellek miktarını hesaba katmak üzere ayarlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-198">When streaming, this quota should be set taking into account the maximum amount of memory you are willing to allocate per message.</span></span> <span data-ttu-id="f6ecb-199">' De olduğu gibi `MaxReceivedMessageSize` , ayar bellek tüketimine mutlak bir en yüksek değer yerleştirmez, ancak yalnızca sabit bir faktör içinde bu değeri kısıtlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-199">As with `MaxReceivedMessageSize`, the setting does not put an absolute maximum on memory consumption but only limits it to within a constant factor.</span></span> <span data-ttu-id="f6ecb-200">Ayrıca, ' de olduğu gibi `MaxReceivedMessageSize` , aynı anda birden çok ileti işleme olasılığının farkında olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-200">Also, as with `MaxReceivedMessageSize`, be aware of the possibility of multiple messages being processed simultaneously.</span></span>

### <a name="maxbuffersize-details"></a><span data-ttu-id="f6ecb-201">MaxBufferSize ayrıntıları</span><span class="sxs-lookup"><span data-stu-id="f6ecb-201">MaxBufferSize Details</span></span>

<span data-ttu-id="f6ecb-202">`MaxBufferSize`Özelliği, toplu arabelleğe alma WCF 'nin her birini sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-202">The `MaxBufferSize` property limits any bulk buffering WCF does.</span></span> <span data-ttu-id="f6ecb-203">Örneğin, WCF her zaman SOAP üst bilgilerini ve SOAP hatalarını ve bir Ileti Iletimi Iyileştirme mekanizması (MTOM) iletisindeki doğal okuma düzeninde olmayan tüm MIME parçalarını arabelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-203">For example, WCF always buffers SOAP headers and SOAP faults, as well as any MIME parts found to be not in the natural reading order in an Message Transmission Optimization Mechanism (MTOM) message.</span></span> <span data-ttu-id="f6ecb-204">Bu ayar tüm bu durumlarda arabelleğe alma miktarını sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-204">This setting limits the amount of buffering in all these cases.</span></span>

<span data-ttu-id="f6ecb-205">WCF bu `MaxBufferSize` değeri, arabelleği olabilecek çeşitli bileşenlere geçirerek gerçekleştirir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-205">WCF accomplishes this by passing the `MaxBufferSize` value to the various components that may buffer.</span></span> <span data-ttu-id="f6ecb-206">Örneğin, sınıfın bazı <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> aşırı yüklemeleri <xref:System.ServiceModel.Channels.Message> bir `maxSizeOfHeaders` parametre alır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-206">For example, some <xref:System.ServiceModel.Channels.Message.CreateMessage%2A> overloads of the <xref:System.ServiceModel.Channels.Message> class take a `maxSizeOfHeaders` parameter.</span></span> <span data-ttu-id="f6ecb-207">WCF, `MaxBufferSize` SOAP üst bilgisi arabelleğe alma miktarını sınırlamak için değeri bu parametreye geçirir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-207">WCF passes the `MaxBufferSize` value to this parameter to limit the amount of SOAP header buffering.</span></span> <span data-ttu-id="f6ecb-208">Sınıfı doğrudan kullanılırken bu parametrenin ayarlanması önemlidir <xref:System.ServiceModel.Channels.Message> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-208">It is important to set this parameter when using the <xref:System.ServiceModel.Channels.Message> class directly.</span></span> <span data-ttu-id="f6ecb-209">Genel olarak, WCF 'de kota parametreleri alan bir bileşen kullanırken, bu parametrelerin güvenlik etkilerine ilişkin etkilerini anlamak ve doğru şekilde ayarlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-209">In general, when using a component in WCF that takes quota parameters, it is important to understand the security implications of these parameters and set them correctly.</span></span>

<span data-ttu-id="f6ecb-210">MTOM ileti Kodlayıcısı da bir ayara sahiptir `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-210">The MTOM message encoder also has a `MaxBufferSize` setting.</span></span> <span data-ttu-id="f6ecb-211">Standart bağlamaları kullanırken, bu otomatik olarak aktarım düzeyi `MaxBufferSize` değerine ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-211">When using standard bindings, this is set automatically to the transport-level `MaxBufferSize` value.</span></span> <span data-ttu-id="f6ecb-212">Ancak, özel bir bağlama oluşturmak için MTOM ileti Kodlayıcısı bağlama öğesi kullanılırken, `MaxBufferSize` akış kullanıldığında özelliği güvenli bir değere ayarlamanız önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-212">However, when using the MTOM message encoder binding element to construct a custom binding, it is important to set the `MaxBufferSize` property to a safe value when streaming is used.</span></span>

## <a name="xml-based-streaming-attacks"></a><span data-ttu-id="f6ecb-213">XML-Based akış saldırıları</span><span class="sxs-lookup"><span data-stu-id="f6ecb-213">XML-Based Streaming Attacks</span></span>

<span data-ttu-id="f6ecb-214">`MaxBufferSize` Hala, WCF 'nin akış beklenirken arabelleğe alma işlemine zorlanamadığından emin olmak için yeterli değildir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-214">`MaxBufferSize` alone is not enough to ensure that WCF cannot be forced into buffering when streaming is expected.</span></span> <span data-ttu-id="f6ecb-215">Örneğin, WCF XML okuyucuları her zaman yeni bir öğeyi okumaya Başlarken tüm XML öğesi başlangıç etiketini arabelleğe alın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-215">For example, the WCF XML readers always buffer the entire XML element start tag when starting to read a new element.</span></span> <span data-ttu-id="f6ecb-216">Bu işlem, ad alanlarının ve özniteliklerin düzgün şekilde işlenmesini sağlayacak şekilde yapılır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-216">This is done so that namespaces and attributes are properly processed.</span></span> <span data-ttu-id="f6ecb-217">`MaxReceivedMessageSize`Büyük olacak şekilde yapılandırıldıysa (örneğin, doğrudan diske büyük dosya akışı senaryosunu etkinleştirmek için), tüm ileti gövdesinin büyük BIR XML öğesi başlangıç etiketi olduğu durumlarda kötü amaçlı bir ileti oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-217">If `MaxReceivedMessageSize` is configured to be large (for example, to enable a direct-to-disk large file streaming scenario), a malicious message may be constructed where the entire message body is a large XML element start tag.</span></span> <span data-ttu-id="f6ecb-218">Bir ile sonuçları okumaya çalışır <xref:System.OutOfMemoryException> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-218">An attempt to read it results in an <xref:System.OutOfMemoryException>.</span></span> <span data-ttu-id="f6ecb-219">Bu, bu konunun ilerleyen kısımlarında "XML güvenli kullanımı" bölümünde ele alınan XML okuyucu kotaları kullanılarak tamamen azaltılan, XML tabanlı birçok hizmet reddi saldırısından biridir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-219">This is one of many possible XML-based denial-of-service attacks that can all be mitigated using XML reader quotas, discussed in the "Using XML Safely" section later in this topic.</span></span> <span data-ttu-id="f6ecb-220">Akış sırasında, bu kotaların tümünü ayarlamak özellikle önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-220">When streaming, it is especially important to set all of these quotas.</span></span>

### <a name="mixing-streaming-and-buffering-programming-models"></a><span data-ttu-id="f6ecb-221">Akış ve arabelleğe alma programlama modellerini karıştırma</span><span class="sxs-lookup"><span data-stu-id="f6ecb-221">Mixing Streaming and Buffering Programming Models</span></span>

<span data-ttu-id="f6ecb-222">Aynı hizmette akış ve akış olmayan programlama modellerini karıştırarak birçok olası saldırı oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-222">Many possible attacks arise from mixing streaming and non-streaming programming models in the same service.</span></span> <span data-ttu-id="f6ecb-223">İki işlem içeren bir hizmet sözleşmesi olduğunu varsayalım: biri bir alır <xref:System.IO.Stream> ve başka bir özel türün dizisini alır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-223">Suppose there is a service contract with two operations: one takes a <xref:System.IO.Stream> and another takes an array of some custom type.</span></span> <span data-ttu-id="f6ecb-224">Ayrıca, `MaxReceivedMessageSize` ilk işlemin büyük akışları işlemesini sağlamak için büyük bir değere ayarlandığını varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-224">Suppose also that `MaxReceivedMessageSize` is set to a large value to enable the first operation to process large streams.</span></span> <span data-ttu-id="f6ecb-225">Ne yazık ki bu, büyük iletilerin artık ikinci işleme de gönderilebileceği anlamına gelir ve seri hale getirici, işlem çağrılmadan önce, bellekteki verileri bir dizi olarak arabelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-225">Unfortunately, this means that large messages can now be sent to the second operation as well, and the deserializer buffers data in memory as an array before the operation is called.</span></span> <span data-ttu-id="f6ecb-226">Bu, olası bir hizmet reddi saldırıdır: kota, seri `MaxBufferSize` hale getiricinin birlikte çalıştığı ileti gövdesinin boyutunu sınırlamaz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-226">This is a potential denial-of-service attack: the `MaxBufferSize` quota does not limit the size of the message body, which is what the deserializer works with.</span></span>

<span data-ttu-id="f6ecb-227">Bu nedenle, aynı sözleşmede akış tabanlı ve akış olmayan işlemleri karıştırmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-227">For this reason, avoid mixing stream-based and non-streamed operations in the same contract.</span></span> <span data-ttu-id="f6ecb-228">İki programlama modelini kesinlikle karıştırdıysanız, aşağıdaki önlemleri kullanın:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-228">If you absolutely must mix the two programming models, use the following precautions:</span></span>

- <span data-ttu-id="f6ecb-229"><xref:System.Runtime.Serialization.IExtensibleDataObject>Özelliğini olarak ayarlayarak özelliği kapatın <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> <xref:System.ServiceModel.ServiceBehaviorAttribute> `true` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-229">Turn off the <xref:System.Runtime.Serialization.IExtensibleDataObject> feature by setting the <xref:System.ServiceModel.ServiceBehaviorAttribute.IgnoreExtensionDataObject%2A> property of the <xref:System.ServiceModel.ServiceBehaviorAttribute> to `true`.</span></span> <span data-ttu-id="f6ecb-230">Bu, yalnızca sözleşmenin bir parçası olan üyelerin seri durumdan çıkarılmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-230">This ensures that only members that are a part of the contract are deserialized.</span></span>

- <span data-ttu-id="f6ecb-231"><xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A>Öğesinin özelliğini <xref:System.Runtime.Serialization.DataContractSerializer> güvenli bir değere ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-231">Set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property of the <xref:System.Runtime.Serialization.DataContractSerializer> to a safe value.</span></span> <span data-ttu-id="f6ecb-232">Bu kota, <xref:System.ServiceModel.ServiceBehaviorAttribute> özniteliğinde veya yapılandırma aracılığıyla da kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-232">This quota is also available on the <xref:System.ServiceModel.ServiceBehaviorAttribute> attribute or through configuration.</span></span> <span data-ttu-id="f6ecb-233">Bu kota, bir seri kaldırma bölümünde Serisi kaldırılan nesne sayısını sınırlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-233">This quota limits the number of objects that are deserialized in one deserialization episode.</span></span> <span data-ttu-id="f6ecb-234">Normalde, bir ileti sözleşmesinin her bir işlem parametresi veya ileti gövdesi bölümü bir bölümde seri durumdan çıkarılmış olur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-234">Normally, each operation parameter or message body part in a message contract is deserialized in one episode.</span></span> <span data-ttu-id="f6ecb-235">Dizilerin serisi kaldırılırken, her dizi girişi ayrı bir nesne olarak sayılır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-235">When deserializing arrays, each array entry is counted as a separate object.</span></span>

- <span data-ttu-id="f6ecb-236">Tüm XML okuyucu kotalarını güvenli değerlere ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-236">Set all of the XML reader quotas to safe values.</span></span> <span data-ttu-id="f6ecb-237"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>Akış olmayan işlemlerde, ve ' a dikkat edin <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> ve dizeleri önleyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-237">Pay attention to <xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A>, <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, and <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> and avoid strings in non-streaming operations.</span></span>

- <span data-ttu-id="f6ecb-238">Bilinen türlerin listesini gözden geçirin ve bunlardan herhangi birinin herhangi bir zamanda örneklendirildiğini aklınızda bulundurun (Bu konunun ilerleyen kısımlarında yer alan "Istenmeyen türlerin yüklenmesini koruma" bölümüne bakın).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-238">Review the list of known types, keeping in mind that any one of them can be instantiated at any time (see the "Preventing Unintended Types from Being Loaded" section later in this topic).</span></span>

- <span data-ttu-id="f6ecb-239"><xref:System.Xml.Serialization.IXmlSerializable>Çok miktarda veriyi arabelleğe alan arabirimi uygulayan herhangi bir tür kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-239">Do not use any types that implement the <xref:System.Xml.Serialization.IXmlSerializable> interface that buffer a lot of data.</span></span> <span data-ttu-id="f6ecb-240">Bu tür türleri bilinen türler listesine eklemeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-240">Do not add such types to the list of known types.</span></span>

- <span data-ttu-id="f6ecb-241"><xref:System.Xml.XmlElement> <xref:System.Xml.XmlNode> <xref:System.Byte> Bir sözleşmede uygulayan, diziler, diziler veya türler kullanmayın <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-241">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in a contract.</span></span>

- <span data-ttu-id="f6ecb-242"><xref:System.Xml.XmlElement> <xref:System.Xml.XmlNode> <xref:System.Byte> Bilinen türler listesinde öğesini uygulayan, diziler, diziler veya türler kullanmayın <xref:System.Runtime.Serialization.ISerializable> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-242">Do not use the <xref:System.Xml.XmlElement>, <xref:System.Xml.XmlNode> arrays, <xref:System.Byte> arrays, or types that implement <xref:System.Runtime.Serialization.ISerializable> in the list of known types.</span></span>

<span data-ttu-id="f6ecb-243">Akış olmayan işlem ' i kullandığında önceki önlemler geçerlidir <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-243">The preceding precautions apply when the non-streamed operation uses the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="f6ecb-244">, Kota korumasına sahip olmadığından, aynı hizmette akış ve akış olmayan programlama modellerini hiçbir şekilde karıştırmayın <xref:System.Xml.Serialization.XmlSerializer> <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-244">Never mix streaming and non-streaming programming models on the same service if you are using the <xref:System.Xml.Serialization.XmlSerializer>, because it does not have the protection of the <xref:System.ServiceModel.Description.DataContractSerializerOperationBehavior.MaxItemsInObjectGraph%2A> quota.</span></span>

### <a name="slow-stream-attacks"></a><span data-ttu-id="f6ecb-245">Yavaş akış saldırıları</span><span class="sxs-lookup"><span data-stu-id="f6ecb-245">Slow Stream Attacks</span></span>

<span data-ttu-id="f6ecb-246">Akış hizmeti reddi saldırılarının bir sınıfı, bellek tüketimi içermez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-246">A class of streaming denial-of-service attacks does not involve memory consumption.</span></span> <span data-ttu-id="f6ecb-247">Bunun yerine, saldırı yavaş bir göndereni veya veri alıcısını içerir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-247">Instead, the attack involves a slow sender or receiver of data.</span></span> <span data-ttu-id="f6ecb-248">Verilerin gönderilmesi veya alınması beklenirken, iş parçacıkları ve kullanılabilir bağlantılar gibi kaynaklar tükenmiştir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-248">While waiting for the data to be sent or received, resources such as threads and available connections are exhausted.</span></span> <span data-ttu-id="f6ecb-249">Bu durum kötü amaçlı bir saldırının veya yavaş bir ağ bağlantısındaki meşru bir gönderenden/alıcının sonucu olarak ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-249">This situation could arise either as a result of a malicious attack or from a legitimate sender/receiver on a slow network connection.</span></span>

<span data-ttu-id="f6ecb-250">Bu saldırıları azaltmak için taşıma zaman aşımlarını doğru olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-250">To mitigate these attacks, set the transport time-outs correctly.</span></span> <span data-ttu-id="f6ecb-251">Daha fazla bilgi için bkz. [Aktarım kotaları](transport-quotas.md).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-251">For more information, see [Transport Quotas](transport-quotas.md).</span></span> <span data-ttu-id="f6ecb-252">İkinci olarak, `Read` `Write` WCF 'de akışlarla çalışırken hiçbir zaman zaman uyumlu veya işlem kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-252">Secondly, never use synchronous `Read` or `Write` operations when working with streams in WCF.</span></span>

## <a name="using-xml-safely"></a><span data-ttu-id="f6ecb-253">XML 'i güvenle kullanma</span><span class="sxs-lookup"><span data-stu-id="f6ecb-253">Using XML Safely</span></span>

> [!NOTE]
> <span data-ttu-id="f6ecb-254">Bu bölüm XML hakkında olsa da, bilgiler JavaScript Nesne Gösterimi (JSON) belgeleri için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-254">Although this section is about XML, the information also applies to JavaScript Object Notation (JSON) documents.</span></span> <span data-ttu-id="f6ecb-255">Kotalar, [JSON ve XML arasında eşleme](mapping-between-json-and-xml.md)kullanarak benzer şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-255">The quotas work similarly, using [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

### <a name="secure-xml-readers"></a><span data-ttu-id="f6ecb-256">Güvenli XML okuyucuları</span><span class="sxs-lookup"><span data-stu-id="f6ecb-256">Secure XML Readers</span></span>

<span data-ttu-id="f6ecb-257">XML bilgi kümesi, WCF 'deki tüm ileti işlemenin temelini oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-257">The XML Infoset forms the basis of all message processing in WCF.</span></span> <span data-ttu-id="f6ecb-258">Güvenilmeyen bir kaynaktan XML verileri kabul edildiğinde, azaltılmalıdır olması gereken birkaç hizmet reddi saldırısı olasılığı vardır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-258">When accepting XML data from an untrusted source, a number of denial-of-service attack possibilities exist that must be mitigated.</span></span> <span data-ttu-id="f6ecb-259">WCF, özel, güvenli XML okuyucuları sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-259">WCF provides special, secure XML readers.</span></span> <span data-ttu-id="f6ecb-260">Bu okuyucular, WCF 'de standart kodlamalardan biri (metin, ikili veya MTOM) kullanılırken otomatik olarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-260">These readers are created automatically when using one of the standard encodings in WCF (text, binary, or MTOM).</span></span>

<span data-ttu-id="f6ecb-261">Bu okuyucular üzerindeki bazı güvenlik özellikleri her zaman etkindir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-261">Some of the security features on these readers are always active.</span></span> <span data-ttu-id="f6ecb-262">Örneğin, okuyucular asla bir hizmet reddi saldırısı kaynağı olan ve meşru SOAP iletilerinde hiçbir şekilde görünmemesi gereken belge türü tanımlarını (DTD 'Ler) işlemez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-262">For example, the readers never process document type definitions (DTDs), which are a potential source of denial-of-service attacks and should never appear in legitimate SOAP messages.</span></span> <span data-ttu-id="f6ecb-263">Diğer güvenlik özellikleri, aşağıdaki bölümde açıklanan, yapılandırılması gereken okuyucu kotalarını içerir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-263">Other security features include reader quotas that must be configured, which are described in the following section.</span></span>

<span data-ttu-id="f6ecb-264">Doğrudan XML okuyucularıyla (kendi özel kodlayıcıınızı yazarken veya sınıfla doğrudan çalışırken <xref:System.ServiceModel.Channels.Message> ) çalışırken, güvenilmeyen verilerle çalışma şansı olduğunda her zaman WCF güvenli okuyucularını kullanın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-264">When working directly with XML readers (such as when writing your own custom encoder or when working directly with the <xref:System.ServiceModel.Channels.Message> class), always use the WCF secure readers when there is a chance of working with untrusted data.</span></span> <span data-ttu-id="f6ecb-265">, Veya sınıfındaki statik fabrika yöntemi aşırı yüklemelerinin birini çağırarak güvenli okuyucular oluşturun <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A> <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A> <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> <xref:System.Xml.XmlDictionaryReader> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-265">Create the secure readers by calling one of the static factory method overloads of <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> on the <xref:System.Xml.XmlDictionaryReader> class.</span></span> <span data-ttu-id="f6ecb-266">Bir okuyucu oluştururken güvenli kota değerlerini geçirin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-266">When creating a reader, pass in secure quota values.</span></span> <span data-ttu-id="f6ecb-267">`Create`Yöntem aşırı yüklerini çağırmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-267">Do not call the `Create` method overloads.</span></span> <span data-ttu-id="f6ecb-268">Bunlar bir WCF okuyucu oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-268">These do not create a WCF reader.</span></span> <span data-ttu-id="f6ecb-269">Bunun yerine, bu bölümde açıklanan güvenlik özellikleriyle korunmayan bir okuyucu oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-269">Instead, a reader is created that is not protected by the security features described in this section.</span></span>

### <a name="reader-quotas"></a><span data-ttu-id="f6ecb-270">Okuyucu kotaları</span><span class="sxs-lookup"><span data-stu-id="f6ecb-270">Reader Quotas</span></span>

<span data-ttu-id="f6ecb-271">Güvenli XML okuyucuları için beş yapılandırılabilir kota vardır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-271">The secure XML readers have five configurable quotas.</span></span> <span data-ttu-id="f6ecb-272">Bunlar normalde, `ReaderQuotas` kodlama bağlama öğelerinde veya standart bağlamalarda özelliği kullanılarak veya <xref:System.Xml.XmlDictionaryReaderQuotas> okuyucu oluştururken geçirilen bir nesne kullanılarak yapılandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-272">These are normally configured using the `ReaderQuotas` property on the encoding binding elements or standard bindings, or by using an <xref:System.Xml.XmlDictionaryReaderQuotas> object passed when creating a reader.</span></span>

#### <a name="maxbytesperread"></a><span data-ttu-id="f6ecb-273">MaxBytesPerRead</span><span class="sxs-lookup"><span data-stu-id="f6ecb-273">MaxBytesPerRead</span></span>

<span data-ttu-id="f6ecb-274">Bu kota, `Read` öğe başlangıç etiketi ve özniteliklerini okurken tek bir işlemde okunan bayt sayısını sınırlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-274">This quota limits the number of bytes that are read in a single `Read` operation when reading the element start tag and its attributes.</span></span> <span data-ttu-id="f6ecb-275">(Akış olmayan durumlarda, öğe adının kendisi kotaya karşı sayılmaz.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> aşağıdaki nedenlerle önemlidir:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-275">(In non-streamed cases, the element name itself is not counted against the quota.) <xref:System.Xml.XmlDictionaryReaderQuotas.MaxBytesPerRead%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="f6ecb-276">Okuma sırasında, öğe adı ve öznitelikleri her zaman bellekte arabelleğe alınır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-276">The element name and its attributes are always buffered in memory when they are being read.</span></span> <span data-ttu-id="f6ecb-277">Bu nedenle, akış beklendiğinde aşırı arabelleğe almayı engellemek için bu kotayı akış modunda doğru şekilde ayarlamanız önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-277">Therefore, it is important to set this quota correctly in streaming mode to prevent excessive buffering when streaming is expected.</span></span> <span data-ttu-id="f6ecb-278">Gerçekleşen `MaxDepth` gerçek arabelleğe alma miktarı hakkında daha fazla bilgi için kota bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-278">See the `MaxDepth` quota section for information about the actual amount of buffering that takes place.</span></span>

- <span data-ttu-id="f6ecb-279">Öznitelik adlarının benzersizlik için denetlenmesi gerektiğinden, çok fazla XML özniteliği orantısız işleme süresi kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-279">Having too many XML attributes may use up disproportionate processing time because attribute names have to be checked for uniqueness.</span></span> <span data-ttu-id="f6ecb-280">`MaxBytesPerRead` Bu tehdidi azaltır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-280">`MaxBytesPerRead` mitigates this threat.</span></span>

#### <a name="maxdepth"></a><span data-ttu-id="f6ecb-281">MaxDepth</span><span class="sxs-lookup"><span data-stu-id="f6ecb-281">MaxDepth</span></span>

<span data-ttu-id="f6ecb-282">Bu kota, XML öğelerinin en fazla iç içe geçme derinliğini sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-282">This quota limits the maximum nesting depth of XML elements.</span></span> <span data-ttu-id="f6ecb-283">Örneğin, " \<A> \<B> \<C/> \</B> \</A> " belgesinin iç içe geçmiş derinliği üç.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-283">For example, the document "\<A>\<B>\<C/>\</B>\</A>" has a nesting depth of three.</span></span> <span data-ttu-id="f6ecb-284"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> Aşağıdaki nedenlerle önemlidir:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-284"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxDepth%2A> is important for the following reasons:</span></span>

- <span data-ttu-id="f6ecb-285">`MaxDepth` ile etkileşimde `MaxBytesPerRead` bulunur: okuyucu, her zaman geçerli öğe ve tüm üst öğelerinden verileri bellekte tutar, böylece okuyucunun maksimum bellek tüketimi bu iki ayar ürünüyle orantılıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-285">`MaxDepth` interacts with `MaxBytesPerRead`: the reader always keeps data in memory for the current element and all of its ancestors, so the maximum memory consumption of the reader is proportional to the product of these two settings.</span></span>

- <span data-ttu-id="f6ecb-286">Derin iç içe geçmiş bir nesne grafiğinin serisi kaldırılırken, seri hale getirici yığının tamamına erişmeye zorlanır ve kurtarılamaz bir değer oluşturur <xref:System.StackOverflowException> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-286">When deserializing a deeply-nested object graph, the deserializer is forced to access the entire stack and throw an unrecoverable <xref:System.StackOverflowException>.</span></span> <span data-ttu-id="f6ecb-287">Hem hem de için içe geçen XML iç içe ve nesne arasında doğrudan bağıntı bulunur <xref:System.Runtime.Serialization.DataContractSerializer> <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-287">A direct correlation exists between XML nesting and object nesting for both the <xref:System.Runtime.Serialization.DataContractSerializer> and the <xref:System.Xml.Serialization.XmlSerializer>.</span></span> <span data-ttu-id="f6ecb-288">`MaxDepth`Bu tehdidi azaltmak için kullanın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-288">Use `MaxDepth` to mitigate this threat.</span></span>

#### <a name="maxnametablecharcount"></a><span data-ttu-id="f6ecb-289">MaxNameTableCharCount</span><span class="sxs-lookup"><span data-stu-id="f6ecb-289">MaxNameTableCharCount</span></span>

<span data-ttu-id="f6ecb-290">Bu kota, okuyucunun *NameTable* boyutunu sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-290">This quota limits the size of the reader’s *nametable*.</span></span> <span data-ttu-id="f6ecb-291">NameTable, bir XML belgesi işlenirken karşılaşılan belirli dizeleri (ad alanları ve ön ekler gibi) içerir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-291">The nametable contains certain strings (such as namespaces and prefixes) that are encountered when processing an XML document.</span></span> <span data-ttu-id="f6ecb-292">Bu dizelerin bellekte ara belleğe alındığından, akış beklendiğinde aşırı arabelleğe almayı engellemek için bu kotayı ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-292">As these strings are buffered in memory, set this quota to prevent excessive buffering when streaming is expected.</span></span>

#### <a name="maxstringcontentlength"></a><span data-ttu-id="f6ecb-293">MaxStringContentLength</span><span class="sxs-lookup"><span data-stu-id="f6ecb-293">MaxStringContentLength</span></span>

<span data-ttu-id="f6ecb-294">Bu kota, XML okuyucunun döndürdüğü en büyük dize boyutunu sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-294">This quota limits the maximum string size that the XML reader returns.</span></span> <span data-ttu-id="f6ecb-295">Bu kota, XML okuyucusu içindeki bellek tüketimini, ancak okuyucu kullanan bileşende sınırlamaz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-295">This quota does not limit memory consumption in the XML reader itself, but in the component that is using the reader.</span></span> <span data-ttu-id="f6ecb-296">Örneğin,, <xref:System.Runtime.Serialization.DataContractSerializer> ile güvenli hale getirilmiş bir okuyucu kullandığında <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> , bu kotadan daha büyük dizelerin serisini kaldırmaz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-296">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>, it does not deserialize strings larger than this quota.</span></span> <span data-ttu-id="f6ecb-297"><xref:System.Xml.XmlDictionaryReader>Sınıfı doğrudan kullanıldığında, tüm yöntemler bu kotaya uymaz, ancak yalnızca, yöntemi gibi dizeleri okumak için tasarlanan Yöntemler <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-297">When using the <xref:System.Xml.XmlDictionaryReader> class directly, not all methods respect this quota, but only the methods that are specifically designed to read strings, such as the <xref:System.Xml.XmlDictionaryReader.ReadContentAsString%2A> method.</span></span> <span data-ttu-id="f6ecb-298"><xref:System.Xml.XmlReader.Value%2A>Okuyucudaki özelliği bu kotadan etkilenmez ve bu nedenle bu kotanın sağladığı koruma gerekli olduğunda kullanılmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-298">The <xref:System.Xml.XmlReader.Value%2A> property on the reader is not affected by this quota, and thus should not be used when the protection this quota provides is necessary.</span></span>

#### <a name="maxarraylength"></a><span data-ttu-id="f6ecb-299">MaxArrayLength</span><span class="sxs-lookup"><span data-stu-id="f6ecb-299">MaxArrayLength</span></span>

<span data-ttu-id="f6ecb-300">Bu kota, bayt dizileri dahil olmak üzere XML okuyucunun döndürdüğü temel elemanların bir dizisinin maksimum boyutunu sınırlandırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-300">This quota limits the maximum size of an array of primitives that the XML reader returns, including byte arrays.</span></span> <span data-ttu-id="f6ecb-301">Bu kota, XML okuyucusu üzerinde bellek tüketimini sınırlamaz, ancak okuyucu kullanan herhangi bir bileşende.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-301">This quota does not limit memory consumption in the XML reader itself, but in whatever component that is using the reader.</span></span> <span data-ttu-id="f6ecb-302">Örneğin,, <xref:System.Runtime.Serialization.DataContractSerializer> ile güvenli hale getirilmiş bir okuyucu kullandığında <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A> , bu kotadan daha büyük olan bayt dizilerinin serisini kaldırmaz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-302">For example, when the <xref:System.Runtime.Serialization.DataContractSerializer> uses a reader secured with <xref:System.Xml.XmlDictionaryReaderQuotas.MaxArrayLength%2A>, it does not deserialize byte arrays larger than this quota.</span></span> <span data-ttu-id="f6ecb-303">Tek bir sözleşmede akış ve arabellekli programlama modellerini karıştırmaya çalışırken bu kotayı ayarlamanız önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-303">It is important to set this quota when attempting to mix streaming and buffered programming models in a single contract.</span></span> <span data-ttu-id="f6ecb-304"><xref:System.Xml.XmlDictionaryReader>Sınıfı doğrudan kullanırken, yalnızca belirli temel türlerin (örneğin,) yalnızca rastgele boyutu dizileri okumak için özel olarak tasarlanan yöntemleri, bu kotanın dikkate alınması gerektiğini aklınızda bulundurun <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-304">Keep in mind that when using the <xref:System.Xml.XmlDictionaryReader> class directly, only the methods that are specifically designed to read arrays of arbitrary size of certain primitive types, such as <xref:System.Xml.XmlDictionaryReader.ReadInt32Array%2A>, respect this quota.</span></span>

## <a name="threats-specific-to-the-binary-encoding"></a><span data-ttu-id="f6ecb-305">Ikili kodlamaya özgü tehditler</span><span class="sxs-lookup"><span data-stu-id="f6ecb-305">Threats Specific to the Binary Encoding</span></span>

<span data-ttu-id="f6ecb-306">İkili XML kodlaması WCF, bir *Sözlük dizeleri* özelliği içerir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-306">The binary XML encoding WCF supports includes a *dictionary strings* feature.</span></span> <span data-ttu-id="f6ecb-307">Büyük bir dize yalnızca birkaç bayt kullanılarak kodlanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-307">A large string may be encoded using only a few bytes.</span></span> <span data-ttu-id="f6ecb-308">Bu, önemli ölçüde performans artışı sağlar, ancak hafiflemesinin azaltılması gereken yeni hizmet reddi tehditleri sunar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-308">This enables significant performance gains, but introduces new denial-of-service threats that must be mitigated.</span></span>

<span data-ttu-id="f6ecb-309">İki tür sözlük vardır: *statik* ve *dinamik*.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-309">There are two kinds of dictionaries: *static* and *dynamic*.</span></span> <span data-ttu-id="f6ecb-310">Statik sözlük, ikili kodlamada kısa bir kod kullanılarak gösterilebilen uzun dizelerin yerleşik bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-310">The static dictionary is a built-in list of long strings that may be represented using a short code in the binary encoding.</span></span> <span data-ttu-id="f6ecb-311">Bu dizeler listesi okuyucu oluşturulduğunda ve değiştirilemediği zaman sabittir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-311">This list of strings is fixed when the reader is created and cannot be modified.</span></span> <span data-ttu-id="f6ecb-312">Statik sözlükte WCF 'nin varsayılan olarak kullandığı dizelerin hiçbiri, önemli bir hizmet reddi tehdidi oluşturma konusunda yeterince büyük değildir, ancak yine de sözlük genişletme saldırısında kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-312">None of the strings in the static dictionary that WCF uses by default are sufficiently large to pose a serious denial-of-service threat, although they may still be used in a dictionary expansion attack.</span></span> <span data-ttu-id="f6ecb-313">Kendi statik sözlüğünüzü sağladığınız Gelişmiş senaryolarda, büyük sözlük dizeleri oluştururken dikkatli olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-313">In advanced scenarios where you supply your own static dictionary, be careful when introducing large dictionary strings.</span></span>

<span data-ttu-id="f6ecb-314">Dinamik sözlükler özelliği, iletilerin kendi dizelerini tanımlamasına ve bunları kısa kodlarla ilişkilendirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-314">The dynamic dictionaries feature allows messages to define their own strings and associate them with short codes.</span></span> <span data-ttu-id="f6ecb-315">Bu dizeden koda eşlemeler tüm iletişim oturumu sırasında bellekte tutulur, örneğin sonraki iletiler dizelerin yeniden gönderilmesini gerektirmez ve önceden tanımlanmış kodlardan yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-315">These string-to-code mappings are kept in memory during the entire communication session, such that subsequent messages do not have to resend the strings and can utilize codes that are already defined.</span></span> <span data-ttu-id="f6ecb-316">Bu dizeler rastgele uzunlukta olabilir ve bu nedenle statik sözlükten daha ciddi bir tehdit oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-316">These strings may be of arbitrary length and thus pose a more serious threat than those in the static dictionary.</span></span>

<span data-ttu-id="f6ecb-317">Azaltılması gereken ilk tehdit, dinamik sözlüğün (dizeden koda eşleme tablosu) çok büyük hale gelmesine olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-317">The first threat that must be mitigated is the possibility of the dynamic dictionary (the string-to-code mapping table) becoming too large.</span></span> <span data-ttu-id="f6ecb-318">Bu sözlük birkaç ileti kursu üzerine genişletilebilir ve bu nedenle `MaxReceivedMessageSize` yalnızca her bir ileti için ayrı olarak uygulandığı için kota hiçbir koruma gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-318">This dictionary may be expanded over the course of several messages, and so the `MaxReceivedMessageSize` quota offers no protection because it applies only to each message separately.</span></span> <span data-ttu-id="f6ecb-319">Bu nedenle, içinde <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> sözlüğün boyutunu sınırlayan ayrı bir özellik bulunur <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-319">Therefore, a separate <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> property exists on the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement> that limits the size of the dictionary.</span></span>

<span data-ttu-id="f6ecb-320">Diğer kotaların aksine bu kota, ileti yazarken de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-320">Unlike most other quotas, this quota also applies when writing messages.</span></span> <span data-ttu-id="f6ecb-321">İleti okunurken aşılırsa, `QuotaExceededException` her zamanki gibi oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-321">If it is exceeded when reading a message, the `QuotaExceededException` is thrown as usual.</span></span> <span data-ttu-id="f6ecb-322">İleti yazılırken aşılırsa, kotanın aşılmasına neden olan dizeler, Dinamik sözlükler özelliği kullanılmadan olduğu gibi yazılır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-322">If it is exceeded when writing a message, any strings that cause the quota to be exceeded are written as-is, without using the dynamic dictionaries feature.</span></span>

### <a name="dictionary-expansion-threats"></a><span data-ttu-id="f6ecb-323">Sözlük genişletme tehditleri</span><span class="sxs-lookup"><span data-stu-id="f6ecb-323">Dictionary Expansion Threats</span></span>

<span data-ttu-id="f6ecb-324">Sözlük genişletmesinden sonra, ikili özel saldırıların önemli bir sınıfı.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-324">A significant class of binary-specific attacks arises from dictionary expansion.</span></span> <span data-ttu-id="f6ecb-325">İkili biçimdeki küçük bir ileti, dize sözlükleri özelliğinin yoğun bir şekilde kullanılmasını sağlayan tam olarak genişletilmiş metin biçiminde çok büyük bir ileti açabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-325">A small message in binary form may turn into a very large message in fully expanded textual form if it makes extensive use of the string dictionaries feature.</span></span> <span data-ttu-id="f6ecb-326">Dinamik sözlük dizeleri için genişleme faktörü, <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> Tüm sözlüğün en büyük boyutunu aştığından, kota tarafından sınırlandırılır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-326">The expansion factor for dynamic dictionary strings is limited by the <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> quota, because no dynamic dictionary string exceeds the maximum size of the entire dictionary.</span></span>

<span data-ttu-id="f6ecb-327"><xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength` Ve `MaxArrayLength` özellikleri yalnızca bellek tüketimini sınırlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-327">The <xref:System.Xml.XmlDictionaryReaderQuotas.MaxNameTableCharCount%2A>, `MaxStringContentLength`, and `MaxArrayLength` properties only limit memory consumption.</span></span> <span data-ttu-id="f6ecb-328">Bellek kullanımı zaten sınırlı olduğundan, akış olmayan kullanımdaki tehditleri hafifletmek genellikle gerekmez `MaxReceivedMessageSize` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-328">They are normally not required to mitigate any threats in the non-streamed usage because memory usage is already limited by `MaxReceivedMessageSize`.</span></span> <span data-ttu-id="f6ecb-329">Ancak, `MaxReceivedMessageSize` ön genişletme baytlarını sayar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-329">However, `MaxReceivedMessageSize` counts pre-expansion bytes.</span></span> <span data-ttu-id="f6ecb-330">İkili kodlama kullanımda olduğunda, bellek tüketimi büyük olasılıkla `MaxReceivedMessageSize` yalnızca bir faktörle sınırlı olabilir <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-330">When binary encoding is in use, memory consumption could potentially go beyond `MaxReceivedMessageSize`, limited only by a factor of <xref:System.ServiceModel.Channels.BinaryMessageEncodingBindingElement.MaxSessionSize%2A>.</span></span> <span data-ttu-id="f6ecb-331">Bu nedenle, ikili kodlama kullanılırken her zaman okuyucu kotaları (özellikle) ayarlanması önemlidir <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-331">For this reason, it is important to always set all of the reader quotas (especially <xref:System.Xml.XmlDictionaryReaderQuotas.MaxStringContentLength%2A>) when using the binary encoding.</span></span>

<span data-ttu-id="f6ecb-332">İkili kodlama ile birlikte kullanıldığında, <xref:System.Runtime.Serialization.DataContractSerializer> `IExtensibleDataObject` bir sözlük genişletme saldırısı bağlamak için arabirim kötüye kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-332">When using binary encoding together with the <xref:System.Runtime.Serialization.DataContractSerializer>, the `IExtensibleDataObject` interface can be misused to mount a dictionary expansion attack.</span></span> <span data-ttu-id="f6ecb-333">Bu arabirim temelde, sözleşmenin bir parçası olmayan rastgele veriler için sınırsız depolama alanı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-333">This interface essentially provides unlimited storage for arbitrary data that is not a part of the contract.</span></span> <span data-ttu-id="f6ecb-334">Kotalar, bir sorun ortaya çıkaran gibi yeterince düşük bir şekilde ayarlanmıyorsa `MaxSessionSize` `MaxReceivedMessageSize` , `IExtensibleDataObject` ikili kodlamayı kullanırken özelliği devre dışı bırakın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-334">If quotas cannot be set low enough such that `MaxSessionSize` multiplied by `MaxReceivedMessageSize` does not pose a problem, disable the `IExtensibleDataObject` feature when using the binary encoding.</span></span> <span data-ttu-id="f6ecb-335">`IgnoreExtensionDataObject`Özelliği özniteliğinde olarak ayarlayın `true` `ServiceBehaviorAttribute` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-335">Set the `IgnoreExtensionDataObject` property to `true` on the `ServiceBehaviorAttribute` attribute.</span></span> <span data-ttu-id="f6ecb-336">Alternatif olarak, `IExtensibleDataObject` arabirimini uygulamayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-336">Alternatively, do not implement the `IExtensibleDataObject` interface.</span></span> <span data-ttu-id="f6ecb-337">Daha fazla bilgi için bkz. [Ileri uyumlu veri sözleşmeleri](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-337">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span>

### <a name="quotas-summary"></a><span data-ttu-id="f6ecb-338">Kotalar Özeti</span><span class="sxs-lookup"><span data-stu-id="f6ecb-338">Quotas Summary</span></span>

<span data-ttu-id="f6ecb-339">Aşağıdaki tabloda kotalar hakkında rehberlik özetlenmektedir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-339">The following table summarizes the guidance about quotas.</span></span>

|<span data-ttu-id="f6ecb-340">Koşul</span><span class="sxs-lookup"><span data-stu-id="f6ecb-340">Condition</span></span>|<span data-ttu-id="f6ecb-341">Ayarlanacak önemli kotalar</span><span class="sxs-lookup"><span data-stu-id="f6ecb-341">Important quotas to set</span></span>|
|---------------|-----------------------------|
|<span data-ttu-id="f6ecb-342">Akış veya akış küçük iletileri, metin veya MTOM kodlaması yok</span><span class="sxs-lookup"><span data-stu-id="f6ecb-342">No streaming or streaming small messages, text, or MTOM encoding</span></span>|<span data-ttu-id="f6ecb-343">`MaxReceivedMessageSize`, `MaxBytesPerRead` ve `MaxDepth`</span><span class="sxs-lookup"><span data-stu-id="f6ecb-343">`MaxReceivedMessageSize`, `MaxBytesPerRead`, and `MaxDepth`</span></span>|
|<span data-ttu-id="f6ecb-344">Akış veya akış küçük iletileri, ikili kodlama</span><span class="sxs-lookup"><span data-stu-id="f6ecb-344">No streaming or streaming small messages, binary encoding</span></span>|<span data-ttu-id="f6ecb-345">`MaxReceivedMessageSize`, `MaxSessionSize` , ve tümü `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="f6ecb-345">`MaxReceivedMessageSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="f6ecb-346">Büyük ileti, metin veya MTOM kodlamasını akışa alma</span><span class="sxs-lookup"><span data-stu-id="f6ecb-346">Streaming large messages, text, or MTOM encoding</span></span>|<span data-ttu-id="f6ecb-347">`MaxBufferSize` ve tümü `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="f6ecb-347">`MaxBufferSize` and all `ReaderQuotas`</span></span>|
|<span data-ttu-id="f6ecb-348">Büyük iletileri akışa alma, ikili kodlama</span><span class="sxs-lookup"><span data-stu-id="f6ecb-348">Streaming large messages, binary encoding</span></span>|<span data-ttu-id="f6ecb-349">`MaxBufferSize`, `MaxSessionSize` , ve tümü `ReaderQuotas`</span><span class="sxs-lookup"><span data-stu-id="f6ecb-349">`MaxBufferSize`, `MaxSessionSize`, and all `ReaderQuotas`</span></span>|

- <span data-ttu-id="f6ecb-350">Aktarım düzeyi zaman aşımları her zaman ayarlanmalıdır ve büyük veya küçük iletiler akışı yapıp görmediğine bakılmaksızın, akış kullanımda olduğunda zaman uyumlu okuma/yazma işlemleri kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-350">Transport-level time-outs must always be set and never use synchronous reads/writes when streaming is in use, regardless of whether you are streaming large or small messages.</span></span>

- <span data-ttu-id="f6ecb-351">Bir kota hakkında şüpheli olduğunda, açık bırakmak yerine güvenli bir değere ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-351">When in doubt about a quota, set it to a safe value rather than leaving it open.</span></span>

## <a name="preventing-malicious-code-execution"></a><span data-ttu-id="f6ecb-352">Kötü amaçlı kod yürütmeyi önler</span><span class="sxs-lookup"><span data-stu-id="f6ecb-352">Preventing Malicious Code Execution</span></span>

<span data-ttu-id="f6ecb-353">Aşağıdaki genel tehdit sınıfları kodu yürütebilir ve istenmeyen etkilere sahip olabilir:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-353">The following general classes of threats can execute code and have unintended effects:</span></span>

- <span data-ttu-id="f6ecb-354">Seri hale getirici, kötü amaçlı, güvenli olmayan veya güvenliğe duyarlı bir tür yükler.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-354">The deserializer loads a malicious, unsafe, or security-sensitive type.</span></span>

- <span data-ttu-id="f6ecb-355">Gelen bir ileti, seri hale getiricinin, olağan dışı sonuçlara sahip olacak şekilde normal bir şekilde güvenli türde bir örnek oluşturmasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-355">An incoming message causes the deserializer to construct an instance of a normally safe type in such a way that it has unintended consequences.</span></span>

<span data-ttu-id="f6ecb-356">Aşağıdaki bölümlerde bu tehdit sınıfları daha fazla ele alınmaktadır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-356">The following sections discuss these classes of threats further.</span></span>

## <a name="datacontractserializer"></a><span data-ttu-id="f6ecb-357">DataContractSerializer</span><span class="sxs-lookup"><span data-stu-id="f6ecb-357">DataContractSerializer</span></span>

<span data-ttu-id="f6ecb-358">(Hakkında güvenlik bilgileri için <xref:System.Xml.Serialization.XmlSerializer> ilgili belgelere bakın.) İçin güvenlik modeli, <xref:System.Xml.Serialization.XmlSerializer> <xref:System.Runtime.Serialization.DataContractSerializer> ile benzerdir ve genellikle ayrıntılarda farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-358">(For security information on the <xref:System.Xml.Serialization.XmlSerializer>, see the relevant documentation.) The security model for the <xref:System.Xml.Serialization.XmlSerializer> is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>, and differs mostly in details.</span></span> <span data-ttu-id="f6ecb-359">Örneğin, <xref:System.Xml.Serialization.XmlIncludeAttribute> özniteliği özniteliği yerine tür içerme için kullanılır <xref:System.Runtime.Serialization.KnownTypeAttribute> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-359">For example, the <xref:System.Xml.Serialization.XmlIncludeAttribute> attribute is used for type inclusion instead of the <xref:System.Runtime.Serialization.KnownTypeAttribute> attribute.</span></span> <span data-ttu-id="f6ecb-360">Ancak, öğesine özgü bazı tehditler <xref:System.Xml.Serialization.XmlSerializer> Bu konunun ilerleyen kısımlarında ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-360">However, some threats unique to the <xref:System.Xml.Serialization.XmlSerializer> are discussed later in this topic.</span></span>

### <a name="preventing-unintended-types-from-being-loaded"></a><span data-ttu-id="f6ecb-361">Istenmeyen türlerin yüklenmesini önler</span><span class="sxs-lookup"><span data-stu-id="f6ecb-361">Preventing Unintended Types from Being Loaded</span></span>

<span data-ttu-id="f6ecb-362">İstenmeden türlerin yüklenmesi, türün kötü amaçlı olup olmadığı veya yalnızca güvenliğe duyarlı yan etkileri olan önemli sonuçlara sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-362">Loading unintended types may have significant consequences, whether the type is malicious or just has security-sensitive side effects.</span></span> <span data-ttu-id="f6ecb-363">Bir tür, açıktan yararlanma güvenlik açığı içerebilir, kurucuya da sınıf oluşturucusunda güvenliğe duyarlı eylemler gerçekleştirebilir, hizmet reddi saldırılarını kolaylaştıran büyük bir bellek parmak izine sahip olabilir veya kurtarılamaz özel durumlar oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-363">A type may contain exploitable security vulnerability, perform security-sensitive actions in its constructor or class constructor, have a large memory footprint that facilitates denial-of-service attacks, or may throw non-recoverable exceptions.</span></span> <span data-ttu-id="f6ecb-364">Türler, türü yüklendikten hemen sonra ve herhangi bir örnek oluşturulmadan önce çalışan sınıf oluşturuculara sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-364">Types may have class constructors that run as soon as the type is loaded and before any instances are created.</span></span> <span data-ttu-id="f6ecb-365">Bu nedenlerden dolayı, seri hale getiricinin yükleyebileceği tür kümesini denetlemek önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-365">For these reasons, it is important to control the set of types that the deserializer may load.</span></span>

<span data-ttu-id="f6ecb-366">, <xref:System.Runtime.Serialization.DataContractSerializer> Gevşek olarak bağlanmış bir şekilde seri hale getirir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-366">The <xref:System.Runtime.Serialization.DataContractSerializer> deserializes in a loosely coupled way.</span></span> <span data-ttu-id="f6ecb-367">Ortak dil çalışma zamanı (CLR) türünü ve gelen verilerden derleme adlarını hiçbir şekilde okumazlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-367">It never reads common language runtime (CLR) type and assembly names from the incoming data.</span></span> <span data-ttu-id="f6ecb-368">Bu, öğesinin davranışına benzerdir, ancak,, <xref:System.Xml.Serialization.XmlSerializer> ve ' nin davranışından farklıdır <xref:System.Runtime.Serialization.NetDataContractSerializer> <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-368">This is similar to the behavior of the <xref:System.Xml.Serialization.XmlSerializer>, but differs from the behavior of the <xref:System.Runtime.Serialization.NetDataContractSerializer>, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>, and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="f6ecb-369">Gevşek bir güvenlik derecesi, uzak saldırgan yalnızca iletideki türü adlandırarak, yüklenecek rastgele bir tür belirtemediği için bir güvenlik derecesi sunar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-369">Loose coupling introduces a degree of safety, because the remote attacker cannot indicate an arbitrary type to load just by naming that type in the message.</span></span>

<span data-ttu-id="f6ecb-370"><xref:System.Runtime.Serialization.DataContractSerializer>Her zaman sözleşmeye göre beklenen bir tür yüklemeye izin verilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-370">The <xref:System.Runtime.Serialization.DataContractSerializer> is always allowed to load a type that is currently expected according to the contract.</span></span> <span data-ttu-id="f6ecb-371">Örneğin, bir veri sözleşmesinin türünde bir veri üyesi varsa `Customer` , <xref:System.Runtime.Serialization.DataContractSerializer> `Customer` Bu veri üyesini serileştirtiğinde türü yüklemesine izin verilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-371">For example, if a data contract has a data member of type `Customer`, the <xref:System.Runtime.Serialization.DataContractSerializer> is allowed to load the `Customer` type when it deserializes this data member.</span></span>

<span data-ttu-id="f6ecb-372">Ayrıca, çok <xref:System.Runtime.Serialization.DataContractSerializer> biçimliliği destekler.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-372">Additionally, the <xref:System.Runtime.Serialization.DataContractSerializer> supports polymorphism.</span></span> <span data-ttu-id="f6ecb-373">Veri üyesi olarak bildirilebilecek <xref:System.Object> , ancak gelen veriler bir örnek içeriyor olabilir `Customer` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-373">A data member may be declared as <xref:System.Object>, but the incoming data may contain a `Customer` instance.</span></span> <span data-ttu-id="f6ecb-374">Bu, yalnızca `Customer` tür "bilinen" Bu mekanizmalardan biri aracılığıyla seri hale getirici 'e "bilindiğinde" yapılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-374">This is possible only if the `Customer` type has been made "known" to the deserializer through one of these mechanisms:</span></span>

- <span data-ttu-id="f6ecb-375"><xref:System.Runtime.Serialization.KnownTypeAttribute> bir türe uygulanan öznitelik.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-375"><xref:System.Runtime.Serialization.KnownTypeAttribute> attribute applied to a type.</span></span>

- <span data-ttu-id="f6ecb-376">`KnownTypeAttribute` bir tür listesi döndüren bir yöntemi belirten öznitelik.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-376">`KnownTypeAttribute` attribute specifying a method that returns a list of types.</span></span>

- <span data-ttu-id="f6ecb-377">`ServiceKnownTypeAttribute` özniteliğe.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-377">`ServiceKnownTypeAttribute` attribute.</span></span>

- <span data-ttu-id="f6ecb-378">`KnownTypes`Yapılandırma bölümü.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-378">The `KnownTypes` configuration section.</span></span>

- <span data-ttu-id="f6ecb-379">Serileştirici doğrudan kullanılıyorsa, oluşturma sırasında açıkça kendisine geçirilen bilinen türlerin listesi <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-379">A list of known types explicitly passed to the <xref:System.Runtime.Serialization.DataContractSerializer> during construction, if using the serializer directly.</span></span>

<span data-ttu-id="f6ecb-380">Bu mekanizmaların her biri, seri hale getiricinin yükleyemekte olduğu daha fazla tür sunarak yüzey alanını artırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-380">Each of these mechanisms increases the surface area by introducing more types that the deserializer can load.</span></span> <span data-ttu-id="f6ecb-381">Bilinen türler listesine kötü amaçlı veya istenmeyen türlerin eklenmemesini sağlamak için bu mekanizmaların her birini denetleyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-381">Control each of these mechanisms to ensure no malicious or unintended types are added to the known types list.</span></span>

<span data-ttu-id="f6ecb-382">Bilinen bir tür kapsam içinde olduğunda, bu, herhangi bir zamanda yüklenebilir ve anlaşma gerçekten onu kullanıyor olsa bile, türün örnekleri oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-382">Once a known type is in scope, it can be loaded at any time, and instances of the type can be created, even if the contract forbids actually using it.</span></span> <span data-ttu-id="f6ecb-383">Örneğin, yukarıdaki mekanizmalardan birini kullanarak "MyDangerousType" türünün bilinen türler listesine eklendiğini varsayalım.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-383">For example, suppose the type "MyDangerousType" is added to the known types list using one of the mechanisms above.</span></span> <span data-ttu-id="f6ecb-384">Bunun anlamı:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-384">This means that:</span></span>

- <span data-ttu-id="f6ecb-385">`MyDangerousType` yüklenir ve sınıf oluşturucusu çalışır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-385">`MyDangerousType` is loaded and its class constructor runs.</span></span>

- <span data-ttu-id="f6ecb-386">Bir veri sözleşmesinin dize veri üyesine serisi kaldırılırken bile kötü amaçlı bir ileti bir örneğinin oluşturulmasına neden olabilir `MyDangerousType` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-386">Even when deserializing a data contract with a string data member, a malicious message may still cause an instance of `MyDangerousType` to create.</span></span> <span data-ttu-id="f6ecb-387">İçindeki `MyDangerousType` özellik ayarlayıcıları gibi kod çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-387">Code in `MyDangerousType`, such as property setters, may run.</span></span> <span data-ttu-id="f6ecb-388">Bu yapıldıktan sonra, seri hale getirici bu örneği dize veri üyesine atamayı dener ve bir özel durumla başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-388">After this is done, the deserializer tries to assign this instance to the string data member and fail with an exception.</span></span>

<span data-ttu-id="f6ecb-389">Bilinen türlerin bir listesini döndüren veya bir listeyi doğrudan oluşturucuya geçirirken bir yöntemi yazarken <xref:System.Runtime.Serialization.DataContractSerializer> , listeyi hazırlayan kodun güvenli olduğundan ve yalnızca güvenilir veriler üzerinde çalıştığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-389">When writing a method that returns a list of known types, or when passing a list directly to the <xref:System.Runtime.Serialization.DataContractSerializer> constructor, ensure that the code that prepares the list is secure and operates only on trusted data.</span></span>

<span data-ttu-id="f6ecb-390">Yapılandırmada bilinen türleri belirtirken, yapılandırma dosyasının güvenli olduğundan emin olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-390">If specifying known types in configuration, ensure that the configuration file is secure.</span></span> <span data-ttu-id="f6ecb-391">Yapılandırmada her zaman tanımlayıcı adlar kullanın (türün bulunduğu imzalı derlemenin ortak anahtarını belirterek), ancak yüklenecek türün sürümünü belirtmeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-391">Always use strong names in configuration (by specifying the public key of the signed assembly where the type resides), but do not specify the version of the type to load.</span></span> <span data-ttu-id="f6ecb-392">Tür yükleyicisi, mümkünse en son sürümü otomatik olarak seçer.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-392">The type loader automatically picks the latest version, if possible.</span></span> <span data-ttu-id="f6ecb-393">Yapılandırmada belirli bir sürümü belirtirseniz, aşağıdaki riski çalıştırırsınız: bir tür, gelecekteki bir sürümde düzeltilebilecek bir güvenlik güvenlik açığına sahip olabilir, ancak yapılandırmada açık bir şekilde belirtildiğinden, savunmasız sürüm hala yüklenir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-393">If you specify a particular version in configuration, you run the following risk: A type may have a security vulnerability that may be fixed in a future version, but the vulnerable version still loads because it is explicitly specified in configuration.</span></span>

<span data-ttu-id="f6ecb-394">Çok sayıda bilinen türün başka bir sonucu vardır:, <xref:System.Runtime.Serialization.DataContractSerializer> uygulama etki alanında serileştirme ve seri durumdan çıkarma gereken her tür için bir giriş içeren bir serileştirme/seri hale getirme kodu önbelleği oluşturur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-394">Having too many known types has another consequence: The <xref:System.Runtime.Serialization.DataContractSerializer> creates a cache of serialization/deserialization code in the application domain, with an entry for each type it must serialize and deserialize.</span></span> <span data-ttu-id="f6ecb-395">Bu önbellek, uygulama etki alanı çalıştığı sürece hiçbir zaman temizlenmez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-395">This cache is never cleared as long as the application domain is running.</span></span> <span data-ttu-id="f6ecb-396">Bu nedenle, bir uygulamanın birçok bilinen türü kullandığını algılayan bir saldırgan bu türlerin serisini kaldırma, önbelleğin orantısız büyük miktarda belleği kullanmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-396">Therefore, an attacker who is aware that an application uses many known types can cause the deserialization of all these types, causing the cache to consume a disproportionately large amount of memory.</span></span>

### <a name="preventing-types-from-being-in-an-unintended-state"></a><span data-ttu-id="f6ecb-397">Türlerin ISTENMEDEN bir durumda olmasını önlemek</span><span class="sxs-lookup"><span data-stu-id="f6ecb-397">Preventing Types from Being in an Unintended State</span></span>

<span data-ttu-id="f6ecb-398">Bir tür, Zorlanmış olması gereken iç tutarlılık kısıtlamalarına sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-398">A type may have internal consistency constraints that must be enforced.</span></span> <span data-ttu-id="f6ecb-399">Seri durumdan çıkarma sırasında bu kısıtlamaların kesilmesini önlemek için dikkatli olunmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-399">Care must be taken to avoid breaking these constraints during deserialization.</span></span>

<span data-ttu-id="f6ecb-400">Aşağıdaki bir tür örneği, bir spaceckft üzerindeki Airlock 'un durumunu temsil eder ve hem iç hem de dış kapıların aynı anda açık olmadığı kısıtlamayı zorlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-400">The following example of a type represents the state of an airlock on a spacecraft, and enforces the constraint that both the inner and the outer doors cannot be open at the same time.</span></span>

[!code-csharp[DataContractAttribute#3](../../../../samples/snippets/csharp/VS_Snippets_CFX/datacontractattribute/cs/overview.cs#3)]
[!code-vb[DataContractAttribute#3](../../../../samples/snippets/visualbasic/VS_Snippets_CFX/datacontractattribute/vb/overview.vb#3)]

<span data-ttu-id="f6ecb-401">Bir saldırgan bunun gibi kötü amaçlı bir ileti gönderebilir ve bu, kısıtlamaları ve nesneyi geçersiz duruma getirmeye karşı istenmeyen ve öngörülemeyen sonuçlara yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-401">An attacker may send a malicious message like this, getting around the constraints and getting the object into an invalid state, which may have unintended and unpredictable consequences.</span></span>

```xml
<SpaceStationAirlock>
    <innerDoorOpen>true</innerDoorOpen>
    <outerDoorOpen>true</outerDoorOpen>
</SpaceStationAirlock>
```

<span data-ttu-id="f6ecb-402">Bu durumun aşağıdaki noktalara dikkat ederek kaçınılabilir:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-402">This situation can be avoided by being aware of the following points:</span></span>

- <span data-ttu-id="f6ecb-403"><xref:System.Runtime.Serialization.DataContractSerializer>Çoğu sınıfı seri hale geldiğinde, oluşturucular çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-403">When the <xref:System.Runtime.Serialization.DataContractSerializer> deserializes most classes, constructors do not run.</span></span> <span data-ttu-id="f6ecb-404">Bu nedenle, oluşturucuda gerçekleştirilen herhangi bir durum yönetimine güvenmeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-404">Therefore, do not rely on any state management done in the constructor.</span></span>

- <span data-ttu-id="f6ecb-405">Nesnenin geçerli bir durumda olduğundan emin olmak için geri çağırmaları kullanın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-405">Use callbacks to ensure that the object is in a valid state.</span></span> <span data-ttu-id="f6ecb-406">Özniteliği ile işaretlenen geri çağırma <xref:System.Runtime.Serialization.OnDeserializedAttribute> işlemi, seri durumdan çıkarma tamamlandıktan sonra çalıştığı ve genel durumu İnceleme ve düzeltme şansı varsa özellikle yararlıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-406">The callback marked with the <xref:System.Runtime.Serialization.OnDeserializedAttribute> attribute is especially useful because it runs after deserialization is complete and has a chance to examine and correct the overall state.</span></span> <span data-ttu-id="f6ecb-407">Daha fazla bilgi için bkz. [Sürüm dayanıklı serileştirme geri çağırmaları](version-tolerant-serialization-callbacks.md).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-407">For more information, see [Version-Tolerant Serialization Callbacks](version-tolerant-serialization-callbacks.md).</span></span>

- <span data-ttu-id="f6ecb-408">Veri anlaşması türlerini, özellik ayarlayıcılarının çağrılması gereken belirli bir sıraya göre tasarlamayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-408">Do not design data contract types to rely on any particular order in which property setters must be called.</span></span>

- <span data-ttu-id="f6ecb-409">Özniteliğiyle işaretlenmiş eski türleri kullanarak dikkatli yapın <xref:System.SerializableAttribute> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-409">Take care using legacy types marked with the <xref:System.SerializableAttribute> attribute.</span></span> <span data-ttu-id="f6ecb-410">Bunların birçoğu yalnızca güvenilir verilerle kullanılmak üzere .NET Framework uzaktan iletişim için tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-410">Many of them were designed to work with .NET Framework remoting for use with trusted data only.</span></span> <span data-ttu-id="f6ecb-411">Bu öznitelikle işaretlenen mevcut türler, durum güvenliği göz önünde bulundurularak tasarlanmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-411">Existing types marked with this attribute may not have been designed with state safety in mind.</span></span>

- <span data-ttu-id="f6ecb-412"><xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> <xref:System.Runtime.Serialization.DataMemberAttribute> Durum güvenliği açısından verilerin varlığını güvence altına almak için özniteliğinin özelliğine güvenmeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-412">Do not rely on the <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A> property of the <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to guarantee presence of data as far as state safety is concerned.</span></span> <span data-ttu-id="f6ecb-413">Veriler her zaman, `null` `zero` veya olabilir `invalid` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-413">Data could always be `null`, `zero`, or `invalid`.</span></span>

- <span data-ttu-id="f6ecb-414">Güvenilmeyen bir veri kaynağından Serisi kaldırılan bir nesne grafiğine hiçbir şekilde güvenmez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-414">Never trust an object graph deserialized from an untrusted data source without validating it first.</span></span> <span data-ttu-id="f6ecb-415">Tek tek her nesne tutarlı bir durumda olabilir, ancak nesne grafı bir bütün olarak olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-415">Each individual object may be in a consistent state, but the object graph as a whole may not be.</span></span> <span data-ttu-id="f6ecb-416">Ayrıca, nesne grafik koruma modu devre dışı olsa bile, serisi kaldırılan grafikte aynı nesneye birden fazla başvuru olabilir veya döngüsel başvurular olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-416">Furthermore, even if the object graph preservation mode is disabled, the deserialized graph may have multiple references to the same object or have circular references.</span></span> <span data-ttu-id="f6ecb-417">Daha fazla bilgi için bkz. [serileştirme ve seri durumundan çıkarma](serialization-and-deserialization.md).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-417">For more information, see [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

### <a name="using-the-netdatacontractserializer-securely"></a><span data-ttu-id="f6ecb-418">NetDataContractSerializer 'ı güvenli kullanma</span><span class="sxs-lookup"><span data-stu-id="f6ecb-418">Using the NetDataContractSerializer Securely</span></span>

<span data-ttu-id="f6ecb-419">, <xref:System.Runtime.Serialization.NetDataContractSerializer> Türlerine sıkı biçimde kullanan bir serileştirme altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-419">The <xref:System.Runtime.Serialization.NetDataContractSerializer> is a serialization engine that uses tight coupling to types.</span></span> <span data-ttu-id="f6ecb-420">Bu, <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> ve ' a benzerdir <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-420">This is similar to the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> and the <xref:System.Runtime.Serialization.Formatters.Soap.SoapFormatter>.</span></span> <span data-ttu-id="f6ecb-421">Diğer bir deyişle, gelen verilerden .NET Framework derlemeyi ve tür adını okuyarak hangi türün örneklendirilecek olduğunu belirler.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-421">That is, it determines which type to instantiate by reading the .NET Framework assembly and type name from the incoming data.</span></span> <span data-ttu-id="f6ecb-422">WCF 'nin bir parçası olsa da, bu serileştirme altyapısını takma yöntemi değildir; özel kod yazılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-422">Although it is a part of WCF, there is no supplied way of plugging in this serialization engine; custom code must be written.</span></span> <span data-ttu-id="f6ecb-423">, `NetDataContractSerializer` Öncelikle .NET Framework uzaktan iletişim IÇIN WCF 'e geçiş kolaylığı sağlar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-423">The `NetDataContractSerializer` is provided primarily to ease migration from .NET Framework remoting to WCF.</span></span> <span data-ttu-id="f6ecb-424">Daha fazla bilgi için [serileştirme ve seri durumundan çıkarma](serialization-and-deserialization.md)bölümündeki ilgili bölüme bakın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-424">For more information, see the relevant section in [Serialization and Deserialization](serialization-and-deserialization.md).</span></span>

<span data-ttu-id="f6ecb-425">İletinin kendisi herhangi bir tür yüklenebildiğinden, <xref:System.Runtime.Serialization.NetDataContractSerializer> mekanizma doğal olarak güvenli değildir ve yalnızca güvenilir verilerle kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-425">Because the message itself may indicate any type can be loaded, the <xref:System.Runtime.Serialization.NetDataContractSerializer> mechanism is inherently insecure and should be used only with trusted data.</span></span> <span data-ttu-id="f6ecb-426">Daha fazla bilgi için, bkz. [BinaryFormatter Güvenlik Kılavuzu](../../../standard/serialization/binaryformatter-security-guide.md).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-426">For more information, see the [BinaryFormatter security guide](../../../standard/serialization/binaryformatter-security-guide.md).</span></span>

<span data-ttu-id="f6ecb-427">Güvenilen verilerle birlikte kullanıldığında, gelen veriler, özellikle özelliği olarak ayarlandıysa, yüklenecek türü yeterince belirleyebilir <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-427">Even when used with trusted data, the incoming data may insufficiently specify the type to load, especially if the <xref:System.Runtime.Serialization.NetDataContractSerializer.AssemblyFormat%2A> property is set to <xref:System.Runtime.Serialization.Formatters.FormatterAssemblyStyle.Simple>.</span></span> <span data-ttu-id="f6ecb-428">Uygulamanın dizinine veya genel derleme önbelleğine erişimi olan herkes, yüklenmesi beklenen kötü amaçlı bir türü yerine getirebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-428">Anyone with access to the application’s directory or to the global assembly cache can substitute a malicious type in place of the one that is supposed to load.</span></span> <span data-ttu-id="f6ecb-429">İzinleri doğru şekilde ayarlayarak uygulamanızın dizininin ve genel derleme önbelleğinin güvenliğinin her zaman emin olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-429">Always ensure the security of your application’s directory and of the global assembly cache by correctly setting permissions.</span></span>

<span data-ttu-id="f6ecb-430">Genel olarak, örneğinize kısmen güvenilen kod erişimine izin verirseniz `NetDataContractSerializer` veya yedek seçiciyi ( <xref:System.Runtime.Serialization.ISurrogateSelector> ) veya seri hale getirme cildi () kontrol ediyorsanız <xref:System.Runtime.Serialization.SerializationBinder> , kod serileştirme/seri kaldırma işlemi üzerinde harika bir denetim uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-430">In general, if you allow partially trusted code access to your `NetDataContractSerializer` instance or otherwise control the surrogate selector (<xref:System.Runtime.Serialization.ISurrogateSelector>) or the serialization binder (<xref:System.Runtime.Serialization.SerializationBinder>), the code may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="f6ecb-431">Örneğin, rastgele türler ekleyebilir, bilgilerin açığa çıkmasına, sonuçta ortaya çıkan nesne grafı veya serileştirilmiş verilerle oynanmasına ya da sonuç olarak seri hale getirilmiş akış taşmasına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-431">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span>

<span data-ttu-id="f6ecb-432">İle ilgili başka bir güvenlik, `NetDataContractSerializer` kötü amaçlı kod yürütme tehdidi değil, hizmet reddine neden olur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-432">Another security concern with the `NetDataContractSerializer` is a denial of service, not a malicious code execution threat.</span></span> <span data-ttu-id="f6ecb-433">Kullanırken `NetDataContractSerializer` , her zaman <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> kotayı güvenli bir değer olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-433">When using the `NetDataContractSerializer`, always set the <xref:System.Runtime.Serialization.NetDataContractSerializer.MaxItemsInObjectGraph%2A> quota to a safe value.</span></span> <span data-ttu-id="f6ecb-434">Boyutu yalnızca bu kotayla sınırlı olan bir nesne dizisini ayıran küçük bir kötü amaçlı ileti oluşturmak kolaydır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-434">It is easy to construct a small malicious message that allocates an array of objects whose size is limited only by this quota.</span></span>

### <a name="xmlserializer-specific-threats"></a><span data-ttu-id="f6ecb-435">XmlSerializer-Specific tehditler</span><span class="sxs-lookup"><span data-stu-id="f6ecb-435">XmlSerializer-Specific Threats</span></span>

<span data-ttu-id="f6ecb-436"><xref:System.Xml.Serialization.XmlSerializer>Güvenlik modeli, ile benzerdir <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-436">The <xref:System.Xml.Serialization.XmlSerializer> security model is similar to that of the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="f6ecb-437">Ancak, birkaç tehdit için benzersizdir <xref:System.Xml.Serialization.XmlSerializer> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-437">A few threats, however, are unique to the <xref:System.Xml.Serialization.XmlSerializer>.</span></span>

<span data-ttu-id="f6ecb-438">, <xref:System.Xml.Serialization.XmlSerializer> Çalışma zamanında *serileştirme derlemeleri* oluşturur ve bunları seri hale getirir ve onları yeniden çıkarır; bu derlemeler geçici dosyalar dizininde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-438">The <xref:System.Xml.Serialization.XmlSerializer> generates *serialization assemblies* at runtime that contain code that actually serializes and deserializes; these assemblies are created in a temporary files directory.</span></span> <span data-ttu-id="f6ecb-439">Başka bir işlem veya kullanıcının bu dizine erişim hakları varsa, bu, rastgele kodla serileştirme/seri kaldırma kodunun üzerine yazabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-439">If some other process or user has access rights to that directory, they may overwrite the serialization/deserialization code with arbitrary code.</span></span> <span data-ttu-id="f6ecb-440"><xref:System.Xml.Serialization.XmlSerializer>Ardından, serileştirme/seri durumdan çıkarma kodu yerine bu kodu güvenlik bağlamını kullanarak çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-440">The <xref:System.Xml.Serialization.XmlSerializer> then runs this code using its security context, instead of the serialization/deserialization code.</span></span> <span data-ttu-id="f6ecb-441">Bunun oluşmasını engellemek için izinlerin geçici dosyalar dizininde doğru ayarlandığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-441">Make sure the permissions are set correctly on the temporary files directory to prevent this from happening.</span></span>

<span data-ttu-id="f6ecb-442"><xref:System.Xml.Serialization.XmlSerializer>Ayrıca, çalışma zamanında oluşturmak yerine önceden oluşturulmuş serileştirme derlemelerinin kullanıldığı bir moda sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-442">The <xref:System.Xml.Serialization.XmlSerializer> also has a mode in which it uses pre-generated serialization assemblies instead of generating them at runtime.</span></span> <span data-ttu-id="f6ecb-443">Bu mod <xref:System.Xml.Serialization.XmlSerializer> uygun bir serileştirme derlemesini her bulabileceği zaman tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-443">This mode is triggered whenever the <xref:System.Xml.Serialization.XmlSerializer> can find a suitable serialization assembly.</span></span> <span data-ttu-id="f6ecb-444"><xref:System.Xml.Serialization.XmlSerializer>Serileştirme derlemesinin seri hale getirilen türleri içeren derlemeyi imzalamak için kullanılan anahtarla imzalanmış olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-444">The <xref:System.Xml.Serialization.XmlSerializer> checks whether or not the serialization assembly was signed by the same key that was used to sign the assembly that contains the types being serialized.</span></span> <span data-ttu-id="f6ecb-445">Bu, kötü amaçlı derlemelerden serileştirme derlemeleri olarak yürütülen koruma sunar.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-445">This offers protection from malicious assemblies being disguised as serialization assemblies.</span></span> <span data-ttu-id="f6ecb-446">Ancak, serileştirilebilir türlerinizi içeren derleme imzalanmamışsa, <xref:System.Xml.Serialization.XmlSerializer> Bu denetimi gerçekleştiremez ve doğru ada sahip herhangi bir derlemeyi kullanır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-446">However, if the assembly that contains your serializable types is not signed, the <xref:System.Xml.Serialization.XmlSerializer> cannot perform this check and uses any assembly with the correct name.</span></span> <span data-ttu-id="f6ecb-447">Bu, kötü amaçlı kod çalışmasını mümkün hale getirir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-447">This makes running malicious code possible.</span></span> <span data-ttu-id="f6ecb-448">Yalnızca serileştirilebilir türlerinizi içeren derlemeleri veya kötü amaçlı derlemelerin giriş durumunu engellemek için uygulamanızın dizinine ve genel derleme önbelleğine erişimi sıkı bir şekilde denetleyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-448">Always sign the assemblies that contain your serializable types, or tightly control access to your application’s directory and the global assembly cache to prevent the introduction of malicious assemblies.</span></span>

<span data-ttu-id="f6ecb-449"><xref:System.Xml.Serialization.XmlSerializer>Hizmet reddi saldırısına tabi olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-449">The <xref:System.Xml.Serialization.XmlSerializer> can be subject to a denial of service attack.</span></span> <span data-ttu-id="f6ecb-450"><xref:System.Xml.Serialization.XmlSerializer>Bir `MaxItemsInObjectGraph` kotası yoktur (üzerinde olduğu gibi <xref:System.Runtime.Serialization.DataContractSerializer> ).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-450">The <xref:System.Xml.Serialization.XmlSerializer> does not have a `MaxItemsInObjectGraph` quota (as is available on the <xref:System.Runtime.Serialization.DataContractSerializer>).</span></span> <span data-ttu-id="f6ecb-451">Bu nedenle, yalnızca ileti boyutuyla sınırlı olan, rastgele bir nesne miktarını serileştirir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-451">Thus, it deserializes an arbitrary amount of objects, limited only by the message size.</span></span>

### <a name="partial-trust-threats"></a><span data-ttu-id="f6ecb-452">Kısmi güven tehditleri</span><span class="sxs-lookup"><span data-stu-id="f6ecb-452">Partial Trust Threats</span></span>

<span data-ttu-id="f6ecb-453">Kısmi güvenle çalışan kodla ilgili tehditlere ilişkin aşağıdaki kaygılara dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-453">Note the following concerns regarding threats related to code running with partial trust.</span></span> <span data-ttu-id="f6ecb-454">Bu tehditler, kötü amaçlı kısmen güvenilen kodun yanı sıra diğer saldırı senaryolarıyla birlikte kötü amaçlı kısmen güvenilen kod içerir (örneğin, belirli bir dizeyi oluşturan ve serisini kaldırma kısmen güvenilen kod).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-454">These threats include malicious partially-trusted code as well as malicious partially-trusted code in combination with other attack scenarios (for example, partially-trusted code that constructs a specific string and then deserializing it).</span></span>

- <span data-ttu-id="f6ecb-455">Herhangi bir serileştirme bileşeni kullanırken, tüm serileştirme senaryosu sizin onay kapsamı içinde olsa bile, bu kullanımdan önce hiçbir izni hiçbir zaman onaylama, ancak güvenilmeyen herhangi bir veri veya nesne ile ilgilenmeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-455">When using any serialization components, never assert any permissions before such usage, even if the entire serialization scenario is within the scope of your assert, and you are not dealing with any untrusted data or objects.</span></span> <span data-ttu-id="f6ecb-456">Bu tür kullanımlar güvenlik açıklarına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-456">Such usage may lead to security vulnerabilities.</span></span>

- <span data-ttu-id="f6ecb-457">Kısmen güvenilen kodun, serileştirme süreci üzerinde, genişletilebilirlik noktaları (yedeklerin kapıları), serileştirildiği türler veya diğer yollarla denetimi olduğu durumlarda, kısmen güvenilen kod seri hale getiricinin büyük miktarda verinin serileştirilmiş akışa çıkış olmasına neden olabilir ve bu da bu akışın alıcısından hizmet reddi (DoS) oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-457">In cases where partially-trusted code has control over the serialization process, either through extensibility points (surrogates), types being serialized, or through other means, the partially-trusted code may cause the serializer to output a large amount of data into the serialized stream, which may cause Denial of Service (DoS) to the receiver of this stream.</span></span> <span data-ttu-id="f6ecb-458">DoS tehditleri açısından duyarlı olan bir hedef için tasarlanan verileri serileştirdiyseniz kısmen güvenilen türler serileştirmeyin veya kısmen güvenilen kod denetimi serileştirmesine izin vermeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-458">If you are serializing data intended for a target that is sensitive to DoS threats, do not serialize partially-trusted types or otherwise let partially-trusted code control serialization.</span></span>

- <span data-ttu-id="f6ecb-459">Örneğiniz için kısmen güvenilen kod erişimine izin verirseniz <xref:System.Runtime.Serialization.DataContractSerializer> veya [veri sözleşmesinin yedeklerin kapılarını](../extending/data-contract-surrogates.md)kontrol ediyorsanız, serileştirme/seri kaldırma işlemi üzerinde çok fazla denetim uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-459">If you allow partially-trusted code access to your <xref:System.Runtime.Serialization.DataContractSerializer> instance or otherwise control the [Data Contract Surrogates](../extending/data-contract-surrogates.md), it may exercise a great deal of control over the serialization/deserialization process.</span></span> <span data-ttu-id="f6ecb-460">Örneğin, rastgele türler ekleyebilir, bilgilerin açığa çıkmasına, sonuçta ortaya çıkan nesne grafı veya serileştirilmiş verilerle oynanmasına ya da sonuç olarak seri hale getirilmiş akış taşmasına yol açabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-460">For example, it may inject arbitrary types, lead to information disclosure, tamper with the resulting object graph or serialized data, or overflow the resultant serialized stream.</span></span> <span data-ttu-id="f6ecb-461">Eşdeğer <xref:System.Runtime.Serialization.NetDataContractSerializer> tehdit, "NetDataContractSerializer güvenli kullanımı" bölümünde açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-461">An equivalent <xref:System.Runtime.Serialization.NetDataContractSerializer> threat is described in the "Using the NetDataContractSerializer Securely" section.</span></span>

- <span data-ttu-id="f6ecb-462"><xref:System.Runtime.Serialization.DataContractAttribute>Öznitelik bir türe uygulanmışsa (veya olarak işaretlenen tür olarak işaretlenmiş <xref:System.SerializableAttribute> ancak yoksa <xref:System.Runtime.Serialization.ISerializable> ), tüm oluşturucular genel olmayan veya taleplerine göre korunsa bile, seri hale getirici böyle bir türün bir örneğini oluşturabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-462">If the <xref:System.Runtime.Serialization.DataContractAttribute> attribute is applied to a type (or the type marked as <xref:System.SerializableAttribute> but is not <xref:System.Runtime.Serialization.ISerializable>), the deserializer can create an instance of such a type even if all constructors are non-public or protected by demands.</span></span>

- <span data-ttu-id="f6ecb-463">Seri durumdan çıkarılacak veriler güvenilir olmadığından ve bilinen tüm türlerin güvendiğiniz türler olduğundan emin değilseniz, seri durumdan çıkarma sonucuna hiçbir şekilde güvenmeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-463">Never trust the result of deserialization unless the data to be deserialized is trusted and you are certain that all known types are types that you trust.</span></span> <span data-ttu-id="f6ecb-464">Bilinen türlerin, kısmi güvende çalışırken uygulama yapılandırma dosyasından yüklenmediğini (ancak bilgisayar yapılandırma dosyasından yüklendiğini) unutmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-464">Note that known types are not loaded from the application configuration file, (but are loaded from the computer configuration file) when running in partial trust.</span></span>

- <span data-ttu-id="f6ecb-465"><xref:System.Runtime.Serialization.DataContractSerializer>Kısmen güvenilen koda eklenen bir yedek içeren bir örnek geçirirseniz, kod o vekil üzerinde değiştirilebilir tüm ayarları değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-465">If you pass a <xref:System.Runtime.Serialization.DataContractSerializer> instance with a surrogate added to partially-trusted code, the code can change any modifiable settings on that surrogate.</span></span>

- <span data-ttu-id="f6ecb-466">Seri durumdan çıkarılmış bir nesne için, XML okuyucu (veya içindeki veriler) kısmen güvenilen koddan geliyorsa, sonuçta elde edilen seri durumdan çıkarılmış nesneyi güvenilmeyen veriler olarak değerlendirin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-466">For a deserialized object, if the XML reader (or the data therein) comes from partially-trusted code, treat the resulting deserialized object as untrusted data.</span></span>

- <span data-ttu-id="f6ecb-467"><xref:System.Runtime.Serialization.ExtensionDataObject>Türün ortak üyesi olmaması aslında, içindeki verilerin güvenli olduğu anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-467">The fact that the <xref:System.Runtime.Serialization.ExtensionDataObject> type has no public members does not mean that data within it is secure.</span></span> <span data-ttu-id="f6ecb-468">Örneğin, ayrıcalıklı bir veri kaynağından bazı verilerin bulunduğu bir nesne olarak seri durumdan çıkardıysanız ve bu nesneyi kısmen güvenilen koda verirseniz, kısmen güvenilen kod `ExtensionDataObject` nesneyi serileştirerek içindeki verileri okuyabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-468">For example, if you deserialize from a privileged data source into an object in which some data resides, then hand that object to partially-trusted code, the partially-trusted code can read the data in the `ExtensionDataObject` by serializing the object.</span></span> <span data-ttu-id="f6ecb-469"><xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> `true` Ayrıcalıklı bir veri kaynağından, daha sonra kısmen güvenilen koda geçirilen bir nesneye ne zaman seri durumdan çıkarılırken, öğesini olarak ayarlamayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-469">Consider setting <xref:System.Runtime.Serialization.DataContractSerializer.IgnoreExtensionDataObject%2A> to `true` when deserializing from a privileged data source into an object that is later passed to partially-trusted code.</span></span>

- <span data-ttu-id="f6ecb-470"><xref:System.Runtime.Serialization.DataContractSerializer> ve <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> tam güvende özel, korunan, iç ve ortak üyelerin serileştirmesini destekler.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-470"><xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> support the serialization of private, protected, internal, and public members in full trust.</span></span> <span data-ttu-id="f6ecb-471">Ancak kısmi güvende yalnızca ortak üyeler seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-471">However, in partial trust, only public members can be serialized.</span></span> <span data-ttu-id="f6ecb-472">Bir <xref:System.Security.SecurityException> uygulama genel olmayan bir üyeyi serileştirmek istediğinde, oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-472">A <xref:System.Security.SecurityException> is thrown if an application attempts to serialize a non-public member.</span></span>

    <span data-ttu-id="f6ecb-473">İç veya korumalı iç üyelerin kısmi güvende serileştirilmesine izin vermek için <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> derleme özniteliğini kullanın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-473">To allow internal or protected internal members to be serialized in partial trust, use the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> assembly attribute.</span></span> <span data-ttu-id="f6ecb-474">Bu öznitelik, bir derlemenin iç üyelerinin diğer bir derlemede görünür olduğunu bildirmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-474">This attribute allows an assembly to declare that its internal members are visible to some other assembly.</span></span> <span data-ttu-id="f6ecb-475">Bu durumda, iç üyelerinin serileştirilmesi isteyen bir derleme, iç üyelerinin System.Runtime.Serialization.dll görünür olduğunu bildirir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-475">In this case, an assembly that wants to have its internal members serialized declares that its internal members are visible to System.Runtime.Serialization.dll.</span></span>

    <span data-ttu-id="f6ecb-476">Bu yaklaşımın avantajı, yükseltilmiş kod oluşturma yolu gerektirmemelidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-476">The advantage of this approach is that it does not require an elevated code generation path.</span></span>

    <span data-ttu-id="f6ecb-477">Aynı zamanda, iki önemli olumsuz de vardır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-477">At the same time, there are two major disadvantages.</span></span>

    <span data-ttu-id="f6ecb-478">Birinci dezavantajı, özniteliğin kabul etme özelliğinin <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> bütünleştirilmiş kod genelinde bir özelliktir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-478">The first disadvantage is that the opt-in property of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute is assembly-wide.</span></span> <span data-ttu-id="f6ecb-479">Diğer bir deyişle, yalnızca belirli bir sınıfın iç üyeleri seri hale getirilebilir olduğunu belirtemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-479">That is, you cannot specify that only a certain class can have its internal members serialized.</span></span> <span data-ttu-id="f6ecb-480">Kuşkusuz, belirli bir iç üyeyi seri hale getirmeniz gerekmez, yalnızca bu üyeye bir öznitelik eklememeyi seçebilirsiniz <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-480">Of course, you can still choose not to serialize a specific internal member, by simply not adding a <xref:System.Runtime.Serialization.DataMemberAttribute> attribute to that member.</span></span> <span data-ttu-id="f6ecb-481">Benzer şekilde, bir geliştirici, hafif görünürlük sorunları ile özel veya korumalı bir üye oluşturmak da tercih edebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-481">Similarly, a developer can also choose to make a member internal rather than private or protected, with slight visibility concerns.</span></span>

    <span data-ttu-id="f6ecb-482">İkinci dezavantajı, hala özel veya korumalı üyeleri desteklemezler.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-482">The second disadvantage is that it still does not support private or protected members.</span></span>

    <span data-ttu-id="f6ecb-483">Kısmi güvende özniteliğin kullanımını göstermek için <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> aşağıdaki programı göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-483">To illustrate the use of the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute in partial trust, consider the following program:</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#1](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#1)]

    <span data-ttu-id="f6ecb-484">Yukarıdaki örnekte, `PermissionsHelper.InternetZone` <xref:System.Security.PermissionSet> kısmi güven için öğesine karşılık gelir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-484">In the example above, `PermissionsHelper.InternetZone` corresponds to the <xref:System.Security.PermissionSet> for partial trust.</span></span> <span data-ttu-id="f6ecb-485">Artık, özniteliği olmadan <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> uygulama başarısız olur, <xref:System.Security.SecurityException> genel olmayan üyelerin kısmi güvende serileştirilmediğini belirten bir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-485">Now, without the <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> attribute, the application will fail, throwing a <xref:System.Security.SecurityException> indicating that non-public members cannot be serialized in partial trust.</span></span>

    <span data-ttu-id="f6ecb-486">Ancak, kaynak dosyaya aşağıdaki satırı eklediğimiz takdirde program başarıyla çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-486">However, if we add the following line to the source file, the program runs successfully.</span></span>

    [!code-csharp[CDF_WCF_SecurityConsiderationsForData#2](../../../../samples/snippets/csharp/VS_Snippets_CFX/cdf_wcf_securityconsiderationsfordata/cs/program.cs#2)]

## <a name="other-state-management-concerns"></a><span data-ttu-id="f6ecb-487">Diğer durum yönetimi konuları</span><span class="sxs-lookup"><span data-stu-id="f6ecb-487">Other State Management Concerns</span></span>

<span data-ttu-id="f6ecb-488">Nesne durumu yönetimiyle ilgili diğer konular aşağıda yer alınır:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-488">A few other concerns regarding object state management are worth mentioning:</span></span>

- <span data-ttu-id="f6ecb-489">Akış temelli programlama modelini bir akış taşımasıyla kullanırken ileti geldiğinde ileti işleme oluşur.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-489">When using the stream-based programming model with a streaming transport, processing of the message occurs as the message arrives.</span></span> <span data-ttu-id="f6ecb-490">İletiyi gönderen, akışın ortasında Gönder işlemini iptal edebilir ve daha fazla içerik bekleniyorsa kodunuzu öngörülemeyen bir durumda bırakır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-490">The sender of the message may abort the send operation in the middle of the stream, leaving your code in an unpredictable state if more content was expected.</span></span> <span data-ttu-id="f6ecb-491">Genel olarak, akışın tamamlanmamakta olmaması ve akışın durdurulduğu durumlarda geri alınamaz bir akış tabanlı işlemde herhangi bir iş gerçekleştirmeyin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-491">In general, do not rely on the stream being complete, and do not perform any work in a stream-based operation that cannot be rolled back in case the stream is aborted.</span></span> <span data-ttu-id="f6ecb-492">Bu durum, akış gövdesinden sonra bir iletinin hatalı biçimlendirilmiş olabileceği durumlar için de geçerlidir (örneğin, SOAP Zarfı için bir bitiş etiketi eksik olabilir veya ikinci bir ileti gövdesi olabilir).</span><span class="sxs-lookup"><span data-stu-id="f6ecb-492">This also applies to the situation where a message may be malformed after the streaming body (for example, it may be missing an end tag for the SOAP envelope or may have a second message body).</span></span>

- <span data-ttu-id="f6ecb-493">Özelliği kullanmak `IExtensibleDataObject` gizli verilerin oluşturulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-493">Using the `IExtensibleDataObject` feature may cause sensitive data to be emitted.</span></span> <span data-ttu-id="f6ecb-494">Güvenilmeyen bir kaynaktan veri sözleşmeleri içeren verileri kabul ediyorsanız `IExtensibleObjectData` ve daha sonra iletilerin imzalandığı bir güvenli kanalda yeniden yaydıysanız, hiçbir şeyi bildiğiniz veriler için büyük olasılıkla vouching olursunuz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-494">If you are accepting data from an untrusted source into data contracts with `IExtensibleObjectData` and later re-emitting it on a secure channel where messages are signed, you are potentially vouching for data you know nothing about.</span></span> <span data-ttu-id="f6ecb-495">Ayrıca, gönderdiğiniz genel durum hem bilinen hem de bilinmeyen veri parçalarını hesaba aldıysanız geçersiz olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-495">Moreover, the overall state you are sending may be invalid if you take both the known and unknown pieces of data into account.</span></span> <span data-ttu-id="f6ecb-496">Uzantı verisi özelliğini seçerek `null` veya özelliği seçmeli olarak devre dışı bırakarak bu durumdan kaçının `IExtensibleObjectData` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-496">Avoid this situation by either selectively setting the extension data property to `null` or by selectively disabling the `IExtensibleObjectData` feature.</span></span>

## <a name="schema-import"></a><span data-ttu-id="f6ecb-497">Şemayı Içeri aktarma</span><span class="sxs-lookup"><span data-stu-id="f6ecb-497">Schema Import</span></span>

<span data-ttu-id="f6ecb-498">Normalde, türleri oluşturmak için şemayı içeri aktarma işlemi yalnızca tasarım zamanında gerçekleşir, örneğin, bir istemci sınıfı oluşturmak için bir Web hizmetindeki [ServiceModel meta veri yardımcı programı Aracı (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) kullanılırken.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-498">Normally, the process of importing schema to generate types happens only at design time, for example, when using the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../servicemodel-metadata-utility-tool-svcutil-exe.md) on a Web service to generate a client class.</span></span> <span data-ttu-id="f6ecb-499">Ancak, daha Gelişmiş senaryolarda, çalışma zamanında şemayı işleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-499">However, in more advanced scenarios, you may process schema at runtime.</span></span> <span data-ttu-id="f6ecb-500">Bunu yapmanın, hizmet reddi risklerine maruz bırakacağına dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-500">Be aware that doing so can expose you to denial-of-service risks.</span></span> <span data-ttu-id="f6ecb-501">Bazı şemanın içeri aktarılması uzun zaman alabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-501">Some schema may take a long time to be imported.</span></span> <span data-ttu-id="f6ecb-502"><xref:System.Xml.Serialization.XmlSerializer>Şemalar muhtemelen güvenilmeyen bir kaynaktan geliyorsa, bu senaryolarda hiçbir şekilde şema içeri aktarma bileşenini kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-502">Never use the <xref:System.Xml.Serialization.XmlSerializer> schema import component in such scenarios if schemas are possibly coming from an untrusted source.</span></span>

## <a name="threats-specific-to-aspnet-ajax-integration"></a><span data-ttu-id="f6ecb-503">ASP.NET AJAX tümleştirmesine özgü tehditler</span><span class="sxs-lookup"><span data-stu-id="f6ecb-503">Threats Specific to ASP.NET AJAX Integration</span></span>

<span data-ttu-id="f6ecb-504">Kullanıcı veya uyguladığı zaman <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> <xref:System.ServiceModel.Description.WebHttpBehavior> , WCF hem XML hem de JSON iletilerini kabul edebilecek bir uç nokta gösterir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-504">When the user implements <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> or <xref:System.ServiceModel.Description.WebHttpBehavior>, WCF exposes an endpoint that can accept both XML and JSON messages.</span></span> <span data-ttu-id="f6ecb-505">Ancak, hem XML okuyucu hem de JSON okuyucusu tarafından kullanılan tek bir okuyucu kotaları kümesi vardır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-505">However, there is only one set of reader quotas, used both by the XML reader and the JSON reader.</span></span> <span data-ttu-id="f6ecb-506">Bazı Kota ayarları bir okuyucu için uygun olabilir ancak diğeri için çok büyük olabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-506">Some quota settings may be appropriate for one reader but too large for the other.</span></span>

<span data-ttu-id="f6ecb-507">Uygularken `WebScriptEnablingBehavior` , kullanıcının uç noktada bir JavaScript proxy 'si sunma seçeneği vardır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-507">When implementing `WebScriptEnablingBehavior`, the user has the option to expose a JavaScript proxy at the endpoint.</span></span> <span data-ttu-id="f6ecb-508">Aşağıdaki güvenlik sorunları göz önünde bulundurulmalıdır:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-508">The following security issues must be considered:</span></span>

- <span data-ttu-id="f6ecb-509">Hizmet hakkındaki bilgiler (işlem adları, parametre adları vb.), JavaScript proxy 'si incelenerek elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-509">Information about the service (operation names, parameter names, and so on) can be obtained by examining the JavaScript proxy.</span></span>

- <span data-ttu-id="f6ecb-510">JavaScript uç noktası kullanılırken, hassas ve özel bilgiler istemci Web tarayıcısı önbelleğinde tutulabilir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-510">When using the JavaScript endpoint, sensitive and private information might be retained in the client Web browser cache.</span></span>

## <a name="a-note-on-components"></a><span data-ttu-id="f6ecb-511">Bileşenlere bir göz</span><span class="sxs-lookup"><span data-stu-id="f6ecb-511">A Note on Components</span></span>

<span data-ttu-id="f6ecb-512">WCF esnek ve özelleştirilebilir bir sistemdir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-512">WCF is a flexible and customizable system.</span></span> <span data-ttu-id="f6ecb-513">Bu konunun içeriklerinin çoğu, en yaygın WCF kullanımı senaryolarına odaklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-513">Most of the contents of this topic focus on the most common WCF usage scenarios.</span></span> <span data-ttu-id="f6ecb-514">Ancak, WCF bileşenleri oluşturmak için birçok farklı yol vardır.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-514">However, it is possible to compose components WCF provides in many different ways.</span></span> <span data-ttu-id="f6ecb-515">Her bileşeni kullanmanın güvenlik etkilerine ilişkin etkileri anlamak önemlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-515">It is important to understand the security implications of using each component.</span></span> <span data-ttu-id="f6ecb-516">Özellikle:</span><span class="sxs-lookup"><span data-stu-id="f6ecb-516">In particular:</span></span>

- <span data-ttu-id="f6ecb-517">XML okuyucuları kullanmanız gerektiğinde, <xref:System.Xml.XmlDictionaryReader> sınıfının diğer okuyucuların aksine sağladığı okuyucuları kullanın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-517">When you must use XML readers, use the readers the <xref:System.Xml.XmlDictionaryReader> class provides as opposed to any other readers.</span></span> <span data-ttu-id="f6ecb-518">Güvenli okuyucular <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A> ,, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A> veya yöntemleri kullanılarak oluşturulur <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-518">Safe readers are created using <xref:System.Xml.XmlDictionaryReader.CreateTextReader%2A>, <xref:System.Xml.XmlDictionaryReader.CreateBinaryReader%2A>, or <xref:System.Xml.XmlDictionaryReader.CreateMtomReader%2A> methods.</span></span> <span data-ttu-id="f6ecb-519"><xref:System.Xml.XmlReader.Create%2A>Yöntemini kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-519">Do not use the <xref:System.Xml.XmlReader.Create%2A> method.</span></span> <span data-ttu-id="f6ecb-520">Okuyucuları her zaman güvenli kotalar ile yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-520">Always configure the readers with safe quotas.</span></span> <span data-ttu-id="f6ecb-521">WCF 'deki serileştirme motorları yalnızca WCF 'den güvenli XML okuyucuları ile birlikte kullanıldığında güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-521">The serialization engines in WCF are secure only when used with secure XML readers from WCF.</span></span>

- <span data-ttu-id="f6ecb-522">, <xref:System.Runtime.Serialization.DataContractSerializer> Güvenilir olmayan verileri seri durumdan çıkarmak için kullanırken, her zaman <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> özelliği ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-522">When using the <xref:System.Runtime.Serialization.DataContractSerializer> to deserialize potentially untrusted data, always set the <xref:System.Runtime.Serialization.DataContractSerializer.MaxItemsInObjectGraph%2A> property.</span></span>

- <span data-ttu-id="f6ecb-523">Bir ileti oluştururken, `maxSizeOfHeaders` `MaxReceivedMessageSize` yeterli koruma sunmıyorsa parametresini ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-523">When creating a message, set the `maxSizeOfHeaders` parameter if `MaxReceivedMessageSize` does not offer enough protection.</span></span>

- <span data-ttu-id="f6ecb-524">Kodlayıcı oluştururken, ve gibi ilgili kotaları her zaman yapılandırın `MaxSessionSize` `MaxBufferSize` .</span><span class="sxs-lookup"><span data-stu-id="f6ecb-524">When creating an encoder, always configure the relevant quotas, such as `MaxSessionSize` and `MaxBufferSize`.</span></span>

- <span data-ttu-id="f6ecb-525">Bir XPath ileti filtresi kullanırken, <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> filtrenin ziyaret ettığı XML düğümü miktarını sınırlamak için öğesini ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-525">When using an XPath message filter, set the <xref:System.ServiceModel.Dispatcher.XPathMessageFilter.NodeQuota%2A> to limit the amount of XML nodes the filter visits.</span></span> <span data-ttu-id="f6ecb-526">Çok sayıda düğüm ziyaret etmeden hesaplanması uzun süren XPath ifadeleri kullanmayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-526">Do not use XPath expressions that could take a long time to compute without visiting many nodes.</span></span>

- <span data-ttu-id="f6ecb-527">Genel olarak, kota kabul eden herhangi bir bileşeni kullanırken, güvenlik etkilerini anlayın ve güvenli bir değere ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-527">In general, when using any component that accepts a quota, understand its security implications and set it to a safe value.</span></span>

## <a name="see-also"></a><span data-ttu-id="f6ecb-528">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="f6ecb-528">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Xml.XmlDictionaryReader>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="f6ecb-529">Veri Sözleşmesi Bilinen Türler</span><span class="sxs-lookup"><span data-stu-id="f6ecb-529">Data Contract Known Types</span></span>](data-contract-known-types.md)
