---
description: 'Hakkında daha fazla bilgi edinin: DataContractJsonSerializer kullanarak JSON serileştirme Stand-Alone'
title: DataContractJsonSerializer kullanarak JSON serileştirmesini Stand-Alone
ms.date: 03/30/2017
ms.assetid: 312bd7b2-1300-4b12-801e-ebe742bd2287
ms.openlocfilehash: c88a996eeac7e9e62caa7797bc0bf7cd68dfd67b
ms.sourcegitcommit: ddf7edb67715a5b9a45e3dd44536dabc153c1de0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/06/2021
ms.locfileid: "99793421"
---
# <a name="stand-alone-json-serialization-using-datacontractjsonserializer"></a><span data-ttu-id="35eed-103">DataContractJsonSerializer kullanarak JSON serileştirmesini Stand-Alone</span><span class="sxs-lookup"><span data-stu-id="35eed-103">Stand-Alone JSON Serialization using DataContractJsonSerializer</span></span>

> [!NOTE]
> <span data-ttu-id="35eed-104">Bu makalede hakkında bilgi sağlanır <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .</span><span class="sxs-lookup"><span data-stu-id="35eed-104">This article is about <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="35eed-105">JSON serileştirilmesinin ve serisini kaldırma ile ilgili çoğu senaryo için [ ad alanındakiSystem.Text.Js](../../../standard/serialization/system-text-json-overview.md)API 'leri öneririz.</span><span class="sxs-lookup"><span data-stu-id="35eed-105">For most scenarios that involve serializing and deserializing JSON, we recommend the APIs in the [System.Text.Json namespace](../../../standard/serialization/system-text-json-overview.md).</span></span>

<span data-ttu-id="35eed-106">JSON (JavaScript Nesne Gösterimi), tarayıcı içindeki Web sayfalarında çalışan JavaScript kodu tarafından kullanılmak üzere özel olarak tasarlanan bir veri biçimidir.</span><span class="sxs-lookup"><span data-stu-id="35eed-106">JSON (JavaScript Object Notation) is a data format that is specifically designed to be used by JavaScript code running on Web pages inside the browser.</span></span> <span data-ttu-id="35eed-107">Bu, Windows Communication Foundation (WCF) içinde oluşturulan ASP.NET AJAX Hizmetleri tarafından kullanılan varsayılan veri biçimidir.</span><span class="sxs-lookup"><span data-stu-id="35eed-107">It is the default data format used by ASP.NET AJAX services created in Windows Communication Foundation (WCF).</span></span>

<span data-ttu-id="35eed-108">Bu biçim, ASP.NET ile tümleştirmeden AJAX Hizmetleri oluştururken de kullanılabilir-Bu örnekte, XML varsayılandır ancak JSON seçilebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-108">This format can also be used when creating AJAX services without integrating with ASP.NET - in this case, XML is the default but JSON can be chosen.</span></span>

<span data-ttu-id="35eed-109">Son olarak, JSON desteğine ihtiyacınız vardır ancak bir AJAX Hizmeti oluşturmadıysanız, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .net nesnelerinin doğrudan JSON verilerine serileştirmesini ve bu gibi verilerin serisini .net türlerinin örneklerine geri oluşturmasını mümkün hale getirir.</span><span class="sxs-lookup"><span data-stu-id="35eed-109">Finally, if you require JSON support but are not creating an AJAX service, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> makes it possible to directly serialize .NET objects into JSON data and to deserialize such data back into instances of .NET types.</span></span> <span data-ttu-id="35eed-110">Bunun nasıl yapılacağı hakkında bir açıklama için bkz. [nasıl yapılır: serileştirme ve seri durumdan ÇıKARMA JSON verileri](how-to-serialize-and-deserialize-json-data.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-110">For a description of how to do this, see [How to: Serialize and Deserialize JSON Data](how-to-serialize-and-deserialize-json-data.md).</span></span>

<span data-ttu-id="35eed-111">JSON ile çalışırken, tarafından desteklendiği gibi birkaç özel durum ile aynı .NET türleri desteklenir <xref:System.Runtime.Serialization.DataContractSerializer> .</span><span class="sxs-lookup"><span data-stu-id="35eed-111">When working with JSON, the same .NET types are supported, with a few exceptions, as are supported by the <xref:System.Runtime.Serialization.DataContractSerializer>.</span></span> <span data-ttu-id="35eed-112">Desteklenen türlerin listesi için bkz. [veri sözleşmesi serileştiricisi tarafından desteklenen türler](types-supported-by-the-data-contract-serializer.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-112">For a list of the types supported, see [Types Supported by the Data Contract Serializer](types-supported-by-the-data-contract-serializer.md).</span></span> <span data-ttu-id="35eed-113">Buna en basit türler, çoğu dizi ve koleksiyon türü ve ve kullanan karmaşık türler dahildir <xref:System.Runtime.Serialization.DataContractAttribute> <xref:System.Runtime.Serialization.DataMemberAttribute> .</span><span class="sxs-lookup"><span data-stu-id="35eed-113">This includes most primitive types, most array and collection types, as well as complex types that use the <xref:System.Runtime.Serialization.DataContractAttribute> and <xref:System.Runtime.Serialization.DataMemberAttribute>.</span></span>

## <a name="mapping-net-types-to-json-types"></a><span data-ttu-id="35eed-114">.NET türlerini JSON türleriyle eşleme</span><span class="sxs-lookup"><span data-stu-id="35eed-114">Mapping .NET types to JSON Types</span></span>

<span data-ttu-id="35eed-115">Aşağıdaki tabloda, serileştirme ve serisini kaldırma yordamları ile eşlendiğinde .NET türleri ve JSON/JavaScript türleri arasındaki yazışmalar gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="35eed-115">The following table shows the correspondence between .NET types and JSON/JavaScript types when mapped by serialization and deserialization procedures.</span></span>

|<span data-ttu-id="35eed-116">.NET türleri</span><span class="sxs-lookup"><span data-stu-id="35eed-116">.NET Types</span></span>|<span data-ttu-id="35eed-117">JSON/JavaScript</span><span class="sxs-lookup"><span data-stu-id="35eed-117">JSON/JavaScript</span></span>|<span data-ttu-id="35eed-118">Notlar</span><span class="sxs-lookup"><span data-stu-id="35eed-118">Notes</span></span>|
|----------------|----------------------|-----------|
|<span data-ttu-id="35eed-119">Tüm sayısal türler, örneğin <xref:System.Int32> <xref:System.Decimal> veya <xref:System.Double></span><span class="sxs-lookup"><span data-stu-id="35eed-119">All numeric types, for example <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double></span></span>|<span data-ttu-id="35eed-120">Sayı</span><span class="sxs-lookup"><span data-stu-id="35eed-120">Number</span></span>|<span data-ttu-id="35eed-121">Ve gibi özel değerler  `Double.NaN` `Double.PositiveInfinity` `Double.NegativeInfinity` desteklenmez ve geçersiz JSON ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="35eed-121">Special values such as  `Double.NaN`, `Double.PositiveInfinity` and `Double.NegativeInfinity` are not supported and result in invalid JSON.</span></span>|
|<xref:System.Enum>|<span data-ttu-id="35eed-122">Sayı</span><span class="sxs-lookup"><span data-stu-id="35eed-122">Number</span></span>|<span data-ttu-id="35eed-123">Bu konunun devamındaki "numaralandırmalar ve JSON" başlığına bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-123">See "Enumerations and JSON" later in this topic.</span></span>|
|<xref:System.Boolean>|<span data-ttu-id="35eed-124">Boole</span><span class="sxs-lookup"><span data-stu-id="35eed-124">Boolean</span></span>|--|
|<span data-ttu-id="35eed-125"><xref:System.String>, <xref:System.Char></span><span class="sxs-lookup"><span data-stu-id="35eed-125"><xref:System.String>, <xref:System.Char></span></span>|<span data-ttu-id="35eed-126">Dize</span><span class="sxs-lookup"><span data-stu-id="35eed-126">String</span></span>|--|
|<span data-ttu-id="35eed-127"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span><span class="sxs-lookup"><span data-stu-id="35eed-127"><xref:System.TimeSpan>, <xref:System.Guid>, <xref:System.Uri></span></span>|<span data-ttu-id="35eed-128">Dize</span><span class="sxs-lookup"><span data-stu-id="35eed-128">String</span></span>|<span data-ttu-id="35eed-129">JSON 'daki bu türlerin biçimi, XML (temel olarak, ISO 8601 süre biçimindeki zaman aralığı, "12345678-ABCD-ABCD-ABCD-1234567890AB" biçiminde ve URI DEĞERI "" gibi doğal dize biçiminde http://www.example.com ).</span><span class="sxs-lookup"><span data-stu-id="35eed-129">The format of these types in JSON is the same as in XML (essentially, TimeSpan in the ISO 8601 Duration format, GUID in the "12345678-ABCD-ABCD-ABCD-1234567890AB" format and URI in its natural string form like "http://www.example.com").</span></span> <span data-ttu-id="35eed-130">Kesin bilgiler için bkz. [veri sözleşmesi şema başvurusu](data-contract-schema-reference.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-130">For precise information, see [Data Contract Schema Reference](data-contract-schema-reference.md).</span></span>|
|<xref:System.Xml.XmlQualifiedName>|<span data-ttu-id="35eed-131">Dize</span><span class="sxs-lookup"><span data-stu-id="35eed-131">String</span></span>|<span data-ttu-id="35eed-132">Biçim "ad: Namespace" (ilk iki nokta üst üsteden önce herhangi bir şey ad).</span><span class="sxs-lookup"><span data-stu-id="35eed-132">The format is "name:namespace" (anything before the first colon is the name).</span></span> <span data-ttu-id="35eed-133">Ad veya ad alanı eksik olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-133">Either the name or the namespace can be missing.</span></span> <span data-ttu-id="35eed-134">Ad alanı yoksa, iki nokta üst üste işareti de atlanabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-134">If there is no namespace the colon can be omitted as well.</span></span>|
|<span data-ttu-id="35eed-135"><xref:System.Array> türünde <xref:System.Byte></span><span class="sxs-lookup"><span data-stu-id="35eed-135"><xref:System.Array> of type <xref:System.Byte></span></span>|<span data-ttu-id="35eed-136">Sayı dizisi</span><span class="sxs-lookup"><span data-stu-id="35eed-136">Array of numbers</span></span>|<span data-ttu-id="35eed-137">Her sayı bir baytlık değeri temsil eder.</span><span class="sxs-lookup"><span data-stu-id="35eed-137">Each number represents the value of one byte.</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="35eed-138">DateTime veya String</span><span class="sxs-lookup"><span data-stu-id="35eed-138">DateTime or String</span></span>|<span data-ttu-id="35eed-139">Bu konunun ilerleyen kısımlarında tarihlere/saatlere ve JSON öğesine bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-139">See Dates/Times and JSON later in this topic.</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="35eed-140">Karmaşık tür</span><span class="sxs-lookup"><span data-stu-id="35eed-140">Complex type</span></span>|<span data-ttu-id="35eed-141">Bu konunun ilerleyen kısımlarında tarihlere/saatlere ve JSON öğesine bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-141">See Dates/Times and JSON later in this topic.</span></span>|
|<span data-ttu-id="35eed-142">XML ve ADO.NET türleri ( <xref:System.Xml.XmlElement> ,</span><span class="sxs-lookup"><span data-stu-id="35eed-142">XML and ADO.NET types (<xref:System.Xml.XmlElement>,</span></span><br /><br /> <span data-ttu-id="35eed-143"><xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="35eed-143"><xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="35eed-144">Dizileri <xref:System.Xml.XmlNode> ,</span><span class="sxs-lookup"><span data-stu-id="35eed-144">Arrays of <xref:System.Xml.XmlNode>,</span></span><br /><br /> <span data-ttu-id="35eed-145"><xref:System.Runtime.Serialization.ISerializable>,</span><span class="sxs-lookup"><span data-stu-id="35eed-145"><xref:System.Runtime.Serialization.ISerializable>,</span></span><br /><br /> <span data-ttu-id="35eed-146"><xref:System.Data.DataSet>).</span><span class="sxs-lookup"><span data-stu-id="35eed-146"><xref:System.Data.DataSet>).</span></span>|<span data-ttu-id="35eed-147">Dize</span><span class="sxs-lookup"><span data-stu-id="35eed-147">String</span></span>|<span data-ttu-id="35eed-148">Bu konunun XML türleri ve JSON bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-148">See the XML Types and JSON section of this topic.</span></span>|
|<xref:System.DBNull>|<span data-ttu-id="35eed-149">Boş karmaşık tür</span><span class="sxs-lookup"><span data-stu-id="35eed-149">Empty complex type</span></span>|--|
|<span data-ttu-id="35eed-150">Koleksiyonlar, sözlükler ve diziler</span><span class="sxs-lookup"><span data-stu-id="35eed-150">Collections, dictionaries, and arrays</span></span>|<span data-ttu-id="35eed-151">Dizi</span><span class="sxs-lookup"><span data-stu-id="35eed-151">Array</span></span>|<span data-ttu-id="35eed-152">Bu konunun koleksiyonlar, sözlükler ve diziler bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-152">See the Collections, Dictionaries, and Arrays section of this topic.</span></span>|
|<span data-ttu-id="35eed-153">Karmaşık türler ( <xref:System.Runtime.Serialization.DataContractAttribute> veya <xref:System.SerializableAttribute> uygulanmış)</span><span class="sxs-lookup"><span data-stu-id="35eed-153">Complex types (with the <xref:System.Runtime.Serialization.DataContractAttribute> or <xref:System.SerializableAttribute> applied)</span></span>|<span data-ttu-id="35eed-154">Karmaşık tür</span><span class="sxs-lookup"><span data-stu-id="35eed-154">Complex type</span></span>|<span data-ttu-id="35eed-155">Veri üyeleri JavaScript karmaşık türünün üyesi olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-155">Data members become members of the JavaScript complex type.</span></span>|
|<span data-ttu-id="35eed-156">Arabirimi uygulayan karmaşık türler <xref:System.Runtime.Serialization.ISerializable> )</span><span class="sxs-lookup"><span data-stu-id="35eed-156">Complex types implementing the <xref:System.Runtime.Serialization.ISerializable> interface)</span></span>|<span data-ttu-id="35eed-157">Karmaşık tür</span><span class="sxs-lookup"><span data-stu-id="35eed-157">Complex type</span></span>|<span data-ttu-id="35eed-158">Diğer karmaşık türlerle aynı ancak bazı <xref:System.Runtime.Serialization.ISerializable> türler desteklenmez – bu konunun gelişmiş bilgiler bölümünün ISerializable destek bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-158">Same as other complex types but some <xref:System.Runtime.Serialization.ISerializable> types are not supported – see the ISerializable Support part of the Advanced Information section of this topic.</span></span>|
|<span data-ttu-id="35eed-159">`Null` herhangi bir türün değeri</span><span class="sxs-lookup"><span data-stu-id="35eed-159">`Null` value for any type</span></span>|<span data-ttu-id="35eed-160">Null</span><span class="sxs-lookup"><span data-stu-id="35eed-160">Null</span></span>|<span data-ttu-id="35eed-161">Null yapılabilir değer türleri de desteklenir ve JSON ile aynı şekilde null atanamaz değer türleriyle eşlenir.</span><span class="sxs-lookup"><span data-stu-id="35eed-161">Nullable value types are also supported and map to JSON in the same way as non-nullable value types.</span></span>|

### <a name="enumerations-and-json"></a><span data-ttu-id="35eed-162">Numaralandırmalar ve JSON</span><span class="sxs-lookup"><span data-stu-id="35eed-162">Enumerations and JSON</span></span>

<span data-ttu-id="35eed-163">Sabit listesi üyesi değerleri, JSON 'da sayı olarak değerlendirilir ve bu, üye adları olarak dahil oldukları veri sözleşmeleri içinde nasıl ele alındıklarından farklıdır.</span><span class="sxs-lookup"><span data-stu-id="35eed-163">Enumeration member values are treated as numbers in JSON, which is different from how they are treated in data contracts, where they are included as member names.</span></span> <span data-ttu-id="35eed-164">Veri anlaşması işlemi hakkında daha fazla bilgi için bkz. [veri sözleşmeleri Içindeki numaralandırma türleri](enumeration-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-164">For more information about the data contract treatment, see [Enumeration Types in Data Contracts](enumeration-types-in-data-contracts.md).</span></span>

- <span data-ttu-id="35eed-165">Örneğin, varsa `public enum Color {red, green, blue, yellow, pink}` serileştirmek, `yellow` "sarı" dizesini değil 3 sayısını üretir.</span><span class="sxs-lookup"><span data-stu-id="35eed-165">For example, if you have `public enum Color {red, green, blue, yellow, pink}`, serializing `yellow` produces the number 3 and not the string "yellow".</span></span>

- <span data-ttu-id="35eed-166">Tüm `enum` Üyeler seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-166">All `enum` members are serializable.</span></span> <span data-ttu-id="35eed-167"><xref:System.Runtime.Serialization.EnumMemberAttribute>Kullanılıyorsa, ve <xref:System.NonSerializedAttribute> öznitelikleri yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-167">The <xref:System.Runtime.Serialization.EnumMemberAttribute> and the <xref:System.NonSerializedAttribute> attributes are ignored if used.</span></span>

- <span data-ttu-id="35eed-168">Varolmayan bir değerin serisini kaldırmak mümkündür; `enum` Örneğin, tanımlanmış bir renk adı olmasa bile 87 değeri önceki renk numaralandırmasında seri durumdan çıkarılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-168">It is possible to deserialize a nonexistent `enum` value - for example, the value 87 can be deserialized into the previous Color enum even though there is no corresponding color name defined.</span></span>

- <span data-ttu-id="35eed-169">Bayrak `enum` özel değildir ve birbirleriyle aynı şekilde davranır `enum` .</span><span class="sxs-lookup"><span data-stu-id="35eed-169">A flags `enum` is not special and is treated the same as any other `enum`.</span></span>

### <a name="datestimes-and-json"></a><span data-ttu-id="35eed-170">Tarihler/saatler ve JSON</span><span class="sxs-lookup"><span data-stu-id="35eed-170">Dates/Times and JSON</span></span>

<span data-ttu-id="35eed-171">JSON biçimi, tarihleri ve saatleri doğrudan desteklemez.</span><span class="sxs-lookup"><span data-stu-id="35eed-171">The JSON format does not directly support dates and times.</span></span> <span data-ttu-id="35eed-172">Ancak, bunlar çok yaygın olarak kullanılır ve ASP.NET AJAX bu türler için özel destek sağlar.</span><span class="sxs-lookup"><span data-stu-id="35eed-172">However, they are very commonly used and ASP.NET AJAX provides special support for these types.</span></span> <span data-ttu-id="35eed-173">ASP.NET AJAX proxy 'leri kullanılırken, <xref:System.DateTime> .net 'teki tür JavaScript 'teki türü ile tam olarak karşılık gelir `DateTime` .</span><span class="sxs-lookup"><span data-stu-id="35eed-173">When using ASP.NET AJAX proxies, the <xref:System.DateTime> type in .NET fully corresponds to the `DateTime` type in JavaScript.</span></span>

- <span data-ttu-id="35eed-174">ASP.NET kullanmadığınız durumlarda, bir <xref:System.DateTime> tür JSON içinde bu konunun gelişmiş bilgiler bölümünde açıklanan özel bir biçimde bir dize olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-174">When not using ASP.NET, a <xref:System.DateTime> type is represented in JSON as a string with a special format that is described in the Advanced Information section of this topic.</span></span>

- <span data-ttu-id="35eed-175"><xref:System.DateTimeOffset> , JSON 'da karmaşık bir tür olarak temsil edilir: {"DateTime":d Meditime, "OffsetMinutes": offsetMinutes}.</span><span class="sxs-lookup"><span data-stu-id="35eed-175"><xref:System.DateTimeOffset> is represented in JSON as a complex type: {"DateTime":dateTime,"OffsetMinutes":offsetMinutes}.</span></span> <span data-ttu-id="35eed-176">`offsetMinutes`Üye, Greenwich saati 'nin (GMT) yerel saat farkıdır, Ayrıca artık ilgili etkinliğin konumuyla ilişkili olarak Eşgüdümlü Evrensel Saat (UTC) olarak da anılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-176">The `offsetMinutes` member is the local time offset from Greenwich Mean Time (GMT), also now referred to as Coordinated Universal Time (UTC), associated with the location of the event of interest.</span></span> <span data-ttu-id="35eed-177">`dateTime`Üye, ilgilendiğiniz olayın gerçekleştiği zaman örneğini temsil eder (yine de, `DateTime` ASP.NET AJAX kullanımda olduğunda ve olmadığında bir dize olduğunda JavaScript 'te bir olur).</span><span class="sxs-lookup"><span data-stu-id="35eed-177">The `dateTime` member represents the instance in time when the event of interest occurred (again, it becomes a `DateTime` in JavaScript when ASP.NET AJAX is in use and a string when it is not).</span></span> <span data-ttu-id="35eed-178">Serileştirme sırasında, `dateTime` üye her zaman GMT 'de serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-178">On serialization, the `dateTime` member is always serialized in GMT.</span></span> <span data-ttu-id="35eed-179">Bu nedenle, 3:00 New York saati açıklanmışsa, `dateTime` 8:00 ' nin saat bileşeni vardır ve `offsetMinutes` 300 (300 eksi saat veya 5 saat GMT).</span><span class="sxs-lookup"><span data-stu-id="35eed-179">So, if describing 3:00 AM New York time, `dateTime` has a time component of 8:00 AM and `offsetMinutes` are 300 (minus 300 minutes or 5 hours from GMT).</span></span>

  > [!NOTE]
  > <span data-ttu-id="35eed-180"><xref:System.DateTime> ve <xref:System.DateTimeOffset> nesneler JSON ile serileştirildiğinde yalnızca milisaniyelik duyarlığa karşı bilgileri korur.</span><span class="sxs-lookup"><span data-stu-id="35eed-180"><xref:System.DateTime> and <xref:System.DateTimeOffset> objects, when serialized to JSON, only preserve information to millisecond precision.</span></span> <span data-ttu-id="35eed-181">Serileştirme sırasında alt milisaniyelik değerleri (mikro/nanosaniye) kaybolur.</span><span class="sxs-lookup"><span data-stu-id="35eed-181">Sub-millisecond values (micro/nanoseconds) are lost during serialization.</span></span>

### <a name="xml-types-and-json"></a><span data-ttu-id="35eed-182">XML türleri ve JSON</span><span class="sxs-lookup"><span data-stu-id="35eed-182">XML Types and JSON</span></span>

<span data-ttu-id="35eed-183">XML türleri JSON dizeleri olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-183">XML types become JSON strings.</span></span>

- <span data-ttu-id="35eed-184">Örneğin, XElement türünde bir veri üyesi "q" içeriyorsa \<abc/> , JSON {"q": " \<abc/> "} olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-184">For example, if a data member "q" of type XElement contains \<abc/>, the JSON is {"q":"\<abc/>"}.</span></span>

- <span data-ttu-id="35eed-185">XML 'in sarmalanmış olduğunu belirten bazı özel kurallar vardır. daha fazla bilgi için bu konunun ilerleyen kısımlarında yer alan gelişmiş bilgiler bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-185">There are some special rules that specify how XML is wrapped - for more information, see the Advanced Information section later in this topic.</span></span>

- <span data-ttu-id="35eed-186">ASP.NET AJAX kullanıyorsanız ve JavaScript 'te dizeler kullanmak istemiyorsanız, ancak bunun yerine XML DOM ' ı istiyorsanız <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> özelliği üzerinde XML olarak <xref:System.ServiceModel.Web.WebGetAttribute> veya ÖZELLIĞINI üzerinde XML olarak ayarlayın <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> <xref:System.ServiceModel.Web.WebInvokeAttribute> .</span><span class="sxs-lookup"><span data-stu-id="35eed-186">If you are using ASP.NET AJAX and do not want to use strings in the JavaScript, but want the XML DOM instead, set the <xref:System.ServiceModel.Web.WebGetAttribute.ResponseFormat%2A> property to XML on <xref:System.ServiceModel.Web.WebGetAttribute> or the <xref:System.ServiceModel.Web.WebInvokeAttribute.ResponseFormat%2A> property to XML on the <xref:System.ServiceModel.Web.WebInvokeAttribute>.</span></span>

### <a name="collections-dictionaries-and-arrays"></a><span data-ttu-id="35eed-187">Koleksiyonlar, sözlükler ve diziler</span><span class="sxs-lookup"><span data-stu-id="35eed-187">Collections, Dictionaries and Arrays</span></span>

<span data-ttu-id="35eed-188">Tüm koleksiyonlar, sözlükler ve diziler JSON 'da diziler olarak temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-188">All collections, dictionaries, and arrays are represented in JSON as arrays.</span></span>

- <span data-ttu-id="35eed-189">Kullanan tüm özelleştirmeler <xref:System.Runtime.Serialization.CollectionDataContractAttribute> JSON gösteriminde yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-189">Any customization that uses the <xref:System.Runtime.Serialization.CollectionDataContractAttribute> is ignored in the JSON representation.</span></span>

- <span data-ttu-id="35eed-190">Sözlüklerde doğrudan JSON ile çalışmanın bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="35eed-190">Dictionaries are not a way to work directly with JSON.</span></span> <span data-ttu-id="35eed-191">Sözlük \<string,object> , DIĞER JSON teknolojileriyle çalışılmasına benzer şekılde WCF 'de aynı şekilde desteklenmiyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-191">Dictionary\<string,object> may not be supported in the same way in WCF as expected from working with other JSON technologies.</span></span> <span data-ttu-id="35eed-192">Örneğin, "abc", "XYZ" ile eşlenir ve "def" bir sözlükte 42 ile eşleştirilir, JSON temsili {"abc" değil: "XYZ", "def": 42}, ancak [{"Key": "abc", "Value": "XYZ"}, {"Key": "def", "Value": 42}] Bunun yerine.</span><span class="sxs-lookup"><span data-stu-id="35eed-192">For example, if "abc" is mapped to "xyz" and "def" is mapped to 42 in a dictionary, the JSON representation is not {"abc":"xyz","def":42} but is [{"Key":"abc","Value":"xyz"},{"Key":"def","Value":42}] instead.</span></span>

- <span data-ttu-id="35eed-193">JSON ile doğrudan çalışmak istiyorsanız (bir rigıd sözleşmesini önceden tanımlamaya gerek kalmadan anahtar ve değerlere dinamik olarak erişme), birkaç seçeneğiniz vardır:</span><span class="sxs-lookup"><span data-stu-id="35eed-193">If you would like to work with JSON directly (accessing keys and values dynamically, without pre-defining a rigid contract), you have several options:</span></span>

  - <span data-ttu-id="35eed-194">[Zayıf YAZıLMıŞ JSON serileştirme (AJAX)](../samples/weakly-typed-json-serialization-sample.md) örneğini kullanmayı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="35eed-194">Consider using the [Weakly-typed JSON Serialization (AJAX)](../samples/weakly-typed-json-serialization-sample.md) sample.</span></span>

  - <span data-ttu-id="35eed-195"><xref:System.Runtime.Serialization.ISerializable>Arabirim ve seri kaldırma oluşturucularını kullanmayı düşünün-bu iki mekanizma sırasıyla serileştirme ve seri durumundan çıkarma SıRASıNDA JSON anahtar/değer çiftlerine erişmenize izin verir, ancak kısmi güven senaryolarında çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="35eed-195">Consider using the <xref:System.Runtime.Serialization.ISerializable> interface and deserialization constructors - these two mechanisms allow you to access JSON key/value pairs on serialization and deserialization respectively, but do not work in partial trust scenarios.</span></span>

  - <span data-ttu-id="35eed-196">Serileştirici kullanmak yerine [JSON ve XML arasındaki eşleme](mapping-between-json-and-xml.md) ile çalışmayı düşünün.</span><span class="sxs-lookup"><span data-stu-id="35eed-196">Consider working with the [Mapping Between JSON and XML](mapping-between-json-and-xml.md) instead of using a serializer.</span></span>

  - <span data-ttu-id="35eed-197">Serileştirme bağlamındaki çok *biçimlilik* , temel türünün beklendiği türetilmiş bir türü seri hale getirme özelliğine başvurur.</span><span class="sxs-lookup"><span data-stu-id="35eed-197">*Polymorphism* in the context of serialization refers to the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="35eed-198">Koleksiyonlar polymorphically kullanılırken JSON 'a özgü özel kurallar vardır, örneğin, bir koleksiyon ' a atama <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="35eed-198">There are special JSON-specific rules when using collections polymorphically, when, for example, assigning a collection to an <xref:System.Object>.</span></span> <span data-ttu-id="35eed-199">Bu sorun, bu konunun ilerleyen bölümlerinde gelişmiş bilgiler bölümünde daha ayrıntılı olarak ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="35eed-199">This issue is more fully discussed in the Advanced Information section later in this topic.</span></span>

## <a name="additional-details"></a><span data-ttu-id="35eed-200">Ek ayrıntılar</span><span class="sxs-lookup"><span data-stu-id="35eed-200">Additional Details</span></span>

### <a name="order-of-data-members"></a><span data-ttu-id="35eed-201">Veri üyelerinin sırası</span><span class="sxs-lookup"><span data-stu-id="35eed-201">Order of Data Members</span></span>

<span data-ttu-id="35eed-202">JSON kullanılırken veri üyelerinin sırası önemli değildir.</span><span class="sxs-lookup"><span data-stu-id="35eed-202">Order of data members is not important when using JSON.</span></span> <span data-ttu-id="35eed-203">Özellikle de ayarlanmış olsa bile <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> JSON verileri herhangi bir sırada seri durumdan çıkarılamaz.</span><span class="sxs-lookup"><span data-stu-id="35eed-203">Specifically, even if <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A> is set, JSON data can still be deserialized in any order.</span></span>

### <a name="json-types"></a><span data-ttu-id="35eed-204">JSON türleri</span><span class="sxs-lookup"><span data-stu-id="35eed-204">JSON Types</span></span>

<span data-ttu-id="35eed-205">JSON türünün, seri durumdan çıkarma sırasında önceki tabloyla eşleşmesi gerekmez.</span><span class="sxs-lookup"><span data-stu-id="35eed-205">The JSON type does not have to match the preceding table on deserialization.</span></span> <span data-ttu-id="35eed-206">Örneğin, normalde bir `Int` JSON numarasıyla eşleşir, ancak bu dize geçerli bir sayı içerdiği sürece BIR JSON dizesinden de başarıyla seri durumdan çıkarılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-206">For example, an `Int` normally maps to a JSON number, but it can also be successfully deserialized from a JSON string as long as that string contains a valid number.</span></span> <span data-ttu-id="35eed-207">Diğer bir deyişle, `Int` "q" adlı bir veri üyesi varsa {"q": 42} ve {"q": "42"} geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="35eed-207">That is, both {"q":42} and {"q":"42"} are valid if there is an `Int` data member called "q".</span></span>

### <a name="polymorphism"></a><span data-ttu-id="35eed-208">Çok biçimlilik</span><span class="sxs-lookup"><span data-stu-id="35eed-208">Polymorphism</span></span>

<span data-ttu-id="35eed-209">Çok biçimli seri hale getirme, temel türünün beklenildiği türetilmiş bir türü seri hale getirme özelliğinden oluşur.</span><span class="sxs-lookup"><span data-stu-id="35eed-209">Polymorphic serialization consists of the ability to serialize a derived type where its base type is expected.</span></span> <span data-ttu-id="35eed-210">Bu, XML serileştirme desteklenme yöntemine benzer şekilde WCF tarafından JSON serileştirme için desteklenir.</span><span class="sxs-lookup"><span data-stu-id="35eed-210">This is supported for JSON serialization by WCF comparable to the way XML serialization is supported.</span></span> <span data-ttu-id="35eed-211">Örneğin, `MyDerivedType` nerede `MyBaseType` beklenildiği veya seri hale getirme beklenen yerde seri hale getirebilirsiniz `Int` `Object` .</span><span class="sxs-lookup"><span data-stu-id="35eed-211">For example, you can serialize `MyDerivedType` where `MyBaseType` is expected, or serialize `Int` where `Object` is expected.</span></span>

<span data-ttu-id="35eed-212">Karmaşık bir türü seri durumdan çıkarmadığınız takdirde, temel tür bekleniyorsa, tür bilgileri kaybolmuş olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-212">Type information may be lost when deserializing a derived type if the base type is expected, unless you are deserializing a complex type.</span></span> <span data-ttu-id="35eed-213">Örneğin, <xref:System.Uri> seri hale getiriliyorsa, <xref:System.Object> bir JSON dizesine neden olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-213">For example, if <xref:System.Uri> is serialized where <xref:System.Object> is expected, it results in a JSON string.</span></span> <span data-ttu-id="35eed-214">Bu dize daha sonra yeniden seri hale getirilir <xref:System.Object> , .net <xref:System.String> döndürülür.</span><span class="sxs-lookup"><span data-stu-id="35eed-214">If this string is then deserialized back into <xref:System.Object>, a .NET <xref:System.String> is returned.</span></span> <span data-ttu-id="35eed-215">Seri hale getirici, dizenin başlangıçta tür olduğunu bilmez <xref:System.Uri> .</span><span class="sxs-lookup"><span data-stu-id="35eed-215">The deserializer does not know that the string was initially of type <xref:System.Uri>.</span></span> <span data-ttu-id="35eed-216">Genellikle, beklenirken <xref:System.Object> Tüm json dizeleri .net dizeleri olarak seri durumdan çıkarılacak ve .net koleksiyonları, sözlükleri ve dizilerini seri hale getirmek için kullanılan tüm JSON dizileri, <xref:System.Array> <xref:System.Object> gerçek özgün türün ne olursa olsun, türü .net olarak seri durumdan çıkarılacak.</span><span class="sxs-lookup"><span data-stu-id="35eed-216">Generally, when expecting <xref:System.Object>, all JSON strings are deserialized as .NET strings, and all JSON arrays used to serialize .NET collections, dictionaries, and arrays are deserialized as .NET <xref:System.Array> of type <xref:System.Object>, regardless of what the actual original type had been.</span></span> <span data-ttu-id="35eed-217">Bir JSON Boole değeri bir .NET ile eşlenir <xref:System.Boolean> .</span><span class="sxs-lookup"><span data-stu-id="35eed-217">A JSON boolean maps to a .NET <xref:System.Boolean>.</span></span> <span data-ttu-id="35eed-218">Ancak <xref:System.Object> , bir değeri beklerken, .net ya da <xref:System.Int32> <xref:System.Decimal> <xref:System.Double> en uygun türün otomatik olarak çekildiği JSON numaralarının serisi kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-218">However when expecting an <xref:System.Object>, JSON numbers are deserialized as either .NET <xref:System.Int32>, <xref:System.Decimal> or <xref:System.Double>, where the most appropriate type is automatically picked.</span></span>

<span data-ttu-id="35eed-219">Arabirim türünde seri durumdan çıkarılırken, <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> belirtilen tür nesne gibi seri hale getirir.</span><span class="sxs-lookup"><span data-stu-id="35eed-219">When deserializing into an interface type, the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> deserializes as if the declared type were object.</span></span>

<span data-ttu-id="35eed-220">Kendi Tabanınızla ve türetilmiş türlerle çalışırken, <xref:System.Runtime.Serialization.KnownTypeAttribute> <xref:System.ServiceModel.ServiceKnownTypeAttribute> veya ile eşdeğer bir mekanizma gereklidir.</span><span class="sxs-lookup"><span data-stu-id="35eed-220">When working with your own base and derived types, using the <xref:System.Runtime.Serialization.KnownTypeAttribute>, <xref:System.ServiceModel.ServiceKnownTypeAttribute> or an equivalent mechanism is normally required.</span></span> <span data-ttu-id="35eed-221">Örneğin, bir `Animal` dönüş değeri olan ve aslında (öğesinden türetilmiş) bir örneğini döndüren bir işlemden sahipseniz, `Cat` `Animal` <xref:System.Runtime.Serialization.KnownTypeAttribute> öğesini `Animal` türüne ya da öğesine uygulamanız gerekir <xref:System.ServiceModel.ServiceKnownTypeAttribute> ve `Cat` türü bu özniteliklerde belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="35eed-221">For example, if you have an operation that has an `Animal` return value and it actually returns an instance of `Cat` (derived from `Animal`), you should either apply the <xref:System.Runtime.Serialization.KnownTypeAttribute>, to the `Animal` type or the <xref:System.ServiceModel.ServiceKnownTypeAttribute> to the operation and specify the `Cat` type in these attributes.</span></span> <span data-ttu-id="35eed-222">Daha fazla bilgi için bkz. [veri sözleşmesi bilinen türleri](data-contract-known-types.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-222">For more information, see [Data Contract Known Types](data-contract-known-types.md).</span></span>

<span data-ttu-id="35eed-223">Çok biçimli serileştirme çalışmasının nasıl çalıştığı ve bunu kullanırken dikkate alınmalıdır bazı sınırlamalara ilişkin bir Tartışmayla ilgili ayrıntılar için, bu konunun ilerleyen kısımlarında yer alan gelişmiş bilgiler bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="35eed-223">For details of how polymorphic serialization works and a discussion of some of the limitations that must be respected when using it, see the Advanced Information section later in this topic.</span></span>

### <a name="versioning"></a><span data-ttu-id="35eed-224">Sürüm Oluşturma</span><span class="sxs-lookup"><span data-stu-id="35eed-224">Versioning</span></span>

<span data-ttu-id="35eed-225">Arabirim dahil, veri anlaşması sürüm oluşturma özellikleri <xref:System.Runtime.Serialization.IExtensibleDataObject> JSON 'da tamamen desteklenir.</span><span class="sxs-lookup"><span data-stu-id="35eed-225">The data contract versioning features, including the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface, are fully supported in JSON.</span></span> <span data-ttu-id="35eed-226">Ayrıca, çoğu durumda bir türün bir biçimde serisini kaldırmak (örneğin, XML) ve daha sonra başka bir biçimde (örneğin, JSON) seri hale getirmek ve ' de verileri sürdürmek mümkündür <xref:System.Runtime.Serialization.IExtensibleDataObject> .</span><span class="sxs-lookup"><span data-stu-id="35eed-226">Furthermore, in most cases it is possible to deserialize a type in one format (for example, XML) and then serialize it into another format (for example, JSON) and still preserve the data in <xref:System.Runtime.Serialization.IExtensibleDataObject>.</span></span> <span data-ttu-id="35eed-227">Daha fazla bilgi için bkz. [Ileri uyumlu veri sözleşmeleri](forward-compatible-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-227">For more information, see [Forward-Compatible Data Contracts](forward-compatible-data-contracts.md).</span></span> <span data-ttu-id="35eed-228">Herhangi bir sipariş bilgisinin kaybedilmesi için JSON 'un sıralanmamış olduğunu unutmayın.</span><span class="sxs-lookup"><span data-stu-id="35eed-228">Remember that JSON is unordered so any order information is lost.</span></span> <span data-ttu-id="35eed-229">Ayrıca, JSON aynı anahtar adına sahip birden çok anahtar/değer çiftini desteklemez.</span><span class="sxs-lookup"><span data-stu-id="35eed-229">Furthermore, JSON does not support multiple key/value pairs with the same key name.</span></span> <span data-ttu-id="35eed-230">Son olarak, üzerindeki tüm işlemler <xref:System.Runtime.Serialization.IExtensibleDataObject> doğal olarak çok biçimli olur; bunların türetilmiş türü <xref:System.Object> , tüm türlerin temel türüdür.</span><span class="sxs-lookup"><span data-stu-id="35eed-230">Finally, all operations on <xref:System.Runtime.Serialization.IExtensibleDataObject> are inherently polymorphic - that is their derived type are assigned to <xref:System.Object>, the base type for all types.</span></span>

## <a name="json-in-urls"></a><span data-ttu-id="35eed-231">URL 'Lerdeki JSON</span><span class="sxs-lookup"><span data-stu-id="35eed-231">JSON in URLs</span></span>

<span data-ttu-id="35eed-232">HTTP GET fiili ile ASP.NET AJAX uç noktaları kullanılırken ( <xref:System.ServiceModel.Web.WebGetAttribute> özniteliği kullanılarak), gelen parametreler ileti gövdesi yerine Istek URL 'sinde görüntülenir.</span><span class="sxs-lookup"><span data-stu-id="35eed-232">When using ASP.NET AJAX endpoints with the HTTP GET verb (using the <xref:System.ServiceModel.Web.WebGetAttribute> attribute), incoming parameters appear in the request URL instead of the message body.</span></span> <span data-ttu-id="35eed-233">JSON, istek URL 'sinde bile desteklenir, yani `Int` "numara" adlı bir işlem ve `Person` "p" adlı karmaşık bir tür varsa URL aşağıdaki URL 'ye benzeyebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-233">JSON is supported even in the request URL, so if you have an operation that takes an `Int` called "number" and a `Person` complex type called "p", the URL may resemble the following URL.</span></span>

```html
http://example.com/myservice.svc/MyOperation?number=7&p={"name":"John","age":42}
```

<span data-ttu-id="35eed-234">Hizmeti çağırmak için bir ASP.NET AJAX betik Yöneticisi denetimi ve proxy kullanıyorsanız, bu URL proxy tarafından otomatik olarak oluşturulur ve görünmez.</span><span class="sxs-lookup"><span data-stu-id="35eed-234">If you are using an ASP.NET AJAX Script Manager control and proxy to call the service, this URL is automatically generated by the proxy and is not seen.</span></span> <span data-ttu-id="35eed-235">JSON, non-ASP.NET AJAX uç noktalarında URL 'lerde kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="35eed-235">JSON cannot be used in URLs on non-ASP.NET AJAX endpoints.</span></span>

## <a name="advanced-information"></a><span data-ttu-id="35eed-236">Gelişmiş bilgiler</span><span class="sxs-lookup"><span data-stu-id="35eed-236">Advanced information</span></span>

### <a name="iserializable-support"></a><span data-ttu-id="35eed-237">ISerializable desteği</span><span class="sxs-lookup"><span data-stu-id="35eed-237">ISerializable Support</span></span>

#### <a name="supported-and-unsupported-iserializable-types"></a><span data-ttu-id="35eed-238">Desteklenen ve desteklenmeyen ISerializable türleri</span><span class="sxs-lookup"><span data-stu-id="35eed-238">Supported and Unsupported ISerializable Types</span></span>

<span data-ttu-id="35eed-239">Genel olarak, arayüzü uygulayan türler <xref:System.Runtime.Serialization.ISerializable> JSON serileştirilirken/seri durumdan çıkarılırken tamamen desteklenir.</span><span class="sxs-lookup"><span data-stu-id="35eed-239">In general, types that implement the <xref:System.Runtime.Serialization.ISerializable> interface are fully supported when serializing/deserializing JSON.</span></span> <span data-ttu-id="35eed-240">Ancak, bu türlerden bazıları (bazı .NET Framework türler dahil), JSON 'a özgü serileştirme yönlerini doğru şekilde seri durumdan çıkarmamasına neden olacak şekilde uygulanır:</span><span class="sxs-lookup"><span data-stu-id="35eed-240">However, some of these types (including some .NET Framework types) are implemented in such a way that the JSON-specific serialization aspects cause them to not deserialize correctly:</span></span>

- <span data-ttu-id="35eed-241">İle <xref:System.Runtime.Serialization.ISerializable> , bireysel veri üyelerinin türü hiçbir şekilde önceden bilinmez.</span><span class="sxs-lookup"><span data-stu-id="35eed-241">With <xref:System.Runtime.Serialization.ISerializable>, the type of individual data members is never known in advance.</span></span> <span data-ttu-id="35eed-242">Bu, türlerin serisini kaldırmada benzer bir polimorfik bir duruma yol açar.</span><span class="sxs-lookup"><span data-stu-id="35eed-242">This leads to a polymorphic situation similar to deserializing types into an object.</span></span> <span data-ttu-id="35eed-243">Daha önce bahsedildiği gibi, bu, JSON içinde bilgi türü kaybına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-243">As mentioned before, this may lead to loss of type information in JSON.</span></span> <span data-ttu-id="35eed-244">Örneğin, kendi uygulamasında seri hale getirilen bir tür `enum` <xref:System.Runtime.Serialization.ISerializable> ve `enum` `enum` JSON ve JSON numaralarının yerleşik .net sayısal türlerine (Int32, Decimal veya Double) seri durumdan çıkarılabilecek şekilde serileştirildiği için, bu bir tür başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-244">For example, a type that serializes an `enum` in its <xref:System.Runtime.Serialization.ISerializable> implementation and attempts to deserialize back directly into an `enum` (without proper casts) fails, because an `enum` is serialized using numbers in JSON and JSON numbers deserialize into built-in .NET numeric types (Int32, Decimal or Double).</span></span> <span data-ttu-id="35eed-245">Bu nedenle, bir değer olarak kullanılan sayının kaybolması aslında `enum` kaybolur.</span><span class="sxs-lookup"><span data-stu-id="35eed-245">So the fact that the number used to be an `enum` value is lost.</span></span>

- <span data-ttu-id="35eed-246"><xref:System.Runtime.Serialization.ISerializable>Seri hale getiricilerin çoğu belirli bir sırayı garanti etmez, bu, seri durumdan çıkarma oluşturucusunda belirli bir seri durumdan çıkarma sırasına bağlı bir tür JSON verilerinin serisini de gerçekleştiremeyebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-246">An <xref:System.Runtime.Serialization.ISerializable> type that depends on a particular order of deserialization in its deserialization constructor may also fail to deserialize some JSON data, because most JSON serializers do not guarantee any specific order.</span></span>

#### <a name="factory-types"></a><span data-ttu-id="35eed-247">Fabrika türleri</span><span class="sxs-lookup"><span data-stu-id="35eed-247">Factory Types</span></span>

<span data-ttu-id="35eed-248"><xref:System.Runtime.Serialization.IObjectReference>ARABIRIM JSON 'da genel olarak desteklenirken, "fabrika türü" özelliği gerektiren herhangi bir tür (arabirimi uygulayan türden farklı bir türün örneğini döndüren <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> ) desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="35eed-248">While the <xref:System.Runtime.Serialization.IObjectReference> interface is supported in JSON in general, any types that require the "factory type" feature (returning an instance of a different type from <xref:System.Runtime.Serialization.IObjectReference.GetRealObject%28System.Runtime.Serialization.StreamingContext%29> than the type that implements the interface) are not supported.</span></span>

### <a name="datetime-wire-format"></a><span data-ttu-id="35eed-249">DateTime Tel biçimi</span><span class="sxs-lookup"><span data-stu-id="35eed-249">DateTime Wire Format</span></span>

<span data-ttu-id="35eed-250"><xref:System.DateTime> değerler, "/date (700000 + 0500)/" biçiminde JSON dizeleri olarak görünür; burada ilk sayı (örnekteki 700000), gece yarısı, 1 Ocak 1970 ' de gece yarısından bu yana normal (günışığından yararlanma dışı tasarruf) zaman sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="35eed-250"><xref:System.DateTime> values appear as JSON strings in the form of "/Date(700000+0500)/", where the first number (700000 in the example provided) is the number of milliseconds in the GMT time zone, regular (non-daylight savings) time since midnight, January 1, 1970.</span></span> <span data-ttu-id="35eed-251">Bu sayı, önceki süreleri temsil etmek için negatif olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-251">The number may be negative to represent earlier times.</span></span> <span data-ttu-id="35eed-252">Örnekteki "+ 0500" ' den oluşan bölüm isteğe bağlıdır ve zamanın tür olduğunu, yani <xref:System.DateTimeKind.Local> seri durumundan çıkarma sırasında yerel saat dilimine dönüştürülmesi gerektiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="35eed-252">The part that consists of "+0500" in the example is optional and indicates that the time is of the <xref:System.DateTimeKind.Local> kind - that is, should be converted to the local time zone on deserialization.</span></span> <span data-ttu-id="35eed-253">Bu değer yoksa, saat seri durumdan çıkarılmış olur <xref:System.DateTimeKind.Utc> .</span><span class="sxs-lookup"><span data-stu-id="35eed-253">If it is absent, the time is deserialized as <xref:System.DateTimeKind.Utc>.</span></span> <span data-ttu-id="35eed-254">Gerçek sayı (Bu örnekte "0500") ve işareti (+ veya-) yok sayılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-254">The actual number ("0500" in this example) and its sign (+ or -) are ignored.</span></span>

<span data-ttu-id="35eed-255">Serileştirilirken <xref:System.DateTime> <xref:System.DateTimeKind.Local> ve <xref:System.DateTimeKind.Unspecified> zaman bir uzaklığa göre yazıldığında ve <xref:System.DateTimeKind.Utc> olmadan yazıldığında.</span><span class="sxs-lookup"><span data-stu-id="35eed-255">When serializing <xref:System.DateTime>, <xref:System.DateTimeKind.Local> and <xref:System.DateTimeKind.Unspecified> times are written with an offset, and <xref:System.DateTimeKind.Utc> is written without.</span></span>

<span data-ttu-id="35eed-256">ASP.NET AJAX istemci JavaScript kodu, bu tür dizeleri otomatik olarak JavaScript `DateTime` örneklerine dönüştürür.</span><span class="sxs-lookup"><span data-stu-id="35eed-256">The ASP.NET AJAX client JavaScript code automatically converts such strings into JavaScript `DateTime` instances.</span></span> <span data-ttu-id="35eed-257">.NET ' te türünde olmayan benzer bir forma sahip başka dizeler varsa <xref:System.DateTime> , bunlar da dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="35eed-257">If there are other strings that have a similar form that are not of type <xref:System.DateTime> in .NET, they are converted as well.</span></span>

<span data-ttu-id="35eed-258">Dönüştürme yalnızca, "/" karakterlerinin kaçış durumunda (yani, JSON " \\ /date (700000 + 0500) \\ /") ve bu nedenle WCF 'nin JSON Kodlayıcısı (tarafından etkinleştirilir <xref:System.ServiceModel.WebHttpBinding> ) her zaman "/" karakteri çıkar.</span><span class="sxs-lookup"><span data-stu-id="35eed-258">The conversion only takes place if the "/" characters are escaped (that is, the JSON looks like "\\/Date(700000+0500)\\/"), and for this reason WCF's JSON encoder (enabled by the <xref:System.ServiceModel.WebHttpBinding>) always escapes the "/" character.</span></span>

### <a name="xml-in-json-strings"></a><span data-ttu-id="35eed-259">JSON dizelerinde XML</span><span class="sxs-lookup"><span data-stu-id="35eed-259">XML in JSON Strings</span></span>

#### <a name="xmlelement"></a><span data-ttu-id="35eed-260">XmlElement</span><span class="sxs-lookup"><span data-stu-id="35eed-260">XmlElement</span></span>

<span data-ttu-id="35eed-261"><xref:System.Xml.XmlElement> , sarmalama olmadan, olarak serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-261"><xref:System.Xml.XmlElement> is serialized as is, with no wrapping.</span></span> <span data-ttu-id="35eed-262">Örneğin, içeren türün "x" veri üyesi <xref:System.Xml.XmlElement> \<abc/> Şu şekilde temsil edilir:</span><span class="sxs-lookup"><span data-stu-id="35eed-262">For example, data member "x" of type <xref:System.Xml.XmlElement> that contains \<abc/> is represented as follows:</span></span>

```json
{"x":"<abc/>"}
```

#### <a name="arrays-of-xmlnode"></a><span data-ttu-id="35eed-263">XmlNode dizileri</span><span class="sxs-lookup"><span data-stu-id="35eed-263">Arrays of XmlNode</span></span>

<span data-ttu-id="35eed-264"><xref:System.Array> türündeki nesneler <xref:System.Xml.XmlNode> , türü için standart veri sözleşmesi ad alanında ArrayOfXmlNode adlı bir öğede sarmalanır.</span><span class="sxs-lookup"><span data-stu-id="35eed-264"><xref:System.Array> objects of type <xref:System.Xml.XmlNode> are wrapped in an element called ArrayOfXmlNode in the standard data contract namespace for the type.</span></span> <span data-ttu-id="35eed-265">"X", "değer" ve boş bir "d" öğe düğümünü içeren "NS" ad alanındaki "N" öznitelik düğümünü içeren bir diziyse, Gösterim aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="35eed-265">If "x" is an array that contains attribute node "N" in namespace "ns" that contains "value" and an empty element node "M", the representation is as follows.</span></span>

```json
{"x":"<ArrayOfXmlNode xmlns=\"http://schemas.datacontract.org/2004/07/System.Xml\" a:N=\"value\" xmlns:a=\"ns\"><M/></ArrayOfXmlNode>"}
```

 <span data-ttu-id="35eed-266">XmlNode dizilerinin başındaki (diğer öğelerden önceki) boş ad alanındaki öznitelikler desteklenmez.</span><span class="sxs-lookup"><span data-stu-id="35eed-266">Attributes in the empty namespace at the beginning of XmlNode arrays (before other elements) are unsupported.</span></span>

#### <a name="ixmlserializable-types-including-xelement-and-dataset"></a><span data-ttu-id="35eed-267">XElement ve DataSet dahil IXmlSerializable türleri</span><span class="sxs-lookup"><span data-stu-id="35eed-267">IXmlSerializable Types including XElement and DataSet</span></span>

<span data-ttu-id="35eed-268"><xref:System.Runtime.Serialization.ISerializable> türler, "içerik türleri", "veri kümesi türleri" ve "öğe türleri" içinde alt bölümlere ayırır.</span><span class="sxs-lookup"><span data-stu-id="35eed-268"><xref:System.Runtime.Serialization.ISerializable> types subdivide into "content types", "DataSet types" and "element types".</span></span> <span data-ttu-id="35eed-269">Bu türlerin tanımları için bkz. [veri sözleşmeleri Içindeki XML ve ADO.net türleri](xml-and-ado-net-types-in-data-contracts.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-269">For definitions of these types, see [XML and ADO.NET Types in Data Contracts](xml-and-ado-net-types-in-data-contracts.md).</span></span>

<span data-ttu-id="35eed-270">"İçerik" ve "veri kümesi" türleri, <xref:System.Array> <xref:System.Xml.XmlNode> önceki bölümde ele alınan nesnelere benzer şekilde serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-270">"Content" and "DataSet" types are serialized similar to <xref:System.Array> objects of <xref:System.Xml.XmlNode> discussed in the previous section.</span></span> <span data-ttu-id="35eed-271">Ad ve ad alanı, söz konusu türün veri sözleşmesi adına ve ad alanına karşılık gelen bir öğede sarmalanır.</span><span class="sxs-lookup"><span data-stu-id="35eed-271">They are wrapped in an element whose name and namespace corresponds to the data contract name and namespace of the type in question.</span></span>

<span data-ttu-id="35eed-272">Gibi "öğe" türleri <xref:System.Xml.Linq.XElement> , <xref:System.Xml.XmlElement> Bu konuda daha önce açıklananlara benzer olarak serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-272">"Element" types such as <xref:System.Xml.Linq.XElement> are serialized as is, similar to <xref:System.Xml.XmlElement> previously discussed in this topic.</span></span>

### <a name="polymorphism"></a><span data-ttu-id="35eed-273">Çok biçimlilik</span><span class="sxs-lookup"><span data-stu-id="35eed-273">Polymorphism</span></span>

#### <a name="preserving-type-information"></a><span data-ttu-id="35eed-274">Tür bilgilerini koruma</span><span class="sxs-lookup"><span data-stu-id="35eed-274">Preserving Type Information</span></span>

<span data-ttu-id="35eed-275">Daha önce belirtildiği gibi, çok biçimlilik JSON 'ta bazı sınırlamalar ile desteklenir.</span><span class="sxs-lookup"><span data-stu-id="35eed-275">As stated earlier, polymorphism is supported in JSON with some limitations.</span></span> <span data-ttu-id="35eed-276">JavaScript, Zayıf yazılmış bir dildir ve tür kimliği normalde bir sorun değildir.</span><span class="sxs-lookup"><span data-stu-id="35eed-276">JavaScript is a weakly-typed language and type identity is normally not an issue.</span></span> <span data-ttu-id="35eed-277">Ancak, türü kesin belirlenmiş bir sistem (.NET) ve zayıf türsüz bir sistem (JavaScript) arasında iletişim kurmak için JSON kullanırken tür kimliğini korumak yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-277">However, when using JSON to communicate between a strongly typed system (.NET) and a weakly-typed system (JavaScript), it is useful to preserve type identity.</span></span> <span data-ttu-id="35eed-278">Örneğin, veri sözleşme adları "kare" ve "daire" olan türler, "Shape" veri sözleşmesi adına sahip bir türden türetilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-278">For example, types with data contract names "Square" and "Circle" derive from a type with a data contract name of "Shape".</span></span> <span data-ttu-id="35eed-279">.NET ' ten JavaScript 'e ve daha sonra "şekil" bekleyen bir .NET metoduna "daire" döndürülürse, söz konusu nesnenin ilk olarak bir "daire" olduğunu ve aksi durumda türetilmiş türe özgü herhangi bir bilgiyi (örneğin, "daire" üzerinde "yarıçap" veri üyesi) kaybettiğini bilmeleri için .NET tarafında yararlı olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-279">If "Circle" is sent from .NET to JavaScript and is later returned to a .NET method that expects "Shape", it is useful for the .NET side to know that the object in question was originally a "Circle" - otherwise any information specific to the derived type (for example, "radius" data member on "Circle") may be lost.</span></span>

<span data-ttu-id="35eed-280">Tür kimliğini korumak için, karmaşık türler JSON 'a serileştirilirken bir "tür ipucu" eklenebilir ve seri hale getirici ipucunu algılar ve uygun şekilde davranır.</span><span class="sxs-lookup"><span data-stu-id="35eed-280">To preserve type identity, when serializing complex types to JSON a "type hint" can be added, and the deserializer recognizes the hint and acts appropriately.</span></span> <span data-ttu-id="35eed-281">"Tür ipucu", "Type" anahtar adına sahip bir JSON anahtar/değer çiftidir \_ \_ ("Type" kelimesinin ardından iki alt çizgi).</span><span class="sxs-lookup"><span data-stu-id="35eed-281">The "type hint" is a JSON key/value pair with the key name of "\_\_type" (two underscores followed by the word "type").</span></span> <span data-ttu-id="35eed-282">Değer, "DataContractName: DataContractNamespace" biçiminde bir JSON dizesidir (ad, ilk iki nokta üst üste kadar olan addır).</span><span class="sxs-lookup"><span data-stu-id="35eed-282">The value is a JSON string of the form "DataContractName:DataContractNamespace" (anything up to the first colon is the name).</span></span> <span data-ttu-id="35eed-283">Önceki örneği kullanarak, "daire" aşağıdaki gibi seri hale getirilebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-283">Using the earlier example, "Circle" can be serialized as follows.</span></span>

```json
{"__type":"Circle:http://example.com/myNamespace","x":50,"y":70,"radius":10}
```

<span data-ttu-id="35eed-284">Tür ipucu, `xsi:type` XML şema örneği standardı tarafından tanımlanan özniteliğe çok benzer ve XML serileştirilirken/seri durumdan çıkarılırken kullanılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-284">The type hint is very similar to the `xsi:type` attribute defined by the XML Schema Instance standard and used when serializing/deserializing XML.</span></span>

<span data-ttu-id="35eed-285">"Type" adlı veri üyeleri \_ \_ , tür ipucuyla ilgili olası çakışma nedeniyle yasaktır.</span><span class="sxs-lookup"><span data-stu-id="35eed-285">Data members called "\_\_type" are forbidden due to potential conflict with the type hint.</span></span>

#### <a name="reducing-the-size-of-type-hints"></a><span data-ttu-id="35eed-286">Tür Ipuçlarının boyutunu azaltma</span><span class="sxs-lookup"><span data-stu-id="35eed-286">Reducing the Size of Type Hints</span></span>

<span data-ttu-id="35eed-287">JSON iletilerinin boyutunu azaltmak için varsayılan veri sözleşmesi ad alanı ön eki ( `http://schemas.datacontract.org/2004/07/` ) "#" karakteriyle değiştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="35eed-287">To reduce the size of JSON messages, the default data contract namespace prefix (`http://schemas.datacontract.org/2004/07/`) is replaced with the "#" character.</span></span> <span data-ttu-id="35eed-288">(Bu değişikliği geri döndürülebilir hale getirmek için, bir kaçış kuralı kullanılır: ad alanı "#" veya " \\ " karakterlerle başlıyorsa, bunlar fazladan bir " \\ " karakteriyle eklenir).</span><span class="sxs-lookup"><span data-stu-id="35eed-288">(To make this replacement reversible, an escaping rule is used: if the namespace starts with the "#" or "\\" characters, they are appended with an extra "\\" character).</span></span> <span data-ttu-id="35eed-289">Bu nedenle, "Circle" .NET ad alanındaki "MyApp. Shapes" türünde bir tür ise, varsayılan veri sözleşmesi ad alanı olur `http://schemas.datacontract.org/2004/07/MyApp` .</span><span class="sxs-lookup"><span data-stu-id="35eed-289">Thus, if "Circle" is a type in the .NET namespace "MyApp.Shapes", its default data contract namespace is `http://schemas.datacontract.org/2004/07/MyApp`.</span></span> <span data-ttu-id="35eed-290">Şekiller ve JSON temsili aşağıdaki gibidir.</span><span class="sxs-lookup"><span data-stu-id="35eed-290">Shapes and the JSON representation is as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50,"y":70,"radius":10}
```

<span data-ttu-id="35eed-291">Hem kesilmiş (#MyApp. Shapes) hem de Full ( <http://schemas.datacontract.org/2004/07/MyApp.Shapes> ) adları seri durumundan çıkarma sırasında anlaşıldı.</span><span class="sxs-lookup"><span data-stu-id="35eed-291">Both the truncated (#MyApp.Shapes) and the full (<http://schemas.datacontract.org/2004/07/MyApp.Shapes>) names is understood on deserialization.</span></span>

#### <a name="type-hint-position-in-json-objects"></a><span data-ttu-id="35eed-292">JSON nesnelerinde tür Ipucu konumu</span><span class="sxs-lookup"><span data-stu-id="35eed-292">Type Hint Position in JSON Objects</span></span>

<span data-ttu-id="35eed-293">Tür ipucunun JSON temsilinin ilk bölümünde görünmesi gerektiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="35eed-293">Note that the type hint must appear first in the JSON representation.</span></span> <span data-ttu-id="35eed-294">Bu, anahtar/değer çiftlerinin sırasının JSON işlemede önemli olduğu tek durumdur.</span><span class="sxs-lookup"><span data-stu-id="35eed-294">This is the only case where order of key/value pairs is important in JSON processing.</span></span> <span data-ttu-id="35eed-295">Örneğin, tür ipucunu belirtmek için aşağıdaki geçerli bir yol değildir.</span><span class="sxs-lookup"><span data-stu-id="35eed-295">For example, the following is not a valid way to specify the type hint.</span></span>

```json
{"x":50,"y":70,"radius":10,"__type":"Circle:#MyApp.Shapes"}
```

<span data-ttu-id="35eed-296"><xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>WCF ve ASP.NET Ajax istemci sayfaları tarafından kullanılan her ikisi de öncelikle tür ipucunu yayar.</span><span class="sxs-lookup"><span data-stu-id="35eed-296">Both the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> used by WCF and ASP.NET AJAX client pages always emit the type hint first.</span></span>

#### <a name="type-hints-apply-only-to-complex-types"></a><span data-ttu-id="35eed-297">Tür Ipuçları yalnızca karmaşık türler için geçerlidir</span><span class="sxs-lookup"><span data-stu-id="35eed-297">Type Hints Apply Only to Complex Types</span></span>

<span data-ttu-id="35eed-298">Karmaşık olmayan türler için bir tür ipucu yayın bir yolu yoktur.</span><span class="sxs-lookup"><span data-stu-id="35eed-298">There is no way to emit a type hint for non-complex types.</span></span> <span data-ttu-id="35eed-299">Örneğin, bir işlemin <xref:System.Object> dönüş türü varsa ancak bir daire döndürürse, JSON temsili daha önce gösterildiği gibi, tür bilgileri de korunur.</span><span class="sxs-lookup"><span data-stu-id="35eed-299">For example, if an operation has an <xref:System.Object> return type but returns a Circle, the JSON representation can be as shown earlier and the type information is preserved.</span></span> <span data-ttu-id="35eed-300">Ancak, URI döndürülürse JSON temsili bir dizedir ve bir URI 'yi temsil etmek için kullanılan dize kaybedilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-300">However, if Uri is returned, the JSON representation is a string and the fact that the string used to represent a Uri is lost.</span></span> <span data-ttu-id="35eed-301">Bu yalnızca temel türler için değil koleksiyonlar ve diziler için de geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="35eed-301">This applies not only to primitive types but also to collections and arrays.</span></span>

#### <a name="when-are-type-hints-emitted"></a><span data-ttu-id="35eed-302">Tür Ipuçları ne zaman yayınlanır</span><span class="sxs-lookup"><span data-stu-id="35eed-302">When Are Type Hints Emitted</span></span>

<span data-ttu-id="35eed-303">Tür ipuçları ileti boyutunu önemli ölçüde artırabilir (bunun bir yolu, mümkünse daha kısa veri anlaşması ad alanları kullanmaktır).</span><span class="sxs-lookup"><span data-stu-id="35eed-303">Type hints may increase message size significantly (one way to mitigate this is to use shorter data contract namespaces if possible).</span></span> <span data-ttu-id="35eed-304">Bu nedenle, aşağıdaki kurallar tür ipuçlarının yayılıp yayınlanmadığını yönetir:</span><span class="sxs-lookup"><span data-stu-id="35eed-304">Therefore, the following rules govern whether type hints are emitted:</span></span>

- <span data-ttu-id="35eed-305">ASP.NET AJAX kullanırken, bir daire içine bir daire atansa bile, bir taban/türetilmiş atama olmasa bile tür ipuçları her zaman mümkün olduğunda dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-305">When using ASP.NET AJAX, type hints are always emitted whenever possible, even if there is no base/derived assignment - for example, even if a Circle is assigned to a Circle.</span></span> <span data-ttu-id="35eed-306">(Bu, Zayıf yazılmış JSON ortamından çağırma işleminin, önemli olmayan bir bilgi kaybı olmadan kesin olarak belirlenmiş .NET ortamına çağrılması için gereklidir.)</span><span class="sxs-lookup"><span data-stu-id="35eed-306">(This is required to fully enable the process of calling from the weakly-typed JSON environment into the strongly typed .NET environment with no surprising loss of information.)</span></span>

- <span data-ttu-id="35eed-307">ASP.NET tümleştirmesi olmadan AJAX Hizmetleri kullanırken, tür ipuçları yalnızca bir taban/türetilmiş atama olduğunda dağıtılır; bu, daire şekle atandığında veya <xref:System.Object> daire içine atandığında yayılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-307">When using AJAX services with no ASP.NET integration, type hints are only emitted when there is a base/derived assignment - that is, emitted when Circle is assigned to Shape or <xref:System.Object> but not when assigned to Circle.</span></span> <span data-ttu-id="35eed-308">Bu, JavaScript istemcisini doğru şekilde uygulamak için gereken en düşük bilgileri sağlar, bu sayede performansı geliştirir, ancak yanlış tasarlanmış istemcilerde tür bilgi kaybına karşı koruma sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="35eed-308">This provides the minimum information required to correctly implement a JavaScript client, thus improving performance, but does not protect against type information loss in incorrectly-designed clients.</span></span> <span data-ttu-id="35eed-309">İstemcide bu sorunla ilgilenmemek istiyorsanız taban/türetilmiş atamalardan tamamen sunucu üzerinde kaçının.</span><span class="sxs-lookup"><span data-stu-id="35eed-309">Avoid base/derived assignments altogether on the server if you want to avoid dealing with this issue on the client.</span></span>

- <span data-ttu-id="35eed-310"><xref:System.Runtime.Serialization.DataContractSerializer>Türü kullanılırken, `alwaysEmitTypeInformation` Oluşturucu parametresi yukarıdaki iki mod arasında seçim yapmanıza olanak sağlar. varsayılan olarak " `false` " (gerektiğinde yalnızca tür ipuçlarını göster).</span><span class="sxs-lookup"><span data-stu-id="35eed-310">When using the <xref:System.Runtime.Serialization.DataContractSerializer> type, the `alwaysEmitTypeInformation` constructor parameter allows you to choose between the preceding two modes, with the default being "`false`" (only emit type hints when required).</span></span>

#### <a name="duplicate-data-member-names"></a><span data-ttu-id="35eed-311">Yinelenen veri üyesi adları</span><span class="sxs-lookup"><span data-stu-id="35eed-311">Duplicate Data Member Names</span></span>

<span data-ttu-id="35eed-312">Türetilmiş tür bilgileri, temel tür bilgileriyle birlikte aynı JSON nesnesinde bulunur ve herhangi bir sırada gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-312">Derived type information is present in the same JSON object together with base type information, and can occur in any order.</span></span> <span data-ttu-id="35eed-313">Örneğin, `Shape` aşağıdaki gibi gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-313">For example, `Shape` may be represented as follows.</span></span>

```json
{"__type":"Shape:#MyApp.Shapes","x":50,"y":70}
```

<span data-ttu-id="35eed-314">Daire, aşağıdaki gibi gösterilebilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-314">Whereas Circle may be represented as follows.</span></span>

```json
{"__type":"Circle:#MyApp.Shapes","x":50, "radius":10,"y":70}
```

<span data-ttu-id="35eed-315">Temel `Shape` tür Ayrıca "" adlı bir veri üyesi içeriyorsa `radius` , bu, her iki SERILEŞTIRME (JSON nesneleri yinelenen anahtar adlarına sahip olmadığı için) ve seri durumundan çıkarma ("Radius" ya da buna işaret edildiği net olmadığından) için bir çarpışmayı doğurur `Shape.radius` `Circle.radius` .</span><span class="sxs-lookup"><span data-stu-id="35eed-315">If the base `Shape` type also contained a data member called "`radius`", this leads to a collision on both serialization (because JSON objects cannot have repeating key names) and deserialization (because it is unclear whether "radius" refers to `Shape.radius` or `Circle.radius`).</span></span> <span data-ttu-id="35eed-316">Bu nedenle, "özellik gizleme" kavramı (temel ve türetilmiş sınıflarda aynı ada sahip veri üyeleri) genellikle veri sözleşme sınıflarında önerilmemekle karşı, JSON durumunda gerçekten yasak olur.</span><span class="sxs-lookup"><span data-stu-id="35eed-316">Therefore, while the concept of "property hiding" (data members of the same name on based and derived classes) is generally not recommended in data contract classes, it is actually forbidden in the case of JSON.</span></span>

#### <a name="polymorphism-and-ixmlserializable-types"></a><span data-ttu-id="35eed-317">Çok biçimlilik ve IXmlSerializable türleri</span><span class="sxs-lookup"><span data-stu-id="35eed-317">Polymorphism and IXmlSerializable Types</span></span>

<span data-ttu-id="35eed-318"><xref:System.Xml.Serialization.IXmlSerializable> türler, her zamanki veri sözleşme kurallarına göre, bilinen türler karşılandığı sürece her zamanki gibi polymorphically atanmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-318"><xref:System.Xml.Serialization.IXmlSerializable> types may be polymorphically assigned to each other as usual as long as Known Types requirements are met, according to usual data contract rules.</span></span> <span data-ttu-id="35eed-319">Ancak, <xref:System.Xml.Serialization.IXmlSerializable> <xref:System.Object> sonuç bir JSON dizesi olduğu için tür bilgilerinin kaybına neden olan bir türün serileştirilmesi.</span><span class="sxs-lookup"><span data-stu-id="35eed-319">However, serializing an <xref:System.Xml.Serialization.IXmlSerializable> type in place of <xref:System.Object> results in loss of type information as the result is a JSON string.</span></span>

#### <a name="polymorphism-and-certain-interface-types"></a><span data-ttu-id="35eed-320">Çok biçimlilik ve belirli arabirim türleri</span><span class="sxs-lookup"><span data-stu-id="35eed-320">Polymorphism and Certain Interface Types</span></span>

<span data-ttu-id="35eed-321">Bir koleksiyon türü veya <xref:System.Xml.Serialization.IXmlSerializable> olmayan bir koleksiyon türü <xref:System.Xml.Serialization.IXmlSerializable> (için hariç) için beklenen bir türü seri hale getirmek yasaktır <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="35eed-321">It is forbidden to serialize a collection type or a type that implements <xref:System.Xml.Serialization.IXmlSerializable> where a non-collection type that is not <xref:System.Xml.Serialization.IXmlSerializable> (except for <xref:System.Object>) is expected.</span></span> <span data-ttu-id="35eed-322">Örneğin, adlı özel bir arabirim `IMyInterface` ve `MyType` hem türü hem de uygulayan bir tür <xref:System.Collections.Generic.IEnumerable%601> `int` `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="35eed-322">For example, a custom interface called `IMyInterface` and a type `MyType` that implement both <xref:System.Collections.Generic.IEnumerable%601> of type `int` and `IMyInterface`.</span></span> <span data-ttu-id="35eed-323">`MyType`Dönüş türü olan bir işlemden döndürülmesi yasaktır `IMyInterface` .</span><span class="sxs-lookup"><span data-stu-id="35eed-323">It is forbidden to return `MyType` from an operation whose return type is `IMyInterface`.</span></span> <span data-ttu-id="35eed-324">Bunun nedeni, `MyType` BIR JSON dizisi olarak serileştirilmesi ve bir tür ipucu gerektirdiğinden ve diziler içeren bir tür ipucu ve yalnızca karmaşık türlerle dahil edilebilmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="35eed-324">This is because `MyType` must be serialized as a JSON array and requires a type hint, and as stated before you cannot include a type hint with arrays, only with complex types.</span></span>

#### <a name="known-types-and-configuration"></a><span data-ttu-id="35eed-325">Bilinen türler ve yapılandırma</span><span class="sxs-lookup"><span data-stu-id="35eed-325">Known Types and Configuration</span></span>

<span data-ttu-id="35eed-326">Tarafından kullanılan tüm bilinen tür mekanizmaları <xref:System.Runtime.Serialization.DataContractSerializer> , ile aynı şekilde de desteklenir <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> .</span><span class="sxs-lookup"><span data-stu-id="35eed-326">All of the Known Type mechanisms used by the <xref:System.Runtime.Serialization.DataContractSerializer> are also supported in the same way by the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>.</span></span> <span data-ttu-id="35eed-327">Her iki serileştiriciler, [\<dataContractSerializer>](../../configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) [\<system.runtime.serialization>](../../configure-apps/file-schema/wcf/system-runtime-serialization.md) bir yapılandırma dosyası aracılığıyla eklenen bilinen türleri öğrenmek için içindeki aynı yapılandırma öğesini okur.</span><span class="sxs-lookup"><span data-stu-id="35eed-327">Both serializers read the same configuration element, [\<dataContractSerializer>](../../configure-apps/file-schema/wcf/datacontractserializer-of-system-runtime-serialization.md) in [\<system.runtime.serialization>](../../configure-apps/file-schema/wcf/system-runtime-serialization.md), to discover known types added through a configuration file.</span></span>

#### <a name="collections-assigned-to-object"></a><span data-ttu-id="35eed-328">Nesneye atanan Koleksiyonlar</span><span class="sxs-lookup"><span data-stu-id="35eed-328">Collections Assigned to Object</span></span>

<span data-ttu-id="35eed-329">Nesnesine atanan koleksiyonlar, uygulayan koleksiyonlardır olarak serileştirilir <xref:System.Collections.Generic.IEnumerable%601> : BIR JSON dizisi, bir tür ipucu olan her bir girdi, karmaşık bir türdür.</span><span class="sxs-lookup"><span data-stu-id="35eed-329">Collections assigned to Object are serialized as if they are collections that implement <xref:System.Collections.Generic.IEnumerable%601>: a JSON array with each entry that has a type hint if it is a complex type.</span></span> <span data-ttu-id="35eed-330">Örneğin, atanmış bir <xref:System.Collections.Generic.List%601> türü `Shape` <xref:System.Object> aşağıdaki gibi görünür.</span><span class="sxs-lookup"><span data-stu-id="35eed-330">For example, a <xref:System.Collections.Generic.List%601> of type `Shape` assigned to <xref:System.Object> looks like the following.</span></span>

```json
[{"__type":"Shape:#MyApp.Shapes","x":50,"y":70},
{"__type":"Shape:#MyApp.Shapes","x":58,"y":73},
{"__type":"Shape:#MyApp.Shapes","x":41,"y":32}]
```

<span data-ttu-id="35eed-331">Seri durumdan yeniden <xref:System.Object> :</span><span class="sxs-lookup"><span data-stu-id="35eed-331">When deserialized back into <xref:System.Object>:</span></span>

- <span data-ttu-id="35eed-332">`Shape` Bilinen türler listesinde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="35eed-332">`Shape` must be in the Known Types list.</span></span> <span data-ttu-id="35eed-333"><xref:System.Collections.Generic.List%601> `Shape` Bilinen türlerde türün bir etkisi yoktur.</span><span class="sxs-lookup"><span data-stu-id="35eed-333">Having <xref:System.Collections.Generic.List%601> of type `Shape` in known types has no effect.</span></span> <span data-ttu-id="35eed-334">`Shape`Bu durumda, serileştirme üzerinde bilinen türlere eklemeniz gerekmez; bu otomatik olarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="35eed-334">Note that you do not have to add `Shape` to known types on serialization in this case - this is done automatically.</span></span>

- <span data-ttu-id="35eed-335">Koleksiyon, örnekleri içeren bir tür olarak seri durumdan çıkarılacak <xref:System.Array> <xref:System.Object> `Shape` .</span><span class="sxs-lookup"><span data-stu-id="35eed-335">The collection is deserialized as an <xref:System.Array> of type <xref:System.Object> that contains `Shape` instances.</span></span>

#### <a name="derived-collections-assigned-to-base-collections"></a><span data-ttu-id="35eed-336">Taban koleksiyonlara atanmış türetilmiş Koleksiyonlar</span><span class="sxs-lookup"><span data-stu-id="35eed-336">Derived Collections Assigned to Base Collections</span></span>

<span data-ttu-id="35eed-337">Türetilmiş bir koleksiyon bir temel koleksiyona atandığında, koleksiyon genellikle temel türün bir koleksiyonu gibi serileştirilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-337">When a derived collection is assigned to a base collection, the collection is usually serialized as if it was a collection of the base type.</span></span> <span data-ttu-id="35eed-338">Ancak, türetilmiş koleksiyonun öğe türü, temel koleksiyonun öğe türüne atanmamışsa, bir özel durum oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="35eed-338">However, if the item type of the derived collection cannot be assigned to the item type of the base collection, an exception is thrown.</span></span>

#### <a name="type-hints-and-dictionaries"></a><span data-ttu-id="35eed-339">Ipuçları ve sözlükler yazın</span><span class="sxs-lookup"><span data-stu-id="35eed-339">Type Hints and Dictionaries</span></span>

<span data-ttu-id="35eed-340">Bir sözlüğe bir sözlük atandığında <xref:System.Object> , Sözlükteki her anahtar ve değer girişi atanmış gibi değerlendirilir <xref:System.Object> ve bir tür ipucu alır.</span><span class="sxs-lookup"><span data-stu-id="35eed-340">When a dictionary is assigned to an <xref:System.Object>, each Key and Value entry in the dictionary is treated as if it was assigned to <xref:System.Object> and gets a type hint.</span></span>

<span data-ttu-id="35eed-341">Sözlük türlerini serileştirirken, "Key" ve "Value" üyelerini içeren JSON nesnesi `alwaysEmitTypeInformation` ayarından etkilenmez ve yalnızca önceki koleksiyon kuralları gerektirdiğinde bir tür ipucu içerir.</span><span class="sxs-lookup"><span data-stu-id="35eed-341">When serializing dictionary types, the JSON object that contains the "Key" and "Value" members is unaffected by the `alwaysEmitTypeInformation` setting and only contains a type hint when the preceding collection rules require it.</span></span>

### <a name="valid-json-key-names"></a><span data-ttu-id="35eed-342">Geçerli JSON anahtar adları</span><span class="sxs-lookup"><span data-stu-id="35eed-342">Valid JSON Key Names</span></span>

<span data-ttu-id="35eed-343">Seri hale getirici XML-geçerli XML adı olmayan anahtar adlarını kodlar.</span><span class="sxs-lookup"><span data-stu-id="35eed-343">The serializer XML-encodes key names that are not valid XML names.</span></span> <span data-ttu-id="35eed-344">Örneğin, "123" adlı bir veri üyesi "x0031 x0032 x0033" gibi kodlanmış bir ada sahip olur, \_ \_ \_ \_ \_ \_ çünkü "123" geçersiz bir XML öğesi adı (bir basamakla başlar).</span><span class="sxs-lookup"><span data-stu-id="35eed-344">For example, a data member with the name of "123" would have an encoded name such as "\_x0031\_\_x0032\_\_x0033\_" because "123" is an invalid XML element name (starts with a digit).</span></span> <span data-ttu-id="35eed-345">Bazı uluslararası karakter kümelerinde XML adlarında geçerli olmayan benzer bir durum ortaya çıkabilir.</span><span class="sxs-lookup"><span data-stu-id="35eed-345">A similar situation may arise with some international character sets not valid in XML names.</span></span> <span data-ttu-id="35eed-346">JSON işlemede XML 'nin bu efektinin açıklaması için bkz. [JSON ve XML arasında eşleme](mapping-between-json-and-xml.md).</span><span class="sxs-lookup"><span data-stu-id="35eed-346">For an explanation of this effect of XML on JSON processing, see [Mapping Between JSON and XML](mapping-between-json-and-xml.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="35eed-347">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="35eed-347">See also</span></span>

- [<span data-ttu-id="35eed-348">JSON ve Diğer Veri Aktarma Biçimleri için Destek</span><span class="sxs-lookup"><span data-stu-id="35eed-348">Support for JSON and Other Data Transfer Formats</span></span>](support-for-json-and-other-data-transfer-formats.md)
