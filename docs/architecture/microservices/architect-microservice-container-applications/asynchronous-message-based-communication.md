---
title: Zaman uyumsuz ileti tabanlı iletişim
description: Kapsayıcılı .NET uygulamaları için .NET mikro hizmetleri mimarisi | Zaman uyumsuz ileti tabanlı iletişimler mikro hizmetler mimarisinde önemli bir kavramdır, çünkü mikro hizmetleri bir diğerinden bağımsız tutmanın en iyi yolu, Ayrıca, sonunda da eşzamanlı olarak eşitlenmektir.
ms.date: 09/20/2018
ms.openlocfilehash: 2bd79935cad3d62e488a57da6b40a0c87349960b
ms.sourcegitcommit: aa6d8a90a4f5d8fe0f6e967980b8c98433f05a44
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 09/16/2020
ms.locfileid: "90679181"
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="dc5ed-103">Zaman uyumsuz ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="dc5ed-103">Asynchronous message-based communication</span></span>

<span data-ttu-id="dc5ed-104">Zaman uyumsuz mesajlaşma ve olay odaklı iletişim, değişiklikler birden çok mikro hizmette ve ilgili etki alanı modelleriyle yayılırken kritik öneme sahiptir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-104">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="dc5ed-105">Daha önce tartışma mikro hizmetleri ve sınırlanmış bağlamlar (IBH), modeller (Kullanıcı, müşteri, ürün, hesap, vb.), farklı mikro hizmetler veya BCs farklı şeyler anlamına gelebilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-105">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="dc5ed-106">Bu, değişiklikler gerçekleştiğinde farklı modellerdeki değişiklikleri mutabık kılmak için bir yol yapmanız gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-106">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="dc5ed-107">Bir çözüm, zaman uyumsuz mesajlaşmaya göre nihai tutarlılık ve olay odaklı iletişimdir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-107">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="dc5ed-108">Mesajlaşma kullanılırken, işlem zaman uyumsuz olarak ileti değiş tokuşu yaparak iletişim kurar.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-108">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="dc5ed-109">İstemci bir ileti göndererek bir komut veya hizmet isteği yapar.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-109">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="dc5ed-110">Hizmetin yanıt vermesi gerekiyorsa, istemciye başka bir ileti gönderilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-110">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="dc5ed-111">İleti tabanlı bir iletişim olduğundan, istemci yanıtın hemen alınmayabileceğini ve hiç yanıt alınmadığını varsayar.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-111">Since it's a message-based communication, the client assumes that the reply won't be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="dc5ed-112">Bir ileti, bir üst bilgi (tanımlama veya güvenlik bilgileri gibi meta veriler) ve bir gövde ile oluşur.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-112">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="dc5ed-113">İletiler genellikle AMQP gibi zaman uyumsuz protokoller aracılığıyla gönderilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-113">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="dc5ed-114">Mikro hizmetler topluluğundaki bu iletişim türü için tercih edilen altyapı, SOA 'de kullanılan büyük aracılardan ve düzenleyicilerinden farklı olan hafif bir ileti aracısıdır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-114">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="dc5ed-115">Hafif bir ileti aracısından altyapı genellikle "Dumb", yalnızca bir ileti Aracısı olarak davranan, bulutta ırbbitmq veya ölçeklenebilir bir hizmet veri yolu gibi basit uygulamalarla (Azure Service Bus gibi).</span><span class="sxs-lookup"><span data-stu-id="dc5ed-115">In a lightweight message broker, the infrastructure is typically "dumb," acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="dc5ed-116">Bu senaryoda, "akıllı" düşünmenin çoğu, iletileri üreten ve kullanan uç noktalarda (mikro hizmetlerde) devam etmektedir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-116">In this scenario, most of the "smart" thinking still lives in the endpoints that are producing and consuming messages-that is, in the microservices.</span></span>

<span data-ttu-id="dc5ed-117">İzlemeniz gereken diğer bir kural, iç hizmetler arasında yalnızca zaman uyumsuz mesajlaşma kullanmak ve yalnızca istemci uygulamalarından ön uç hizmetlerine (API ağ geçitleri ve ilk mikro hizmet düzeyi) zaman uyumlu iletişim (HTTP gibi) kullanmak içindir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-117">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="dc5ed-118">İki tür zaman uyumsuz mesajlaşma iletişimi vardır: tek alıcı ileti tabanlı iletişim ve birden çok alıcı ileti tabanlı iletişim.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-118">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="dc5ed-119">Aşağıdaki bölümlerde bunlarla ilgili ayrıntılar sağlanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-119">The following sections provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="dc5ed-120">Tek ahize ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="dc5ed-120">Single-receiver message-based communication</span></span>

<span data-ttu-id="dc5ed-121">Tek bir alıcı ile ileti tabanlı zaman uyumsuz iletişim, kanaldan okuyan tüketicilerden tam olarak birine bir ileti sunan noktadan noktaya iletişim ve iletinin yalnızca bir kez işlendiğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-121">Message-based asynchronous communication with a single receiver means there's point-to-point communication that delivers a message to exactly one of the consumers that's reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="dc5ed-122">Ancak, özel durumlar vardır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-122">However, there are special situations.</span></span> <span data-ttu-id="dc5ed-123">Örneğin, hatalardan otomatik olarak kurtarmaya çalışan bir bulut sisteminde, aynı ileti birden çok kez gönderilebilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-123">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="dc5ed-124">Ağ veya diğer hatalardan dolayı istemcinin iletileri göndermeyi yeniden denemesi gerekir ve sunucunun belirli bir iletiyi yalnızca bir kez işlemesi için ıdempotent olmak üzere bir işlem uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-124">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="dc5ed-125">Tek alıcıdaki ileti tabanlı iletişim, bu yaklaşımı gösteren şekil 4-18 ' de gösterildiği gibi, bir mikro hizmetten diğerine zaman uyumsuz komutların gönderilmesi için özellikle idealdir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-125">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="dc5ed-126">İleti tabanlı iletişim göndermeye başladıktan sonra (komutları veya olayları kullanarak), zaman uyumlu HTTP iletişimi ile ileti tabanlı iletişimi karıştırmaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-126">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![Tek bir mikro hizmet zaman uyumsuz ileti alıyor](./media/asynchronous-message-based-communication/single-receiver-message-based-communication.png)

<span data-ttu-id="dc5ed-128">**Şekil 4-18**.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-128">**Figure 4-18**.</span></span> <span data-ttu-id="dc5ed-129">Tek bir mikro hizmet zaman uyumsuz ileti alıyor</span><span class="sxs-lookup"><span data-stu-id="dc5ed-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="dc5ed-130">Komutlar istemci uygulamalardan geldiğinde, HTTP zaman uyumlu komutları olarak uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-130">When the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="dc5ed-131">Daha yüksek ölçeklenebilirlik gerektiğinde veya ileti tabanlı bir iş sürecinizdeki ileti tabanlı komutları kullanın.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-131">Use message-based commands when you need higher scalability or when you're already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="dc5ed-132">Birden çok alıcılar ileti tabanlı iletişim</span><span class="sxs-lookup"><span data-stu-id="dc5ed-132">Multiple-receivers message-based communication</span></span>

<span data-ttu-id="dc5ed-133">Daha esnek bir yaklaşım olarak, gönderenden iletişimin ek abone mikro hizmetleri veya dış uygulamalar tarafından kullanılabilmesi için bir yayımlama/abone olma mekanizması kullanmak da isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="dc5ed-134">Bu nedenle, gönderme hizmetindeki [açık/kapalı ilkesini](https://en.wikipedia.org/wiki/Open/closed_principle) izlemenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="dc5ed-135">Bu şekilde, gönderen hizmetini değiştirme gereksinimi olmadan gelecekte ek aboneler eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="dc5ed-136">Yayımla/abone ol iletişimi kullandığınızda, olayları herhangi bir aboneye yayımlamak için bir olay veri yolu arabirimi kullanıyor olabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="dc5ed-137">Zaman uyumsuz olay temelli iletişim</span><span class="sxs-lookup"><span data-stu-id="dc5ed-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="dc5ed-138">Zaman uyumsuz olay temelli iletişim kullanılırken, mikro hizmet, etki alanı içinde bir şeyler olduğunda bir tümleştirme olayı yayınlar ve bir ürün kataloğu mikro hizmetindeki fiyat değişikliği gibi başka bir mikro hizmetin bunu farkında olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="dc5ed-139">Ek mikro hizmetler, olayları zaman uyumsuz olarak alabilmesi için olaylara abone olur.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="dc5ed-140">Bu durumda alıcılar kendi etki alanı varlıklarını güncelleştirebilir ve bu da daha fazla tümleştirme olayının yayımlanmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="dc5ed-141">Bu yayımlama/abone olma sistemi genellikle bir olay veri yolunun uygulanması kullanılarak gerçekleştirilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="dc5ed-142">Olay veri yolu, bir soyutlama veya arabirim olarak tasarlanabilir ve olaylara abone olmak ya da aboneliği kaldırmak ve olayları yayımlamak için gereken API 'yi kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-142">The event bus can be designed as an abstraction or interface, with the API that's needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="dc5ed-143">Olay veri yolu, zaman uyumsuz iletişimi ve bir yayımlama/abonelik modelini destekleyen bir mesajlaşma kuyruğu ya da hizmet veri yolu gibi işlem tabanlı ve mesajlaşma aracısına dayalı bir veya daha fazla uygulama içerebilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="dc5ed-144">Bir sistem, tümleştirme olayları tarafından yönetilen nihai tutarlılığı kullanıyorsa, bu yaklaşımın son kullanıcıya tamamen açık olması önerilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-144">If a system uses eventual consistency driven by integration events, it's recommended that this approach is made completely clear to the end user.</span></span> <span data-ttu-id="dc5ed-145">Sistem, istemci tarafından SignalR veya yoklama sistemleri gibi tümleştirme olaylarını taklit eden bir yaklaşım kullanmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-145">The system shouldn't use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="dc5ed-146">Son Kullanıcı ve işletme sahibi sistemde nihai tutarlılığı açıkça benimsemek ve birçok durumda, açık olduğu sürece bu yaklaşım ile ilgili herhangi bir sorun olmadığını fark ediyor.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business doesn't have any problem with this approach, as long as it's explicit.</span></span> <span data-ttu-id="dc5ed-147">Kullanıcılar bazı sonuçları hemen görmeyi beklediği için bu önemlidir ve bu durum nihai tutarlılık ile gerçekleşmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-147">This is important because users might expect to see some results immediately and this might not happen with eventual consistency.</span></span>

<span data-ttu-id="dc5ed-148">Daha önce [Dağıtılmış veri yönetimi sorunları ve çözümleri](distributed-data-management.md) bölümünde belirtildiği gibi, birden fazla mikro hizmete yayılan iş görevlerini uygulamak için tümleştirme olaylarını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-148">As noted earlier in the [Challenges and solutions for distributed data management](distributed-data-management.md) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="dc5ed-149">Bu nedenle, bu hizmetler arasında nihai tutarlılık olacaktır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-149">Thus, you'll have eventual consistency between those services.</span></span> <span data-ttu-id="dc5ed-150">Sonuçta tutarlı bir işlem, dağıtılmış eylemler koleksiyonundan oluşur.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-150">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="dc5ed-151">Her eylemde, ilgili mikro hizmet bir etki alanı varlığını güncelleştirir ve aynı uçtan uca iş göreviyle sonraki eylemi başlatan başka bir tümleştirme olayı yayımlar.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-151">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="dc5ed-152">Önemli bir nokta, aynı olaya abone olan birden fazla mikro hizmet ile iletişim kurmak isteyebileceğiniz bir noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-152">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="dc5ed-153">Bunu yapmak için Şekil 4-19 ' de gösterildiği gibi, olay odaklı iletişime göre yayımla/abone ol iletilerini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-153">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="dc5ed-154">Bu yayımla/abone olma mekanizması mikro hizmet mimarisine özel değildir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-154">This publish/subscribe mechanism isn't exclusive to the microservice architecture.</span></span> <span data-ttu-id="dc5ed-155">Bu, DDD 'daki [sınırlı bağlamların](https://martinfowler.com/bliki/BoundedContext.html) iletişim kurması veya [komut ve sorgu sorumluluklarının ayrılığı (CQRS)](https://martinfowler.com/bliki/CQRS.html) mimari deseninin yazma veritabanındaki okuma veritabanına nasıl yayılacağından benzerdir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-155">It's similar to the way [Bounded Contexts](https://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](https://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="dc5ed-156">Amaç, dağıtılmış sisteminizde birden çok veri kaynağı arasında nihai tutarlılık sağlamaktır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-156">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![Zaman uyumsuz olay odaklı iletişimleri gösteren diyagram.](./media/asynchronous-message-based-communication/asynchronous-event-driven-communication.png)

<span data-ttu-id="dc5ed-158">**Şekil 4-19**.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-158">**Figure 4-19**.</span></span> <span data-ttu-id="dc5ed-159">Zaman uyumsuz olay odaklı ileti iletişimi</span><span class="sxs-lookup"><span data-stu-id="dc5ed-159">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="dc5ed-160">Olay temelli zaman uyumsuz iletişimde, bir mikro hizmet olayları bir olay veri yoluna yayımlar ve çok sayıda mikro hizmet, bildirim almak ve bu hizmete işlem yapmak için abone olabilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-160">In asynchronous event-driven communication, one microservice publishes events to an event bus and many microservices can subscribe to it, to get notified and act on it.</span></span> <span data-ttu-id="dc5ed-161">Uygulamanız, olay odaklı ileti tabanlı iletişimler için kullanılacak protokolü tespit eder.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-161">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="dc5ed-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) , güvenilir sıraya alınmış iletişimin sağlanmasına yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-162">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="dc5ed-163">Bir olay veri yolu kullandığınızda, [Kbbitmq](https://www.rabbitmq.com/) gibi bir ileti ARACıSıDıR API kullanarak kod içeren bir soyutlama düzeyi (bir olay veri yolu arabirimi gibi) ve [konularla birlikte Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)gibi bir hizmet veri yolu kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-163">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="dc5ed-164">Alternatif olarak, Event Bus ve Yayımla/abone ol sisteminizi ifade etmek için NServiceBus, Masstransıya ya da daha parlak gibi daha yüksek düzeyde bir Service Bus kullanmak isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-164">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="dc5ed-165">Üretim sistemleri için mesajlaşma teknolojileri hakkında bir göz</span><span class="sxs-lookup"><span data-stu-id="dc5ed-165">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="dc5ed-166">Özet olay veri yolundan uygulama için kullanılabilen mesajlaşma teknolojileri farklı düzeylerde.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-166">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="dc5ed-167">Örneğin, Kbbitmq (bir mesajlaşma Aracısı taşıması) ve Azure Service Bus daha düşük bir düzeyde, NServiceBus, Masstransıya veya daha parlaktır. Bu, Kbbitmq ve Azure Service Bus üzerinde çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-167">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="dc5ed-168">Seçiminiz, uygulama düzeyinde ve uygulamanız için ihtiyaç duyduğunuz çok sayıda zengin özellik sayısına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-168">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="dc5ed-169">Geliştirme ortamınız için yalnızca bir kavram kanıtı olay veri yolu uygulamak üzere eShopOnContainers örneğinde yapıldığı gibi, bir Docker kapsayıcısında çalışan kbbitmq üzerinde basit bir uygulama yeterince olabilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-169">For implementing just a proof-of-concept event bus for your development environment, as it was done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="dc5ed-170">Ancak, Hyper-ölçeklenebilirlik gerektiren görev açısından kritik ve üretim sistemlerinde Azure Service Bus değerlendirmek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-170">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="dc5ed-171">Dağıtılmış uygulamaların geliştirilmesine daha kolay bir şekilde sahip olan üst düzey soyutlamalar ve özellikler için NServiceBus, Masstransıya ve daha parlak gibi diğer ticari ve açık kaynaklı hizmet veri yollarını değerlendirmeniz önerilir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-171">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="dc5ed-172">Tabii ki, Kbbitmq ve Docker gibi alt düzey teknolojilerin üzerine kendi hizmet veri yolu özelliklerinizi oluşturabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-172">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="dc5ed-173">Ancak, bu sıhhi tesisat işi özel bir kurumsal uygulama için çok fazla maliyetli olabilirler.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-173">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="dc5ed-174">Dayanıklı bağlantısı olay veri yoluna yayımlama</span><span class="sxs-lookup"><span data-stu-id="dc5ed-174">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="dc5ed-175">Birden çok mikro hizmette olay odaklı bir mimari uygulamaya yönelik bir zorluk, dayanıklı bağlantısı ile ilgili tümleştirme olayını olay veri yoluna yayımlarken, işlemlere bağlı olarak, özgün mikro hizmette durumu otomatik olarak güncelleştirme.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-175">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="dc5ed-176">Aşağıda, ek yaklaşımlar da dahil olmak üzere, bunu yapmanın birkaç yolu verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-176">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

- <span data-ttu-id="dc5ed-177">MSMQ gibi bir işlem (DTC tabanlı) kuyruğu kullanma.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-177">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="dc5ed-178">(Ancak, bu eski bir yaklaşımdır.)</span><span class="sxs-lookup"><span data-stu-id="dc5ed-178">(However, this is a legacy approach.)</span></span>

- <span data-ttu-id="dc5ed-179">[İşlem günlüğü madenciliği](https://www.scoop.it/t/sql-server-transaction-log-mining)kullanılıyor.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-179">Using [transaction log mining](https://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

- <span data-ttu-id="dc5ed-180">Tam [olay](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) kaynağını belirleme düzenini kullanma.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-180">Using full [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing) pattern.</span></span>

- <span data-ttu-id="dc5ed-181">[Giden kutusu deseninin](https://www.kamilgrzybek.com/design/the-outbox-pattern/)kullanımı: bir işlem veritabanı tablosu, olayı oluşturacak ve yayınlayacak bir olay Oluşturucu bileşeni için temel olacak bir ileti kuyruğu olarak.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-181">Using the [Outbox pattern](https://www.kamilgrzybek.com/design/the-outbox-pattern/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="dc5ed-182">Zaman uyumsuz iletişimin kullanılması sırasında göz önünde bulundurmanız gereken ek konular Message Eşkuvvetlilik ve iletiyi yinelenenleri kaldırma.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-182">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="dc5ed-183">Bu konular, bu kılavuzun ilerleyen kısımlarında [mikro hizmetler (Tümleştirme olayları) arasındaki olay tabanlı Iletişimi uygulama](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) bölümünde ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="dc5ed-183">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](../multi-container-microservice-net-applications/integration-event-based-microservice-communications.md) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="dc5ed-184">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="dc5ed-184">Additional resources</span></span>

- <span data-ttu-id="dc5ed-185">**Olay odaklı mesajlaşma** </span><span class="sxs-lookup"><span data-stu-id="dc5ed-185">**Event Driven Messaging** </span></span>\
  <https://patterns.arcitura.com/soa-patterns/design_patterns/event_driven_messaging>

- <span data-ttu-id="dc5ed-186">**Yayımla/abone ol kanalı** </span><span class="sxs-lookup"><span data-stu-id="dc5ed-186">**Publish/Subscribe Channel** </span></span>\
  <https://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html>

- <span data-ttu-id="dc5ed-187">**UDI Dahan. Açıklanan CQRS** </span><span class="sxs-lookup"><span data-stu-id="dc5ed-187">**Udi Dahan. Clarified CQRS** </span></span>\
  <https://udidahan.com/2009/12/09/clarified-cqrs/>

- <span data-ttu-id="dc5ed-188">**Komut ve Sorgu Sorumluluklarının Ayrılığı (CQRS)** </span><span class="sxs-lookup"><span data-stu-id="dc5ed-188">**Command and Query Responsibility Segregation (CQRS)** </span></span>\
  <https://docs.microsoft.com/azure/architecture/patterns/cqrs>

- <span data-ttu-id="dc5ed-189">**Sınırlanmış bağlamlar arasında iletişim kurma** </span><span class="sxs-lookup"><span data-stu-id="dc5ed-189">**Communicating Between Bounded Contexts** </span></span>\
  <https://docs.microsoft.com/previous-versions/msp-n-p/jj591572(v=pandp.10)>

- <span data-ttu-id="dc5ed-190">**Nihai tutarlılık** </span><span class="sxs-lookup"><span data-stu-id="dc5ed-190">**Eventual consistency** </span></span>\
  <https://en.wikipedia.org/wiki/Eventual_consistency>

- <span data-ttu-id="dc5ed-191">**Jimmy Bogard. Esnekliği doğru yeniden düzenleme: kuponu değerlendirme** </span><span class="sxs-lookup"><span data-stu-id="dc5ed-191">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling** </span></span>\
  <https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/>

> [!div class="step-by-step"]
> <span data-ttu-id="dc5ed-192">[Önceki](communication-in-microservice-architecture.md) 
>  [Sonraki](maintain-microservice-apis.md)</span><span class="sxs-lookup"><span data-stu-id="dc5ed-192">[Previous](communication-in-microservice-architecture.md)
[Next](maintain-microservice-apis.md)</span></span>
