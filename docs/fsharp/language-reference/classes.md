---
title: Sınıflar
description: 'F # sınıflarının özelliklere, yöntemlere ve olaylara sahip olan nesneleri temsil eden türler olduğunu öğrenin.'
ms.date: 05/16/2016
ms.openlocfilehash: fd6638e0f1c08cf667a73582e19b2bb5bba46e20
ms.sourcegitcommit: 7ef96827b161ef3fcde75f79d839885632e26ef1
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 01/07/2021
ms.locfileid: "97970173"
---
# <a name="classes"></a><span data-ttu-id="9d933-103">Sınıflar</span><span class="sxs-lookup"><span data-stu-id="9d933-103">Classes</span></span>

<span data-ttu-id="9d933-104">*Sınıflar* , özelliklere, yöntemlere ve olaylara sahip olabilir nesneleri temsil eden türlerdir.</span><span class="sxs-lookup"><span data-stu-id="9d933-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>

## <a name="syntax"></a><span data-ttu-id="9d933-105">Syntax</span><span class="sxs-lookup"><span data-stu-id="9d933-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="9d933-106">Açıklamalar</span><span class="sxs-lookup"><span data-stu-id="9d933-106">Remarks</span></span>

<span data-ttu-id="9d933-107">Sınıflar .NET nesne türlerinin temel açıklamasını temsil eder; sınıfı, F # içinde nesne odaklı programlamayı destekleyen birincil tür kavramıdır.</span><span class="sxs-lookup"><span data-stu-id="9d933-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="9d933-108">Önceki sözdiziminde, `type-name` geçerli bir tanıtıcıdır.</span><span class="sxs-lookup"><span data-stu-id="9d933-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="9d933-109">`type-params`İsteğe bağlı genel tür parametrelerini açıklar.</span><span class="sxs-lookup"><span data-stu-id="9d933-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="9d933-110">Bu, açılı ayraçlar (ve) içine alınmış parametre adları ve kısıtlamalarından oluşur `<` `>` .</span><span class="sxs-lookup"><span data-stu-id="9d933-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="9d933-111">Daha fazla bilgi için bkz. [Genel türler](./generics/index.md) ve [kısıtlamalar](./generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="9d933-111">For more information, see [Generics](./generics/index.md) and [Constraints](./generics/constraints.md).</span></span> <span data-ttu-id="9d933-112">`parameter-list`Oluşturucu parametrelerini açıklar.</span><span class="sxs-lookup"><span data-stu-id="9d933-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="9d933-113">İlk erişim değiştiricisi türe aittir; İkincisi, birincil oluşturucuya aittir.</span><span class="sxs-lookup"><span data-stu-id="9d933-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="9d933-114">Her iki durumda da varsayılan olur `public` .</span><span class="sxs-lookup"><span data-stu-id="9d933-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="9d933-115">Anahtar sözcüğünü kullanarak bir sınıf için taban sınıfı belirtirsiniz `inherit` .</span><span class="sxs-lookup"><span data-stu-id="9d933-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="9d933-116">Taban sınıf oluşturucusu için parantez içinde bağımsız değişkenler sağlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9d933-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="9d933-117">Bağlamaları kullanarak sınıfa yerel olan alanları veya işlev değerlerini bildirir `let` ve bağlamaların genel kurallarını izlemeniz gerekir `let` .</span><span class="sxs-lookup"><span data-stu-id="9d933-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="9d933-118">`do-bindings`Bölüm, nesne oluşturma sırasında yürütülecek kodu içerir.</span><span class="sxs-lookup"><span data-stu-id="9d933-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="9d933-119">`member-list`Ek oluşturucular, örnek ve statik yöntem bildirimleri, arabirim bildirimleri, soyut bağlamalar ve özellik ve olay bildirimleri oluşur.</span><span class="sxs-lookup"><span data-stu-id="9d933-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="9d933-120">Bunlar [Üyelerde](./members/index.md)açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="9d933-120">These are described in [Members](./members/index.md).</span></span>

<span data-ttu-id="9d933-121">`identifier`İsteğe bağlı anahtar sözcüğü ile birlikte kullanılan, `as` örnek değişkenine veya türün örneğine başvurmak için tür tanımında kullanılabilecek bir ad verir.</span><span class="sxs-lookup"><span data-stu-id="9d933-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="9d933-122">Daha fazla bilgi için, bu konunun ilerleyen kısımlarında yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="9d933-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="9d933-123">`class` `end` Tanımın başlangıcını ve bitişini işaretleyen anahtar sözcükler ve isteğe bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="9d933-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="9d933-124">Birbirini gösteren türler olan birbirini dışlayan özyinelemeli türler, `and` tıpkı karşılıklı özyinelemeli işlevlerin olduğu gibi anahtar sözcükle birlikte birleştirilir.</span><span class="sxs-lookup"><span data-stu-id="9d933-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="9d933-125">Bir örnek için, birbirini dışlayan özyinelemeli türler bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="9d933-125">For an example, see the section Mutually Recursive Types.</span></span>

## <a name="constructors"></a><span data-ttu-id="9d933-126">Oluşturucular</span><span class="sxs-lookup"><span data-stu-id="9d933-126">Constructors</span></span>

<span data-ttu-id="9d933-127">Oluşturucu, sınıf türünün bir örneğini oluşturan koddur.</span><span class="sxs-lookup"><span data-stu-id="9d933-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="9d933-128">Sınıfların oluşturucuları, F # ' ta diğer .NET dillerinde olduklarından farklı şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="9d933-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="9d933-129">Bir F # sınıfında, bağımsız değişkenleri `parameter-list` tür adını izleyen ' de açıklanan ve gövdesi `let` `let rec` sınıf bildiriminin başlangıcında ve izleyen bağlamalardan oluşan (ve) bağlamalardan oluşan bir birincil Oluşturucu vardır `do` .</span><span class="sxs-lookup"><span data-stu-id="9d933-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="9d933-130">Birincil oluşturucunun bağımsız değişkenleri, sınıf bildiriminin tamamında kapsamdadır.</span><span class="sxs-lookup"><span data-stu-id="9d933-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="9d933-131">`new`Aşağıdaki gibi bir üye eklemek için anahtar sözcüğünü kullanarak ek oluşturucular ekleyebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="9d933-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="9d933-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="9d933-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="9d933-133">Yeni oluşturucunun gövdesi, sınıf bildiriminin en üstünde belirtilen birincil oluşturucuyu çağırmalıdır.</span><span class="sxs-lookup"><span data-stu-id="9d933-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="9d933-134">Aşağıdaki örnekte bu kavram gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="9d933-134">The following example illustrates this concept.</span></span> <span data-ttu-id="9d933-135">Aşağıdaki kodda, iki `MyClass` bağımsız değişken alan bir birincil Oluşturucu ve bağımsız değişken içermeyen başka bir Oluşturucu olan iki Oluşturucu vardır.</span><span class="sxs-lookup"><span data-stu-id="9d933-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]

## <a name="let-and-do-bindings"></a><span data-ttu-id="9d933-136">Let ve do bağlamaları</span><span class="sxs-lookup"><span data-stu-id="9d933-136">let and do Bindings</span></span>

<span data-ttu-id="9d933-137">`let` `do` Bir sınıf tanımındaki ve bağlamaları, birincil sınıf oluşturucusunun gövdesini oluşturur ve bu nedenle her bir sınıf örneği oluşturulduğunda çalışır.</span><span class="sxs-lookup"><span data-stu-id="9d933-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="9d933-138">`let`Bağlama bir işlev ise, bir üyeye derlenir.</span><span class="sxs-lookup"><span data-stu-id="9d933-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="9d933-139">`let`Bağlama herhangi bir işlevde veya üyede kullanılmayan bir değer ise, oluşturucunun yerel bir değişkenine derlenir.</span><span class="sxs-lookup"><span data-stu-id="9d933-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="9d933-140">Aksi halde, sınıfının bir alanına derlenir.</span><span class="sxs-lookup"><span data-stu-id="9d933-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="9d933-141">`do`Aşağıdaki ifadeler birincil oluşturucuya derlenir ve her örnek için başlatma kodunu yürütür.</span><span class="sxs-lookup"><span data-stu-id="9d933-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="9d933-142">Herhangi bir ek Oluşturucu her zaman birincil oluşturucuyu çağırdığından, `let` bağlamalar ve `do` bağlamalar hangi oluşturucunun çağrıldığına bakılmaksızın her zaman yürütülür.</span><span class="sxs-lookup"><span data-stu-id="9d933-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="9d933-143">`let`Bağlamalarla oluşturulan alanlara sınıfının yöntemleri ve özellikleri boyunca erişilebilir; ancak, statik yöntemler parametre olarak bir örnek değişkeni alsa bile, bunlara statik metotlardan erişilemez.</span><span class="sxs-lookup"><span data-stu-id="9d933-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="9d933-144">Bir varsa, kendi kendine tanımlayıcı kullanılarak erişilemez.</span><span class="sxs-lookup"><span data-stu-id="9d933-144">They cannot be accessed by using the self identifier, if one exists.</span></span>

## <a name="self-identifiers"></a><span data-ttu-id="9d933-145">Kendi kendine tanımlayıcılar</span><span class="sxs-lookup"><span data-stu-id="9d933-145">Self Identifiers</span></span>

<span data-ttu-id="9d933-146">*Kendi kendine tanımlayıcı* , geçerli örneği temsil eden bir addır.</span><span class="sxs-lookup"><span data-stu-id="9d933-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="9d933-147">Kendi tanımlayıcıları, `this` C# veya C++ veya Visual Basic içindeki anahtar sözcüğe benzer `Me` .</span><span class="sxs-lookup"><span data-stu-id="9d933-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="9d933-148">Kendi sınıf tanımının veya yalnızca tek bir yöntemin kapsamında olmasını isteyip istemediğinize bağlı olarak, kendinden tanımlayıcıyı iki farklı şekilde tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9d933-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="9d933-149">Tüm sınıf için kendi kendine tanımlayıcı tanımlamak için, `as` Oluşturucu parametre listesinin kapatma parantezinden sonra anahtar sözcüğünü kullanın ve tanımlayıcı adını belirtin.</span><span class="sxs-lookup"><span data-stu-id="9d933-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="9d933-150">Yalnızca bir yöntem için kendi kendine tanımlayıcı tanımlamak üzere, üye bildiriminde, yöntem adından ve bir nokta (.) ayırıcı olarak kendi kendine tanımlayıcıyı sağlayın.</span><span class="sxs-lookup"><span data-stu-id="9d933-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="9d933-151">Aşağıdaki kod örneği, kendi kendine tanımlayıcı oluşturmanın iki yolunu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="9d933-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="9d933-152">İlk satırda, `as` anahtar sözcüğü kendi tanımlayıcısını tanımlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9d933-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="9d933-153">Beşinci satırda, `this` kapsamı yöntemiyle kısıtlanmış bir kendi tanımlayıcısını tanımlamak için tanımlayıcı kullanılır `PrintMessage` .</span><span class="sxs-lookup"><span data-stu-id="9d933-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="9d933-154">Diğer .NET dillerinin aksine, kendi tanımlayıcısını istediğiniz şekilde adlandırın; , veya gibi adlarla sınırlı değilsiniz `self` `Me` `this` .</span><span class="sxs-lookup"><span data-stu-id="9d933-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="9d933-155">Anahtar sözcüğüyle belirtilen kendine tanımlayıcı, `as` temel oluşturucudan sonra başlatılmaz.</span><span class="sxs-lookup"><span data-stu-id="9d933-155">The self identifier that is declared with the `as` keyword is not initialized until after the base constructor.</span></span> <span data-ttu-id="9d933-156">Bu nedenle, temel oluşturucunun öncesinde veya içinde kullanıldığında, `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` çalışma zamanı sırasında tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="9d933-156">Therefore, when used before or inside the base constructor, `System.InvalidOperationException: The initialization of an object or value resulted in an object or value being accessed recursively before it was fully initialized.` will be raised during runtime.</span></span> <span data-ttu-id="9d933-157">Kendi kendine tanımlayıcıyı, bağlama veya bağlamalar gibi temel oluşturucudan sonra ücretsiz olarak kullanabilirsiniz `let` `do` .</span><span class="sxs-lookup"><span data-stu-id="9d933-157">You can use the self identifier freely after the base constructor, such as in `let` bindings or `do` bindings.</span></span>

## <a name="generic-type-parameters"></a><span data-ttu-id="9d933-158">Genel Tür Parametreleri</span><span class="sxs-lookup"><span data-stu-id="9d933-158">Generic Type Parameters</span></span>

<span data-ttu-id="9d933-159">Genel tür parametreleri `<` `>` , tek tırnak işareti ve ardından bir tanımlayıcı tarafından izlenen köşeli ayraç (ve) biçiminde belirtilir.</span><span class="sxs-lookup"><span data-stu-id="9d933-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="9d933-160">Birden çok genel tür parametresi virgülle ayrılır.</span><span class="sxs-lookup"><span data-stu-id="9d933-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="9d933-161">Genel tür parametresi, bildirim genelinde kapsamdadır.</span><span class="sxs-lookup"><span data-stu-id="9d933-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="9d933-162">Aşağıdaki kod örneği, genel tür parametrelerinin nasıl ekleneceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="9d933-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="9d933-163">Tür bağımsız değişkenleri tür kullanıldığında algılanır.</span><span class="sxs-lookup"><span data-stu-id="9d933-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="9d933-164">Aşağıdaki kodda, gösterilen tür bir tanımlama grubu dizisidir.</span><span class="sxs-lookup"><span data-stu-id="9d933-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]

## <a name="specifying-inheritance"></a><span data-ttu-id="9d933-165">Devralmayı belirtme</span><span class="sxs-lookup"><span data-stu-id="9d933-165">Specifying Inheritance</span></span>

<span data-ttu-id="9d933-166">`inherit`Yan tümcesi, varsa doğrudan temel sınıfı tanımlar.</span><span class="sxs-lookup"><span data-stu-id="9d933-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="9d933-167">F # içinde yalnızca bir doğrudan taban sınıfa izin verilir.</span><span class="sxs-lookup"><span data-stu-id="9d933-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="9d933-168">Bir sınıfın uyguladığı arabirimler temel sınıflar olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="9d933-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="9d933-169">Arabirimler, [arabirimler](Interfaces.md) konusunda ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="9d933-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="9d933-170">Dil anahtar sözcüğünü `base` tanımlayıcı olarak ve ardından bir nokta (.) ve üyenin adını kullanarak türetilmiş sınıftan temel sınıfın yöntemlerine ve özelliklerine erişebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9d933-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="9d933-171">Daha fazla bilgi için bkz. [Devralma](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="9d933-171">For more information, see [Inheritance](inheritance.md).</span></span>

## <a name="members-section"></a><span data-ttu-id="9d933-172">Üyeler bölümü</span><span class="sxs-lookup"><span data-stu-id="9d933-172">Members Section</span></span>

<span data-ttu-id="9d933-173">Bu bölümde statik veya örnek yöntemleri, özellikleri, arabirim uygulamalarını, soyut üyeleri, olay bildirimlerini ve ek oluşturucuları tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9d933-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="9d933-174">Let ve do bağlamaları bu bölümde görünemez.</span><span class="sxs-lookup"><span data-stu-id="9d933-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="9d933-175">Üyeler sınıflara ek olarak çeşitli F # türlerine eklenebildiğinden, bunlar ayrı bir konuda, [üyelerinde](./members/index.md)ele alınmıştır.</span><span class="sxs-lookup"><span data-stu-id="9d933-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](./members/index.md).</span></span>

## <a name="mutually-recursive-types"></a><span data-ttu-id="9d933-176">Birbirini dışlayan özyinelemeli türler</span><span class="sxs-lookup"><span data-stu-id="9d933-176">Mutually Recursive Types</span></span>

<span data-ttu-id="9d933-177">Birbirini dairesel bir şekilde birbirlerine başvuran türler tanımladığınızda, anahtar sözcüğünü kullanarak tür tanımlarını birlikte dizolursunuz `and` .</span><span class="sxs-lookup"><span data-stu-id="9d933-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="9d933-178">`and`Anahtar sözcüğü, `type` aşağıdaki gibi, ilk tanım hariç tüm anahtar kelimesinin yerini alır.</span><span class="sxs-lookup"><span data-stu-id="9d933-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](~/samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="9d933-179">Çıktı, geçerli dizindeki tüm dosyaların bir listesidir.</span><span class="sxs-lookup"><span data-stu-id="9d933-179">The output is a list of all the files in the current directory.</span></span>

## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="9d933-180">Sınıfların, birleşimlerin, kayıtların ve yapıların ne zaman kullanılacağı</span><span class="sxs-lookup"><span data-stu-id="9d933-180">When to Use Classes, Unions, Records, and Structures</span></span>

<span data-ttu-id="9d933-181">Aralarından seçim yapabileceğiniz çeşitli türler verildiğinde, belirli bir durum için uygun türü seçmek üzere her bir türün ne şekilde tasarlandığına ilişkin iyi bir fikir sahibi olmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9d933-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="9d933-182">Sınıflar, nesne odaklı programlama bağlamlarında kullanılmak üzere tasarlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="9d933-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="9d933-183">Nesne odaklı programlama, .NET Framework için yazılan uygulamalarda kullanılan baskın paradigma.</span><span class="sxs-lookup"><span data-stu-id="9d933-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="9d933-184">F # kodunuzun .NET Framework veya başka bir nesne tabanlı kitaplıkla yakından çalışması gerekiyorsa ve özellikle de bir UI kitaplığı gibi nesne yönelimli bir tür sisteminden genişletmeniz gerekiyorsa, sınıflar muhtemelen uygun olabilir.</span><span class="sxs-lookup"><span data-stu-id="9d933-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="9d933-185">Nesne odaklı kodla yakından birlikte bulundurduysanız veya kendi içinde bulunan ve bu nedenle nesne odaklı kod ile sık etkileşim 'ten korunan bir kod yazıyorsanız, kayıtları ve ayırt edici birleşimleri kullanmayı göz önünde bulundurmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="9d933-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="9d933-186">Uygun düzende eşleşen kod ile birlikte, tek ve iyi düşünce bir ayrılmış birleşim, genellikle bir nesne hiyerarşisinin daha basit bir alternatifi olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="9d933-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="9d933-187">Ayrılmış birleşimler hakkında daha fazla bilgi için bkz. [ayırt edici birleşimler](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="9d933-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="9d933-188">Kayıtlar, sınıflardan daha basit olmasının avantajına sahiptir, ancak bir tür talepleri basitlikle neler yapılabileceğini aşarsa kayıtlar uygun değildir.</span><span class="sxs-lookup"><span data-stu-id="9d933-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="9d933-189">Kayıtlar, gizli alanlar olmadan ve devralma ya da arabirim uygulamaları olmadan özel eylemler gerçekleştirebilen ayrı oluşturucular olmadan, temelde basit değer toplalarıdır.</span><span class="sxs-lookup"><span data-stu-id="9d933-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="9d933-190">Özellikleri ve yöntemleri gibi Üyeler davranışlarını daha karmaşık hale getirmek için kayıtlara eklenebilse de, bir kayıtta depolanan alanlar yine de basit değerler toplamasıdır.</span><span class="sxs-lookup"><span data-stu-id="9d933-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="9d933-191">Kayıtlar hakkında daha fazla bilgi için bkz. [kayıtlar](records.md).</span><span class="sxs-lookup"><span data-stu-id="9d933-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="9d933-192">Yapıları, küçük veri toplamaları için de kullanışlıdır, ancak .NET değer türleri oldukları sınıfların ve kayıtlardan farklıdır.</span><span class="sxs-lookup"><span data-stu-id="9d933-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="9d933-193">Sınıflar ve kayıtlar .NET başvuru türleridir.</span><span class="sxs-lookup"><span data-stu-id="9d933-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="9d933-194">Değer türleri ve başvuru türleri semantiği değer tarafından geçirilir.</span><span class="sxs-lookup"><span data-stu-id="9d933-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="9d933-195">Bu, bir parametre olarak geçirildiği veya bir işlevden döndürüldüğü zaman bit için bit olarak kopyalandığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="9d933-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="9d933-196">Ayrıca, yığın üzerinde saklanır veya bir alan olarak kullanılıyorsa, yığın üzerinde kendi ayrı konumlarına depolanması yerine üst nesnenin içine gömülü olurlar.</span><span class="sxs-lookup"><span data-stu-id="9d933-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="9d933-197">Bu nedenle, yığına erişim ek yükü bir sorun olduğunda yapılar sık erişilen veriler için uygundur.</span><span class="sxs-lookup"><span data-stu-id="9d933-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="9d933-198">Yapılar hakkında daha fazla bilgi için bkz. [yapılar](structures.md).</span><span class="sxs-lookup"><span data-stu-id="9d933-198">For more information about structures, see [Structures](structures.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="9d933-199">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="9d933-199">See also</span></span>

- [<span data-ttu-id="9d933-200">F # dil başvurusu</span><span class="sxs-lookup"><span data-stu-id="9d933-200">F# Language Reference</span></span>](index.md)
- [<span data-ttu-id="9d933-201">Üyeler</span><span class="sxs-lookup"><span data-stu-id="9d933-201">Members</span></span>](./members/index.md)
- [<span data-ttu-id="9d933-202">Devralma</span><span class="sxs-lookup"><span data-stu-id="9d933-202">Inheritance</span></span>](inheritance.md)
- [<span data-ttu-id="9d933-203">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="9d933-203">Interfaces</span></span>](interfaces.md)
