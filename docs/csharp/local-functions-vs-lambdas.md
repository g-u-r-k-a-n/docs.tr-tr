---
title: Yerel işlevler ve lambda ifadeleri karşılaştırması
description: Yerel işlevlerin neden lambda ifadelerinden daha iyi bir seçim olabileceğini öğrenin.
ms.date: 06/27/2016
ms.technology: csharp-advanced-concepts
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: a644b6868a37b3d6231a514dc37030cae062785a
ms.sourcegitcommit: ad800f019ac976cb669e635fb0ea49db740e6890
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/29/2019
ms.locfileid: "73038807"
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="f70dc-103">Yerel işlevler lambda ifadeleriyle karşılaştırılır</span><span class="sxs-lookup"><span data-stu-id="f70dc-103">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="f70dc-104">İlk bakışta, [yerel işlevler](programming-guide/classes-and-structs/local-functions.md) ve [lambda ifadeleri](./programming-guide/statements-expressions-operators/lambda-expressions.md) çok benzerdir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-104">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](./programming-guide/statements-expressions-operators/lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="f70dc-105">Birçok durumda, lambda ifadeleri ve yerel işlevler kullanma arasında seçim stili ve kişisel tercihlerden bağımsız olur.</span><span class="sxs-lookup"><span data-stu-id="f70dc-105">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="f70dc-106">Ancak, dikkat etmeniz gereken bir veya diğerini kullanabileceğiniz gerçek farklılıklar vardır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-106">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="f70dc-107">Bu, yerel işlev ve çarpınımı algoritmasının lambda ifadesi uygulamaları arasındaki farkları inceleyelim.</span><span class="sxs-lookup"><span data-stu-id="f70dc-107">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="f70dc-108">Yerel bir işlev kullanan ilk sürüm:</span><span class="sxs-lookup"><span data-stu-id="f70dc-108">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="f70dc-109">Bu uygulamayı lambda ifadeleri kullanan bir sürümle karşıtlık:</span><span class="sxs-lookup"><span data-stu-id="f70dc-109">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="f70dc-110">Yerel işlevlerin adları vardır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-110">The local functions have names.</span></span> <span data-ttu-id="f70dc-111">Lambda ifadeleri `Func` veya `Action` türler olan değişkenlere atanan anonim yöntemlerdir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-111">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="f70dc-112">Yerel bir işlev bildirdiğinizde, bağımsız değişken türleri ve dönüş türü, işlev bildiriminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-112">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="f70dc-113">Lambda ifadesinin gövdesi bir parçası olmak yerine, bağımsız değişken türleri ve dönüş türü, lambda ifadesinin değişken türü bildiriminin bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-113">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="f70dc-114">Bu iki fark kodun daha net bir şekilde oluşmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-114">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="f70dc-115">Yerel işlevler, lambda ifadelerinden kesin atama için farklı kurallara sahiptir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-115">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="f70dc-116">Bir yerel işlev bildirimine, kapsamdaki herhangi bir kod konumundan başvurulabilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-116">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="f70dc-117">Bir lambda ifadesi, erişilebilmesi için bir temsilci değişkenine atanmalıdır (veya lambda ifadesine başvuran temsilci aracılığıyla çağrılabilir.) Lambda ifadesini kullanan sürümün lambda ifadesini bildirmelidir ve başlatması gerektiğini, `nthFactorial` tanımlamadan önce dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="f70dc-117">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delegate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="f70dc-118">Bu nedenle, atamadan önce `nthFactorial` başvurmak için derleme zamanı hatasına neden olur.</span><span class="sxs-lookup"><span data-stu-id="f70dc-118">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="f70dc-119">Bu farklılıklar özyinelemeli algoritmaların yerel işlevler kullanılarak oluşturulması daha kolay hale gelir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-119">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="f70dc-120">Kendisini çağıran bir yerel işlev tanımlayabilir ve tanımlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="f70dc-120">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="f70dc-121">Lambda ifadeleri, aynı lambda ifadesine başvuran bir gövdeye yeniden atanabilmeleri için bildirilmelidir ve varsayılan bir değer atanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-121">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="f70dc-122">Belirli atama kuralları, yerel işlev veya lambda ifadesi tarafından yakalanan tüm değişkenleri de etkiler.</span><span class="sxs-lookup"><span data-stu-id="f70dc-122">Definite assignment rules also affect any variables that are captured by the local function or lambda expression.</span></span> <span data-ttu-id="f70dc-123">Yerel işlev veya lambda ifadesi bir temsilciye dönüştürüldüğünde, her iki yerel işlev ve lambda ifadesi kuralı, yakalanan değişkenlerin herhangi bir noktaya kesinlikle atandığını talep edilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-123">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="f70dc-124">Fark, lambda ifadelerinin bildirildiği zaman temsilcilere dönüştürülmesidir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-124">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="f70dc-125">Yerel işlevler yalnızca temsilci olarak kullanıldığında temsilcilere dönüştürülür.</span><span class="sxs-lookup"><span data-stu-id="f70dc-125">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="f70dc-126">Yerel bir işlev bildirirseniz ve yalnızca bir yöntem gibi çağırarak buna başvurmanız durumunda, bir temsilciye dönüştürülmez.</span><span class="sxs-lookup"><span data-stu-id="f70dc-126">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="f70dc-127">Bu kural, kapsayan kapsamındaki herhangi bir uygun konumda yerel bir işlev bildirmenize olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="f70dc-127">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="f70dc-128">Herhangi bir dönüş deyiminden sonra, üst yöntemin sonunda yerel işlevleri bildirmek yaygın bir yöntemdir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-128">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="f70dc-129">Üçüncü olarak derleyici, yerel işlevlerin kapsayan kapsamda kesin olarak yakalanan değişkenleri atamasını sağlayan statik analiz gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-129">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="f70dc-130">Şu örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f70dc-130">Consider this example:</span></span>

```csharp
int M()
{
    int y;
    LocalFunction();
    return y;

    void LocalFunction() => y = 0;
}
```

<span data-ttu-id="f70dc-131">Derleyici, çağrıldığında `LocalFunction` kesinlikle `y` atayıp atamayacağını tespit edebilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-131">The compiler can determine that `LocalFunction` definitely assigns `y` when called.</span></span> <span data-ttu-id="f70dc-132">`LocalFunction` `return` deyimden önce çağrıldığından `y`, `return` bildiriminde kesin olarak atanır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-132">Because `LocalFunction` is called before the `return` statement, `y` is definitely assigned at the `return` statement.</span></span>

<span data-ttu-id="f70dc-133">Örnek analizine izin veren analiz, dördüncü farkı mümkün kıdır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-133">The analysis that enables the example analysis enables the fourth difference.</span></span>
<span data-ttu-id="f70dc-134">Yerel işlevler, kullanım amaçlarına bağlı olarak, lambda ifadeleri için her zaman gerekli olan yığın ayırmalara engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-134">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="f70dc-135">Yerel bir işlev hiçbir şekilde temsilciye dönüştürülürse ve yerel işlev tarafından yakalanan değişkenlerden hiçbiri, başka Lambdalar veya temsilcilere dönüştürülen yerel işlevler tarafından yakalanmazsa, derleyici yığın ayırmalara engel olabilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-135">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="f70dc-136">Bu zaman uyumsuz örneği göz önünde bulundurun:</span><span class="sxs-lookup"><span data-stu-id="f70dc-136">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="f70dc-137">Bu lambda ifadesinin kapanışı `address`, `index` ve `name` değişkenlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-137">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="f70dc-138">Yerel işlevler söz konusu olduğunda, kapanışı uygulayan nesne `struct` bir tür olabilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-138">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="f70dc-139">Bu yapı türü yerel işleve başvuruya göre geçirilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-139">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="f70dc-140">Uygulamadaki bu fark bir ayırmaya kaydedilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-140">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="f70dc-141">Lambda ifadeleri için gereken örnek oluşturma, zaman açısından kritik kod yollarındaki bir performans faktörü olabilecek fazladan bellek ayırmaları anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-141">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="f70dc-142">Yerel işlevler bu ek yüke neden olmaz.</span><span class="sxs-lookup"><span data-stu-id="f70dc-142">Local functions do not incur this overhead.</span></span> <span data-ttu-id="f70dc-143">Yukarıdaki örnekte, yerel işlevlerin sürümünde lambda ifadesi sürümünden daha az sayıda ayırma bulunur.</span><span class="sxs-lookup"><span data-stu-id="f70dc-143">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="f70dc-144">Bu yöntemin yerel işlev eşdeğeri, kapanış için bir sınıf de kullanır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-144">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="f70dc-145">Yerel işleve yönelik kapanışın `class` olarak uygulanıp uygulanmadığı veya bir `struct` uygulama ayrıntısı olup olmadığı.</span><span class="sxs-lookup"><span data-stu-id="f70dc-145">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="f70dc-146">Bir lambda, her zaman bir `class`kullanacak şekilde, yerel bir işlev `struct` kullanabilir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-146">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#TaskExample "Task returning method with local function")]

<span data-ttu-id="f70dc-147">Bu örnekte gösterilmeyen bir son avantaj, yerel işlevlerin yineleyiciler olarak uygulanabilmesinin yanı sıra bir değer dizisi oluşturmak için `yield return` sözdizimini kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="f70dc-147">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="f70dc-148">Lambda ifadelerinde `yield return` ifadeye izin verilmez.</span><span class="sxs-lookup"><span data-stu-id="f70dc-148">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="f70dc-149">Yerel işlevler Lambda ifadelerinde gereksiz gibi görünse de, bu işlemler aslında farklı amaçlara hizmet eder ve farklı kullanımlar sağlar.</span><span class="sxs-lookup"><span data-stu-id="f70dc-149">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="f70dc-150">Yalnızca başka bir yöntemin bağlamından çağrılan bir işlev yazmak istediğinizde yerel işlevler bu durum için daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="f70dc-150">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
