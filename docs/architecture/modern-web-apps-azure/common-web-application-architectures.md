---
title: Ortak web uygulaması mimarileri
description: ASP.NET Core ve Azure ile Mimar Modern Web Uygulamaları | Ortak web uygulama mimarilerini keşfedin
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: 7ec0d9cece40ba8a99e8ab5e028f7ac491ed6f4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "77450198"
---
# <a name="common-web-application-architectures"></a><span data-ttu-id="6b155-103">Ortak web uygulaması mimarileri</span><span class="sxs-lookup"><span data-stu-id="6b155-103">Common web application architectures</span></span>

> <span data-ttu-id="6b155-104">"İyi mimarinin pahalı olduğunu düşünüyorsanız, kötü mimariyi deneyin."</span><span class="sxs-lookup"><span data-stu-id="6b155-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="6b155-105">_- Brian Foote ve Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="6b155-105">_- Brian Foote and Joseph Yoder_</span></span>

<span data-ttu-id="6b155-106">Geleneksel .NET uygulamalarının çoğu, tek bir IIS appetki alanında çalışan yürütülebilir veya tek bir web uygulamasına karşılık gelen tek birimler olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-106">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="6b155-107">Bu en basit dağıtım modelidir ve birçok iç ve küçük genel uygulamalara çok iyi hizmet vermektedir.</span><span class="sxs-lookup"><span data-stu-id="6b155-107">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="6b155-108">Ancak, bu tek dağıtım birimi göz önüne alındığında bile, önemsiz olmayan iş uygulamalarının çoğu birkaç katmana bazı mantıksal ayırmadan yararlanır.</span><span class="sxs-lookup"><span data-stu-id="6b155-108">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="6b155-109">Yekpare uygulama nedir?</span><span class="sxs-lookup"><span data-stu-id="6b155-109">What is a monolithic application?</span></span>

<span data-ttu-id="6b155-110">Yekpare bir uygulama, davranışı açısından tamamen kendi kendine yeten bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="6b155-110">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="6b155-111">İşlemlerini gerçekleştirirken diğer hizmetler veya veri depolarıyla etkileşimkurabilir, ancak davranışının özü kendi işlemi içinde çalışır ve uygulamanın tamamı genellikle tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-111">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="6b155-112">Böyle bir uygulamanın yatay olarak ölçeklendirmesi gerekiyorsa, genellikle uygulamanın tamamı birden çok sunucu veya sanal makineler arasında çoğaltılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-112">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="6b155-113">Hepsi bir e-bir uygulamalar</span><span class="sxs-lookup"><span data-stu-id="6b155-113">All-in-one applications</span></span>

<span data-ttu-id="6b155-114">Bir uygulama mimarisi için mümkün olan en küçük proje sayısı biridir.</span><span class="sxs-lookup"><span data-stu-id="6b155-114">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="6b155-115">Bu mimaride, uygulamanın tüm mantığı tek bir projede bulunur, tek bir derlemeye derlenir ve tek bir birim olarak dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-115">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="6b155-116">Visual Studio'da veya komut satırından oluşturulan yeni bir ASP.NET Core projesi, basit bir "hepsi bir arada" monolit olarak başlar.</span><span class="sxs-lookup"><span data-stu-id="6b155-116">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="6b155-117">Sunu, iş ve veri erişim mantığı da dahil olmak üzere uygulamanın tüm davranışını içerir.</span><span class="sxs-lookup"><span data-stu-id="6b155-117">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="6b155-118">Şekil 5-1 tek projeli bir uygulamanın dosya yapısını gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-118">Figure 5-1 shows the file structure of a single-project app.</span></span>

![Core uygulaması ASP.NET tek bir proje](./media/image5-1.png)

<span data-ttu-id="6b155-120">**Şekil 5-1.**</span><span class="sxs-lookup"><span data-stu-id="6b155-120">**Figure 5-1.**</span></span> <span data-ttu-id="6b155-121">Core uygulaması ASP.NET tek bir proje.</span><span class="sxs-lookup"><span data-stu-id="6b155-121">A single project ASP.NET Core app.</span></span>

<span data-ttu-id="6b155-122">Tek bir proje senaryosunda, klasörler aracılığıyla giderme sağlanır.</span><span class="sxs-lookup"><span data-stu-id="6b155-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="6b155-123">Varsayılan şablon, Modeller, Görünümler ve Denetleyicilerin MVC desen sorumlulukları için ayrı klasörlerin yanı sıra Veri ve Hizmetler için ek klasörler içerir.</span><span class="sxs-lookup"><span data-stu-id="6b155-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="6b155-124">Bu düzenlemede, sunu ayrıntıları Görünümler klasörüne mümkün olduğunca sınırlandırılmalı ve veri erişimi uygulama ayrıntıları Veri klasöründe tutulan sınıflar ile sınırlandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="6b155-125">İş mantığı, Modeller klasöründeki hizmetlerde ve sınıflarda yer almalıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="6b155-126">Basit olmasına rağmen, tek projeye sahip monolitik çözümün bazı dezavantajları vardır.</span><span class="sxs-lookup"><span data-stu-id="6b155-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="6b155-127">Projenin boyutu ve karmaşıklığı arttıkça, dosya ve klasör sayısı da artmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="6b155-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="6b155-128">Kullanıcı arabirimi (UI) endişeleri (modeller, görünümler, denetleyiciler) alfabetik olarak gruplandırılmadı birden çok klasörde bulunur.</span><span class="sxs-lookup"><span data-stu-id="6b155-128">User interface (UI) concerns (models, views, controllers) reside in multiple folders, which aren't grouped together alphabetically.</span></span> <span data-ttu-id="6b155-129">Bu sorun, filtreler veya ModelBinders gibi ek UI düzeyi yapıları kendi klasörlerine eklendiğinde daha da kötüleşir.</span><span class="sxs-lookup"><span data-stu-id="6b155-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="6b155-130">İş mantığı Modeller ve Hizmetler klasörleri arasında dağılmış durumda dır ve hangi klasörlerin hangi sınıflarda kime bağlı olması gerektiğine dair net bir belirti yoktur.</span><span class="sxs-lookup"><span data-stu-id="6b155-130">Business logic is scattered between the Models and Services folders, and there's no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="6b155-131">Proje düzeyinde organizasyon bu eksikliği sık sık [spagetti koduna](https://deviq.com/spaghetti-code/)yol açar.</span><span class="sxs-lookup"><span data-stu-id="6b155-131">This lack of organization at the project level frequently leads to [spaghetti code](https://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="6b155-132">Bu sorunları gidermek için, uygulamalar genellikle her projenin uygulamanın belirli bir _katmanında_ bulunduğu düşünülen çok projeli çözümlere dönüşür.</span><span class="sxs-lookup"><span data-stu-id="6b155-132">To address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular _layer_ of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="6b155-133">Mantıksal katman nedir?</span><span class="sxs-lookup"><span data-stu-id="6b155-133">What are layers?</span></span>

<span data-ttu-id="6b155-134">Uygulamalar karmaşıklık içinde büyüdükçe, bu karmaşıklığı yönetmenin bir yolu, uygulamanın sorumluluklarını veya endişelerine göre parçalamaktır.</span><span class="sxs-lookup"><span data-stu-id="6b155-134">As applications grow in complexity, one way to manage that complexity is to break up the application according to its responsibilities or concerns.</span></span> <span data-ttu-id="6b155-135">Bu, endişelerin ayrılması ilkesini izler ve geliştiricilerin belirli işlevlerin uygulandığı yeri kolayca bulabilmeleri için büyüyen bir kod tabanının düzenli tutulmasına yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-135">This follows the separation of concerns principle and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="6b155-136">Katmanlı mimari olsa da, sadece kod organizasyonu ötesinde bir dizi avantaj sunar.</span><span class="sxs-lookup"><span data-stu-id="6b155-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="6b155-137">Kodu katmanlar halinde düzenleyerek, ortak alt düzey işlevsellik uygulama boyunca yeniden kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="6b155-138">Bu yeniden kullanım yararlıdır, çünkü daha az kod yazılması gerektiği anlamına gelir ve uygulamanın [kendinizi tekrarlama (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) ilkesini takiben tek bir uygulamada standartlaşmasına izin verebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the [don't repeat yourself (DRY)](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.</span></span>

<span data-ttu-id="6b155-139">Katmanlı bir mimariyle, uygulamalar katmanların diğer katmanlarla iletişim kurabileceği kısıtlamaları zorlayabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="6b155-140">Bu kapsülleme elde etmek için yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="6b155-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="6b155-141">Bir katman değiştirildiğinde veya değiştirildiğinde, yalnızca onunla çalışan katmanlar etkilenmelidir.</span><span class="sxs-lookup"><span data-stu-id="6b155-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="6b155-142">Hangi katmanların diğer katmanlara bağlı olduğunu sınırlayarak, tek bir değişikliğin tüm uygulamayı etkilememesi için değişikliklerin etkisi azaltılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="6b155-143">Katmanlar (ve kapsülleme) uygulama içindeki işlevselliği değiştirmeyi çok daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="6b155-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="6b155-144">Örneğin, bir uygulama başlangıçta kalıcılık için kendi SQL Server veritabanını kullanabilir, ancak daha sonra bulut tabanlı kalıcılık stratejisini veya bir web API'sinin arkasındakini kullanmayı seçebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="6b155-145">Uygulama kalıcılık uygulamasını mantıksal bir katman içinde düzgün bir şekilde kapsüllemişse, sql server özel katmanı aynı ortak arabirimi uygulayan yeni bir katmanla değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="6b155-146">Gereksinimleri gelecekteki değişikliklere yanıt olarak uygulamaları takas potansiyeline ek olarak, uygulama katmanları da daha kolay test amacıyla uygulamaları takas yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="6b155-147">Uygulamanın gerçek veri katmanına veya Kullanıcı Arabirimi katmanına karşı çalışan testler yazmak yerine, bu katmanlar test zamanında isteklere bilinen yanıtları sağlayan sahte uygulamalarla değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="6b155-148">Bu genellikle, uygulamanın gerçek altyapısına karşı testleri çalıştırmayla karşılaştırıldığında, testlerin yazılması çok daha kolay ve çalıştırılması çok daha hızlı hale getirir.</span><span class="sxs-lookup"><span data-stu-id="6b155-148">This typically makes tests much easier to write and much faster to run when compared to running tests against the application's real infrastructure.</span></span>

<span data-ttu-id="6b155-149">Mantıksal katmanlama, kurumsal yazılım uygulamalarında kod organizasyonunu geliştirmek için yaygın bir tekniktir ve kodun katmanlar halinde düzenlenebileceği çeşitli yöntemler vardır.</span><span class="sxs-lookup"><span data-stu-id="6b155-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
 > <span data-ttu-id="6b155-150">_Katmanlar_ uygulama içinde mantıksal ayırmayı temsil ediyor.</span><span class="sxs-lookup"><span data-stu-id="6b155-150">_Layers_ represent logical separation within the application.</span></span> <span data-ttu-id="6b155-151">Uygulama mantığının ayrı sunuculara veya işlemlere fiziksel olarak dağıtılması durumunda, bu ayrı fiziksel dağıtım hedefleri _katmanlar_olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as _tiers_.</span></span> <span data-ttu-id="6b155-152">Tek bir katmana dağıtılan bir N-Layer uygulamasına sahip olmak mümkündür ve oldukça yaygındır.</span><span class="sxs-lookup"><span data-stu-id="6b155-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="6b155-153">Geleneksel "N-Layer" mimari uygulamaları</span><span class="sxs-lookup"><span data-stu-id="6b155-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="6b155-154">Uygulama mantığının katmanlar halinde en yaygın organizasyonu Şekil 5-2'de gösterilmiştir.</span><span class="sxs-lookup"><span data-stu-id="6b155-154">The most common organization of application logic into layers is shown in Figure 5-2.</span></span>

![Tipik uygulama katmanları](./media/image5-2.png)

<span data-ttu-id="6b155-156">**Şekil 5-2.**</span><span class="sxs-lookup"><span data-stu-id="6b155-156">**Figure 5-2.**</span></span> <span data-ttu-id="6b155-157">Tipik uygulama katmanları.</span><span class="sxs-lookup"><span data-stu-id="6b155-157">Typical application layers.</span></span>

<span data-ttu-id="6b155-158">Bu katmanlar genellikle UI, BLL (Business Logic Layer) ve DAL (Data Access Layer) olarak kısaltılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-158">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="6b155-159">Bu mimariyi kullanarak, kullanıcılar yalnızca BLL ile etkileşime giren Kullanıcı Arası Tümcülleri katmanı aracılığıyla istekte bulunun.</span><span class="sxs-lookup"><span data-stu-id="6b155-159">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="6b155-160">BLL, buna karşılık, veri erişim istekleri için DAL'yi arayabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-160">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="6b155-161">UI katmanı DAL'a doğrudan herhangi bir istekte bulunamaz ve diğer yollarla kalıcılıkla doğrudan etkileşime girmemelidir.</span><span class="sxs-lookup"><span data-stu-id="6b155-161">The UI layer shouldn't make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="6b155-162">Aynı şekilde, BLL sadece DAL geçerek sebat ile etkileşim gerekir.</span><span class="sxs-lookup"><span data-stu-id="6b155-162">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="6b155-163">Bu şekilde, her katmanın kendi bilinen sorumluluğu vardır.</span><span class="sxs-lookup"><span data-stu-id="6b155-163">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="6b155-164">Bu geleneksel katmanlama yaklaşımının bir dezavantajı derleme zaman bağımlılıkları yukarıdan aşağıya doğru çalıştırmak olduğunu.</span><span class="sxs-lookup"><span data-stu-id="6b155-164">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="6b155-165">Diğer bir de, UI katmanı DAL'a bağlı olan BLL'ye bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-165">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="6b155-166">Bu, genellikle uygulamada en önemli mantığı tutan BLL'nin veri erişimi uygulama ayrıntılarına (ve genellikle bir veritabanının varlığına) bağlı olduğu anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-166">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="6b155-167">Böyle bir mimaride iş mantığını sınamak genellikle zordur ve bir test veritabanı gerektirir.</span><span class="sxs-lookup"><span data-stu-id="6b155-167">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="6b155-168">Bağımlılık ters çevirme ilkesi, bir sonraki bölümde göreceğiniz gibi, bu sorunu gidermek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-168">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="6b155-169">Şekil 5-3, uygulamayı sorumluluk (veya katman) ile üç projeye ayırarak örnek bir çözüm gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-169">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

![Üç projeile basit bir monolitik uygulama](./media/image5-3.png)

<span data-ttu-id="6b155-171">**Şekil 5-3.**</span><span class="sxs-lookup"><span data-stu-id="6b155-171">**Figure 5-3.**</span></span> <span data-ttu-id="6b155-172">Üç projeile basit bir monolitik uygulama.</span><span class="sxs-lookup"><span data-stu-id="6b155-172">A simple monolithic application with three projects.</span></span>

<span data-ttu-id="6b155-173">Bu uygulama kuruluş amaçları için çeşitli projeler kullansa da, yine de tek bir birim olarak dağıtılır ve istemcileri tek bir web uygulaması olarak bu uygulamayla etkileşime girecektir.</span><span class="sxs-lookup"><span data-stu-id="6b155-173">Although this application uses several projects for organizational purposes, it's still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="6b155-174">Bu çok basit dağıtım işlemi sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b155-174">This allows for very simple deployment process.</span></span> <span data-ttu-id="6b155-175">Şekil 5-4, böyle bir uygulamanın Azure kullanılarak nasıl barındırılan olabileceğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-175">Figure 5-4 shows how such an app might be hosted using Azure.</span></span>

![Azure Web Uygulamasının basit dağıtımı](./media/image5-4.png)

<span data-ttu-id="6b155-177">**Şekil 5-4.**</span><span class="sxs-lookup"><span data-stu-id="6b155-177">**Figure 5-4.**</span></span> <span data-ttu-id="6b155-178">Azure Web Uygulamasının basit dağıtımı</span><span class="sxs-lookup"><span data-stu-id="6b155-178">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="6b155-179">Uygulama gereksinimleri arttıkça, daha karmaşık ve sağlam dağıtım çözümleri gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-179">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="6b155-180">Şekil 5-5, ek yetenekleri destekleyen daha karmaşık bir dağıtım planı nın bir örneğini gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-180">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![Bir Azure Uygulama Hizmetine web uygulaması dağıtma](./media/image5-5.png)

<span data-ttu-id="6b155-182">**Şekil 5-5.**</span><span class="sxs-lookup"><span data-stu-id="6b155-182">**Figure 5-5.**</span></span> <span data-ttu-id="6b155-183">Bir Azure Uygulama Hizmetine web uygulaması dağıtma</span><span class="sxs-lookup"><span data-stu-id="6b155-183">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="6b155-184">Dahili olarak, bu projenin sorumluluk temel alınarak birden fazla projeye dönüştürülmesi, uygulamanın sürdürülebilirliğini artırır.</span><span class="sxs-lookup"><span data-stu-id="6b155-184">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="6b155-185">Bu birim, bulut tabanlı isteğe bağlı ölçeklenebilirlik avantajlarından yararlanmak için ölçeklendirilebilir veya çıkarılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-185">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="6b155-186">Ölçekleme, uygulamanızı barındıran sunucuya ek CPU, bellek, disk alanı veya başka kaynaklar eklemek anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-186">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="6b155-187">Ölçekleme, ister fiziksel sunucular, ister sanal makineler veya kapsayıcılar olsun, bu tür sunucuların ek örnekleri eklemek anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-187">Scaling out means adding additional instances of such servers, whether these are physical servers, virtual machines, or containers.</span></span> <span data-ttu-id="6b155-188">Uygulamanız birden çok örnekte barındırıldığında, tek tek uygulama örneklerine istek atamak için bir yük dengeleyicisi kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-188">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="6b155-189">Azure'da bir web uygulamasını ölçeklemenin en basit yaklaşımı, uygulamanın Uygulama Hizmet Planı'nda ölçekleme işlemlerini el ile yapılandırmaktır.</span><span class="sxs-lookup"><span data-stu-id="6b155-189">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="6b155-190">Şekil 5-6, bir uygulamaya kaç örnek sunulur yapılandırmak için uygun Azure pano ekranını gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-190">Figure 5-6 shows the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![Azure'da Uygulama Hizmet Planı ölçekleme](./media/image5-6.png)

<span data-ttu-id="6b155-192">**Şekil 5-6.**</span><span class="sxs-lookup"><span data-stu-id="6b155-192">**Figure 5-6.**</span></span> <span data-ttu-id="6b155-193">Azure'da Uygulama Hizmet Planı ölçekleme.</span><span class="sxs-lookup"><span data-stu-id="6b155-193">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="6b155-194">Temiz mimari</span><span class="sxs-lookup"><span data-stu-id="6b155-194">Clean architecture</span></span>

<span data-ttu-id="6b155-195">Bağımlılık Inversion İlke'sinin yanı sıra Etki Alanı Odaklı Tasarım (DDD) ilkelerini izleyen uygulamalar da benzer bir mimariye ulaşma eğilimindedir.</span><span class="sxs-lookup"><span data-stu-id="6b155-195">Applications that follow the Dependency Inversion Principle as well as the Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="6b155-196">Bu mimari yıllar içinde birçok isim le gitti.</span><span class="sxs-lookup"><span data-stu-id="6b155-196">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="6b155-197">İlk isimlerden biri Altıgen Mimari, onu Ports-and-Adapters izledi.</span><span class="sxs-lookup"><span data-stu-id="6b155-197">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="6b155-198">Daha yakın zamanda, [Soğan Mimarisi](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) veya [Temiz Mimari](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)olarak belirtilmiştir.</span><span class="sxs-lookup"><span data-stu-id="6b155-198">More recently, it's been cited as the [Onion Architecture](https://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="6b155-199">İkinci adı, Temiz Mimari, bu e-kitapta bu mimari için ad olarak kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-199">The latter name, Clean Architecture, is used as the name for this architecture in this e-book.</span></span>

<span data-ttu-id="6b155-200">eShopOnWeb başvuru uygulaması, kodlarını projelere dönüştürmede Temiz Mimari yaklaşımını kullanır.</span><span class="sxs-lookup"><span data-stu-id="6b155-200">The eShopOnWeb reference application uses the Clean Architecture approach in organizing its code into projects.</span></span> <span data-ttu-id="6b155-201">[Ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) GitHub deposunda kendi ASP.NET Core'unuz için başlangıç noktası olarak kullanabileceğiniz bir çözüm şablonu bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-201">You can find a solution template you can use as a starting point for your own ASP.NET Core on the [ardalis/cleanarchitecture](https://github.com/ardalis/cleanarchitecture) GitHub repository.</span></span>

<span data-ttu-id="6b155-202">Temiz mimari, iş mantığını ve uygulama modelini uygulamanın merkezine yerletir.</span><span class="sxs-lookup"><span data-stu-id="6b155-202">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="6b155-203">İş mantığının veri erişimine veya diğer altyapı kaygılarına bağlı olması yerine, bu bağımlılık tersine çevrilmiş tir: altyapı ve uygulama ayrıntıları Uygulama Çekirdeğine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-203">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="6b155-204">Bu, Uygulama Çekirdeği'nde, altyapı katmanında tanımlanan türler tarafından uygulanan soyutlamaları veya arabirimleri tanımlayarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-204">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="6b155-205">Bu mimarigörselleştirme ortak bir yolu, bir soğan benzer eşmerkezli daireler bir dizi kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="6b155-205">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="6b155-206">Şekil 5-7 mimari temsil bu stilin bir örnek gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-206">Figure 5-7 shows an example of this style of architectural representation.</span></span>

![Temiz Mimari; soğan görünümü](./media/image5-7.png)

<span data-ttu-id="6b155-208">**Şekil 5-7.**</span><span class="sxs-lookup"><span data-stu-id="6b155-208">**Figure 5-7.**</span></span> <span data-ttu-id="6b155-209">Temiz Mimari; soğan görünümü</span><span class="sxs-lookup"><span data-stu-id="6b155-209">Clean Architecture; onion view</span></span>

<span data-ttu-id="6b155-210">Bu diyagramda, bağımlılıklar en içteki daireye doğru akar.</span><span class="sxs-lookup"><span data-stu-id="6b155-210">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="6b155-211">Uygulama Çekirdeği adını bu diyagramın merkezindeki konumundan alır.</span><span class="sxs-lookup"><span data-stu-id="6b155-211">The Application Core takes its name from its position at the core of this diagram.</span></span> <span data-ttu-id="6b155-212">Ve diyagramda Uygulama Çekirdeğinin diğer uygulama katmanlarına hiçbir bağımlılığı olmadığını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-212">And you can see on the diagram that the Application Core has no dependencies on other application layers.</span></span> <span data-ttu-id="6b155-213">Uygulamanın varlıkları ve arayüzleri tam merkezdedir.</span><span class="sxs-lookup"><span data-stu-id="6b155-213">The application's entities and interfaces are at the very center.</span></span> <span data-ttu-id="6b155-214">Yalnızca dışarıda, ancak yine de Uygulama Çekirdeği'nde, genellikle iç dairede tanımlanan arabirimleri uygulayan etki alanı hizmetleri bulunur.</span><span class="sxs-lookup"><span data-stu-id="6b155-214">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="6b155-215">Uygulama Çekirdeği dışında, hem Kullanıcı UI hem de Altyapı katmanları Uygulama Çekirdeğine bağlıdır, ancak birbirlerine (mutlaka) bağlı değildir.</span><span class="sxs-lookup"><span data-stu-id="6b155-215">Outside of the Application Core, both the UI and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="6b155-216">Şekil 5-8, UI ve diğer katmanlar arasındaki bağımlılığı daha iyi yansıtan daha geleneksel bir yatay katman diyagramı gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-216">Figure 5-8 shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![Temiz Mimari; yatay katman görünümü](./media/image5-8.png)

<span data-ttu-id="6b155-218">**Şekil 5-8.**</span><span class="sxs-lookup"><span data-stu-id="6b155-218">**Figure 5-8.**</span></span> <span data-ttu-id="6b155-219">Temiz Mimari; yatay katman görünümü</span><span class="sxs-lookup"><span data-stu-id="6b155-219">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="6b155-220">Düz okların derleme zamanı bağımlılıklarını temsil ettiğini, kesikli ok ise yalnızca çalışma zamanı bağımlılığını temsil ettiğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="6b155-220">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="6b155-221">Temiz mimari ile, Kullanıcı Arabirimi katmanı derleme zamanında Uygulama Çekirdeği'nde tanımlanan arabirimlerle çalışır ve ideal olarak Altyapı katmanında tanımlanan uygulama türleri hakkında bilgi olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-221">With the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally shouldn't know about the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="6b155-222">Ancak çalışma zamanında, bu uygulama türlerinin uygulamanın yürütülmesi için gerekli olduğundan, bağımlılık enjeksiyonu yoluyla Uygulama Çekirdeği arabirimlerine bağlı olmaları gerekir.</span><span class="sxs-lookup"><span data-stu-id="6b155-222">At run time, however, these implementation types are required for the app to execute, so they need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="6b155-223">Şekil 5-9, bu önerilere göre üretildiğinde ASP.NET Core uygulamasının mimarisinin daha ayrıntılı bir görünümünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="6b155-223">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![Temiz Mimari'yi takip eden ASP.NET Temel mimari diyagramı](./media/image5-9.png)

<span data-ttu-id="6b155-225">**Şekil 5-9.**</span><span class="sxs-lookup"><span data-stu-id="6b155-225">**Figure 5-9.**</span></span> <span data-ttu-id="6b155-226">Temiz Mimari'yi izleyen ASP.NET Çekirdek mimari diyagramı.</span><span class="sxs-lookup"><span data-stu-id="6b155-226">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="6b155-227">Uygulama Çekirdeği Altyapıya bağlı olmadığından, bu katman için otomatik birim testleri yazmak çok kolaydır.</span><span class="sxs-lookup"><span data-stu-id="6b155-227">Because the Application Core doesn't depend on Infrastructure, it's very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="6b155-228">5-10 ve 5-11 rakamları testlerin bu mimariye nasıl uyduğunu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="6b155-228">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="6b155-230">**Şekil 5-10.**</span><span class="sxs-lookup"><span data-stu-id="6b155-230">**Figure 5-10.**</span></span> <span data-ttu-id="6b155-231">Ünite test Uygulama Çekirdeği izole.</span><span class="sxs-lookup"><span data-stu-id="6b155-231">Unit testing Application Core in isolation.</span></span>

![Entegrasyon Testleri](./media/image5-11.png)

<span data-ttu-id="6b155-233">**Şekil 5-11.**</span><span class="sxs-lookup"><span data-stu-id="6b155-233">**Figure 5-11.**</span></span> <span data-ttu-id="6b155-234">Dış bağımlılıklarla altyapı uygulamalarını tümleştirme testi.</span><span class="sxs-lookup"><span data-stu-id="6b155-234">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="6b155-235">Kullanıcı Bira Bilgisi katmanı altyapı projesinde tanımlanan türlere doğrudan bağımlılık taşımadığından, testleri kolaylaştırmak veya değişen uygulama gereksinimlerine yanıt olarak uygulamaları değiştirmek de çok kolaydır.</span><span class="sxs-lookup"><span data-stu-id="6b155-235">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it's likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="6b155-236">ASP.NET Core'un bağımlılık enjeksiyonu için yerleşik kullanımı ve desteği, bu mimariyi önemsiz olmayan monolitik uygulamaları yapılandırmanın en uygun yolu haline getirir.</span><span class="sxs-lookup"><span data-stu-id="6b155-236">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="6b155-237">Yekpare uygulamalar için Uygulama Çekirdeği, Altyapı ve Kullanıcı Arabirimi projelerinin tümü tek bir uygulama olarak çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-237">For monolithic applications the Application Core, Infrastructure, and UI projects are all run as a single application.</span></span> <span data-ttu-id="6b155-238">Çalışma zamanı uygulama mimarisi Şekil 5-12 gibi görünebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-238">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASP.NET Temel Mimari 2](./media/image5-12.png)

<span data-ttu-id="6b155-240">**Şekil 5-12.**</span><span class="sxs-lookup"><span data-stu-id="6b155-240">**Figure 5-12.**</span></span> <span data-ttu-id="6b155-241">Core uygulamasının çalışma zamanı mimarisiASP.NET bir örnek.</span><span class="sxs-lookup"><span data-stu-id="6b155-241">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="6b155-242">Temiz Mimaride Kodu Düzenleme</span><span class="sxs-lookup"><span data-stu-id="6b155-242">Organizing code in Clean Architecture</span></span>

<span data-ttu-id="6b155-243">Temiz Mimari çözümünde, her projenin net sorumlulukları vardır.</span><span class="sxs-lookup"><span data-stu-id="6b155-243">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="6b155-244">Bu nedenle, belirli türler her projeye aittir ve sık sık uygun projede bu türlere karşılık gelen klasörler bulacaksınız.</span><span class="sxs-lookup"><span data-stu-id="6b155-244">As such, certain types belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="6b155-245">Uygulama Çekirdeği, varlıkları, hizmetleri ve arabirimleri içeren iş modelini tutar.</span><span class="sxs-lookup"><span data-stu-id="6b155-245">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="6b155-246">Bu arabirimler, veri erişimi, dosya sistemi erişimi, ağ aramaları gibi Altyapı kullanılarak gerçekleştirilecek işlemler için soyutlamalar içerir. Bazen bu katmanda tanımlanan hizmetlerin veya arabirimlerin, UI veya Altyapı'ya bağımlı olmayan varlık türleri ile çalışması gerekir.</span><span class="sxs-lookup"><span data-stu-id="6b155-246">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="6b155-247">Bunlar basit Veri Aktarım Nesneleri (DTOs) olarak tanımlanabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-247">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

### <a name="application-core-types"></a><span data-ttu-id="6b155-248">Uygulama Çekirdek türleri</span><span class="sxs-lookup"><span data-stu-id="6b155-248">Application Core types</span></span>

- <span data-ttu-id="6b155-249">Varlıklar (kalıcı olan iş modeli sınıfları)</span><span class="sxs-lookup"><span data-stu-id="6b155-249">Entities (business model classes that are persisted)</span></span>
- <span data-ttu-id="6b155-250">Arabirimler</span><span class="sxs-lookup"><span data-stu-id="6b155-250">Interfaces</span></span>
- <span data-ttu-id="6b155-251">Hizmetler</span><span class="sxs-lookup"><span data-stu-id="6b155-251">Services</span></span>
- <span data-ttu-id="6b155-252">DTO'lar</span><span class="sxs-lookup"><span data-stu-id="6b155-252">DTOs</span></span>

<span data-ttu-id="6b155-253">Altyapı projesi genellikle veri erişim uygulamalarını içerir.</span><span class="sxs-lookup"><span data-stu-id="6b155-253">The Infrastructure project typically includes data access implementations.</span></span> <span data-ttu-id="6b155-254">Tipik bir ASP.NET Core web uygulamasında, bu uygulamalar Varlık Çerçevesi (EF) `Migration` DbContext, tanımlanmış tüm EF Core nesneleri ve veri erişimi uygulama sınıflarını içerir.</span><span class="sxs-lookup"><span data-stu-id="6b155-254">In a typical ASP.NET Core web application, these implementations include the Entity Framework (EF) DbContext, any EF Core `Migration` objects that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="6b155-255">Soyut veri erişim uygulama kodu için en yaygın yolu [Deposu tasarım deseni](https://deviq.com/repository-pattern/)kullanımı ile.</span><span class="sxs-lookup"><span data-stu-id="6b155-255">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](https://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="6b155-256">Veri erişim uygulamalarına ek olarak, Altyapı projesi altyapı sorunlarıyla etkileşimde olması gereken hizmetlerin uygulamalarını içermelidir.</span><span class="sxs-lookup"><span data-stu-id="6b155-256">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="6b155-257">Bu hizmetler, Uygulama Çekirdeği'nde tanımlanan arabirimleri uygulamalı ve altyapının Uygulama Çekirdeği projesine bir başvurusu olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-257">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

### <a name="infrastructure-types"></a><span data-ttu-id="6b155-258">Altyapı tipleri</span><span class="sxs-lookup"><span data-stu-id="6b155-258">Infrastructure types</span></span>

- <span data-ttu-id="6b155-259">EF Çekirdek`DbContext`tipleri `Migration`( , )</span><span class="sxs-lookup"><span data-stu-id="6b155-259">EF Core types (`DbContext`, `Migration`)</span></span>
- <span data-ttu-id="6b155-260">Veri erişimi uygulama türleri (Depositories)</span><span class="sxs-lookup"><span data-stu-id="6b155-260">Data access implementation types (Repositories)</span></span>
- <span data-ttu-id="6b155-261">Altyapıya özel hizmetler (örneğin, `FileLogger` veya) `SmtpNotifier`</span><span class="sxs-lookup"><span data-stu-id="6b155-261">Infrastructure-specific services (for example, `FileLogger` or `SmtpNotifier`)</span></span>

<span data-ttu-id="6b155-262">ASP.NET Core MVC uygulamasındaki kullanıcı arabirimi katmanı, uygulamanın giriş noktasıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-262">The user interface layer in an ASP.NET Core MVC application is the entry point for the application.</span></span> <span data-ttu-id="6b155-263">Bu proje, Uygulama Çekirdeği projesine başvurmalı ve türleri uygulama çekirdeğinde tanımlanan arabirimler aracılığıyla altyapıyla etkileşime girmelidir.</span><span class="sxs-lookup"><span data-stu-id="6b155-263">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="6b155-264">UI katmanında Altyapı katmanı türlerine doğrudan anlık veya statik çağrılara izin verilmemelidir.</span><span class="sxs-lookup"><span data-stu-id="6b155-264">No direct instantiation of or static calls to the Infrastructure layer types should be allowed in the UI layer.</span></span>

### <a name="ui-layer-types"></a><span data-ttu-id="6b155-265">UI katman türleri</span><span class="sxs-lookup"><span data-stu-id="6b155-265">UI layer types</span></span>

- <span data-ttu-id="6b155-266">Denetleyiciler</span><span class="sxs-lookup"><span data-stu-id="6b155-266">Controllers</span></span>
- <span data-ttu-id="6b155-267">Filtreler</span><span class="sxs-lookup"><span data-stu-id="6b155-267">Filters</span></span>
- <span data-ttu-id="6b155-268">Görünümler</span><span class="sxs-lookup"><span data-stu-id="6b155-268">Views</span></span>
- <span data-ttu-id="6b155-269">Modelleri Görüntüle</span><span class="sxs-lookup"><span data-stu-id="6b155-269">ViewModels</span></span>
- <span data-ttu-id="6b155-270">Başlangıç</span><span class="sxs-lookup"><span data-stu-id="6b155-270">Startup</span></span>

<span data-ttu-id="6b155-271">Başlangıç sınıfı, uygulamayı yapılandırmaktan ve uygulama türlerini arabirimlere kablolamaktan ve bağımlılık enjeksiyonunun çalışma zamanında düzgün çalışmasına izin vermekten sorumludur.</span><span class="sxs-lookup"><span data-stu-id="6b155-271">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="6b155-272">Yapılandırılan Hizmetlerdeki bağımlılık enjeksiyonunun UI projesinin Startup.cs dosyasına iletebilmesi için, projenin Altyapı projesine başvurması gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-272">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="6b155-273">Bu bağımlılık, en kolay özel bir DI kapsayıcı kullanılarak ortadan kaldırılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-273">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="6b155-274">Bu örneğin amaçları için, en basit yaklaşım UI projesinin Altyapı projesine başvurmasına izin vermektir.</span><span class="sxs-lookup"><span data-stu-id="6b155-274">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="6b155-275">Monolitik uygulamalar ve kaplar</span><span class="sxs-lookup"><span data-stu-id="6b155-275">Monolithic applications and containers</span></span>

<span data-ttu-id="6b155-276">Tek ve yekpare dağıtım tabanlı Web Uygulaması veya Hizmeti oluşturabilir ve kapsayıcı olarak dağıtabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-276">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="6b155-277">Uygulama içinde, yekpare olmayabilir, ancak çeşitli kitaplıklar, bileşenler veya katmanlar halinde organize edilebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-277">Within the application, it might not be monolithic but organized into several libraries, components, or layers.</span></span> <span data-ttu-id="6b155-278">Harici olarak, tek bir işlem, tek bir web uygulaması veya tek bir hizmet gibi tek bir kapsayıcı.</span><span class="sxs-lookup"><span data-stu-id="6b155-278">Externally, it's a single container like a single process, single web application, or single service.</span></span>

<span data-ttu-id="6b155-279">Bu modeli yönetmek için, uygulamayı temsil etmek için tek bir kapsayıcı dağıtın.</span><span class="sxs-lookup"><span data-stu-id="6b155-279">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="6b155-280">Ölçeklendirmek için, önünüzde bir yük dengeleyicisi olan ek kopyalar eklemeniz gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="6b155-280">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="6b155-281">Basitlik, tek bir kapsayıcıda veya VM'de tek bir dağıtımın yönetilmesinden gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-281">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![Şekil 5-13](./media/image5-13.png)

<span data-ttu-id="6b155-283">Şekil 5-13'te gösterildiği gibi, her kapsayıcıya birden çok bileşen/kitaplık veya dahili katman ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-283">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-13.</span></span> <span data-ttu-id="6b155-284">Ama, _"bir konteyner bir şey yapar ve tek bir süreç içinde yapar"_ konteyner prensibini izleyerek, yekpare desen bir çatışma olabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-284">But, following the container principle of _"a container does one thing, and does it in one process_", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="6b155-285">Bu yaklaşımın dezavantajı, uygulama büyüyünce ölçeklendirmesini gerektiren bir yaklaşım la gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-285">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="6b155-286">Tüm uygulama ölçekler, gerçekten bir sorun değil.</span><span class="sxs-lookup"><span data-stu-id="6b155-286">If the entire application scales, it's not really a problem.</span></span> <span data-ttu-id="6b155-287">Ancak, çoğu durumda, uygulamanın birkaç bölümü ölçekleme gerektiren boğma noktalarıdır, diğer bileşenler ise daha az kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-287">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="6b155-288">Tipik e-ticaret örneğini kullanarak, ölçeklendirmeniz gereken şey ürün bilgileri bileşenidir.</span><span class="sxs-lookup"><span data-stu-id="6b155-288">Using the typical eCommerce example, what you likely need to scale is the product information component.</span></span> <span data-ttu-id="6b155-289">Çok daha fazla müşteri satın almaktan çok ürünlere göz atar.</span><span class="sxs-lookup"><span data-stu-id="6b155-289">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="6b155-290">Sepetlerini ödeme ardışık hattını kullanmaktan daha fazla müşteri kullanır.</span><span class="sxs-lookup"><span data-stu-id="6b155-290">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="6b155-291">Daha az müşteri yorum ekler veya satın alma geçmişini görüntüleyin.</span><span class="sxs-lookup"><span data-stu-id="6b155-291">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="6b155-292">Ve büyük olasılıkla yalnızca tek bir bölgede, içerik ve pazarlama kampanyalarını yönetmesi gereken bir avuç çalışana sahip sinizdir.</span><span class="sxs-lookup"><span data-stu-id="6b155-292">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="6b155-293">Yekpare tasarımı ölçeklendirerek, tüm kod birden çok kez dağıtılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-293">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="6b155-294">"Her şeyi ölçeklendir" sorununa ek olarak, tek bir bileşendeki değişiklikler tüm uygulamanın tam olarak yeniden test edilmesini ve tüm örneklerin tam olarak yeniden dağıtılmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="6b155-294">In addition to the "scale everything" problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="6b155-295">Yekpare yaklaşım yaygındır ve birçok kuruluş bu mimari yaklaşımla gelişmektedir.</span><span class="sxs-lookup"><span data-stu-id="6b155-295">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="6b155-296">Pek çoğu yeterince iyi sonuçlar alırken, diğerleri sınırları zorluyor.</span><span class="sxs-lookup"><span data-stu-id="6b155-296">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="6b155-297">Araçlar ve altyapı hizmet odaklı mimariler (SOA) oluşturmak çok zor olduğu için birçok kişi uygulamalarını bu modelde tasarladı ve uygulama büyüyene kadar bu ihtiyacı görmediler.</span><span class="sxs-lookup"><span data-stu-id="6b155-297">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service-oriented architectures (SOA), and they didn't see the need until the app grew.</span></span> <span data-ttu-id="6b155-298">Yekpare yaklaşımın sınırlarını zorlarsanız, uygulamanın kaplardan ve mikro hizmetlerden daha iyi yararlanmasını sağlamak için uygulamayı parçalamak bir sonraki mantıklı adım olabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-298">If you find you're hitting the limits of the monolithic approach, breaking up the app to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![Şekil 5-14](./media/image5-14.png)

<span data-ttu-id="6b155-300">Microsoft Azure'da yekpare uygulamaları dağıtmak her örnek için özel VM'ler kullanılarak elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-300">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="6b155-301">[Azure Sanal Makine Ölçek Kümelerini](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)kullanarak, Sanal Makineler'i kolayca ölçeklendirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-301">Using [Azure Virtual Machine Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="6b155-302">[Azure Uygulama Hizmetleri,](https://azure.microsoft.com/services/app-service/) VM'leri yönetmek zorunda kalmadan yekpare uygulamalar çalıştırabilir ve örnekleri kolayca ölçeklendirebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-302">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="6b155-303">Azure Uygulama Hizmetleri, dağıtımı basitleştirerek docker kapsayıcılarının tek örneklerini de çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-303">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="6b155-304">Docker'ı kullanarak, docker ana bilgisayar olarak tek bir VM dağıtabilir ve birden çok örnek çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-304">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="6b155-305">Şekil 5-14'te gösterildiği gibi Azure dengeleyicisini kullanarak ölçeklemayı yönetebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-305">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="6b155-306">Çeşitli ana bilgisayarlara dağıtım geleneksel dağıtım teknikleri ile yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-306">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="6b155-307">Docker ana bilgisayarları, docker **run** gibi komutlarla el ile çalıştırılabilir veya Sürekli Teslimat (CD) ardışık hatları gibi otomasyon yoluyla yönetilebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-307">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="6b155-308">Konteyner olarak dağıtılan monolitik uygulama</span><span class="sxs-lookup"><span data-stu-id="6b155-308">Monolithic application deployed as a container</span></span>

<span data-ttu-id="6b155-309">Yekpare uygulama dağıtımlarını yönetmek için kapsayıcıları kullanmanın yararları vardır.</span><span class="sxs-lookup"><span data-stu-id="6b155-309">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="6b155-310">Kapsayıcı örneklerini ölçekleme, ek VM'leri dağıtmaktan çok daha hızlı ve kolaydır.</span><span class="sxs-lookup"><span data-stu-id="6b155-310">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="6b155-311">Sanal makine ölçek kümelerini VM'leri ölçeklendirmek için kullanırken bile, örneğin ilerler.</span><span class="sxs-lookup"><span data-stu-id="6b155-311">Even when using virtual machine scale sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="6b155-312">Uygulama örnekleri olarak dağıtıldığında, uygulamanın yapılandırması VM'nin bir parçası olarak yönetilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-312">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="6b155-313">Docker görüntüleri olarak güncellemeleri dağıtmak çok daha hızlı ve ağ verimlidir.</span><span class="sxs-lookup"><span data-stu-id="6b155-313">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="6b155-314">Docker Images genellikle saniyeler içinde başlar ve hızlı bir şekilde piyasaya çıkar.</span><span class="sxs-lookup"><span data-stu-id="6b155-314">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="6b155-315">Docker örneğini yıkmak, genellikle bir saniyeden kısa sürede tamamlayan bir `docker stop` komut vermek kadar kolaydır.</span><span class="sxs-lookup"><span data-stu-id="6b155-315">Tearing down a Docker instance is as easy as issuing a `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="6b155-316">Kapsayıcılar doğuştan tasarım alabildiği için bozuk VM'ler hakkında endişelenmenize gerek yoktur, ancak güncelleştirme komut dosyaları diskte bırakılan belirli bir yapılandırma yı veya dosyayı hesaba kaçıklamayı unutabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-316">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="6b155-317">Daha basit web uygulamalarının yekpare dağıtımı için Docker kapsayıcılarını kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-317">You can use Docker containers for monolithic deployment of simpler web applications.</span></span> <span data-ttu-id="6b155-318">Bu, sürekli tümleştirme ve sürekli dağıtım ardışık hatlarını geliştirir ve dağıtımdan üretime başarı elde etmeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="6b155-318">This improves continuous integration and continuous deployment pipelines and helps achieve deployment-to-production success.</span></span> <span data-ttu-id="6b155-319">Artık "Makinemde çalışıyor, neden üretimde çalışmıyor?"</span><span class="sxs-lookup"><span data-stu-id="6b155-319">No more “It works on my machine, why does it not work in production?”</span></span>

<span data-ttu-id="6b155-320">Mikro hizmetler tabanlı bir mimarinin birçok faydası vardır, ancak bu avantajlar karmaşıklığın artmasının bir bedeli dir.</span><span class="sxs-lookup"><span data-stu-id="6b155-320">A microservices-based architecture has many benefits, but those benefits come at a cost of increased complexity.</span></span> <span data-ttu-id="6b155-321">Bazı durumlarda, maliyetler avantajlardan daha ağır bastığından, tek bir kapsayıcıda veya yalnızca birkaç kapsayıcıda çalışan yekpare bir dağıtım uygulaması daha iyi bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="6b155-321">In some cases, the costs outweigh the benefits, so a monolithic deployment application running in a single container or in just a few containers is a better option.</span></span>

<span data-ttu-id="6b155-322">Yekpare bir uygulama, iyi ayrılmış mikro hizmetlere kolayca ayrıştırılamaz.</span><span class="sxs-lookup"><span data-stu-id="6b155-322">A monolithic application might not be easily decomposable into well-separated microservices.</span></span> <span data-ttu-id="6b155-323">Mikro hizmetler daha esnek bir uygulama sağlamak için birbirinden bağımsız çalışmalıdır.</span><span class="sxs-lookup"><span data-stu-id="6b155-323">Microservices should work independently of each other to provide a more resilient application.</span></span> <span data-ttu-id="6b155-324">Uygulamanın bağımsız özellik dilimlerini teslim edemezseniz, onu ayırmak yalnızca karmaşıklık ekler.</span><span class="sxs-lookup"><span data-stu-id="6b155-324">If you can't deliver independent feature slices of the application, separating it only adds complexity.</span></span>

<span data-ttu-id="6b155-325">Bir uygulamanın özellikleri bağımsız olarak ölçeklendirmesi gerekmeyebilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-325">An application might not yet need to scale features independently.</span></span> <span data-ttu-id="6b155-326">Birçok uygulama, tek bir örneğin ötesine ölçeklendirmek gerektiğinde, bunu tüm örneği klonlama nın nispeten basit bir işlemi yle yapabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-326">Many applications, when they need to scale beyond a single instance, can do so through the relatively simple process of cloning that entire instance.</span></span> <span data-ttu-id="6b155-327">Uygulamanın tam örneklerini ölçekleme basit ve uygun maliyetli olduğunda, uygulamayı ayrı ayrı hizmetlere ayırmak için yapılan ek çalışma en az fayda sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b155-327">The additional work to separate the application into discrete services provides minimal benefit when scaling full instances of the application is simple and cost-effective.</span></span>

<span data-ttu-id="6b155-328">Bir uygulamanın geliştirilmesinin başlarında, doğal işlevsel sınırların nerede olduğu hakkında net bir fikriniz olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-328">Early in the development of an application, you might not have a clear idea where the natural functional boundaries are.</span></span> <span data-ttu-id="6b155-329">Minimum uygulanabilir bir ürün geliştirdikçe, doğal ayrım henüz ortaya çıkmış olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-329">As you develop a minimum viable product, the natural separation might not yet have emerged.</span></span> <span data-ttu-id="6b155-330">Bu koşullardan bazıları geçici olabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-330">Some of these conditions might be temporary.</span></span> <span data-ttu-id="6b155-331">Yekpare bir uygulama oluşturarak başlayabilir ve daha sonra geliştirilecek ve mikro hizmetler olarak dağıtılacak bazı özellikleri ayırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-331">You might start by creating a monolithic application, and later separate some features to be developed and deployed as microservices.</span></span> <span data-ttu-id="6b155-332">Diğer koşullar, uygulamanın sorun alanı için gerekli olabilir, bu da uygulamanın hiçbir zaman birden çok mikro hizmete bölünmeyeceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-332">Other conditions might be essential to the application’s problem space, meaning that the application might never be broken into multiple microservices.</span></span>

<span data-ttu-id="6b155-333">Bir uygulamayı birçok ayrı işlemle ayırmak da ek yükü ortaya çıkarmaz.</span><span class="sxs-lookup"><span data-stu-id="6b155-333">Separating an application into many discrete processes also introduces overhead.</span></span> <span data-ttu-id="6b155-334">Özellikleri farklı işlemlere ayırmada daha karmaşıklık vardır.</span><span class="sxs-lookup"><span data-stu-id="6b155-334">There's more complexity in separating features into different processes.</span></span> <span data-ttu-id="6b155-335">İletişim protokolleri daha karmaşık hale gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-335">The communication protocols become more complex.</span></span> <span data-ttu-id="6b155-336">Yöntem çağrıları yerine, hizmetler arasında eşzamanlı iletişim kullanmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6b155-336">Instead of method calls, you must use asynchronous communications between services.</span></span> <span data-ttu-id="6b155-337">Mikro hizmetler mimarisine geçerken, eShopOnContainers uygulamasının mikrohizmetler sürümünde uygulanan yapı taşlarının çoğunu eklemeniz gerekir: olay veri otobüsü kullanımı, ileti esnekliği ve yeniden denemeleri, nihai tutarlılık ve daha fazlası.</span><span class="sxs-lookup"><span data-stu-id="6b155-337">As you move to a microservices architecture, you need to add many of the building blocks implemented in the microservices version of the eShopOnContainers application: event bus handling, message resiliency and retries, eventual consistency, and more.</span></span>

<span data-ttu-id="6b155-338">Çok daha basit [eShopOnWeb referans uygulaması](https://github.com/dotnet-architecture/eShopOnWeb) tek konteyner monolitik konteyner kullanımını destekler.</span><span class="sxs-lookup"><span data-stu-id="6b155-338">The much simpler [eShopOnWeb reference application](https://github.com/dotnet-architecture/eShopOnWeb) supports single-container monolithic container usage.</span></span> <span data-ttu-id="6b155-339">Uygulama geleneksel MVC görünümleri, web API'leri ve Razor Pages içeren bir web uygulaması içerir.</span><span class="sxs-lookup"><span data-stu-id="6b155-339">The application includes one web application that includes traditional MVC views, web APIs, and Razor Pages.</span></span> <span data-ttu-id="6b155-340">Bu uygulama çözüm kökünden `docker-compose build` ve `docker-compose up` komutları kullanılarak başlatılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-340">This application can be launched from the solution root using the `docker-compose build` and `docker-compose up` commands.</span></span> <span data-ttu-id="6b155-341">Bu komut, web projesinin kökünde `Dockerfile` bulunanı kullanarak web örneği için bir kapsayıcıyı yapılandırır ve kapsayıcıyı belirtilen bir bağlantı noktasında çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="6b155-341">This command configures a container for the web instance, using the `Dockerfile` found in the web project's root, and runs the container on a specified port.</span></span> <span data-ttu-id="6b155-342">Bu uygulamanın kaynağını GitHub'dan indirebilir ve yerel olarak çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-342">You can download the source for this application from GitHub and run it locally.</span></span> <span data-ttu-id="6b155-343">Bu yekpare uygulama bile bir kapsayıcı ortamında dağıtılmaktan yararlanır.</span><span class="sxs-lookup"><span data-stu-id="6b155-343">Even this monolithic application benefits from being deployed in a container environment.</span></span>

<span data-ttu-id="6b155-344">İlk olarak, kapsayıcı dağıtım, uygulamanın her örneğinin aynı ortamda çalıştığı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="6b155-344">For one, the containerized deployment means that every instance of the application runs in the same environment.</span></span> <span data-ttu-id="6b155-345">Bu, erken test ve geliştirmenin gerçekleştiği geliştirici ortamını içerir.</span><span class="sxs-lookup"><span data-stu-id="6b155-345">This includes the developer environment where early testing and development take place.</span></span> <span data-ttu-id="6b155-346">Geliştirme ekibi, uygulamayı üretim ortamıyla eşleşen kapsayıcı bir ortamda çalıştırabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-346">The development team can run the application in a containerized environment that matches the production environment.</span></span>

<span data-ttu-id="6b155-347">Buna ek olarak, konteyner uygulamaları daha düşük maliyetle ölçeklendirilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-347">In addition, containerized applications scale out at lower cost.</span></span> <span data-ttu-id="6b155-348">Kapsayıcı ortamının kullanılması, geleneksel VM ortamlarından daha fazla kaynak paylaşımı sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b155-348">Using a container environment enables greater resource sharing than traditional VM environments.</span></span>

<span data-ttu-id="6b155-349">Son olarak, uygulama kapsayıcı iş mantığı ve depolama sunucusu arasında bir ayrım zorlar.</span><span class="sxs-lookup"><span data-stu-id="6b155-349">Finally, containerizing the application forces a separation between the business logic and the storage server.</span></span> <span data-ttu-id="6b155-350">Uygulama ölçeklendikçe, birden çok kapsayıcının tümü tek bir fiziksel depolama ortamına güvenir.</span><span class="sxs-lookup"><span data-stu-id="6b155-350">As the application scales out, the multiple containers will all rely on a single physical storage medium.</span></span> <span data-ttu-id="6b155-351">Bu depolama ortamı genellikle BIR SQL Server veritabanı çalıştıran yüksek kullanılabilirlikli bir sunucu olacaktır.</span><span class="sxs-lookup"><span data-stu-id="6b155-351">This storage medium would typically be a high-availability server running a SQL Server database.</span></span>

## <a name="docker-support"></a><span data-ttu-id="6b155-352">Docker desteği</span><span class="sxs-lookup"><span data-stu-id="6b155-352">Docker support</span></span>

<span data-ttu-id="6b155-353">Proje `eShopOnWeb` .NET Core üzerinde çalışır.</span><span class="sxs-lookup"><span data-stu-id="6b155-353">The `eShopOnWeb` project runs on .NET Core.</span></span> <span data-ttu-id="6b155-354">Bu nedenle, Linux tabanlı veya Windows tabanlı kapsayıcılarda çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-354">Therefore, it can run in either Linux-based or Windows-based containers.</span></span> <span data-ttu-id="6b155-355">Docker dağıtımı için SQL Server için aynı ana bilgisayar türünü kullanmak istediğinizi unutmayın.</span><span class="sxs-lookup"><span data-stu-id="6b155-355">Note that for Docker deployment, you want to use the same host type for SQL Server.</span></span> <span data-ttu-id="6b155-356">Linux tabanlı kaplar daha küçük bir ayak izi sağlar ve tercih edilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-356">Linux-based containers allow a smaller footprint and are preferred.</span></span>

<span data-ttu-id="6b155-357">Visual Studio 2017 veya sonraki **durumlarda, Solution Explorer'daki** bir projeye sağ tıklayarak ve**Docker Desteği** **Ekle'yi** > seçerek mevcut bir uygulamaya Docker desteği ekleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-357">You can use Visual Studio 2017 or later to add Docker support to an existing application by right-clicking on a project in **Solution Explorer** and choosing **Add** > **Docker Support**.</span></span> <span data-ttu-id="6b155-358">Bu, gerekli dosyaları ekler ve bunları kullanmak için projeyi değiştirir.</span><span class="sxs-lookup"><span data-stu-id="6b155-358">This adds the files required and modifies the project to use them.</span></span> <span data-ttu-id="6b155-359">Geçerli `eShopOnWeb` örnekte bu dosyalar zaten yerinde.</span><span class="sxs-lookup"><span data-stu-id="6b155-359">The current `eShopOnWeb` sample already has these files in place.</span></span>

<span data-ttu-id="6b155-360">Çözüm düzeyindeki `docker-compose.yml` dosya, hangi görüntülerin oluşturulması ve hangi kapsayıcıların başlatılaması hakkında bilgi içerir.</span><span class="sxs-lookup"><span data-stu-id="6b155-360">The solution-level `docker-compose.yml` file contains information about what images to build and what containers to launch.</span></span> <span data-ttu-id="6b155-361">Dosya, aynı anda `docker-compose` birden çok uygulama başlatmak için komutu kullanmanıza olanak sağlar.</span><span class="sxs-lookup"><span data-stu-id="6b155-361">The file allows you to use the `docker-compose` command to launch multiple applications at the same time.</span></span> <span data-ttu-id="6b155-362">Bu durumda, yalnızca Web projesini başlatıyor.</span><span class="sxs-lookup"><span data-stu-id="6b155-362">In this case, it is only launching the Web project.</span></span> <span data-ttu-id="6b155-363">Ayrı bir veritabanı kapsayıcısı gibi bağımlılıkları yapılandırmak için de kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-363">You can also use it to configure dependencies, such as a separate database container.</span></span>

```yml
version: '3'

services:
  eshopwebmvc:
    image: eshopwebmvc
    build:
      context: .
      dockerfile: src/Web/Dockerfile
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - "5106:5106"

networks:
  default:
    external:
      name: nat
```

<span data-ttu-id="6b155-364">Dosya, `docker-compose.yml` `Dockerfile` projedekine `Web` başvurur.</span><span class="sxs-lookup"><span data-stu-id="6b155-364">The `docker-compose.yml` file references the `Dockerfile` in the `Web` project.</span></span> <span data-ttu-id="6b155-365">Hangi `Dockerfile` temel kapsayıcının kullanılacağını ve uygulamanın üzerinde nasıl yapılandırılacağını belirtmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="6b155-365">The `Dockerfile` is used to specify which base container will be used and how the application will be configured on it.</span></span> <span data-ttu-id="6b155-366">' `Web` `Dockerfile`( ) :</span><span class="sxs-lookup"><span data-stu-id="6b155-366">The `Web`' `Dockerfile`:</span></span>

```Dockerfile
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build
WORKDIR /app

COPY *.sln .
COPY . .
WORKDIR /app/src/Web
RUN dotnet restore

RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/core/aspnet:3.1 AS runtime
WORKDIR /app
COPY --from=build /app/src/Web/out ./

ENTRYPOINT ["dotnet", "Web.dll"]
```

### <a name="troubleshooting-docker-problems"></a><span data-ttu-id="6b155-367">Sorun giderme Docker sorunları</span><span class="sxs-lookup"><span data-stu-id="6b155-367">Troubleshooting Docker problems</span></span>

<span data-ttu-id="6b155-368">Kapsayıcı lı uygulamayı çalıştırdıktan sonra, siz durduruna kadar çalıştırmaya devam ediyor.</span><span class="sxs-lookup"><span data-stu-id="6b155-368">Once you run the containerized application, it continues to run until you stop it.</span></span> <span data-ttu-id="6b155-369">`docker ps` Komutla hangi kapsayıcıların çalıştığını görüntüleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-369">You can view which containers are running with the `docker ps` command.</span></span> <span data-ttu-id="6b155-370">Komutu `docker stop` kullanarak ve kapsayıcı kimliğini belirterek çalışan bir kapsayıcıyı durdurabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="6b155-370">You can stop a running container by using the `docker stop` command and specifying the container ID.</span></span>

<span data-ttu-id="6b155-371">Docker kapsayıcılarını çalıştırmak, geliştirme ortamınızda kullanmayı deneyeceğiniz bağlantı noktalarına bağlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="6b155-371">Note that running Docker containers may be bound to ports you might otherwise try to use in your development environment.</span></span> <span data-ttu-id="6b155-372">Çalışan Docker kapsayıcısı ile aynı bağlantı noktasını kullanarak bir uygulamayı çalıştırmaya veya hata ayıklamaya çalışırsanız, sunucunun bu bağlantı noktasına bağlanamamasını belirten bir hata alırsınız.</span><span class="sxs-lookup"><span data-stu-id="6b155-372">If you try to run or debug an application using the same port as a running Docker container, you'll get an error stating that the server can't bind to that port.</span></span> <span data-ttu-id="6b155-373">Bir kez daha, kapsayıcıdurdurma sorunu çözmek gerekir.</span><span class="sxs-lookup"><span data-stu-id="6b155-373">Once again, stopping the container should resolve the issue.</span></span>

<span data-ttu-id="6b155-374">Visual Studio'yu kullanarak uygulamanız için Docker desteği eklemek istiyorsanız, bunu yaparken Docker Desktop'ın çalıştığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="6b155-374">If you want to add Docker support to your application using Visual Studio, make sure Docker Desktop is running when you do so.</span></span> <span data-ttu-id="6b155-375">Sihirbazı çalıştırdığınızda Docker Desktop çalışmıyorsa sihirbaz düzgün çalışmaz.</span><span class="sxs-lookup"><span data-stu-id="6b155-375">The wizard won't run correctly if Docker Desktop isn't running when you start the wizard.</span></span> <span data-ttu-id="6b155-376">Ayrıca sihirbaz, doğru Docker desteğini eklemek için geçerli kapsayıcı seçiminizi inceler.</span><span class="sxs-lookup"><span data-stu-id="6b155-376">In addition, the wizard examines your current container choice to add the correct Docker support.</span></span> <span data-ttu-id="6b155-377">Windows Kapsayıcıları için destek eklemek istiyorsanız, Windows Kapsayıcıları yapılandırılmış docker masaüstü çalışırken sihirbazı çalıştırmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="6b155-377">If you want to add support for Windows Containers, you need to run the wizard while you have Docker Desktop running with Windows Containers configured.</span></span> <span data-ttu-id="6b155-378">Linux kapsayıcıları için destek eklemek istiyorsanız, Docker Linux kapsayıcıları yapılandırılmış çalıştırırken sihirbazı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="6b155-378">If you want to add support for Linux containers, run the wizard while you have Docker running with Linux containers configured.</span></span>

### <a name="references--common-web-architectures"></a><span data-ttu-id="6b155-379">Referanslar – Ortak web mimarileri</span><span class="sxs-lookup"><span data-stu-id="6b155-379">References – Common web architectures</span></span>

- <span data-ttu-id="6b155-380">**Temiz Mimari**</span><span class="sxs-lookup"><span data-stu-id="6b155-380">**The Clean Architecture**</span></span>  
  <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
- <span data-ttu-id="6b155-381">**Soğan Mimarisi**</span><span class="sxs-lookup"><span data-stu-id="6b155-381">**The Onion Architecture**</span></span>  
  <https://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
- <span data-ttu-id="6b155-382">**Depo Deseni**</span><span class="sxs-lookup"><span data-stu-id="6b155-382">**The Repository Pattern**</span></span>  
  <https://deviq.com/repository-pattern/>
- <span data-ttu-id="6b155-383">**Temiz Mimari Çözüm Şablonu**</span><span class="sxs-lookup"><span data-stu-id="6b155-383">**Clean Architecture Solution Template**</span></span>  
  <https://github.com/ardalis/cleanarchitecture>
- <span data-ttu-id="6b155-384">**Mimarlık Mikrohizmetler e-kitap**</span><span class="sxs-lookup"><span data-stu-id="6b155-384">**Architecting Microservices e-book**</span></span>  
  <https://aka.ms/MicroservicesEbook>
- <span data-ttu-id="6b155-385">**DDD (Etki Alanı Odaklı Tasarım)**</span><span class="sxs-lookup"><span data-stu-id="6b155-385">**DDD (Domain-Driven Design)**</span></span>  
  <https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/>

>[!div class="step-by-step"]
><span data-ttu-id="6b155-386">[Önceki](architectural-principles.md)
>[Sonraki](common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="6b155-386">[Previous](architectural-principles.md)
[Next](common-client-side-web-technologies.md)</span></span>
