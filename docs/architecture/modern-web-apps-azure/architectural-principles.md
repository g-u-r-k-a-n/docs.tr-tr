---
title: Mimari ilkeleri
description: ASP.NET Core ve Azure ile Mimar Modern Web Uygulamaları | Mimari ilkeler
author: ardalis
ms.author: wiwagn
ms.date: 12/04/2019
ms.openlocfilehash: ffc890bf8cd6b07bd70d8fc7b2b8cfeaf474ae35
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/14/2020
ms.locfileid: "77450277"
---
# <a name="architectural-principles"></a><span data-ttu-id="a1388-103">Mimari ilkeleri</span><span class="sxs-lookup"><span data-stu-id="a1388-103">Architectural principles</span></span>

> <span data-ttu-id="a1388-104">"Eğer inşaatçılar programcıların program yazdığı gibi binalar inşa ederlerse, o zaman ortaya çıkan ilk ağaçkakan uygarlığı yok ederdi."</span><span class="sxs-lookup"><span data-stu-id="a1388-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="a1388-105">_\-Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="a1388-105">_\- Gerald Weinberg_</span></span>

<span data-ttu-id="a1388-106">Yazılım çözümlerini akılda takılmalı ve tasarlamalısınız.</span><span class="sxs-lookup"><span data-stu-id="a1388-106">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="a1388-107">Bu bölümde özetlenen ilkeler, temiz ve bakımı yla sonuçlanacak mimari kararlara doğru size rehberlik edebilir.</span><span class="sxs-lookup"><span data-stu-id="a1388-107">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="a1388-108">Genel olarak, bu ilkeler, uygulamanızın diğer bölümleriyle sıkı bir şekilde birleşen, ancak açık arabirimler veya ileti sistemleri aracılığıyla iletişim kuramayan ayrı bileşenlerden uygulamalar oluşturmanıza yönelik tir.</span><span class="sxs-lookup"><span data-stu-id="a1388-108">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="a1388-109">Ortak tasarım ilkeleri</span><span class="sxs-lookup"><span data-stu-id="a1388-109">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="a1388-110">Endişelerin ayrılması</span><span class="sxs-lookup"><span data-stu-id="a1388-110">Separation of concerns</span></span>

<span data-ttu-id="a1388-111">Geliştirirken yol gösterici bir ilke **Kaygıların Ayrılmasıdır.**</span><span class="sxs-lookup"><span data-stu-id="a1388-111">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="a1388-112">Bu ilke, yazılımın gerçekleştirdiği çalışma türlerine göre ayrılması gerektiğini ileri sürmelidir.</span><span class="sxs-lookup"><span data-stu-id="a1388-112">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="a1388-113">Örneğin, kayda değer öğeleri kullanıcıya görüntülemek için tanımlama mantığı içeren ve bu tür öğeleri daha belirgin hale getirmek için belirli bir şekilde biçimlendiren bir uygulama düşünün.</span><span class="sxs-lookup"><span data-stu-id="a1388-113">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="a1388-114">Biçimlendirilecek öğelerin seçilmesinden sorumlu davranış, öğeleri biçimlendirmekten sorumlu davranıştan ayrı tutulmalıdır, çünkü bunlar yalnızca tesadüfen birbiriyle ilişkili olan ayrı kaygılardır.</span><span class="sxs-lookup"><span data-stu-id="a1388-114">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="a1388-115">Mimari olarak, uygulamalar temel iş davranışını altyapı ve kullanıcı arabirimi mantığından ayırarak bu ilkeyi takip etmek için mantıksal olarak oluşturulabilir.</span><span class="sxs-lookup"><span data-stu-id="a1388-115">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="a1388-116">İdeal olarak, iş kuralları ve mantığı, uygulamadaki diğer projelere bağlı olmayan ayrı bir projede yer almalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-116">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="a1388-117">Bu, iş modelinin test edilmesinin kolay olmasını ve düşük düzeyli uygulama ayrıntılarıyla sıkı bir şekilde birleştirilmeden gelişebilmesini sağlamaya yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="a1388-117">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="a1388-118">Endişelerin ayrılması, uygulama mimarilerinde katmanların kullanımının ardındaki önemli bir husustur.</span><span class="sxs-lookup"><span data-stu-id="a1388-118">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="a1388-119">Kapsülleme</span><span class="sxs-lookup"><span data-stu-id="a1388-119">Encapsulation</span></span>

<span data-ttu-id="a1388-120">Bir uygulamanın farklı bölümleri, uygulamanın diğer bölümlerinden izole etmek için **kapsülleme** kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-120">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="a1388-121">Uygulama bileşenleri ve katmanları, dış sözleşmeler ihlal edilmedikçe, işbirlikçilerini bozmadan kendi iç uygulamalarını ayarlayabilmelidir.</span><span class="sxs-lookup"><span data-stu-id="a1388-121">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="a1388-122">Nesneler ve paketler aynı arabirim korununca alternatif uygulamalarla değiştirilebildiği için, kapsüllemenin doğru kullanımı uygulama tasarımlarında gevşek bağlantı ve modülerlik elde edilmesine yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="a1388-122">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="a1388-123">Sınıflarda kapsülleme, sınıfın iç durumuna dışarıdan erişimsınırılarak elde edilir.</span><span class="sxs-lookup"><span data-stu-id="a1388-123">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="a1388-124">Dışarıdan bir aktör nesnenin durumunu işlemek istiyorsa, bunu nesnenin özel durumuna doğrudan erişim yerine iyi tanımlanmış bir işlev (veya özellik ayarlayıcısı) aracılığıyla yapmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-124">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="a1388-125">Aynı şekilde, uygulama bileşenleri ve uygulamaları kendilerini kendi durumu doğrudan değiştirilmesine izin yerine, kendi ortak kullanmak için iyi tanımlanmış arabirimleri ortaya çıkarmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-125">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="a1388-126">Bu, kamu sözleşmeleri sürdürülde kadar, uygulamanın iç tasarımının zaman içinde gelişmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="a1388-126">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="a1388-127">Bağımlılık inversiyon</span><span class="sxs-lookup"><span data-stu-id="a1388-127">Dependency inversion</span></span>

<span data-ttu-id="a1388-128">Uygulama içindeki bağımlılık yönü, uygulama ayrıntıları değil, soyutlama yönünde olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-128">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="a1388-129">Çoğu uygulama, çalışma zamanı yürütme yönünde zaman bağımlılık akışlarını derleyen şekilde yazılır.</span><span class="sxs-lookup"><span data-stu-id="a1388-129">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="a1388-130">Bu, doğrudan bağımlılık grafiği üretir.</span><span class="sxs-lookup"><span data-stu-id="a1388-130">This produces a direct dependency graph.</span></span> <span data-ttu-id="a1388-131">Diğer bir deyişle, A modülü B modülünde bir işlev çağırırsa, c modülünde bir işlev çağırırsa, derleme zamanında A, Şekil 4-1'de gösterildiği gibi C'ye bağlı olacak olan B'ye bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-131">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B, which will depend on C, as shown in Figure 4-1.</span></span>

![Doğrudan bağımlılık grafiği](./media/image4-1.png)

<span data-ttu-id="a1388-133">**Şekil 4-1.**</span><span class="sxs-lookup"><span data-stu-id="a1388-133">**Figure 4-1.**</span></span> <span data-ttu-id="a1388-134">Doğrudan bağımlılık grafiği.</span><span class="sxs-lookup"><span data-stu-id="a1388-134">Direct dependency graph.</span></span>

<span data-ttu-id="a1388-135">Bağımlılık inversiyon ilkesinin uygulanması, A'nın B'nin uyguladığı bir soyutlama üzerinde metod lar çağırmasına olanak tanır, bu da A'nın çalışma zamanında B'yi aramasını, ancak B'nin derleme zamanında A tarafından denetlenen bir arabirime (böylece tipik derleme zamanı bağımlılığını *tersine çevirme)* bağlı olmasını sağlar.</span><span class="sxs-lookup"><span data-stu-id="a1388-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="a1388-136">Çalışma zamanında, program yürütme akışı değişmeden kalır, ancak arabirimlerin giriş bu arabirimlerin farklı uygulamaları kolayca takılabilir anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="a1388-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![Ters bağımlılık grafiği](./media/image4-2.png)

<span data-ttu-id="a1388-138">**Şekil 4-2.**</span><span class="sxs-lookup"><span data-stu-id="a1388-138">**Figure 4-2.**</span></span> <span data-ttu-id="a1388-139">Ters bağımlılık grafiği.</span><span class="sxs-lookup"><span data-stu-id="a1388-139">Inverted dependency graph.</span></span>

<span data-ttu-id="a1388-140">**Bağımlılık ters çevirme,** uygulama ayrıntıları başka bir yol yerine, daha üst düzey soyutlamalara bağlı olacak ve uygulayacak şekilde yazılabilir olduğundan, gevşek birleştirilmiş uygulamalar oluşturmanın önemli bir parçasıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-140">**Dependency inversion** is a key part of building loosely coupled applications, since implementation details can be written to depend on and implement higher-level abstractions, rather than the other way around.</span></span> <span data-ttu-id="a1388-141">Ortaya çıkan uygulamalar daha test edilebilir, modüler ve sonuç olarak korunabilir.</span><span class="sxs-lookup"><span data-stu-id="a1388-141">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="a1388-142">*Bağımlılık enjeksiyonu* uygulaması bağımlılık inversiyon prensibini izleyerek mümkün kılınır.</span><span class="sxs-lookup"><span data-stu-id="a1388-142">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="a1388-143">Açık bağımlılıklar</span><span class="sxs-lookup"><span data-stu-id="a1388-143">Explicit dependencies</span></span>

<span data-ttu-id="a1388-144">**Yöntemler ve sınıflar, düzgün çalışabilmek için ihtiyaç duydukları ortak nesneleri açıkça gerektirmelidir.**</span><span class="sxs-lookup"><span data-stu-id="a1388-144">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="a1388-145">Sınıf oluşturucuları, sınıfların geçerli bir durumda olmak ve düzgün bir şekilde çalışabilmeleri için ihtiyaç duydukları şeyleri tanımlamaları için bir fırsat sağlar.</span><span class="sxs-lookup"><span data-stu-id="a1388-145">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="a1388-146">Oluşturulabilen ve çağrılabilen, ancak yalnızca belirli genel veya altyapı bileşenleri yerindeyse düzgün çalışacak sınıfları tanımlarsanız, bu sınıflar istemcilerine *karşı dürüst olmaktan* değildir.</span><span class="sxs-lookup"><span data-stu-id="a1388-146">If you define classes that can be constructed and called, but that will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="a1388-147">Oluşturucu sözleşme yalnızca belirtilen şeyler (sınıf sadece parametresiz bir yapıcı kullanıyorsa muhtemelen hiçbir şey) ihtiyacı istemci söylüyor, ama sonra çalışma zamanında nesne gerçekten başka bir şey ihtiyacı olduğu ortaya çıkıyor.</span><span class="sxs-lookup"><span data-stu-id="a1388-147">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a parameterless constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="a1388-148">Açık bağımlılıklar ilkesini izleyerek, sınıflarınız ve yöntemleriniz, işleyebilmek için ihtiyaç duydukları şey konusunda müşterilerine karşı dürüst oluyorlar.</span><span class="sxs-lookup"><span data-stu-id="a1388-148">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="a1388-149">Bu, kodunuzu daha kendi kendine belgeleme ve kodlama sözleşmelerinizi daha kullanıcı dostu hale getirir, çünkü kullanıcılar yöntem veya yapıcı parametreleri şeklinde gerekli olan şeyi sağladıkları sürece, çalıştıkları nesnelerin çalışacağına güvenirler çalışma zamanında doğru bir şekilde.</span><span class="sxs-lookup"><span data-stu-id="a1388-149">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="a1388-150">Tek sorumluluk</span><span class="sxs-lookup"><span data-stu-id="a1388-150">Single responsibility</span></span>

<span data-ttu-id="a1388-151">Tek sorumluluk ilkesi nesne yönelimli tasarım için geçerlidir, ancak aynı zamanda kaygıların ayrılmasına benzer bir mimari ilke olarak da düşünülebilir.</span><span class="sxs-lookup"><span data-stu-id="a1388-151">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="a1388-152">Nesnelerin tek bir sorumluluğu olması gerektiğini ve değişmek için tek bir nedenleri olması gerektiğini belirtir.</span><span class="sxs-lookup"><span data-stu-id="a1388-152">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="a1388-153">Özellikle, nesnenin değişmesi gereken tek durum, tek bir sorumluluğu gerçekleştirme biçiminin güncellenmesi gerektiğidir.</span><span class="sxs-lookup"><span data-stu-id="a1388-153">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="a1388-154">Bu ilkeyi izleyerek daha gevşek birleştirilmiş ve modüler sistemler üretmek için yardımcı olur, yeni davranış birçok türde yeni sınıflar olarak uygulanabilir, yerine mevcut sınıflara ek sorumluluk ekleyerek.</span><span class="sxs-lookup"><span data-stu-id="a1388-154">Following this principle helps to produce more loosely coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="a1388-155">Yeni sınıflar eklemek, henüz yeni sınıflara bağlı olmadığından, varolan sınıfları değiştirmekten her zaman daha güvenlidir.</span><span class="sxs-lookup"><span data-stu-id="a1388-155">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="a1388-156">Yekpare bir uygulamada, uygulamadaki katmanlara yüksek düzeyde tek sorumluluk ilkesini uygulayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="a1388-156">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="a1388-157">Sunum sorumluluğu UI projesinde kalırken, veri erişim sorumluluğu bir altyapı projesi içinde tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-157">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="a1388-158">İş mantığı, kolayca test edilebildiği ve diğer sorumluluklardan bağımsız olarak gelişebildiği uygulama temel projesinde tutulmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-158">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="a1388-159">Bu ilke uygulama mimarisine uygulandığında ve mantıksal bitiş noktasına alındığında, mikro hizmetler alırsınız.</span><span class="sxs-lookup"><span data-stu-id="a1388-159">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="a1388-160">Belirli bir mikro hizmetin tek bir sorumluluğu olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-160">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="a1388-161">Bir sistemin davranışını genişletmeniz gerekiyorsa, varolan bir sisteme sorumluluk eklemek yerine ek mikro hizmetler ekleyerek bunu yapmak genellikle daha iyidir.</span><span class="sxs-lookup"><span data-stu-id="a1388-161">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="a1388-162">Mikro hizmetler mimarisi hakkında daha fazla bilgi edinin</span><span class="sxs-lookup"><span data-stu-id="a1388-162">Learn more about microservices architecture</span></span>](https://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="a1388-163">Kendinizi tekrar etmeyin (DRY)</span><span class="sxs-lookup"><span data-stu-id="a1388-163">Don't repeat yourself (DRY)</span></span>

<span data-ttu-id="a1388-164">Uygulama, sık karşılaşılan bir hata kaynağı olduğundan, belirli bir kavramla ilgili davranışı birden çok yerde belirtmekten kaçınmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-164">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="a1388-165">Bir noktada, gereksinimlerde bir değişiklik bu davranışın değiştirilmesini gerektirir ve davranışın en az bir örneğinin güncelleştirileme olasılığı sistemin tutarsız davranışına neden olur.</span><span class="sxs-lookup"><span data-stu-id="a1388-165">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="a1388-166">Mantığı çoğaltmak yerine, bir programlama yapısına dahil edin.</span><span class="sxs-lookup"><span data-stu-id="a1388-166">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="a1388-167">Bu yapıyı bu davranış üzerinde tek bir yetki oluşturmayı ve bu davranışı gerektiren uygulamanın başka bir bölümünün yeni yapıyı kullanmasını sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="a1388-167">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="a1388-168">Yalnızca tesadüfen yinelenen birlikte davranışı bağlamaktan kaçının.</span><span class="sxs-lookup"><span data-stu-id="a1388-168">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="a1388-169">Örneğin, iki farklı sabitin her ikisinin de aynı değere sahip olması, kavramsal olarak farklı şeylere atıfta bulunarak yalnızca bir sabitiniz olması gerektiği anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="a1388-169">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="a1388-170">Sebat cehalet</span><span class="sxs-lookup"><span data-stu-id="a1388-170">Persistence ignorance</span></span>

<span data-ttu-id="a1388-171">**Kalıcılık cehaleti** (PI), kalıcı olması gereken, ancak kodu kalıcılık teknolojisinin seçiminden etkilenmeyen türleri ifade eder.</span><span class="sxs-lookup"><span data-stu-id="a1388-171">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="a1388-172">.NET'teki bu tür türler bazen Düz Eski CLR Nesneleri (POCOs) olarak adlandırılır, çünkü belirli bir taban sınıftan devralmaları veya belirli bir arabirim uygulamaları gerekmez.</span><span class="sxs-lookup"><span data-stu-id="a1388-172">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="a1388-173">Aynı iş modelinin birden fazla şekilde devam etmesine izin verdiği için kalıcı lık cehaleti değerlidir ve uygulamaya ek esneklik sağlar.</span><span class="sxs-lookup"><span data-stu-id="a1388-173">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="a1388-174">Kalıcılık seçenekleri zaman içinde değişebilir, bir veritabanı teknolojisinden diğerine veya uygulamanın başladığı şeye ek olarak ek kalıcılık biçimleri gerekebilir (örneğin, bir Redis önbelleği veya Azure Cosmos DB'si ilişkisel veritabanı).</span><span class="sxs-lookup"><span data-stu-id="a1388-174">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure Cosmos DB in addition to a relational database).</span></span>

<span data-ttu-id="a1388-175">Bu ilkenin ihlaline örnek olarak şunlar verilebilir:</span><span class="sxs-lookup"><span data-stu-id="a1388-175">Some examples of violations of this principle include:</span></span>

- <span data-ttu-id="a1388-176">Gerekli bir taban sınıf.</span><span class="sxs-lookup"><span data-stu-id="a1388-176">A required base class.</span></span>

- <span data-ttu-id="a1388-177">Gerekli bir arayüz uygulaması.</span><span class="sxs-lookup"><span data-stu-id="a1388-177">A required interface implementation.</span></span>

- <span data-ttu-id="a1388-178">Kendilerini kaydetmekten sorumlu sınıflar (Etkin Kayıt deseni gibi).</span><span class="sxs-lookup"><span data-stu-id="a1388-178">Classes responsible for saving themselves (such as the Active Record pattern).</span></span>

- <span data-ttu-id="a1388-179">Gerekli parametresiz yapıcı.</span><span class="sxs-lookup"><span data-stu-id="a1388-179">Required parameterless constructor.</span></span>

- <span data-ttu-id="a1388-180">Sanal anahtar kelime gerektiren özellikler.</span><span class="sxs-lookup"><span data-stu-id="a1388-180">Properties requiring virtual keyword.</span></span>

- <span data-ttu-id="a1388-181">Kalıcılığa özgü gerekli öznitelikler.</span><span class="sxs-lookup"><span data-stu-id="a1388-181">Persistence-specific required attributes.</span></span>

<span data-ttu-id="a1388-182">Sınıfların yukarıdaki özelliklerden veya davranışlardan herhangi birine sahip olması gereksinimi, kalıcılık teknolojisinin seçimi ile kalıcılık teknolojisinin seçimi arasındaki bağlantıyı ekler ve gelecekte yeni veri erişim stratejilerinin benimsenmesini zorlaştırır.</span><span class="sxs-lookup"><span data-stu-id="a1388-182">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="a1388-183">Sınırlı bağlamlar</span><span class="sxs-lookup"><span data-stu-id="a1388-183">Bounded contexts</span></span>

<span data-ttu-id="a1388-184">**Sınırlı bağlamlar** Etki Alanı Odaklı Tasarım'da merkezi bir desendir.</span><span class="sxs-lookup"><span data-stu-id="a1388-184">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="a1388-185">Büyük uygulamalarda veya kuruluşlarda karmaşıklığı ayrı kavramsal modüllere ayırarak karmaşıklıkla başa çıkmanın bir yolunu sağlarlar.</span><span class="sxs-lookup"><span data-stu-id="a1388-185">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="a1388-186">Her kavramsal modül daha sonra diğer bağlamlardan (dolayısıyla sınırlanmış) ayrılan ve bağımsız olarak evrimleşebilen bir bağlamı temsil eder.</span><span class="sxs-lookup"><span data-stu-id="a1388-186">Each conceptual module then represents a context that is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="a1388-187">Her sınırlı bağlam ideal olarak içindeki kavramlar için kendi adlarını seçmekte özgür olmalı ve kendi kalıcılık deposuna özel erişime sahip olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="a1388-187">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="a1388-188">En azından, tek tek web uygulamaları, diğer uygulamalarla bir veritabanı paylaşmak yerine, kendi iş modeli için kendi kalıcılık deposu ile kendi sınırlı bağlamı olmak için çaba göstermelidir.</span><span class="sxs-lookup"><span data-stu-id="a1388-188">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="a1388-189">Sınırlı bağlamlar arasındaki iletişim, iş mantığının ve olayların gerçekleşen değişikliklere yanıt olarak gerçekleşmesine olanak tanıyan paylaşılan bir veritabanı yerine programlı arabirimler aracılığıyla gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="a1388-189">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="a1388-190">Sınırlı bağlamlar, ideal olarak kendi bireysel sınırlı bağlamları olarak da uygulanan mikro hizmetlerle yakından eşlenir.</span><span class="sxs-lookup"><span data-stu-id="a1388-190">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a1388-191">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="a1388-191">Additional resources</span></span>

- [<span data-ttu-id="a1388-192">JAVA Tasarım Desenleri: İlkeler</span><span class="sxs-lookup"><span data-stu-id="a1388-192">JAVA Design Patterns: Principles</span></span>](https://java-design-patterns.com/principles/)
- [<span data-ttu-id="a1388-193">Sınırlı Bağlam</span><span class="sxs-lookup"><span data-stu-id="a1388-193">Bounded Context</span></span>](https://martinfowler.com/bliki/BoundedContext.html)

>[!div class="step-by-step"]
><span data-ttu-id="a1388-194">[Önceki](choose-between-traditional-web-and-single-page-apps.md)
>[Sonraki](common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="a1388-194">[Previous](choose-between-traditional-web-and-single-page-apps.md)
[Next](common-web-application-architectures.md)</span></span>
