---
title: 'CA2007: bir görevi doğrudan bekleme (kod analizi)'
description: 'Kod Analizi kuralı CA2007 hakkında bilgi edinin: bir görevi doğrudan bekleme'
ms.date: 03/08/2019
ms.topic: reference
f1_keywords:
- CA2007
- DoNotDirectlyAwaitATaskAnalyzer
helpviewer_keywords:
- CA2007
author: gewarren
ms.author: gewarren
dev_langs:
- CSharp
ms.openlocfilehash: 3a0ae8035b897562d1d50a6d006fc8937f5bb315
ms.sourcegitcommit: 636af37170ae75a11c4f7d1ecd770820e7dfe7bd
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/07/2020
ms.locfileid: "96589430"
---
# <a name="ca2007-do-not-directly-await-a-task"></a>CA2007: Doğrudan bir Görevi beklemeyin

| | Değer |
|-|-|
| **Kural Kimliği** |CA2007|
| **Kategori** |Microsoft. güvenilirliği|
| **Düzeltilme veya kırılmamış** |Kırılmamış|

## <a name="cause"></a>Nedeni

Zaman uyumsuz bir [awaits](../../../csharp/language-reference/operators/await.md) yöntem doğrudan bekler <xref:System.Threading.Tasks.Task> .

## <a name="rule-description"></a>Kural açıklaması

Zaman uyumsuz bir yöntem <xref:System.Threading.Tasks.Task> doğrudan bekler, zaman uyumsuz bağlam temelinde, devamlılık genellikle görevi oluşturan aynı iş parçacığında oluşur. Bu davranış, performans açısından maliyetli olabilir ve Kullanıcı arabirimi iş parçacığında kilitlenmeye neden olabilir. <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType>Devamlılığını sağlamak için çağırmayı düşünün.

## <a name="how-to-fix-violations"></a>İhlalleri çözme

İhlalleri onarmak için, <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> bekletildi üzerinde çağrı yapın <xref:System.Threading.Tasks.Task> . `true`Parametresi için veya ' i geçirebilirsiniz `false` `continueOnCapturedContext` .

- `ConfigureAwait(true)`Görevde çağırmak, açıkça çağrılmayan aynı davranışa sahiptir <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> . Bu yöntemi açık bir şekilde çağırarak, okuyucuların özgün eşitleme bağlamında devamlılığını bilerek gerçekleştirmek istediğinizi öğrenmiş olursunuz.

- `ConfigureAwait(false)`İş parçacığı havuzunda devamlılıkları zamanlamak için görevde çağrı yapın, böylece kullanıcı arabirimi iş parçacığında kilitlenmelerden kaçının. Geçirme `false` , uygulamayla bağımsız kitaplıklar için iyi bir seçenektir.

## <a name="when-to-suppress-warnings"></a>Uyarıların ne zaman bastırılamıyor

Bu uyarı, kodun rastgele ortamlarda yürütülebileceği ve kodun ortam hakkında varsayımları olmaması ya da yöntemin çağırıcısı tarafından nasıl çağrıllabileceği ya da beklenmemesi gerektiği kitaplıklara yöneliktir. Genellikle, uyarı kodu yerine uygulama kodunu temsil eden projeler için uyarıyı tamamen bastırmak için uygundur; Aslında, bu çözümleyici 'yi uygulama kodunda (örneğin, bir WinForms veya WPF projesindeki düğme tıklama olayı işleyicileri) çalıştırmak, yanlış eylemlere neden olabilir.

Devamlılığın orijinal içeriğe geri zamanlanması veya böyle bir bağlamın yerinde olmaması durumunda bu uyarıyı gizleyebilirsiniz. Örneğin, bir düğmeye bir bir WinForms veya WPF uygulamasında kod yazarken, genel olarak bir await 'den devamlılık Kullanıcı arabirimi iş parçacığında çalışmalıdır ve bu nedenle devamlılığını kaynak bağlamına geri doğru zamanlamaya yönelik varsayılan davranış tercih edilir. Başka bir örnek olarak, bir ASP.NET Core uygulamasına kod yazarken, varsayılan olarak <xref:System.Threading.SynchronizationContext> <xref:System.Threading.Tasks.TaskScheduler> herhangi bir davranışı hiçbir şekilde değiştirmediği için, veya, bir, değildir `ConfigureAwait` .

## <a name="example"></a>Örnek

Aşağıdaki kod parçacığı uyarı oluşturur:

```csharp
public async Task Execute()
{
    Task task = null;
    await task;
}
```

İhlalin giderilmesi için, beklenen <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> <xref:System.Threading.Tasks.Task> :

```csharp
public async Task Execute()
{
    Task task = null;
    await task.ConfigureAwait(false);
}
```

## <a name="configurability"></a>Yapılandırılabilirlik

Bu kuraldan bir değer döndürmeyen zaman uyumsuz yöntemleri dışlamak isteyip istemediğiniz yapılandırabilirsiniz. Bu tür yöntemleri dışlamak için, aşağıdaki anahtar-değer çiftini projenizdeki bir *. editorconfig* dosyasına ekleyin:

```ini
# Package version 2.9.0 and later
dotnet_code_quality.CA2007.exclude_async_void_methods = true

# Package version 2.6.3 and earlier
dotnet_code_quality.CA2007.skip_async_void_methods = true
```

Ayrıca, bu kuralın hangi çıkış derleme türlerini uygulanacağını de yapılandırabilirsiniz. Örneğin, bu kuralı yalnızca bir konsol uygulaması veya dinamik olarak bağlı bir kitaplık (yani, bir UI uygulaması değil) üreten koda uygulamak için, aşağıdaki anahtar-değer çiftini projenizdeki bir *. editorconfig* dosyasına ekleyin:

```ini
dotnet_code_quality.CA2007.output_kind = ConsoleApplication, DynamicallyLinkedLibrary
```

Daha fazla bilgi için bkz. [kod kalitesi kural yapılandırma seçenekleri](../code-quality-rule-options.md).

## <a name="see-also"></a>Ayrıca bkz.

- [ConfigureAwait SSS](https://devblogs.microsoft.com/dotnet/configureawait-faq/)
- [ConfigureAwait (false) ile bir görevi beklemem gerekir mi?](https://github.com/Microsoft/vs-threading/blob/master/doc/cookbook_vs.md#should-i-await-a-task-with-configureawaitfalse)
- [CA2008: TaskScheduler geçirmeden görev oluşturmayın](ca2008.md)
- [Güvenilirlik kuralları](reliability-warnings.md)
