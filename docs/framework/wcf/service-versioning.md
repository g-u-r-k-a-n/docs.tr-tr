---
title: Hizmet Sürümü Oluşturma
ms.date: 03/30/2017
ms.assetid: 37575ead-d820-4a67-8059-da11a2ab48e2
ms.openlocfilehash: 3f9fd87eacf67a1b23568dcf87df086e935879ba
ms.sourcegitcommit: 14ad34f7c4564ee0f009acb8bfc0ea7af3bc9541
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/01/2019
ms.locfileid: "73423680"
---
# <a name="service-versioning"></a><span data-ttu-id="bd8e9-102">Hizmet Sürümü Oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-102">Service Versioning</span></span>
<span data-ttu-id="bd8e9-103">İlk dağıtımdan sonra ve yaşam süreleri (ve sergiledikleri uç noktalar) sırasında, iş ihtiyaçlarını değiştirme, bilgi teknolojisi gereksinimleri gibi çeşitli nedenlerle değişiklik yapılması veya diğer sorunları ele almanız gerekebilir çıkışları.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-103">After initial deployment, and potentially several times during their lifetime, services (and the endpoints they expose) may need to be changed for a variety of reasons, such as changing business needs, information technology requirements, or to address other issues.</span></span> <span data-ttu-id="bd8e9-104">Her değişiklik, hizmetin yeni bir sürümünü kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-104">Each change introduces a new version of the service.</span></span> <span data-ttu-id="bd8e9-105">Bu konu, Windows Communication Foundation (WCF) sürümünde sürüm oluşturmayı nasıl düşüntireceğinizi açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-105">This topic explains how to consider versioning in Windows Communication Foundation (WCF).</span></span>  
  
## <a name="four-categories-of-service-changes"></a><span data-ttu-id="bd8e9-106">Dört hizmet kategorisi değişikliği</span><span class="sxs-lookup"><span data-stu-id="bd8e9-106">Four Categories of Service Changes</span></span>  
 <span data-ttu-id="bd8e9-107">Gerekebilecek hizmetlerde yapılan değişiklikler dört kategoride sınıflandırılabilir:</span><span class="sxs-lookup"><span data-stu-id="bd8e9-107">The changes to services that may be required can be classified into four categories:</span></span>  
  
- <span data-ttu-id="bd8e9-108">Sözleşme değişiklikleri: Örneğin, bir işlem eklenebilir veya bir iletideki veri öğesi eklenebilir veya değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-108">Contract changes: For example, an operation might be added, or a data element in a message might be added or changed.</span></span>  
  
- <span data-ttu-id="bd8e9-109">Adres değişiklikleri: Örneğin, bir hizmet, uç noktaların yeni adreslere sahip olduğu farklı bir konuma geçer.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-109">Address changes: For example, a service moves to a different location where endpoints have new addresses.</span></span>  
  
- <span data-ttu-id="bd8e9-110">Bağlantı değişiklikleri: Örneğin, bir güvenlik mekanizması değişir veya ayarları değişir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-110">Binding changes: For example, a security mechanism changes or its settings change.</span></span>  
  
- <span data-ttu-id="bd8e9-111">Uygulama değişiklikleri: Örneğin, bir iç Yöntem uygulamasında değişiklik yapıldığında.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-111">Implementation changes: For example, when an internal method implementation changes.</span></span>  
  
 <span data-ttu-id="bd8e9-112">Bu değişikliklerden bazıları "kırın" olarak, diğerleri ise "bölünemez" olarak adlandırılır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-112">Some of these changes are called "breaking" and others are "nonbreaking."</span></span> <span data-ttu-id="bd8e9-113">Önceki sürümde başarıyla işlenen tüm iletiler yeni sürümde başarıyla işlenirse bir değişiklik *bölünemez* .</span><span class="sxs-lookup"><span data-stu-id="bd8e9-113">A change is *nonbreaking* if all messages that would have been processed successfully in the previous version are processed successfully in the new version.</span></span> <span data-ttu-id="bd8e9-114">Bu ölçütü karşılamayan herhangi bir değişiklik, bir *son* değişiklik olur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-114">Any change that does not meet that criterion is a *breaking* change.</span></span>  
  
## <a name="service-orientation-and-versioning"></a><span data-ttu-id="bd8e9-115">Hizmet yönü ve sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-115">Service Orientation and Versioning</span></span>  
 <span data-ttu-id="bd8e9-116">Hizmet yönünün her biri, hizmetlerin ve istemcilerin otonom (veya bağımsız) olduğu bir hizmettir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-116">One of the tenets of service orientation is that services and clients are autonomous (or independent).</span></span> <span data-ttu-id="bd8e9-117">Diğer şeyler arasında bu, Service Developers 'ın tüm hizmet istemcileri hakkında kontrol ettikleri veya bunlara yönelik olduğunu varsaymayacağı anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-117">Among other things, this implies that service developers cannot assume that they control or even know about all service clients.</span></span> <span data-ttu-id="bd8e9-118">Bu, bir hizmet sürümleri değiştirdiğinde tüm istemcilerin yeniden oluşturulması ve yeniden dağıtılması seçeneklerini ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-118">This eliminates the option of rebuilding and redeploying all clients when a service changes versions.</span></span> <span data-ttu-id="bd8e9-119">Bu konu, hizmetin bu temel 'e ait olduğunu varsayar ve bu nedenle, istemcilerinden bağımsız olarak değiştirilmesi veya "sürümlenmiş" olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-119">This topic assumes the service adheres to this tenet and therefore must be changed or "versioned" independent of its clients.</span></span>  
  
 <span data-ttu-id="bd8e9-120">Önemli bir değişikliğin beklenmiyorsa ve kaçınılmaz durumda, bir uygulama bu temel 'i yok saymayı seçebilir ve istemcilerin yeniden oluşturulmasını ve hizmetin yeni bir sürümü ile yeniden dağıtılmasını gerektirebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-120">In cases where a breaking change is unexpected and cannot be avoided, an application may choose to ignore this tenet and require that clients be rebuilt and redeployed with a new version of the service.</span></span>  
  
## <a name="contract-versioning"></a><span data-ttu-id="bd8e9-121">Sözleşme sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-121">Contract Versioning</span></span>  
 <span data-ttu-id="bd8e9-122">İstemci tarafından kullanılan sözleşmelerin, hizmet tarafından kullanılan sözleşmeyle aynı olması gerekmez; yalnızca uyumlu olmaları gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-122">Contracts used by a client do not need to be the same as the contract used by the service; they need only to be compatible.</span></span>  
  
 <span data-ttu-id="bd8e9-123">Hizmet sözleşmeleri için uyumluluk, hizmet tarafından kullanıma sunulan yeni işlemler eklenebilir, ancak mevcut işlemler kaldırılabilir veya anlamsal olarak değiştirilemez.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-123">For service contracts, compatibility means new operations exposed by the service can be added but existing operations cannot be removed or changed semantically.</span></span>  
  
 <span data-ttu-id="bd8e9-124">Veri sözleşmeleri için uyumluluk, yeni şema türü tanımlarının eklenebileceği, ancak var olan şema türü tanımlarının de kırılmaya karşı değiştirimeyeceği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-124">For data contracts, compatibility means new schema type definitions can be added but existing schema type definitions cannot be changed in breaking ways.</span></span> <span data-ttu-id="bd8e9-125">Son değişiklikler veri üyelerini kaldırmayı veya incompatibly veri türünü değiştirmeyi içerebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-125">Breaking changes might include removing data members or changing their data type incompatibly.</span></span> <span data-ttu-id="bd8e9-126">Bu özellik, hizmetin istemcileri bozmadan sözleşmelerinin sürümünü değiştirme konusunda bazı Enlem sağlar.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-126">This feature allows the service some latitude in changing the version of its contracts without breaking clients.</span></span> <span data-ttu-id="bd8e9-127">Sonraki iki bölüm, WCF verileri ve hizmet sözleşmeleri üzerinde yapılabilecek bölünemez ve son değişiklikleri açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-127">The next two sections explain nonbreaking and breaking changes that can be made to WCF data and service contracts.</span></span>  
  
## <a name="data-contract-versioning"></a><span data-ttu-id="bd8e9-128">Veri Sözleşmesi Sürümü Oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-128">Data Contract Versioning</span></span>  
 <span data-ttu-id="bd8e9-129">Bu bölüm <xref:System.Runtime.Serialization.DataContractSerializer> ve <xref:System.Runtime.Serialization.DataContractAttribute> sınıfları kullanılırken veri sürümü oluşturma ile ilgilidir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-129">This section deals with data versioning when using the <xref:System.Runtime.Serialization.DataContractSerializer> and <xref:System.Runtime.Serialization.DataContractAttribute> classes.</span></span>  
  
### <a name="strict-versioning"></a><span data-ttu-id="bd8e9-130">Katı sürüm oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-130">Strict Versioning</span></span>  
 <span data-ttu-id="bd8e9-131">Birçok senaryoda, sürümleri değiştirirken bir sorun olduğunda, hizmet geliştiricisi istemciler üzerinde denetime sahip değildir ve bu nedenle ileti XML veya şemadaki değişikliklere nasıl tepki verdikleri hakkında varsayımlar yapamaz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-131">In many scenarios when changing versions is an issue, the service developer does not have control over the clients and therefore cannot make assumptions about how they would react to changes in the message XML or schema.</span></span> <span data-ttu-id="bd8e9-132">Bu durumlarda, yeni iletilerin iki nedenden dolayı eski şemaya göre doğrulanabileceğini garanti etmeniz gerekir:</span><span class="sxs-lookup"><span data-stu-id="bd8e9-132">In these cases, you must guarantee that the new messages will validate against the old schema, for two reasons:</span></span>  
  
- <span data-ttu-id="bd8e9-133">Eski istemciler şemanın değişmeyecek varsayımıyla geliştirilmiştir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-133">The old clients were developed with the assumption that the schema will not change.</span></span> <span data-ttu-id="bd8e9-134">Şimdiye kadar tasarlandıkları iletileri işleyemeyebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-134">They may fail to process messages that they were never designed for.</span></span>  
  
- <span data-ttu-id="bd8e9-135">Eski istemciler, iletileri işlemeye çalışmadan önce eski şemaya göre gerçek şema doğrulaması gerçekleştirebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-135">The old clients may perform actual schema validation against the old schema before even attempting to process the messages.</span></span>  
  
 <span data-ttu-id="bd8e9-136">Bu senaryolarda önerilen yaklaşım, var olan veri sözleşmelerini sabit olarak değerlendirmek ve benzersiz XML nitelikli adlarıyla yenilerini oluşturmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-136">The recommended approach in such scenarios is to treat existing data contracts as immutable and create new ones with unique XML qualified names.</span></span> <span data-ttu-id="bd8e9-137">Hizmet geliştiricisi daha sonra mevcut bir hizmet sözleşmesine yeni yöntemler ekler ya da yeni veri sözleşmesini kullanan yöntemlerle yeni bir hizmet sözleşmesi oluşturur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-137">The service developer would then either add new methods to an existing service contract or create a new service contract with methods that use the new data contract.</span></span>  
  
 <span data-ttu-id="bd8e9-138">Genellikle bir hizmet geliştiricisinin, veri sözleşmesinin tüm sürümlerinde çalışması gereken bir iş mantığı yazması ve veri sözleşmesinin her sürümü için sürüme özgü iş kodu olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-138">It will often be the case that a service developer needs to write some business logic that should run within all versions of a data contract plus version-specific business code for each version of the data contract.</span></span> <span data-ttu-id="bd8e9-139">Bu konunun sonundaki ek, arabirimlerin bu gereksinimi karşılamak için nasıl kullanılabileceğini açıklar.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-139">The appendix at the end of this topic explains how interfaces can be used to satisfy this need.</span></span>  
  
### <a name="lax-versioning"></a><span data-ttu-id="bd8e9-140">LAX sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-140">Lax Versioning</span></span>  
 <span data-ttu-id="bd8e9-141">Diğer birçok senaryoda, hizmet geliştiricisi, veri sözleşmesine yeni ve isteğe bağlı bir üyenin eklenmesinin mevcut istemcileri bozmayacak şekilde varsayımını yapabilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-141">In many other scenarios, the service developer can make the assumption that adding a new, optional member to the data contract will not break existing clients.</span></span> <span data-ttu-id="bd8e9-142">Bu, hizmet geliştiricisi 'nin mevcut istemcilerin şema doğrulaması yapıp gerçekleştirmediğini ve bilinmeyen veri üyelerini yoksaymalarını araştırmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-142">This requires the service developer to investigate whether existing clients are not performing schema validation and that they ignore unknown data members.</span></span> <span data-ttu-id="bd8e9-143">Bu senaryolarda, yeni üyeleri bölünemez bir şekilde eklemek için veri sözleşmesi özelliklerinden faydalanmak mümkündür.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-143">In these scenarios, it is possible to take advantage of data contract features for adding new members in a nonbreaking way.</span></span> <span data-ttu-id="bd8e9-144">Hizmet geliştiricisi, sürüm için veri sözleşmesi özelliklerinin hizmetin ilk sürümü için zaten kullanılmış olması durumunda bu varsayımını güvenle yapabilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-144">The service developer can make this assumption with confidence if the data contract features for versioning were already used for the first version of the service.</span></span>  
  
 <span data-ttu-id="bd8e9-145">WCF, ASP.NET Web Hizmetleri ve diğer birçok Web hizmeti yığını *LAX sürüm oluşturmayı*destekler: Yani, alınan verilerdeki yeni bilinmeyen veri üyeleri için özel durumlar oluşturmaz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-145">WCF, ASP.NET Web Services, and many other Web service stacks support *lax versioning*: that is, they do not throw exceptions for new unknown data members in received data.</span></span>  
  
 <span data-ttu-id="bd8e9-146">Yeni bir üyenin eklenmesi, var olan istemcileri bozmayacak şekilde çok daha kolay bir şekilde inanacaktır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-146">It is easy to mistakenly believe that adding a new member will not break existing clients.</span></span> <span data-ttu-id="bd8e9-147">Tüm istemcilerin LAX sürümü oluşturma işlemi yaptığından emin değilseniz, katı sürüm oluşturma yönergelerini kullanmak ve veri sözleşmelerini sabit olarak değerlendirmek için öneri önerilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-147">If you are unsure that all clients can handle lax versioning, the recommendation is to use the strict versioning guidelines and treat data contracts as immutable.</span></span>  
  
 <span data-ttu-id="bd8e9-148">Veri sözleşmelerinin hem LAX hem de katı sürümü oluşturma hakkında ayrıntılı yönergeler için bkz. [En Iyi uygulamalar: veri sözleşmesi sürümü oluşturma](best-practices-data-contract-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="bd8e9-148">For detailed guidelines for both lax and strict versioning of data contracts, see [Best Practices: Data Contract Versioning](best-practices-data-contract-versioning.md).</span></span>  
  
### <a name="distinguishing-between-data-contract-and-net-types"></a><span data-ttu-id="bd8e9-149">Veri sözleşmesi ve .NET türleri arasında ayrım</span><span class="sxs-lookup"><span data-stu-id="bd8e9-149">Distinguishing Between Data Contract and .NET Types</span></span>  
 <span data-ttu-id="bd8e9-150">Bir .NET sınıfı veya yapısı, sınıfa <xref:System.Runtime.Serialization.DataContractAttribute> özniteliği uygulanarak veri sözleşmesi olarak yansıtılyabilirler.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-150">A .NET class or structure can be projected as a data contract by applying the <xref:System.Runtime.Serialization.DataContractAttribute> attribute to the class.</span></span> <span data-ttu-id="bd8e9-151">.NET türü ve veri sözleşmesi projeksiyonları iki ayrı önemlidir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-151">The .NET type and its data contract projections are two distinct matters.</span></span> <span data-ttu-id="bd8e9-152">Aynı veri anlaşması projeksiyonu ile birden çok .NET türü olması mümkündür.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-152">It is possible to have multiple .NET types with the same data contract projection.</span></span> <span data-ttu-id="bd8e9-153">Bu ayrım özellikle, tasarlanan veri sözleşmesini koruyarak .NET türünü değiştirmenize olanak tanıyan yararlı olur ve böylece sözcüğün katı anlamda bile mevcut istemcilerle uyumluluğu sürdürmenize yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-153">This distinction is especially useful in allowing you to change the .NET type while maintaining the projected data contract, thereby maintaining compatibility with existing clients even in the strict sense of the word.</span></span> <span data-ttu-id="bd8e9-154">.NET türü ve veri sözleşmesi arasında bu ayrımı sürdürmek için her zaman yapmanız gereken iki şey vardır:</span><span class="sxs-lookup"><span data-stu-id="bd8e9-154">There are two things you should always do to maintain this distinction between .NET type and data contract:</span></span>  
  
- <span data-ttu-id="bd8e9-155">Bir <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> ve <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>belirtin.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-155">Specify a <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A> and <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>.</span></span> <span data-ttu-id="bd8e9-156">.NET türünün adının ve ad alanının sözleşmede gösterilmesini engellemek için, her zaman veri sözleşmeniz adını ve ad alanını belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-156">You should always specify the name and namespace of your data contract to prevent your .NET type’s name and namespace from being exposed in the contract.</span></span> <span data-ttu-id="bd8e9-157">Bu şekilde, daha sonra .NET ad alanı veya tür adı değiştirmeye karar verirseniz, veri sözleşmeniz aynı kalır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-157">This way, if you decide later to change the .NET namespace or type name, your data contract remains the same.</span></span>  
  
- <span data-ttu-id="bd8e9-158"><xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>belirtin.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-158">Specify <xref:System.Runtime.Serialization.DataMemberAttribute.Name%2A>.</span></span> <span data-ttu-id="bd8e9-159">.NET üye adınızın sözleşmede gösterilmesini engellemek için, her zaman veri üyelerinizin adını belirtmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-159">You should always specify the name of your data members to prevent your .NET member name from being exposed in the contract.</span></span> <span data-ttu-id="bd8e9-160">Bu şekilde, üyenin .NET adını daha sonra değiştirmeye karar verirseniz, veri sözleşmeniz aynı kalır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-160">This way, if you decide later to change the .NET name of the member, your data contract remains the same.</span></span>  
  
### <a name="changing-or-removing-members"></a><span data-ttu-id="bd8e9-161">Üyeleri değiştirme veya kaldırma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-161">Changing or Removing Members</span></span>  
 <span data-ttu-id="bd8e9-162">Bir üyenin adını veya veri türünü değiştirmek ya da veri üyelerini kaldırmak, LAX sürümliğine izin verilse bile Son değişiklik olur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-162">Changing the name or data type of a member, or removing data members is a breaking change even if lax versioning is allowed.</span></span> <span data-ttu-id="bd8e9-163">Bu gerekliyse, yeni bir veri sözleşmesi oluşturun.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-163">If this is necessary, create a new data contract.</span></span>  
  
 <span data-ttu-id="bd8e9-164">Hizmet uyumluluğu yüksek öneme sahip ise, kodunuzda kullanılmayan veri üyelerini yoksaymayı ve bunları yerinde bırakmayı düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-164">If service compatibility is of high importance, you might consider ignoring unused data members in your code and leave them in place.</span></span> <span data-ttu-id="bd8e9-165">Bir veri üyesini birden çok üyeye bölebiliyorsanız, alt düzey istemciler (en son sürüme yükseltilmeyen istemciler) için gerekli bölme ve yeniden toplamayı gerçekleştirebilecek bir özellik olarak var olan üyeyi yerinde bırakmayı düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-165">If you are splitting up a data member into multiple members, you might consider leaving the existing member in place as a property that can perform the required splitting and re-aggregation for down-level clients (clients that are not upgraded to the latest version).</span></span>  
  
 <span data-ttu-id="bd8e9-166">Benzer şekilde, veri sözleşmesinin adı veya ad alanındaki değişiklikler de büyük değişikliklerdir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-166">Similarly, changes to the data contract’s name or namespace are breaking changes.</span></span>  
  
### <a name="round-trips-of-unknown-data"></a><span data-ttu-id="bd8e9-167">Bilinmeyen verilerin gidiş dönüşleri</span><span class="sxs-lookup"><span data-stu-id="bd8e9-167">Round-Trips of Unknown Data</span></span>  
 <span data-ttu-id="bd8e9-168">Bazı senaryolarda, yeni bir sürüme eklenen üyelerden gelen bilinmeyen veriler "gidiş dönüş" için bir gereksinim vardır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-168">In some scenarios, there is a need to "round-trip" unknown data that comes from members added in a new version.</span></span> <span data-ttu-id="bd8e9-169">Örneğin, "versionNew" hizmeti, yeni eklenen bazı üyelere "versionOld" istemcisine veri gönderir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-169">For example, a "versionNew" service sends data with some newly added members to a "versionOld" client.</span></span> <span data-ttu-id="bd8e9-170">İstemci, iletiyi işlerken yeni eklenen üyeleri yoksayar, ancak yeni eklenen üyeler de dahil olmak üzere aynı verileri versionNew hizmetine geri gönderir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-170">The client ignores the newly added members when processing the message, but it resends that same data, including the newly added members, back to the versionNew service.</span></span> <span data-ttu-id="bd8e9-171">Bunun için tipik senaryo, verilerin hizmetten alındığı, değiştirildiği ve döndürüldüğü veri güncelleştirmeleridir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-171">The typical scenario for this is data updates where data is retrieved from the service, changed, and returned.</span></span>  
  
 <span data-ttu-id="bd8e9-172">Belirli bir tür için gidiş-dönüşü etkinleştirmek üzere, türün <xref:System.Runtime.Serialization.IExtensibleDataObject> arabirimini uygulaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-172">To enable round-tripping for a particular type, the type must implement the <xref:System.Runtime.Serialization.IExtensibleDataObject> interface.</span></span> <span data-ttu-id="bd8e9-173">Arabirim bir özellik içerir, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> <xref:System.Runtime.Serialization.ExtensionDataObject> türünü döndürür.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-173">The interface contains one property, <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> that returns the <xref:System.Runtime.Serialization.ExtensionDataObject> type.</span></span> <span data-ttu-id="bd8e9-174">Özelliği, geçerli sürüme bilinmeyen veri sözleşmesinin gelecekteki sürümlerindeki verileri depolamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-174">The property is used to store any data from future versions of the data contract that is unknown to the current version.</span></span> <span data-ttu-id="bd8e9-175">Bu veriler istemci için opaktır, ancak örnek serileştirildiğinde <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> özelliğinin içeriği, veri sözleşmesinin üyelerinin verileri ile yazılır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-175">This data is opaque to the client, but when the instance is serialized, the content of the <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A> property is written with the rest of the data contract members' data.</span></span>  
  
 <span data-ttu-id="bd8e9-176">Tüm türlerinizin, yeni ve bilinmeyen gelecekteki üyelere uyum sağlaması için bu arabirimi uygulaması önerilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-176">It is recommended that all your types implement this interface to accommodate new and unknown future members.</span></span>  
  
### <a name="data-contract-libraries"></a><span data-ttu-id="bd8e9-177">Veri sözleşmesi kitaplıkları</span><span class="sxs-lookup"><span data-stu-id="bd8e9-177">Data Contract Libraries</span></span>  
 <span data-ttu-id="bd8e9-178">Bir sözleşmenin merkezi bir depoya yayımlandığı veri sözleşmeleri kitaplıkları olabilir ve hizmet ve tür uygulayıcıları, bu depodan veri sözleşmeleri uygular ve kullanıma sunar.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-178">There may be libraries of data contracts where a contract is published to a central repository, and service and type implementers implement and expose data contracts from that repository.</span></span> <span data-ttu-id="bd8e9-179">Bu durumda, depoya bir veri sözleşmesi yayımladığınızda, kendisini uygulayan türler oluşturan herhangi bir denetiminiz yoktur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-179">In that case, when you publish a data contract to the repository, you have no control over who creates types that implement it.</span></span> <span data-ttu-id="bd8e9-180">Bu nedenle, sözleşmeyi yayımlandıktan sonra değiştiremezsiniz ve etkili bir şekilde sabit hale gelir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-180">Thus, you cannot modify the contract once it is published, rendering it effectively immutable.</span></span>  
  
### <a name="when-using-the-xmlserializer"></a><span data-ttu-id="bd8e9-181">XmlSerializer kullanılırken</span><span class="sxs-lookup"><span data-stu-id="bd8e9-181">When Using the XmlSerializer</span></span>  
 <span data-ttu-id="bd8e9-182"><xref:System.Xml.Serialization.XmlSerializer> sınıfı kullanılırken aynı sürüm oluşturma ilkeleri uygulanır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-182">The same versioning principles apply when using the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="bd8e9-183">Katı sürüm oluşturma gerektiğinde, veri sözleşmelerini sabit olarak değerlendirin ve yeni sürümler için benzersiz ve nitelikli adlarla yeni veri sözleşmeleri oluşturun.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-183">When strict versioning is required, treat data contracts as immutable and create new data contracts with unique, qualified names for the new versions.</span></span> <span data-ttu-id="bd8e9-184">LAX sürümü oluşturma 'nın kullanılabilir olduğundan emin olduğunuzda, yeni sürümlere yeni seri hale getirilebilir Üyeler ekleyebilirsiniz, ancak var olan üyeleri değiştirmez veya kaldıramazsınız.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-184">When you are sure that lax versioning can be used, you can add new serializable members in new versions but not change or remove existing members.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bd8e9-185"><xref:System.Xml.Serialization.XmlSerializer>, bilinmeyen verilerin gidiş dönüşü desteklemek için <xref:System.Xml.Serialization.XmlAnyElementAttribute> ve <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> özniteliklerini kullanır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-185">The <xref:System.Xml.Serialization.XmlSerializer> uses the <xref:System.Xml.Serialization.XmlAnyElementAttribute> and <xref:System.Xml.Serialization.XmlAnyAttributeAttribute> attributes to support round-tripping of unknown data.</span></span>  
  
## <a name="message-contract-versioning"></a><span data-ttu-id="bd8e9-186">İleti sözleşmesi sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-186">Message Contract Versioning</span></span>  
 <span data-ttu-id="bd8e9-187">İleti sözleşmesi sürümü oluşturma yönergeleri, veri sözleşmelerinin sürümü oluşturma konusunda çok benzer.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-187">The guidelines for message contract versioning are very similar to versioning data contracts.</span></span> <span data-ttu-id="bd8e9-188">Katı sürüm oluşturma gerekliyse, ileti gövdesini değiştirmemelisiniz, bunun yerine benzersiz bir nitelenmiş ada sahip yeni bir ileti sözleşmesi oluşturmalısınız.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-188">If strict versioning is required, you should not change your message body but instead create a new message contract with a unique qualified name.</span></span> <span data-ttu-id="bd8e9-189">LAX sürümü oluşturmayı biliyorsanız, yeni ileti gövdesi parçalarını ekleyebilir, ancak varolanları değiştirmez veya kaldırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-189">If you know that you can use lax versioning, you can add new message body parts but not change or remove existing ones.</span></span> <span data-ttu-id="bd8e9-190">Bu kılavuz, hem çıplak hem de Sarmalanan ileti sözleşmeleri için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-190">This guidance applies both to bare and wrapped message contracts.</span></span>  
  
 <span data-ttu-id="bd8e9-191">Katı sürüm oluşturma kullanımda olsa bile ileti üstbilgileri her zaman eklenebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-191">Message headers can always be added, even if strict versioning is in use.</span></span> <span data-ttu-id="bd8e9-192">MustUnderstand bayrağı sürümü oluşturmayı etkileyebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-192">The MustUnderstand flag may affect versioning.</span></span> <span data-ttu-id="bd8e9-193">Genel olarak, WCF 'deki üst bilgiler için sürüm oluşturma modeli SOAP belirtiminde açıklanacaktır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-193">In general, the versioning model for headers in WCF is as described in the SOAP specification.</span></span>  
  
## <a name="service-contract-versioning"></a><span data-ttu-id="bd8e9-194">Hizmet sözleşmesi sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-194">Service Contract Versioning</span></span>  
 <span data-ttu-id="bd8e9-195">Veri sözleşmesi sürümü oluşturma ile benzer şekilde, hizmet sözleşmesi sürümü oluşturma işlemi ekleme, değiştirme ve kaldırma işlemlerini de kapsar.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-195">Similar to data contract versioning, service contract versioning also involves adding, changing, and removing operations.</span></span>  
  
### <a name="specifying-name-namespace-and-action"></a><span data-ttu-id="bd8e9-196">Ad, ad alanı ve eylem belirtme</span><span class="sxs-lookup"><span data-stu-id="bd8e9-196">Specifying Name, Namespace, and Action</span></span>  
 <span data-ttu-id="bd8e9-197">Varsayılan olarak, bir hizmet sözleşmesinin adı arabirimin adıdır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-197">By default, the name of a service contract is the name of the interface.</span></span> <span data-ttu-id="bd8e9-198">Varsayılan ad alanı "http://tempuri.org" ve her bir işlemin eylemi "http://tempuri.org/contractname/methodname".</span><span class="sxs-lookup"><span data-stu-id="bd8e9-198">Its default namespace is "http://tempuri.org", and each operation’s action is "http://tempuri.org/contractname/methodname".</span></span> <span data-ttu-id="bd8e9-199">Hizmet sözleşmesi için bir ad ve ad alanı ve "http://tempuri.org" kullanmaktan kaçınmak ve arabirim ve yöntem adlarının hizmetin sözleşmesinde gösterilmesini önlemek için her işlem için bir eylem belirlemeniz önerilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-199">It is recommended that you explicitly specify a name and namespace for the service contract, and an action for each operation to avoid using "http://tempuri.org" and to prevent interface and method names from being exposed in the service’s contract.</span></span>  
  
### <a name="adding-parameters-and-operations"></a><span data-ttu-id="bd8e9-200">Parametreleri ve Işlemleri ekleme</span><span class="sxs-lookup"><span data-stu-id="bd8e9-200">Adding Parameters and Operations</span></span>  
 <span data-ttu-id="bd8e9-201">Hizmet tarafından sunulan hizmet işlemlerinin eklenmesi, var olan istemcilerin bu yeni işlemler konusunda endişe duymadığı için bölünemez bir değişiklik.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-201">Adding service operations exposed by the service is a nonbreaking change because existing clients need not be concerned about those new operations.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="bd8e9-202">Bir çift yönlü geri çağırma sözleşmesine işlemler eklemek, önemli bir değişiklik olur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-202">Adding operations to a duplex callback contract is a breaking change.</span></span>  
  
### <a name="changing-operation-parameter-or-return-types"></a><span data-ttu-id="bd8e9-203">Işlem parametresini veya dönüş türlerini değiştirme</span><span class="sxs-lookup"><span data-stu-id="bd8e9-203">Changing Operation Parameter or Return Types</span></span>  
 <span data-ttu-id="bd8e9-204">Yeni tür, eski tür tarafından uygulanan aynı veri sözleşmesini uygularsa, parametre veya dönüş türlerinin genel olarak değiştirilmesi genellikle bir son değişiklik olur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-204">Changing parameter or return types generally is a breaking change unless the new type implements the same data contract implemented by the old type.</span></span> <span data-ttu-id="bd8e9-205">Böyle bir değişiklik yapmak için, hizmet sözleşmesine yeni bir işlem ekleyin veya yeni bir hizmet sözleşmesi tanımlayın.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-205">To make such a change, add a new operation to the service contract or define a new service contract.</span></span>  
  
### <a name="removing-operations"></a><span data-ttu-id="bd8e9-206">Işlemleri kaldırma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-206">Removing Operations</span></span>  
 <span data-ttu-id="bd8e9-207">İşlemleri kaldırma işlemi de son değişiklik olur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-207">Removing operations is also a breaking change.</span></span> <span data-ttu-id="bd8e9-208">Böyle bir değişiklik yapmak için yeni bir hizmet sözleşmesi tanımlayın ve yeni bir uç noktada kullanıma sunun.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-208">To make such a change, define a new service contract and expose it on a new endpoint.</span></span>  
  
### <a name="fault-contracts"></a><span data-ttu-id="bd8e9-209">Hata sözleşmeleri</span><span class="sxs-lookup"><span data-stu-id="bd8e9-209">Fault Contracts</span></span>  
 <span data-ttu-id="bd8e9-210"><xref:System.ServiceModel.FaultContractAttribute> özniteliği, bir hizmet sözleşmesi geliştiricisinin, sözleşmenin işlemlerinden döndürülebilecek hatalar hakkında bilgi belirtmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-210">The <xref:System.ServiceModel.FaultContractAttribute> attribute enables a service contract developer to specify information about faults that can be returned from the contract's operations.</span></span>  
  
 <span data-ttu-id="bd8e9-211">Bir hizmetin sözleşmesinde açıklanan hataların listesi ayrıntılı olarak değerlendirilmez.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-211">The list of faults described in a service's contract is not considered exhaustive.</span></span> <span data-ttu-id="bd8e9-212">Herhangi bir zamanda, bir işlem sözleşmede açıklanmayan hatalar döndürebilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-212">At any time, an operation may return faults that are not described in its contract.</span></span> <span data-ttu-id="bd8e9-213">Bu nedenle, sözleşmede açıklanan hata kümesini değiştirmenin bölünmesi düşünülmez.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-213">Therefore changing the set of faults described in the contract is not considered breaking.</span></span> <span data-ttu-id="bd8e9-214">Örneğin, <xref:System.ServiceModel.FaultContractAttribute> kullanarak sözleşmeye yeni bir hata ekleme veya mevcut bir hatayı sözleşmeden kaldırma.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-214">For example, adding a new fault to the contract using the <xref:System.ServiceModel.FaultContractAttribute> or removing an existing fault from the contract.</span></span>  
  
### <a name="service-contract-libraries"></a><span data-ttu-id="bd8e9-215">Hizmet sözleşmesi kitaplıkları</span><span class="sxs-lookup"><span data-stu-id="bd8e9-215">Service Contract Libraries</span></span>  
 <span data-ttu-id="bd8e9-216">Kuruluşların, bir sözleşmenin merkezi bir depoya yayımlandığı ve hizmet uygulayıcıları bu depodan sözleşme uygulayan sözleşmeler kitaplıkları olabilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-216">Organizations may have libraries of contracts where a contract is published to a central repository and service implementers implement contracts from that repository.</span></span> <span data-ttu-id="bd8e9-217">Bu durumda, depoya bir hizmet sözleşmesi yayımladığınızda, kendisini uygulayan hizmetler oluşturan herhangi bir denetiminiz yoktur.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-217">In this case, when you publish a service contract to the repository you have no control over who creates services that implement it.</span></span> <span data-ttu-id="bd8e9-218">Bu nedenle, hizmet sözleşmesini yayımlandıktan sonra değiştirilemez, böylece etkili bir şekilde işleme alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-218">Therefore, you cannot modify the service contract once published, rendering it effectively immutable.</span></span> <span data-ttu-id="bd8e9-219">WCF, mevcut sözleşmeleri genişleten yeni bir sözleşme oluşturmak için kullanılabilecek sözleşme devralmayı destekler.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-219">WCF supports contract inheritance, which can be used to create a new contract that extends existing contracts.</span></span> <span data-ttu-id="bd8e9-220">Bu özelliği kullanmak için eski hizmet sözleşmesi arabiriminden devralan yeni bir hizmet sözleşmesi arabirimi tanımlayın ve ardından yeni arabirime Yöntemler ekleyin.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-220">To use this feature, define a new service contract interface that inherits from the old service contract interface, then add methods to the new interface.</span></span> <span data-ttu-id="bd8e9-221">Daha sonra, yeni sözleşmeyi uygulamak için eski sözleşmeyi uygulayan hizmeti değiştirirsiniz ve "versionOld" uç nokta tanımını yeni sözleşmeyi kullanacak şekilde değiştirebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-221">You then change the service that implements the old contract to implement the new contract and change the "versionOld" endpoint definition to use the new contract.</span></span> <span data-ttu-id="bd8e9-222">"VersionOld" istemcileri için uç nokta, "versionOld" sözleşmesini açığa çıkarmasına devam edecektir; "versionNew" istemcileri için uç nokta "versionNew" sözleşmesini kullanıma sunacaktır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-222">To "versionOld" clients, the endpoint will continue to appear as exposing the "versionOld" contract; to "versionNew" clients, the endpoint will appear to expose the "versionNew" contract.</span></span>  
  
## <a name="address-and-binding-versioning"></a><span data-ttu-id="bd8e9-223">Adres ve bağlama sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-223">Address and Binding Versioning</span></span>  
 <span data-ttu-id="bd8e9-224">İstemcilerin yeni uç nokta adresini veya bağlamayı dinamik olarak bulamadığı durumlar, uç nokta adresi ve bağlamadaki değişiklikler ortadan kaldırılır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-224">Changes to endpoint address and binding are breaking changes unless clients are capable of dynamically discovering the new endpoint address or binding.</span></span> <span data-ttu-id="bd8e9-225">Bu özelliği uygulamaya yönelik bir mekanizma, bir evrensel keşif açıklaması ve Tümleştirme (UDDI) kayıt defteri ve istemcinin bir uç noktayla iletişim kurmayı denediği ve hata durumunda iyi bilinen bir UDDI 'yı sorgulayan bir UDDI çağırma modelini kullanmaktır geçerli uç nokta meta verileri için kayıt defteri.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-225">One mechanism for implementing this capability is by using a Universal Discovery Description and Integration (UDDI) registry and the UDDI Invocation Pattern where a client attempts to communicate with an endpoint and, upon failure, queries a well-known UDDI registry for the current endpoint metadata.</span></span> <span data-ttu-id="bd8e9-226">İstemci daha sonra uç noktayla iletişim kurmak için bu meta verilerden adresi ve bağlamayı kullanır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-226">The client then uses the address and binding from this metadata to communicate with the endpoint.</span></span> <span data-ttu-id="bd8e9-227">Bu iletişim başarılı olursa istemci, daha sonra kullanmak üzere adresi ve bağlama bilgilerini önbelleğe alır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-227">If this communication succeeds, the client caches the address and binding information for future use.</span></span>  
  
## <a name="routing-service-and-versioning"></a><span data-ttu-id="bd8e9-228">Yönlendirme hizmeti ve sürümü oluşturma</span><span class="sxs-lookup"><span data-stu-id="bd8e9-228">Routing Service and Versioning</span></span>  
 <span data-ttu-id="bd8e9-229">Bir hizmette yapılan değişiklikler önemli değişiklikler olduğunda ve hizmetin iki veya daha fazla farklı sürümünü aynı anda çalıştıran bir hizmete sahip olmanız gerekiyorsa, iletileri uygun hizmet örneğine yönlendirmek için WCF yönlendirme hizmetini kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-229">If the changes made to a service are breaking changes and you need to have two or more different versions of a service running simultaneously you can use the WCF Routing Service to route messages to the appropriate service instance.</span></span> <span data-ttu-id="bd8e9-230">WCF yönlendirme hizmeti, içerik tabanlı yönlendirme kullanır, diğer bir deyişle, iletinin nereye yönlendirileceğini anlamak için ileti içindeki bilgileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-230">The WCF Routing Service uses content-based routing, in other words, it uses information within the message to determine where to route the message.</span></span> <span data-ttu-id="bd8e9-231">WCF yönlendirme hizmeti hakkında daha fazla bilgi için bkz. [yönlendirme hizmeti](./feature-details/routing-service.md).</span><span class="sxs-lookup"><span data-stu-id="bd8e9-231">For more information about the WCF Routing Service see [Routing Service](./feature-details/routing-service.md).</span></span> <span data-ttu-id="bd8e9-232">Hizmet sürümü oluşturma için WCF yönlendirme hizmetini nasıl kullanacağınızı gösteren bir örnek için bkz. [nasıl yapılır: hizmet sürümü oluşturma](./feature-details/how-to-service-versioning.md).</span><span class="sxs-lookup"><span data-stu-id="bd8e9-232">For an example of how to use the WCF Routing Service for service versioning see [How To: Service Versioning](./feature-details/how-to-service-versioning.md).</span></span>  
  
## <a name="appendix"></a><span data-ttu-id="bd8e9-233">Yer</span><span class="sxs-lookup"><span data-stu-id="bd8e9-233">Appendix</span></span>  
 <span data-ttu-id="bd8e9-234">Katı sürüm oluşturma gerektiğinde genel veri anlaşması sürüm oluşturma kılavuzu, veri sözleşmelerini sabit olarak değerlendirmek ve değişiklikler gerektiğinde yenilerini oluşturmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-234">The general data contract versioning guidance when strict versioning is needed is to treat data contracts as immutable and create new ones when changes are required.</span></span> <span data-ttu-id="bd8e9-235">Her yeni veri sözleşmesi için yeni bir sınıf oluşturulması gerekir. bu nedenle, eski veri sözleşmesi sınıfına göre yazılmış olan kodu almak zorunda kalmamak ve yeni veri sözleşmesi sınıfına yeniden yazmak için bir mekanizma gereklidir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-235">A new class needs to be created for each new data contract, so a mechanism is needed to avoid having to take existing code that was written in terms of the old data contract class and rewrite it in terms of the new data contract class.</span></span>  
  
 <span data-ttu-id="bd8e9-236">Bu tür bir mekanizma, her bir veri sözleşmesinin üyelerini tanımlamak ve arabirimleri uygulayan veri sözleşmesi sınıfları yerine iç uygulama kodu yazmak için arabirimler kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-236">One such mechanism is to use interfaces to define the members of each data contract and write internal implementation code in terms of the interfaces rather than the data contract classes that implement the interfaces.</span></span> <span data-ttu-id="bd8e9-237">Bir hizmetin 1. sürümü için aşağıdaki kod `IPurchaseOrderV1` arabirimini ve `PurchaseOrderV1` ' i gösterir:</span><span class="sxs-lookup"><span data-stu-id="bd8e9-237">The following code for version 1 of a service shows an `IPurchaseOrderV1` interface and a `PurchaseOrderV1`:</span></span>  
  
```csharp  
public interface IPurchaseOrderV1  
{  
    string OrderId { get; set; }  
    string CustomerId { get; set; }  
}  
  
[DataContract(  
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2005/10/PurchaseOrder")]  
public class PurchaseOrderV1 : IPurchaseOrderV1  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
}  
```  
  
 <span data-ttu-id="bd8e9-238">Hizmet sözleşmesinin işlemleri `PurchaseOrderV1` ' da yazıldığında, gerçek iş mantığı `IPurchaseOrderV1` ' de olabilir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-238">While the service contract’s operations would be written in terms of `PurchaseOrderV1`, the actual business logic would be in terms of `IPurchaseOrderV1`.</span></span> <span data-ttu-id="bd8e9-239">Ardından, sürüm 2 ' de, aşağıdaki kodda gösterildiği gibi yeni bir `IPurchaseOrderV2` arabirimi ve yeni bir `PurchaseOrderV2` sınıfı vardır:</span><span class="sxs-lookup"><span data-stu-id="bd8e9-239">Then, in version 2, there would be a new `IPurchaseOrderV2` interface and a new `PurchaseOrderV2` class as shown in the following code:</span></span>  
  
```csharp
public interface IPurchaseOrderV2  
{  
    DateTime OrderDate { get; set; }  
}

[DataContract(   
Name = "PurchaseOrder",  
Namespace = "http://examples.microsoft.com/WCF/2006/02/PurchaseOrder")]  
public class PurchaseOrderV2 : IPurchaseOrderV1, IPurchaseOrderV2  
{  
    [DataMember(...)]  
    public string OrderId {...}  
    [DataMember(...)]  
    public string CustomerId {...}  
    [DataMember(...)]  
    public DateTime OrderDate { ... }  
}  
```  
  
 <span data-ttu-id="bd8e9-240">Hizmet sözleşmesi, `PurchaseOrderV2` ' da yazılı yeni işlemleri içerecek şekilde güncelleştirilecektir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-240">The service contract would be updated to include new operations that are written in terms of `PurchaseOrderV2`.</span></span> <span data-ttu-id="bd8e9-241">`IPurchaseOrderV1` olarak yazılan mevcut iş mantığı `PurchaseOrderV2` ve `OrderDate` özelliğin `IPurchaseOrderV2`açısından yazılması gereken yeni iş mantığı için çalışmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-241">Existing business logic written in terms of `IPurchaseOrderV1` would continue to work for `PurchaseOrderV2` and new business logic that needs the `OrderDate` property would be written in terms of `IPurchaseOrderV2`.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="bd8e9-242">Ayrıca bkz.</span><span class="sxs-lookup"><span data-stu-id="bd8e9-242">See also</span></span>

- <xref:System.Runtime.Serialization.DataContractSerializer>
- <xref:System.Runtime.Serialization.DataContractAttribute>
- <xref:System.Runtime.Serialization.DataContractAttribute.Name%2A>
- <xref:System.Runtime.Serialization.DataContractAttribute.Namespace%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.Order%2A>
- <xref:System.Runtime.Serialization.DataMemberAttribute.IsRequired%2A>
- <xref:System.Runtime.Serialization.IExtensibleDataObject>
- <xref:System.Runtime.Serialization.ExtensionDataObject>
- <xref:System.Runtime.Serialization.IExtensibleDataObject.ExtensionData%2A>
- <xref:System.Xml.Serialization.XmlSerializer>
- [<span data-ttu-id="bd8e9-243">Veri Anlaşması Eşitliği</span><span class="sxs-lookup"><span data-stu-id="bd8e9-243">Data Contract Equivalence</span></span>](./feature-details/data-contract-equivalence.md)
- [<span data-ttu-id="bd8e9-244">Sürüm Toleranslı Seri Hale Getirme Geri Çağrıları</span><span class="sxs-lookup"><span data-stu-id="bd8e9-244">Version-Tolerant Serialization Callbacks</span></span>](./feature-details/version-tolerant-serialization-callbacks.md)
