---
title: Mikro hizmet başına veritabanı
description: Monolitik ve bulut ait uygulamalarda kontrast veri depolama.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141451"
---
# <a name="database-per-microservice"></a><span data-ttu-id="4ee94-103">Mikro hizmet başına veritabanı</span><span class="sxs-lookup"><span data-stu-id="4ee94-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="4ee94-104">Bu kitapta gördüğümüz gibi, bulut açi yaklaşımı uygulamaları tasarlama, dağıtma ve yönetme şeklinizi değiştirir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="4ee94-105">Ayrıca, verileri yönetme ve depolama şeklinizi de değiştirir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="4ee94-106">Şekil 5-1 farklılıkları karşılar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-106">Figure 5-1 contrasts the differences.</span></span>

![Bulut ayarı uygulamalarda veri depolama](./media/distributed-data.png)

<span data-ttu-id="4ee94-108">**Şekil 5-1**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-108">**Figure 5-1**.</span></span> <span data-ttu-id="4ee94-109">Bulut ait uygulamalarda veri yönetimi</span><span class="sxs-lookup"><span data-stu-id="4ee94-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="4ee94-110">Deneyimli geliştiriciler şekil 5-1'in sol tarafındaki mimariyi kolayca tanıyacaktır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="4ee94-111">Bu *yekpare uygulamada,* iş hizmeti bileşenleri paylaşılan bir hizmet katmanında bir araya getirin ve tek bir ilişkisel veritabanından veri paylaşır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="4ee94-112">Birçok yönden, tek bir veritabanı veri yönetimini basit tutar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="4ee94-113">Verileri birden çok tabloda sorgulamak kolaydır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="4ee94-114">Verilerde yapılan değişiklikler birlikte güncellenir veya hepsi geri alır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="4ee94-115">[ACID işlemleri](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) güçlü ve anında tutarlılığı garanti altına adamaktadır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="4ee94-116">Bulut-yerli için tasarım, farklı bir yaklaşım benimsiyoruz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="4ee94-117">Şekil 5-1'in sağ tarafında, iş işlevlerinin küçük, bağımsız mikro hizmetlere nasıl ayrıştırdığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="4ee94-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="4ee94-118">Her microservice belirli bir iş yeteneği ve kendi verilerini kapsüller.</span><span class="sxs-lookup"><span data-stu-id="4ee94-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="4ee94-119">Yekpare veritabanı, her biri bir microservice ile hizalayan çok daha küçük veritabanları ile dağıtılmış bir veri modeli ne ayrılır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="4ee94-120">Duman temizlendiğinde, *mikrohizmet başına*bir veritabanı ortaya çıkaran bir tasarım ile ortaya çıkar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="4ee94-121">Neden?</span><span class="sxs-lookup"><span data-stu-id="4ee94-121">Why?</span></span>

<span data-ttu-id="4ee94-122">Mikro hizmet başına bu veritabanı, özellikle hızla gelişmesi ve büyük ölçekli desteklenmesi gereken sistemler için birçok avantaj sağlar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="4ee94-123">Bu model ile...</span><span class="sxs-lookup"><span data-stu-id="4ee94-123">With this model...</span></span>

- <span data-ttu-id="4ee94-124">Etki alanı verileri hizmet içinde kapsüllenir</span><span class="sxs-lookup"><span data-stu-id="4ee94-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="4ee94-125">Veri şeması diğer hizmetleri doğrudan etkilemeden gelişebilir</span><span class="sxs-lookup"><span data-stu-id="4ee94-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="4ee94-126">Her veri deposu bağımsız olarak ölçeklendirilebilir</span><span class="sxs-lookup"><span data-stu-id="4ee94-126">Each data store can independently scale</span></span>
- <span data-ttu-id="4ee94-127">Bir hizmetteki veri deposu hatası diğer hizmetleri doğrudan etkilemez</span><span class="sxs-lookup"><span data-stu-id="4ee94-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="4ee94-128">Verileri ayırma, her bir mikro hizmetin iş yükü, depolama gereksinimleri ve okuma/yazma desenleri için en iyi şekilde optimize edilmiş veri deposu türünü uygulamasına da olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="4ee94-129">Seçenekler ilişkisel, belge, anahtar değeri ve hatta grafik tabanlı veri depolarını içerir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="4ee94-130">Şekil 5-2, bulut-yerel bir sistemde çok dillikalıcılık ilkesini sunar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Polyglot veri kalıcılığı](./media/polyglot-data-persistence.png)

<span data-ttu-id="4ee94-132">**Şekil 5-2**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-132">**Figure 5-2**.</span></span> <span data-ttu-id="4ee94-133">Polyglot veri kalıcılığı</span><span class="sxs-lookup"><span data-stu-id="4ee94-133">Polyglot data persistence</span></span>

<span data-ttu-id="4ee94-134">Önceki şekilde, her bir mikro hizmetin farklı türde bir veri deposunu nasıl desteklediğini not edin.</span><span class="sxs-lookup"><span data-stu-id="4ee94-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="4ee94-135">Ürün kataloğu microservice, temel verilerinin zengin ilişkisel yapısını karşılamak için ilişkisel bir veritabanı tüketir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="4ee94-136">Alışveriş sepeti microservice, basit, anahtar değerli veri deposunu destekleyen dağıtılmış bir önbellek tüketir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="4ee94-137">Sipariş microservice, yüksek hacimli okuma işlemlerini karşılamak için hem yazma işlemleri için bir NoSql belge veritabanı hem de son derece denormalleştirilmiş anahtar/değer deposu tüketir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="4ee94-138">İlişkisel veritabanları karmaşık verilere sahip mikro hizmetler için geçerli liğini korurken, NoSQL veritabanları önemli ölçüde popülerlik kazanmıştır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="4ee94-139">Onlar büyük ölçekli ve yüksek kullanılabilirlik sağlar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="4ee94-140">Onların şemasız doğası geliştiricilerin bozuk para ve zaman alıcı yapmak dakti-sa'lık veri sınıfları ve ORM'ler mimarisinden uzaklaşmalarını sağlar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="4ee94-141">Bu bölümde noSQL veritabanlarını daha sonra ele alıyoruz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="4ee94-142">Verileri ayrı mikro hizmetlere kapsülleme çevikliği, performansı ve ölçeklenebilirliği artırabilirken, aynı zamanda birçok zorluk da sunar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="4ee94-143">Bir sonraki bölümde, bu zorlukların üstesinden gelinmeye yardımcı olacak kalıplar ve uygulamalarla birlikte tartışAcağız.</span><span class="sxs-lookup"><span data-stu-id="4ee94-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="4ee94-144">Servisler arası sorgular</span><span class="sxs-lookup"><span data-stu-id="4ee94-144">Cross-service queries</span></span>

<span data-ttu-id="4ee94-145">Mikro hizmetler bağımsız olsa da ve envanter, sevkiyat veya sipariş gibi belirli işlevsel yeteneklere odaklanırken, sık sık diğer mikro hizmetlerle tümleştirme gerektirir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="4ee94-146">Genellikle tümleştirme, bir microservice'in diğerini veri *sorgulamasını* içerir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="4ee94-147">Şekil 5-3 senaryoyu gösterir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-147">Figure 5-3 shows the scenario.</span></span>

![Mikro hizmetler arasında sorgulama](./media/cross-service-query.png)

<span data-ttu-id="4ee94-149">**Şekil 5-3**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-149">**Figure 5-3**.</span></span> <span data-ttu-id="4ee94-150">Mikro hizmetler arasında sorgulama</span><span class="sxs-lookup"><span data-stu-id="4ee94-150">Querying across microservices</span></span>

<span data-ttu-id="4ee94-151">Önceki şekilde, kullanıcının alışveriş sepetine bir öğe ekleyen bir alışveriş sepeti microservice görüyoruz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="4ee94-152">Bu mikro hizmetin veri deposu sepet ve satır öğesi verileri içerse de, ürün veya fiyatlandırma verilerini korumaz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="4ee94-153">Bunun yerine, bu veri öğeleri katalog ve fiyatlandırma mikroservices aittir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="4ee94-154">Bu bir sorun teşkil sunuyor.</span><span class="sxs-lookup"><span data-stu-id="4ee94-154">This presents a problem.</span></span> <span data-ttu-id="4ee94-155">Alışveriş sepeti microservice, veritabanında ürün veya fiyatlandırma verileri yoksa, kullanıcının alışveriş sepetine nasıl ürün ekleyebilir?</span><span class="sxs-lookup"><span data-stu-id="4ee94-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="4ee94-156">Bölüm 4'te tartışılan seçeneklerden biri, alışveriş sepetinden katalog ve fiyatlandırma mikro hizmetlerine [doğrudan http çağrısıdır.](service-to-service-communication.md#queries)</span><span class="sxs-lookup"><span data-stu-id="4ee94-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="4ee94-157">Ancak, bölüm 4, biz senkron HTTP *birlikte çift* mikrohizmetleri çağırır, onların özerklik azaltarak ve mimari yararları azalan söyledi.</span><span class="sxs-lookup"><span data-stu-id="4ee94-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="4ee94-158">Ayrıca, her hizmet için ayrı gelen ve giden kuyrukları içeren bir istek yanıtde deseni uygulayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="4ee94-159">Ancak, bu desen karmaşıktır ve istek ve yanıt iletilerini ilişkilendirmek için tesisat gerektirir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="4ee94-160">Arka uç mikrohizmet çağrılarını ayırmak la birlikte, arama hizmeti yine de çağrının tamamlanmasını eşzamanlı olarak beklemelidir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="4ee94-161">Ağ tıkanıklığı, geçici hatalar veya aşırı yüklü bir mikro hizmet, uzun süreli ve hatta başarısız işlemlere neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="4ee94-162">Bunun yerine, çapraz hizmet bağımlılıklarını kaldırmak için yaygın olarak kabul gören bir desen, Şekil 5-4'te gösterilen [Materyalize Görünüm Deseni'dir.](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="4ee94-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Maddeleştirilmiş görünüm deseni](./media/materialized-view-pattern.png)

<span data-ttu-id="4ee94-164">**Şekil 5-4**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-164">**Figure 5-4**.</span></span> <span data-ttu-id="4ee94-165">Gerçekleştirilmiş Görünüm Düzeni</span><span class="sxs-lookup"><span data-stu-id="4ee94-165">Materialized View Pattern</span></span>

<span data-ttu-id="4ee94-166">Bu desenle, alışveriş sepeti hizmetine yerel bir veri tablosu *(okuma modeli*olarak bilinir) yersiniz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="4ee94-167">Bu tablo, ürün ve fiyatlandırma mikroservices gerekli verilerin normalleştirilmiş bir kopyasını içerir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="4ee94-168">Verilerin doğrudan alışveriş sepetine kopyalanması, pahalı servisler arası çağrılara duyulan ihtiyacı ortadan kaldırır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="4ee94-169">Hizmete yerel verilerle, hizmetin yanıt süresini ve güvenilirliğini artırırsınız.</span><span class="sxs-lookup"><span data-stu-id="4ee94-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="4ee94-170">Ayrıca, verilerin kendi kopyasına sahip olmak alışveriş sepeti hizmetini daha esnek hale getirir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="4ee94-171">Katalog hizmeti kullanılamıyorsa, alışveriş sepeti hizmetini doğrudan etkilemez.</span><span class="sxs-lookup"><span data-stu-id="4ee94-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="4ee94-172">Alışveriş sepeti kendi mağazasından gelen verilerle çalışmaya devam edebilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="4ee94-173">Bu yaklaşımın yakaladığı fark, artık sisteminizde yinelenen verilerin olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="4ee94-174">Ancak, bulut-yerel sistemlerde verileri *stratejik olarak* çoğaltmak yerleşik bir uygulamadır ve bir anti-desen veya kötü uygulama olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="4ee94-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="4ee94-175">Bir ve *tek bir hizmetin* bir veri kümesine sahip olabileceğini ve bu konuda yetkisahibi olabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="4ee94-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="4ee94-176">Kayıt sistemi güncelleştirildiğinde okunan modelleri eşitlemeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="4ee94-177">Senkronizasyon genellikle Şekil 5.4'te gösterildiği gibi, [yayımla/abone](service-to-service-communication.md#events)oltasıyla eşzamanlı mesajlaşma yoluyla uygulanır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="4ee94-178">Dağıtılmış işlemler</span><span class="sxs-lookup"><span data-stu-id="4ee94-178">Distributed transactions</span></span>

<span data-ttu-id="4ee94-179">Mikro hizmetler arasında veri sorgulamak zor olsa da, çeşitli mikro hizmetler arasında bir işlem uygulamak daha da karmaşıktır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="4ee94-180">Farklı mikro hizmetlerde bağımsız veri kaynakları arasında veri tutarlılığını korumanın doğasında var olan zorluk hafife alınamaz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="4ee94-181">Bulut ait uygulamalarda dağıtılmış hareketlerin olmaması, dağıtılmış hareketleri programlı bir şekilde yönetmeniz gerektiği anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="4ee94-182">*Hemen tutarlılık* lı bir dünyadan nihai *tutarlılığa geçersiniz.*</span><span class="sxs-lookup"><span data-stu-id="4ee94-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="4ee94-183">Şekil 5-5 sorunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-183">Figure 5-5 shows the problem.</span></span>

![Destan deseninde işlem](./media/saga-transaction-operation.png)

<span data-ttu-id="4ee94-185">**Şekil 5-5**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-185">**Figure 5-5**.</span></span> <span data-ttu-id="4ee94-186">Mikro hizmetler arasında bir işlem uygulama</span><span class="sxs-lookup"><span data-stu-id="4ee94-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="4ee94-187">Önceki şekilde, beş bağımsız mikro hizmet bir sipariş oluşturan dağıtılmış bir işlem katılır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="4ee94-188">Her microservice kendi veri deposu tutar ve deposu için yerel bir işlem uygular.</span><span class="sxs-lookup"><span data-stu-id="4ee94-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="4ee94-189">Siparişi oluşturmak için, *her bir* mikro hizmet için yerel işlemin başarılı olması veya *tüm* işlemin iptal edilip geri alması gerekir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="4ee94-190">Yerleşik işlem desteği her mikro hizmetin içinde kullanılabilir olsa da, verileri tutarlı tutmak için beş hizmete de yayılan dağıtılmış bir işlem için destek yoktur.</span><span class="sxs-lookup"><span data-stu-id="4ee94-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="4ee94-191">Bunun yerine, bu dağıtılmış hareketi *programlı bir şekilde*oluşturmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="4ee94-192">Dağıtılmış işlem desteği eklemek için popüler bir desen Saga desenidir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="4ee94-193">Yerel işlemleri programlı ve sıralı olarak gruplandırarak uygulanır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="4ee94-194">Yerel işlemlerden herhangi biri başarısız olursa, Destan işlemi iptal eder ve telafi [edici hareketler](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)kümesi çağırır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="4ee94-195">Telafi edici hareketler, önceki yerel hareketler tarafından yapılan değişiklikleri geri alar ve veri tutarlılığını geri yükler.</span><span class="sxs-lookup"><span data-stu-id="4ee94-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="4ee94-196">Şekil 5-6, Saga deseniyle başarısız bir işlemi gösterir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Destan deseninde geri dön](./media/saga-rollback-operation.png)

<span data-ttu-id="4ee94-198">**Şekil 5-6**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-198">**Figure 5-6**.</span></span> <span data-ttu-id="4ee94-199">Bir hareketi geri alma</span><span class="sxs-lookup"><span data-stu-id="4ee94-199">Rolling back a transaction</span></span>

<span data-ttu-id="4ee94-200">Önceki şekilde, *Stok güncelleştirme* işlemi Stok mikrohizmetinde başarısız oldu.</span><span class="sxs-lookup"><span data-stu-id="4ee94-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="4ee94-201">Destan, stok sayımlarını ayarlamak, ödemeyi ve siparişi iptal etmek ve her mikro hizmetiçin verileri tutarlı bir duruma döndürmek için bir dizi telafi hareketi (kırmızı) çağırır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="4ee94-202">Destan desenleri genellikle ilgili olaylar dizisi olarak koreografisi yapılır veya ilgili komutlar kümesi olarak düzenlenmiştir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="4ee94-203">Bölüm 4'te, planlı bir destan uygulamasının temelini oluşturabilecek hizmet toplayıcı modelini tartıştık.</span><span class="sxs-lookup"><span data-stu-id="4ee94-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="4ee94-204">Ayrıca, koreografisi yapılan bir destan uygulamasının temelini oluşturabilecek Azure Hizmet Veri Tos ve Azure Event Grid konularıyla birlikte etkinliği de tartıştık.</span><span class="sxs-lookup"><span data-stu-id="4ee94-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="4ee94-205">Yüksek hacimli veriler</span><span class="sxs-lookup"><span data-stu-id="4ee94-205">High volume data</span></span>

<span data-ttu-id="4ee94-206">Büyük bulut tabanlı uygulamalar genellikle yüksek hacimli veri gereksinimlerini destekler.</span><span class="sxs-lookup"><span data-stu-id="4ee94-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="4ee94-207">Bu senaryolarda, geleneksel veri depolama teknikleri darboğazlara neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="4ee94-208">Büyük ölçekte dağıtılan karmaşık sistemler için, hem Komut hem de Sorgu Sorumluluğu Ayrımı (CQRS) ve Olay Kaynağı uygulama performansını artırabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="4ee94-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="4ee94-209">CQRS</span></span>

<span data-ttu-id="4ee94-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), performans, ölçeklenebilirlik ve güvenliği en üst düzeye çıkarmaya yardımcı olabilecek mimari bir desendir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="4ee94-211">Desen, verileri okuyan işlemleri veri yazan işlemlerden ayırır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="4ee94-212">Normal senaryolar için, aynı varlık modeli ve veri deposu nesnesi hem okuma *hem de* yazma işlemleri için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="4ee94-213">Ancak, yüksek hacimli bir veri senaryosu okuma ve yazma için ayrı modeller ve veri tablolarından yararlanabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="4ee94-214">Performansı artırmak için, okuma işlemi pahalı yinelenen tablo birleştirmeleri ve tablo kilitleri önlemek için verilerin son derece denormalleştirilmiş gösterimi karşı sorgu olabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="4ee94-215">*Komut*olarak bilinen *yazma* işlemi, tutarlılığı garanti edecek verilerin tamamen normalleştirilmiş bir temsiline karşı güncellenir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="4ee94-216">Daha sonra her iki gösterimi eşit tutmak için bir mekanizma uygulamanız gerekir. Genellikle, yazma tablosu değiştirildiğinde, okuma tablosunda yapılan değişikliği çoğaltan bir olay yayımlar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="4ee94-217">Şekil 5-7 CQRS deseninin bir uygulamasını gösterir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![Komut ve Sorgu Sorumluluğu Ayrımı](./media/cqrs-implementation.png)

<span data-ttu-id="4ee94-219">**Şekil 5-7**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-219">**Figure 5-7**.</span></span> <span data-ttu-id="4ee94-220">CQRS uygulaması</span><span class="sxs-lookup"><span data-stu-id="4ee94-220">CQRS implementation</span></span>

<span data-ttu-id="4ee94-221">Önceki şekilde, ayrı komut ve sorgu modelleri uygulanır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="4ee94-222">Her veri yazma işlemi yazma deposuna kaydedilir ve daha sonra okuma deposuna yayılır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="4ee94-223">Veri yayma işleminin [nihai tutarlılık](http://www.cloudcomputingpatterns.org/eventual_consistency/)ilkesine göre nasıl işlediğine dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="4ee94-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="4ee94-224">Okuma modeli sonunda yazma modeli yle eşitlenir, ancak işlemde bazı gecikmeler olabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="4ee94-225">Bir sonraki bölümde nihai tutarlılığı tartışıyoruz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="4ee94-226">Bu ayrım okuma ve yazmanın bağımsız olarak ölçeklemesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="4ee94-227">Okuma işlemleri sorgular için en iyi duruma getirilmiş bir şema kullanırken, yazmalar güncelleştirmeler için en iyi duruma getirilmiş bir şema kullanır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="4ee94-228">Okuma sorguları normalize edilmiş verilere ters gider, karmaşık iş mantığı yazma modeline uygulanabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="4ee94-229">Yanı sıra, yazma işlemlerine, teşhir okumalardan daha sıkı güvenlik dayatabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="4ee94-230">CQRS uygulanması, bulut ait hizmetler için uygulama performansını artırabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="4ee94-231">Ancak, daha karmaşık bir tasarım alabın.</span><span class="sxs-lookup"><span data-stu-id="4ee94-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="4ee94-232">Bu ilkeyi bulut yerel uygulamanızın bundan yararlanacak bölümlerine dikkatli ve stratejik bir şekilde uygulayın.</span><span class="sxs-lookup"><span data-stu-id="4ee94-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="4ee94-233">CQRS hakkında daha fazla bilgi için Microsoft kitabı [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="4ee94-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="4ee94-234">Olay kaynak</span><span class="sxs-lookup"><span data-stu-id="4ee94-234">Event sourcing</span></span>

<span data-ttu-id="4ee94-235">Yüksek hacimli veri senaryolarını optimize etmek için başka bir yaklaşım [Olay Kaynak](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)içerir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="4ee94-236">Sistem genellikle bir veri varlığının geçerli durumunu depolar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="4ee94-237">Örneğin, bir kullanıcı telefon numarasını değiştirirse, müşteri kaydı yeni numarayla güncelleştirilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="4ee94-238">Bir veri varlığının geçerli durumunu her zaman biliriz, ancak her güncelleştirme önceki durumu yazar.</span><span class="sxs-lookup"><span data-stu-id="4ee94-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="4ee94-239">Çoğu durumda, bu model iyi çalışır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-239">In most cases, this model works fine.</span></span> <span data-ttu-id="4ee94-240">Ancak, yüksek hacimli sistemlerde, işlem kilitleme ve sık güncelleştirme işlemlerinden kaynaklanan ek yük veritabanı performansını, yanıt verme yeteneğini ve ölçeklenebilirliği sınırlayabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="4ee94-241">Olay Kaynak veri yakalama için farklı bir yaklaşım alır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="4ee94-242">Verileri etkileyen her işlem bir olay deposunda kalıcıdır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="4ee94-243">Bir veri kaydının durumunu güncelleştirmek yerine, her değişikliği bir muhasebecinin genel muhasebesine benzer şekilde geçmiş olayların sıralı listesine ekleriz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="4ee94-244">Olay Deposu, veriler için kayıt sistemi haline gelir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="4ee94-245">Bir mikro hizmetin sınırlı bağlamında çeşitli materyalize görünümleri yaymak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="4ee94-246">Şekil 5.8 deseni gösterir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-246">Figure 5.8 shows the pattern.</span></span>

![Olay Kaynağını Belirleme](./media/event-sourcing.png)

<span data-ttu-id="4ee94-248">**Şekil 5-8**.</span><span class="sxs-lookup"><span data-stu-id="4ee94-248">**Figure 5-8**.</span></span> <span data-ttu-id="4ee94-249">Olay Kaynağını Belirleme</span><span class="sxs-lookup"><span data-stu-id="4ee94-249">Event Sourcing</span></span>

<span data-ttu-id="4ee94-250">Önceki şekilde, bir kullanıcının alışveriş sepetine ait her girişin (mavi renkte) temel bir etkinlik deposuna nasıl eklenilen bir şekilde eklenilenlere dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="4ee94-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="4ee94-251">Bitişik maddeleştirilmiş görünümde, sistem her alışveriş sepetiyle ilişkili tüm olayları yeniden oynatarak geçerli durumu projeleri.</span><span class="sxs-lookup"><span data-stu-id="4ee94-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="4ee94-252">Bu görünüm veya okuma modeli, daha sonra geri UI maruz kalır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="4ee94-253">Olaylar, dış sistemler ve uygulamalarla da tümleştirilebilir veya bir varlığın geçerli durumunu belirlemek için sorgulanabilir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="4ee94-254">Bu yaklaşımla, tarihi korursunuz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-254">With this approach, you maintain history.</span></span> <span data-ttu-id="4ee94-255">Sadece bir varlığın durumunu değil, aynı zamanda bu duruma nasıl ulaştığınızı da biliyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="4ee94-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="4ee94-256">Mekanik olarak konuşursak, olay kaynak yazma modelini basitleştirir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="4ee94-257">Güncelleştirme veya silme yok.</span><span class="sxs-lookup"><span data-stu-id="4ee94-257">There are no updates or deletes.</span></span> <span data-ttu-id="4ee94-258">Her veri girişini değişmez bir olay olarak ekleyen, ilişkisel veritabanlarıyla ilişkili çekişme, kilitleme ve eşzamanlılık çakışmalarını en aza indirir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="4ee94-259">Materyalize görünüm deseni ile okuma modelleri oluşturma, görünümü yazma modelinden ayırmanızı ve uygulama kullanıcı larınızın gereksinimlerini en iyi duruma getirmek için en iyi veri deposunu seçmenize olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="4ee94-260">Bu desen için, olay kaynağını doğrudan destekleyen bir veri deposu düşünün.</span><span class="sxs-lookup"><span data-stu-id="4ee94-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="4ee94-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB ve RavenDB iyi adaylardır.</span><span class="sxs-lookup"><span data-stu-id="4ee94-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="4ee94-262">Tüm kalıpve teknolojilerde olduğu gibi, stratejik ve gerektiğinde uygulayın.</span><span class="sxs-lookup"><span data-stu-id="4ee94-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="4ee94-263">Olay kaynak artan performans ve ölçeklenebilirlik sağlayabilir iken, karmaşıklık ve bir öğrenme eğrisi pahasına gelir.</span><span class="sxs-lookup"><span data-stu-id="4ee94-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="4ee94-264">[Önceki](service-mesh-communication-infrastructure.md)
>[Sonraki](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="4ee94-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
