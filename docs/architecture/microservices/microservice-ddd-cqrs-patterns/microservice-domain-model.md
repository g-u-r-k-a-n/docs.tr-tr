---
title: Mikro hizmet etki alan modeli tasarlama
description: .NET Microservices Mimari Containerized .NET Uygulamaları için | DDD yönelimli etki alanı modeli tasarlarken temel kavramları anlayın.
ms.date: 01/30/2020
ms.openlocfilehash: 64860d75dca645904e973a4b8927a716a1603394
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988420"
---
# <a name="design-a-microservice-domain-model"></a><span data-ttu-id="b4a01-103">Microservice etki alanı modeli tasarla</span><span class="sxs-lookup"><span data-stu-id="b4a01-103">Design a microservice domain model</span></span>

<span data-ttu-id="b4a01-104">*Her iş microservice veya Sınırlı Bağlam için bir zengin etki alanı modeli tanımlayın.*</span><span class="sxs-lookup"><span data-stu-id="b4a01-104">*Define one rich domain model for each business microservice or Bounded Context.*</span></span>

<span data-ttu-id="b4a01-105">Amacınız, her iş microservice veya Bounded Context (BC) için tek bir uyumlu etki alanı modeli oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-105">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC).</span></span> <span data-ttu-id="b4a01-106">Ancak, bir BC veya iş microservice bazen tek bir etki alanı modeli paylaşan birkaç fiziksel hizmetlerden oluşabileceğini unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b4a01-106">Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model.</span></span> <span data-ttu-id="b4a01-107">Etki alanı modeli, temsil ettiği tek Sınırlı Bağlam'ın veya iş mikro hizmetinin kurallarını, davranışını, iş dilini ve kısıtlamalarını yakalamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-107">The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</span></span>

## <a name="the-domain-entity-pattern"></a><span data-ttu-id="b4a01-108">Etki Alanı Varlık deseni</span><span class="sxs-lookup"><span data-stu-id="b4a01-108">The Domain Entity pattern</span></span>

<span data-ttu-id="b4a01-109">Varlıklar etki alanı nesnelerini temsil eder ve öncelikle kimlikleri, süreklilikleri ve zaman içinde kalıcılıkları ile tanımlanırlar ve yalnızca onları oluşturan özniteliklerle değil.</span><span class="sxs-lookup"><span data-stu-id="b4a01-109">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them.</span></span> <span data-ttu-id="b4a01-110">Eric Evans'ın dediği gibi, "öncelikle kimliğiyle tanımlanan bir nesneye Varlık denir."</span><span class="sxs-lookup"><span data-stu-id="b4a01-110">As Eric Evans says, "an object primarily defined by its identity is called an Entity."</span></span> <span data-ttu-id="b4a01-111">Varlıklar etki alanı modelinde çok önemlidir, çünkü bir modelin temelini onlardır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-111">Entities are very important in the domain model, since they are the base for a model.</span></span> <span data-ttu-id="b4a01-112">Bu nedenle, bunları dikkatle tanımlamalı ve tasarlamanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-112">Therefore, you should identify and design them carefully.</span></span>

<span data-ttu-id="b4a01-113">*Bir varlığın kimliği birden çok mikro hizmeti veya Sınırlı Bağlamları geçebilir.*</span><span class="sxs-lookup"><span data-stu-id="b4a01-113">*An entity's identity can cross multiple microservices or Bounded Contexts.*</span></span>

<span data-ttu-id="b4a01-114">Aynı kimlik (yani aynı `Id` değer, belki aynı etki alanı varlığı olmasa da) birden çok Bağlı Bağlamveya mikro hizmetler arasında modellenebilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-114">The same identity (that is, the same `Id` value, although perhaps not the same domain entity) can be modeled across multiple Bounded Contexts or microservices.</span></span> <span data-ttu-id="b4a01-115">Ancak, bu aynı varlık, aynı öznitelikleri ve mantığı ile birden çok Bağlı Bağlamlarda uygulanacağı anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="b4a01-115">However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts.</span></span> <span data-ttu-id="b4a01-116">Bunun yerine, her Bağlı Bağlam'daki varlıklar özniteliklerini ve davranışlarını bu Bağlı Bağlam'ın etki alanında gerekli olanlarla sınırlandırın.</span><span class="sxs-lookup"><span data-stu-id="b4a01-116">Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context's domain.</span></span>

<span data-ttu-id="b4a01-117">Örneğin, alıcı varlık, kimlik de dahil olmak üzere profil veya kimlik mikrohizmetinde kullanıcı varlığında tanımlanan bir kişinin özniteliklerinin çoğuna sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-117">For instance, the buyer entity might have most of a person's attributes that are defined in the user entity in the profile or identity microservice, including the identity.</span></span> <span data-ttu-id="b4a01-118">Ancak, yalnızca belirli alıcı verileri sipariş işlemiyle ilgili olduğundan, sipariş mikrohizmetindeki alıcı varlığı daha az özniteliklere sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-118">But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process.</span></span> <span data-ttu-id="b4a01-119">Her microservice veya Bounded Context bağlamı etki alanı modelini etkiler.</span><span class="sxs-lookup"><span data-stu-id="b4a01-119">The context of each microservice or Bounded Context impacts its domain model.</span></span>

<span data-ttu-id="b4a01-120">*Etki alanı varlıkları, veri özniteliklerini uygulamaya ek olarak davranışı uygulamalıdır.*</span><span class="sxs-lookup"><span data-stu-id="b4a01-120">*Domain entities must implement behavior in addition to implementing data attributes.*</span></span>

<span data-ttu-id="b4a01-121">DDD'deki bir etki alanı varlığı, varlık verileriyle (bellekte erişilen nesne) etki alanı mantığını veya davranışını uygulamalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-121">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory).</span></span> <span data-ttu-id="b4a01-122">Örneğin, bir sipariş varlık sınıfının bir parçası olarak, sipariş öğesi, veri doğrulaması ve toplam hesaplama ekleme gibi görevler için yöntem olarak uygulanan iş mantığı ve işlemleri olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-122">For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation.</span></span> <span data-ttu-id="b4a01-123">Varlığın yöntemleri, bu kuralların uygulama katmanına yayılması yerine varlığın değişmezleri ve kurallarıyla ilgilenir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-123">The entity's methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</span></span>

<span data-ttu-id="b4a01-124">Şekil 7-8, yalnızca veri özniteliklerini değil, ilgili etki alanı mantığına sahip işlemleri veya yöntemleri uygulayan bir etki alanı varlığını gösterir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-124">Figure 7-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</span></span>

![Etki Alanı Varlığı deseni gösteren diyagram.](./media/microservice-domain-model/domain-entity-pattern.png)

<span data-ttu-id="b4a01-126">**Şekil 7-8**.</span><span class="sxs-lookup"><span data-stu-id="b4a01-126">**Figure 7-8**.</span></span> <span data-ttu-id="b4a01-127">Veri artı davranışı uygulayan bir etki alanı varlık tasarımı örneği</span><span class="sxs-lookup"><span data-stu-id="b4a01-127">Example of a domain entity design implementing data plus behavior</span></span>

<span data-ttu-id="b4a01-128">Etki alanı modeli varlık yöntemleri ile davranışları uygular, yani bir "anemik" model değil.</span><span class="sxs-lookup"><span data-stu-id="b4a01-128">A domain model entity implements behaviors through methods, that is, it's not an "anemic" model.</span></span> <span data-ttu-id="b4a01-129">Tabii ki, bazen varlık sınıfının bir parçası olarak herhangi bir mantık uygulamayan varlıklar olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-129">Of course, sometimes you can have entities that do not implement any logic as part of the entity class.</span></span> <span data-ttu-id="b4a01-130">Mantığın çoğu toplam kökünde tanımlandığı için, alt varlığın özel bir mantığı yoksa, bu durum bir toplam içindeki alt varlıklarda gerçekleşebilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-130">This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root.</span></span> <span data-ttu-id="b4a01-131">Etki alanı varlıkları yerine hizmet sınıflarında uygulanan çok fazla mantığa sahip karmaşık bir mikro hizmetiniz varsa, aşağıdaki bölümde açıklanan anemik etki alanı modeline düşebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4a01-131">If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</span></span>

### <a name="rich-domain-model-versus-anemic-domain-model"></a><span data-ttu-id="b4a01-132">Anemik etki alanı modeline karşı zengin etki alanı modeli</span><span class="sxs-lookup"><span data-stu-id="b4a01-132">Rich domain model versus anemic domain model</span></span>

<span data-ttu-id="b4a01-133">Onun sonrası [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html)olarak, Martin Fowler bu şekilde bir anemik etki alanı modeli açıklar:</span><span class="sxs-lookup"><span data-stu-id="b4a01-133">In his post [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html), Martin Fowler describes an anemic domain model this way:</span></span>

<span data-ttu-id="b4a01-134">Bir Anemik Etki Alanı Modeli temel belirtisi ilk allık gerçek bir şey gibi görünüyor olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-134">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing.</span></span> <span data-ttu-id="b4a01-135">Birçok nesne, etki alanı içinde isimler sonra adlandırılmış ve bu nesnelerin zengin ilişkiler ve gerçek etki alanı modelleri sahip yapısı ile bağlı.</span><span class="sxs-lookup"><span data-stu-id="b4a01-135">There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have.</span></span> <span data-ttu-id="b4a01-136">Bu davranışa baktığınızda, ve bu nesnelerde neredeyse hiç davranış olmadığını fark ettiğinizde, onları buli ve ayarlayıcı torbalarından biraz daha fazlası haline getirirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4a01-136">The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</span></span>

<span data-ttu-id="b4a01-137">Tabii ki, bir anemik etki alanı modeli kullandığınızda, bu veri modelleri tüm etki alanı veya iş mantığı yakalamak hizmet nesneleri kümesi (geleneksel olarak adlandırılan *iş katmanı)* kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-137">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the *business layer*) which capture all the domain or business logic.</span></span> <span data-ttu-id="b4a01-138">İş katmanı veri modelinin üstüne oturur ve veri modelini veri gibi kullanır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-138">The business layer sits on top of the data model and uses the data model just as data.</span></span>

<span data-ttu-id="b4a01-139">Anemik etki alanı modeli sadece bir prosedür tarzı tasarımdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-139">The anemic domain model is just a procedural style design.</span></span> <span data-ttu-id="b4a01-140">Anemik varlık nesneleri, davranış (yöntem) eksikliği nden dolayı gerçek nesneler değildir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-140">Anemic entity objects are not real objects because they lack behavior (methods).</span></span> <span data-ttu-id="b4a01-141">Bunlar yalnızca veri özelliklerine sahiptir ve bu nedenle nesne yönelimli tasarım değildir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-141">They only hold data properties and thus it is not object-oriented design.</span></span> <span data-ttu-id="b4a01-142">Tüm davranışları hizmet nesnelerine (iş katmanına) koyarak aslında [spagetti kodu](https://en.wikipedia.org/wiki/Spaghetti_code) veya [işlem komut dosyalarıyla](https://martinfowler.com/eaaCatalog/transactionScript.html)sonuçlanır ve bu nedenle etki alanı modelinin sağladığı avantajları kaybedersiniz.</span><span class="sxs-lookup"><span data-stu-id="b4a01-142">By putting all the behavior out into service objects (the business layer) you essentially end up with [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) or [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), and therefore you lose the advantages that a domain model provides.</span></span>

<span data-ttu-id="b4a01-143">Ne olursa olsun, microservice veya Bounded Context çok basit (CRUD hizmeti), sadece veri özellikleri ile varlık nesneleri şeklinde anemik etki alanı modeli yeterince iyi olabilir ve daha karmaşık DDD desenleri uygulamaya değer olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-143">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns.</span></span> <span data-ttu-id="b4a01-144">Bu durumda, kasıtlı olarak CRUD amaçları için yalnızca veri içeren bir varlık oluşturduğunuziçin, bu yalnızca bir kalıcılık modeli olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-144">In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</span></span>

<span data-ttu-id="b4a01-145">Bu nedenle mikrohizmet mimarileri, her Sınırlı İçerime bağlı olarak çok mimari bir yaklaşım için mükemmeldir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-145">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context.</span></span> <span data-ttu-id="b4a01-146">Örneğin, eShopOnContainers, sipariş microservice DDD desenleri uygular, ancak basit bir CRUD hizmeti olan katalog microservice, değil.</span><span class="sxs-lookup"><span data-stu-id="b4a01-146">For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</span></span>

<span data-ttu-id="b4a01-147">Bazı insanlar anemik etki alanı modeli bir anti-desen olduğunu söylüyorlar.</span><span class="sxs-lookup"><span data-stu-id="b4a01-147">Some people say that the anemic domain model is an anti-pattern.</span></span> <span data-ttu-id="b4a01-148">Gerçekten ne uyguladığınıza bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-148">It really depends on what you are implementing.</span></span> <span data-ttu-id="b4a01-149">Oluşturduğunuz microservice yeterince basit ise (örneğin, bir CRUD hizmeti), anemik etki alanı modelini takip bir anti-desen değildir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-149">If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern.</span></span> <span data-ttu-id="b4a01-150">Ancak, sürekli değişen iş kuralları bir yeri olan bir microservice etki alanı karmaşıklığı mücadele etmek gerekiyorsa, anemik etki alanı modeli bu microservice veya Bounded Context için bir anti-desen olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-150">However, if you need to tackle the complexity of a microservice's domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context.</span></span> <span data-ttu-id="b4a01-151">Bu durumda, veri artı davranış içeren varlıklar ile zengin bir model olarak tasarlanması yanı sıra ek DDD desenleri (agregalar, değer nesneleri, vb) uygulanması gibi bir mikrohizmetin uzun vadeli başarısı için büyük faydalar olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-151">In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b4a01-152">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b4a01-152">Additional resources</span></span>

- <span data-ttu-id="b4a01-153">**DevIQ mı? Etki Alanı Varlığı** </span><span class="sxs-lookup"><span data-stu-id="b4a01-153">**DevIQ. Domain Entity** </span></span>\
  <https://deviq.com/entity/>

- <span data-ttu-id="b4a01-154">**Martin Fowler' ı. Etki Alanı Modeli** </span><span class="sxs-lookup"><span data-stu-id="b4a01-154">**Martin Fowler. The Domain Model** </span></span>\
  <https://martinfowler.com/eaaCatalog/domainModel.html>

- <span data-ttu-id="b4a01-155">**Martin Fowler' ı. Anemik Etki Alanı Modeli** </span><span class="sxs-lookup"><span data-stu-id="b4a01-155">**Martin Fowler. The Anemic Domain Model** </span></span>\
  <https://martinfowler.com/bliki/AnemicDomainModel.html>

### <a name="the-value-object-pattern"></a><span data-ttu-id="b4a01-156">Değer Nesnesi deseni</span><span class="sxs-lookup"><span data-stu-id="b4a01-156">The Value Object pattern</span></span>

<span data-ttu-id="b4a01-157">Eric Evans'ın belirttiği gibi, "Birçok nesne kavramsal bir kimliğe sahip değildir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-157">As Eric Evans has noted, "Many objects do not have conceptual identity.</span></span> <span data-ttu-id="b4a01-158">Bu nesneler bir şeyin belirli özelliklerini tanımlar."</span><span class="sxs-lookup"><span data-stu-id="b4a01-158">These objects describe certain characteristics of a thing."</span></span>

<span data-ttu-id="b4a01-159">Bir varlık bir kimlik gerektirir, ancak değer nesnesi deseni gibi bir sistemde olmayan birçok nesne vardır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-159">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern.</span></span> <span data-ttu-id="b4a01-160">Değer nesnesi, etki alanı yönünü açıklayan kavramsal kimliği olmayan bir nesnedir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-160">A value object is an object with no conceptual identity that describes a domain aspect.</span></span> <span data-ttu-id="b4a01-161">Bunlar, yalnızca sizi geçici olarak ilgilendiren tasarım öğelerini temsil etmek için anlık olarak yaptığınız nesnelerdir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-161">These are objects that you instantiate to represent design elements that only concern you temporarily.</span></span> <span data-ttu-id="b4a01-162">*Ne* olduklarını önemsiyorsun, *kim* olduklarını değil.</span><span class="sxs-lookup"><span data-stu-id="b4a01-162">You care about *what* they are, not *who* they are.</span></span> <span data-ttu-id="b4a01-163">Örnekler sayılar ve dizeleri içerir, ancak öznitelik grupları gibi üst düzey kavramlar da olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-163">Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</span></span>

<span data-ttu-id="b4a01-164">Bir mikro hizmetteki bir varlık başka bir microservice'teki bir varlık olmayabilir, çünkü ikinci durumda, Bağlı Bağlam farklı bir anlama sahip olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-164">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning.</span></span> <span data-ttu-id="b4a01-165">Örneğin, bir e-ticaret uygulamasındaki bir adresin kimliği hiç olmayabilir, çünkü yalnızca bir kişi veya şirket için müşterinin profilinin öznitelikleri grubunu temsil edebilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-165">For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer's profile for a person or company.</span></span> <span data-ttu-id="b4a01-166">Bu durumda, adres bir değer nesnesi olarak sınıflandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-166">In this case, the address should be classified as a value object.</span></span> <span data-ttu-id="b4a01-167">Ancak, bir elektrik elektrik şirketi için bir uygulamada, müşteri adresi iş etki alanı için önemli olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-167">However, in an application for an electric power utility company, the customer address could be important for the business domain.</span></span> <span data-ttu-id="b4a01-168">Bu nedenle, faturalandırma sisteminin doğrudan adrese bağlanabilmesi için adresin bir kimliği olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-168">Therefore, the address must have an identity so the billing system can be directly linked to the address.</span></span> <span data-ttu-id="b4a01-169">Bu durumda, bir adres etki alanı varlığı olarak sınıflandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-169">In that case, an address should be classified as a domain entity.</span></span>

<span data-ttu-id="b4a01-170">Ad ve soyad taşıyan bir kişi, ad ve soyad başka bir değer kümesiyle çakışsa bile, bu ad ve soyadı farklı bir kişi için de atıfta bulunuyorsa, bir kişinin kimliği olduğundan genellikle bir varlıktır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-170">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</span></span>

<span data-ttu-id="b4a01-171">Değer nesnelerinin varlık çerçevesi (EF) gibi ilişkisel veritabanlarında ve ORM'larda yönetilmesi zorken, belge yönelimli veritabanlarında uygulanması ve kullanılması daha kolaydır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-171">Value objects are hard to manage in relational databases and ORMs like Entity Framework (EF), whereas in document-oriented databases they are easier to implement and use.</span></span>

<span data-ttu-id="b4a01-172">EF Core 2.0 ve sonraki sürümler, daha sonra ayrıntılı olarak göreceğimiz gibi değer nesnelerinin işlemesini kolaylaştıran [Sahip olunan Varlıklar](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) özelliğini içerir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-172">EF Core 2.0 and later versions include the [Owned Entities](https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-2-0/#owned-entities-and-table-splitting) feature that makes it easier to handle value objects, as we’ll see in detail later on.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b4a01-173">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b4a01-173">Additional resources</span></span>

- <span data-ttu-id="b4a01-174">**Martin Fowler' ı. Değer Nesnesi deseni** </span><span class="sxs-lookup"><span data-stu-id="b4a01-174">**Martin Fowler. Value Object pattern** </span></span>\
  <https://martinfowler.com/bliki/ValueObject.html>

- <span data-ttu-id="b4a01-175">**Değer Nesnesi** </span><span class="sxs-lookup"><span data-stu-id="b4a01-175">**Value Object** </span></span>\
  <https://deviq.com/value-object/>

- <span data-ttu-id="b4a01-176">**Test Odaklı Geliştirmede Değer Nesneleri** </span><span class="sxs-lookup"><span data-stu-id="b4a01-176">**Value Objects in Test-Driven Development** </span></span>\
  [https://leanpub.com/tdd-ebook/read\#leanpub-auto-value-objects](https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects)

- <span data-ttu-id="b4a01-177">**Eric Evans' ı. Etki Alanı Odaklı Tasarım: Yazılımın Kalbinde Karmaşıklıkla Mücadele.**</span><span class="sxs-lookup"><span data-stu-id="b4a01-177">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="b4a01-178">(Kitap; değer nesnelerinin bir tartışma içerir) </span><span class="sxs-lookup"><span data-stu-id="b4a01-178">(Book; includes a discussion of value objects) </span></span>\
  <https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/>

### <a name="the-aggregate-pattern"></a><span data-ttu-id="b4a01-179">Agrega deseni</span><span class="sxs-lookup"><span data-stu-id="b4a01-179">The Aggregate pattern</span></span>

<span data-ttu-id="b4a01-180">Etki alanı modeli, sipariş yerine getirme veya envanter gibi önemli bir işlevsellik alanını denetlenebilen farklı veri varlıkları ve işlem kümeleri içerir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-180">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfillment or inventory.</span></span> <span data-ttu-id="b4a01-181">Daha ince taneli DDD birimi, bir kümeyi veya karma birim olarak kabul edilebilen varlık ve davranış grubunu açıklayan toplamdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-181">A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</span></span>

<span data-ttu-id="b4a01-182">Genellikle gereksinim duyduğunuz hareketleri temel alan bir toplam tanımlarsınız.</span><span class="sxs-lookup"><span data-stu-id="b4a01-182">You usually define an aggregate based on the transactions that you need.</span></span> <span data-ttu-id="b4a01-183">Klasik bir örnek, sipariş öğelerinin listesini de içeren bir sipariştir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-183">A classic example is an order that also contains a list of order items.</span></span> <span data-ttu-id="b4a01-184">Bir sipariş öğesi genellikle bir varlık olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-184">An order item will usually be an entity.</span></span> <span data-ttu-id="b4a01-185">Ancak, genellikle toplu kök olarak adlandırılan, kök varlığı olarak sipariş varlığını da içerecek olan sipariş toplamı içinde bir alt varlık olacaktır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-185">But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</span></span>

<span data-ttu-id="b4a01-186">Agregaları tanımlamak zor olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-186">Identifying aggregates can be hard.</span></span> <span data-ttu-id="b4a01-187">Toplam, birlikte tutarlı olması gereken bir nesne grubudur, ancak bir nesne grubunu seçip bunları bir toplu olarak etiketleyemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4a01-187">An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate.</span></span> <span data-ttu-id="b4a01-188">Bir etki alanı kavramıyla başlamalı ve bu kavramla ilgili en yaygın işlemlerde kullanılan varlıkları düşünmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="b4a01-188">You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept.</span></span> <span data-ttu-id="b4a01-189">İşlemsel olarak tutarlı olması gereken varlıklar, bir toplamı oluşturan varlıklardır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-189">Those entities that need to be transactionally consistent are what forms an aggregate.</span></span> <span data-ttu-id="b4a01-190">İşlem işlemleri hakkında düşünme, muhtemelen toplamları tanımlamanın en iyi yoludur.</span><span class="sxs-lookup"><span data-stu-id="b4a01-190">Thinking about transaction operations is probably the best way to identify aggregates.</span></span>

### <a name="the-aggregate-root-or-root-entity-pattern"></a><span data-ttu-id="b4a01-191">Toplam Kök veya Kök Varlık deseni</span><span class="sxs-lookup"><span data-stu-id="b4a01-191">The Aggregate Root or Root Entity pattern</span></span>

<span data-ttu-id="b4a01-192">Bir toplam en az bir varlıktan oluşur: kök varlık veya birincil varlık olarak da adlandırılan toplam kök.</span><span class="sxs-lookup"><span data-stu-id="b4a01-192">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity.</span></span> <span data-ttu-id="b4a01-193">Ayrıca, gerekli davranış ve hareketleri uygulamak için tüm varlıklar ve nesneler birlikte çalışan birden çok alt varlıklar ve değer nesneleri olabilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-193">Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</span></span>

<span data-ttu-id="b4a01-194">Bir toplam kökün amacı, agreganın tutarlılığını sağlamaktır; bu toplam kök sınıfında yöntemler veya işlemler yoluyla toplam güncelleştirmeleri için tek giriş noktası olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-194">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class.</span></span> <span data-ttu-id="b4a01-195">Yalnızca toplam kökü üzerinden toplam içindeki varlıklarda değişiklik yapmalısınız.</span><span class="sxs-lookup"><span data-stu-id="b4a01-195">You should make changes to entities within the aggregate only via the aggregate root.</span></span> <span data-ttu-id="b4a01-196">Toplu olarak uymanız gerekebilecek tüm değişmezleri ve tutarlılık kurallarını göz önünde bulundurarak, toplamın tutarlılık koruyucusudur.</span><span class="sxs-lookup"><span data-stu-id="b4a01-196">It is the aggregate's consistency guardian, considering all the invariants and consistency rules you might need to comply with in your aggregate.</span></span> <span data-ttu-id="b4a01-197">Bir alt varlığı veya değer nesnesini bağımsız olarak değiştirirseniz, toplam kök, toplamın geçerli bir durumda olduğundan emin olamaz.</span><span class="sxs-lookup"><span data-stu-id="b4a01-197">If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state.</span></span> <span data-ttu-id="b4a01-198">Gevşek bacaklı bir masa gibi olurdu.</span><span class="sxs-lookup"><span data-stu-id="b4a01-198">It would be like a table with a loose leg.</span></span> <span data-ttu-id="b4a01-199">Tutarlılığı korumak, toplam kökün temel amacıdır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-199">Maintaining consistency is the main purpose of the aggregate root.</span></span>

<span data-ttu-id="b4a01-200">Şekil 7-9'da, tek bir varlık (toplam kök Alıcı) içeren alıcı toplamı gibi örnek agregaları görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b4a01-200">In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer).</span></span> <span data-ttu-id="b4a01-201">Sipariş toplamı birden çok varlık ve bir değer nesnesi içerir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-201">The order aggregate contains multiple entities and a value object.</span></span>

![Alıcı toplamı ve sipariş toplamına karşılaştırıldığında diyagram.](./media/microservice-domain-model/buyer-order-aggregate-pattern.png)

<span data-ttu-id="b4a01-203">**Şekil 7-9**.</span><span class="sxs-lookup"><span data-stu-id="b4a01-203">**Figure 7-9**.</span></span> <span data-ttu-id="b4a01-204">Birden fazla veya tek tüzel kişilikli agrega örneği</span><span class="sxs-lookup"><span data-stu-id="b4a01-204">Example of aggregates with multiple or single entities</span></span>

<span data-ttu-id="b4a01-205">Bir DDD etki alanı modeli agregalardan oluşur, bir agrega yalnızca bir varlık veya daha fazla olabilir ve değer nesneleri de içerebilir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-205">A DDD domain model is composed from aggregates, an aggregate can have just one entity or more, and can include value objects as well.</span></span> <span data-ttu-id="b4a01-206">EShopOnContainers başvuru uygulamasında sipariş mikroservice yaptığı gibi Alıcı toplu, etki alanıbağlı olarak ek alt varlıklar olabilir unutmayın.</span><span class="sxs-lookup"><span data-stu-id="b4a01-206">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application.</span></span> <span data-ttu-id="b4a01-207">Şekil 7-9 yalnızca toplam kök içeren bir toplam örneği olarak, alıcının tek bir varlığa sahip olduğu bir durumu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-207">Figure 7-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</span></span>

<span data-ttu-id="b4a01-208">Agregaların ayrılığını korumak ve aralarındaki sınırları korumak için, ddd etki alanı modelinde, agregalar arasında doğrudan gezinmeye izin vermemek ve eShopOnContainers'daki [Sipariş mikrohizmet etki alanı modelinde](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) uygulandığı gibi yalnızca yabancı anahtar (FK) alanına sahip olmak iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="b4a01-208">In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the [Ordering microservice domain model](https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs) in eShopOnContainers.</span></span> <span data-ttu-id="b4a01-209">Sipariş varlığı yalnızca alıcı için bir FK alanına sahiptir, ancak aşağıdaki kodda gösterildiği gibi bir EF Core navigasyon özelliği ne değildir:</span><span class="sxs-lookup"><span data-stu-id="b4a01-209">The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code:</span></span>

```csharp
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId; //FK pointing to a different aggregate root
    public OrderStatus OrderStatus { get; private set; }
    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;
    // ... Additional code
}
```

<span data-ttu-id="b4a01-210">Agregaların tanımlanması ve çalışılması araştırma ve deneyim gerektirir.</span><span class="sxs-lookup"><span data-stu-id="b4a01-210">Identifying and working with aggregates requires research and experience.</span></span> <span data-ttu-id="b4a01-211">Daha fazla bilgi için aşağıdaki Ek kaynaklar listesine bakın.</span><span class="sxs-lookup"><span data-stu-id="b4a01-211">For more information, see the following Additional resources list.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="b4a01-212">Ek kaynaklar</span><span class="sxs-lookup"><span data-stu-id="b4a01-212">Additional resources</span></span>

- <span data-ttu-id="b4a01-213">**Vaughn Vernon' u. Etkili Agrega Tasarımı - Bölüm I: Tek Bir Agreganın Modelleilmesi** (from) <http://dddcommunity.org/></span><span class="sxs-lookup"><span data-stu-id="b4a01-213">**Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf>

- <span data-ttu-id="b4a01-214">**Vaughn Vernon' u. Etkili Agrega Tasarımı - Bölüm II: Agregaların Birlikte Çalışmasını Sağlama** (from) <http://dddcommunity.org/></span><span class="sxs-lookup"><span data-stu-id="b4a01-214">**Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf>

- <span data-ttu-id="b4a01-215">**Vaughn Vernon' u. Etkili Toplam Tasarım - Bölüm III: Discovery through Insight Kazanma** (dan) <http://dddcommunity.org/></span><span class="sxs-lookup"><span data-stu-id="b4a01-215">**Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery** (from <http://dddcommunity.org/>) </span></span>\
  <http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf>

- <span data-ttu-id="b4a01-216">**Sergey Grybniak. DDD Taktik Tasarım Desenleri** </span><span class="sxs-lookup"><span data-stu-id="b4a01-216">**Sergey Grybniak. DDD Tactical Design Patterns** </span></span>\
  <https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part>

- <span data-ttu-id="b4a01-217">**Chris Richardson' ı. Agregaları Kullanarak İşlemsel Mikro Hizmetler Geliştirme** </span><span class="sxs-lookup"><span data-stu-id="b4a01-217">**Chris Richardson. Developing Transactional Microservices Using Aggregates** </span></span>\
  <https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson>

- <span data-ttu-id="b4a01-218">**DevIQ mı? Agrega deseni** </span><span class="sxs-lookup"><span data-stu-id="b4a01-218">**DevIQ. The Aggregate pattern** </span></span>\
  <https://deviq.com/aggregate-pattern/>

>[!div class="step-by-step"]
><span data-ttu-id="b4a01-219">[Önceki](ddd-oriented-microservice.md)
>[Sonraki](net-core-microservice-domain-model.md)</span><span class="sxs-lookup"><span data-stu-id="b4a01-219">[Previous](ddd-oriented-microservice.md)
[Next](net-core-microservice-domain-model.md)</span></span>
